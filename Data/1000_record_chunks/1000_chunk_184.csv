record_number,buggy_code,fixed_code,code_similarity
183001,"void prepareTracking(int y){
  mTracking=true;
  mVelocityTracker=VelocityTracker.obtain();
  boolean opening=!mExpanded;
  if (!mExpanded) {
    mAnimAccel=2000.0f;
    mAnimVel=200;
    mAnimY=mStatusBarView.getHeight();
    updateExpandedViewPos((int)mAnimY);
    mAnimating=true;
    mAnimatingReveal=true;
    mHandler.removeMessages(MSG_ANIMATE);
    mHandler.removeMessages(MSG_ANIMATE_REVEAL);
    long now=SystemClock.uptimeMillis();
    mAnimLastTime=now;
    mCurAnimationTime=now + ANIM_FRAME_DURATION;
    mAnimating=true;
    mHandler.sendMessageAtTime(mHandler.obtainMessage(MSG_ANIMATE_REVEAL),mCurAnimationTime);
  }
 else {
    if (mAnimating) {
      mAnimating=false;
      mHandler.removeMessages(MSG_ANIMATE);
    }
  }
  if (opening) {
    makeExpandedVisible();
  }
 else {
    updateExpandedViewPos(y + mViewDelta);
  }
}","void prepareTracking(int y){
  mTracking=true;
  mVelocityTracker=VelocityTracker.obtain();
  boolean opening=!mExpanded;
  if (opening) {
    mAnimAccel=2000.0f;
    mAnimVel=200;
    mAnimY=mStatusBarView.getHeight();
    updateExpandedViewPos((int)mAnimY);
    mAnimating=true;
    mAnimatingReveal=true;
    mHandler.removeMessages(MSG_ANIMATE);
    mHandler.removeMessages(MSG_ANIMATE_REVEAL);
    long now=SystemClock.uptimeMillis();
    mAnimLastTime=now;
    mCurAnimationTime=now + ANIM_FRAME_DURATION;
    mAnimating=true;
    mHandler.sendMessageAtTime(mHandler.obtainMessage(MSG_ANIMATE_REVEAL),mCurAnimationTime);
    makeExpandedVisible();
  }
 else {
    if (mAnimating) {
      mAnimating=false;
      mHandler.removeMessages(MSG_ANIMATE);
    }
    updateExpandedViewPos(y + mViewDelta);
  }
}",0.9371980676328504
183002,"void animateCollapse(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpanded + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible) {
    return;
  }
  prepareTracking(mDisplay.getHeight() - 1);
  performFling(mDisplay.getHeight() - 1,-2000.0f,true);
}","void animateCollapse(){
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + mExpanded + ""String_Node_Str""+ mExpandedVisible+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ mAnimVel);
  }
  if (!mExpandedVisible) {
    return;
  }
  if (mAnimating) {
    return;
  }
  int y=mDisplay.getHeight() - 1;
  prepareTracking(y);
  performFling(y,-2000.0f,true);
}",0.6957928802588996
183003,"@Override public boolean dispatchKeyEvent(KeyEvent event){
  boolean down=event.getAction() == KeyEvent.ACTION_DOWN;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_BACK:
    if (down) {
      StatusBarService.this.deactivate();
    }
  return true;
}
return super.dispatchKeyEvent(event);
}","@Override public boolean dispatchKeyEvent(KeyEvent event){
  boolean down=event.getAction() == KeyEvent.ACTION_DOWN;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_BACK:
    if (!down) {
      StatusBarService.this.deactivate();
    }
  return true;
}
return super.dispatchKeyEvent(event);
}",0.9983079526226736
183004,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}",0.9894709809964048
183005,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}",0.6966773847802786
183006,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}",0.7710011507479861
183007,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}",0.9988239905919248
183008,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}",0.8691006233303651
183009,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9546271338724168
183010,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}",0.9939223936418888
183011,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  int hintWant=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWidth=mHintLayout == null ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else   if ((mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight())) {
    if (mHint == null && mEllipsize == null && want > mLayout.getWidth() && (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want))) {
      mLayout.increaseWidthTo(want);
    }
 else {
      makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
    }
  }
 else {
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,height);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  int hintWant=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWidth=mHintLayout == null ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else   if ((mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight())) {
    if (mHint == null && mEllipsize == null && want > mLayout.getWidth() && (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want))) {
      mLayout.increaseWidthTo(want);
    }
 else {
      makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
    }
  }
 else {
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}",0.9995067817509248
183012,"void setTargetLocked(int target,int stepsToTarget,int initialValue,int nominalCurrentValue){
  if (!initialized) {
    initialized=true;
    curValue=(float)initialValue;
  }
  targetValue=target;
  delta=(targetValue - (nominalCurrentValue >= 0 ? nominalCurrentValue : curValue)) / stepsToTarget;
  if (mSpew) {
    String noticeMe=nominalCurrentValue == curValue ? ""String_Node_Str"" : ""String_Node_Str"";
    Log.i(TAG,""String_Node_Str"" + mask + ""String_Node_Str""+ curValue+ ""String_Node_Str""+ targetValue+ ""String_Node_Str""+ delta+ ""String_Node_Str""+ nominalCurrentValue+ noticeMe);
  }
  animating=true;
}","boolean setTargetLocked(int target,int stepsToTarget,int initialValue,int nominalCurrentValue){
  if (!initialized) {
    initialized=true;
    curValue=(float)initialValue;
  }
 else   if (targetValue == target) {
    return false;
  }
  targetValue=target;
  delta=(targetValue - (nominalCurrentValue >= 0 ? nominalCurrentValue : curValue)) / stepsToTarget;
  if (mSpew) {
    String noticeMe=nominalCurrentValue == curValue ? ""String_Node_Str"" : ""String_Node_Str"";
    Log.i(TAG,""String_Node_Str"" + mask + ""String_Node_Str""+ curValue+ ""String_Node_Str""+ targetValue+ ""String_Node_Str""+ delta+ ""String_Node_Str""+ nominalCurrentValue+ noticeMe);
  }
  animating=true;
  return true;
}",0.934261407579273
183013,"private void updateLightsLocked(int newState,int forceState){
  final int oldState=mPowerState;
  final int realDifference=(newState ^ oldState);
  final int difference=realDifference | forceState;
  if (difference == 0) {
    return;
  }
  int offMask=0;
  int dimMask=0;
  int onMask=0;
  int preferredBrightness=getPreferredBrightness();
  boolean startAnimation=false;
  if ((difference & KEYBOARD_BRIGHT_BIT) != 0) {
    if (ANIMATE_KEYBOARD_LIGHTS) {
      if ((newState & KEYBOARD_BRIGHT_BIT) == 0) {
        mKeyboardBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,ANIM_STEPS,INITIAL_KEYBOARD_BRIGHTNESS,preferredBrightness);
      }
 else {
        mKeyboardBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_KEYBOARD_BRIGHTNESS,Power.BRIGHTNESS_OFF);
      }
      startAnimation=true;
    }
 else {
      if ((newState & KEYBOARD_BRIGHT_BIT) == 0) {
        offMask|=KEYBOARD_BRIGHT_BIT;
      }
 else {
        onMask|=KEYBOARD_BRIGHT_BIT;
      }
    }
  }
  if ((difference & BUTTON_BRIGHT_BIT) != 0) {
    if (ANIMATE_BUTTON_LIGHTS) {
      if ((newState & BUTTON_BRIGHT_BIT) == 0) {
        mButtonBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,ANIM_STEPS,INITIAL_BUTTON_BRIGHTNESS,preferredBrightness);
      }
 else {
        mButtonBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_BUTTON_BRIGHTNESS,Power.BRIGHTNESS_OFF);
      }
      startAnimation=true;
    }
 else {
      if ((newState & BUTTON_BRIGHT_BIT) == 0) {
        offMask|=BUTTON_BRIGHT_BIT;
      }
 else {
        onMask|=BUTTON_BRIGHT_BIT;
      }
    }
  }
  if ((difference & (SCREEN_ON_BIT | SCREEN_BRIGHT_BIT)) != 0) {
    if (ANIMATE_SCREEN_LIGHTS) {
      int nominalCurrentValue=-1;
      if ((realDifference & (SCREEN_ON_BIT | SCREEN_BRIGHT_BIT)) != 0) {
switch (oldState & (SCREEN_BRIGHT_BIT | SCREEN_ON_BIT)) {
case SCREEN_BRIGHT_BIT | SCREEN_ON_BIT:
          nominalCurrentValue=preferredBrightness;
        break;
case SCREEN_ON_BIT:
      nominalCurrentValue=Power.BRIGHTNESS_DIM;
    break;
case 0:
  nominalCurrentValue=Power.BRIGHTNESS_OFF;
break;
case SCREEN_BRIGHT_BIT:
default :
nominalCurrentValue=(int)mScreenBrightness.curValue;
break;
}
}
int brightness=preferredBrightness;
int steps=ANIM_STEPS;
if ((newState & SCREEN_BRIGHT_BIT) == 0) {
final float scale=1.5f;
float ratio=(((float)Power.BRIGHTNESS_DIM) / preferredBrightness);
if (ratio > 1.0f) ratio=1.0f;
if ((newState & SCREEN_ON_BIT) == 0) {
if ((oldState & SCREEN_BRIGHT_BIT) != 0) {
steps=ANIM_STEPS;
}
 else {
steps=(int)(ANIM_STEPS * ratio * scale);
}
brightness=Power.BRIGHTNESS_OFF;
}
 else {
if ((oldState & SCREEN_ON_BIT) != 0) {
steps=(int)(ANIM_STEPS * (1.0f - ratio) * scale);
}
 else {
steps=(int)(ANIM_STEPS * ratio);
}
if (mStayOnConditions != 0 && mBatteryService.isPowered(mStayOnConditions)) {
mScreenOffTime=SystemClock.elapsedRealtime();
}
brightness=Power.BRIGHTNESS_DIM;
}
}
long identity=Binder.clearCallingIdentity();
try {
mBatteryStats.noteScreenBrightness(brightness);
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(identity);
}
mScreenBrightness.setTargetLocked(brightness,steps,INITIAL_SCREEN_BRIGHTNESS,nominalCurrentValue);
startAnimation=true;
}
 else {
if ((newState & SCREEN_BRIGHT_BIT) == 0) {
if ((newState & SCREEN_ON_BIT) == 0) {
offMask|=SCREEN_BRIGHT_BIT;
}
 else {
dimMask|=SCREEN_BRIGHT_BIT;
}
}
 else {
onMask|=SCREEN_BRIGHT_BIT;
}
}
}
if (startAnimation) {
if (mSpew) {
Log.i(TAG,""String_Node_Str"");
}
mHandler.removeCallbacks(mLightAnimator);
mHandler.post(mLightAnimator);
}
if (offMask != 0) {
setLightBrightness(offMask,Power.BRIGHTNESS_OFF);
}
if (dimMask != 0) {
int brightness=Power.BRIGHTNESS_DIM;
if ((newState & BATTERY_LOW_BIT) != 0 && brightness > Power.BRIGHTNESS_LOW_BATTERY) {
brightness=Power.BRIGHTNESS_LOW_BATTERY;
}
setLightBrightness(dimMask,brightness);
}
if (onMask != 0) {
int brightness=getPreferredBrightness();
if ((newState & BATTERY_LOW_BIT) != 0 && brightness > Power.BRIGHTNESS_LOW_BATTERY) {
brightness=Power.BRIGHTNESS_LOW_BATTERY;
}
setLightBrightness(onMask,brightness);
}
}","private void updateLightsLocked(int newState,int forceState){
  final int oldState=mPowerState;
  final int realDifference=(newState ^ oldState);
  final int difference=realDifference | forceState;
  if (difference == 0) {
    return;
  }
  int offMask=0;
  int dimMask=0;
  int onMask=0;
  int preferredBrightness=getPreferredBrightness();
  boolean startAnimation=false;
  if ((difference & KEYBOARD_BRIGHT_BIT) != 0) {
    if (ANIMATE_KEYBOARD_LIGHTS) {
      if ((newState & KEYBOARD_BRIGHT_BIT) == 0) {
        mKeyboardBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,ANIM_STEPS,INITIAL_KEYBOARD_BRIGHTNESS,preferredBrightness);
      }
 else {
        mKeyboardBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_KEYBOARD_BRIGHTNESS,Power.BRIGHTNESS_OFF);
      }
      startAnimation=true;
    }
 else {
      if ((newState & KEYBOARD_BRIGHT_BIT) == 0) {
        offMask|=KEYBOARD_BRIGHT_BIT;
      }
 else {
        onMask|=KEYBOARD_BRIGHT_BIT;
      }
    }
  }
  if ((difference & BUTTON_BRIGHT_BIT) != 0) {
    if (ANIMATE_BUTTON_LIGHTS) {
      if ((newState & BUTTON_BRIGHT_BIT) == 0) {
        mButtonBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,ANIM_STEPS,INITIAL_BUTTON_BRIGHTNESS,preferredBrightness);
      }
 else {
        mButtonBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_BUTTON_BRIGHTNESS,Power.BRIGHTNESS_OFF);
      }
      startAnimation=true;
    }
 else {
      if ((newState & BUTTON_BRIGHT_BIT) == 0) {
        offMask|=BUTTON_BRIGHT_BIT;
      }
 else {
        onMask|=BUTTON_BRIGHT_BIT;
      }
    }
  }
  if ((difference & (SCREEN_ON_BIT | SCREEN_BRIGHT_BIT)) != 0) {
    if (ANIMATE_SCREEN_LIGHTS) {
      int nominalCurrentValue=-1;
      if ((realDifference & (SCREEN_ON_BIT | SCREEN_BRIGHT_BIT)) != 0) {
switch (oldState & (SCREEN_BRIGHT_BIT | SCREEN_ON_BIT)) {
case SCREEN_BRIGHT_BIT | SCREEN_ON_BIT:
          nominalCurrentValue=preferredBrightness;
        break;
case SCREEN_ON_BIT:
      nominalCurrentValue=Power.BRIGHTNESS_DIM;
    break;
case 0:
  nominalCurrentValue=Power.BRIGHTNESS_OFF;
break;
case SCREEN_BRIGHT_BIT:
default :
nominalCurrentValue=(int)mScreenBrightness.curValue;
break;
}
}
int brightness=preferredBrightness;
int steps=ANIM_STEPS;
if ((newState & SCREEN_BRIGHT_BIT) == 0) {
final float scale=1.5f;
float ratio=(((float)Power.BRIGHTNESS_DIM) / preferredBrightness);
if (ratio > 1.0f) ratio=1.0f;
if ((newState & SCREEN_ON_BIT) == 0) {
if ((oldState & SCREEN_BRIGHT_BIT) != 0) {
steps=ANIM_STEPS;
}
 else {
steps=(int)(ANIM_STEPS * ratio * scale);
}
brightness=Power.BRIGHTNESS_OFF;
}
 else {
if ((oldState & SCREEN_ON_BIT) != 0) {
steps=(int)(ANIM_STEPS * (1.0f - ratio) * scale);
}
 else {
steps=(int)(ANIM_STEPS * ratio);
}
if (mStayOnConditions != 0 && mBatteryService.isPowered(mStayOnConditions)) {
mScreenOffTime=SystemClock.elapsedRealtime();
}
brightness=Power.BRIGHTNESS_DIM;
}
}
long identity=Binder.clearCallingIdentity();
try {
mBatteryStats.noteScreenBrightness(brightness);
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(identity);
}
if (mScreenBrightness.setTargetLocked(brightness,steps,INITIAL_SCREEN_BRIGHTNESS,nominalCurrentValue)) {
startAnimation=true;
}
}
 else {
if ((newState & SCREEN_BRIGHT_BIT) == 0) {
if ((newState & SCREEN_ON_BIT) == 0) {
offMask|=SCREEN_BRIGHT_BIT;
}
 else {
dimMask|=SCREEN_BRIGHT_BIT;
}
}
 else {
onMask|=SCREEN_BRIGHT_BIT;
}
}
}
if (startAnimation) {
if (mSpew) {
Log.i(TAG,""String_Node_Str"");
}
mHandler.removeCallbacks(mLightAnimator);
mHandler.post(mLightAnimator);
}
if (offMask != 0) {
setLightBrightness(offMask,Power.BRIGHTNESS_OFF);
}
if (dimMask != 0) {
int brightness=Power.BRIGHTNESS_DIM;
if ((newState & BATTERY_LOW_BIT) != 0 && brightness > Power.BRIGHTNESS_LOW_BATTERY) {
brightness=Power.BRIGHTNESS_LOW_BATTERY;
}
setLightBrightness(dimMask,brightness);
}
if (onMask != 0) {
int brightness=getPreferredBrightness();
if ((newState & BATTERY_LOW_BIT) != 0 && brightness > Power.BRIGHTNESS_LOW_BATTERY) {
brightness=Power.BRIGHTNESS_LOW_BATTERY;
}
setLightBrightness(onMask,brightness);
}
}",0.9987754102375704
183014,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  int hintWant=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWidth=mHintLayout == null ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else   if ((mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight())) {
    if (mHint == null && mEllipsize == null && want > mLayout.getWidth() && (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want))) {
      mLayout.increaseWidthTo(want);
    }
 else {
      makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
    }
  }
 else {
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,height);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  int hintWant=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWidth=mHintLayout == null ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else   if ((mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight())) {
    if (mHint == null && mEllipsize == null && want > mLayout.getWidth() && (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want))) {
      mLayout.increaseWidthTo(want);
    }
 else {
      makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
    }
  }
 else {
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}",0.9995067817509248
183015,"private final boolean bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean whileRestarting){
  if (r.app != null) {
    sendServiceArgsLocked(r,false);
    return true;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return true;
  }
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  mRestartingServices.remove(r);
  final String appName=r.processName;
  ProcessRecord app=getProcessRecordLocked(appName,r.appInfo.uid);
  if (app != null && app.thread != null) {
    try {
      realStartServiceLocked(r,app);
      return true;
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + r.shortName,e);
    }
  }
  if (!mPendingServices.contains(r)) {
    if (startProcessLocked(appName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false) == null) {
      Log.w(TAG,""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"");
      bringDownServiceLocked(r,true);
      return false;
    }
    mPendingServices.add(r);
  }
  return true;
}","private final boolean bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean whileRestarting){
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,false);
    return true;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return true;
  }
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  mRestartingServices.remove(r);
  final String appName=r.processName;
  ProcessRecord app=getProcessRecordLocked(appName,r.appInfo.uid);
  if (app != null && app.thread != null) {
    try {
      realStartServiceLocked(r,app);
      return true;
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + r.shortName,e);
    }
  }
  if (startProcessLocked(appName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false) == null) {
    Log.w(TAG,""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"");
    bringDownServiceLocked(r,true);
    return false;
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  return true;
}",0.9350766456266908
183016,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  mProcessesToGc.remove(app);
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}",0.9960998439937596
183017,"private final void appDiedLocked(ProcessRecord app,int pid,IApplicationThread thread){
  mProcDeaths[0]++;
  if (app.thread != null && app.thread.asBinder() == thread.asBinder()) {
    Log.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ pid+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,app.pid,app.processName);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ pid+ ""String_Node_Str""+ thread.asBinder());
    boolean doLowMem=app.instrumentationClass == null;
    handleAppDiedLocked(app,false);
    if (doLowMem) {
      boolean haveBg=false;
      int count=mLRUProcesses.size();
      int i;
      for (i=0; i < count; i++) {
        ProcessRecord rec=mLRUProcesses.get(i);
        if (rec.thread != null && rec.setAdj >= HIDDEN_APP_MIN_ADJ) {
          haveBg=true;
          break;
        }
      }
      if (!haveBg) {
        Log.i(TAG,""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_LOW_MEMORY,mLRUProcesses.size());
        long now=SystemClock.uptimeMillis();
        for (i=0; i < count; i++) {
          ProcessRecord rec=mLRUProcesses.get(i);
          if (rec.thread != null && (rec.lastLowMemory + GC_MIN_INTERVAL) <= now) {
            if (rec.setAdj <= VISIBLE_APP_ADJ) {
              rec.lastRequestedGc=0;
            }
 else {
              rec.lastRequestedGc=rec.lastLowMemory;
            }
            rec.reportLowMemory=true;
            rec.lastLowMemory=now;
            mProcessesToGc.remove(rec);
            addProcessToGcListLocked(rec);
          }
        }
        scheduleAppGcsLocked();
      }
    }
  }
 else   if (Config.LOGD) {
    Log.d(TAG,""String_Node_Str"" + thread.asBinder());
  }
}","private final void appDiedLocked(ProcessRecord app,int pid,IApplicationThread thread){
  mProcDeaths[0]++;
  if (app.thread != null && app.thread.asBinder() == thread.asBinder()) {
    Log.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ pid+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,app.pid,app.processName);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ pid+ ""String_Node_Str""+ thread.asBinder());
    boolean doLowMem=app.instrumentationClass == null;
    handleAppDiedLocked(app,false);
    if (doLowMem) {
      boolean haveBg=false;
      int count=mLRUProcesses.size();
      int i;
      for (i=0; i < count; i++) {
        ProcessRecord rec=mLRUProcesses.get(i);
        if (rec.thread != null && rec.setAdj >= HIDDEN_APP_MIN_ADJ) {
          haveBg=true;
          break;
        }
      }
      if (!haveBg) {
        Log.i(TAG,""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_LOW_MEMORY,mLRUProcesses.size());
        long now=SystemClock.uptimeMillis();
        for (i=0; i < count; i++) {
          ProcessRecord rec=mLRUProcesses.get(i);
          if (rec != app && rec.thread != null && (rec.lastLowMemory + GC_MIN_INTERVAL) <= now) {
            if (rec.setAdj <= VISIBLE_APP_ADJ) {
              rec.lastRequestedGc=0;
            }
 else {
              rec.lastRequestedGc=rec.lastLowMemory;
            }
            rec.reportLowMemory=true;
            rec.lastLowMemory=now;
            mProcessesToGc.remove(rec);
            addProcessToGcListLocked(rec);
          }
        }
        scheduleAppGcsLocked();
      }
    }
  }
 else   if (Config.LOGD) {
    Log.d(TAG,""String_Node_Str"" + thread.asBinder());
  }
}",0.9959016393442623
183018,"public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
}","public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
  mSuspending=false;
  mResuming=false;
}",0.9778024417314096
183019,"public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str"");
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_PLAYING:
    return true;
case BluetoothA2dp.STATE_CONNECTED:
  return resumeSinkNative(path);
default :
return false;
}
}","public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mResuming+ ""String_Node_Str""+ mSuspending);
  if (mResuming) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_PLAYING:
    if (mSuspending) {
      mResuming=true;
    }
  return true;
case BluetoothA2dp.STATE_CONNECTED:
mResuming=resumeSinkNative(path);
mAudioManager.setParameters(""String_Node_Str"");
return mResuming;
default :
return false;
}
}",0.8509777478084963
183020,"private synchronized void onBluetoothEnable(){
  String devices=mBluetoothService.getProperty(""String_Node_Str"");
  mSinkCount=0;
  if (devices != null) {
    String[] paths=devices.split(""String_Node_Str"");
    for (    String path : paths) {
      String address=mBluetoothService.getAddressFromObjectPath(path);
      BluetoothDevice device=mAdapter.getRemoteDevice(address);
      ParcelUuid[] remoteUuids=mBluetoothService.getRemoteUuids(address);
      if (remoteUuids != null)       if (BluetoothUuid.containsAnyUuid(remoteUuids,new ParcelUuid[]{BluetoothUuid.AudioSink,BluetoothUuid.AdvAudioDist})) {
        addAudioSink(device);
      }
    }
  }
  mAudioManager.setParameters(BLUETOOTH_ENABLED + ""String_Node_Str"");
}","private synchronized void onBluetoothEnable(){
  String devices=mBluetoothService.getProperty(""String_Node_Str"");
  mSinkCount=0;
  if (devices != null) {
    String[] paths=devices.split(""String_Node_Str"");
    for (    String path : paths) {
      String address=mBluetoothService.getAddressFromObjectPath(path);
      BluetoothDevice device=mAdapter.getRemoteDevice(address);
      ParcelUuid[] remoteUuids=mBluetoothService.getRemoteUuids(address);
      if (remoteUuids != null)       if (BluetoothUuid.containsAnyUuid(remoteUuids,new ParcelUuid[]{BluetoothUuid.AudioSink,BluetoothUuid.AdvAudioDist})) {
        addAudioSink(device);
      }
    }
  }
  mAudioManager.setParameters(BLUETOOTH_ENABLED + ""String_Node_Str"");
  mAudioManager.setParameters(""String_Node_Str"");
}",0.9667994687915008
183021,"public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str"");
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_CONNECTED:
    return true;
case BluetoothA2dp.STATE_PLAYING:
  return suspendSinkNative(path);
default :
return false;
}
}","public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mSuspending+ ""String_Node_Str""+ mResuming);
  if (mSuspending) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_CONNECTED:
    if (mResuming) {
      mSuspending=true;
    }
  return true;
case BluetoothA2dp.STATE_PLAYING:
mAudioManager.setParameters(""String_Node_Str"");
mSuspending=suspendSinkNative(path);
return mSuspending;
default :
return false;
}
}",0.8479571332886805
183022,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state == BluetoothA2dp.STATE_DISCONNECTED) {
    mSuspending=false;
    mResuming=false;
  }
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    if (state == BluetoothA2dp.STATE_CONNECTED && prevState == BluetoothA2dp.STATE_PLAYING) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mSuspending) {
        mSuspending=false;
        if (mResuming) {
          mResuming=false;
          resumeSink(device);
        }
      }
    }
    if (state == BluetoothA2dp.STATE_PLAYING && prevState == BluetoothA2dp.STATE_CONNECTED) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mResuming) {
        mResuming=false;
        if (mSuspending) {
          mSuspending=false;
          suspendSink(device);
        }
      }
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}",0.7189964157706094
183023,"public void onReceive(Context context,Intent intent){
synchronized (this) {
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
      Phone.DataState state=getMobileDataState(intent);
      String reason=intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
      String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
      String apnTypeList=intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
      boolean unavailable=intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
      mNetworkInfo.setIsAvailable(!unavailable);
      if (isApnTypeIncluded(apnTypeList)) {
        if (mEnabled == false) {
          if (state == Phone.DataState.CONNECTED) {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + mInterfaceName + ""String_Node_Str""+ intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY)+ ""String_Node_Str""+ mApnType);
            mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
          }
          return;
        }
      }
 else {
        return;
      }
      if (DBG)       Log.d(TAG,mApnType + ""String_Node_Str"" + state+ ""String_Node_Str""+ mMobileDataState+ ""String_Node_Str""+ (reason == null ? ""String_Node_Str"" : reason)+ ""String_Node_Str""+ apnTypeList);
      if (mMobileDataState != state) {
        mMobileDataState=state;
switch (state) {
case DISCONNECTED:
          if (isTeardownRequested()) {
            mEnabled=false;
            setTeardownRequested(false);
          }
        setDetailedState(DetailedState.DISCONNECTED,reason,apnName);
      if (mInterfaceName != null) {
        NetworkUtils.resetConnections(mInterfaceName);
      }
    break;
case CONNECTING:
  setDetailedState(DetailedState.CONNECTING,reason,apnName);
break;
case SUSPENDED:
setDetailedState(DetailedState.SUSPENDED,reason,apnName);
break;
case CONNECTED:
mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
if (mInterfaceName == null) {
Log.d(TAG,""String_Node_Str"");
}
setDetailedState(DetailedState.CONNECTED,reason,apnName);
break;
}
}
}
 else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
mEnabled=false;
String reason=intent.getStringExtra(Phone.FAILURE_REASON_KEY);
String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
if (DBG) Log.d(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ reason == null ? ""String_Node_Str"" : ""String_Node_Str"" + reason + ""String_Node_Str"");
setDetailedState(DetailedState.FAILED,reason,apnName);
}
TelephonyManager tm=TelephonyManager.getDefault();
setRoamingStatus(tm.isNetworkRoaming());
setSubtype(tm.getNetworkType(),tm.getNetworkTypeName());
}
}","public void onReceive(Context context,Intent intent){
synchronized (this) {
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
      Phone.DataState state=getMobileDataState(intent);
      String reason=intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
      String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
      String apnTypeList=intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
      mApnName=apnName;
      boolean unavailable=intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
      mNetworkInfo.setIsAvailable(!unavailable);
      if (isApnTypeIncluded(apnTypeList)) {
        if (mEnabled == false) {
          if (state == Phone.DataState.CONNECTED) {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + mInterfaceName + ""String_Node_Str""+ intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY)+ ""String_Node_Str""+ mApnType);
            mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
          }
          return;
        }
      }
 else {
        return;
      }
      if (DBG)       Log.d(TAG,mApnType + ""String_Node_Str"" + state+ ""String_Node_Str""+ mMobileDataState+ ""String_Node_Str""+ (reason == null ? ""String_Node_Str"" : reason)+ ""String_Node_Str""+ apnTypeList);
      if (mMobileDataState != state) {
        mMobileDataState=state;
switch (state) {
case DISCONNECTED:
          if (isTeardownRequested()) {
            mEnabled=false;
            setTeardownRequested(false);
          }
        setDetailedState(DetailedState.DISCONNECTED,reason,apnName);
      if (mInterfaceName != null) {
        NetworkUtils.resetConnections(mInterfaceName);
      }
    break;
case CONNECTING:
  setDetailedState(DetailedState.CONNECTING,reason,apnName);
break;
case SUSPENDED:
setDetailedState(DetailedState.SUSPENDED,reason,apnName);
break;
case CONNECTED:
mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
if (mInterfaceName == null) {
Log.d(TAG,""String_Node_Str"");
}
setDetailedState(DetailedState.CONNECTED,reason,apnName);
break;
}
}
}
 else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
mEnabled=false;
String reason=intent.getStringExtra(Phone.FAILURE_REASON_KEY);
String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
if (DBG) Log.d(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ reason == null ? ""String_Node_Str"" : ""String_Node_Str"" + reason + ""String_Node_Str"");
setDetailedState(DetailedState.FAILED,reason,apnName);
}
TelephonyManager tm=TelephonyManager.getDefault();
setRoamingStatus(tm.isNetworkRoaming());
setSubtype(tm.getNetworkType(),tm.getNetworkTypeName());
}
}",0.9954579863739592
183024,"/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnType);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}","/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnType);
intent.putExtra(Phone.DATA_APN_KEY,mApnName);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}",0.9800173761946134
183025,"private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}","private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}",0.9281524926686217
183026,"/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}","/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}",0.958904109589041
183027,"private Dialog getProgressDialog(){
  if (mCheckingDialog == null) {
    mCheckingDialog=new ProgressDialog(mContext);
    mCheckingDialog.setMessage(mContext.getString(R.string.lockscreen_glogin_checking_password));
    mCheckingDialog.setIndeterminate(true);
    mCheckingDialog.setCancelable(false);
    mCheckingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    mCheckingDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  return mCheckingDialog;
}","private Dialog getProgressDialog(){
  if (mCheckingDialog == null) {
    mCheckingDialog=new ProgressDialog(mContext);
    mCheckingDialog.setMessage(mContext.getString(R.string.lockscreen_glogin_checking_password));
    mCheckingDialog.setIndeterminate(true);
    mCheckingDialog.setCancelable(false);
    mCheckingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      mCheckingDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
  }
  return mCheckingDialog;
}",0.9150865622423744
183028,"/** 
 * Create the global actions dialog.
 * @return A new dialog.
 */
private AlertDialog createDialog(){
  mSilentModeToggle=new ToggleAction(R.drawable.ic_lock_silent_mode,R.drawable.ic_lock_silent_mode_off,R.string.global_action_toggle_silent_mode,R.string.global_action_silent_mode_on_status,R.string.global_action_silent_mode_off_status){
    void onToggle(    boolean on){
      mAudioManager.setRingerMode(on ? AudioManager.RINGER_MODE_SILENT : AudioManager.RINGER_MODE_NORMAL);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mAirplaneModeOn=new ToggleAction(R.drawable.ic_lock_airplane_mode,R.drawable.ic_lock_airplane_mode_off,R.string.global_actions_toggle_airplane_mode,R.string.global_actions_airplane_mode_on_status,R.string.global_actions_airplane_mode_off_status){
    void onToggle(    boolean on){
      if (Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
        mIsWaitingForEcmExit=true;
        Intent ecmDialogIntent=new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS,null);
        ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(ecmDialogIntent);
      }
 else {
        changeAirplaneModeSystemSetting(on);
      }
    }
    @Override protected void changeStateFromPress(    boolean buttonOn){
      if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
        mState=buttonOn ? State.TurningOn : State.TurningOff;
        mAirplaneState=mState;
      }
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mItems=Lists.newArrayList(mSilentModeToggle,mAirplaneModeOn,new SinglePressAction(com.android.internal.R.drawable.ic_lock_power_off,R.string.global_action_power_off){
    public void onPress(){
      ShutdownThread.shutdown(mContext,true);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return true;
    }
  }
);
  mAdapter=new MyAdapter();
  final AlertDialog.Builder ab=new AlertDialog.Builder(mContext);
  ab.setAdapter(mAdapter,this).setInverseBackgroundForced(true).setTitle(R.string.global_actions);
  final AlertDialog dialog=ab.create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.setOnDismissListener(this);
  return dialog;
}","/** 
 * Create the global actions dialog.
 * @return A new dialog.
 */
private AlertDialog createDialog(){
  mSilentModeToggle=new ToggleAction(R.drawable.ic_lock_silent_mode,R.drawable.ic_lock_silent_mode_off,R.string.global_action_toggle_silent_mode,R.string.global_action_silent_mode_on_status,R.string.global_action_silent_mode_off_status){
    void onToggle(    boolean on){
      mAudioManager.setRingerMode(on ? AudioManager.RINGER_MODE_SILENT : AudioManager.RINGER_MODE_NORMAL);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mAirplaneModeOn=new ToggleAction(R.drawable.ic_lock_airplane_mode,R.drawable.ic_lock_airplane_mode_off,R.string.global_actions_toggle_airplane_mode,R.string.global_actions_airplane_mode_on_status,R.string.global_actions_airplane_mode_off_status){
    void onToggle(    boolean on){
      if (Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
        mIsWaitingForEcmExit=true;
        Intent ecmDialogIntent=new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS,null);
        ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(ecmDialogIntent);
      }
 else {
        changeAirplaneModeSystemSetting(on);
      }
    }
    @Override protected void changeStateFromPress(    boolean buttonOn){
      if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
        mState=buttonOn ? State.TurningOn : State.TurningOff;
        mAirplaneState=mState;
      }
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mItems=Lists.newArrayList(mSilentModeToggle,mAirplaneModeOn,new SinglePressAction(com.android.internal.R.drawable.ic_lock_power_off,R.string.global_action_power_off){
    public void onPress(){
      ShutdownThread.shutdown(mContext,true);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return true;
    }
  }
);
  mAdapter=new MyAdapter();
  final AlertDialog.Builder ab=new AlertDialog.Builder(mContext);
  ab.setAdapter(mAdapter,this).setInverseBackgroundForced(true).setTitle(R.string.global_actions);
  final AlertDialog dialog=ab.create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.setOnDismissListener(this);
  return dialog;
}",0.9816087683447892
183029,"private void showAlmostAtAccountLoginDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_failed_attempts_almost_glogin,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.show();
}","private void showAlmostAtAccountLoginDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_failed_attempts_almost_glogin,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.show();
}",0.936741214057508
183030,"private void showTimeoutDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_too_many_failed_attempts_dialog_message,mUpdateMonitor.getFailedAttempts(),timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.show();
}","private void showTimeoutDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_too_many_failed_attempts_dialog_message,mUpdateMonitor.getFailedAttempts(),timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.show();
}",0.9261744966442952
183031,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Context context=getContext();
  if (sStatusBar == null) {
    sStatusBar=(StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
  }
  setContentView(com.android.internal.R.layout.power_dialog);
  getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  setTitle(context.getText(R.string.power_dialog));
  mKeyguard=(Button)findViewById(R.id.keyguard);
  mPower=(Button)findViewById(R.id.off);
  mRadioPower=(Button)findViewById(R.id.radio_power);
  mSilent=(Button)findViewById(R.id.silent);
  if (mKeyguard != null) {
    mKeyguard.setOnKeyListener(this);
    mKeyguard.setOnClickListener(this);
  }
  if (mPower != null) {
    mPower.setOnClickListener(this);
  }
  if (mRadioPower != null) {
    mRadioPower.setOnClickListener(this);
  }
  if (mSilent != null) {
    mSilent.setOnClickListener(this);
    mSilent.setVisibility(View.GONE);
  }
  CharSequence text;
  text=context.getText(R.string.screen_lock);
  mKeyguard.setText(text);
  mKeyguard.requestFocus();
  try {
    ITelephony phone=ITelephony.Stub.asInterface(ServiceManager.checkService(""String_Node_Str""));
    if (phone != null) {
      text=phone.isRadioOn() ? context.getText(R.string.turn_off_radio) : context.getText(R.string.turn_on_radio);
    }
  }
 catch (  RemoteException ex) {
  }
  mRadioPower.setText(text);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Context context=getContext();
  if (sStatusBar == null) {
    sStatusBar=(StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
  }
  setContentView(com.android.internal.R.layout.power_dialog);
  getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  if (!getContext().getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  setTitle(context.getText(R.string.power_dialog));
  mKeyguard=(Button)findViewById(R.id.keyguard);
  mPower=(Button)findViewById(R.id.off);
  mRadioPower=(Button)findViewById(R.id.radio_power);
  mSilent=(Button)findViewById(R.id.silent);
  if (mKeyguard != null) {
    mKeyguard.setOnKeyListener(this);
    mKeyguard.setOnClickListener(this);
  }
  if (mPower != null) {
    mPower.setOnClickListener(this);
  }
  if (mRadioPower != null) {
    mRadioPower.setOnClickListener(this);
  }
  if (mSilent != null) {
    mSilent.setOnClickListener(this);
    mSilent.setVisibility(View.GONE);
  }
  CharSequence text;
  text=context.getText(R.string.screen_lock);
  mKeyguard.setText(text);
  mKeyguard.requestFocus();
  try {
    ITelephony phone=ITelephony.Stub.asInterface(ServiceManager.checkService(""String_Node_Str""));
    if (phone != null) {
      text=phone.isRadioOn() ? context.getText(R.string.turn_off_radio) : context.getText(R.string.turn_on_radio);
    }
  }
 catch (  RemoteException ex) {
  }
  mRadioPower.setText(text);
}",0.9698742322316468
183032,"private Dialog getSimUnlockProgressDialog(){
  if (mSimUnlockProgressDialog == null) {
    mSimUnlockProgressDialog=new ProgressDialog(mContext);
    mSimUnlockProgressDialog.setMessage(mContext.getString(R.string.lockscreen_sim_unlock_progress_dialog_message));
    mSimUnlockProgressDialog.setIndeterminate(true);
    mSimUnlockProgressDialog.setCancelable(false);
    mSimUnlockProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    mSimUnlockProgressDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  return mSimUnlockProgressDialog;
}","private Dialog getSimUnlockProgressDialog(){
  if (mSimUnlockProgressDialog == null) {
    mSimUnlockProgressDialog=new ProgressDialog(mContext);
    mSimUnlockProgressDialog.setMessage(mContext.getString(R.string.lockscreen_sim_unlock_progress_dialog_message));
    mSimUnlockProgressDialog.setIndeterminate(true);
    mSimUnlockProgressDialog.setCancelable(false);
    mSimUnlockProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      mSimUnlockProgressDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
  }
  return mSimUnlockProgressDialog;
}",0.9261648745519712
183033,"private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}","private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}",0.9281524926686217
183034,"/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}","/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}",0.958904109589041
183035,"private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}","private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}",0.9281524926686217
183036,"/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}","/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}",0.958904109589041
183037,"void updatePlugged(){
  Intent powerIntent=mContext.registerReceiver(null,mBatteryStatusFilter);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + powerIntent.getExtras());
  if (powerIntent != null) {
    mPlugged=powerIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED,0);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mPlugged);
  }
}","void updatePlugged(Intent powerIntent){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + powerIntent.getExtras());
  if (powerIntent != null) {
    mPlugged=powerIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED,0);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mPlugged);
  }
}",0.8507223113964687
183038,"/** 
 * {@inheritDoc} 
 */
public void init(Context context,IWindowManager windowManager,LocalPowerManager powerManager){
  mContext=context;
  mWindowManager=windowManager;
  mPowerManager=powerManager;
  mKeyguardMediator=new KeyguardViewMediator(context,this,powerManager);
  mHandler=new Handler();
  mOrientationListener=new MyOrientationListener(mContext);
  SettingsObserver settingsObserver=new SettingsObserver(mHandler);
  settingsObserver.observe();
  mShortcutManager=new ShortcutManager(context,mHandler);
  mShortcutManager.observe();
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mCarDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
  mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mDeskDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
  mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mBroadcastWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock.setReferenceCounted(false);
  mEnableShiftMenuBugReports=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mLidOpenRotation=readRotation(com.android.internal.R.integer.config_lidOpenRotation);
  mCarDockRotation=readRotation(com.android.internal.R.integer.config_carDockRotation);
  mDeskDockRotation=readRotation(com.android.internal.R.integer.config_deskDockRotation);
  mCarDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_carDockKeepsScreenOn);
  mDeskDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_deskDockKeepsScreenOn);
  mCarDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
  mDeskDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
  mLidKeyboardAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
  mLidNavigationAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_POWER_CONNECTED);
  intentFilter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  context.registerReceiver(mPowerReceiver,intentFilter);
  mBatteryStatusFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  mPlugged=0;
  updatePlugged();
  context.registerReceiver(mDockReceiver,new IntentFilter(Intent.ACTION_DOCK_EVENT));
  mVibrator=new Vibrator();
  mLongPressVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_longPressVibePattern);
  mVirtualKeyVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_virtualKeyVibePattern);
  mSafeModeDisabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeDisabledVibePattern);
  mSafeModeEnabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeEnabledVibePattern);
}","/** 
 * {@inheritDoc} 
 */
public void init(Context context,IWindowManager windowManager,LocalPowerManager powerManager){
  mContext=context;
  mWindowManager=windowManager;
  mPowerManager=powerManager;
  mKeyguardMediator=new KeyguardViewMediator(context,this,powerManager);
  mHandler=new Handler();
  mOrientationListener=new MyOrientationListener(mContext);
  SettingsObserver settingsObserver=new SettingsObserver(mHandler);
  settingsObserver.observe();
  mShortcutManager=new ShortcutManager(context,mHandler);
  mShortcutManager.observe();
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mCarDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
  mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mDeskDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
  mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mBroadcastWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock.setReferenceCounted(false);
  mEnableShiftMenuBugReports=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mLidOpenRotation=readRotation(com.android.internal.R.integer.config_lidOpenRotation);
  mCarDockRotation=readRotation(com.android.internal.R.integer.config_carDockRotation);
  mDeskDockRotation=readRotation(com.android.internal.R.integer.config_deskDockRotation);
  mCarDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_carDockKeepsScreenOn);
  mDeskDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_deskDockKeepsScreenOn);
  mCarDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
  mDeskDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
  mLidKeyboardAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
  mLidNavigationAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
  mBatteryStatusFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  mPlugged=0;
  updatePlugged(context.registerReceiver(null,mBatteryStatusFilter));
  context.registerReceiver(mDockReceiver,new IntentFilter(Intent.ACTION_DOCK_EVENT));
  mVibrator=new Vibrator();
  mLongPressVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_longPressVibePattern);
  mVirtualKeyVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_virtualKeyVibePattern);
  mSafeModeDisabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeDisabledVibePattern);
  mSafeModeEnabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeEnabledVibePattern);
}",0.9222109972579016
183039,"public void onReceive(Context context,Intent intent){
  mDockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
  updateKeepScreenOn();
  updateOrientationListenerLp();
}","public void onReceive(Context context,Intent intent){
  mDockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
  boolean watchBattery=mDockState != Intent.EXTRA_DOCK_STATE_UNDOCKED;
  if (watchBattery != mRegisteredBatteryReceiver) {
    mRegisteredBatteryReceiver=watchBattery;
    if (watchBattery) {
      updatePlugged(mContext.registerReceiver(mBatteryReceiver,mBatteryStatusFilter));
    }
 else {
      mContext.unregisterReceiver(mBatteryReceiver);
    }
  }
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
  updateDockKeepingScreenOn();
  updateOrientationListenerLp();
}",0.5944134078212291
183040,"private Dialog getProgressDialog(){
  if (mCheckingDialog == null) {
    mCheckingDialog=new ProgressDialog(mContext);
    mCheckingDialog.setMessage(mContext.getString(R.string.lockscreen_glogin_checking_password));
    mCheckingDialog.setIndeterminate(true);
    mCheckingDialog.setCancelable(false);
    mCheckingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    mCheckingDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  return mCheckingDialog;
}","private Dialog getProgressDialog(){
  if (mCheckingDialog == null) {
    mCheckingDialog=new ProgressDialog(mContext);
    mCheckingDialog.setMessage(mContext.getString(R.string.lockscreen_glogin_checking_password));
    mCheckingDialog.setIndeterminate(true);
    mCheckingDialog.setCancelable(false);
    mCheckingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      mCheckingDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
  }
  return mCheckingDialog;
}",0.9150865622423744
183041,"/** 
 * Create the global actions dialog.
 * @return A new dialog.
 */
private AlertDialog createDialog(){
  mSilentModeToggle=new ToggleAction(R.drawable.ic_lock_silent_mode,R.drawable.ic_lock_silent_mode_off,R.string.global_action_toggle_silent_mode,R.string.global_action_silent_mode_on_status,R.string.global_action_silent_mode_off_status){
    void onToggle(    boolean on){
      mAudioManager.setRingerMode(on ? AudioManager.RINGER_MODE_SILENT : AudioManager.RINGER_MODE_NORMAL);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mAirplaneModeOn=new ToggleAction(R.drawable.ic_lock_airplane_mode,R.drawable.ic_lock_airplane_mode_off,R.string.global_actions_toggle_airplane_mode,R.string.global_actions_airplane_mode_on_status,R.string.global_actions_airplane_mode_off_status){
    void onToggle(    boolean on){
      if (Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
        mIsWaitingForEcmExit=true;
        Intent ecmDialogIntent=new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS,null);
        ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(ecmDialogIntent);
      }
 else {
        changeAirplaneModeSystemSetting(on);
      }
    }
    @Override protected void changeStateFromPress(    boolean buttonOn){
      if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
        mState=buttonOn ? State.TurningOn : State.TurningOff;
        mAirplaneState=mState;
      }
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mItems=Lists.newArrayList(mSilentModeToggle,mAirplaneModeOn,new SinglePressAction(com.android.internal.R.drawable.ic_lock_power_off,R.string.global_action_power_off){
    public void onPress(){
      ShutdownThread.shutdown(mContext,true);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return true;
    }
  }
);
  mAdapter=new MyAdapter();
  final AlertDialog.Builder ab=new AlertDialog.Builder(mContext);
  ab.setAdapter(mAdapter,this).setInverseBackgroundForced(true).setTitle(R.string.global_actions);
  final AlertDialog dialog=ab.create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.setOnDismissListener(this);
  return dialog;
}","/** 
 * Create the global actions dialog.
 * @return A new dialog.
 */
private AlertDialog createDialog(){
  mSilentModeToggle=new ToggleAction(R.drawable.ic_lock_silent_mode,R.drawable.ic_lock_silent_mode_off,R.string.global_action_toggle_silent_mode,R.string.global_action_silent_mode_on_status,R.string.global_action_silent_mode_off_status){
    void onToggle(    boolean on){
      mAudioManager.setRingerMode(on ? AudioManager.RINGER_MODE_SILENT : AudioManager.RINGER_MODE_NORMAL);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mAirplaneModeOn=new ToggleAction(R.drawable.ic_lock_airplane_mode,R.drawable.ic_lock_airplane_mode_off,R.string.global_actions_toggle_airplane_mode,R.string.global_actions_airplane_mode_on_status,R.string.global_actions_airplane_mode_off_status){
    void onToggle(    boolean on){
      if (Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
        mIsWaitingForEcmExit=true;
        Intent ecmDialogIntent=new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS,null);
        ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(ecmDialogIntent);
      }
 else {
        changeAirplaneModeSystemSetting(on);
      }
    }
    @Override protected void changeStateFromPress(    boolean buttonOn){
      if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
        mState=buttonOn ? State.TurningOn : State.TurningOff;
        mAirplaneState=mState;
      }
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mItems=Lists.newArrayList(mSilentModeToggle,mAirplaneModeOn,new SinglePressAction(com.android.internal.R.drawable.ic_lock_power_off,R.string.global_action_power_off){
    public void onPress(){
      ShutdownThread.shutdown(mContext,true);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return true;
    }
  }
);
  mAdapter=new MyAdapter();
  final AlertDialog.Builder ab=new AlertDialog.Builder(mContext);
  ab.setAdapter(mAdapter,this).setInverseBackgroundForced(true).setTitle(R.string.global_actions);
  final AlertDialog dialog=ab.create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.setOnDismissListener(this);
  return dialog;
}",0.9816087683447892
183042,"private void showAlmostAtAccountLoginDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_failed_attempts_almost_glogin,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.show();
}","private void showAlmostAtAccountLoginDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_failed_attempts_almost_glogin,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.show();
}",0.936741214057508
183043,"private void showTimeoutDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_too_many_failed_attempts_dialog_message,mUpdateMonitor.getFailedAttempts(),timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.show();
}","private void showTimeoutDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_too_many_failed_attempts_dialog_message,mUpdateMonitor.getFailedAttempts(),timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.show();
}",0.9261744966442952
183044,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Context context=getContext();
  if (sStatusBar == null) {
    sStatusBar=(StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
  }
  setContentView(com.android.internal.R.layout.power_dialog);
  getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  setTitle(context.getText(R.string.power_dialog));
  mKeyguard=(Button)findViewById(R.id.keyguard);
  mPower=(Button)findViewById(R.id.off);
  mRadioPower=(Button)findViewById(R.id.radio_power);
  mSilent=(Button)findViewById(R.id.silent);
  if (mKeyguard != null) {
    mKeyguard.setOnKeyListener(this);
    mKeyguard.setOnClickListener(this);
  }
  if (mPower != null) {
    mPower.setOnClickListener(this);
  }
  if (mRadioPower != null) {
    mRadioPower.setOnClickListener(this);
  }
  if (mSilent != null) {
    mSilent.setOnClickListener(this);
    mSilent.setVisibility(View.GONE);
  }
  CharSequence text;
  text=context.getText(R.string.screen_lock);
  mKeyguard.setText(text);
  mKeyguard.requestFocus();
  try {
    ITelephony phone=ITelephony.Stub.asInterface(ServiceManager.checkService(""String_Node_Str""));
    if (phone != null) {
      text=phone.isRadioOn() ? context.getText(R.string.turn_off_radio) : context.getText(R.string.turn_on_radio);
    }
  }
 catch (  RemoteException ex) {
  }
  mRadioPower.setText(text);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Context context=getContext();
  if (sStatusBar == null) {
    sStatusBar=(StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
  }
  setContentView(com.android.internal.R.layout.power_dialog);
  getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  if (!getContext().getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  setTitle(context.getText(R.string.power_dialog));
  mKeyguard=(Button)findViewById(R.id.keyguard);
  mPower=(Button)findViewById(R.id.off);
  mRadioPower=(Button)findViewById(R.id.radio_power);
  mSilent=(Button)findViewById(R.id.silent);
  if (mKeyguard != null) {
    mKeyguard.setOnKeyListener(this);
    mKeyguard.setOnClickListener(this);
  }
  if (mPower != null) {
    mPower.setOnClickListener(this);
  }
  if (mRadioPower != null) {
    mRadioPower.setOnClickListener(this);
  }
  if (mSilent != null) {
    mSilent.setOnClickListener(this);
    mSilent.setVisibility(View.GONE);
  }
  CharSequence text;
  text=context.getText(R.string.screen_lock);
  mKeyguard.setText(text);
  mKeyguard.requestFocus();
  try {
    ITelephony phone=ITelephony.Stub.asInterface(ServiceManager.checkService(""String_Node_Str""));
    if (phone != null) {
      text=phone.isRadioOn() ? context.getText(R.string.turn_off_radio) : context.getText(R.string.turn_on_radio);
    }
  }
 catch (  RemoteException ex) {
  }
  mRadioPower.setText(text);
}",0.9698742322316468
183045,"private Dialog getSimUnlockProgressDialog(){
  if (mSimUnlockProgressDialog == null) {
    mSimUnlockProgressDialog=new ProgressDialog(mContext);
    mSimUnlockProgressDialog.setMessage(mContext.getString(R.string.lockscreen_sim_unlock_progress_dialog_message));
    mSimUnlockProgressDialog.setIndeterminate(true);
    mSimUnlockProgressDialog.setCancelable(false);
    mSimUnlockProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    mSimUnlockProgressDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  return mSimUnlockProgressDialog;
}","private Dialog getSimUnlockProgressDialog(){
  if (mSimUnlockProgressDialog == null) {
    mSimUnlockProgressDialog=new ProgressDialog(mContext);
    mSimUnlockProgressDialog.setMessage(mContext.getString(R.string.lockscreen_sim_unlock_progress_dialog_message));
    mSimUnlockProgressDialog.setIndeterminate(true);
    mSimUnlockProgressDialog.setCancelable(false);
    mSimUnlockProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      mSimUnlockProgressDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
  }
  return mSimUnlockProgressDialog;
}",0.9261648745519712
183046,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}",0.6966773847802786
183047,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}",0.7710011507479861
183048,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}",0.9988239905919248
183049,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}",0.8691006233303651
183050,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9546271338724168
183051,"void updatePlugged(){
  Intent powerIntent=mContext.registerReceiver(null,mBatteryStatusFilter);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + powerIntent.getExtras());
  if (powerIntent != null) {
    mPlugged=powerIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED,0);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mPlugged);
  }
}","void updatePlugged(Intent powerIntent){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + powerIntent.getExtras());
  if (powerIntent != null) {
    mPlugged=powerIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED,0);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mPlugged);
  }
}",0.8507223113964687
183052,"/** 
 * {@inheritDoc} 
 */
public void init(Context context,IWindowManager windowManager,LocalPowerManager powerManager){
  mContext=context;
  mWindowManager=windowManager;
  mPowerManager=powerManager;
  mKeyguardMediator=new KeyguardViewMediator(context,this,powerManager);
  mHandler=new Handler();
  mOrientationListener=new MyOrientationListener(mContext);
  SettingsObserver settingsObserver=new SettingsObserver(mHandler);
  settingsObserver.observe();
  mShortcutManager=new ShortcutManager(context,mHandler);
  mShortcutManager.observe();
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mCarDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
  mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mDeskDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
  mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mBroadcastWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock.setReferenceCounted(false);
  mEnableShiftMenuBugReports=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mLidOpenRotation=readRotation(com.android.internal.R.integer.config_lidOpenRotation);
  mCarDockRotation=readRotation(com.android.internal.R.integer.config_carDockRotation);
  mDeskDockRotation=readRotation(com.android.internal.R.integer.config_deskDockRotation);
  mCarDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_carDockKeepsScreenOn);
  mDeskDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_deskDockKeepsScreenOn);
  mCarDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
  mDeskDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
  mLidKeyboardAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
  mLidNavigationAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_POWER_CONNECTED);
  intentFilter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  context.registerReceiver(mPowerReceiver,intentFilter);
  mBatteryStatusFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  mPlugged=0;
  updatePlugged();
  context.registerReceiver(mDockReceiver,new IntentFilter(Intent.ACTION_DOCK_EVENT));
  mVibrator=new Vibrator();
  mLongPressVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_longPressVibePattern);
  mVirtualKeyVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_virtualKeyVibePattern);
  mSafeModeDisabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeDisabledVibePattern);
  mSafeModeEnabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeEnabledVibePattern);
}","/** 
 * {@inheritDoc} 
 */
public void init(Context context,IWindowManager windowManager,LocalPowerManager powerManager){
  mContext=context;
  mWindowManager=windowManager;
  mPowerManager=powerManager;
  mKeyguardMediator=new KeyguardViewMediator(context,this,powerManager);
  mHandler=new Handler();
  mOrientationListener=new MyOrientationListener(mContext);
  SettingsObserver settingsObserver=new SettingsObserver(mHandler);
  settingsObserver.observe();
  mShortcutManager=new ShortcutManager(context,mHandler);
  mShortcutManager.observe();
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mCarDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
  mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mDeskDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
  mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mBroadcastWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock.setReferenceCounted(false);
  mEnableShiftMenuBugReports=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mLidOpenRotation=readRotation(com.android.internal.R.integer.config_lidOpenRotation);
  mCarDockRotation=readRotation(com.android.internal.R.integer.config_carDockRotation);
  mDeskDockRotation=readRotation(com.android.internal.R.integer.config_deskDockRotation);
  mCarDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_carDockKeepsScreenOn);
  mDeskDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_deskDockKeepsScreenOn);
  mCarDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
  mDeskDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
  mLidKeyboardAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
  mLidNavigationAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
  mBatteryStatusFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  mPlugged=0;
  updatePlugged(context.registerReceiver(null,mBatteryStatusFilter));
  context.registerReceiver(mDockReceiver,new IntentFilter(Intent.ACTION_DOCK_EVENT));
  mVibrator=new Vibrator();
  mLongPressVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_longPressVibePattern);
  mVirtualKeyVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_virtualKeyVibePattern);
  mSafeModeDisabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeDisabledVibePattern);
  mSafeModeEnabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeEnabledVibePattern);
}",0.9222109972579016
183053,"public void onReceive(Context context,Intent intent){
  mDockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
  updateKeepScreenOn();
  updateOrientationListenerLp();
}","public void onReceive(Context context,Intent intent){
  mDockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
  boolean watchBattery=mDockState != Intent.EXTRA_DOCK_STATE_UNDOCKED;
  if (watchBattery != mRegisteredBatteryReceiver) {
    mRegisteredBatteryReceiver=watchBattery;
    if (watchBattery) {
      updatePlugged(mContext.registerReceiver(mBatteryReceiver,mBatteryStatusFilter));
    }
 else {
      mContext.unregisterReceiver(mBatteryReceiver);
    }
  }
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
  updateDockKeepingScreenOn();
  updateOrientationListenerLp();
}",0.5944134078212291
183054,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}",0.9939223936418888
183055,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}",0.6966773847802786
183056,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}",0.7710011507479861
183057,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}",0.9988239905919248
183058,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}",0.8691006233303651
183059,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9546271338724168
183060,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}",0.6966773847802786
183061,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}",0.7710011507479861
183062,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}",0.9988239905919248
183063,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}",0.8691006233303651
183064,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9546271338724168
183065,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}",0.6966773847802786
183066,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}",0.7710011507479861
183067,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}",0.9988239905919248
183068,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}",0.8691006233303651
183069,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.9546271338724168
183070,"public void destroy(){
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","public void destroy(){
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}",0.7799227799227799
183071,"public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  Element.initPredefined(this);
}","public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  Element.initPredefined(this);
  mMessageThread=new MessageThread(this);
  mMessageThread.start();
}",0.8785714285714286
183072,"private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      if (cursor != null && cursor.getCount() == 1) {
        cursor.moveToFirst();
        return cursor.getString(2);
      }
 else {
        title=uri.getLastPathSegment();
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}","private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      try {
        if (cursor != null && cursor.getCount() == 1) {
          cursor.moveToFirst();
          return cursor.getString(2);
        }
 else {
          title=uri.getLastPathSegment();
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}",0.9545454545454546
183073,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}",0.9939223936418888
183074,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}",0.9939223936418888
183075,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}",0.9939223936418888
183076,"private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      if (cursor != null && cursor.getCount() == 1) {
        cursor.moveToFirst();
        return cursor.getString(2);
      }
 else {
        title=uri.getLastPathSegment();
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}","private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      try {
        if (cursor != null && cursor.getCount() == 1) {
          cursor.moveToFirst();
          return cursor.getString(2);
        }
 else {
          title=uri.getLastPathSegment();
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}",0.9545454545454546
183077,"@Override public void handleMessage(Message msg){
synchronized (this) {
    updateKeyguardLocked();
    Log.d(TAG,""String_Node_Str"" + mDockState);
    mPowerManager.userActivityWithForce(SystemClock.uptimeMillis(),false,true);
    Intent intent=new Intent(Intent.ACTION_DOCK_EVENT);
    intent.putExtra(Intent.EXTRA_DOCK_STATE,mDockState);
    mContext.sendStickyOrderedBroadcast(intent,mResultReceiver,null,Activity.RESULT_OK,null,null);
  }
}","@Override public void handleMessage(Message msg){
synchronized (this) {
    Log.i(TAG,""String_Node_Str"" + mDockState);
    if (Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) == 0) {
      Log.i(TAG,""String_Node_Str"");
      return;
    }
    mPowerManager.userActivityWithForce(SystemClock.uptimeMillis(),false,true);
    Intent intent=new Intent(Intent.ACTION_DOCK_EVENT);
    intent.putExtra(Intent.EXTRA_DOCK_STATE,mDockState);
    mContext.sendStickyOrderedBroadcast(intent,mResultReceiver,null,Activity.RESULT_OK,null,null);
  }
}",0.7976539589442815
183078,"private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}","private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}",0.9833353314950246
183079,"private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}",0.9616767517320004
183080,"private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}","private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}",0.9807953443258972
183081,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tagName);
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}",0.9911573472041612
183082,"private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}",0.918032786885246
183083,"private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}","private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}",0.9685714285714284
183084,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      Log.i(TAG,""String_Node_Str"" + npi.name + ""String_Node_Str""+ pkg.packageName);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}",0.9780292392830594
183085,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9872844013596878
183086,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9838539838539838
183087,"/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}","/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}",0.9989047097480832
183088,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  boolean hasSAMLAccount=false;
  if (hasAccount) {
    try {
      String[] features=new String[]{""String_Node_Str""};
      hasSAMLAccount=AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,null,null).getResult().length > 0;
    }
 catch (    Exception e) {
      hasSAMLAccount=true;
    }
  }
  mEnableFallback=hasAccount && !hasSAMLAccount;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  if (hasAccount) {
    String[] features=new String[]{""String_Node_Str""};
    AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,this,null);
  }
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}",0.9701114488348532
183089,"View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    return new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts(),mEnableFallback);
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}","View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    UnlockScreen view=new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    view.setEnableFallback(mEnableFallback);
    return view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}",0.952144188937228
183090,"/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts,boolean enableFallback){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mEnableFallback=enableFallback;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}","/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}",0.9529151291512916
183091,"int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}","int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    boolean lowerAnimating=mLowerWallpaperTarget.mAnimation != null || (mLowerWallpaperTarget.mAppToken != null && mLowerWallpaperTarget.mAppToken.animation != null);
    boolean upperAnimating=mUpperWallpaperTarget.mAnimation != null || (mUpperWallpaperTarget.mAppToken != null && mUpperWallpaperTarget.mAppToken.animation != null);
    if (!lowerAnimating || !upperAnimating) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}",0.969666973060878
183092,"/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      pi.activities=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      pi.receivers=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      pi.services=new ServiceInfo[N];
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      pi.providers=new ProviderInfo[N];
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}","/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}",0.6741494212556998
183093,"/** 
 * Trigger a dialog that lists the various methods of interacting with the requested   {@link Contacts} entry. This may be based on available{@link Data} rows under that contact, and may also include socialstatus and presence details.
 * @param context The parent {@link Context} that may be used as theparent for this dialog.
 * @param target Specific {@link Rect} that this dialog should becentered around, in screen coordinates. In particular, if the dialog has a ""callout"" arrow, it will be pointed and centered around this  {@link Rect}.
 * @param lookupUri A {@link Contacts#CONTENT_LOOKUP_URI} style{@link Uri} that describes a specific contact to featurein this dialog.
 * @param mode Any of {@link #MODE_SMALL},   {@link #MODE_MEDIUM}, or  {@link #MODE_LARGE}, indicating the desired dialog size, when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-typesto exclude when showing this dialog. For example, when already viewing the contact details card, this can be used to omit the details entry from the dialog.
 */
public static void showQuickContact(Context context,Rect target,Uri lookupUri,int mode,String[] excludeMimes){
  final Intent intent=new Intent(ACTION_QUICK_CONTACT);
  intent.setData(lookupUri);
  intent.putExtra(EXTRA_TARGET_RECT,target);
  intent.putExtra(EXTRA_MODE,mode);
  intent.putExtra(EXTRA_EXCLUDE_MIMES,excludeMimes);
  intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
  context.startActivity(intent);
}","/** 
 * Trigger a dialog that lists the various methods of interacting with the requested   {@link Contacts} entry. This may be based on available{@link Data} rows under that contact, and may also include socialstatus and presence details.
 * @param context The parent {@link Context} that may be used as theparent for this dialog.
 * @param target Specific {@link Rect} that this dialog should becentered around, in screen coordinates. In particular, if the dialog has a ""callout"" arrow, it will be pointed and centered around this  {@link Rect}.
 * @param lookupUri A {@link ContactsContract.Contacts#CONTENT_LOOKUP_URI} style{@link Uri} that describes a specific contact to featurein this dialog.
 * @param mode Any of {@link #MODE_SMALL},   {@link #MODE_MEDIUM}, or  {@link #MODE_LARGE}, indicating the desired dialog size, when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-typesto exclude when showing this dialog. For example, when already viewing the contact details card, this can be used to omit the details entry from the dialog.
 */
public static void showQuickContact(Context context,Rect target,Uri lookupUri,int mode,String[] excludeMimes){
  final Intent intent=new Intent(ACTION_QUICK_CONTACT);
  intent.setData(lookupUri);
  intent.putExtra(EXTRA_TARGET_RECT,target);
  intent.putExtra(EXTRA_MODE,mode);
  intent.putExtra(EXTRA_EXCLUDE_MIMES,excludeMimes);
  intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
  context.startActivity(intent);
}",0.994316282179873
183094,"public void saveMiniThumbToFile(byte[] data,long id,long magic) throws IOException {
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    if (data != null) {
      if (data.length > BYTES_PER_MINTHUMB - HEADER_SIZE) {
        return;
      }
      mBuffer.clear();
      mBuffer.put((byte)1);
      mBuffer.putLong(magic);
      mBuffer.putInt(data.length);
      mBuffer.put(data);
      mBuffer.flip();
      lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,false);
      mChannel.write(mBuffer,pos);
    }
  }
 catch (  IOException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str"",ex);
    throw ex;
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
}","public synchronized void saveMiniThumbToFile(byte[] data,long id,long magic) throws IOException {
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    if (data != null) {
      if (data.length > BYTES_PER_MINTHUMB - HEADER_SIZE) {
        return;
      }
      mBuffer.clear();
      mBuffer.put((byte)1);
      mBuffer.putLong(magic);
      mBuffer.putInt(data.length);
      mBuffer.put(data);
      mBuffer.flip();
      lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,false);
      mChannel.write(mBuffer,pos);
    }
  }
 catch (  IOException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str"",ex);
    throw ex;
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
}",0.9930145083288554
183095,"/** 
 * We store different types of thumbnails in different files. To remain backward compatibility, we should hashcode of content://media/external/images/media remains the same.
 */
public static synchronized void reset(){
  sThumbFiles.clear();
}","/** 
 * We store different types of thumbnails in different files. To remain backward compatibility, we should hashcode of content://media/external/images/media remains the same.
 */
public static synchronized void reset(){
  for (  MiniThumbFile file : sThumbFiles.values()) {
    file.deactivate();
  }
  sThumbFiles.clear();
}",0.8318890814558059
183096,"/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}","/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}",0.9946035699460356
183097,"public long getMagic(long id){
  RandomAccessFile r=miniThumbDataFile();
  if (r != null) {
    long pos=id * BYTES_PER_MINTHUMB;
    FileLock lock=null;
    try {
      mBuffer.clear();
      mBuffer.limit(1 + 8);
      lock=mChannel.lock(pos,1 + 8,true);
      if (mChannel.read(mBuffer,pos) == 9) {
        mBuffer.position(0);
        if (mBuffer.get() == 1) {
          return mBuffer.getLong();
        }
      }
    }
 catch (    IOException ex) {
      Log.v(TAG,""String_Node_Str"",ex);
    }
catch (    RuntimeException ex) {
      Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
    }
 finally {
      try {
        if (lock != null)         lock.release();
      }
 catch (      IOException ex) {
      }
    }
  }
  return 0;
}","public synchronized long getMagic(long id){
  RandomAccessFile r=miniThumbDataFile();
  if (r != null) {
    long pos=id * BYTES_PER_MINTHUMB;
    FileLock lock=null;
    try {
      mBuffer.clear();
      mBuffer.limit(1 + 8);
      lock=mChannel.lock(pos,1 + 8,true);
      if (mChannel.read(mBuffer,pos) == 9) {
        mBuffer.position(0);
        if (mBuffer.get() == 1) {
          return mBuffer.getLong();
        }
      }
    }
 catch (    IOException ex) {
      Log.v(TAG,""String_Node_Str"",ex);
    }
catch (    RuntimeException ex) {
      Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
    }
 finally {
      try {
        if (lock != null)         lock.release();
      }
 catch (      IOException ex) {
      }
    }
  }
  return 0;
}",0.9915198956294846
183098,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
Log.e(TAG,""String_Node_Str"");
mMediaServerOk=false;
AudioSystem.isMusicActive();
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
mMediaServerOk=true;
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isMusicActive();
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}",0.9435509303058972
183099,"private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}","private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}",0.9833353314950246
183100,"private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}",0.9616767517320004
183101,"private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}","private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}",0.9807953443258972
183102,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tagName);
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}",0.9911573472041612
183103,"private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}",0.918032786885246
183104,"private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}","private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}",0.9685714285714284
183105,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      Log.i(TAG,""String_Node_Str"" + npi.name + ""String_Node_Str""+ pkg.packageName);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}",0.9780292392830594
183106,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9872844013596878
183107,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9838539838539838
183108,"/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}","/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}",0.9989047097480832
183109,"private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}","private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}",0.9833353314950246
183110,"private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}",0.9616767517320004
183111,"private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}","private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}",0.9807953443258972
183112,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tagName);
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}",0.9911573472041612
183113,"private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}",0.918032786885246
183114,"private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}","private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}",0.9685714285714284
183115,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      Log.i(TAG,""String_Node_Str"" + npi.name + ""String_Node_Str""+ pkg.packageName);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}",0.9780292392830594
183116,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9872844013596878
183117,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9838539838539838
183118,"/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}","/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}",0.9989047097480832
183119,"/** 
 * Once we know that we have asked an application to put an activity in the resumed state (either by launching it or explicitly telling it), this function updates the rest of our state to match that fact.
 */
private final void completeResumeLocked(HistoryRecord next){
  next.idle=false;
  next.results=null;
  next.newIntents=null;
  Message msg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
  msg.obj=next;
  mHandler.sendMessageDelayed(msg,IDLE_TIMEOUT);
  if (false) {
    msg=mHandler.obtainMessage(IDLE_NOW_MSG);
    msg.obj=next;
    mHandler.sendMessage(msg);
  }
  reportResumedActivity(next);
  next.thumbnail=null;
  setFocusedActivityLocked(next);
  next.resumeKeyDispatchingLocked();
  ensureActivitiesVisibleLocked(null,0);
  mWindowManager.executeAppTransition();
  mNoAnimActivities.clear();
  if (next.app != null) {
synchronized (mProcessStatsThread) {
      next.cpuTimeAtResume=mProcessStats.getCpuTimeForPid(next.app.pid);
    }
  }
 else {
    next.cpuTimeAtResume=0;
  }
}","/** 
 * Once we know that we have asked an application to put an activity in the resumed state (either by launching it or explicitly telling it), this function updates the rest of our state to match that fact.
 */
private final void completeResumeLocked(HistoryRecord next){
  next.idle=false;
  next.results=null;
  next.newIntents=null;
  Message msg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
  msg.obj=next;
  mHandler.sendMessageDelayed(msg,IDLE_TIMEOUT);
  if (false) {
    msg=mHandler.obtainMessage(IDLE_NOW_MSG);
    msg.obj=next;
    mHandler.sendMessage(msg);
  }
  reportResumedActivityLocked(next);
  next.thumbnail=null;
  setFocusedActivityLocked(next);
  next.resumeKeyDispatchingLocked();
  ensureActivitiesVisibleLocked(null,0);
  mWindowManager.executeAppTransition();
  mNoAnimActivities.clear();
  if (next.app != null) {
synchronized (mProcessStatsThread) {
      next.cpuTimeAtResume=mProcessStats.getCpuTimeForPid(next.app.pid);
    }
  }
 else {
    next.cpuTimeAtResume=0;
  }
}",0.997
183120,"private final boolean relaunchActivityLocked(HistoryRecord r,int changes,boolean andResume){
  List<ResultInfo> results=null;
  List<Intent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
  EventLog.writeEvent(andResume ? LOG_AM_RELAUNCH_RESUME_ACTIVITY : LOG_AM_RELAUNCH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  try {
    if (DEBUG_SWITCH)     Log.i(TAG,""String_Node_Str"" + r);
    r.app.thread.scheduleRelaunchActivity(r,results,newIntents,changes,!andResume);
  }
 catch (  RemoteException e) {
    return false;
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
  }
  return true;
}","private final boolean relaunchActivityLocked(HistoryRecord r,int changes,boolean andResume){
  List<ResultInfo> results=null;
  List<Intent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
  EventLog.writeEvent(andResume ? LOG_AM_RELAUNCH_RESUME_ACTIVITY : LOG_AM_RELAUNCH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  try {
    if (DEBUG_SWITCH)     Log.i(TAG,""String_Node_Str"" + r);
    r.app.thread.scheduleRelaunchActivity(r,results,newIntents,changes,!andResume);
  }
 catch (  RemoteException e) {
    return false;
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
    reportResumedActivityLocked(r);
  }
  return true;
}",0.9796610169491524
183121,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  boolean hasSAMLAccount=false;
  if (hasAccount) {
    try {
      String[] features=new String[]{""String_Node_Str""};
      hasSAMLAccount=AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,null,null).getResult().length > 0;
    }
 catch (    Exception e) {
      hasSAMLAccount=true;
    }
  }
  mEnableFallback=hasAccount && !hasSAMLAccount;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  if (hasAccount) {
    String[] features=new String[]{""String_Node_Str""};
    AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,this,null);
  }
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}",0.9701114488348532
183122,"View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    return new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts(),mEnableFallback);
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}","View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    UnlockScreen view=new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    view.setEnableFallback(mEnableFallback);
    return view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}",0.952144188937228
183123,"/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts,boolean enableFallback){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mEnableFallback=enableFallback;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}","/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}",0.9529151291512916
183124,"/** 
 * Plays a sound effect (Key clicks, lid open/close...)
 * @param effectType The type of sound effect. One of{@link #FX_KEY_CLICK},  {@link #FX_FOCUS_NAVIGATION_UP},  {@link #FX_FOCUS_NAVIGATION_DOWN},  {@link #FX_FOCUS_NAVIGATION_LEFT},  {@link #FX_FOCUS_NAVIGATION_RIGHT},  {@link #FX_KEYPRESS_STANDARD},  {@link #FX_KEYPRESS_SPACEBAR},  {@link #FX_KEYPRESS_DELETE},  {@link #FX_KEYPRESS_RETURN},
 * @param volume Sound effect volumeNOTE: This version is for applications that have their own settings panel for enabling and controlling volume.
 */
public void playSoundEffect(int effectType,float volume){
  if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
    return;
  }
  IAudioService service=getService();
  try {
    service.playSoundEffectVolume(effectType,volume);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}","/** 
 * Plays a sound effect (Key clicks, lid open/close...)
 * @param effectType The type of sound effect. One of{@link #FX_KEY_CLICK},  {@link #FX_FOCUS_NAVIGATION_UP},  {@link #FX_FOCUS_NAVIGATION_DOWN},  {@link #FX_FOCUS_NAVIGATION_LEFT},  {@link #FX_FOCUS_NAVIGATION_RIGHT},  {@link #FX_KEYPRESS_STANDARD},  {@link #FX_KEYPRESS_SPACEBAR},  {@link #FX_KEYPRESS_DELETE},  {@link #FX_KEYPRESS_RETURN},
 * @param volume Sound effect volume.The volume value is a raw scalar so UI controls should be scaled logarithmically. If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used. NOTE: This version is for applications that have their own settings panel for enabling and controlling volume.
 */
public void playSoundEffect(int effectType,float volume){
  if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
    return;
  }
  IAudioService service=getService();
  try {
    service.playSoundEffectVolume(effectType,volume);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}",0.90443864229765
183125,"private void playSoundEffect(int effectType,int volume){
synchronized (mSoundEffectsLock) {
    if (mSoundPool == null) {
      return;
    }
    if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
      float v=(float)volume / 1000.0f;
      mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1],v,v,0,0,1.0f);
    }
 else {
      MediaPlayer mediaPlayer=new MediaPlayer();
      if (mediaPlayer != null) {
        try {
          String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effectType][0]];
          mediaPlayer.setDataSource(filePath);
          mediaPlayer.setAudioStreamType(AudioSystem.STREAM_SYSTEM);
          mediaPlayer.prepare();
          mediaPlayer.setOnCompletionListener(new OnCompletionListener(){
            public void onCompletion(            MediaPlayer mp){
              cleanupPlayer(mp);
            }
          }
);
          mediaPlayer.setOnErrorListener(new OnErrorListener(){
            public boolean onError(            MediaPlayer mp,            int what,            int extra){
              cleanupPlayer(mp);
              return true;
            }
          }
);
          mediaPlayer.start();
        }
 catch (        IOException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalArgumentException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalStateException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
      }
    }
  }
}","private void playSoundEffect(int effectType,int volume){
synchronized (mSoundEffectsLock) {
    if (mSoundPool == null) {
      return;
    }
    float volFloat;
    if (volume < 0) {
      float dBPerStep=(float)((0.5 * 100) / MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC]);
      int musicVolIndex=(mStreamStates[AudioSystem.STREAM_MUSIC].mIndex + 5) / 10;
      float musicVoldB=dBPerStep * (musicVolIndex - MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC]);
      volFloat=(float)Math.pow(10,(musicVoldB - 3) / 20);
    }
 else {
      volFloat=(float)volume / 1000.0f;
    }
    if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
      mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1],volFloat,volFloat,0,0,1.0f);
    }
 else {
      MediaPlayer mediaPlayer=new MediaPlayer();
      if (mediaPlayer != null) {
        try {
          String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effectType][0]];
          mediaPlayer.setDataSource(filePath);
          mediaPlayer.setAudioStreamType(AudioSystem.STREAM_SYSTEM);
          mediaPlayer.prepare();
          mediaPlayer.setVolume(volFloat,volFloat);
          mediaPlayer.setOnCompletionListener(new OnCompletionListener(){
            public void onCompletion(            MediaPlayer mp){
              cleanupPlayer(mp);
            }
          }
);
          mediaPlayer.setOnErrorListener(new OnErrorListener(){
            public boolean onError(            MediaPlayer mp,            int what,            int extra){
              cleanupPlayer(mp);
              return true;
            }
          }
);
          mediaPlayer.start();
        }
 catch (        IOException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalArgumentException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalStateException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
      }
    }
  }
}",0.8465063001145475
183126,"/** 
 * Loads samples into the soundpool. This method must be called at when sound effects are enabled
 */
public boolean loadSoundEffects(){
synchronized (mSoundEffectsLock) {
    mSoundPool=new SoundPool(NUM_SOUNDPOOL_CHANNELS,AudioSystem.STREAM_SYSTEM,0);
    if (mSoundPool == null) {
      return false;
    }
    int[] poolId=new int[SOUND_EFFECT_FILES.length];
    for (int fileIdx=0; fileIdx < SOUND_EFFECT_FILES.length; fileIdx++) {
      poolId[fileIdx]=-1;
    }
    for (int effect=0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
      if (SOUND_EFFECT_FILES_MAP[effect][1] == 0) {
        continue;
      }
      if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == -1) {
        String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effect][0]];
        int sampleId=mSoundPool.load(filePath,0);
        SOUND_EFFECT_FILES_MAP[effect][1]=sampleId;
        poolId[SOUND_EFFECT_FILES_MAP[effect][0]]=sampleId;
        if (sampleId <= 0) {
          Log.w(TAG,""String_Node_Str"" + filePath);
        }
      }
 else {
        SOUND_EFFECT_FILES_MAP[effect][1]=poolId[SOUND_EFFECT_FILES_MAP[effect][0]];
      }
    }
  }
  return true;
}","/** 
 * Loads samples into the soundpool. This method must be called at when sound effects are enabled
 */
public boolean loadSoundEffects(){
synchronized (mSoundEffectsLock) {
    if (mSoundPool != null) {
      return true;
    }
    mSoundPool=new SoundPool(NUM_SOUNDPOOL_CHANNELS,AudioSystem.STREAM_SYSTEM,0);
    if (mSoundPool == null) {
      return false;
    }
    int[] poolId=new int[SOUND_EFFECT_FILES.length];
    for (int fileIdx=0; fileIdx < SOUND_EFFECT_FILES.length; fileIdx++) {
      poolId[fileIdx]=-1;
    }
    for (int effect=0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
      if (SOUND_EFFECT_FILES_MAP[effect][1] == 0) {
        continue;
      }
      if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == -1) {
        String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effect][0]];
        int sampleId=mSoundPool.load(filePath,0);
        SOUND_EFFECT_FILES_MAP[effect][1]=sampleId;
        poolId[SOUND_EFFECT_FILES_MAP[effect][0]]=sampleId;
        if (sampleId <= 0) {
          Log.w(TAG,""String_Node_Str"" + filePath);
        }
      }
 else {
        SOUND_EFFECT_FILES_MAP[effect][1]=poolId[SOUND_EFFECT_FILES_MAP[effect][0]];
      }
    }
  }
  return true;
}",0.9777598059037608
183127,"/** 
 * @see AudioManager#playSoundEffect(int,float) 
 */
public void playSoundEffectVolume(int effectType,float volume){
  sendMsg(mAudioHandler,MSG_PLAY_SOUND_EFFECT,SHARED_MSG,SENDMSG_NOOP,effectType,(int)(volume * 1000),null,0);
}","/** 
 * @see AudioManager#playSoundEffect(int,float) 
 */
public void playSoundEffectVolume(int effectType,float volume){
  loadSoundEffects();
  sendMsg(mAudioHandler,MSG_PLAY_SOUND_EFFECT,SHARED_MSG,SENDMSG_NOOP,effectType,(int)(volume * 1000),null,0);
}",0.9551020408163264
183128,"public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : EditorInfo.TYPE_CLASS_TEXT;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}","public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mTextPaint.setCompatibilityScaling(getResources().getCompatibilityInfo().applicationScale);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setCompatibilityScaling(getResources().getCompatibilityInfo().applicationScale);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : EditorInfo.TYPE_CLASS_TEXT;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}",0.993377028928314
183129,"int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}","int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    boolean lowerAnimating=mLowerWallpaperTarget.mAnimation != null || (mLowerWallpaperTarget.mAppToken != null && mLowerWallpaperTarget.mAppToken.animation != null);
    boolean upperAnimating=mUpperWallpaperTarget.mAnimation != null || (mUpperWallpaperTarget.mAppToken != null && mUpperWallpaperTarget.mAppToken.animation != null);
    if (!lowerAnimating || !upperAnimating) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}",0.969666973060878
183130,"/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      pi.activities=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      pi.receivers=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      pi.services=new ServiceInfo[N];
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      pi.providers=new ProviderInfo[N];
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}","/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}",0.6741494212556998
183131,"/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      pi.activities=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      pi.receivers=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      pi.services=new ServiceInfo[N];
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      pi.providers=new ProviderInfo[N];
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}","/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}",0.6741494212556998
183132,"int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}","int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    boolean lowerAnimating=mLowerWallpaperTarget.mAnimation != null || (mLowerWallpaperTarget.mAppToken != null && mLowerWallpaperTarget.mAppToken.animation != null);
    boolean upperAnimating=mUpperWallpaperTarget.mAnimation != null || (mUpperWallpaperTarget.mAppToken != null && mUpperWallpaperTarget.mAppToken.animation != null);
    if (!lowerAnimating || !upperAnimating) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}",0.969666973060878
183133,"public void die(boolean immediate){
  checkThread();
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
synchronized (this) {
    if (mAdded && !mFirst) {
      int viewVisibility=mView.getVisibility();
      boolean viewVisibilityChanged=mViewVisibility != viewVisibility;
      if (mWindowAttributesChanged || viewVisibilityChanged) {
        try {
          if ((relayoutWindow(mWindowAttributes,viewVisibility,false) & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
            sWindowSession.finishDrawing(mWindow);
          }
        }
 catch (        RemoteException e) {
        }
      }
      mSurface.release();
    }
    if (mAdded) {
      mAdded=false;
      if (immediate) {
        dispatchDetachedFromWindow();
      }
 else       if (mView != null) {
        sendEmptyMessage(DIE);
      }
    }
  }
}","public void die(boolean immediate){
  if (immediate) {
    doDie();
  }
 else {
    sendEmptyMessage(DIE);
  }
}",0.2217700915564598
183134,"/** 
 * Called when the system is mostly done booting to dentermine whether the system should go into safe mode.
 */
public boolean detectSafeMode();","/** 
 * Called when the system is mostly done booting to determine whether the system should go into safe mode.
 */
public boolean detectSafeMode();",0.9966329966329966
183135,"/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length <= ND) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length <= NS) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}","/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length < (ND + (NP * NUM_SAMPLE_DATA))) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length < (NS + 1)) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}",0.9868457878533444
183136,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}",0.9991184249191888
183137,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9948186528497408
183138,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}",0.9940366972477064
183139,"void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDisplayedLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDisplayedLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDisplayedLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}","void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDrawnLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDrawnLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDrawnLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}",0.989010989010989
183140,"Element(){
  super(null);
  mID=0;
  mSize=0;
}","Element(RenderScript rs,int count){
  super(rs);
  mSize=0;
  mEntries=new Entry[count];
}",0.4963503649635036
183141,"public Element create(){
  Element e=new Element();
  e.mEntries=new Entry[mEntryCount];
  java.lang.System.arraycopy(mEntries,0,e.mEntries,0,mEntryCount);
  e.init(mRS);
  return e;
}","public Element create(){
  Element e=new Element(mRS,mEntryCount);
  java.lang.System.arraycopy(mEntries,0,e.mEntries,0,mEntryCount);
  e.init();
  return e;
}",0.9037900874635568
183142,"void init(RenderScript rs){
  mRS=rs;
  internalCreate(mRS,this);
}","void init(){
  internalCreate(mRS,this);
}",0.7706422018348624
183143,"static void initPredefined(RenderScript rs){
  USER_U8.mEntries=new Entry[1];
  USER_U8.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.USER,false,8,null);
  USER_U8.init(rs);
  USER_I8.mEntries=new Entry[1];
  USER_I8.mEntries[0]=new Entry(DataType.SIGNED,DataKind.USER,false,8,null);
  USER_I8.init(rs);
  USER_U16.mEntries=new Entry[1];
  USER_U16.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.USER,false,16,null);
  USER_U16.init(rs);
  USER_I16.mEntries=new Entry[1];
  USER_I16.mEntries[0]=new Entry(DataType.SIGNED,DataKind.USER,false,16,null);
  USER_I16.init(rs);
  USER_U32.mEntries=new Entry[1];
  USER_U32.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.USER,false,32,null);
  USER_U32.init(rs);
  USER_I32.mEntries=new Entry[1];
  USER_I32.mEntries[0]=new Entry(DataType.SIGNED,DataKind.USER,false,32,null);
  USER_I32.init(rs);
  USER_FLOAT.mEntries=new Entry[1];
  USER_FLOAT.mEntries[0]=new Entry(DataType.FLOAT,DataKind.USER,false,32,null);
  USER_FLOAT.init(rs);
  A_8.mEntries=new Entry[1];
  A_8.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,8,""String_Node_Str"");
  A_8.init(rs);
  RGB_565.mEntries=new Entry[3];
  RGB_565.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,5,""String_Node_Str"");
  RGB_565.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,6,""String_Node_Str"");
  RGB_565.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,5,""String_Node_Str"");
  RGB_565.init(rs);
  RGB_888.mEntries=new Entry[3];
  RGB_888.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,8,""String_Node_Str"");
  RGB_888.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,8,""String_Node_Str"");
  RGB_888.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,8,""String_Node_Str"");
  RGB_888.init(rs);
  RGBA_5551.mEntries=new Entry[4];
  RGBA_5551.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,5,""String_Node_Str"");
  RGBA_5551.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,5,""String_Node_Str"");
  RGBA_5551.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,5,""String_Node_Str"");
  RGBA_5551.mEntries[3]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,1,""String_Node_Str"");
  RGBA_5551.init(rs);
  RGBA_4444.mEntries=new Entry[4];
  RGBA_4444.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,4,""String_Node_Str"");
  RGBA_4444.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,4,""String_Node_Str"");
  RGBA_4444.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,4,""String_Node_Str"");
  RGBA_4444.mEntries[3]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,4,""String_Node_Str"");
  RGBA_4444.init(rs);
  RGBA_8888.mEntries=new Entry[4];
  RGBA_8888.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,8,""String_Node_Str"");
  RGBA_8888.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,8,""String_Node_Str"");
  RGBA_8888.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,8,""String_Node_Str"");
  RGBA_8888.mEntries[3]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,8,""String_Node_Str"");
  RGBA_8888.init(rs);
  INDEX_16.mEntries=new Entry[1];
  INDEX_16.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.INDEX,false,16,""String_Node_Str"");
  INDEX_16.init(rs);
  XY_F32.mEntries=new Entry[2];
  XY_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  XY_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  XY_F32.init(rs);
  XYZ_F32.mEntries=new Entry[3];
  XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  XYZ_F32.init(rs);
  ST_XY_F32.mEntries=new Entry[4];
  ST_XY_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.S,false,32,""String_Node_Str"");
  ST_XY_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.T,false,32,""String_Node_Str"");
  ST_XY_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  ST_XY_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  ST_XY_F32.init(rs);
  ST_XYZ_F32.mEntries=new Entry[5];
  ST_XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.S,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.T,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[4]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  ST_XYZ_F32.init(rs);
  NORM_XYZ_F32.mEntries=new Entry[6];
  NORM_XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.NX,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.NY,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.NZ,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[4]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[5]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  NORM_XYZ_F32.init(rs);
  NORM_ST_XYZ_F32.mEntries=new Entry[8];
  NORM_ST_XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.NX,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.NY,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.NZ,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.S,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[4]=new Entry(DataType.FLOAT,DataKind.T,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[5]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[6]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[7]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.init(rs);
  rs.nInitElements(A_8.mID,RGBA_4444.mID,RGBA_8888.mID,RGB_565.mID);
}","static void initPredefined(RenderScript rs){
  rs.nInitElements(A_8(rs).mID,RGBA_4444(rs).mID,RGBA_8888(rs).mID,RGB_565(rs).mID);
}",0.0363866476823287
183144,"public MatrixAllocation(RenderScript rs){
  mModel=new Matrix();
  mProjection=new Matrix();
  mTexture=new Matrix();
  mAlloc=Allocation.createSized(rs,Element.USER_FLOAT,48);
  mAlloc.subData1D(MODELVIEW_OFFSET,16,mModel.mMat);
  mAlloc.subData1D(PROJECTION_OFFSET,16,mProjection.mMat);
  mAlloc.subData1D(TEXTURE_OFFSET,16,mTexture.mMat);
}","public MatrixAllocation(RenderScript rs){
  mModel=new Matrix();
  mProjection=new Matrix();
  mTexture=new Matrix();
  mAlloc=Allocation.createSized(rs,Element.USER_F32(rs),48);
  mAlloc.subData1D(MODELVIEW_OFFSET,16,mModel.mMat);
  mAlloc.subData1D(PROJECTION_OFFSET,16,mProjection.mMat);
  mAlloc.subData1D(TEXTURE_OFFSET,16,mTexture.mMat);
}",0.9854651162790696
183145,"public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  if (!mElementsInitialized) {
    Element.initPredefined(this);
    mElementsInitialized=true;
  }
}","public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  Element.initPredefined(this);
}",0.8392857142857143
183146,"public SimpleMesh create(){
  Element.Builder b=new Element.Builder(mRS);
  int floatCount=mVtxSize;
  if (mVtxSize == 2) {
    b.addFloatXY();
  }
 else {
    b.addFloatXYZ();
  }
  if (mTex) {
    floatCount+=2;
    b.addFloatST();
  }
  if (mNorm) {
    floatCount+=3;
    b.addFloatNorm();
  }
  mElement=b.create();
  Builder smb=new Builder(mRS);
  smb.addVertexType(mElement,mVtxCount / floatCount);
  smb.setIndexType(Element.INDEX_16,mIndexCount);
  smb.setPrimitive(Primitive.TRIANGLE);
  SimpleMesh sm=smb.create();
  Allocation vertexAlloc=sm.createVertexAllocation(0);
  Allocation indexAlloc=sm.createIndexAllocation();
  sm.bindVertexAllocation(vertexAlloc,0);
  sm.bindIndexAllocation(indexAlloc);
  vertexAlloc.data(mVtxData);
  vertexAlloc.uploadToBufferObject();
  indexAlloc.data(mIndexData);
  indexAlloc.uploadToBufferObject();
  return sm;
}","public SimpleMesh create(){
  Element.Builder b=new Element.Builder(mRS);
  int floatCount=mVtxSize;
  if (mVtxSize == 2) {
    b.addFloatXY();
  }
 else {
    b.addFloatXYZ();
  }
  if (mTex) {
    floatCount+=2;
    b.addFloatST();
  }
  if (mNorm) {
    floatCount+=3;
    b.addFloatNorm();
  }
  mElement=b.create();
  Builder smb=new Builder(mRS);
  smb.addVertexType(mElement,mVtxCount / floatCount);
  smb.setIndexType(Element.INDEX_16(mRS),mIndexCount);
  smb.setPrimitive(Primitive.TRIANGLE);
  SimpleMesh sm=smb.create();
  Allocation vertexAlloc=sm.createVertexAllocation(0);
  Allocation indexAlloc=sm.createIndexAllocation();
  sm.bindVertexAllocation(vertexAlloc,0);
  sm.bindIndexAllocation(indexAlloc);
  vertexAlloc.data(mVtxData);
  vertexAlloc.uploadToBufferObject();
  indexAlloc.data(mIndexData);
  indexAlloc.uploadToBufferObject();
  return sm;
}",0.9971148297749568
183147,"public void add(Dimension d,int value){
  if (mEntries.length >= mEntryCount) {
    Entry[] en=new Entry[mEntryCount + 8];
    System.arraycopy(mEntries,0,en,0,mEntries.length);
    mEntries=en;
  }
  mEntries[mEntryCount]=new Entry();
  mEntries[mEntryCount].mDim=d;
  mEntries[mEntryCount].mValue=value;
  mEntryCount++;
}","public void add(Dimension d,int value){
  if (value < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (mEntries.length >= mEntryCount) {
    Entry[] en=new Entry[mEntryCount + 8];
    System.arraycopy(mEntries,0,en,0,mEntries.length);
    mEntries=en;
  }
  mEntries[mEntryCount]=new Entry();
  mEntries[mEntryCount].mDim=d;
  mEntries[mEntryCount].mValue=value;
  mEntryCount++;
}",0.8876712328767123
183148,"public Builder(RenderScript rs,Element e){
  mRS=rs;
  mEntries=new Entry[4];
  mElement=e;
}","public Builder(RenderScript rs,Element e){
  if (e.mID == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mRS=rs;
  mEntries=new Entry[4];
  mElement=e;
}",0.6914498141263941
183149,"private void loadImages(){
  mBufferIDs=new int[13];
  mImages=new Allocation[13];
  mAllocIDs=Allocation.createSized(mRS,Element.USER_FLOAT,mBufferIDs.length);
  Element ie=Element.RGB_565;
  mImages[0]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p01,ie,true);
  mImages[1]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p02,ie,true);
  mImages[2]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p03,ie,true);
  mImages[3]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p04,ie,true);
  mImages[4]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p05,ie,true);
  mImages[5]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p06,ie,true);
  mImages[6]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p07,ie,true);
  mImages[7]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p08,ie,true);
  mImages[8]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p09,ie,true);
  mImages[9]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p10,ie,true);
  mImages[10]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p11,ie,true);
  mImages[11]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p12,ie,true);
  mImages[12]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p13,ie,true);
  int black[]=new int[1024];
  for (int ct=0; ct < mImages.length; ct++) {
    Allocation.Adapter2D a=mImages[ct].createAdapter2D();
    int size=512;
    int mip=0;
    while (size >= 2) {
      a.subData(0,0,2,size,black);
      a.subData(size - 2,0,2,size,black);
      a.subData(0,0,size,2,black);
      a.subData(0,size - 2,size,2,black);
      size>>=1;
      mip++;
      a.setConstraint(Dimension.LOD,mip);
    }
    mImages[ct].uploadToTexture(1);
    mBufferIDs[ct]=mImages[ct].getID();
  }
  mAllocIDs.data(mBufferIDs);
}","private void loadImages(){
  mBufferIDs=new int[13];
  mImages=new Allocation[13];
  mAllocIDs=Allocation.createSized(mRS,Element.USER_F32(mRS),mBufferIDs.length);
  Element ie=Element.RGB_565(mRS);
  mImages[0]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p01,ie,true);
  mImages[1]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p02,ie,true);
  mImages[2]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p03,ie,true);
  mImages[3]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p04,ie,true);
  mImages[4]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p05,ie,true);
  mImages[5]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p06,ie,true);
  mImages[6]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p07,ie,true);
  mImages[7]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p08,ie,true);
  mImages[8]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p09,ie,true);
  mImages[9]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p10,ie,true);
  mImages[10]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p11,ie,true);
  mImages[11]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p12,ie,true);
  mImages[12]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p13,ie,true);
  int black[]=new int[1024];
  for (int ct=0; ct < mImages.length; ct++) {
    Allocation.Adapter2D a=mImages[ct].createAdapter2D();
    int size=512;
    int mip=0;
    while (size >= 2) {
      a.subData(0,0,2,size,black);
      a.subData(size - 2,0,2,size,black);
      a.subData(0,0,size,2,black);
      a.subData(0,size - 2,size,2,black);
      size>>=1;
      mip++;
      a.setConstraint(Dimension.LOD,mip);
    }
    mImages[ct].uploadToTexture(1);
    mBufferIDs[ct]=mImages[ct].getID();
  }
  mAllocIDs.data(mBufferIDs);
}",0.9957310565635006
183150,"private void initState(){
  mBufferState=new int[10];
  mAllocState=Allocation.createSized(mRS,Element.USER_FLOAT,mBufferState.length);
  mBufferState[STATE_LAST_FOCUS]=-1;
  mAllocState.data(mBufferState);
}","private void initState(){
  mBufferState=new int[10];
  mAllocState=Allocation.createSized(mRS,Element.USER_F32(mRS),mBufferState.length);
  mBufferState[STATE_LAST_FOCUS]=-1;
  mAllocState.data(mBufferState);
}",0.973747016706444
183151,"private void initRS(){
  mFSM=new FilmStripMesh();
  mMesh=mFSM.init(mRS);
  mMesh.setName(""String_Node_Str"");
  initPFS();
  initPF();
  initPV();
  Log.e(""String_Node_Str"",""String_Node_Str"");
  mStripPositionType=Type.createFromClass(mRS,StripPosition.class,1);
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.filmstrip);
  sb.setRoot(true);
  sb.setType(mStripPositionType,""String_Node_Str"",1);
  mScriptStrip=sb.create();
  mScriptStrip.setClearColor(0.0f,0.0f,0.0f,1.0f);
  mAllocPos=Allocation.createTyped(mRS,mStripPositionType);
  loadImages();
  initState();
  mPVA=new ProgramVertex.MatrixAllocation(mRS);
  mPVBackground.bindAllocation(mPVA);
  mPVImages.bindAllocation(mPVA);
  mPVA.setupProjectionNormalized(320,480);
  mScriptStrip.bindAllocation(mAllocIDs,0);
  mScriptStrip.bindAllocation(mAllocPos,1);
  mScriptStrip.bindAllocation(mAllocState,2);
  mScriptStrip.bindAllocation(mPVA.mAlloc,3);
  mAllocOffsets=Allocation.createSized(mRS,Element.USER_I32,mFSM.mTriangleOffsets.length);
  mAllocOffsets.data(mFSM.mTriangleOffsets);
  mScriptStrip.bindAllocation(mAllocOffsets,4);
  mAllocOffsetsTex=Allocation.createSized(mRS,Element.USER_FLOAT,mFSM.mTriangleOffsetsTex.length);
  mAllocOffsetsTex.data(mFSM.mTriangleOffsetsTex);
  mScriptStrip.bindAllocation(mAllocOffsetsTex,5);
  setFilmStripPosition(0,0);
  mRS.contextBindRootScript(mScriptStrip);
}","private void initRS(){
  mFSM=new FilmStripMesh();
  mMesh=mFSM.init(mRS);
  mMesh.setName(""String_Node_Str"");
  initPFS();
  initPF();
  initPV();
  Log.e(""String_Node_Str"",""String_Node_Str"");
  mStripPositionType=Type.createFromClass(mRS,StripPosition.class,1);
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.filmstrip);
  sb.setRoot(true);
  sb.setType(mStripPositionType,""String_Node_Str"",1);
  mScriptStrip=sb.create();
  mScriptStrip.setClearColor(0.0f,0.0f,0.0f,1.0f);
  mAllocPos=Allocation.createTyped(mRS,mStripPositionType);
  loadImages();
  initState();
  mPVA=new ProgramVertex.MatrixAllocation(mRS);
  mPVBackground.bindAllocation(mPVA);
  mPVImages.bindAllocation(mPVA);
  mPVA.setupProjectionNormalized(320,480);
  mScriptStrip.bindAllocation(mAllocIDs,0);
  mScriptStrip.bindAllocation(mAllocPos,1);
  mScriptStrip.bindAllocation(mAllocState,2);
  mScriptStrip.bindAllocation(mPVA.mAlloc,3);
  mAllocOffsets=Allocation.createSized(mRS,Element.USER_I32(mRS),mFSM.mTriangleOffsets.length);
  mAllocOffsets.data(mFSM.mTriangleOffsets);
  mScriptStrip.bindAllocation(mAllocOffsets,4);
  mAllocOffsetsTex=Allocation.createSized(mRS,Element.USER_F32(mRS),mFSM.mTriangleOffsetsTex.length);
  mAllocOffsetsTex.data(mFSM.mTriangleOffsetsTex);
  mScriptStrip.bindAllocation(mAllocOffsetsTex,5);
  setFilmStripPosition(0,0);
  mRS.contextBindRootScript(mScriptStrip);
}",0.8991416309012875
183152,"private void initNamed(){
  Sampler.Builder sb=new Sampler.Builder(mRS);
  sb.setMin(Sampler.Value.LINEAR);
  sb.setMag(Sampler.Value.LINEAR);
  sb.setWrapS(Sampler.Value.CLAMP);
  sb.setWrapT(Sampler.Value.CLAMP);
  mSampler=sb.create();
  sb.setMin(Sampler.Value.NEAREST);
  sb.setMag(Sampler.Value.NEAREST);
  mSamplerText=sb.create();
  ProgramFragment.Builder bf=new ProgramFragment.Builder(mRS,null,null);
  bf.setTexEnable(true,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFImages=bf.create();
  mPFImages.setName(""String_Node_Str"");
  mPFImages.bindSampler(mSampler,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFText=bf.create();
  mPFText.setName(""String_Node_Str"");
  mPFText.bindSampler(mSamplerText,0);
  ProgramStore.Builder bs=new ProgramStore.Builder(mRS,null,null);
  bs.setDepthFunc(ProgramStore.DepthFunc.LESS);
  bs.setDitherEnable(false);
  bs.setDepthMask(true);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSBackground=bs.create();
  mPSBackground.setName(""String_Node_Str"");
  bs.setDepthFunc(ProgramStore.DepthFunc.ALWAYS);
  bs.setDepthMask(false);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSText=bs.create();
  mPSText.setName(""String_Node_Str"");
  mPVAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVAlloc.setupProjectionNormalized(mWidth,mHeight);
  ProgramVertex.Builder pvb=new ProgramVertex.Builder(mRS,null,null);
  mPV=pvb.create();
  mPV.setName(""String_Node_Str"");
  mPV.bindAllocation(mPVAlloc);
  mPVOrthoAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVOrthoAlloc.setupOrthoWindow(mWidth,mHeight);
  pvb.setTextureMatrixEnable(true);
  mPVOrtho=pvb.create();
  mPVOrtho.setName(""String_Node_Str"");
  mPVOrtho.bindAllocation(mPVOrthoAlloc);
  mRS.contextBindProgramVertex(mPV);
  mAllocScratchBuf=new int[32];
  mAllocScratch=Allocation.createSized(mRS,Element.USER_I32,mAllocScratchBuf.length);
  mAllocScratch.data(mAllocScratchBuf);
  Log.e(""String_Node_Str"",""String_Node_Str"");
{
    mIcons=new Allocation[29];
    mAllocIconIDBuf=new int[mIcons.length];
    mAllocIconID=Allocation.createSized(mRS,Element.USER_I32,mAllocIconIDBuf.length);
    mLabels=new Allocation[29];
    mAllocLabelIDBuf=new int[mLabels.length];
    mAllocLabelID=Allocation.createSized(mRS,Element.USER_I32,mLabels.length);
    Element ie8888=Element.RGBA_8888;
    mIcons[0]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.browser,ie8888,true);
    mIcons[1]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.market,ie8888,true);
    mIcons[2]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.photos,ie8888,true);
    mIcons[3]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.settings,ie8888,true);
    mIcons[4]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.calendar,ie8888,true);
    mIcons[5]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g1155,ie8888,true);
    mIcons[6]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g2140,ie8888,true);
    mIcons[7]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.maps,ie8888,true);
    mIcons[8]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path431,ie8888,true);
    mIcons[9]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path676,ie8888,true);
    mIcons[10]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path754,ie8888,true);
    mIcons[11]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path815,ie8888,true);
    mIcons[12]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1920,ie8888,true);
    mIcons[13]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1927,ie8888,true);
    mIcons[14]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3099,ie8888,true);
    mIcons[15]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3950,ie8888,true);
    mIcons[16]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path4481,ie8888,true);
    mIcons[17]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path5168,ie8888,true);
    mIcons[18]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.polygon2408,ie8888,true);
    mLabels[0]=makeTextBitmap(""String_Node_Str"");
    mLabels[1]=makeTextBitmap(""String_Node_Str"");
    mLabels[2]=makeTextBitmap(""String_Node_Str"");
    mLabels[3]=makeTextBitmap(""String_Node_Str"");
    mLabels[4]=makeTextBitmap(""String_Node_Str"");
    mLabels[5]=makeTextBitmap(""String_Node_Str"");
    mLabels[6]=makeTextBitmap(""String_Node_Str"");
    mLabels[7]=makeTextBitmap(""String_Node_Str"");
    mLabels[8]=makeTextBitmap(""String_Node_Str"");
    mLabels[9]=makeTextBitmap(""String_Node_Str"");
    mLabels[10]=makeTextBitmap(""String_Node_Str"");
    mLabels[11]=makeTextBitmap(""String_Node_Str"");
    mLabels[12]=makeTextBitmap(""String_Node_Str"");
    mLabels[13]=makeTextBitmap(""String_Node_Str"");
    mLabels[14]=makeTextBitmap(""String_Node_Str"");
    mLabels[15]=makeTextBitmap(""String_Node_Str"");
    mLabels[16]=makeTextBitmap(""String_Node_Str"");
    mLabels[17]=makeTextBitmap(""String_Node_Str"");
    mLabels[18]=makeTextBitmap(""String_Node_Str"");
    mIcons[19]=mIcons[0];
    mIcons[20]=mIcons[1];
    mIcons[21]=mIcons[2];
    mIcons[22]=mIcons[3];
    mIcons[23]=mIcons[4];
    mIcons[24]=mIcons[5];
    mIcons[25]=mIcons[6];
    mIcons[26]=mIcons[7];
    mIcons[27]=mIcons[8];
    mIcons[28]=mIcons[9];
    mLabels[19]=mLabels[0];
    mLabels[20]=mLabels[1];
    mLabels[21]=mLabels[2];
    mLabels[22]=mLabels[3];
    mLabels[23]=mLabels[4];
    mLabels[24]=mLabels[5];
    mLabels[25]=mLabels[6];
    mLabels[26]=mLabels[7];
    mLabels[27]=mLabels[8];
    mLabels[28]=mLabels[9];
    for (int ct=0; ct < mIcons.length; ct++) {
      mIcons[ct].uploadToTexture(0);
      mLabels[ct].uploadToTexture(0);
      mAllocIconIDBuf[ct]=mIcons[ct].getID();
      mAllocLabelIDBuf[ct]=mLabels[ct].getID();
    }
    mAllocIconID.data(mAllocIconIDBuf);
    mAllocLabelID.data(mAllocLabelIDBuf);
  }
}","private void initNamed(){
  Sampler.Builder sb=new Sampler.Builder(mRS);
  sb.setMin(Sampler.Value.LINEAR);
  sb.setMag(Sampler.Value.LINEAR);
  sb.setWrapS(Sampler.Value.CLAMP);
  sb.setWrapT(Sampler.Value.CLAMP);
  mSampler=sb.create();
  sb.setMin(Sampler.Value.NEAREST);
  sb.setMag(Sampler.Value.NEAREST);
  mSamplerText=sb.create();
  ProgramFragment.Builder bf=new ProgramFragment.Builder(mRS,null,null);
  bf.setTexEnable(true,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFImages=bf.create();
  mPFImages.setName(""String_Node_Str"");
  mPFImages.bindSampler(mSampler,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFText=bf.create();
  mPFText.setName(""String_Node_Str"");
  mPFText.bindSampler(mSamplerText,0);
  ProgramStore.Builder bs=new ProgramStore.Builder(mRS,null,null);
  bs.setDepthFunc(ProgramStore.DepthFunc.LESS);
  bs.setDitherEnable(false);
  bs.setDepthMask(true);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSBackground=bs.create();
  mPSBackground.setName(""String_Node_Str"");
  bs.setDepthFunc(ProgramStore.DepthFunc.ALWAYS);
  bs.setDepthMask(false);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSText=bs.create();
  mPSText.setName(""String_Node_Str"");
  mPVAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVAlloc.setupProjectionNormalized(mWidth,mHeight);
  ProgramVertex.Builder pvb=new ProgramVertex.Builder(mRS,null,null);
  mPV=pvb.create();
  mPV.setName(""String_Node_Str"");
  mPV.bindAllocation(mPVAlloc);
  mPVOrthoAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVOrthoAlloc.setupOrthoWindow(mWidth,mHeight);
  pvb.setTextureMatrixEnable(true);
  mPVOrtho=pvb.create();
  mPVOrtho.setName(""String_Node_Str"");
  mPVOrtho.bindAllocation(mPVOrthoAlloc);
  mRS.contextBindProgramVertex(mPV);
  mAllocScratchBuf=new int[32];
  mAllocScratch=Allocation.createSized(mRS,Element.USER_I32(mRS),mAllocScratchBuf.length);
  mAllocScratch.data(mAllocScratchBuf);
  Log.e(""String_Node_Str"",""String_Node_Str"");
{
    mIcons=new Allocation[29];
    mAllocIconIDBuf=new int[mIcons.length];
    mAllocIconID=Allocation.createSized(mRS,Element.USER_I32(mRS),mAllocIconIDBuf.length);
    mLabels=new Allocation[29];
    mAllocLabelIDBuf=new int[mLabels.length];
    mAllocLabelID=Allocation.createSized(mRS,Element.USER_I32(mRS),mLabels.length);
    Element ie8888=Element.RGBA_8888(mRS);
    mIcons[0]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.browser,ie8888,true);
    mIcons[1]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.market,ie8888,true);
    mIcons[2]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.photos,ie8888,true);
    mIcons[3]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.settings,ie8888,true);
    mIcons[4]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.calendar,ie8888,true);
    mIcons[5]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g1155,ie8888,true);
    mIcons[6]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g2140,ie8888,true);
    mIcons[7]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.maps,ie8888,true);
    mIcons[8]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path431,ie8888,true);
    mIcons[9]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path676,ie8888,true);
    mIcons[10]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path754,ie8888,true);
    mIcons[11]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path815,ie8888,true);
    mIcons[12]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1920,ie8888,true);
    mIcons[13]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1927,ie8888,true);
    mIcons[14]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3099,ie8888,true);
    mIcons[15]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3950,ie8888,true);
    mIcons[16]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path4481,ie8888,true);
    mIcons[17]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path5168,ie8888,true);
    mIcons[18]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.polygon2408,ie8888,true);
    mLabels[0]=makeTextBitmap(""String_Node_Str"");
    mLabels[1]=makeTextBitmap(""String_Node_Str"");
    mLabels[2]=makeTextBitmap(""String_Node_Str"");
    mLabels[3]=makeTextBitmap(""String_Node_Str"");
    mLabels[4]=makeTextBitmap(""String_Node_Str"");
    mLabels[5]=makeTextBitmap(""String_Node_Str"");
    mLabels[6]=makeTextBitmap(""String_Node_Str"");
    mLabels[7]=makeTextBitmap(""String_Node_Str"");
    mLabels[8]=makeTextBitmap(""String_Node_Str"");
    mLabels[9]=makeTextBitmap(""String_Node_Str"");
    mLabels[10]=makeTextBitmap(""String_Node_Str"");
    mLabels[11]=makeTextBitmap(""String_Node_Str"");
    mLabels[12]=makeTextBitmap(""String_Node_Str"");
    mLabels[13]=makeTextBitmap(""String_Node_Str"");
    mLabels[14]=makeTextBitmap(""String_Node_Str"");
    mLabels[15]=makeTextBitmap(""String_Node_Str"");
    mLabels[16]=makeTextBitmap(""String_Node_Str"");
    mLabels[17]=makeTextBitmap(""String_Node_Str"");
    mLabels[18]=makeTextBitmap(""String_Node_Str"");
    mIcons[19]=mIcons[0];
    mIcons[20]=mIcons[1];
    mIcons[21]=mIcons[2];
    mIcons[22]=mIcons[3];
    mIcons[23]=mIcons[4];
    mIcons[24]=mIcons[5];
    mIcons[25]=mIcons[6];
    mIcons[26]=mIcons[7];
    mIcons[27]=mIcons[8];
    mIcons[28]=mIcons[9];
    mLabels[19]=mLabels[0];
    mLabels[20]=mLabels[1];
    mLabels[21]=mLabels[2];
    mLabels[22]=mLabels[3];
    mLabels[23]=mLabels[4];
    mLabels[24]=mLabels[5];
    mLabels[25]=mLabels[6];
    mLabels[26]=mLabels[7];
    mLabels[27]=mLabels[8];
    mLabels[28]=mLabels[9];
    for (int ct=0; ct < mIcons.length; ct++) {
      mIcons[ct].uploadToTexture(0);
      mLabels[ct].uploadToTexture(0);
      mAllocIconIDBuf[ct]=mIcons[ct].getID();
      mAllocLabelIDBuf[ct]=mLabels[ct].getID();
    }
    mAllocIconID.data(mAllocIconIDBuf);
    mAllocLabelID.data(mAllocLabelIDBuf);
  }
}",0.9983133749367517
183153,"private void initRS(){
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.rollo);
  sb.setRoot(true);
  mScript=sb.create();
  mScript.setClearColor(0.0f,0.0f,0.0f,0.0f);
  mAllocStateBuf=new int[]{0,0,0,8,0,0,-1,0,mAllocIconIDBuf.length,0,0};
  mAllocState=Allocation.createSized(mRS,Element.USER_I32,mAllocStateBuf.length);
  mScript.bindAllocation(mAllocState,0);
  mScript.bindAllocation(mAllocIconID,1);
  mScript.bindAllocation(mAllocScratch,2);
  mScript.bindAllocation(mAllocLabelID,3);
  setPosition(0);
  setZoom(1);
  mRS.contextBindRootScript(mScript);
}","private void initRS(){
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.rollo);
  sb.setRoot(true);
  mScript=sb.create();
  mScript.setClearColor(0.0f,0.0f,0.0f,0.0f);
  mAllocStateBuf=new int[]{0,0,0,8,0,0,-1,0,mAllocIconIDBuf.length,0,0};
  mAllocState=Allocation.createSized(mRS,Element.USER_I32(mRS),mAllocStateBuf.length);
  mScript.bindAllocation(mAllocState,0);
  mScript.bindAllocation(mAllocIconID,1);
  mScript.bindAllocation(mAllocScratch,2);
  mScript.bindAllocation(mAllocLabelID,3);
  setPosition(0);
  setZoom(1);
  mRS.contextBindRootScript(mScript);
}",0.995766299745978
183154,"Allocation makeTextBitmap(String t){
  Bitmap b=Bitmap.createBitmap(128,32,Bitmap.Config.ARGB_8888);
  Canvas c=new Canvas(b);
  Paint p=new Paint();
  p.setTypeface(Typeface.DEFAULT_BOLD);
  p.setTextSize(20);
  p.setColor(0xffffffff);
  c.drawText(t,2,26,p);
  return Allocation.createFromBitmap(mRS,b,Element.RGBA_8888,true);
}","Allocation makeTextBitmap(String t){
  Bitmap b=Bitmap.createBitmap(128,32,Bitmap.Config.ARGB_8888);
  Canvas c=new Canvas(b);
  Paint p=new Paint();
  p.setTypeface(Typeface.DEFAULT_BOLD);
  p.setTextSize(20);
  p.setColor(0xffffffff);
  c.drawText(t,2,26,p);
  return Allocation.createFromBitmap(mRS,b,Element.RGBA_8888(mRS),true);
}",0.9924812030075189
183155,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}",0.9991184249191888
183156,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9948186528497408
183157,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}",0.9940366972477064
183158,"void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDisplayedLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDisplayedLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDisplayedLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}","void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDrawnLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDrawnLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDrawnLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}",0.989010989010989
183159,"/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final long contactId=c.getLong(HEADER_CONTACT_ID_COLUMN_INDEX);
  final String lookupKey=c.getString(HEADER_LOOKUP_KEY_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  mPhotoView.assignContactUri(Contacts.getLookupUri(contactId,lookupKey));
  int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
  mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
}","/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final long contactId=c.getLong(HEADER_CONTACT_ID_COLUMN_INDEX);
  final String lookupKey=c.getString(HEADER_LOOKUP_KEY_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  mPhotoView.assignContactUri(Contacts.getLookupUri(contactId,lookupKey));
  if (!c.isNull(HEADER_PRESENCE_STATUS_COLUMN_INDEX)) {
    int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
    mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
    mPresenceView.setVisibility(View.VISIBLE);
  }
 else {
    mPresenceView.setVisibility(View.GONE);
  }
}",0.9005186232909005
183160,"/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length <= ND) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length <= NS) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}","/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length < (ND + (NP * NUM_SAMPLE_DATA))) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length < (NS + 1)) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}",0.9868457878533444
183161,"/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length <= ND) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length <= NS) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}","/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length < (ND + (NP * NUM_SAMPLE_DATA))) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length < (NS + 1)) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}",0.9868457878533444
183162,"final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward){
  unscheduleGcIdler();
  ActivityRecord r=performResumeActivity(token,clearHide);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    if (r.window == null && !a.mFinished && !a.mStartedActivity) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (a.mVisibleFromClient) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (a.mStartedActivity) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    if (!r.activity.mFinished && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChanged(r.activity,r.newConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        ViewManager wm=a.getWindowManager();
        View decor=r.window.getDecorView();
        wm.updateViewLayout(decor,l);
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    r.nextIdle=mNewActivities;
    mNewActivities=r;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    Looper.myQueue().addIdleHandler(new Idler());
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward){
  unscheduleGcIdler();
  ActivityRecord r=performResumeActivity(token,clearHide);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    if (r.window == null && !a.mFinished && !a.mStartedActivity) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (a.mVisibleFromClient) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (a.mStartedActivity) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    if (!r.activity.mFinished && !a.mStartedActivity && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChanged(r.activity,r.newConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    r.nextIdle=mNewActivities;
    mNewActivities=r;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    Looper.myQueue().addIdleHandler(new Idler());
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}",0.9825508932280848
183163,"/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
  }
}","/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(""String_Node_Str"");
    }
 catch (    RemoteException e) {
    }
  }
}",0.8310387984981227
183164,"/** 
 * Creates a centered bitmap of the desired size.
 * @param source
 * @param recycle whether we want to recycle the input
 */
public static Bitmap extractMiniThumb(Bitmap source,int width,int height,boolean recycle){
  if (source == null) {
    return null;
  }
  float scale;
  if (source.getWidth() < source.getHeight()) {
    scale=width / (float)source.getWidth();
  }
 else {
    scale=height / (float)source.getHeight();
  }
  Matrix matrix=new Matrix();
  matrix.setScale(scale,scale);
  Bitmap miniThumbnail=transform(matrix,source,width,height,false,recycle);
  return miniThumbnail;
}","/** 
 * Creates a centered bitmap of the desired size.
 * @param source
 * @param recycle whether we want to recycle the input
 */
public static Bitmap extractMiniThumb(Bitmap source,int width,int height,boolean recycle){
  if (source == null) {
    return null;
  }
  float scale;
  if (source.getWidth() < source.getHeight()) {
    scale=width / (float)source.getWidth();
  }
 else {
    scale=height / (float)source.getHeight();
  }
  Matrix matrix=new Matrix();
  matrix.setScale(scale,scale);
  Bitmap miniThumbnail=transform(matrix,source,width,height,true,recycle);
  return miniThumbnail;
}",0.9941520467836256
183165,"public PackageInfo(ActivityThread activityThread,String name,Context systemContext){
  mActivityThread=activityThread;
  mApplicationInfo=new ApplicationInfo();
  mApplicationInfo.packageName=name;
  mPackageName=name;
  mAppDir=null;
  mResDir=null;
  mSharedLibraries=null;
  mDataDir=null;
  mDataDirFile=null;
  mBaseClassLoader=null;
  mSecurityViolation=false;
  mIncludeCode=true;
  mClassLoader=systemContext.getClassLoader();
  mResources=systemContext.getResources();
  mCompatibilityInfo=new CompatibilityInfo(mApplicationInfo);
}","public PackageInfo(ActivityThread activityThread,String name,Context systemContext,ApplicationInfo info){
  mActivityThread=activityThread;
  mApplicationInfo=info != null ? info : new ApplicationInfo();
  mApplicationInfo.packageName=name;
  mPackageName=name;
  mAppDir=null;
  mResDir=null;
  mSharedLibraries=null;
  mDataDir=null;
  mDataDirFile=null;
  mBaseClassLoader=null;
  mSecurityViolation=false;
  mIncludeCode=true;
  mClassLoader=systemContext.getClassLoader();
  mResources=systemContext.getResources();
  mCompatibilityInfo=new CompatibilityInfo(mApplicationInfo);
}",0.9617777777777776
183166,"public ApplicationContext getSystemContext(){
synchronized (this) {
    if (mSystemContext == null) {
      ApplicationContext context=ApplicationContext.createSystemContext(this);
      PackageInfo info=new PackageInfo(this,""String_Node_Str"",context);
      context.init(info,null,this);
      context.getResources().updateConfiguration(getConfiguration(),getDisplayMetricsLocked(false));
      mSystemContext=context;
    }
  }
  return mSystemContext;
}","public ApplicationContext getSystemContext(){
synchronized (this) {
    if (mSystemContext == null) {
      ApplicationContext context=ApplicationContext.createSystemContext(this);
      PackageInfo info=new PackageInfo(this,""String_Node_Str"",context,null);
      context.init(info,null,this);
      context.getResources().updateConfiguration(getConfiguration(),getDisplayMetricsLocked(false));
      mSystemContext=context;
    }
  }
  return mSystemContext;
}",0.9945474372955287
183167,"public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",STOCK_PM_FLAGS);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",STOCK_PM_FLAGS);
    mSystemThread.installSystemApplicationInfo(info);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.9801762114537445
183168,"/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
temp=appendAddressType(addr[i]);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
temp=appendAddressType(from);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendEncodedString(temp);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}","/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
temp=appendAddressType(addr[i]);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || TextUtils.isEmpty(from.getString()) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
temp=appendAddressType(from);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendEncodedString(temp);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}",0.9944021817137936
183169,"private void updateAnimation(){
  final long millisSoFar=currentAnimationTimeMillis() - mAnimationStartTime;
  final long millisLeft=mAnimationDuration - millisSoFar;
  final int totalDeltaX=mAnimatingDeltaXStart - mAnimatingDeltaXEnd;
  final boolean goingRight=totalDeltaX < 0;
  if (DBG)   log(""String_Node_Str"" + millisLeft);
  if (millisLeft <= 0) {
    reset();
    return;
  }
  float interpolation=mInterpolator.getInterpolation((float)millisSoFar / mAnimationDuration);
  final int dx=(int)(totalDeltaX * (1 - interpolation));
  mRotaryOffsetX=mAnimatingDeltaXEnd + dx;
  if (mDimplesOfFling > 0) {
    if (!goingRight && mRotaryOffsetX < 3 * mDimpleSpacing) {
      mRotaryOffsetX+=mDimplesOfFling * mDimpleSpacing;
    }
 else     if (goingRight && mRotaryOffsetX > 3 * mDimpleSpacing) {
      mRotaryOffsetX-=mDimplesOfFling * mDimpleSpacing;
    }
  }
  invalidate();
}","private void updateAnimation(){
  final long millisSoFar=currentAnimationTimeMillis() - mAnimationStartTime;
  final long millisLeft=mAnimationDuration - millisSoFar;
  final int totalDeltaX=mAnimatingDeltaXStart - mAnimatingDeltaXEnd;
  final boolean goingRight=totalDeltaX < 0;
  if (DBG)   log(""String_Node_Str"" + millisLeft);
  if (millisLeft <= 0) {
    reset();
    return;
  }
  float interpolation=mInterpolator.getInterpolation((float)millisSoFar / mAnimationDuration);
  final int dx=(int)(totalDeltaX * (1 - interpolation));
  mRotaryOffsetX=mAnimatingDeltaXEnd + dx;
  if (mDimplesOfFling > 0) {
    if (!goingRight && mRotaryOffsetX < -3 * mDimpleSpacing) {
      mRotaryOffsetX+=mDimplesOfFling * mDimpleSpacing;
    }
 else     if (goingRight && mRotaryOffsetX > 3 * mDimpleSpacing) {
      mRotaryOffsetX-=mDimplesOfFling * mDimpleSpacing;
    }
  }
  invalidate();
}",0.9994334277620396
183170,"/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
  }
}","/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(""String_Node_Str"");
    }
 catch (    RemoteException e) {
    }
  }
}",0.8310387984981227
183171,"private final void sendServiceArgsLocked(ServiceRecord r,boolean oomAdjusted){
  final int N=r.pendingStarts.size();
  if (N == 0) {
    return;
  }
  int i=0;
  while (i < N) {
    try {
      ServiceRecord.StartItem si=r.pendingStarts.get(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ si.intent);
      if (si.intent == null && N > 0) {
        i++;
        continue;
      }
      bumpServiceExecutingLocked(r);
      if (!oomAdjusted) {
        oomAdjusted=true;
        updateOomAdjLocked(r.app);
      }
      int flags=0;
      if (si.deliveryCount > 0) {
        flags|=Service.START_FLAG_RETRY;
      }
      if (si.doneExecutingCount > 0) {
        flags|=Service.START_FLAG_REDELIVERY;
      }
      r.app.thread.scheduleServiceArgs(r,si.id,flags,si.intent);
      si.deliveredTime=SystemClock.uptimeMillis();
      r.deliveredStarts.add(si);
      si.deliveryCount++;
      i++;
    }
 catch (    RemoteException e) {
      break;
    }
catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"",e);
      break;
    }
  }
  if (i == N) {
    r.pendingStarts.clear();
  }
 else {
    while (i > 0) {
      i--;
      r.pendingStarts.remove(i);
    }
  }
}","private final void sendServiceArgsLocked(ServiceRecord r,boolean oomAdjusted){
  final int N=r.pendingStarts.size();
  if (N == 0) {
    return;
  }
  int i=0;
  while (i < N) {
    try {
      ServiceRecord.StartItem si=r.pendingStarts.get(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ si.intent);
      if (si.intent == null && N > 1) {
        i++;
        continue;
      }
      bumpServiceExecutingLocked(r);
      if (!oomAdjusted) {
        oomAdjusted=true;
        updateOomAdjLocked(r.app);
      }
      int flags=0;
      if (si.deliveryCount > 0) {
        flags|=Service.START_FLAG_RETRY;
      }
      if (si.doneExecutingCount > 0) {
        flags|=Service.START_FLAG_REDELIVERY;
      }
      r.app.thread.scheduleServiceArgs(r,si.id,flags,si.intent);
      si.deliveredTime=SystemClock.uptimeMillis();
      r.deliveredStarts.add(si);
      si.deliveryCount++;
      i++;
    }
 catch (    RemoteException e) {
      break;
    }
catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"",e);
      break;
    }
  }
  if (i == N) {
    r.pendingStarts.clear();
  }
 else {
    while (i > 0) {
      i--;
      r.pendingStarts.remove(i);
    }
  }
}",0.9991961414790996
183172,"/** 
 * Tests international matching issues for the PHONE_NUMBERS_EQUAL function.
 * @throws Exception
 */
@SmallTest public void testPhoneNumbersEqualInternationl() throws Exception {
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
}","/** 
 * Tests international matching issues for the PHONE_NUMBERS_EQUAL function.
 * @throws Exception
 */
@SmallTest public void testPhoneNumbersEqualInternationl() throws Exception {
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
}",0.999275887038378
183173,"/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
try {
int addressType=checkAddressType(addr[i].getString());
temp=EncodedStringValue.copy(addr[i]);
if (PDU_PHONE_NUMBER_ADDRESS_TYPE == addressType) {
temp.appendTextString(STRING_PHONE_NUMBER_ADDRESS_TYPE.getBytes());
}
 else if (PDU_IPV4_ADDRESS_TYPE == addressType) {
temp.appendTextString(STRING_IPV4_ADDRESS_TYPE.getBytes());
}
 else if (PDU_IPV6_ADDRESS_TYPE == addressType) {
temp.appendTextString(STRING_IPV6_ADDRESS_TYPE.getBytes());
}
}
 catch (NullPointerException e) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
appendEncodedString(from);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}","/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
temp=appendAddressType(addr[i]);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
temp=appendAddressType(from);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendEncodedString(temp);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}",0.8260211800302572
183174,"/** 
 * @return whether the descendant of this scroll view is within deltapixels of being on the screen.
 */
private boolean isWithinDeltaOfScreen(View descendant,int delta){
  descendant.getDrawingRect(mTempRect);
  offsetDescendantRectToMyCoords(descendant,mTempRect);
  return (mTempRect.bottom + delta) >= getScrollY() && (mTempRect.top - delta) <= (getScrollY() + getHeight());
}","/** 
 * @return whether the descendant of this scroll view is within deltapixels of being on the screen.
 */
private boolean isWithinDeltaOfScreen(View descendant,int delta,int height){
  descendant.getDrawingRect(mTempRect);
  offsetDescendantRectToMyCoords(descendant,mTempRect);
  return (mTempRect.bottom + delta) >= getScrollY() && (mTempRect.top - delta) <= (getScrollY() + height);
}",0.9638242894056848
183175,"/** 
 * @return whether the descendant of this scroll view is scrolled offscreen.
 */
private boolean isOffScreen(View descendant){
  return !isWithinDeltaOfScreen(descendant,0);
}","/** 
 * @return whether the descendant of this scroll view is scrolled offscreen.
 */
private boolean isOffScreen(View descendant){
  return !isWithinDeltaOfScreen(descendant,0,getHeight());
}",0.967741935483871
183176,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  View currentFocused=findFocus();
  if (null == currentFocused || this == currentFocused)   return;
  final int maxJump=mBottom - mTop;
  if (isWithinDeltaOfScreen(currentFocused,maxJump)) {
    currentFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(currentFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
  }
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  View currentFocused=findFocus();
  if (null == currentFocused || this == currentFocused)   return;
  if (isWithinDeltaOfScreen(currentFocused,0,oldh)) {
    currentFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(currentFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
  }
}",0.9506545820745216
183177,"/** 
 * Handle scrolling in response to an up or down arrow click.
 * @param direction The direction corresponding to the arrow key that waspressed
 * @return True if we consumed the event, false otherwise
 */
public boolean arrowScroll(int direction){
  View currentFocused=findFocus();
  if (currentFocused == this)   currentFocused=null;
  View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,direction);
  final int maxJump=getMaxScrollAmount();
  if (nextFocused != null && isWithinDeltaOfScreen(nextFocused,maxJump)) {
    nextFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(nextFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
    nextFocused.requestFocus(direction);
  }
 else {
    int scrollDelta=maxJump;
    if (direction == View.FOCUS_UP && getScrollY() < scrollDelta) {
      scrollDelta=getScrollY();
    }
 else     if (direction == View.FOCUS_DOWN) {
      if (getChildCount() > 0) {
        int daBottom=getChildAt(0).getBottom();
        int screenBottom=getScrollY() + getHeight();
        if (daBottom - screenBottom < maxJump) {
          scrollDelta=daBottom - screenBottom;
        }
      }
    }
    if (scrollDelta == 0) {
      return false;
    }
    doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
  }
  if (currentFocused != null && currentFocused.isFocused() && isOffScreen(currentFocused)) {
    final int descendantFocusability=getDescendantFocusability();
    setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
    requestFocus();
    setDescendantFocusability(descendantFocusability);
  }
  return true;
}","/** 
 * Handle scrolling in response to an up or down arrow click.
 * @param direction The direction corresponding to the arrow key that waspressed
 * @return True if we consumed the event, false otherwise
 */
public boolean arrowScroll(int direction){
  View currentFocused=findFocus();
  if (currentFocused == this)   currentFocused=null;
  View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,direction);
  final int maxJump=getMaxScrollAmount();
  if (nextFocused != null && isWithinDeltaOfScreen(nextFocused,maxJump,getHeight())) {
    nextFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(nextFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
    nextFocused.requestFocus(direction);
  }
 else {
    int scrollDelta=maxJump;
    if (direction == View.FOCUS_UP && getScrollY() < scrollDelta) {
      scrollDelta=getScrollY();
    }
 else     if (direction == View.FOCUS_DOWN) {
      if (getChildCount() > 0) {
        int daBottom=getChildAt(0).getBottom();
        int screenBottom=getScrollY() + getHeight();
        if (daBottom - screenBottom < maxJump) {
          scrollDelta=daBottom - screenBottom;
        }
      }
    }
    if (scrollDelta == 0) {
      return false;
    }
    doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
  }
  if (currentFocused != null && currentFocused.isFocused() && isOffScreen(currentFocused)) {
    final int descendantFocusability=getDescendantFocusability();
    setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
    requestFocus();
    setDescendantFocusability(descendantFocusability);
  }
  return true;
}",0.996468510888758
183178,"/** 
 * Report a click from an in app search result back to global search for shortcutting porpoises.
 * @param c The cursor that is pointing to the clicked position.
 * @param intent The intent that will be launched for the click.
 */
private void reportInAppClickToGlobalSearch(Cursor c,Intent intent){
  Uri uri=getClickReportingUri();
  final ContentValues cv=new ContentValues();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_QUERY,mUserQuery);
  final ComponentName source=mSearchable.getSearchActivity();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_COMPONENT,source.flattenToShortString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_ACTION,intent.getAction());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_DATA,intent.getDataString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_COMPONENT_NAME,intent.getStringExtra(SearchManager.COMPONENT_NAME_KEY));
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_1,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_1)));
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_2,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_2)));
  cv.put(SearchManager.SUGGEST_COLUMN_FORMAT,getColumnString(c,SearchManager.SUGGEST_COLUMN_FORMAT));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_1,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_1));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_2,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_2));
  cv.put(SearchManager.SUGGEST_COLUMN_QUERY,getColumnString(c,SearchManager.SUGGEST_COLUMN_QUERY));
  cv.put(SearchManager.SUGGEST_COLUMN_SHORTCUT_ID,getColumnString(c,SearchManager.SUGGEST_COLUMN_SHORTCUT_ID));
  mContext.getContentResolver().insert(uri,cv);
}","/** 
 * Report a click from an in app search result back to global search for shortcutting porpoises.
 * @param c The cursor that is pointing to the clicked position.
 * @param intent The intent that will be launched for the click.
 */
private void reportInAppClickToGlobalSearch(Cursor c,Intent intent){
  Uri uri=getClickReportingUri();
  final ContentValues cv=new ContentValues();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_QUERY,mUserQuery);
  final ComponentName source=mSearchable.getSearchActivity();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_COMPONENT,source.flattenToShortString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_ACTION,intent.getAction());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_DATA,intent.getDataString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_COMPONENT_NAME,intent.getComponent().flattenToShortString());
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_1,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_1)));
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_2,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_2)));
  cv.put(SearchManager.SUGGEST_COLUMN_FORMAT,getColumnString(c,SearchManager.SUGGEST_COLUMN_FORMAT));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_1,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_1));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_2,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_2));
  cv.put(SearchManager.SUGGEST_COLUMN_QUERY,getColumnString(c,SearchManager.SUGGEST_COLUMN_QUERY));
  cv.put(SearchManager.SUGGEST_COLUMN_SHORTCUT_ID,getColumnString(c,SearchManager.SUGGEST_COLUMN_SHORTCUT_ID));
  mContext.getContentResolver().insert(uri,cv);
}",0.9779179810725552
183179,"private void updateStatusLines(){
  if (!mStatus.showStatusLines()) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}","private void updateStatusLines(){
  if (!mStatus.showStatusLines() || (mCharging == null && mNextAlarm == null)) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}",0.979214780600462
183180,"private void updateStatusLines(){
  if (!mStatus.showStatusLines()) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}","private void updateStatusLines(){
  if (!mStatus.showStatusLines() || (mCharging == null && mNextAlarm == null)) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}",0.979214780600462
183181,"public static Intent getIntentOld(String uri) throws URISyntaxException {
  Intent intent;
  int i=uri.lastIndexOf('#');
  if (i >= 0) {
    Uri data=null;
    String action=null;
    if (i > 0) {
      data=Uri.parse(uri.substring(0,i));
    }
    i++;
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      i+=7;
      int j=uri.indexOf(')',i);
      action=uri.substring(i,j);
      i=j + 1;
    }
    intent=new Intent(action,data);
    if (uri.regionMatches(i,""String_Node_Str"",0,11)) {
      i+=11;
      int j=uri.indexOf(')',i);
      while (i < j) {
        int sep=uri.indexOf('!',i);
        if (sep < 0)         sep=j;
        if (i < sep) {
          intent.addCategory(uri.substring(i,sep));
        }
        i=sep + 1;
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,5)) {
      i+=5;
      int j=uri.indexOf(')',i);
      intent.mType=uri.substring(i,j);
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,12)) {
      i+=12;
      int j=uri.indexOf(')',i);
      intent.mFlags=Integer.decode(uri.substring(i,j)).intValue();
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,10)) {
      i+=10;
      int j=uri.indexOf(')',i);
      int sep=uri.indexOf('!',i);
      if (sep >= 0 && sep < j) {
        String pkg=uri.substring(i,sep);
        String cls=uri.substring(sep + 1,j);
        intent.mComponent=new ComponentName(pkg,cls);
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      i+=7;
      final int closeParen=uri.indexOf(')',i);
      if (closeParen == -1)       throw new URISyntaxException(uri,""String_Node_Str"",i);
      while (i < closeParen) {
        int j=uri.indexOf('=',i);
        if (j <= i + 1 || i >= closeParen) {
          throw new URISyntaxException(uri,""String_Node_Str"",i);
        }
        char type=uri.charAt(i);
        i++;
        String key=uri.substring(i,j);
        i=j + 1;
        j=uri.indexOf('!',i);
        if (j == -1 || j >= closeParen)         j=closeParen;
        if (i >= j)         throw new URISyntaxException(uri,""String_Node_Str"",i);
        String value=uri.substring(i,j);
        i=j;
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        try {
switch (type) {
case 'S':
            intent.mExtras.putString(key,Uri.decode(value));
          break;
case 'B':
        intent.mExtras.putBoolean(key,Boolean.parseBoolean(value));
      break;
case 'b':
    intent.mExtras.putByte(key,Byte.parseByte(value));
  break;
case 'c':
intent.mExtras.putChar(key,Uri.decode(value).charAt(0));
break;
case 'd':
intent.mExtras.putDouble(key,Double.parseDouble(value));
break;
case 'f':
intent.mExtras.putFloat(key,Float.parseFloat(value));
break;
case 'i':
intent.mExtras.putInt(key,Integer.parseInt(value));
break;
case 'l':
intent.mExtras.putLong(key,Long.parseLong(value));
break;
case 's':
intent.mExtras.putShort(key,Short.parseShort(value));
break;
default :
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
}
 catch (NumberFormatException e) {
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
char ch=uri.charAt(i);
if (ch == ')') break;
if (ch != '!') throw new URISyntaxException(uri,""String_Node_Str"",i);
i++;
}
}
if (intent.mAction == null) {
intent.mAction=ACTION_VIEW;
}
}
 else {
intent=new Intent(ACTION_VIEW,Uri.parse(uri));
}
return intent;
}","public static Intent getIntentOld(String uri) throws URISyntaxException {
  Intent intent;
  int i=uri.lastIndexOf('#');
  if (i >= 0) {
    String action=null;
    final int intentFragmentStart=i;
    boolean isIntentFragment=false;
    i++;
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      isIntentFragment=true;
      i+=7;
      int j=uri.indexOf(')',i);
      action=uri.substring(i,j);
      i=j + 1;
    }
    intent=new Intent(action);
    if (uri.regionMatches(i,""String_Node_Str"",0,11)) {
      isIntentFragment=true;
      i+=11;
      int j=uri.indexOf(')',i);
      while (i < j) {
        int sep=uri.indexOf('!',i);
        if (sep < 0)         sep=j;
        if (i < sep) {
          intent.addCategory(uri.substring(i,sep));
        }
        i=sep + 1;
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,5)) {
      isIntentFragment=true;
      i+=5;
      int j=uri.indexOf(')',i);
      intent.mType=uri.substring(i,j);
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,12)) {
      isIntentFragment=true;
      i+=12;
      int j=uri.indexOf(')',i);
      intent.mFlags=Integer.decode(uri.substring(i,j)).intValue();
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,10)) {
      isIntentFragment=true;
      i+=10;
      int j=uri.indexOf(')',i);
      int sep=uri.indexOf('!',i);
      if (sep >= 0 && sep < j) {
        String pkg=uri.substring(i,sep);
        String cls=uri.substring(sep + 1,j);
        intent.mComponent=new ComponentName(pkg,cls);
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      isIntentFragment=true;
      i+=7;
      final int closeParen=uri.indexOf(')',i);
      if (closeParen == -1)       throw new URISyntaxException(uri,""String_Node_Str"",i);
      while (i < closeParen) {
        int j=uri.indexOf('=',i);
        if (j <= i + 1 || i >= closeParen) {
          throw new URISyntaxException(uri,""String_Node_Str"",i);
        }
        char type=uri.charAt(i);
        i++;
        String key=uri.substring(i,j);
        i=j + 1;
        j=uri.indexOf('!',i);
        if (j == -1 || j >= closeParen)         j=closeParen;
        if (i >= j)         throw new URISyntaxException(uri,""String_Node_Str"",i);
        String value=uri.substring(i,j);
        i=j;
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        try {
switch (type) {
case 'S':
            intent.mExtras.putString(key,Uri.decode(value));
          break;
case 'B':
        intent.mExtras.putBoolean(key,Boolean.parseBoolean(value));
      break;
case 'b':
    intent.mExtras.putByte(key,Byte.parseByte(value));
  break;
case 'c':
intent.mExtras.putChar(key,Uri.decode(value).charAt(0));
break;
case 'd':
intent.mExtras.putDouble(key,Double.parseDouble(value));
break;
case 'f':
intent.mExtras.putFloat(key,Float.parseFloat(value));
break;
case 'i':
intent.mExtras.putInt(key,Integer.parseInt(value));
break;
case 'l':
intent.mExtras.putLong(key,Long.parseLong(value));
break;
case 's':
intent.mExtras.putShort(key,Short.parseShort(value));
break;
default :
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
}
 catch (NumberFormatException e) {
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
char ch=uri.charAt(i);
if (ch == ')') break;
if (ch != '!') throw new URISyntaxException(uri,""String_Node_Str"",i);
i++;
}
}
if (isIntentFragment) {
intent.mData=Uri.parse(uri.substring(0,intentFragmentStart));
}
 else {
intent.mData=Uri.parse(uri);
}
if (intent.mAction == null) {
intent.mAction=ACTION_VIEW;
}
}
 else {
intent=new Intent(ACTION_VIEW,Uri.parse(uri));
}
return intent;
}",0.9292929292929292
183182,"/** 
 * Create an intent from a URI.  This URI may encode the action, category, and other intent fields, if it was returned by  {@link #toUri}.  If the Intent was not generate by toUri(), its data will be the entire URI and its action will be ACTION_VIEW. <p>The URI given here must not be relative -- that is, it must include the scheme and full path.
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or
 * @return Intent The newly created Intent object.
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntaxit bad (as parsed by the Uri class) or the Intent data within the URI is invalid.
 * @see #toUri
 */
public static Intent parseUri(String uri,int flags) throws URISyntaxException {
  int i=0;
  try {
    if ((flags & URI_INTENT_SCHEME) != 0) {
      if (!uri.startsWith(""String_Node_Str"")) {
        Intent intent=new Intent(ACTION_VIEW);
        try {
          intent.setData(Uri.parse(uri));
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
        return intent;
      }
    }
    i=uri.lastIndexOf(""String_Node_Str"");
    if (i == -1)     return new Intent(ACTION_VIEW,Uri.parse(uri));
    if (!uri.startsWith(""String_Node_Str"",i))     return getIntentOld(uri);
    Intent intent=new Intent(ACTION_VIEW);
    String data=i >= 0 ? uri.substring(0,i) : null;
    String scheme=null;
    i+=""String_Node_Str"".length();
    while (!uri.startsWith(""String_Node_Str"",i)) {
      int eq=uri.indexOf('=',i);
      int semi=uri.indexOf(';',eq);
      String value=Uri.decode(uri.substring(eq + 1,semi));
      if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mAction=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.addCategory(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mType=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mFlags=Integer.decode(value).intValue();
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mPackage=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mComponent=ComponentName.unflattenFromString(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        scheme=value;
      }
 else {
        String key=Uri.decode(uri.substring(i + 2,eq));
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        Bundle b=intent.mExtras;
        if (uri.startsWith(""String_Node_Str"",i))         b.putString(key,value);
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putBoolean(key,Boolean.parseBoolean(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putByte(key,Byte.parseByte(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putChar(key,value.charAt(0));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putDouble(key,Double.parseDouble(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putFloat(key,Float.parseFloat(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putInt(key,Integer.parseInt(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putLong(key,Long.parseLong(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putShort(key,Short.parseShort(value));
 else         throw new URISyntaxException(uri,""String_Node_Str"",i);
      }
      i=semi + 1;
    }
    if (data != null) {
      if (data.startsWith(""String_Node_Str"")) {
        data=data.substring(7);
        if (scheme != null) {
          data=scheme + ':' + data;
        }
      }
      if (data.length() > 0) {
        try {
          intent.mData=Uri.parse(data);
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
      }
    }
    return intent;
  }
 catch (  IndexOutOfBoundsException e) {
    throw new URISyntaxException(uri,""String_Node_Str"",i);
  }
}","/** 
 * Create an intent from a URI.  This URI may encode the action, category, and other intent fields, if it was returned by  {@link #toUri}.  If the Intent was not generate by toUri(), its data will be the entire URI and its action will be ACTION_VIEW. <p>The URI given here must not be relative -- that is, it must include the scheme and full path.
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or{@link #URI_INTENT_SCHEME}.
 * @return Intent The newly created Intent object.
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntaxit bad (as parsed by the Uri class) or the Intent data within the URI is invalid.
 * @see #toUri
 */
public static Intent parseUri(String uri,int flags) throws URISyntaxException {
  int i=0;
  try {
    if ((flags & URI_INTENT_SCHEME) != 0) {
      if (!uri.startsWith(""String_Node_Str"")) {
        Intent intent=new Intent(ACTION_VIEW);
        try {
          intent.setData(Uri.parse(uri));
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
        return intent;
      }
    }
    i=uri.lastIndexOf(""String_Node_Str"");
    if (i == -1)     return new Intent(ACTION_VIEW,Uri.parse(uri));
    if (!uri.startsWith(""String_Node_Str"",i))     return getIntentOld(uri);
    Intent intent=new Intent(ACTION_VIEW);
    String data=i >= 0 ? uri.substring(0,i) : null;
    String scheme=null;
    i+=""String_Node_Str"".length();
    while (!uri.startsWith(""String_Node_Str"",i)) {
      int eq=uri.indexOf('=',i);
      int semi=uri.indexOf(';',eq);
      String value=Uri.decode(uri.substring(eq + 1,semi));
      if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mAction=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.addCategory(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mType=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mFlags=Integer.decode(value).intValue();
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mPackage=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mComponent=ComponentName.unflattenFromString(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        scheme=value;
      }
 else {
        String key=Uri.decode(uri.substring(i + 2,eq));
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        Bundle b=intent.mExtras;
        if (uri.startsWith(""String_Node_Str"",i))         b.putString(key,value);
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putBoolean(key,Boolean.parseBoolean(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putByte(key,Byte.parseByte(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putChar(key,value.charAt(0));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putDouble(key,Double.parseDouble(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putFloat(key,Float.parseFloat(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putInt(key,Integer.parseInt(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putLong(key,Long.parseLong(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putShort(key,Short.parseShort(value));
 else         throw new URISyntaxException(uri,""String_Node_Str"",i);
      }
      i=semi + 1;
    }
    if (data != null) {
      if (data.startsWith(""String_Node_Str"")) {
        data=data.substring(7);
        if (scheme != null) {
          data=scheme + ':' + data;
        }
      }
      if (data.length() > 0) {
        try {
          intent.mData=Uri.parse(data);
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
      }
    }
    return intent;
  }
 catch (  IndexOutOfBoundsException e) {
    throw new URISyntaxException(uri,""String_Node_Str"",i);
  }
}",0.8587474056891711
183183,"void onPropertyChanged(String[] propValues){
  if (mBluetoothService.isAdapterPropertiesEmpty()) {
    mBluetoothService.getAllProperties();
  }
  String name=propValues[0];
  if (name.equals(""String_Node_Str"")) {
    Intent intent=new Intent(BluetoothDevice.ACTION_NAME_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_NAME,propValues[1]);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    String pairable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    String discoverable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    if (pairable == null || discoverable == null)     return;
    int mode=BluetoothService.bluezStringToScanMode(pairable.equals(""String_Node_Str""),discoverable.equals(""String_Node_Str""));
    if (mode >= 0) {
      Intent intent=new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
      intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE,mode);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    }
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    Intent intent;
    if (propValues[1].equals(""String_Node_Str"")) {
      mBluetoothService.setIsDiscovering(true);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
    }
 else {
      mBluetoothService.cancelDiscovery();
      mBluetoothService.setIsDiscovering(false);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
    }
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    String value=null;
    int len=Integer.valueOf(propValues[1]);
    if (len > 0) {
      StringBuilder str=new StringBuilder();
      for (int i=2; i < propValues.length; i++) {
        str.append(propValues[i]);
        str.append(""String_Node_Str"");
      }
      value=str.toString();
    }
    mBluetoothService.setProperty(name,value);
  }
 else   if (name.equals(""String_Node_Str"")) {
    if (propValues[1].equals(""String_Node_Str""))     onRestartRequired();
  }
}","void onPropertyChanged(String[] propValues){
  if (mBluetoothService.isAdapterPropertiesEmpty()) {
    mBluetoothService.getAllProperties();
  }
  String name=propValues[0];
  if (name.equals(""String_Node_Str"")) {
    Intent intent=new Intent(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
    intent.putExtra(BluetoothAdapter.EXTRA_LOCAL_NAME,propValues[1]);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    String pairable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    String discoverable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    if (pairable == null || discoverable == null)     return;
    int mode=BluetoothService.bluezStringToScanMode(pairable.equals(""String_Node_Str""),discoverable.equals(""String_Node_Str""));
    if (mode >= 0) {
      Intent intent=new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
      intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE,mode);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    }
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    Intent intent;
    if (propValues[1].equals(""String_Node_Str"")) {
      mBluetoothService.setIsDiscovering(true);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
    }
 else {
      mBluetoothService.cancelDiscovery();
      mBluetoothService.setIsDiscovering(false);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
    }
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    String value=null;
    int len=Integer.valueOf(propValues[1]);
    if (len > 0) {
      StringBuilder str=new StringBuilder();
      for (int i=2; i < propValues.length; i++) {
        str.append(propValues[i]);
        str.append(""String_Node_Str"");
      }
      value=str.toString();
    }
    mBluetoothService.setProperty(name,value);
  }
 else   if (name.equals(""String_Node_Str"")) {
    if (propValues[1].equals(""String_Node_Str""))     onRestartRequired();
  }
}",0.9919627749576988
183184,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_CONTACT_INFO:
{
        bindContactInfo(cursor);
        invalidate();
        break;
      }
case TOKEN_SOCIAL:
{
      bindSocial(cursor);
      invalidate();
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      setDisplayName((String)cookie,null);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    setDisplayName((String)cookie,null);
  }
  break;
}
case TOKEN_LOOKUP_CONTACT_FOR_SOCIAL_QUERY:
{
if (cursor != null && cursor.moveToFirst()) {
  long contactId=cursor.getLong(CONTACT_LOOKUP_ID_COLUMN_INDEX);
  startSocialQuery(ContentUris.withAppendedId(Activities.CONTENT_CONTACT_STATUS_URI,contactId));
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_CONTACT_INFO:
{
        bindContactInfo(cursor);
        invalidate();
        break;
      }
case TOKEN_SOCIAL:
{
      bindSocial(cursor);
      invalidate();
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
case TOKEN_LOOKUP_CONTACT_FOR_SOCIAL_QUERY:
{
if (cursor != null && cursor.moveToFirst()) {
  long contactId=cursor.getLong(CONTACT_LOOKUP_ID_COLUMN_INDEX);
  startSocialQuery(ContentUris.withAppendedId(Activities.CONTENT_CONTACT_STATUS_URI,contactId));
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}",0.9151039890896692
183185,"private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (isPause(c) && (nextNonPwCharIndex > (currPwIndex + 2))) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}","private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (nextNonPwCharIndex > (currPwIndex + 1)) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}",0.9727272727272728
183186,"boolean update(DriverCall dc){
  CdmaCall newParent;
  boolean changed=false;
  boolean wasConnectingInOrOut=isConnectingInOrOut();
  boolean wasHolding=(getState() == CdmaCall.State.HOLDING);
  newParent=parentFromDCState(dc.state);
  if (!equalsHandlesNulls(address,dc.number)) {
    if (Phone.DEBUG_PHONE)     log(""String_Node_Str"");
    address=dc.number;
    changed=true;
  }
  if (TextUtils.isEmpty(dc.name)) {
    if (!TextUtils.isEmpty(cnapName)) {
      changed=true;
      cnapName=""String_Node_Str"";
    }
  }
 else   if (!dc.name.equals(cnapName)) {
    changed=true;
    cnapName=dc.name;
  }
  log(""String_Node_Str"" + cnapName);
  cnapNamePresentation=dc.namePresentation;
  numberPresentation=dc.numberPresentation;
  if (newParent != parent) {
    if (parent != null) {
      parent.detach(this);
    }
    newParent.attach(this,dc);
    parent=newParent;
    changed=true;
  }
 else {
    boolean parentStateChange;
    parentStateChange=parent.update(this,dc);
    changed=changed || parentStateChange;
  }
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + parent + ""String_Node_Str""+ (newParent != parent)+ ""String_Node_Str""+ wasConnectingInOrOut+ ""String_Node_Str""+ wasHolding+ ""String_Node_Str""+ isConnectingInOrOut()+ ""String_Node_Str""+ changed);
  if (wasConnectingInOrOut && !isConnectingInOrOut()) {
    onConnectedInOrOut();
  }
  if (changed && !wasHolding && (getState() == CdmaCall.State.HOLDING)) {
    onStartedHolding();
  }
  return changed;
}","boolean update(DriverCall dc){
  CdmaCall newParent;
  boolean changed=false;
  boolean wasConnectingInOrOut=isConnectingInOrOut();
  boolean wasHolding=(getState() == CdmaCall.State.HOLDING);
  newParent=parentFromDCState(dc.state);
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + parent + ""String_Node_Str""+ newParent);
  if (!equalsHandlesNulls(address,dc.number)) {
    if (Phone.DEBUG_PHONE)     log(""String_Node_Str"");
    address=dc.number;
    changed=true;
  }
  if (TextUtils.isEmpty(dc.name)) {
    if (!TextUtils.isEmpty(cnapName)) {
      changed=true;
      cnapName=""String_Node_Str"";
    }
  }
 else   if (!dc.name.equals(cnapName)) {
    changed=true;
    cnapName=dc.name;
  }
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + cnapName);
  cnapNamePresentation=dc.namePresentation;
  numberPresentation=dc.numberPresentation;
  if (newParent != parent) {
    if (parent != null) {
      parent.detach(this);
    }
    newParent.attach(this,dc);
    parent=newParent;
    changed=true;
  }
 else {
    boolean parentStateChange;
    parentStateChange=parent.update(this,dc);
    changed=changed || parentStateChange;
  }
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + wasConnectingInOrOut + ""String_Node_Str""+ wasHolding+ ""String_Node_Str""+ isConnectingInOrOut()+ ""String_Node_Str""+ changed);
  if (wasConnectingInOrOut && !isConnectingInOrOut()) {
    onConnectedInOrOut();
  }
  if (changed && !wasHolding && (getState() == CdmaCall.State.HOLDING)) {
    onStartedHolding();
  }
  return changed;
}",0.4408924408924409
183187,"/** 
 * format original dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 2)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return PhoneNumberUtils.cdmaCheckAndProcessPlusCode(ret.toString());
}","/** 
 * format original dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 1)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return PhoneNumberUtils.cdmaCheckAndProcessPlusCode(ret.toString());
}",0.999194198227236
183188,"/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param conatctUri Either a {Contacts.CONTENT_URI} or {Contacts.CONTENT_LOOKUP_URI}style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}","/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param contactUri Either a {@link Contacts#CONTENT_URI} or{@link Contacts#CONTENT_LOOKUP_URI} style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}",0.9272237196765498
183189,"/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}",0.9748520710059172
183190,"public void onClick(View v){
  final Rect target=getTargetRect(v);
  if (mContactUri != null) {
    trigger(mContactUri,target);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}","public void onClick(View v){
  if (mContactUri != null) {
    final ContentResolver resolver=getContext().getContentResolver();
    final Uri lookupUri=Contacts.getLookupUri(resolver,mContactUri);
    trigger(lookupUri);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,mContactEmail,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,mContactPhone,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}",0.3651771956856702
183191,"/** 
 * Set the fasttrack window mode. Options are   {@link Intents.MODE_SMALL},  {@link Intents.MODE_MEDIUM},   {@link Intents.MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}","/** 
 * Set the fasttrack window mode. Options are   {@link FastTrack#MODE_SMALL},  {@link FastTrack#MODE_MEDIUM},   {@link FastTrack#MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}",0.8708133971291866
183192,"public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,Intents.MODE_MEDIUM);
  a.recycle();
  init();
}","public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,FastTrack.MODE_MEDIUM);
  a.recycle();
  init();
}",0.9783783783783784
183193,"/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}",0.97503671071953
183194,"private void trigger(Uri contactUri,Rect target){
  Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,contactUri);
  intent.putExtra(Intents.EXTRA_TARGET_RECT,target);
  intent.putExtra(Intents.EXTRA_MODE,mMode);
  mContext.startActivity(intent);
}","private void trigger(Uri lookupUri){
  FastTrack.showFastTrack(getContext(),this,lookupUri,mMode,mExcludeMimes);
}",0.3315217391304347
183195,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri contactUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
case TOKEN_PHONE_LOOKUP:
{
      if (cursor != null && cursor.moveToFirst()) {
        long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
        String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
        contactUri=Contacts.getLookupUri(contactId,lookupKey);
      }
      break;
    }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
  trigger=true;
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
    contactUri=Contacts.getLookupUri(contactId,lookupKey);
  }
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
if (contactUri != null) {
mContactUri=contactUri;
if (trigger && cookie != null) {
trigger(contactUri,(Rect)cookie);
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri lookupUri=null;
  Uri createUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
    createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
      lookupUri=Contacts.getLookupUri(contactId,lookupKey);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
trigger=true;
createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_EMAIL_LOOKUP:
{
if (cursor != null && cursor.moveToFirst()) {
long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
lookupUri=Contacts.getLookupUri(contactId,lookupKey);
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
mContactUri=lookupUri;
if (trigger && lookupUri != null) {
trigger(lookupUri);
}
 else if (createUri != null) {
final Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,createUri);
getContext().startActivity(intent);
}
}",0.7892416225749559
183196,"/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param conatctUri Either a {Contacts.CONTENT_URI} or {Contacts.CONTENT_LOOKUP_URI}style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}","/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param contactUri Either a {@link Contacts#CONTENT_URI} or{@link Contacts#CONTENT_LOOKUP_URI} style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}",0.9272237196765498
183197,"/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}",0.9748520710059172
183198,"public void onClick(View v){
  final Rect target=getTargetRect(v);
  if (mContactUri != null) {
    trigger(mContactUri,target);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}","public void onClick(View v){
  if (mContactUri != null) {
    final ContentResolver resolver=getContext().getContentResolver();
    final Uri lookupUri=Contacts.getLookupUri(resolver,mContactUri);
    trigger(lookupUri);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,mContactEmail,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,mContactPhone,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}",0.3651771956856702
183199,"/** 
 * Set the fasttrack window mode. Options are   {@link Intents.MODE_SMALL},  {@link Intents.MODE_MEDIUM},   {@link Intents.MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}","/** 
 * Set the fasttrack window mode. Options are   {@link FastTrack#MODE_SMALL},  {@link FastTrack#MODE_MEDIUM},   {@link FastTrack#MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}",0.8708133971291866
183200,"public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,Intents.MODE_MEDIUM);
  a.recycle();
  init();
}","public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,FastTrack.MODE_MEDIUM);
  a.recycle();
  init();
}",0.9783783783783784
183201,"/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}",0.97503671071953
183202,"private void trigger(Uri contactUri,Rect target){
  Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,contactUri);
  intent.putExtra(Intents.EXTRA_TARGET_RECT,target);
  intent.putExtra(Intents.EXTRA_MODE,mMode);
  mContext.startActivity(intent);
}","private void trigger(Uri lookupUri){
  FastTrack.showFastTrack(getContext(),this,lookupUri,mMode,mExcludeMimes);
}",0.3315217391304347
183203,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri contactUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
case TOKEN_PHONE_LOOKUP:
{
      if (cursor != null && cursor.moveToFirst()) {
        long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
        String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
        contactUri=Contacts.getLookupUri(contactId,lookupKey);
      }
      break;
    }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
  trigger=true;
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
    contactUri=Contacts.getLookupUri(contactId,lookupKey);
  }
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
if (contactUri != null) {
mContactUri=contactUri;
if (trigger && cookie != null) {
trigger(contactUri,(Rect)cookie);
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri lookupUri=null;
  Uri createUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
    createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
      lookupUri=Contacts.getLookupUri(contactId,lookupKey);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
trigger=true;
createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_EMAIL_LOOKUP:
{
if (cursor != null && cursor.moveToFirst()) {
long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
lookupUri=Contacts.getLookupUri(contactId,lookupKey);
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
mContactUri=lookupUri;
if (trigger && lookupUri != null) {
trigger(lookupUri);
}
 else if (createUri != null) {
final Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,createUri);
getContext().startActivity(intent);
}
}",0.7892416225749559
183204,"boolean isInProximity(double latitude,double longitude){
  Location loc=new Location(""String_Node_Str"");
  loc.setLatitude(latitude);
  loc.setLongitude(longitude);
  double radius=loc.distanceTo(mLocation);
  return radius <= mRadius;
}","boolean isInProximity(double latitude,double longitude,float accuracy){
  Location loc=new Location(""String_Node_Str"");
  loc.setLatitude(latitude);
  loc.setLongitude(longitude);
  double radius=loc.distanceTo(mLocation);
  return radius <= Math.max(mRadius,accuracy);
}",0.9330708661417324
183205,"public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}","public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}",0.9918256130790192
183206,"private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_PANEL,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}","private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}",0.9814656401482748
183207,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}",0.9967466807350744
183208,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(0);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}",0.9938553647392468
183209,"/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}","/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}",0.9951334999342364
183210,"/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(-1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9944895591647333
183211,"/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9933608469406064
183212,"protected void onLooperPrepared(){
  mDidSetup=true;
  mLooperTid=Process.myTid();
}","protected void onLooperPrepared(){
synchronized (HandlerThreadTest.this) {
    mDidSetup=true;
    mLooperTid=Process.myTid();
    HandlerThreadTest.this.notify();
  }
}",0.6640316205533597
183213,"@MediumTest public void testHandlerThread() throws Exception {
  HandlerThread th1=new HandlerThread(""String_Node_Str""){
    protected void onLooperPrepared(){
      mDidSetup=true;
      mLooperTid=Process.myTid();
    }
  }
;
  assertFalse(th1.isAlive());
  assertNull(th1.getLooper());
  th1.start();
  assertTrue(th1.isAlive());
  assertNotNull(th1.getLooper());
  assertNotSame(Process.myTid(),mLooperTid);
  assertTrue(mDidSetup);
  final Handler h1=new Handler(th1.getLooper()){
    public void handleMessage(    Message msg){
      assertEquals(TEST_WHAT,msg.what);
      assertEquals(mLooperTid,Process.myTid());
      mGotMessageWhat=msg.what;
      mGotMessage=true;
synchronized (this) {
        notifyAll();
      }
    }
  }
;
  Message msg=h1.obtainMessage(TEST_WHAT);
synchronized (h1) {
    h1.sendMessage(msg);
    try {
      h1.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  assertTrue(mGotMessage);
  assertEquals(TEST_WHAT,mGotMessageWhat);
}","@MediumTest public void testHandlerThread() throws Exception {
  HandlerThread th1=new HandlerThread(""String_Node_Str""){
    protected void onLooperPrepared(){
synchronized (HandlerThreadTest.this) {
        mDidSetup=true;
        mLooperTid=Process.myTid();
        HandlerThreadTest.this.notify();
      }
    }
  }
;
  assertFalse(th1.isAlive());
  assertNull(th1.getLooper());
  th1.start();
  assertTrue(th1.isAlive());
  assertNotNull(th1.getLooper());
synchronized (this) {
    while (!mDidSetup) {
      try {
        wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
  assertNotSame(-1,mLooperTid);
  assertNotSame(Process.myTid(),mLooperTid);
  final Handler h1=new Handler(th1.getLooper()){
    public void handleMessage(    Message msg){
      assertEquals(TEST_WHAT,msg.what);
      assertEquals(mLooperTid,Process.myTid());
      mGotMessageWhat=msg.what;
      mGotMessage=true;
synchronized (this) {
        notifyAll();
      }
    }
  }
;
  Message msg=h1.obtainMessage(TEST_WHAT);
synchronized (h1) {
    h1.sendMessage(msg);
    try {
      h1.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  assertTrue(mGotMessage);
  assertEquals(TEST_WHAT,mGotMessageWhat);
}",0.8679073990013618
183214,"public void onClick(View view){
  if (mContactUri == null) {
    return;
  }
switch (view.getId()) {
case R.id.star:
{
      final ContentValues values=new ContentValues(1);
      values.put(Contacts.STARRED,mStarredView.isChecked());
      mContentResolver.update(mContactUri,values,null,null);
      break;
    }
case R.id.photo:
{
    final Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,mContactUri);
    final Rect target=getTargetRect(view);
    intent.putExtra(Intents.EXTRA_TARGET_RECT,target);
    intent.putExtra(Intents.EXTRA_MODE,Intents.MODE_SMALL);
    if (mExcludeMimes != null) {
      intent.putExtra(Intents.EXTRA_EXCLUDE_MIMES,mExcludeMimes);
    }
    mContext.startActivity(intent);
    break;
  }
}
}","public void onClick(View view){
  if (mContactUri == null) {
    return;
  }
  if (view.getId() == R.id.star) {
    final ContentValues values=new ContentValues(1);
    values.put(Contacts.STARRED,mStarredView.isChecked());
    mContentResolver.update(mContactUri,values,null,null);
  }
}",0.5318940137389597
183215,"/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
  mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
}","/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final long contactId=c.getLong(HEADER_CONTACT_ID_COLUMN_INDEX);
  final String lookupKey=c.getString(HEADER_LOOKUP_KEY_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  mPhotoView.assignContactUri(Contacts.getLookupUri(contactId,lookupKey));
  int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
  mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
}",0.642570281124498
183216,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  Cursor c=null;
  try {
    c=mContentResolver.query(Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
    if (c != null && c.moveToFirst()) {
      long contactId=c.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      bindFromContactId(contactId);
    }
 else {
      setDisplayName(number,null);
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,number),PHONE_LOOKUP_PROJECTION,null,null,null);
}",0.6896551724137931
183217,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  Cursor c=null;
  try {
    c=mContentResolver.query(Uri.withAppendedPath(Email.CONTENT_FILTER_EMAIL_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
    if (c != null && c.moveToFirst()) {
      long contactId=c.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      bindFromContactId(contactId);
    }
 else {
      setDisplayName(emailAddress,null);
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}",0.6977848101265823
183218,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mDisplayNameView.setOnLongClickListener(this);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(ImageView)findViewById(R.id.photo);
  mPhotoView.setOnClickListener(this);
  mPhotoView.setOnLongClickListener(this);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mDisplayNameView.setOnLongClickListener(this);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(FasttrackBadgeWidget)findViewById(R.id.photo);
  mPhotoView.setOnLongClickListener(this);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}",0.9287598944591028
183219,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (token == TOKEN_CONTACT_INFO) {
      bindContactInfo(cursor);
      invalidate();
    }
 else     if (token == TOKEN_SOCIAL) {
      bindSocial(cursor);
      invalidate();
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_CONTACT_INFO:
{
        bindContactInfo(cursor);
        invalidate();
        break;
      }
case TOKEN_SOCIAL:
{
      bindSocial(cursor);
      invalidate();
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      setDisplayName((String)cookie,null);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    setDisplayName((String)cookie,null);
  }
  break;
}
case TOKEN_LOOKUP_CONTACT_FOR_SOCIAL_QUERY:
{
if (cursor != null && cursor.moveToFirst()) {
  long contactId=cursor.getLong(CONTACT_LOOKUP_ID_COLUMN_INDEX);
  startSocialQuery(ContentUris.withAppendedId(Activities.CONTENT_CONTACT_STATUS_URI,contactId));
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}",0.1929110981987216
183220,"private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_PANEL,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}","private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}",0.9814656401482748
183221,"/** 
 * Sets the setting for when the vibrate type should vibrate.
 * @param vibrateType The type of vibrate. One of{@link #VIBRATE_TYPE_NOTIFICATION} or{@link #VIBRATE_TYPE_RINGER}.
 * @param vibrateSetting The vibrate setting, one of{@link #VIBRATE_SETTING_ON},  {@link #VIBRATE_SETTING_OFF}, or  {@link #VIBRATE_SETTING_ONLY_SILENT}.
 * @see #getVibrateSetting(int)
 * @see #shouldVibrate(int)
 */
public void setVibrateSetting(int vibrateType,int vibrateSetting){
  IAudioService service=getService();
  try {
    service.setVibrateSetting(vibrateType,vibrateSetting);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the setting for when the vibrate type should vibrate. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param vibrateType The type of vibrate. One of{@link #VIBRATE_TYPE_NOTIFICATION} or{@link #VIBRATE_TYPE_RINGER}.
 * @param vibrateSetting The vibrate setting, one of{@link #VIBRATE_SETTING_ON},  {@link #VIBRATE_SETTING_OFF}, or  {@link #VIBRATE_SETTING_ONLY_SILENT}.
 * @see #getVibrateSetting(int)
 * @see #shouldVibrate(int)
 */
public void setVibrateSetting(int vibrateType,int vibrateSetting){
  IAudioService service=getService();
  try {
    service.setVibrateSetting(vibrateType,vibrateSetting);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.8982698961937716
183222,"/** 
 * Adjusts the volume of a particular stream by one step in a direction.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustStreamVolume(streamType,direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustStreamVolume(streamType,direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9113924050632912
183223,"/** 
 * Mute or unmute an audio stream. <p> The mute command is protected against client process death: if a process with an active mute request on a stream dies, this stream will be unmuted automatically. <p> The mute requests for a given stream are cumulative: the AudioManager can receive several mute requests from one or more clients and the stream will be unmuted only when the same number of unmute requests are received. <p> For a better user experience, applications MUST unmute a muted stream in onPause() and mute is again in onResume() if appropriate.
 * @param streamType The stream to be muted/unmuted.
 * @param state The required mute state: true for mute ON, false for mute OFF
 */
public void setStreamMute(int streamType,boolean state){
  IAudioService service=getService();
  try {
    service.setStreamMute(streamType,state,mICallBack);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Mute or unmute an audio stream. <p> The mute command is protected against client process death: if a process with an active mute request on a stream dies, this stream will be unmuted automatically. <p> The mute requests for a given stream are cumulative: the AudioManager can receive several mute requests from one or more clients and the stream will be unmuted only when the same number of unmute requests are received. <p> For a better user experience, applications MUST unmute a muted stream in onPause() and mute is again in onResume() if appropriate. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream to be muted/unmuted.
 * @param state The required mute state: true for mute ON, false for mute OFF
 */
public void setStreamMute(int streamType,boolean state){
  IAudioService service=getService();
  try {
    service.setStreamMute(streamType,state,mICallBack);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9270471464019852
183224,"/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9165247018739352
183225,"/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustVolume(direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustVolume(direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9166193987521272
183226,"/** 
 * Request use of Bluetooth SCO headset for communications.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  IAudioService service=getService();
  try {
    service.setBluetoothScoOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Request use of Bluetooth SCO headset for communications. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  IAudioService service=getService();
  try {
    service.setBluetoothScoOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.8457502623294858
183227,"/** 
 * Sets the microphone mute on or off.
 * @param on set <var>true</var> to mute the microphone;<var>false</var> to turn mute off
 */
public void setMicrophoneMute(boolean on){
  AudioSystem.muteMicrophone(on);
}","/** 
 * Sets the microphone mute on or off. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param on set <var>true</var> to mute the microphone;<var>false</var> to turn mute off
 */
public void setMicrophoneMute(boolean on){
  AudioSystem.muteMicrophone(on);
}",0.7461139896373057
183228,"/** 
 * Sets the audio mode.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.6325503355704698
183229,"/** 
 * Sets the speakerphone on or off.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  IAudioService service=getService();
  try {
    service.setSpeakerphoneOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the speakerphone on or off. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  IAudioService service=getService();
  try {
    service.setSpeakerphoneOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.8196319018404908
183230,"protected void handlePollCalls(AsyncResult ar){
  List polledCalls;
  if (ar.exception == null) {
    polledCalls=(List)ar.result;
  }
 else   if (isCommandExceptionRadioNotAvailable(ar.exception)) {
    polledCalls=new ArrayList();
  }
 else {
    pollCallsAfterDelay();
    return;
  }
  Connection newRinging=null;
  boolean hasNonHangupStateChanged=false;
  boolean needsPollDelay=false;
  boolean unknownConnectionAppeared=false;
  for (int i=0, curDC=0, dcSize=polledCalls.size(); i < connections.length; i++) {
    CdmaConnection conn=connections[i];
    DriverCall dc=null;
    if (curDC < dcSize) {
      dc=(DriverCall)polledCalls.get(curDC);
      if (dc.index == i + 1) {
        curDC++;
      }
 else {
        dc=null;
      }
    }
    if (DBG_POLL)     log(""String_Node_Str"" + i + ""String_Node_Str""+ conn+ ""String_Node_Str""+ dc);
    if (conn == null && dc != null) {
      if (pendingMO != null && pendingMO.compareTo(dc)) {
        if (DBG_POLL)         log(""String_Node_Str"" + pendingMO);
        connections[i]=pendingMO;
        pendingMO.index=i;
        pendingMO.update(dc);
        pendingMO=null;
        if (hangupPendingMO) {
          hangupPendingMO=false;
          if (mIsEcmTimerCanceled) {
            handleEcmTimer(phone.RESTART_ECM_TIMER);
          }
          try {
            if (Phone.DEBUG_PHONE)             log(""String_Node_Str"" + i);
            hangup(connections[i]);
          }
 catch (          CallStateException ex) {
            Log.e(LOG_TAG,""String_Node_Str"");
          }
          return;
        }
      }
 else {
        connections[i]=new CdmaConnection(phone.getContext(),dc,this,i);
        if (connections[i].getCall() == ringingCall) {
          newRinging=connections[i];
        }
 else {
          Log.i(LOG_TAG,""String_Node_Str"" + dc);
          if (dc.state != DriverCall.State.ALERTING && dc.state != DriverCall.State.DIALING) {
            connections[i].connectTime=System.currentTimeMillis();
          }
          unknownConnectionAppeared=true;
        }
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc == null) {
      int count=foregroundCall.connections.size();
      if (count == 0) {
        droppedDuringPoll.add(conn);
      }
 else {
        for (int n=0; n < count; n++) {
          CdmaConnection cn=(CdmaConnection)foregroundCall.connections.get(n);
          droppedDuringPoll.add(cn);
        }
      }
      foregroundCall.setGeneric(false);
      if (mIsEcmTimerCanceled) {
        handleEcmTimer(phone.RESTART_ECM_TIMER);
      }
 else {
        mIsInEmergencyCall=false;
      }
      connections[i]=null;
    }
 else     if (conn != null && dc != null) {
      boolean changed;
      changed=conn.update(dc);
      hasNonHangupStateChanged=hasNonHangupStateChanged || changed;
    }
    if (REPEAT_POLLING) {
      if (dc != null) {
        if ((dc.state == DriverCall.State.DIALING) || (dc.state == DriverCall.State.ALERTING) || (dc.state == DriverCall.State.INCOMING)|| (dc.state == DriverCall.State.WAITING)) {
          needsPollDelay=true;
        }
      }
    }
  }
  if (pendingMO != null) {
    Log.d(LOG_TAG,""String_Node_Str"" + foregroundCall.getState());
    droppedDuringPoll.add(pendingMO);
    pendingMO=null;
    hangupPendingMO=false;
    if (pendingCallInEcm) {
      pendingCallInEcm=false;
    }
  }
  if (newRinging != null) {
    phone.notifyNewRingingConnection(newRinging);
  }
  for (int i=droppedDuringPoll.size() - 1; i >= 0; i--) {
    CdmaConnection conn=droppedDuringPoll.get(i);
    if (conn.isIncoming() && conn.getConnectTime() == 0) {
      Connection.DisconnectCause cause;
      if (conn.cause == Connection.DisconnectCause.LOCAL) {
        cause=Connection.DisconnectCause.INCOMING_REJECTED;
      }
 else {
        cause=Connection.DisconnectCause.INCOMING_MISSED;
      }
      if (Phone.DEBUG_PHONE) {
        log(""String_Node_Str"" + conn.cause);
        log(""String_Node_Str"" + cause);
      }
      droppedDuringPoll.remove(i);
      conn.onDisconnect(cause);
    }
 else     if (conn.cause == Connection.DisconnectCause.LOCAL) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.LOCAL);
    }
 else     if (conn.cause == Connection.DisconnectCause.INVALID_NUMBER) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.INVALID_NUMBER);
    }
  }
  if (droppedDuringPoll.size() > 0) {
    cm.getLastCallFailCause(obtainNoPollCompleteMessage(EVENT_GET_LAST_CALL_FAIL_CAUSE));
  }
  if (needsPollDelay) {
    pollCallsAfterDelay();
  }
  if (newRinging != null || hasNonHangupStateChanged) {
    internalClearDisconnected();
  }
  updatePhoneState();
  if (unknownConnectionAppeared) {
    phone.notifyUnknownConnection();
  }
  if (hasNonHangupStateChanged || newRinging != null) {
    phone.notifyPreciseCallStateChanged();
  }
}","protected void handlePollCalls(AsyncResult ar){
  List polledCalls;
  if (ar.exception == null) {
    polledCalls=(List)ar.result;
  }
 else   if (isCommandExceptionRadioNotAvailable(ar.exception)) {
    polledCalls=new ArrayList();
  }
 else {
    pollCallsAfterDelay();
    return;
  }
  Connection newRinging=null;
  boolean hasNonHangupStateChanged=false;
  boolean needsPollDelay=false;
  boolean unknownConnectionAppeared=false;
  for (int i=0, curDC=0, dcSize=polledCalls.size(); i < connections.length; i++) {
    CdmaConnection conn=connections[i];
    DriverCall dc=null;
    if (curDC < dcSize) {
      dc=(DriverCall)polledCalls.get(curDC);
      if (dc.index == i + 1) {
        curDC++;
      }
 else {
        dc=null;
      }
    }
    if (DBG_POLL)     log(""String_Node_Str"" + i + ""String_Node_Str""+ conn+ ""String_Node_Str""+ dc);
    if (conn == null && dc != null) {
      if (pendingMO != null && pendingMO.compareTo(dc)) {
        if (DBG_POLL)         log(""String_Node_Str"" + pendingMO);
        connections[i]=pendingMO;
        pendingMO.index=i;
        pendingMO.update(dc);
        pendingMO=null;
        if (hangupPendingMO) {
          hangupPendingMO=false;
          if (mIsEcmTimerCanceled) {
            handleEcmTimer(phone.RESTART_ECM_TIMER);
          }
          try {
            if (Phone.DEBUG_PHONE)             log(""String_Node_Str"" + i);
            hangup(connections[i]);
          }
 catch (          CallStateException ex) {
            Log.e(LOG_TAG,""String_Node_Str"");
          }
          return;
        }
      }
 else {
        if (Phone.DEBUG_PHONE) {
          log(""String_Node_Str"" + pendingMO + dc);
        }
        newRinging=checkMtFindNewRinging(dc,i);
        if (newRinging == null) {
          unknownConnectionAppeared=true;
        }
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc == null) {
      int count=foregroundCall.connections.size();
      if (count == 0) {
        droppedDuringPoll.add(conn);
      }
 else {
        for (int n=0; n < count; n++) {
          CdmaConnection cn=(CdmaConnection)foregroundCall.connections.get(n);
          droppedDuringPoll.add(cn);
        }
      }
      foregroundCall.setGeneric(false);
      if (mIsEcmTimerCanceled) {
        handleEcmTimer(phone.RESTART_ECM_TIMER);
      }
 else {
        mIsInEmergencyCall=false;
      }
      connections[i]=null;
    }
 else     if (conn != null && dc != null) {
      if (conn.isIncoming != dc.isMT) {
        if (dc.isMT == true) {
          droppedDuringPoll.add(conn);
          newRinging=checkMtFindNewRinging(dc,i);
          if (newRinging == null) {
            unknownConnectionAppeared=true;
          }
        }
 else {
          Log.e(LOG_TAG,""String_Node_Str"" + dc);
        }
      }
 else {
        boolean changed;
        changed=conn.update(dc);
        hasNonHangupStateChanged=hasNonHangupStateChanged || changed;
      }
    }
    if (REPEAT_POLLING) {
      if (dc != null) {
        if ((dc.state == DriverCall.State.DIALING) || (dc.state == DriverCall.State.ALERTING) || (dc.state == DriverCall.State.INCOMING)|| (dc.state == DriverCall.State.WAITING)) {
          needsPollDelay=true;
        }
      }
    }
  }
  if (pendingMO != null) {
    Log.d(LOG_TAG,""String_Node_Str"" + foregroundCall.getState());
    droppedDuringPoll.add(pendingMO);
    pendingMO=null;
    hangupPendingMO=false;
    if (pendingCallInEcm) {
      pendingCallInEcm=false;
    }
  }
  if (newRinging != null) {
    phone.notifyNewRingingConnection(newRinging);
  }
  for (int i=droppedDuringPoll.size() - 1; i >= 0; i--) {
    CdmaConnection conn=droppedDuringPoll.get(i);
    if (conn.isIncoming() && conn.getConnectTime() == 0) {
      Connection.DisconnectCause cause;
      if (conn.cause == Connection.DisconnectCause.LOCAL) {
        cause=Connection.DisconnectCause.INCOMING_REJECTED;
      }
 else {
        cause=Connection.DisconnectCause.INCOMING_MISSED;
      }
      if (Phone.DEBUG_PHONE) {
        log(""String_Node_Str"" + conn.cause);
        log(""String_Node_Str"" + cause);
      }
      droppedDuringPoll.remove(i);
      conn.onDisconnect(cause);
    }
 else     if (conn.cause == Connection.DisconnectCause.LOCAL) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.LOCAL);
    }
 else     if (conn.cause == Connection.DisconnectCause.INVALID_NUMBER) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.INVALID_NUMBER);
    }
  }
  if (droppedDuringPoll.size() > 0) {
    cm.getLastCallFailCause(obtainNoPollCompleteMessage(EVENT_GET_LAST_CALL_FAIL_CAUSE));
  }
  if (needsPollDelay) {
    pollCallsAfterDelay();
  }
  if (newRinging != null || hasNonHangupStateChanged) {
    internalClearDisconnected();
  }
  updatePhoneState();
  if (unknownConnectionAppeared) {
    phone.notifyUnknownConnection();
  }
  if (hasNonHangupStateChanged || newRinging != null) {
    phone.notifyPreciseCallStateChanged();
  }
}",0.7794102745972237
183231,"private void updatePhoneState(){
  Phone.State oldState=state;
  if (ringingCall.isRinging()) {
    state=Phone.State.RINGING;
  }
 else   if (pendingMO != null || !(foregroundCall.isIdle() && backgroundCall.isIdle())) {
    state=Phone.State.OFFHOOK;
  }
 else {
    state=Phone.State.IDLE;
  }
  if (state == Phone.State.IDLE && oldState != state) {
    voiceCallEndedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
 else   if (oldState == Phone.State.IDLE && oldState != state) {
    voiceCallStartedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
  if (state != oldState) {
    phone.notifyPhoneStateChanged();
  }
}","private void updatePhoneState(){
  Phone.State oldState=state;
  if (ringingCall.isRinging()) {
    state=Phone.State.RINGING;
  }
 else   if (pendingMO != null || !(foregroundCall.isIdle() && backgroundCall.isIdle())) {
    state=Phone.State.OFFHOOK;
  }
 else {
    state=Phone.State.IDLE;
  }
  if (state == Phone.State.IDLE && oldState != state) {
    voiceCallEndedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
 else   if (oldState == Phone.State.IDLE && oldState != state) {
    voiceCallStartedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
  if (Phone.DEBUG_PHONE) {
    log(""String_Node_Str"" + oldState + state);
  }
  if (state != oldState) {
    phone.notifyPhoneStateChanged();
  }
}",0.944206008583691
183232,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}",0.9967466807350744
183233,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(0);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}",0.9938553647392468
183234,"/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}","/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}",0.9951334999342364
183235,"/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(-1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9944895591647333
183236,"/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9933608469406064
183237,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}",0.9967466807350744
183238,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(0);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}",0.9938553647392468
183239,"/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}","/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}",0.9951334999342364
183240,"/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(-1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9944895591647333
183241,"/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}",0.9933608469406064
183242,"@Override public boolean onTouchEvent(MotionEvent event){
  if (!mIsUserSeekable || !isEnabled()) {
    return false;
  }
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    setPressed(true);
  onStartTrackingTouch();
trackTouchEvent(event);
break;
case MotionEvent.ACTION_MOVE:
trackTouchEvent(event);
attemptClaimDrag();
break;
case MotionEvent.ACTION_UP:
trackTouchEvent(event);
onStopTrackingTouch();
setPressed(false);
break;
case MotionEvent.ACTION_CANCEL:
onStopTrackingTouch();
setPressed(false);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (!mIsUserSeekable || !isEnabled()) {
    return false;
  }
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    setPressed(true);
  onStartTrackingTouch();
trackTouchEvent(event);
break;
case MotionEvent.ACTION_MOVE:
trackTouchEvent(event);
attemptClaimDrag();
break;
case MotionEvent.ACTION_UP:
trackTouchEvent(event);
onStopTrackingTouch();
setPressed(false);
invalidate();
break;
case MotionEvent.ACTION_CANCEL:
onStopTrackingTouch();
setPressed(false);
invalidate();
break;
}
return true;
}",0.9746835443037974
183243,"public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}","public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : EditorInfo.TYPE_CLASS_TEXT;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}",0.99774954125264
183244,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}",0.9985805097821392
183245,"/** 
 * @see AudioManager#setBluetoothScoOn() 
 */
public void setBluetoothScoOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_BT_SCO);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_BT_SCO);
    mForcedUseForComm=AudioSystem.FORCE_BT_SCO;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}","/** 
 * @see AudioManager#setBluetoothScoOn() 
 */
public void setBluetoothScoOn(boolean on){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_BT_SCO);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_BT_SCO);
    mForcedUseForComm=AudioSystem.FORCE_BT_SCO;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}",0.9357638888888888
183246,"/** 
 * @see AudioManager#setSpeakerphoneOn() 
 */
public void setSpeakerphoneOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_SPEAKER);
    mForcedUseForComm=AudioSystem.FORCE_SPEAKER;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}","/** 
 * @see AudioManager#setSpeakerphoneOn() 
 */
public void setSpeakerphoneOn(boolean on){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_SPEAKER);
    mForcedUseForComm=AudioSystem.FORCE_SPEAKER;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}",0.9127358490566038
183247,"public void onTerminate(){
  if (mWriter != null) {
    try {
      mWriter.flush();
      if (mOutputStream != null && mOutputStream instanceof FileOutputStream) {
        ((FileOutputStream)mOutputStream).getFD().sync();
      }
    }
 catch (    IOException e) {
      Log.d(LOG_TAG,""String_Node_Str"" + e.getMessage());
    }
 finally {
      try {
        mWriter.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","public void onTerminate(){
  mOnTerminateIsCalled=true;
  if (mWriter != null) {
    try {
      mWriter.flush();
      if (mOutputStream != null && mOutputStream instanceof FileOutputStream) {
        ((FileOutputStream)mOutputStream).getFD().sync();
      }
    }
 catch (    IOException e) {
      Log.d(LOG_TAG,""String_Node_Str"" + e.getMessage());
    }
 finally {
      try {
        mWriter.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.967741935483871
183248,"private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  for (  ContentValues contentValues : contentValuesList) {
    final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
    final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
    final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
    final String prefix=contentValues.getAsString(StructuredName.PREFIX);
    final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
    final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
    if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
      final String encodedFamily=escapeCharacters(familyName);
      final String encodedGiven=escapeCharacters(givenName);
      final String encodedMiddle=escapeCharacters(middleName);
      final String encodedPrefix=escapeCharacters(prefix);
      final String encodedSuffix=escapeCharacters(suffix);
      builder.append(VCARD_PROPERTY_NAME);
      if (!(VCardUtils.containsOnlyAscii(familyName) && VCardUtils.containsOnlyAscii(givenName) && VCardUtils.containsOnlyAscii(middleName)&& VCardUtils.containsOnlyAscii(prefix)&& VCardUtils.containsOnlyAscii(suffix))) {
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(mVCardAttributeCharset);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
      builder.append(VCARD_COL_SEPARATOR);
      final String encodedFullname=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),encodedFamily,encodedMiddle,encodedGiven,encodedPrefix,encodedSuffix);
      builder.append(VCARD_PROPERTY_FULL_NAME);
      builder.append(VCARD_ATTR_SEPARATOR);
      if (!VCardUtils.containsOnlyAscii(encodedFullname)) {
        builder.append(mVCardAttributeCharset);
        builder.append(VCARD_DATA_SEPARATOR);
      }
      builder.append(encodedFullname);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (!TextUtils.isEmpty(displayName)) {
      builder.append(VCARD_PROPERTY_NAME);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(mVCardAttributeCharset);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(escapeCharacters(displayName));
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (mIsDoCoMo) {
      appendVCardLine(builder,VCARD_PROPERTY_NAME,""String_Node_Str"");
    }
    String phoneticFamilyName=contentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String phoneticMiddleName=contentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String phoneticGivenName=contentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
      if (mIsJapaneseMobilePhone) {
        phoneticFamilyName=VCardUtils.toHalfWidthString(phoneticFamilyName);
        phoneticMiddleName=VCardUtils.toHalfWidthString(phoneticMiddleName);
        phoneticGivenName=VCardUtils.toHalfWidthString(phoneticGivenName);
      }
      if (mIsV30) {
        final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
        builder.append(VCARD_PROPERTY_SORT_STRING);
        if (!VCardUtils.containsOnlyAscii(sortString)) {
          builder.append(VCARD_ATTR_SEPARATOR);
          builder.append(mVCardAttributeCharset);
        }
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(sortString);
        builder.append(VCARD_COL_SEPARATOR);
      }
 else {
        builder.append(VCARD_PROPERTY_SOUND);
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(Constants.ATTR_TYPE_X_IRMC_N);
        builder.append(VCARD_ATTR_SEPARATOR);
        if (!(VCardUtils.containsOnlyAscii(phoneticFamilyName) && VCardUtils.containsOnlyAscii(phoneticMiddleName) && VCardUtils.containsOnlyAscii(phoneticGivenName))) {
          builder.append(mVCardAttributeCharset);
          builder.append(VCARD_DATA_SEPARATOR);
        }
        builder.append(escapeCharacters(phoneticFamilyName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticMiddleName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticGivenName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_COL_SEPARATOR);
        if (mUsesAndroidProperty) {
          final String phoneticName=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
          builder.append(VCARD_PROPERTY_X_PHONETIC_NAME);
          if (!VCardUtils.containsOnlyAscii(phoneticName)) {
            builder.append(VCARD_ATTR_SEPARATOR);
            builder.append(mVCardAttributeCharset);
          }
          builder.append(VCARD_DATA_SEPARATOR);
          builder.append(phoneticName);
          builder.append(VCARD_COL_SEPARATOR);
        }
      }
    }
 else     if (mIsDoCoMo) {
      builder.append(VCARD_PROPERTY_SOUND);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(Constants.ATTR_TYPE_X_IRMC_N);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
    if (mUsesDefactProperty) {
      if (!TextUtils.isEmpty(phoneticGivenName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_FIRST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticGivenName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticMiddleName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_MIDDLE_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticMiddleName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticFamilyName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_LAST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticFamilyName);
        builder.append(VCARD_COL_SEPARATOR);
      }
    }
  }
}","private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  for (  ContentValues contentValues : contentValuesList) {
    final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
    final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
    final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
    final String prefix=contentValues.getAsString(StructuredName.PREFIX);
    final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
    final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
    if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
      final String encodedFamily=escapeCharacters(familyName);
      final String encodedGiven=escapeCharacters(givenName);
      final String encodedMiddle=escapeCharacters(middleName);
      final String encodedPrefix=escapeCharacters(prefix);
      final String encodedSuffix=escapeCharacters(suffix);
      builder.append(VCARD_PROPERTY_NAME);
      if (!(VCardUtils.containsOnlyAscii(familyName) && VCardUtils.containsOnlyAscii(givenName) && VCardUtils.containsOnlyAscii(middleName)&& VCardUtils.containsOnlyAscii(prefix)&& VCardUtils.containsOnlyAscii(suffix))) {
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(mVCardAttributeCharset);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
      builder.append(VCARD_COL_SEPARATOR);
      final String encodedFullname=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),encodedFamily,encodedMiddle,encodedGiven,encodedPrefix,encodedSuffix);
      builder.append(VCARD_PROPERTY_FULL_NAME);
      if (!VCardUtils.containsOnlyAscii(encodedFullname)) {
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(mVCardAttributeCharset);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFullname);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (!TextUtils.isEmpty(displayName)) {
      builder.append(VCARD_PROPERTY_NAME);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(mVCardAttributeCharset);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(escapeCharacters(displayName));
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (mIsDoCoMo) {
      appendVCardLine(builder,VCARD_PROPERTY_NAME,""String_Node_Str"");
    }
    String phoneticFamilyName=contentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String phoneticMiddleName=contentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String phoneticGivenName=contentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
      if (mIsJapaneseMobilePhone) {
        phoneticFamilyName=VCardUtils.toHalfWidthString(phoneticFamilyName);
        phoneticMiddleName=VCardUtils.toHalfWidthString(phoneticMiddleName);
        phoneticGivenName=VCardUtils.toHalfWidthString(phoneticGivenName);
      }
      if (mIsV30) {
        final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
        builder.append(VCARD_PROPERTY_SORT_STRING);
        if (!VCardUtils.containsOnlyAscii(sortString)) {
          builder.append(VCARD_ATTR_SEPARATOR);
          builder.append(mVCardAttributeCharset);
        }
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(sortString);
        builder.append(VCARD_COL_SEPARATOR);
      }
 else {
        builder.append(VCARD_PROPERTY_SOUND);
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(Constants.ATTR_TYPE_X_IRMC_N);
        builder.append(VCARD_ATTR_SEPARATOR);
        if (!(VCardUtils.containsOnlyAscii(phoneticFamilyName) && VCardUtils.containsOnlyAscii(phoneticMiddleName) && VCardUtils.containsOnlyAscii(phoneticGivenName))) {
          builder.append(mVCardAttributeCharset);
          builder.append(VCARD_DATA_SEPARATOR);
        }
        builder.append(escapeCharacters(phoneticFamilyName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticMiddleName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticGivenName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_COL_SEPARATOR);
        if (mUsesAndroidProperty) {
          final String phoneticName=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
          builder.append(VCARD_PROPERTY_X_PHONETIC_NAME);
          if (!VCardUtils.containsOnlyAscii(phoneticName)) {
            builder.append(VCARD_ATTR_SEPARATOR);
            builder.append(mVCardAttributeCharset);
          }
          builder.append(VCARD_DATA_SEPARATOR);
          builder.append(phoneticName);
          builder.append(VCARD_COL_SEPARATOR);
        }
      }
    }
 else     if (mIsDoCoMo) {
      builder.append(VCARD_PROPERTY_SOUND);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(Constants.ATTR_TYPE_X_IRMC_N);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
    if (mUsesDefactProperty) {
      if (!TextUtils.isEmpty(phoneticGivenName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_FIRST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticGivenName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticMiddleName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_MIDDLE_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticMiddleName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticFamilyName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_LAST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticFamilyName);
        builder.append(VCARD_COL_SEPARATOR);
      }
    }
  }
}",0.9869356945855712
183249,"private void appendVCardEmailLine(StringBuilder builder,int type,String label,String data){
  builder.append(VCARD_PROPERTY_EMAIL);
  builder.append(VCARD_ATTR_SEPARATOR);
switch (type) {
case Email.TYPE_CUSTOM:
    if (label.equals(android.provider.Contacts.ContactMethodsColumns.MOBILE_EMAIL_TYPE_NAME)) {
      builder.append(Constants.ATTR_TYPE_CELL);
    }
 else     if (mUsesAndroidProperty && VCardUtils.containsOnlyAlphaDigitHyphen(label)) {
      builder.append(""String_Node_Str"");
      builder.append(label);
    }
 else {
      builder.append(Constants.ATTR_TYPE_INTERNET);
    }
  break;
case Email.TYPE_HOME:
builder.append(Constants.ATTR_TYPE_HOME);
break;
case Email.TYPE_WORK:
builder.append(Constants.ATTR_TYPE_WORK);
break;
case Email.TYPE_OTHER:
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + type);
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
}
builder.append(VCARD_DATA_SEPARATOR);
builder.append(data);
builder.append(VCARD_COL_SEPARATOR);
}","private void appendVCardEmailLine(StringBuilder builder,int type,String label,String data){
  builder.append(VCARD_PROPERTY_EMAIL);
  builder.append(VCARD_ATTR_SEPARATOR);
switch (type) {
case Email.TYPE_CUSTOM:
    if (label.equals(android.provider.Contacts.ContactMethodsColumns.MOBILE_EMAIL_TYPE_NAME)) {
      builder.append(Constants.ATTR_TYPE_CELL);
    }
 else     if (mUsesAndroidProperty && VCardUtils.containsOnlyAlphaDigitHyphen(label)) {
      builder.append(""String_Node_Str"");
      builder.append(label);
    }
 else {
      builder.append(Constants.ATTR_TYPE_INTERNET);
    }
  break;
case Email.TYPE_HOME:
builder.append(Constants.ATTR_TYPE_HOME);
break;
case Email.TYPE_WORK:
builder.append(Constants.ATTR_TYPE_WORK);
break;
case Email.TYPE_OTHER:
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
case Email.TYPE_MOBILE:
builder.append(Constants.ATTR_TYPE_CELL);
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + type);
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
}
builder.append(VCARD_DATA_SEPARATOR);
builder.append(data);
builder.append(VCARD_COL_SEPARATOR);
}",0.9655497876356772
183250,"@Override protected void handleAgent(String propertyValue) throws VCardException {
  throw new VCardException(""String_Node_Str"");
}","@Override protected void handleAgent(String propertyValue){
  if (!mEmittedAgentWarning) {
    Log.w(LOG_TAG,""String_Node_Str"");
    mEmittedAgentWarning=true;
  }
}",0.6283783783783784
183251,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.clear();
    mCreated=false;
  }
}","void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}",0.9934569247546348
183252,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.FILL_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.FILL_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.FILL_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.FILL_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}",0.9920472619859124
183253,private native void release();,"/** 
 * Release the local reference to the server-side surface. @hide 
 */
public native void release();",0.373134328358209
183254,"public void die(boolean immediate){
  checkThread();
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
synchronized (this) {
    if (mAdded && !mFirst) {
      int viewVisibility=mView.getVisibility();
      boolean viewVisibilityChanged=mViewVisibility != viewVisibility;
      if (mWindowAttributesChanged || viewVisibilityChanged) {
        try {
          if ((relayoutWindow(mWindowAttributes,viewVisibility,false) & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
            sWindowSession.finishDrawing(mWindow);
          }
        }
 catch (        RemoteException e) {
        }
      }
      mSurface.clear();
    }
    if (mAdded) {
      mAdded=false;
      if (immediate) {
        dispatchDetachedFromWindow();
      }
 else       if (mView != null) {
        sendEmptyMessage(DIE);
      }
    }
  }
}","public void die(boolean immediate){
  checkThread();
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
synchronized (this) {
    if (mAdded && !mFirst) {
      int viewVisibility=mView.getVisibility();
      boolean viewVisibilityChanged=mViewVisibility != viewVisibility;
      if (mWindowAttributesChanged || viewVisibilityChanged) {
        try {
          if ((relayoutWindow(mWindowAttributes,viewVisibility,false) & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
            sWindowSession.finishDrawing(mWindow);
          }
        }
 catch (        RemoteException e) {
        }
      }
      mSurface.release();
    }
    if (mAdded) {
      mAdded=false;
      if (immediate) {
        dispatchDetachedFromWindow();
      }
 else       if (mView != null) {
        sendEmptyMessage(DIE);
      }
    }
  }
}",0.993103448275862
183255,"void dispatchDetachedFromWindow(){
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
  if (mView != null) {
    mView.dispatchDetachedFromWindow();
  }
  mView=null;
  mAttachInfo.mRootView=null;
  mAttachInfo.mSurface=null;
  if (mUseGL) {
    destroyGL();
  }
  mSurface.clear();
  try {
    sWindowSession.remove(mWindow);
  }
 catch (  RemoteException e) {
  }
}","void dispatchDetachedFromWindow(){
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
  if (mView != null) {
    mView.dispatchDetachedFromWindow();
  }
  mView=null;
  mAttachInfo.mRootView=null;
  mAttachInfo.mSurface=null;
  if (mUseGL) {
    destroyGL();
  }
  mSurface.release();
  try {
    sWindowSession.remove(mWindow);
  }
 catch (  RemoteException e) {
  }
}",0.9856801909307876
183256,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (localLOGV)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.appInfo.processName == r.info.processName) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"");
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}",0.926161369193154
183257,"private final void bringDownServiceLocked(ServiceRecord r,boolean force){
  if (!force && r.startRequested) {
    return;
  }
  if (r.connections.size() > 0) {
    if (!force) {
      Iterator<ConnectionRecord> it=r.connections.values().iterator();
      while (it.hasNext()) {
        ConnectionRecord cr=it.next();
        if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
          return;
        }
      }
    }
    Iterator<ConnectionRecord> it=r.connections.values().iterator();
    while (it.hasNext()) {
      ConnectionRecord c=it.next();
      try {
        c.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.bindings.size() > 0 && r.app != null && r.app.thread != null) {
    Iterator<IntentBindRecord> it=r.bindings.values().iterator();
    while (it.hasNext()) {
      IntentBindRecord ibr=it.next();
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (r.app != null && r.app.thread != null && ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r);
          updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  EventLog.writeEvent(LOG_AM_DESTROY_SERVICE,System.identityHashCode(r),r.shortName,(r.app != null) ? r.app.pid : -1);
  mServices.remove(r.name);
  mServicesByIntent.remove(r.intent);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r.shortName);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.deliveredStarts.clear();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        Log.i(TAG,""String_Node_Str"" + r.shortName);
        bumpServiceExecutingLocked(r);
        mStoppingServices.add(r);
        updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
    }
  }
 else {
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + r.shortName);
  }
}","private final void bringDownServiceLocked(ServiceRecord r,boolean force){
  if (!force && r.startRequested) {
    return;
  }
  if (r.connections.size() > 0) {
    if (!force) {
      Iterator<ConnectionRecord> it=r.connections.values().iterator();
      while (it.hasNext()) {
        ConnectionRecord cr=it.next();
        if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
          return;
        }
      }
    }
    Iterator<ConnectionRecord> it=r.connections.values().iterator();
    while (it.hasNext()) {
      ConnectionRecord c=it.next();
      try {
        c.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.bindings.size() > 0 && r.app != null && r.app.thread != null) {
    Iterator<IntentBindRecord> it=r.bindings.values().iterator();
    while (it.hasNext()) {
      IntentBindRecord ibr=it.next();
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (r.app != null && r.app.thread != null && ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r);
          updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  EventLog.writeEvent(LOG_AM_DESTROY_SERVICE,System.identityHashCode(r),r.shortName,(r.app != null) ? r.app.pid : -1);
  mServices.remove(r.name);
  mServicesByIntent.remove(r.intent);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r.shortName);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.deliveredStarts.clear();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        if (DEBUG_SERVICE)         Log.v(TAG,""String_Node_Str"" + r.shortName);
        bumpServiceExecutingLocked(r);
        mStoppingServices.add(r);
        updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
    }
  }
 else {
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + r.shortName);
  }
}",0.8642845697804838
183258,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.2893606870229007
183259,"Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(looper){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}",0.9915730337078652
183260,"private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      mWindows.add(index,win);
      index++;
      added=true;
    }
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    mWindows.add(index,win);
    index++;
  }
  return index;
}","private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
      mWindows.add(index,win);
      index++;
      added=true;
    }
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ win);
    mWindows.add(index,win);
    index++;
  }
  return index;
}",0.7532894736842105
183261,"Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
  }
  if (config != null) {
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
  }
  return config;
}","Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
    if (config != null) {
      mLayoutNeeded=true;
      performLayoutAndPlaceSurfacesLocked();
    }
  }
  return config;
}",0.9436997319034852
183262,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}",0.9979363527750624
183263,"private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      mWindows.remove(win.mChildWindows.get(j));
    }
  }
  return NW > 0;
}","private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + win);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      WindowState cwin=(WindowState)win.mChildWindows.get(j);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + cwin);
      mWindows.remove(cwin);
    }
  }
  return NW > 0;
}",0.7468499427262314
183264,"private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}","private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  if (false) {
    RuntimeException e=new RuntimeException(""String_Node_Str"");
    e.fillInStackTrace();
    Log.w(TAG,""String_Node_Str"" + win,e);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}",0.9636757276882368
183265,"final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      mWindows.remove(i);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    AppWindowToken wt=mAppTokens.get(j);
    final int NTW=wt.windows.size();
    for (int k=0; k < NTW; k++) {
      WindowState win=wt.windows.get(k);
      final int NC=win.mChildWindows.size();
      int c;
      for (c=0; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        if (cwin.mSubLayer >= 0) {
          break;
        }
        mWindows.add(i,cwin);
        i++;
      }
      mWindows.add(i,win);
      i++;
      for (; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        mWindows.add(i,cwin);
        i++;
      }
    }
  }
}","final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      WindowState win=(WindowState)mWindows.remove(i);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + win);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mExitingAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mExitingAppTokens.get(j));
  }
  NT=mAppTokens.size();
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mAppTokens.get(j));
  }
}",0.4454849498327759
183266,"Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(looper){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}",0.9915730337078652
183267,"private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      mWindows.add(index,win);
      index++;
      added=true;
    }
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    mWindows.add(index,win);
    index++;
  }
  return index;
}","private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
      mWindows.add(index,win);
      index++;
      added=true;
    }
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ win);
    mWindows.add(index,win);
    index++;
  }
  return index;
}",0.7532894736842105
183268,"Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
  }
  if (config != null) {
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
  }
  return config;
}","Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
    if (config != null) {
      mLayoutNeeded=true;
      performLayoutAndPlaceSurfacesLocked();
    }
  }
  return config;
}",0.9436997319034852
183269,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}",0.9979363527750624
183270,"private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      mWindows.remove(win.mChildWindows.get(j));
    }
  }
  return NW > 0;
}","private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + win);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      WindowState cwin=(WindowState)win.mChildWindows.get(j);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + cwin);
      mWindows.remove(cwin);
    }
  }
  return NW > 0;
}",0.7468499427262314
183271,"private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}","private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  if (false) {
    RuntimeException e=new RuntimeException(""String_Node_Str"");
    e.fillInStackTrace();
    Log.w(TAG,""String_Node_Str"" + win,e);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}",0.9636757276882368
183272,"final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      mWindows.remove(i);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    AppWindowToken wt=mAppTokens.get(j);
    final int NTW=wt.windows.size();
    for (int k=0; k < NTW; k++) {
      WindowState win=wt.windows.get(k);
      final int NC=win.mChildWindows.size();
      int c;
      for (c=0; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        if (cwin.mSubLayer >= 0) {
          break;
        }
        mWindows.add(i,cwin);
        i++;
      }
      mWindows.add(i,win);
      i++;
      for (; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        mWindows.add(i,cwin);
        i++;
      }
    }
  }
}","final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      WindowState win=(WindowState)mWindows.remove(i);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + win);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mExitingAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mExitingAppTokens.get(j));
  }
  NT=mAppTokens.size();
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mAppTokens.get(j));
  }
}",0.4454849498327759
183273,"Globals(){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}",0.5280665280665281
183274,"static void initGlobals(Looper looper){
synchronized (mSync) {
    if (sGlobals == null) {
      sGlobals=new Globals();
    }
  }
}","static void initGlobals(Looper looper){
synchronized (mSync) {
    if (sGlobals == null) {
      sGlobals=new Globals(looper);
    }
  }
}",0.9777777777777776
183275,"InputBindResult startInputInnerLocked(){
  if (mCurMethodId == null) {
    return mNoBinding;
  }
  if (!mSystemReady) {
    return new InputBindResult(null,mCurId,mCurSeq);
  }
  InputMethodInfo info=mMethodMap.get(mCurMethodId);
  if (info == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  unbindCurrentMethodLocked(false);
  mCurIntent=new Intent(InputMethod.SERVICE_INTERFACE);
  mCurIntent.setComponent(info.getComponent());
  if (mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE)) {
    mLastBindTime=SystemClock.uptimeMillis();
    mHaveConnection=true;
    mCurId=info.getId();
    mCurToken=new Binder();
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mCurToken);
      mIWindowManager.addWindowToken(mCurToken,WindowManager.LayoutParams.TYPE_INPUT_METHOD);
    }
 catch (    RemoteException e) {
    }
    return new InputBindResult(null,mCurId,mCurSeq);
  }
 else {
    mCurIntent=null;
    Log.w(TAG,""String_Node_Str"" + mCurIntent);
  }
  return null;
}","InputBindResult startInputInnerLocked(){
  if (mCurMethodId == null) {
    return mNoBinding;
  }
  if (!mSystemReady) {
    return new InputBindResult(null,mCurMethodId,mCurSeq);
  }
  InputMethodInfo info=mMethodMap.get(mCurMethodId);
  if (info == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  unbindCurrentMethodLocked(false);
  mCurIntent=new Intent(InputMethod.SERVICE_INTERFACE);
  mCurIntent.setComponent(info.getComponent());
  if (mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE)) {
    mLastBindTime=SystemClock.uptimeMillis();
    mHaveConnection=true;
    mCurId=info.getId();
    mCurToken=new Binder();
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mCurToken);
      mIWindowManager.addWindowToken(mCurToken,WindowManager.LayoutParams.TYPE_INPUT_METHOD);
    }
 catch (    RemoteException e) {
    }
    return new InputBindResult(null,mCurId,mCurSeq);
  }
 else {
    mCurIntent=null;
    Log.w(TAG,""String_Node_Str"" + mCurIntent);
  }
  return null;
}",0.9971098265895952
183276,"public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mMethodMap) {
    if (mCurIntent != null && name.equals(mCurIntent.getComponent())) {
      mCurMethod=IInputMethod.Stub.asInterface(service);
      if (mCurClient != null) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + mCurToken);
        executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_ATTACH_TOKEN,mCurMethod,mCurToken));
        if (mCurClient != null) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mCurClient);
          executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_CREATE_SESSION,mCurMethod,new MethodCallback(mCurMethod)));
        }
      }
    }
  }
}","public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mMethodMap) {
    if (mCurIntent != null && name.equals(mCurIntent.getComponent())) {
      mCurMethod=IInputMethod.Stub.asInterface(service);
      if (mCurToken == null) {
        Log.w(TAG,""String_Node_Str"");
        unbindCurrentMethodLocked(false);
        return;
      }
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mCurToken);
      executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_ATTACH_TOKEN,mCurMethod,mCurToken));
      if (mCurClient != null) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + mCurClient);
        executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_CREATE_SESSION,mCurMethod,new MethodCallback(mCurMethod)));
      }
    }
  }
}",0.9057627118644068
183277,"boolean showCurrentInputLocked(int flags,ResultReceiver resultReceiver){
  mShowRequested=true;
  if ((flags & InputMethodManager.SHOW_IMPLICIT) == 0) {
    mShowExplicitlyRequested=true;
  }
  if ((flags & InputMethodManager.SHOW_FORCED) != 0) {
    mShowExplicitlyRequested=true;
    mShowForced=true;
  }
  boolean res=false;
  if (mCurMethod != null) {
    executeOrSendMessage(mCurMethod,mCaller.obtainMessageIOO(MSG_SHOW_SOFT_INPUT,getImeShowFlags(),mCurMethod,resultReceiver));
    mInputShown=true;
    res=true;
  }
 else   if (mHaveConnection && SystemClock.uptimeMillis() < (mLastBindTime + TIME_TO_RECONNECT)) {
    EventLog.writeEvent(LOG_IMF_FORCE_RECONNECT_IME,mCurMethodId,SystemClock.uptimeMillis() - mLastBindTime,1);
    mContext.unbindService(this);
    mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE);
  }
  return res;
}","boolean showCurrentInputLocked(int flags,ResultReceiver resultReceiver){
  mShowRequested=true;
  if ((flags & InputMethodManager.SHOW_IMPLICIT) == 0) {
    mShowExplicitlyRequested=true;
  }
  if ((flags & InputMethodManager.SHOW_FORCED) != 0) {
    mShowExplicitlyRequested=true;
    mShowForced=true;
  }
  if (!mSystemReady) {
    return false;
  }
  boolean res=false;
  if (mCurMethod != null) {
    executeOrSendMessage(mCurMethod,mCaller.obtainMessageIOO(MSG_SHOW_SOFT_INPUT,getImeShowFlags(),mCurMethod,resultReceiver));
    mInputShown=true;
    res=true;
  }
 else   if (mHaveConnection && SystemClock.uptimeMillis() < (mLastBindTime + TIME_TO_RECONNECT)) {
    EventLog.writeEvent(LOG_IMF_FORCE_RECONNECT_IME,mCurMethodId,SystemClock.uptimeMillis() - mLastBindTime,1);
    mContext.unbindService(this);
    mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE);
  }
  return res;
}",0.9744172825469016
183278,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
  IInputMethod method;
  ClientState client;
  final Printer p=new PrintWriterPrinter(pw);
synchronized (mMethodMap) {
    p.println(""String_Node_Str"");
    int N=mMethodList.size();
    p.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      InputMethodInfo info=mMethodList.get(i);
      p.println(""String_Node_Str"" + i + ""String_Node_Str"");
      info.dump(p,""String_Node_Str"");
    }
    p.println(""String_Node_Str"");
    for (    ClientState ci : mClients.values()) {
      p.println(""String_Node_Str"" + ci + ""String_Node_Str"");
      p.println(""String_Node_Str"" + ci.client);
      p.println(""String_Node_Str"" + ci.inputContext);
      p.println(""String_Node_Str"" + ci.sessionRequested);
      p.println(""String_Node_Str"" + ci.curSession);
    }
    p.println(""String_Node_Str"" + mInputMethodIcon);
    p.println(""String_Node_Str"" + mInputMethodData);
    p.println(""String_Node_Str"" + mCurMethodId);
    client=mCurClient;
    p.println(""String_Node_Str"" + client + ""String_Node_Str""+ mCurSeq);
    p.println(""String_Node_Str"" + mCurFocusedWindow);
    p.println(""String_Node_Str"" + mCurId + ""String_Node_Str""+ mHaveConnection+ ""String_Node_Str""+ mBoundToMethod);
    p.println(""String_Node_Str"" + mCurToken);
    p.println(""String_Node_Str"" + mCurIntent);
    method=mCurMethod;
    p.println(""String_Node_Str"" + mCurMethod);
    p.println(""String_Node_Str"" + mEnabledSession);
    p.println(""String_Node_Str"" + mShowRequested + ""String_Node_Str""+ mShowExplicitlyRequested+ ""String_Node_Str""+ mShowForced+ ""String_Node_Str""+ mInputShown);
    p.println(""String_Node_Str"" + mScreenOn);
  }
  if (client != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      client.client.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
  if (method != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      method.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
  IInputMethod method;
  ClientState client;
  final Printer p=new PrintWriterPrinter(pw);
synchronized (mMethodMap) {
    p.println(""String_Node_Str"");
    int N=mMethodList.size();
    p.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      InputMethodInfo info=mMethodList.get(i);
      p.println(""String_Node_Str"" + i + ""String_Node_Str"");
      info.dump(p,""String_Node_Str"");
    }
    p.println(""String_Node_Str"");
    for (    ClientState ci : mClients.values()) {
      p.println(""String_Node_Str"" + ci + ""String_Node_Str"");
      p.println(""String_Node_Str"" + ci.client);
      p.println(""String_Node_Str"" + ci.inputContext);
      p.println(""String_Node_Str"" + ci.sessionRequested);
      p.println(""String_Node_Str"" + ci.curSession);
    }
    p.println(""String_Node_Str"" + mInputMethodIcon);
    p.println(""String_Node_Str"" + mInputMethodData);
    p.println(""String_Node_Str"" + mCurMethodId);
    client=mCurClient;
    p.println(""String_Node_Str"" + client + ""String_Node_Str""+ mCurSeq);
    p.println(""String_Node_Str"" + mCurFocusedWindow);
    p.println(""String_Node_Str"" + mCurId + ""String_Node_Str""+ mHaveConnection+ ""String_Node_Str""+ mBoundToMethod);
    p.println(""String_Node_Str"" + mCurToken);
    p.println(""String_Node_Str"" + mCurIntent);
    method=mCurMethod;
    p.println(""String_Node_Str"" + mCurMethod);
    p.println(""String_Node_Str"" + mEnabledSession);
    p.println(""String_Node_Str"" + mShowRequested + ""String_Node_Str""+ mShowExplicitlyRequested+ ""String_Node_Str""+ mShowForced+ ""String_Node_Str""+ mInputShown);
    p.println(""String_Node_Str"" + mSystemReady + ""String_Node_Str""+ mScreenOn);
  }
  if (client != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      client.client.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
  if (method != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      method.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
}",0.992842105263158
183279,"public void systemReady(){
synchronized (mMethodMap) {
    if (!mSystemReady) {
      mSystemReady=true;
      startInputInnerLocked();
    }
  }
}","public void systemReady(){
synchronized (mMethodMap) {
    if (!mSystemReady) {
      mSystemReady=true;
      try {
        startInputInnerLocked();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}",0.7
183280,"private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      mWindows.add(index,win);
      index++;
      added=true;
    }
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    mWindows.add(index,win);
    index++;
  }
  return index;
}","private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
      mWindows.add(index,win);
      index++;
      added=true;
    }
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ win);
    mWindows.add(index,win);
    index++;
  }
  return index;
}",0.7532894736842105
183281,"Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
  }
  if (config != null) {
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
  }
  return config;
}","Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
    if (config != null) {
      mLayoutNeeded=true;
      performLayoutAndPlaceSurfacesLocked();
    }
  }
  return config;
}",0.9436997319034852
183282,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}",0.9979363527750624
183283,"private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      mWindows.remove(win.mChildWindows.get(j));
    }
  }
  return NW > 0;
}","private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + win);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      WindowState cwin=(WindowState)win.mChildWindows.get(j);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + cwin);
      mWindows.remove(cwin);
    }
  }
  return NW > 0;
}",0.7468499427262314
183284,"private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}","private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  if (false) {
    RuntimeException e=new RuntimeException(""String_Node_Str"");
    e.fillInStackTrace();
    Log.w(TAG,""String_Node_Str"" + win,e);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}",0.9636757276882368
183285,"final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      mWindows.remove(i);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    AppWindowToken wt=mAppTokens.get(j);
    final int NTW=wt.windows.size();
    for (int k=0; k < NTW; k++) {
      WindowState win=wt.windows.get(k);
      final int NC=win.mChildWindows.size();
      int c;
      for (c=0; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        if (cwin.mSubLayer >= 0) {
          break;
        }
        mWindows.add(i,cwin);
        i++;
      }
      mWindows.add(i,win);
      i++;
      for (; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        mWindows.add(i,cwin);
        i++;
      }
    }
  }
}","final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      WindowState win=(WindowState)mWindows.remove(i);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + win);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mExitingAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mExitingAppTokens.get(j));
  }
  NT=mAppTokens.size();
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mAppTokens.get(j));
  }
}",0.4454849498327759
183286,"Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(looper){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}",0.9915730337078652
183287,"public Connection dial(String dialString) throws CallStateException {
  String newDialString=PhoneNumberUtils.stripSeparators(dialString);
  if (!mCT.foregroundCall.isIdle()) {
    FeatureCode fc=FeatureCode.newFromDialString(newDialString,this);
    if (fc != null) {
      fc.processCode();
      return null;
    }
  }
  return mCT.dial(newDialString);
}","public Connection dial(String dialString) throws CallStateException {
  String newDialString=PhoneNumberUtils.stripSeparators(dialString);
  return mCT.dial(newDialString);
}",0.655367231638418
183288,"/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  if (unreadConversations == null) {
    return 0;
  }
 else {
    return unreadConversations;
  }
}","/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  if (unreadConversations == null) {
    return 0;
  }
 else {
    return unreadConversations < 0 ? 0 : unreadConversations;
  }
}",0.9572649572649572
183289,"/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  if (unreadConversations == null) {
    return 0;
  }
 else {
    return unreadConversations < 0 ? 0 : unreadConversations;
  }
}","/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  int result=0;
  if (unreadConversations != null) {
    result=unreadConversations < 0 ? 0 : unreadConversations;
  }
  return result;
}",0.6792963464140731
183290,"/** 
 * Compare the IMSI to the one stored in the login service's database.  If they differ, erase all passwords and authtokens (and store the new IMSI).
 */
@Override public void onReceive(Context context,Intent intent){
  String imsi=((TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE)).getSubscriberId();
  if (TextUtils.isEmpty(imsi))   return;
  String storedImsi=getMetaValue(""String_Node_Str"");
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + imsi + ""String_Node_Str""+ storedImsi);
  }
  if (!imsi.equals(storedImsi) && !""String_Node_Str"".equals(storedImsi)) {
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Log.v(TAG,""String_Node_Str"");
    }
    SQLiteDatabase db=mOpenHelper.getWritableDatabase();
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + TABLE_AUTHTOKENS);
      db.execSQL(""String_Node_Str"" + TABLE_ACCOUNTS + ""String_Node_Str""+ ACCOUNTS_PASSWORD+ ""String_Node_Str"");
      sendAccountsChangedBroadcast();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
  }
  setMetaValue(""String_Node_Str"",imsi);
}","/** 
 * Compare the IMSI to the one stored in the login service's database.  If they differ, erase all passwords and authtokens (and store the new IMSI).
 */
@Override public void onReceive(Context context,Intent intent){
  String imsi=((TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE)).getSubscriberId();
  if (TextUtils.isEmpty(imsi))   return;
  String storedImsi=getMetaValue(""String_Node_Str"");
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + imsi + ""String_Node_Str""+ storedImsi);
  }
  if (!imsi.equals(storedImsi) && !TextUtils.isEmpty(storedImsi)) {
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Log.v(TAG,""String_Node_Str"");
    }
    SQLiteDatabase db=mOpenHelper.getWritableDatabase();
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + TABLE_AUTHTOKENS);
      db.execSQL(""String_Node_Str"" + TABLE_ACCOUNTS + ""String_Node_Str""+ ACCOUNTS_PASSWORD+ ""String_Node_Str"");
      sendAccountsChangedBroadcast();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
  }
  setMetaValue(""String_Node_Str"",imsi);
}",0.9818342933097032
183291,"@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=new int[sid.length];
for (int i=0; i < sid.length; i++) {
try {
mHomeSystemId[i]=Integer.parseInt(sid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[1]);
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=new int[nid.length];
for (int i=0; i < nid.length; i++) {
try {
mHomeNetworkId[i]=Integer.parseInt(nid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[2]);
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
if (cdmaForSubscriptionInfoReadyRegistrants != null) {
cdmaForSubscriptionInfoReadyRegistrants.notifyRegistrants();
}
if (!mIsMinInfoReady) {
mIsMinInfoReady=true;
}
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
case EVENT_SET_RADIO_POWER_OFF:
synchronized (this) {
if (mPendingRadioPowerOffAfterDataOff) {
if (DBG) log(""String_Node_Str"");
cm.setRadioPower(false,null);
mPendingRadioPowerOffAfterDataOff=false;
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}","@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=new int[sid.length];
for (int i=0; i < sid.length; i++) {
try {
mHomeSystemId[i]=Integer.parseInt(sid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[1]);
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=new int[nid.length];
for (int i=0; i < nid.length; i++) {
try {
mHomeNetworkId[i]=Integer.parseInt(nid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[2]);
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
if (cdmaForSubscriptionInfoReadyRegistrants != null) {
cdmaForSubscriptionInfoReadyRegistrants.notifyRegistrants();
}
if (!mIsMinInfoReady) {
mIsMinInfoReady=true;
}
phone.getIccCard().broadcastIccStateChangedIntent(IccCard.INTENT_VALUE_ICC_IMSI,null);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
case EVENT_SET_RADIO_POWER_OFF:
synchronized (this) {
if (mPendingRadioPowerOffAfterDataOff) {
if (DBG) log(""String_Node_Str"");
cm.setRadioPower(false,null);
mPendingRadioPowerOffAfterDataOff=false;
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}",0.9909591603450068
183292,"/** 
 * <p>Set the range of the progress bar to 0...<tt>max</tt>.</p>
 * @param max the upper range of this progress bar
 * @see #getMax()
 * @see #setProgress(int) 
 * @see #setSecondaryProgress(int) 
 */
@android.view.RemotableViewMethod public synchronized void setMax(int max){
  if (max < 0) {
    max=0;
  }
  if (max != mMax) {
    mMax=max;
    postInvalidate();
    if (mProgress > max) {
      mProgress=max;
    }
  }
}","/** 
 * <p>Set the range of the progress bar to 0...<tt>max</tt>.</p>
 * @param max the upper range of this progress bar
 * @see #getMax()
 * @see #setProgress(int) 
 * @see #setSecondaryProgress(int) 
 */
@android.view.RemotableViewMethod public synchronized void setMax(int max){
  if (max < 0) {
    max=0;
  }
  if (max != mMax) {
    mMax=max;
    postInvalidate();
    if (mProgress > max) {
      mProgress=max;
      refreshProgress(R.id.progress,mProgress,false);
    }
  }
}",0.9409190371991248
183293,public abstract Handler getHandler();,"public Handler getHandler(){
  return this;
}",0.6829268292682927
183294,"/** 
 * Constructs a PhoneBase in normal (non-unit test) mode.
 * @param context Context object from hosting application
 * @param notifier An instance of DefaultPhoneNotifier,unless unit testing.
 * @param unitTestMode when true, prevents notificationsof state change events
 */
protected PhoneBase(PhoneNotifier notifier,Context context,boolean unitTestMode){
  this.mNotifier=notifier;
  this.mContext=context;
  mLooper=Looper.myLooper();
  setPropertiesByCarrier();
  setUnitTestMode(unitTestMode);
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  mDnsCheckDisabled=sp.getBoolean(DNS_SERVER_CHECK_DISABLED_KEY,false);
}","/** 
 * Constructs a PhoneBase in normal (non-unit test) mode.
 * @param context Context object from hosting application
 * @param notifier An instance of DefaultPhoneNotifier,unless unit testing.
 * @param unitTestMode when true, prevents notificationsof state change events
 */
protected PhoneBase(PhoneNotifier notifier,Context context,CommandsInterface ci,boolean unitTestMode){
  this.mNotifier=notifier;
  this.mContext=context;
  mLooper=Looper.myLooper();
  mCM=ci;
  setPropertiesByCarrier();
  setUnitTestMode(unitTestMode);
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  mDnsCheckDisabled=sp.getBoolean(DNS_SERVER_CHECK_DISABLED_KEY,false);
  mCM.setOnCallRing(this,EVENT_CALL_RING,null);
  mDoesRilSendMultipleCallRing=SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING,true);
  Log.d(LOG_TAG,""String_Node_Str"" + mDoesRilSendMultipleCallRing);
  mCallRingDelay=SystemProperties.getInt(TelephonyProperties.PROPERTY_CALL_RING_DELAY,3000);
  Log.d(LOG_TAG,""String_Node_Str"" + mCallRingDelay);
}",0.7592592592592593
183295,"public void executeMessage(Message message){
switch (message.what) {
case DO_ON_ACCESSIBILITY_EVENT:
    AccessibilityEvent event=(AccessibilityEvent)message.obj;
  mTarget.onAccessibilityEvent(event);
event.recycle();
return;
case DO_ON_INTERRUPT:
mTarget.onInterrupt();
return;
case DO_SET_SET_CONNECTION:
mConnection=((IAccessibilityServiceConnection)message.obj);
mTarget.onServiceConnected();
return;
default :
Log.w(LOG_TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ON_ACCESSIBILITY_EVENT:
    AccessibilityEvent event=(AccessibilityEvent)message.obj;
  if (event != null) {
    mTarget.onAccessibilityEvent(event);
    event.recycle();
  }
return;
case DO_ON_INTERRUPT:
mTarget.onInterrupt();
return;
case DO_SET_SET_CONNECTION:
mConnection=((IAccessibilityServiceConnection)message.obj);
mTarget.onServiceConnected();
return;
default :
Log.w(LOG_TAG,""String_Node_Str"" + message.what);
}
}",0.9659442724458204
183296,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}",0.9924465438944798
183297,"boolean adjustWallpaperWindowsLocked(){
  boolean changed=false;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
      if (!w.mAppToken.appFullscreen) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && !w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && w.mAppToken != null && w.mAppToken.animation != null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_NONE) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && foundW.mAppToken != null && oldW != null && oldW.mAppToken != null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundW.mAppToken.animation + ""String_Node_Str""+ oldW.mAppToken.animation);
      }
      if (foundW.mAppToken.animation != null && oldW.mAppToken.animation != null) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=!foundW.mObscured;
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
  foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(mWallpaperTarget,wallpaper,dw,dh);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed=true;
    }
  }
  return changed;
}","boolean adjustWallpaperWindowsLocked(){
  boolean changed=false;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
      if (!w.mAppToken.appFullscreen) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && w.mAppToken != null && w.mAppToken.animation != null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_NONE) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && foundW.mAppToken != null && oldW != null && oldW.mAppToken != null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundW.mAppToken.animation + ""String_Node_Str""+ oldW.mAppToken.animation);
      }
      if (foundW.mAppToken.animation != null && oldW.mAppToken.animation != null) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=!foundW.mObscured;
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
  foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(mWallpaperTarget,wallpaper,dw,dh);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed=true;
    }
  }
  return changed;
}",0.997564866907381
183298,"void commitFinishDrawingLocked(long currentTime){
  if (!mCommitDrawPending) {
    return;
  }
  mCommitDrawPending=false;
  mReadyToShow=true;
  final boolean starting=mAttrs.type == TYPE_APPLICATION_STARTING;
  final AppWindowToken atoken=mAppToken;
  if (atoken == null || atoken.allDrawn || starting) {
    performShowLocked();
  }
}","boolean commitFinishDrawingLocked(long currentTime){
  if (!mCommitDrawPending) {
    return false;
  }
  mCommitDrawPending=false;
  mReadyToShow=true;
  final boolean starting=mAttrs.type == TYPE_APPLICATION_STARTING;
  final AppWindowToken atoken=mAppToken;
  if (atoken == null || atoken.allDrawn || starting) {
    performShowLocked();
  }
  return true;
}",0.9541547277936964
183299,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}",0.9384521633150518
183300,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}",0.689119170984456
183301,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}",0.672929120409906
183302,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}",0.9577836411609498
183303,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}",0.9384521633150518
183304,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}",0.689119170984456
183305,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}",0.672929120409906
183306,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}",0.9577836411609498
183307,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}",0.9384521633150518
183308,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}",0.689119170984456
183309,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}",0.672929120409906
183310,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}",0.9577836411609498
183311,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}",0.9384521633150518
183312,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}",0.689119170984456
183313,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}",0.672929120409906
183314,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}",0.9577836411609498
183315,"@Override public boolean onTouchEvent(MotionEvent motionEvent){
  if (!mInputEnabled || !isEnabled()) {
    return false;
  }
  final float x=motionEvent.getX();
  final float y=motionEvent.getY();
  Cell hitCell;
switch (motionEvent.getAction()) {
case MotionEvent.ACTION_DOWN:
    resetPattern();
  hitCell=detectAndAddHit(x,y);
if (hitCell != null && mOnPatternListener != null) {
  mPatternInProgress=true;
  mPatternDisplayMode=DisplayMode.Correct;
  mOnPatternListener.onPatternStart();
}
 else if (mOnPatternListener != null) {
  mPatternInProgress=false;
  mOnPatternListener.onPatternCleared();
}
if (hitCell != null) {
final float startX=getCenterXForColumn(hitCell.column);
final float startY=getCenterYForRow(hitCell.row);
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidate((int)(startX - widthOffset),(int)(startY - heightOffset),(int)(startX + widthOffset),(int)(startY + heightOffset));
}
mInProgressX=x;
mInProgressY=y;
if (PROFILE_DRAWING) {
if (!mDrawingProfilingStarted) {
Debug.startMethodTracing(""String_Node_Str"");
mDrawingProfilingStarted=true;
}
}
return true;
case MotionEvent.ACTION_UP:
if (!mPattern.isEmpty() && mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternDetected(mPattern);
invalidate();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
case MotionEvent.ACTION_MOVE:
final int patternSizePreHitDetect=mPattern.size();
hitCell=detectAndAddHit(x,y);
final int patternSize=mPattern.size();
if (hitCell != null && (mOnPatternListener != null) && (patternSize == 1)) {
mPatternInProgress=true;
mOnPatternListener.onPatternStart();
}
final float dx=Math.abs(x - mInProgressX);
final float dy=Math.abs(y - mInProgressY);
if (dx + dy > mSquareWidth * 0.01f) {
float oldX=mInProgressX;
float oldY=mInProgressY;
mInProgressX=x;
mInProgressY=y;
if (mPatternInProgress) {
final ArrayList<Cell> pattern=mPattern;
final float radius=mSquareWidth * mDiameterFactor * 0.5f;
Cell cell=pattern.get(patternSize - 1);
float startX=getCenterXForColumn(cell.column);
float startY=getCenterYForRow(cell.row);
float left;
float top;
float right;
float bottom;
final Rect invalidateRect=mInvalidate;
if (startX < x) {
left=startX;
right=x;
}
 else {
left=x;
right=startX;
}
if (startY < y) {
top=startY;
bottom=y;
}
 else {
top=y;
bottom=startY;
}
invalidateRect.set((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
invalidateRect.union((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (hitCell != null) {
startX=getCenterXForColumn(hitCell.column);
startY=getCenterYForRow(hitCell.row);
if (patternSize >= 2) {
hitCell=pattern.get(patternSize - 1 - (patternSize - patternSizePreHitDetect));
oldX=getCenterXForColumn(hitCell.column);
oldY=getCenterYForRow(hitCell.row);
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
}
 else {
left=right=startX;
top=bottom=startY;
}
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidateRect.set((int)(left - widthOffset),(int)(top - heightOffset),(int)(right + widthOffset),(int)(bottom + heightOffset));
}
invalidate(invalidateRect);
}
 else {
invalidate();
}
}
return true;
case MotionEvent.ACTION_CANCEL:
resetPattern();
if (mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternCleared();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
}
return false;
}","@Override public boolean onTouchEvent(MotionEvent motionEvent){
  if (!mInputEnabled || !isEnabled()) {
    return false;
  }
  final float x=motionEvent.getX();
  final float y=motionEvent.getY();
  Cell hitCell;
switch (motionEvent.getAction()) {
case MotionEvent.ACTION_DOWN:
    resetPattern();
  hitCell=detectAndAddHit(x,y);
if (hitCell != null && mOnPatternListener != null) {
  mPatternInProgress=true;
  mPatternDisplayMode=DisplayMode.Correct;
  mOnPatternListener.onPatternStart();
}
 else if (mOnPatternListener != null) {
  mPatternInProgress=false;
  mOnPatternListener.onPatternCleared();
}
if (hitCell != null) {
final float startX=getCenterXForColumn(hitCell.column);
final float startY=getCenterYForRow(hitCell.row);
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidate((int)(startX - widthOffset),(int)(startY - heightOffset),(int)(startX + widthOffset),(int)(startY + heightOffset));
}
mInProgressX=x;
mInProgressY=y;
if (PROFILE_DRAWING) {
if (!mDrawingProfilingStarted) {
Debug.startMethodTracing(""String_Node_Str"");
mDrawingProfilingStarted=true;
}
}
return true;
case MotionEvent.ACTION_UP:
if (!mPattern.isEmpty() && mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternDetected(mPattern);
invalidate();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
case MotionEvent.ACTION_MOVE:
final int patternSizePreHitDetect=mPattern.size();
hitCell=detectAndAddHit(x,y);
final int patternSize=mPattern.size();
if (hitCell != null && (mOnPatternListener != null) && (patternSize == 1)) {
mPatternInProgress=true;
mOnPatternListener.onPatternStart();
}
final float dx=Math.abs(x - mInProgressX);
final float dy=Math.abs(y - mInProgressY);
if (dx + dy > mSquareWidth * 0.01f) {
float oldX=mInProgressX;
float oldY=mInProgressY;
mInProgressX=x;
mInProgressY=y;
if (mPatternInProgress) {
if (mPattern.isEmpty()) return false;
final ArrayList<Cell> pattern=mPattern;
final float radius=mSquareWidth * mDiameterFactor * 0.5f;
Cell cell=pattern.get(patternSize - 1);
float startX=getCenterXForColumn(cell.column);
float startY=getCenterYForRow(cell.row);
float left;
float top;
float right;
float bottom;
final Rect invalidateRect=mInvalidate;
if (startX < x) {
left=startX;
right=x;
}
 else {
left=x;
right=startX;
}
if (startY < y) {
top=startY;
bottom=y;
}
 else {
top=y;
bottom=startY;
}
invalidateRect.set((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
invalidateRect.union((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (hitCell != null) {
startX=getCenterXForColumn(hitCell.column);
startY=getCenterYForRow(hitCell.row);
if (patternSize >= 2) {
hitCell=pattern.get(patternSize - 1 - (patternSize - patternSizePreHitDetect));
oldX=getCenterXForColumn(hitCell.column);
oldY=getCenterYForRow(hitCell.row);
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
}
 else {
left=right=startX;
top=bottom=startY;
}
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidateRect.set((int)(left - widthOffset),(int)(top - heightOffset),(int)(right + widthOffset),(int)(bottom + heightOffset));
}
invalidate(invalidateRect);
}
 else {
invalidate();
}
}
return true;
case MotionEvent.ACTION_CANCEL:
resetPattern();
if (mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternCleared();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
}
return false;
}",0.9951456310679612
183316,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}",0.9987568488420278
183317,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  if (Network.getInstance(mContext).checkSslPrefTable(this,error)) {
    return true;
  }
  if (isSynchronous()) {
    mRequestHandle.handleSslErrorResponse(false);
    return true;
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}",0.8540031397174255
183318,"/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0));
}","/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0,mLoaderQueue.poll()));
}",0.943502824858757
183319,"/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(boolean proceed){
  LoadListener loader=mLoaderQueue.poll();
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=loader.sslError().getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}","/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(LoadListener loader,SslError error,boolean proceed){
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
    Assert.assertNotNull(error);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=error.getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}",0.9223584354932868
183320,"/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}","/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
synchronized boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}",0.9809104258443464
183321,"/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0));
}","/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0,mLoaderQueue.poll()));
}",0.9236641221374046
183322,"/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}","/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
synchronized boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}",0.9748549323017408
183323,"/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    int primary=error.getPrimaryError();
    String host=loader.host();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertTrue(host != null && primary != 0);
    }
    if (mSslPrefTable.containsKey(host)) {
      if (primary <= mSslPrefTable.getInt(host)) {
        handleSslErrorResponse(true);
        return true;
      }
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}","/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      mLoaderQueue.remove(loader);
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    if (checkSslPrefTable(loader,error)) {
      mLoaderQueue.remove(loader);
      return true;
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}",0.714828897338403
183324,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    handleSslErrorResponse(msg.arg1 == 1);
  fastProcessQueuedSslErrors();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    LoadListener loader=(LoadListener)msg.obj;
  handleSslErrorResponse(loader,loader.sslError(),msg.arg1 == 1);
fastProcessQueuedSslErrors();
break;
}
}",0.8293838862559242
183325,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  if (Network.getInstance(mContext).checkSslPrefTable(this,error)) {
    return true;
  }
  if (isSynchronous()) {
    mRequestHandle.handleSslErrorResponse(false);
    return true;
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}",0.8540031397174255
183326,"/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0));
}","/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0,mLoaderQueue.poll()));
}",0.943502824858757
183327,"/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(boolean proceed){
  LoadListener loader=mLoaderQueue.poll();
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=loader.sslError().getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}","/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(LoadListener loader,SslError error,boolean proceed){
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
    Assert.assertNotNull(error);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=error.getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}",0.9223584354932868
183328,"/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}","/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
synchronized boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}",0.9809104258443464
183329,"/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0));
}","/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0,mLoaderQueue.poll()));
}",0.9236641221374046
183330,"/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}","/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
synchronized boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}",0.9748549323017408
183331,"/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    int primary=error.getPrimaryError();
    String host=loader.host();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertTrue(host != null && primary != 0);
    }
    if (mSslPrefTable.containsKey(host)) {
      if (primary <= mSslPrefTable.getInt(host)) {
        handleSslErrorResponse(true);
        return true;
      }
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}","/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      mLoaderQueue.remove(loader);
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    if (checkSslPrefTable(loader,error)) {
      mLoaderQueue.remove(loader);
      return true;
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}",0.714828897338403
183332,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    handleSslErrorResponse(msg.arg1 == 1);
  fastProcessQueuedSslErrors();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    LoadListener loader=(LoadListener)msg.obj;
  handleSslErrorResponse(loader,loader.sslError(),msg.arg1 == 1);
fastProcessQueuedSslErrors();
break;
}
}",0.8293838862559242
183333,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  if (Network.getInstance(mContext).checkSslPrefTable(this,error)) {
    return true;
  }
  if (isSynchronous()) {
    mRequestHandle.handleSslErrorResponse(false);
    return true;
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}",0.8540031397174255
183334,"/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0));
}","/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0,mLoaderQueue.poll()));
}",0.943502824858757
183335,"/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(boolean proceed){
  LoadListener loader=mLoaderQueue.poll();
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=loader.sslError().getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}","/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(LoadListener loader,SslError error,boolean proceed){
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
    Assert.assertNotNull(error);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=error.getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}",0.9223584354932868
183336,"/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}","/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
synchronized boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}",0.9809104258443464
183337,"/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0));
}","/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0,mLoaderQueue.poll()));
}",0.9236641221374046
183338,"/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}","/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
synchronized boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}",0.9748549323017408
183339,"/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    int primary=error.getPrimaryError();
    String host=loader.host();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertTrue(host != null && primary != 0);
    }
    if (mSslPrefTable.containsKey(host)) {
      if (primary <= mSslPrefTable.getInt(host)) {
        handleSslErrorResponse(true);
        return true;
      }
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}","/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      mLoaderQueue.remove(loader);
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    if (checkSslPrefTable(loader,error)) {
      mLoaderQueue.remove(loader);
      return true;
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}",0.714828897338403
183340,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    handleSslErrorResponse(msg.arg1 == 1);
  fastProcessQueuedSslErrors();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    LoadListener loader=(LoadListener)msg.obj;
  handleSslErrorResponse(loader,loader.sslError(),msg.arg1 == 1);
fastProcessQueuedSslErrors();
break;
}
}",0.8293838862559242
183341,"@Override public EGLConfig chooseConfig(EGL10 egl,EGLDisplay display,EGLConfig[] configs){
  EGLConfig closestConfig=null;
  int closestDistance=1000;
  for (  EGLConfig config : configs) {
    int r=findConfigAttrib(egl,display,config,EGL10.EGL_RED_SIZE,0);
    int g=findConfigAttrib(egl,display,config,EGL10.EGL_GREEN_SIZE,0);
    int b=findConfigAttrib(egl,display,config,EGL10.EGL_BLUE_SIZE,0);
    int a=findConfigAttrib(egl,display,config,EGL10.EGL_ALPHA_SIZE,0);
    int d=findConfigAttrib(egl,display,config,EGL10.EGL_DEPTH_SIZE,0);
    int s=findConfigAttrib(egl,display,config,EGL10.EGL_STENCIL_SIZE,0);
    int distance=Math.abs(r - mRedSize) + Math.abs(g - mGreenSize) + Math.abs(b - mBlueSize)+ Math.abs(a - mAlphaSize)+ Math.abs(d - mDepthSize)+ Math.abs(s - mStencilSize);
    if (distance < closestDistance) {
      closestDistance=distance;
      closestConfig=config;
    }
  }
  return closestConfig;
}","@Override public EGLConfig chooseConfig(EGL10 egl,EGLDisplay display,EGLConfig[] configs){
  EGLConfig closestConfig=null;
  int closestDistance=1000;
  for (  EGLConfig config : configs) {
    int d=findConfigAttrib(egl,display,config,EGL10.EGL_DEPTH_SIZE,0);
    int s=findConfigAttrib(egl,display,config,EGL10.EGL_STENCIL_SIZE,0);
    if (d >= mDepthSize && s >= mStencilSize) {
      int r=findConfigAttrib(egl,display,config,EGL10.EGL_RED_SIZE,0);
      int g=findConfigAttrib(egl,display,config,EGL10.EGL_GREEN_SIZE,0);
      int b=findConfigAttrib(egl,display,config,EGL10.EGL_BLUE_SIZE,0);
      int a=findConfigAttrib(egl,display,config,EGL10.EGL_ALPHA_SIZE,0);
      int distance=Math.abs(r - mRedSize) + Math.abs(g - mGreenSize) + Math.abs(b - mBlueSize)+ Math.abs(a - mAlphaSize);
      if (distance < closestDistance) {
        closestDistance=distance;
        closestConfig=config;
      }
    }
  }
  return closestConfig;
}",0.6745435016111708
183342,"/** 
 * This function checks if there is a plus sign (+) in the passed-in dialing number. If there is, it processes the plus sign based on the default telephone numbering plan of the system when the phone is activated and the current telephone numbering plan of the system that the phone is camped on. Currently, we only support the case that the default and current telephone numbering plans are North American Numbering Plan(NANP). The passed-in dialStr should only contain the valid format as described below, 1) the 1st character in the dialStr should be one of the really dialable characters listed below ISO-LATIN characters 0-9, *, # , + 2) the dialStr should already strip out the separator characters, every character in the dialStr should be one of the non separator characters listed below ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE Otherwise, this function returns the dial string passed in This API is for CDMA only
 * @hide TODO: pending API Council approval
 */
public static String cdmaCheckAndProcessPlusCode(String dialStr){
  if (!TextUtils.isEmpty(dialStr)) {
    if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
      return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr,getFormatTypeForLocale(Locale.getDefault()));
    }
  }
  return dialStr;
}","/** 
 * This function checks if there is a plus sign (+) in the passed-in dialing number. If there is, it processes the plus sign based on the default telephone numbering plan of the system when the phone is activated and the current telephone numbering plan of the system that the phone is camped on. Currently, we only support the case that the default and current telephone numbering plans are North American Numbering Plan(NANP). The passed-in dialStr should only contain the valid format as described below, 1) the 1st character in the dialStr should be one of the really dialable characters listed below ISO-LATIN characters 0-9, *, # , + 2) the dialStr should already strip out the separator characters, every character in the dialStr should be one of the non separator characters listed below ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE Otherwise, this function returns the dial string passed in
 * @param dialStr the original dial string
 * @return the converted dial string if the current/default countries belong to NANP,and if there is the ""+"" in the original dial string. Otherwise, the original dial string returns. This API is for CDMA only
 * @hide TODO: pending API Council approval
 */
public static String cdmaCheckAndProcessPlusCode(String dialStr){
  if (!TextUtils.isEmpty(dialStr)) {
    if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
      String currIso=SystemProperties.get(PROPERTY_OPERATOR_ISO_COUNTRY,""String_Node_Str"");
      String defaultIso=SystemProperties.get(PROPERTY_ICC_OPERATOR_ISO_COUNTRY,""String_Node_Str"");
      if (!TextUtils.isEmpty(currIso) && !TextUtils.isEmpty(defaultIso)) {
        return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr,getFormatTypeFromCountryCode(currIso),getFormatTypeFromCountryCode(defaultIso));
      }
    }
  }
  return dialStr;
}",0.8132357620108177
183343,"/** 
 * This function handles the plus code conversion within NANP CDMA network If the number format is 1)+NANP or +1NANP,remove +, 2)+non-NANP Numbers,replace + with the current IDP
 */
private static String processPlusCodeWithinNanp(String networkDialStr){
  String retStr=networkDialStr;
  if (DBG)   log(""String_Node_Str"" + networkDialStr);
  if (networkDialStr != null & networkDialStr.charAt(0) == PLUS_SIGN_CHAR && networkDialStr.length() > 1) {
    String newStr=networkDialStr.substring(1);
    if (isNanp(newStr) || isOneNanp(newStr)) {
      retStr=newStr;
    }
 else {
      String idpStr=getDefaultIdp();
      retStr=networkDialStr.replaceFirst(""String_Node_Str"",idpStr);
    }
  }
  if (DBG)   log(""String_Node_Str"" + retStr);
  return retStr;
}","/** 
 * This function handles the plus code conversion within NANP CDMA network If the number format is 1)+1NANP,remove +, 2)other than +1NANP, any + numbers,replace + with the current IDP
 */
private static String processPlusCodeWithinNanp(String networkDialStr){
  String retStr=networkDialStr;
  if (DBG)   log(""String_Node_Str"" + networkDialStr);
  if (networkDialStr != null & networkDialStr.charAt(0) == PLUS_SIGN_CHAR && networkDialStr.length() > 1) {
    String newStr=networkDialStr.substring(1);
    if (isOneNanp(newStr)) {
      retStr=newStr;
    }
 else {
      String idpStr=getDefaultIdp();
      retStr=networkDialStr.replaceFirst(""String_Node_Str"",idpStr);
    }
  }
  if (DBG)   log(""String_Node_Str"" + retStr);
  return retStr;
}",0.952317880794702
183344,"/** 
 * Returns the phone number formatting type for the given locale.
 * @param locale The locale of interest, usually {@link Locale#getDefault()}
 * @return the formatting type for the given locale, or FORMAT_UNKNOWN if the formattingrules are not known for the given locale
 */
public static int getFormatTypeForLocale(Locale locale){
  String country=locale.getCountry();
  int length=NANP_COUNTRIES.length;
  for (int i=0; i < length; i++) {
    if (NANP_COUNTRIES[i].equals(country)) {
      return FORMAT_NANP;
    }
  }
  if (locale.equals(Locale.JAPAN)) {
    return FORMAT_JAPAN;
  }
  return FORMAT_UNKNOWN;
}","/** 
 * Returns the phone number formatting type for the given locale.
 * @param locale The locale of interest, usually {@link Locale#getDefault()}
 * @return the formatting type for the given locale, or FORMAT_UNKNOWN if the formattingrules are not known for the given locale
 */
public static int getFormatTypeForLocale(Locale locale){
  String country=locale.getCountry();
  return getFormatTypeFromCountryCode(country);
}",0.7311004784688995
183345,"/** 
 * This function should be called from checkAndProcessPlusCode only And it is used for test purpose also. It checks the dial string by looping through the network portion, post dial portion 1, post dial porting 2, etc. If there is any plus sign, then process the plus sign. Currently, this function supports the plus sign conversion within NANP only. Specifically, it handles the plus sign in the following ways: 1)+NANP or +1NANP,remove +, e.g. +8475797000 is converted to 8475797000, +18475797000 is converted to 18475797000, 2)+non-NANP Numbers,replace + with the current NANP IDP, e.g, +11875767800 is converted to 01111875767800 3)+NANP in post dial string(s), e.g. 8475797000;+8475231753 is converted to 8475797000;8475231753 This function returns the original dial string if locale/numbering plan aren't supported.
 * @hide
 */
public static String cdmaCheckAndProcessPlusCodeByNumberFormat(String dialStr,int numFormat){
  String retStr=dialStr;
  if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
    String postDialStr=null;
    String tempDialStr=dialStr;
    retStr=null;
    if (DBG)     log(""String_Node_Str"" + dialStr);
    do {
      String networkDialStr;
      if (numFormat != FORMAT_NANP) {
        Log.e(""String_Node_Str"",dialStr);
        return dialStr;
      }
 else {
        networkDialStr=extractNetworkPortion(tempDialStr);
        networkDialStr=processPlusCodeWithinNanp(networkDialStr);
      }
      if (!TextUtils.isEmpty(networkDialStr)) {
        if (retStr == null) {
          retStr=networkDialStr;
        }
 else {
          retStr=retStr.concat(networkDialStr);
        }
      }
 else {
        Log.e(""String_Node_Str"",networkDialStr);
        return dialStr;
      }
      postDialStr=extractPostDialPortion(tempDialStr);
      if (!TextUtils.isEmpty(postDialStr)) {
        int dialableIndex=findDialableIndexFromPostDialStr(postDialStr);
        if (dialableIndex >= 1) {
          retStr=appendPwCharBackToOrigDialStr(dialableIndex,retStr,postDialStr);
          tempDialStr=postDialStr.substring(dialableIndex);
        }
 else {
          if (dialableIndex < 0) {
            postDialStr=""String_Node_Str"";
          }
          Log.e(""String_Node_Str"",postDialStr);
        }
      }
      if (DBG)       log(""String_Node_Str"" + postDialStr);
    }
 while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
  }
  return retStr;
}","/** 
 * This function should be called from checkAndProcessPlusCode only And it is used for test purpose also. It checks the dial string by looping through the network portion, post dial portion 1, post dial porting 2, etc. If there is any plus sign, then process the plus sign. Currently, this function supports the plus sign conversion within NANP only. Specifically, it handles the plus sign in the following ways: 1)+1NANP,remove +, e.g. +18475797000 is converted to 18475797000, 2)+NANP or +non-NANP Numbers,replace + with the current NANP IDP, e.g, +8475797000 is converted to 0118475797000, +11875767800 is converted to 01111875767800 3)+1NANP in post dial string(s), e.g. 8475797000;+18475231753 is converted to 8475797000;18475231753
 * @param dialStr the original dial string
 * @param currFormat the numbering system of the current country that the phone is camped on
 * @param defaultFormat the numbering system of the country that the phone is activated on
 * @return the converted dial string if the current/default countries belong to NANP,and if there is the ""+"" in the original dial string. Otherwise, the original dial string returns.
 * @hide
 */
public static String cdmaCheckAndProcessPlusCodeByNumberFormat(String dialStr,int currFormat,int defaultFormt){
  String retStr=dialStr;
  if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
    if ((currFormat == defaultFormt) && (currFormat == FORMAT_NANP)) {
      String postDialStr=null;
      String tempDialStr=dialStr;
      retStr=null;
      if (DBG)       log(""String_Node_Str"" + dialStr);
      do {
        String networkDialStr;
        networkDialStr=extractNetworkPortion(tempDialStr);
        networkDialStr=processPlusCodeWithinNanp(networkDialStr);
        if (!TextUtils.isEmpty(networkDialStr)) {
          if (retStr == null) {
            retStr=networkDialStr;
          }
 else {
            retStr=retStr.concat(networkDialStr);
          }
        }
 else {
          Log.e(""String_Node_Str"",networkDialStr);
          return dialStr;
        }
        postDialStr=extractPostDialPortion(tempDialStr);
        if (!TextUtils.isEmpty(postDialStr)) {
          int dialableIndex=findDialableIndexFromPostDialStr(postDialStr);
          if (dialableIndex >= 1) {
            retStr=appendPwCharBackToOrigDialStr(dialableIndex,retStr,postDialStr);
            tempDialStr=postDialStr.substring(dialableIndex);
          }
 else {
            if (dialableIndex < 0) {
              postDialStr=""String_Node_Str"";
            }
            Log.e(""String_Node_Str"",postDialStr);
          }
        }
        if (DBG)         log(""String_Node_Str"" + postDialStr);
      }
 while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
    }
 else {
      Log.e(""String_Node_Str"",dialStr);
    }
  }
  return retStr;
}",0.7802929427430093
183346,"@SmallTest public void testCheckAndProcessPlusCodeByNumberFormat(){
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_UNKNOWN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_UNKNOWN));
}","@SmallTest public void testCheckAndProcessPlusCodeByNumberFormat(){
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_NANP,PhoneNumberUtils.FORMAT_NANP));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_NANP,PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_NANP,PhoneNumberUtils.FORMAT_UNKNOWN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_JAPAN,PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_UNKNOWN,PhoneNumberUtils.FORMAT_UNKNOWN));
}",0.8096141682479443
183347,"/** 
 * Ensure that a network route exists to deliver traffic to the specified host via the mobile data network.
 * @param hostAddress the IP address of the host to which the route is desired,in network byte order.
 * @return {@code true} on success, {@code false} on failure
 */
@Override public boolean requestRouteToHost(int hostAddress){
  if (mInterfaceName != null && hostAddress != -1) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + Integer.toHexString(hostAddress));
    }
    return NetworkUtils.addHostRoute(mInterfaceName,hostAddress) == 0;
  }
 else {
    return false;
  }
}","/** 
 * Ensure that a network route exists to deliver traffic to the specified host via the mobile data network.
 * @param hostAddress the IP address of the host to which the route is desired,in network byte order.
 * @return {@code true} on success, {@code false} on failure
 */
@Override public boolean requestRouteToHost(int hostAddress){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + Integer.toHexString(hostAddress) + ""String_Node_Str""+ mApnType+ ""String_Node_Str""+ mInterfaceName+ ""String_Node_Str"");
  }
  if (mInterfaceName != null && hostAddress != -1) {
    return NetworkUtils.addHostRoute(mInterfaceName,hostAddress) == 0;
  }
 else {
    return false;
  }
}",0.8449367088607594
183348,"public void onReceive(Context context,Intent intent){
synchronized (this) {
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
      Phone.DataState state=getMobileDataState(intent);
      String reason=intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
      String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
      String apnTypeList=intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
      boolean unavailable=intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
      if (DBG)       Log.d(TAG,mApnType + ""String_Node_Str"" + intent.getAction()+ ""String_Node_Str""+ state+ ""String_Node_Str""+ unavailable+ ""String_Node_Str""+ (reason == null ? ""String_Node_Str"" : reason));
      if (isApnTypeIncluded(apnTypeList)) {
        if (mEnabled == false) {
          if (mInterfaceName == null && state == Phone.DataState.CONNECTED) {
            mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
          }
 else           if (state == Phone.DataState.DISCONNECTED) {
            mInterfaceName=null;
          }
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return;
        }
      }
 else {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return;
      }
      mNetworkInfo.setIsAvailable(!unavailable);
      if (mMobileDataState != state) {
        mMobileDataState=state;
switch (state) {
case DISCONNECTED:
          if (isTeardownRequested()) {
            mEnabled=false;
            setTeardownRequested(false);
          }
        setDetailedState(DetailedState.DISCONNECTED,reason,apnName);
      if (mInterfaceName != null) {
        NetworkUtils.resetConnections(mInterfaceName);
      }
    mInterfaceName=null;
  mDefaultGatewayAddr=0;
break;
case CONNECTING:
setDetailedState(DetailedState.CONNECTING,reason,apnName);
break;
case SUSPENDED:
setDetailedState(DetailedState.SUSPENDED,reason,apnName);
break;
case CONNECTED:
mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
if (mInterfaceName == null) {
Log.d(TAG,""String_Node_Str"");
}
setDetailedState(DetailedState.CONNECTED,reason,apnName);
break;
}
}
}
 else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
mEnabled=false;
String reason=intent.getStringExtra(Phone.FAILURE_REASON_KEY);
String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
if (DBG) Log.d(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ reason == null ? ""String_Node_Str"" : ""String_Node_Str"" + reason + ""String_Node_Str"");
setDetailedState(DetailedState.FAILED,reason,apnName);
}
TelephonyManager tm=TelephonyManager.getDefault();
setRoamingStatus(tm.isNetworkRoaming());
setSubtype(tm.getNetworkType(),tm.getNetworkTypeName());
}
}","public void onReceive(Context context,Intent intent){
synchronized (this) {
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
      Phone.DataState state=getMobileDataState(intent);
      String reason=intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
      String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
      String apnTypeList=intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
      boolean unavailable=intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
      if (DBG)       Log.d(TAG,mApnType + ""String_Node_Str"" + intent.getAction()+ ""String_Node_Str""+ state+ ""String_Node_Str""+ mMobileDataState+ ""String_Node_Str""+ unavailable+ ""String_Node_Str""+ (reason == null ? ""String_Node_Str"" : reason));
      if (isApnTypeIncluded(apnTypeList)) {
        if (mEnabled == false) {
          if (state == Phone.DataState.CONNECTED) {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + mInterfaceName + ""String_Node_Str""+ intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY)+ ""String_Node_Str""+ mApnType);
            mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
          }
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return;
        }
      }
 else {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return;
      }
      mNetworkInfo.setIsAvailable(!unavailable);
      if (mMobileDataState != state) {
        mMobileDataState=state;
switch (state) {
case DISCONNECTED:
          if (isTeardownRequested()) {
            mEnabled=false;
            setTeardownRequested(false);
          }
        setDetailedState(DetailedState.DISCONNECTED,reason,apnName);
      if (mInterfaceName != null) {
        NetworkUtils.resetConnections(mInterfaceName);
      }
    if (DBG)     Log.d(TAG,""String_Node_Str"" + mApnType + ""String_Node_Str"");
  mInterfaceName=null;
mDefaultGatewayAddr=0;
break;
case CONNECTING:
setDetailedState(DetailedState.CONNECTING,reason,apnName);
break;
case SUSPENDED:
setDetailedState(DetailedState.SUSPENDED,reason,apnName);
break;
case CONNECTED:
mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
if (mInterfaceName == null) {
Log.d(TAG,""String_Node_Str"");
}
setDetailedState(DetailedState.CONNECTED,reason,apnName);
break;
}
}
}
 else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
mEnabled=false;
String reason=intent.getStringExtra(Phone.FAILURE_REASON_KEY);
String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
if (DBG) Log.d(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ reason == null ? ""String_Node_Str"" : ""String_Node_Str"" + reason + ""String_Node_Str"");
setDetailedState(DetailedState.FAILED,reason,apnName);
}
TelephonyManager tm=TelephonyManager.getDefault();
setRoamingStatus(tm.isNetworkRoaming());
setSubtype(tm.getNetworkType(),tm.getNetworkTypeName());
}
}",0.7243090007087172
183349,"/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnType);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}","/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnType);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}",0.9781871061560834
183350,"private int getNumConnectedNetworks(){
  int numConnectedNets=0;
  for (  NetworkStateTracker nt : mNetTrackers) {
    if (nt.getNetworkInfo().isConnected() && !nt.isTeardownRequested()) {
      ++numConnectedNets;
    }
  }
  return numConnectedNets;
}","private int getNumConnectedNetworks(){
  int numConnectedNets=0;
  for (  NetworkStateTracker nt : mNetTrackers) {
    if (nt.getNetworkInfo().isConnected() && !nt.isTeardownRequested()) {
      ++numConnectedNets;
    }
  }
  if (DBG)   Log.d(TAG,""String_Node_Str"" + numConnectedNets);
  return numConnectedNets;
}",0.8098591549295775
183351,"/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName());
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  if (!mNetAttributes[prevNetType].isDefault()) {
    List pids=mNetRequestersPids[prevNetType];
    for (int i=0; i < pids.size(); i++) {
      Integer pid=(Integer)pids.get(i);
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[prevNetType].isDefault()) {
    if (DBG)     Log.d(TAG,""String_Node_Str"");
    if (mActiveDefaultNetwork == prevNetType) {
      mActiveDefaultNetwork=-1;
    }
    int newType=-1;
    int newPriority=-1;
    for (int checkType=0; checkType <= ConnectivityManager.MAX_NETWORK_TYPE; checkType++) {
      if (checkType == prevNetType) {
        continue;
      }
      if (mNetAttributes[checkType].isDefault()) {
        if (checkType == mNetworkPreference) {
          newType=checkType;
          break;
        }
        if (mRadioAttributes[mNetAttributes[checkType].mRadio].mPriority > newPriority) {
          newType=checkType;
          newPriority=mRadioAttributes[mNetAttributes[newType].mRadio].mPriority;
        }
      }
    }
    if (newType != -1) {
      newNet=mNetTrackers[newType];
      if (newNet.isAvailable()) {
        NetworkInfo switchTo=newNet.getNetworkInfo();
        switchTo.setFailover(true);
        if (!switchTo.isConnectedOrConnecting()) {
          newNet.reconnect();
        }
        if (DBG) {
          if (switchTo.isConnected()) {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
 else {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
        }
        intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
      }
 else {
        newNet.reconnect();
      }
    }
 else {
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  handleConnectivityChange();
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName() + (newNet == null || !newNet.isAvailable() ? ""String_Node_Str"" : ""String_Node_Str"" + newNet.getNetworkInfo().getTypeName()));
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected())   sendConnectedBroadcast(newNet.getNetworkInfo());
}","/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName());
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  if (!mNetAttributes[prevNetType].isDefault()) {
    List pids=mNetRequestersPids[prevNetType];
    for (int i=0; i < pids.size(); i++) {
      Integer pid=(Integer)pids.get(i);
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[prevNetType].isDefault()) {
    if (DBG)     Log.d(TAG,""String_Node_Str"");
    if (mActiveDefaultNetwork == prevNetType) {
      mActiveDefaultNetwork=-1;
    }
    int newType=-1;
    int newPriority=-1;
    for (int checkType=0; checkType <= ConnectivityManager.MAX_NETWORK_TYPE; checkType++) {
      if (checkType == prevNetType) {
        continue;
      }
      if (mNetAttributes[checkType].isDefault()) {
        if (checkType == mNetworkPreference) {
          newType=checkType;
          break;
        }
        if (mRadioAttributes[mNetAttributes[checkType].mRadio].mPriority > newPriority) {
          newType=checkType;
          newPriority=mRadioAttributes[mNetAttributes[newType].mRadio].mPriority;
        }
      }
    }
    if (newType != -1) {
      newNet=mNetTrackers[newType];
      if (newNet.isAvailable()) {
        NetworkInfo switchTo=newNet.getNetworkInfo();
        switchTo.setFailover(true);
        if (!switchTo.isConnectedOrConnecting() || newNet.isTeardownRequested()) {
          newNet.reconnect();
        }
        if (DBG) {
          if (switchTo.isConnected()) {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
 else {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
        }
        intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
      }
 else {
        newNet.reconnect();
      }
    }
 else {
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  handleConnectivityChange();
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName() + (newNet == null || !newNet.isAvailable() ? ""String_Node_Str"" : ""String_Node_Str"" + newNet.getNetworkInfo().getTypeName()));
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected())   sendConnectedBroadcast(newNet.getNetworkInfo());
}",0.9949109414758268
183352,"public int startUsingNetworkFeature(int networkType,String feature,IBinder binder){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + networkType + ""String_Node_Str""+ feature);
  }
  enforceChangePermission();
  if (!ConnectivityManager.isNetworkTypeValid(networkType)) {
    return Phone.APN_REQUEST_FAILED;
  }
synchronized (mFeatureUsers) {
    mFeatureUsers.add(new FeatureUser(networkType,feature,binder));
  }
  int usedNetworkType=networkType;
  if (networkType == ConnectivityManager.TYPE_MOBILE) {
    if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_MMS)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_MMS;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_SUPL)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_SUPL;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_DUN)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_DUN;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_HIPRI)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_HIPRI;
    }
  }
  NetworkStateTracker network=mNetTrackers[usedNetworkType];
  if (network != null) {
    if (usedNetworkType != networkType) {
      Integer currentPid=new Integer(getCallingPid());
      NetworkStateTracker radio=mNetTrackers[networkType];
      NetworkInfo ni=network.getNetworkInfo();
      if (ni.isAvailable() == false) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_TYPE_NOT_AVAILABLE;
      }
      if (!mNetRequestersPids[usedNetworkType].contains(currentPid)) {
        mNetRequestersPids[usedNetworkType].add(currentPid);
      }
      if (ni.isConnectedOrConnecting() == true) {
        if (ni.isConnected() == true) {
          handleDnsConfigurationChange();
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return Phone.APN_ALREADY_ACTIVE;
        }
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_REQUEST_STARTED;
      }
      if (mHandler.hasMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio) || radio.getNetworkInfo().isConnectedOrConnecting()) {
        mHandler.removeMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio);
        mHandler.sendMessageDelayed(mHandler.obtainMessage(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio),getRestoreDefaultNetworkDelay());
      }
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      network.reconnect();
      return Phone.APN_REQUEST_STARTED;
    }
 else {
      return network.startUsingNetworkFeature(feature,getCallingPid(),getCallingUid());
    }
  }
  return Phone.APN_TYPE_NOT_AVAILABLE;
}","public int startUsingNetworkFeature(int networkType,String feature,IBinder binder){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + networkType + ""String_Node_Str""+ feature);
  }
  enforceChangePermission();
  if (!ConnectivityManager.isNetworkTypeValid(networkType)) {
    return Phone.APN_REQUEST_FAILED;
  }
synchronized (mFeatureUsers) {
    mFeatureUsers.add(new FeatureUser(networkType,feature,binder));
  }
  int usedNetworkType=networkType;
  if (networkType == ConnectivityManager.TYPE_MOBILE) {
    if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_MMS)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_MMS;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_SUPL)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_SUPL;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_DUN)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_DUN;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_HIPRI)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_HIPRI;
    }
  }
  NetworkStateTracker network=mNetTrackers[usedNetworkType];
  if (network != null) {
    if (usedNetworkType != networkType) {
      Integer currentPid=new Integer(getCallingPid());
      NetworkStateTracker radio=mNetTrackers[networkType];
      NetworkInfo ni=network.getNetworkInfo();
      if (ni.isAvailable() == false) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_TYPE_NOT_AVAILABLE;
      }
      if (!mNetRequestersPids[usedNetworkType].contains(currentPid)) {
        mNetRequestersPids[usedNetworkType].add(currentPid);
      }
      if ((ni.isConnectedOrConnecting() == true) && !network.isTeardownRequested()) {
        if (ni.isConnected() == true) {
          handleDnsConfigurationChange();
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return Phone.APN_ALREADY_ACTIVE;
        }
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_REQUEST_STARTED;
      }
      if (mHandler.hasMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio) || radio.getNetworkInfo().isConnectedOrConnecting()) {
        mHandler.removeMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio);
        mHandler.sendMessageDelayed(mHandler.obtainMessage(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio),getRestoreDefaultNetworkDelay());
      }
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      network.reconnect();
      return Phone.APN_REQUEST_STARTED;
    }
 else {
      return network.startUsingNetworkFeature(feature,getCallingPid(),getCallingUid());
    }
  }
  return Phone.APN_TYPE_NOT_AVAILABLE;
}",0.9931921331316188
183353,"protected synchronized void setEnabled(int id,boolean enable){
  if (DBG)   Log.d(LOG_TAG,""String_Node_Str"" + id + ""String_Node_Str""+ enable+ ')');
  if (dataEnabled[id] != enable) {
    dataEnabled[id]=enable;
    if (enable) {
      enabledCount++;
    }
 else {
      enabledCount--;
    }
    if (enabledCount == 0) {
      setPrivateDataEnabled(false);
    }
 else     if (enabledCount == 1) {
      setPrivateDataEnabled(true);
    }
  }
}","protected synchronized void setEnabled(int id,boolean enable){
  if (DBG)   Log.d(LOG_TAG,""String_Node_Str"" + id + ""String_Node_Str""+ enable+ ')');
  if (dataEnabled[id] != enable) {
    dataEnabled[id]=enable;
    if (enable) {
      enabledCount++;
      if (enabledCount == 1) {
        setPrivateDataEnabled(true);
      }
    }
 else {
      enabledCount--;
      if (enabledCount == 0) {
        setPrivateDataEnabled(false);
      }
    }
  }
}",0.7991071428571429
183354,"private boolean onModifiedTouchEvent(MotionEvent me){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  int action=me.getAction();
  long eventTime=me.getEventTime();
  int keyIndex=getKeyIndices(touchX,touchY,null);
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
repeatKey();
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
if (keyIndex != mRepeatKeyIndex) {
mHandler.removeMessages(MSG_REPEAT);
mRepeatKeyIndex=NOT_A_KEY;
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_UP:
mHandler.removeMessages(MSG_SHOW_PREVIEW);
mHandler.removeMessages(MSG_REPEAT);
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}","private boolean onModifiedTouchEvent(MotionEvent me){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  int action=me.getAction();
  long eventTime=me.getEventTime();
  int keyIndex=getKeyIndices(touchX,touchY,null);
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
repeatKey();
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
break;
case MotionEvent.ACTION_UP:
mHandler.removeMessages(MSG_SHOW_PREVIEW);
mHandler.removeMessages(MSG_REPEAT);
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}",0.9729539866526168
183355,"@Override public boolean onTouchEvent(MotionEvent me){
  int pointerCount=me.getPointerCount();
  boolean result=false;
  if (pointerCount != mOldPointerCount) {
    long now=me.getEventTime();
    if (pointerCount == 1) {
      MotionEvent down=MotionEvent.obtain(now,now,MotionEvent.ACTION_DOWN,me.getX(),me.getY(),me.getMetaState());
      result=onModifiedTouchEvent(down);
      down.recycle();
    }
 else {
      MotionEvent up=MotionEvent.obtain(now,now,MotionEvent.ACTION_UP,mOldPointerX,mOldPointerY,me.getMetaState());
      result=onModifiedTouchEvent(up);
      up.recycle();
    }
  }
 else {
    if (pointerCount == 1) {
      mOldPointerX=me.getX();
      mOldPointerY=me.getY();
      result=onModifiedTouchEvent(me);
    }
 else {
      result=true;
    }
  }
  mOldPointerCount=pointerCount;
  return result;
}","@Override public boolean onTouchEvent(MotionEvent me){
  int pointerCount=me.getPointerCount();
  boolean result=false;
  if (pointerCount != mOldPointerCount) {
    long now=me.getEventTime();
    if (pointerCount == 1) {
      MotionEvent down=MotionEvent.obtain(now,now,MotionEvent.ACTION_DOWN,me.getX(),me.getY(),me.getMetaState());
      result=onModifiedTouchEvent(down);
      down.recycle();
      if (me.getAction() == MotionEvent.ACTION_UP) {
        result=onModifiedTouchEvent(me);
      }
    }
 else {
      MotionEvent up=MotionEvent.obtain(now,now,MotionEvent.ACTION_UP,mOldPointerX,mOldPointerY,me.getMetaState());
      result=onModifiedTouchEvent(up);
      up.recycle();
    }
  }
 else {
    if (pointerCount == 1) {
      mOldPointerX=me.getX();
      mOldPointerY=me.getY();
      result=onModifiedTouchEvent(me);
    }
 else {
      result=true;
    }
  }
  mOldPointerCount=pointerCount;
  return result;
}",0.9420454545454544
183356,"public void run(){
  long sent, received;
  long preTxPkts=-1, preRxPkts=-1;
  Activity newActivity;
  preTxPkts=txPkts;
  preRxPkts=rxPkts;
  if (netstat != null) {
    try {
      txPkts=netstat.getMobileTxPackets();
      rxPkts=netstat.getMobileRxPackets();
    }
 catch (    RemoteException e) {
      txPkts=0;
      rxPkts=0;
    }
    if (netStatPollEnabled && (preTxPkts > 0 || preRxPkts > 0)) {
      sent=txPkts - preTxPkts;
      received=rxPkts - preRxPkts;
      if (sent > 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAINANDOUT;
      }
 else       if (sent > 0 && received == 0) {
        if (phone.getState() == Phone.State.IDLE) {
          sentSinceLastRecv+=sent;
        }
 else {
          sentSinceLastRecv=0;
        }
        newActivity=Activity.DATAOUT;
      }
 else       if (sent == 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAIN;
      }
 else       if (sent == 0 && received == 0) {
        newActivity=Activity.NONE;
      }
 else {
        sentSinceLastRecv=0;
        newActivity=Activity.NONE;
      }
      if (activity != newActivity) {
        activity=newActivity;
        phone.notifyDataActivity();
      }
    }
    if (sentSinceLastRecv >= NUMBER_SENT_PACKETS_OF_HANG) {
      if (mNoRecvPollCount == 0) {
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET_COUNTDOWN_TRIGGERED,sentSinceLastRecv);
      }
      if (mNoRecvPollCount < NO_RECV_POLL_LIMIT) {
        mNoRecvPollCount++;
        netStatPollPeriod=POLL_NETSTAT_SLOW_MILLIS;
      }
 else {
        if (DBG)         log(""String_Node_Str"" + String.valueOf(sentSinceLastRecv) + ""String_Node_Str"");
        netStatPollEnabled=false;
        stopNetStatPoll();
        restartRadio();
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET,NO_RECV_POLL_LIMIT);
      }
    }
 else {
      mNoRecvPollCount=0;
      netStatPollPeriod=POLL_NETSTAT_MILLIS;
    }
    if (netStatPollEnabled) {
      mDataConnectionTracker.postDelayed(this,netStatPollPeriod);
    }
  }
}","public void run(){
  long sent, received;
  long preTxPkts=-1, preRxPkts=-1;
  Activity newActivity;
  preTxPkts=txPkts;
  preRxPkts=rxPkts;
  if (netstat != null) {
    try {
      txPkts=netstat.getMobileTxPackets();
      rxPkts=netstat.getMobileRxPackets();
    }
 catch (    RemoteException e) {
      txPkts=0;
      rxPkts=0;
    }
    if (netStatPollEnabled && (preTxPkts > 0 || preRxPkts > 0)) {
      sent=txPkts - preTxPkts;
      received=rxPkts - preRxPkts;
      if (sent > 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAINANDOUT;
      }
 else       if (sent > 0 && received == 0) {
        if (phone.getState() == Phone.State.IDLE) {
          sentSinceLastRecv+=sent;
        }
 else {
          sentSinceLastRecv=0;
        }
        newActivity=Activity.DATAOUT;
      }
 else       if (sent == 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAIN;
      }
 else       if (sent == 0 && received == 0) {
        newActivity=(activity == Activity.DORMANT) ? activity : Activity.NONE;
      }
 else {
        sentSinceLastRecv=0;
        newActivity=(activity == Activity.DORMANT) ? activity : Activity.NONE;
      }
      if (activity != newActivity) {
        activity=newActivity;
        phone.notifyDataActivity();
      }
    }
    if (sentSinceLastRecv >= NUMBER_SENT_PACKETS_OF_HANG) {
      if (mNoRecvPollCount == 0) {
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET_COUNTDOWN_TRIGGERED,sentSinceLastRecv);
      }
      if (mNoRecvPollCount < NO_RECV_POLL_LIMIT) {
        mNoRecvPollCount++;
        netStatPollPeriod=POLL_NETSTAT_SLOW_MILLIS;
      }
 else {
        if (DBG)         log(""String_Node_Str"" + String.valueOf(sentSinceLastRecv) + ""String_Node_Str"");
        netStatPollEnabled=false;
        stopNetStatPoll();
        restartRadio();
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET,NO_RECV_POLL_LIMIT);
      }
    }
 else {
      mNoRecvPollCount=0;
      netStatPollPeriod=POLL_NETSTAT_MILLIS;
    }
    if (netStatPollEnabled) {
      mDataConnectionTracker.postDelayed(this,netStatPollPeriod);
    }
  }
}",0.9787535410764872
183357,"public void runTest(TestResult testResult){
  mTestResult=testResult;
  for (  TestListener testListener : mTestListeners) {
    mTestResult.addListener(testListener);
  }
  Context testContext=mInstrumentation.getContext();
  for (  TestCase testCase : mTestCases) {
    setContextIfAndroidTestCase(testCase,mContext,testContext);
    setInstrumentationIfInstrumentationTestCase(testCase,mInstrumentation);
    testCase.run(mTestResult);
  }
}","public void runTest(TestResult testResult){
  mTestResult=testResult;
  for (  TestListener testListener : mTestListeners) {
    mTestResult.addListener(testListener);
  }
  Context testContext=mInstrumentation == null ? mContext : mInstrumentation.getContext();
  for (  TestCase testCase : mTestCases) {
    setContextIfAndroidTestCase(testCase,mContext,testContext);
    setInstrumentationIfInstrumentationTestCase(testCase,mInstrumentation);
    testCase.run(mTestResult);
  }
}",0.958963282937365
183358,"/** 
 * parseCookie() parses the cookieString which is a comma-separated list of one or more cookies in the format of ""NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secure httponly"" to a list of Cookies. Here is a sample: IGDND=1, IGPC=ET=UB8TSNwtDmQ:AF=0; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/ig; domain=.google.com, =, PREF=ID=408909b1b304593d:TM=1156459854:LM=1156459854:S=V-vCAU6Sh-gobCfO; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com which contains 3 cookies IGDND, IGPC, PREF and an empty cookie
 * @param host The default host
 * @param path The default path
 * @param cookieString The string coming from ""Set-Cookie:""
 * @return A list of Cookies
 */
private ArrayList<Cookie> parseCookie(String host,String path,String cookieString){
  ArrayList<Cookie> ret=new ArrayList<Cookie>();
  int index=0;
  int length=cookieString.length();
  while (true) {
    Cookie cookie=null;
    if (index < 0 || index >= length) {
      break;
    }
    if (cookieString.charAt(index) == WHITE_SPACE) {
      index++;
      continue;
    }
    int semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    int equalIndex=cookieString.indexOf(EQUAL,index);
    if (equalIndex == -1) {
      break;
    }
    if (semicolonIndex > -1 && semicolonIndex < equalIndex) {
      break;
    }
    cookie=new Cookie(host,path);
    cookie.name=cookieString.substring(index,equalIndex);
    if (cookieString.charAt(equalIndex + 1) == QUOTATION) {
      index=cookieString.indexOf(QUOTATION,equalIndex + 2);
      if (index == -1) {
        break;
      }
    }
    semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    if (semicolonIndex == -1) {
      semicolonIndex=length;
    }
    if (semicolonIndex - equalIndex > MAX_COOKIE_LENGTH) {
      cookie.value=cookieString.substring(equalIndex + 1,equalIndex + MAX_COOKIE_LENGTH);
    }
 else     if (equalIndex + 1 == semicolonIndex || semicolonIndex < equalIndex) {
      cookie.value=""String_Node_Str"";
    }
 else {
      cookie.value=cookieString.substring(equalIndex + 1,semicolonIndex);
    }
    index=semicolonIndex;
    while (true) {
      if (index < 0 || index >= length) {
        break;
      }
      if (cookieString.charAt(index) == WHITE_SPACE || cookieString.charAt(index) == SEMICOLON) {
        index++;
        continue;
      }
      if (cookieString.charAt(index) == COMMA) {
        index++;
        break;
      }
      if (length - index > SECURE_LENGTH && cookieString.substring(index,index + SECURE_LENGTH).equalsIgnoreCase(SECURE)) {
        index+=SECURE_LENGTH;
        cookie.secure=true;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      if (length - index > HTTP_ONLY_LENGTH && cookieString.substring(index,index + HTTP_ONLY_LENGTH).equalsIgnoreCase(HTTP_ONLY)) {
        index+=HTTP_ONLY_LENGTH;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      equalIndex=cookieString.indexOf(EQUAL,index);
      if (equalIndex > 0) {
        String name=cookieString.substring(index,equalIndex).toLowerCase();
        if (name.equals(EXPIRES)) {
          int comaIndex=cookieString.indexOf(COMMA,equalIndex);
          if ((comaIndex != -1) && (comaIndex - equalIndex <= 10)) {
            index=comaIndex + 1;
          }
        }
        semicolonIndex=cookieString.indexOf(SEMICOLON,index);
        int commaIndex=cookieString.indexOf(COMMA,index);
        if (semicolonIndex == -1 && commaIndex == -1) {
          index=length;
        }
 else         if (semicolonIndex == -1) {
          index=commaIndex;
        }
 else         if (commaIndex == -1) {
          index=semicolonIndex;
        }
 else {
          index=Math.min(semicolonIndex,commaIndex);
        }
        String value=cookieString.substring(equalIndex + 1,index);
        if (value.length() > 2 && value.charAt(0) == QUOTATION) {
          int endQuote=value.indexOf(QUOTATION,1);
          if (endQuote > 0) {
            value=value.substring(1,endQuote);
          }
        }
        if (name.equals(EXPIRES)) {
          try {
            cookie.expires=HttpDateTime.parse(value);
          }
 catch (          IllegalArgumentException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(MAX_AGE)) {
          try {
            cookie.expires=System.currentTimeMillis() + 1000 * Long.parseLong(value);
          }
 catch (          NumberFormatException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(PATH)) {
          if (value.length() > 0) {
            cookie.path=value;
          }
        }
 else         if (name.equals(DOMAIN)) {
          int lastPeriod=value.lastIndexOf(PERIOD);
          if (lastPeriod == 0) {
            cookie.domain=null;
            continue;
          }
          try {
            Integer.parseInt(value.substring(lastPeriod + 1));
            if (!value.equals(host)) {
              cookie.domain=null;
            }
            continue;
          }
 catch (          NumberFormatException ex) {
          }
          value=value.toLowerCase();
          if (value.charAt(0) != PERIOD) {
            value=PERIOD + value;
            lastPeriod++;
          }
          if (host.endsWith(value.substring(1))) {
            int len=value.length();
            int hostLen=host.length();
            if (hostLen > (len - 1) && host.charAt(hostLen - len) != PERIOD) {
              cookie.domain=null;
              continue;
            }
            if ((len == lastPeriod + 3) && (len >= 6 && len <= 8)) {
              String s=value.substring(1,lastPeriod);
              if (Arrays.binarySearch(BAD_COUNTRY_2LDS,s) >= 0) {
                cookie.domain=null;
                continue;
              }
            }
            cookie.domain=value;
          }
 else {
            cookie.domain=null;
          }
        }
      }
 else {
        index=length;
      }
    }
    if (cookie != null && cookie.domain != null) {
      ret.add(cookie);
    }
  }
  return ret;
}","/** 
 * parseCookie() parses the cookieString which is a comma-separated list of one or more cookies in the format of ""NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secure httponly"" to a list of Cookies. Here is a sample: IGDND=1, IGPC=ET=UB8TSNwtDmQ:AF=0; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/ig; domain=.google.com, =, PREF=ID=408909b1b304593d:TM=1156459854:LM=1156459854:S=V-vCAU6Sh-gobCfO; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com which contains 3 cookies IGDND, IGPC, PREF and an empty cookie
 * @param host The default host
 * @param path The default path
 * @param cookieString The string coming from ""Set-Cookie:""
 * @return A list of Cookies
 */
private ArrayList<Cookie> parseCookie(String host,String path,String cookieString){
  ArrayList<Cookie> ret=new ArrayList<Cookie>();
  int index=0;
  int length=cookieString.length();
  while (true) {
    Cookie cookie=null;
    if (index < 0 || index >= length) {
      break;
    }
    if (cookieString.charAt(index) == WHITE_SPACE) {
      index++;
      continue;
    }
    int semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    int equalIndex=cookieString.indexOf(EQUAL,index);
    if (equalIndex == -1) {
      break;
    }
    if (semicolonIndex > -1 && semicolonIndex < equalIndex) {
      break;
    }
    cookie=new Cookie(host,path);
    cookie.name=cookieString.substring(index,equalIndex);
    if (cookieString.charAt(equalIndex + 1) == QUOTATION) {
      index=cookieString.indexOf(QUOTATION,equalIndex + 2);
      if (index == -1) {
        break;
      }
    }
    semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    if (semicolonIndex == -1) {
      semicolonIndex=length;
    }
    if (semicolonIndex - equalIndex > MAX_COOKIE_LENGTH) {
      cookie.value=cookieString.substring(equalIndex + 1,equalIndex + MAX_COOKIE_LENGTH);
    }
 else     if (equalIndex + 1 == semicolonIndex || semicolonIndex < equalIndex) {
      cookie.value=""String_Node_Str"";
    }
 else {
      cookie.value=cookieString.substring(equalIndex + 1,semicolonIndex);
    }
    index=semicolonIndex;
    while (true) {
      if (index < 0 || index >= length) {
        break;
      }
      if (cookieString.charAt(index) == WHITE_SPACE || cookieString.charAt(index) == SEMICOLON) {
        index++;
        continue;
      }
      if (cookieString.charAt(index) == COMMA) {
        index++;
        break;
      }
      if (length - index >= SECURE_LENGTH && cookieString.substring(index,index + SECURE_LENGTH).equalsIgnoreCase(SECURE)) {
        index+=SECURE_LENGTH;
        cookie.secure=true;
        if (index == length)         break;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      if (length - index >= HTTP_ONLY_LENGTH && cookieString.substring(index,index + HTTP_ONLY_LENGTH).equalsIgnoreCase(HTTP_ONLY)) {
        index+=HTTP_ONLY_LENGTH;
        if (index == length)         break;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      equalIndex=cookieString.indexOf(EQUAL,index);
      if (equalIndex > 0) {
        String name=cookieString.substring(index,equalIndex).toLowerCase();
        if (name.equals(EXPIRES)) {
          int comaIndex=cookieString.indexOf(COMMA,equalIndex);
          if ((comaIndex != -1) && (comaIndex - equalIndex <= 10)) {
            index=comaIndex + 1;
          }
        }
        semicolonIndex=cookieString.indexOf(SEMICOLON,index);
        int commaIndex=cookieString.indexOf(COMMA,index);
        if (semicolonIndex == -1 && commaIndex == -1) {
          index=length;
        }
 else         if (semicolonIndex == -1) {
          index=commaIndex;
        }
 else         if (commaIndex == -1) {
          index=semicolonIndex;
        }
 else {
          index=Math.min(semicolonIndex,commaIndex);
        }
        String value=cookieString.substring(equalIndex + 1,index);
        if (value.length() > 2 && value.charAt(0) == QUOTATION) {
          int endQuote=value.indexOf(QUOTATION,1);
          if (endQuote > 0) {
            value=value.substring(1,endQuote);
          }
        }
        if (name.equals(EXPIRES)) {
          try {
            cookie.expires=HttpDateTime.parse(value);
          }
 catch (          IllegalArgumentException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(MAX_AGE)) {
          try {
            cookie.expires=System.currentTimeMillis() + 1000 * Long.parseLong(value);
          }
 catch (          NumberFormatException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(PATH)) {
          if (value.length() > 0) {
            cookie.path=value;
          }
        }
 else         if (name.equals(DOMAIN)) {
          int lastPeriod=value.lastIndexOf(PERIOD);
          if (lastPeriod == 0) {
            cookie.domain=null;
            continue;
          }
          try {
            Integer.parseInt(value.substring(lastPeriod + 1));
            if (!value.equals(host)) {
              cookie.domain=null;
            }
            continue;
          }
 catch (          NumberFormatException ex) {
          }
          value=value.toLowerCase();
          if (value.charAt(0) != PERIOD) {
            value=PERIOD + value;
            lastPeriod++;
          }
          if (host.endsWith(value.substring(1))) {
            int len=value.length();
            int hostLen=host.length();
            if (hostLen > (len - 1) && host.charAt(hostLen - len) != PERIOD) {
              cookie.domain=null;
              continue;
            }
            if ((len == lastPeriod + 3) && (len >= 6 && len <= 8)) {
              String s=value.substring(1,lastPeriod);
              if (Arrays.binarySearch(BAD_COUNTRY_2LDS,s) >= 0) {
                cookie.domain=null;
                continue;
              }
            }
            cookie.domain=value;
          }
 else {
            cookie.domain=null;
          }
        }
      }
 else {
        index=length;
      }
    }
    if (cookie != null && cookie.domain != null) {
      ret.add(cookie);
    }
  }
  return ret;
}",0.99269717624148
183359,"public void onSensorChanged(SensorEvent event){
  long milliseconds=event.timestamp / 1000000;
  if (event.values[0] == 0.0) {
    goToSleep(milliseconds);
  }
 else {
    userActivity(milliseconds,false);
  }
}","public void onSensorChanged(SensorEvent event){
  long milliseconds=event.timestamp / 1000000;
  if (event.values[0] == 0.0) {
    goToSleep(milliseconds);
  }
 else {
synchronized (mLocks) {
      boolean savedActivityAllowed=mUserActivityAllowed;
      mUserActivityAllowed=true;
      userActivity(milliseconds,false);
      mUserActivityAllowed=savedActivityAllowed;
    }
  }
}",0.7116357504215851
183360,"/** 
 * This is the internal entry point for handling Activity.finish().
 * @param token The Binder token referencing the Activity we want to finish.
 * @param resultCode Result code, if any, from this Activity.
 * @param resultData Result data (Intent), if any, from this Activity.
 * @result Returns true if the activity successfully finished, or false if it is still running.
 */
public final boolean finishActivity(IBinder token,int resultCode,Intent resultData){
  if (resultData != null && resultData.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    if (mController != null) {
      HistoryRecord next=topRunningActivityLocked(token,0);
      if (next != null) {
        boolean resumeOK=true;
        try {
          resumeOK=mController.activityResuming(next.packageName);
        }
 catch (        RemoteException e) {
          mController=null;
        }
        if (!resumeOK) {
          return false;
        }
      }
    }
    final long origId=Binder.clearCallingIdentity();
    boolean res=requestFinishActivityLocked(token,resultCode,resultData,""String_Node_Str"");
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","/** 
 * This is the internal entry point for handling Activity.finish().
 * @param token The Binder token referencing the Activity we want to finish.
 * @param resultCode Result code, if any, from this Activity.
 * @param resultData Result data (Intent), if any, from this Activity.
 * @return Returns true if the activity successfully finished, or false if it is still running.
 */
public final boolean finishActivity(IBinder token,int resultCode,Intent resultData){
  if (resultData != null && resultData.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    if (mController != null) {
      HistoryRecord next=topRunningActivityLocked(token,0);
      if (next != null) {
        boolean resumeOK=true;
        try {
          resumeOK=mController.activityResuming(next.packageName);
        }
 catch (        RemoteException e) {
          mController=null;
        }
        if (!resumeOK) {
          return false;
        }
      }
    }
    final long origId=Binder.clearCallingIdentity();
    boolean res=requestFinishActivityLocked(token,resultCode,resultData,""String_Node_Str"");
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}",0.99672131147541
183361,"/** 
 * Unlocks Wifi Multicast, restoring the filter of packets not addressed specifically to this device and saving power. If this MulticastLock is reference-counted, each call to  {@code release} will decrement the reference count, and themulticast packets will only stop being received when the reference count reaches zero.  If the reference count goes below zero (that is, if  {@code release} is called a greater number of times than{@link #acquire}), an exception is thrown. If this MulticastLock is not reference-counted, the first call to  {@code release} (after the radio was multicast locked using{@linke #acquire}) will unlock the multicast, and subsequent calls will be ignored. Note that if any other Wifi Multicast Locks are still outstanding this   {@code release} call will not have an immediate effect.  Onlywhen all applications have released all their Multicast Locks will the Multicast filter be turned back on. Also note that when an app exits or crashes all of its Multicast Locks will be automatically released.
 */
public void release(){
synchronized (mBinder) {
    if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
      try {
        mService.releaseMulticastLock();
synchronized (WifiManager.this) {
          mActiveLockCount--;
        }
      }
 catch (      RemoteException ignore) {
      }
      mHeld=false;
    }
    if (mRefCount < 0) {
      throw new RuntimeException(""String_Node_Str"" + mTag);
    }
  }
}","/** 
 * Unlocks Wifi Multicast, restoring the filter of packets not addressed specifically to this device and saving power. If this MulticastLock is reference-counted, each call to  {@code release} will decrement the reference count, and themulticast packets will only stop being received when the reference count reaches zero.  If the reference count goes below zero (that is, if  {@code release} is called a greater number of times than{@link #acquire}), an exception is thrown. If this MulticastLock is not reference-counted, the first call to  {@code release} (after the radio was multicast locked using{@link #acquire}) will unlock the multicast, and subsequent calls will be ignored. Note that if any other Wifi Multicast Locks are still outstanding this   {@code release} call will not have an immediate effect.  Onlywhen all applications have released all their Multicast Locks will the Multicast filter be turned back on. Also note that when an app exits or crashes all of its Multicast Locks will be automatically released.
 */
public void release(){
synchronized (mBinder) {
    if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
      try {
        mService.releaseMulticastLock();
synchronized (WifiManager.this) {
          mActiveLockCount--;
        }
      }
 catch (      RemoteException ignore) {
      }
      mHeld=false;
    }
    if (mRefCount < 0) {
      throw new RuntimeException(""String_Node_Str"" + mTag);
    }
  }
}",0.9996538594669436
183362,"void readStateFromFileLocked(File file){
  FileInputStream stream=null;
  boolean success=false;
  try {
    stream=new FileInputStream(file);
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(stream,null);
    int type;
    int providerIndex=0;
    HashMap<Integer,Provider> loadedProviders=new HashMap<Integer,Provider>();
    do {
      type=parser.next();
      if (type == XmlPullParser.START_TAG) {
        String tag=parser.getName();
        if (""String_Node_Str"".equals(tag)) {
          String pkg=parser.getAttributeValue(null,""String_Node_Str"");
          String cl=parser.getAttributeValue(null,""String_Node_Str"");
          Provider p=lookupProviderLocked(new ComponentName(pkg,cl));
          if (p == null && mSafeMode) {
            p=new Provider();
            p.info=new AppWidgetProviderInfo();
            p.info.provider=new ComponentName(pkg,cl);
            p.zombie=true;
            mInstalledProviders.add(p);
          }
          if (p != null) {
            loadedProviders.put(providerIndex,p);
          }
          providerIndex++;
        }
 else         if (""String_Node_Str"".equals(tag)) {
          Host host=new Host();
          host.packageName=parser.getAttributeValue(null,""String_Node_Str"");
          try {
            host.uid=getUidForPackage(host.packageName);
          }
 catch (          PackageManager.NameNotFoundException ex) {
            host.zombie=true;
          }
          if (!host.zombie || mSafeMode) {
            host.hostId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
            mHosts.add(host);
          }
        }
 else         if (""String_Node_Str"".equals(tag)) {
          AppWidgetId id=new AppWidgetId();
          id.appWidgetId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          if (id.appWidgetId >= mNextAppWidgetId) {
            mNextAppWidgetId=id.appWidgetId + 1;
          }
          String providerString=parser.getAttributeValue(null,""String_Node_Str"");
          if (providerString != null) {
            int pIndex=Integer.parseInt(providerString,16);
            id.provider=loadedProviders.get(pIndex);
            if (false) {
              Log.d(TAG,""String_Node_Str"" + id.appWidgetId + ""String_Node_Str""+ pIndex+ ""String_Node_Str""+ id.provider);
            }
            if (id.provider == null) {
              continue;
            }
          }
          int hIndex=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          id.host=mHosts.get(hIndex);
          if (id.host == null) {
            continue;
          }
          if (id.provider != null) {
            id.provider.instances.add(id);
          }
          id.host.instances.add(id);
          mAppWidgetIds.add(id);
        }
      }
    }
 while (type != XmlPullParser.END_DOCUMENT);
    success=true;
  }
 catch (  NullPointerException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  NumberFormatException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IndexOutOfBoundsException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
  try {
    if (stream != null) {
      stream.close();
    }
  }
 catch (  IOException e) {
  }
  if (success) {
    final int N=mHosts.size();
    for (int i=0; i < N; i++) {
      pruneHostLocked(mHosts.get(i));
    }
  }
 else {
    mAppWidgetIds.clear();
    mHosts.clear();
    final int N=mInstalledProviders.size();
    for (int i=0; i < N; i++) {
      mInstalledProviders.get(i).instances.clear();
    }
  }
}","void readStateFromFileLocked(File file){
  FileInputStream stream=null;
  boolean success=false;
  try {
    stream=new FileInputStream(file);
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(stream,null);
    int type;
    int providerIndex=0;
    HashMap<Integer,Provider> loadedProviders=new HashMap<Integer,Provider>();
    do {
      type=parser.next();
      if (type == XmlPullParser.START_TAG) {
        String tag=parser.getName();
        if (""String_Node_Str"".equals(tag)) {
          String pkg=parser.getAttributeValue(null,""String_Node_Str"");
          String cl=parser.getAttributeValue(null,""String_Node_Str"");
          Provider p=lookupProviderLocked(new ComponentName(pkg,cl));
          if (p == null && mSafeMode) {
            p=new Provider();
            p.info=new AppWidgetProviderInfo();
            p.info.provider=new ComponentName(pkg,cl);
            p.zombie=true;
            mInstalledProviders.add(p);
          }
          if (p != null) {
            loadedProviders.put(providerIndex,p);
          }
          providerIndex++;
        }
 else         if (""String_Node_Str"".equals(tag)) {
          Host host=new Host();
          host.packageName=parser.getAttributeValue(null,""String_Node_Str"");
          try {
            host.uid=getUidForPackage(host.packageName);
          }
 catch (          PackageManager.NameNotFoundException ex) {
            host.zombie=true;
          }
          if (!host.zombie || mSafeMode) {
            host.hostId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
            mHosts.add(host);
          }
        }
 else         if (""String_Node_Str"".equals(tag)) {
          AppWidgetId id=new AppWidgetId();
          id.appWidgetId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          if (id.appWidgetId >= mNextAppWidgetId) {
            mNextAppWidgetId=id.appWidgetId + 1;
          }
          String providerString=parser.getAttributeValue(null,""String_Node_Str"");
          if (providerString != null) {
            int pIndex=Integer.parseInt(providerString,16);
            id.provider=loadedProviders.get(pIndex);
            if (false) {
              Log.d(TAG,""String_Node_Str"" + id.appWidgetId + ""String_Node_Str""+ pIndex+ ""String_Node_Str""+ id.provider);
            }
            if (id.provider == null) {
              continue;
            }
          }
          int hIndex=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          id.host=mHosts.get(hIndex);
          if (id.host == null) {
            continue;
          }
          if (id.provider != null) {
            id.provider.instances.add(id);
          }
          id.host.instances.add(id);
          mAppWidgetIds.add(id);
        }
      }
    }
 while (type != XmlPullParser.END_DOCUMENT);
    success=true;
  }
 catch (  NullPointerException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  NumberFormatException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IndexOutOfBoundsException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
  try {
    if (stream != null) {
      stream.close();
    }
  }
 catch (  IOException e) {
  }
  if (success) {
    for (int i=mHosts.size() - 1; i >= 0; i--) {
      pruneHostLocked(mHosts.get(i));
    }
  }
 else {
    mAppWidgetIds.clear();
    mHosts.clear();
    final int N=mInstalledProviders.size();
    for (int i=0; i < N; i++) {
      mInstalledProviders.get(i).instances.clear();
    }
  }
}",0.9406504065040652
183363,"MotionEvent generateAbsMotion(InputDevice device,long curTime,long curTimeNano,Display display,int orientation,int metaState){
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + mNextNumPointers + ""String_Node_Str""+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData=mLastData;
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + numPointers + ""String_Node_Str""+ lastNumPointers+ ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str"");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[i + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Log.i(""String_Node_Str"",""String_Node_Str"" + reportData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ reportData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Log.i(""String_Node_Str"",""String_Node_Str"" + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}","MotionEvent generateAbsMotion(InputDevice device,long curTime,long curTimeNano,Display display,int orientation,int metaState){
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + mNextNumPointers + ""String_Node_Str""+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData=mLastData;
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + numPointers + ""String_Node_Str""+ lastNumPointers+ ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str"");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[j + MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[j + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Log.i(""String_Node_Str"",""String_Node_Str"" + reportData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ reportData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Log.i(""String_Node_Str"",""String_Node_Str"" + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}",0.9993810604497628
183364,"public void run(){
  Log.d(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          mDevices.put(ev.deviceId,di);
          if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
            readVirtualKeys(di.name);
          }
          configChanged=true;
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else {
            Log.w(TAG,""String_Node_Str"" + ev.deviceId);
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (di == null) {
        continue;
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_2 && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[1]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.mAbs.mNextData[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.mAbs.mNextData[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[(di.mAbs.mDown[0] ? MotionEvent.NUM_SAMPLE_DATA : 0) + MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[(di.mAbs.mDown[0] ? MotionEvent.NUM_SAMPLE_DATA : 0) + MotionEvent.SAMPLE_Y]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0])                 ms.mNextNumPointers++;
                if (ms.mDown[1])                 ms.mNextNumPointers++;
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && ms.mLastNumPointers == 0) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (false)                   Log.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Log.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Log.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Log.e(TAG,""String_Node_Str"",exc);
    }
  }
}","public void run(){
  Log.d(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          mDevices.put(ev.deviceId,di);
          if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
            readVirtualKeys(di.name);
          }
          configChanged=true;
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else {
            Log.w(TAG,""String_Node_Str"" + ev.deviceId);
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (di == null) {
        continue;
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_2 && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[1]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_Y]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
                if (ms.mDown[1]) {
                  System.arraycopy(di.curTouchVals,MotionEvent.NUM_SAMPLE_DATA,ms.mNextData,ms.mNextNumPointers * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && ms.mLastNumPointers == 0) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (false)                   Log.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Log.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Log.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Log.e(TAG,""String_Node_Str"",exc);
    }
  }
}",0.971767028627838
183365,"/** 
 * True if c is ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE   
 */
public final static boolean isNonSeparator(char c){
  return (c >= '0' && c <= '9') || c == '*' || c == '#' || c == '+' || c == WILD || c == WAIT || c == PAUSE;
}","private static boolean isNonSeparator(String address){
  for (int i=0, count=address.length(); i < count; i++) {
    if (!isNonSeparator(address.charAt(i))) {
      return false;
    }
  }
  return true;
}",0.0222717149220489
183366,"private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (isPause(c) && (nextNonPwCharIndex > (currPwIndex + 1))) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}","private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (isPause(c) && (nextNonPwCharIndex > (currPwIndex + 2))) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}",0.9970414201183432
183367,"private static int findNextPCharOrNonPOrNonWCharIndex(String phoneNumber,int currIndex){
  boolean wMatched=false;
  int index=currIndex + 1;
  int length=phoneNumber.length();
  while (index < length) {
    char cNext=phoneNumber.charAt(index);
    if (isWait(cNext)) {
      wMatched=true;
    }
    if (!isWait(cNext) && !isPause(cNext)) {
      break;
    }
    index++;
  }
  if ((index < length) && (index > (currIndex + 1)) && ((wMatched == false) && isPause(phoneNumber.charAt(currIndex)))) {
    return (currIndex + 1);
  }
  return index;
}","private static int findNextPCharOrNonPOrNonWCharIndex(String phoneNumber,int currIndex){
  boolean wMatched=isWait(phoneNumber.charAt(currIndex));
  int index=currIndex + 1;
  int length=phoneNumber.length();
  while (index < length) {
    char cNext=phoneNumber.charAt(index);
    if (isWait(cNext)) {
      wMatched=true;
    }
    if (!isWait(cNext) && !isPause(cNext)) {
      break;
    }
    index++;
  }
  if ((index < length) && (index > (currIndex + 1)) && ((wMatched == false) && isPause(phoneNumber.charAt(currIndex)))) {
    return (currIndex + 1);
  }
  return index;
}",0.9628975265017669
183368,"/** 
 * format orignal dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (PhoneNumberUtils.isDialable(c)) {
      if (c == '+') {
        String ps=null;
        SystemProperties.get(TelephonyProperties.PROPERTY_IDP_STRING,ps);
        if (TextUtils.isEmpty(ps)) {
          ps=""String_Node_Str"";
        }
        ret.append(ps);
      }
 else {
        ret.append(c);
      }
    }
 else     if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 1)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return ret.toString();
}","/** 
 * format original dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 2)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return PhoneNumberUtils.cdmaCheckAndProcessPlusCode(ret.toString());
}",0.4951069227981152
183369,"private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  if (mBatteryLevel == 0 && isPowered(0xffffffff)) {
    ShutdownThread.shutdown(mContext,false);
  }
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}","private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  shutdownIfNoPower();
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}",0.9863676901516116
183370,"/** 
 * Returns a Locale instance describing the language currently being used by the TTS engine.
 * @return language, country (if any) and variant (if any) used by the engine stored in a Localeinstance, or null is the TTS engine has failed.
 */
public Locale getLanguage(){
synchronized (mStartLock) {
    if (!mStarted) {
      return null;
    }
    try {
      String[] locStrings=mITts.getLanguage();
      if (locStrings.length == 3) {
        return new Locale(locStrings[0],locStrings[1],locStrings[2]);
      }
 else {
        return null;
      }
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
    return null;
  }
}","/** 
 * Returns a Locale instance describing the language currently being used by the TTS engine.
 * @return language, country (if any) and variant (if any) used by the engine stored in a Localeinstance, or null is the TTS engine has failed.
 */
public Locale getLanguage(){
synchronized (mStartLock) {
    if (!mStarted) {
      return null;
    }
    try {
      String[] locStrings=mITts.getLanguage();
      if ((locStrings != null) && (locStrings.length == 3)) {
        return new Locale(locStrings[0],locStrings[1],locStrings[2]);
      }
 else {
        return null;
      }
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
    return null;
  }
}",0.9878731343283582
183371,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}",0.9608294930875576
183372,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally, except those intended to be synthesized to file.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        try {
          result=sNativeSynth.stop();
        }
 catch (        NullPointerException e1) {
          result=TextToSpeech.ERROR;
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}",0.9406688241639698
183373,"@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  stopAll(""String_Node_Str"");
  cleanUpPlayer();
  if (sNativeSynth != null) {
    sNativeSynth.shutdown();
  }
  sNativeSynth=null;
  mCallbacks.kill();
}",0.8146067415730337
183374,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(""String_Node_Str"",""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9600307455803228
183375,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(""String_Node_Str"",""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9753215154675008
183376,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Debug.MemoryInfo memInfo=new Debug.MemoryInfo();
  Debug.getMemoryInfo(memInfo);
  final int nativeShared=memInfo.nativeSharedDirty;
  final int dalvikShared=memInfo.dalvikSharedDirty;
  final int otherShared=memInfo.otherSharedDirty;
  final int nativePrivate=memInfo.nativePrivateDirty;
  final int dalvikPrivate=memInfo.dalvikPrivateDirty;
  final int otherPrivate=memInfo.otherPrivateDirty;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootInstanceCount();
  long appContextInstanceCount=ApplicationContext.getInstanceCount();
  long activityInstanceCount=Activity.getInstanceCount();
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  int openSslSocketCount=OpenSSLSocketImpl.getInstanceCount();
  long sqliteAllocated=SQLiteDebug.getHeapAllocatedSize() / 1024;
  SQLiteDebug.PagerStats stats=new SQLiteDebug.PagerStats();
  SQLiteDebug.getPagerStats(stats);
  boolean doCheckinFormat=false;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg))       doCheckinFormat=true;
    }
  }
  if (doCheckinFormat) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
    pw.print(',');
    pw.print(nativeShared);
    pw.print(',');
    pw.print(dalvikShared);
    pw.print(',');
    pw.print(otherShared);
    pw.print(',');
    pw.print(nativeShared + dalvikShared + otherShared);
    pw.print(',');
    pw.print(nativePrivate);
    pw.print(',');
    pw.print(dalvikPrivate);
    pw.print(',');
    pw.print(otherPrivate);
    pw.print(',');
    pw.print(nativePrivate + dalvikPrivate + otherPrivate);
    pw.print(',');
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(sqliteAllocated);
    pw.print(',');
    pw.print(stats.databaseBytes / 1024);
    pw.print(',');
    pw.print(stats.numPagers);
    pw.print(',');
    pw.print((stats.totalBytes - stats.referencedBytes) / 1024);
    pw.print(',');
    pw.print(stats.referencedBytes / 1024);
    pw.print('\n');
    return;
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeMax,dalvikMax,""String_Node_Str"",nativeMax + dalvikMax);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeAllocated,dalvikAllocated,""String_Node_Str"",nativeAllocated + dalvikAllocated);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeFree,dalvikFree,""String_Node_Str"",nativeFree + dalvikFree);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.dalvikPss,memInfo.otherPss,memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeShared,dalvikShared,otherShared,nativeShared + dalvikShared + otherShared);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativePrivate,dalvikPrivate,otherPrivate,nativePrivate + dalvikPrivate + otherPrivate);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",sqliteAllocated,""String_Node_Str"",stats.databaseBytes / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.numPagers,""String_Node_Str"",(stats.totalBytes - stats.referencedBytes) / 1024);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.referencedBytes / 1024);
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Debug.MemoryInfo memInfo=new Debug.MemoryInfo();
  Debug.getMemoryInfo(memInfo);
  final int nativeShared=memInfo.nativeSharedDirty;
  final int dalvikShared=memInfo.dalvikSharedDirty;
  final int otherShared=memInfo.otherSharedDirty;
  final int nativePrivate=memInfo.nativePrivateDirty;
  final int dalvikPrivate=memInfo.dalvikPrivateDirty;
  final int otherPrivate=memInfo.otherPrivateDirty;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootInstanceCount();
  long appContextInstanceCount=ApplicationContext.getInstanceCount();
  long activityInstanceCount=Activity.getInstanceCount();
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  int openSslSocketCount=OpenSSLSocketImpl.getInstanceCount();
  long sqliteAllocated=SQLiteDebug.getHeapAllocatedSize() / 1024;
  SQLiteDebug.PagerStats stats=new SQLiteDebug.PagerStats();
  SQLiteDebug.getPagerStats(stats);
  boolean doCheckinFormat=false;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg))       doCheckinFormat=true;
    }
  }
  if (doCheckinFormat) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
    pw.print(',');
    pw.print(nativeShared);
    pw.print(',');
    pw.print(dalvikShared);
    pw.print(',');
    pw.print(otherShared);
    pw.print(',');
    pw.print(nativeShared + dalvikShared + otherShared);
    pw.print(',');
    pw.print(nativePrivate);
    pw.print(',');
    pw.print(dalvikPrivate);
    pw.print(',');
    pw.print(otherPrivate);
    pw.print(',');
    pw.print(nativePrivate + dalvikPrivate + otherPrivate);
    pw.print(',');
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(sqliteAllocated);
    pw.print(',');
    pw.print(stats.databaseBytes / 1024);
    pw.print(',');
    pw.print(stats.numPagers);
    pw.print(',');
    pw.print((stats.totalBytes - stats.referencedBytes) / 1024);
    pw.print(',');
    pw.print(stats.referencedBytes / 1024);
    pw.print('\n');
    return;
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeMax,dalvikMax,""String_Node_Str"",nativeMax + dalvikMax);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeAllocated,dalvikAllocated,""String_Node_Str"",nativeAllocated + dalvikAllocated);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeFree,dalvikFree,""String_Node_Str"",nativeFree + dalvikFree);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.dalvikPss,memInfo.otherPss,memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeShared,dalvikShared,otherShared,nativeShared + dalvikShared + otherShared);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativePrivate,dalvikPrivate,otherPrivate,nativePrivate + dalvikPrivate + otherPrivate);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",sqliteAllocated,""String_Node_Str"",stats.databaseBytes / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.numPagers,""String_Node_Str"",(stats.totalBytes - stats.referencedBytes) / 1024);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.referencedBytes / 1024);
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}",0.9852682145716574
183377,"/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapter().getCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}","/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapterCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}",0.995398773006135
183378,"public void setFilename(String filename){
  mFilename=filename;
}","public void setFilename(String filename){
  if (mFilename == null || !mFilename.equals(filename)) {
    mFilename=filename;
    mCachedAttributes=null;
  }
}",0.5855855855855856
183379,"synchronized int getSocketError(){
  for (  DaemonProxy s : mDaemonList) {
switch (getResultFromSocket(s)) {
case 0:
      return 0;
case AUTH_ERROR_CODE:
    return VpnManager.VPN_ERROR_AUTH;
case CHALLENGE_ERROR_CODE:
  return VpnManager.VPN_ERROR_CHALLENGE;
case REMOTE_HUNG_UP_ERROR_CODE:
return VpnManager.VPN_ERROR_REMOTE_HUNG_UP;
default :
return VpnManager.VPN_ERROR_CONNECTION_FAILED;
}
}
return 0;
}","synchronized int getSocketError(){
  for (  DaemonProxy s : mDaemonList) {
switch (getResultFromSocket(s)) {
case 0:
      continue;
case AUTH_ERROR_CODE:
    return VpnManager.VPN_ERROR_AUTH;
case CHALLENGE_ERROR_CODE:
  return VpnManager.VPN_ERROR_CHALLENGE;
case REMOTE_HUNG_UP_ERROR_CODE:
return VpnManager.VPN_ERROR_REMOTE_HUNG_UP;
default :
return VpnManager.VPN_ERROR_CONNECTION_FAILED;
}
}
return 0;
}",0.980440097799511
183380,"/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapter().getCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}","/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapterCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}",0.995398773006135
183381,"static public Allocation createSized(RenderScript rs,Element e,int count){
  int id;
  if (e.mIsPredefined) {
    id=rs.nAllocationCreatePredefSized(e.mPredefinedID,count);
  }
 else {
    id=rs.nAllocationCreateSized(e.mID,count);
  }
  return new Allocation(id,rs);
}","static public Allocation createSized(RenderScript rs,Element e,int count) throws IllegalArgumentException {
  int id;
  if (e.mIsPredefined) {
    id=rs.nAllocationCreatePredefSized(e.mPredefinedID,count);
  }
 else {
    id=rs.nAllocationCreateSized(e.mID,count);
    if (id == 0) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
  return new Allocation(id,rs);
}",0.8226299694189603
183382,"static public Allocation createTyped(RenderScript rs,Type type){
  int id=rs.nAllocationCreateTyped(type.mID);
  return new Allocation(id,rs);
}","static public Allocation createTyped(RenderScript rs,Type type) throws IllegalArgumentException {
  if (type.mID == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  int id=rs.nAllocationCreateTyped(type.mID);
  return new Allocation(id,rs);
}",0.5594059405940595
183383,"BaseObj(RenderScript rs){
  mRS=rs;
  mID=0;
}","BaseObj(RenderScript rs){
  mRS=rs;
  mID=0;
  mDestroyed=false;
}",0.8214285714285714
183384,"protected void finalize() throws Throwable {
  if (mID != 0) {
    Log.v(RenderScript.LOG_TAG,""String_Node_Str"");
  }
  super.finalize();
}","protected void finalize() throws Throwable {
  if (!mDestroyed) {
    Log.v(RenderScript.LOG_TAG,""String_Node_Str"");
  }
  super.finalize();
}",0.9466192170818504
183385,"public void destroy() throws IllegalStateException {
  if (mIsPredefined) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mRS.nElementDestroy(mID);
  mID=0;
}","public void destroy() throws IllegalStateException {
  if (mIsPredefined) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nElementDestroy(mID);
}",0.7534246575342466
183386,"static synchronized Element internalCreate(RenderScript rs,Builder b){
  rs.nElementBegin();
  for (int ct=0; ct < b.mEntryCount; ct++) {
    Entry en=b.mEntries[ct];
    if (en.mElement != null) {
      rs.nElementAddPredefined(en.mElement.mPredefinedID);
    }
 else {
      int norm=0;
      if (en.mIsNormalized) {
        norm=1;
      }
      rs.nElementAdd(en.mType.mID,en.mKind.mID,norm,en.mBits);
    }
  }
  int id=rs.nElementCreate();
  return new Element(id,rs);
}","static synchronized Element internalCreate(RenderScript rs,Builder b){
  rs.nElementBegin();
  for (int ct=0; ct < b.mEntryCount; ct++) {
    Entry en=b.mEntries[ct];
    if (en.mElement != null) {
      rs.nElementAddPredefined(en.mElement.mPredefinedID);
    }
 else {
      int norm=0;
      if (en.mIsNormalized) {
        norm=1;
      }
      rs.nElementAdd(en.mKind.mID,en.mType.mID,norm,en.mBits);
    }
  }
  int id=rs.nElementCreate();
  return new Element(id,rs);
}",0.7983193277310925
183387,"public void destroy(){
  mRS.nProgramFragmentStoreDestroy(mID);
  mID=0;
}","public void destroy(){
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nProgramFragmentStoreDestroy(mID);
}",0.5462184873949579
183388,"public void destroy(){
  mRS.nProgramFragmentStoreDestroy(mID);
  mID=0;
}","public void destroy(){
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nProgramFragmentStoreDestroy(mID);
}",0.5462184873949579
183389,"public void destroy(){
  mRS.nScriptDestroy(mID);
  mID=0;
}","public void destroy(){
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nScriptDestroy(mID);
}",0.4857142857142857
183390,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPerms(deletedPs);
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    mSettings.writeLP();
  }
}",0.9851439182915506
183391,"private void removeMulticasterLocked(int i,int uid){
  Multicaster removed=mMulticasters.remove(i);
  if (removed != null) {
    removed.unlinkDeathRecipient();
  }
  if (mMulticasters.size() == 0) {
    WifiNative.startPacketFiltering();
  }
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastDisabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}","private void removeMulticasterLocked(int i,int uid){
  Multicaster removed=mMulticasters.remove(i);
  if (removed != null) {
    removed.unlinkDeathRecipient();
  }
  if (mMulticasters.size() == 0) {
synchronized (mWifiStateTracker) {
      WifiNative.startPacketFiltering();
    }
  }
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastDisabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9449838187702264
183392,"public void acquireMulticastLock(IBinder binder,String tag){
  enforceMulticastChangePermission();
synchronized (mMulticasters) {
    mMulticastEnabled++;
    mMulticasters.add(new Multicaster(tag,binder));
    WifiNative.stopPacketFiltering();
  }
  int uid=Binder.getCallingUid();
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastEnabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void acquireMulticastLock(IBinder binder,String tag){
  enforceMulticastChangePermission();
synchronized (mMulticasters) {
    mMulticastEnabled++;
    mMulticasters.add(new Multicaster(tag,binder));
synchronized (mWifiStateTracker) {
      WifiNative.stopPacketFiltering();
    }
  }
  int uid=Binder.getCallingUid();
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastEnabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.9572139303482587
183393,"private void handleExitEmergencyCallbackMode(Message msg){
  Log.d(LOG_TAG,""String_Node_Str"");
  AsyncResult ar=(AsyncResult)msg.obj;
  h.removeCallbacks(mExitEcmRunnable);
  if (mECMExitRespRegistrant != null) {
    mECMExitRespRegistrant.notifyRegistrant(ar);
  }
  if (ar.exception == null) {
    if (mIsPhoneInECMState) {
      mIsPhoneInECMState=false;
      setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE,""String_Node_Str"");
    }
    sendEmergencyCallbackModeChange();
  }
}","private void handleExitEmergencyCallbackMode(Message msg){
  Log.d(LOG_TAG,""String_Node_Str"");
  AsyncResult ar=(AsyncResult)msg.obj;
  h.removeCallbacks(mExitEcmRunnable);
  if (mECMExitRespRegistrant != null) {
    mECMExitRespRegistrant.notifyRegistrant(ar);
  }
  if (ar.exception == null) {
    if (mIsPhoneInECMState) {
      mIsPhoneInECMState=false;
      setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE,""String_Node_Str"");
    }
    sendEmergencyCallbackModeChange();
    mDataConnection.setDataEnabled(true);
  }
}",0.95906432748538
183394,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=36;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}",0.999875868917577
183395,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      if (!sIsKillingSynth) {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}",0.9610145608266792
183396,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        if (sIsKillingSynth) {
          Log.v(""String_Node_Str"",""String_Node_Str"");
          result=TextToSpeech.ERROR;
        }
 else {
          result=sNativeSynth.stop();
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}",0.9291907514450868
183397,"@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
    sIsKillingSynth=false;
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}","@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}",0.9784860557768924
183398,"@Override public void onDestroy(){
  super.onDestroy();
  sIsKillingSynth=true;
  Log.i(""String_Node_Str"",""String_Node_Str"");
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}",0.8055555555555556
183399,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9655577299412916
183400,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9752650176678446
183401,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      if (!sIsKillingSynth) {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}",0.9610145608266792
183402,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        if (sIsKillingSynth) {
          Log.v(""String_Node_Str"",""String_Node_Str"");
          result=TextToSpeech.ERROR;
        }
 else {
          result=sNativeSynth.stop();
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}",0.9291907514450868
183403,"@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
    sIsKillingSynth=false;
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}","@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}",0.9784860557768924
183404,"@Override public void onDestroy(){
  super.onDestroy();
  sIsKillingSynth=true;
  Log.i(""String_Node_Str"",""String_Node_Str"");
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}",0.8055555555555556
183405,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9655577299412916
183406,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9752650176678446
183407,"public void data(float[] d){
  mRS.nAdapter1DData(mID,d);
}","public void data(float[] d){
  mRS.nAdapter2DData(mID,d);
}",0.9830508474576272
183408,"public void destroy(){
  mRS.nAdapter1DDestroy(mID);
  mID=0;
}","public void destroy(){
  mRS.nAdapter2DDestroy(mID);
  mID=0;
}",0.984126984126984
183409,"public void setConstraint(Dimension dim,int value){
  mRS.nAdapter1DSetConstraint(mID,dim.mID,value);
}","public void setConstraint(Dimension dim,int value){
  mRS.nAdapter2DSetConstraint(mID,dim.mID,value);
}",0.9902912621359224
183410,"public void subData(int off,int count,float[] d){
  mRS.nAdapter1DSubData(mID,off,count,d);
}","public void subData(int xoff,int yoff,int w,int h,float[] d){
  mRS.nAdapter2DSubData(mID,xoff,yoff,w,h,d);
}",0.8514851485148515
183411,"private static Integer signalParamHash(int signalType,int alertPitch,int signal){
  if ((signalType < 0) || (signalType > 256) || (alertPitch > 256)|| (alertPitch < 0)|| (signal > 256)|| (signal < 0)) {
    return new Integer(CDMA_INVALID_TONE);
  }
  return new Integer(signalType * 256 * 256 + alertPitch * 256 + signal);
}","private static Integer signalParamHash(int signalType,int alertPitch,int signal){
  if ((signalType < 0) || (signalType > 256) || (alertPitch > 256)|| (alertPitch < 0)|| (signal > 256)|| (signal < 0)) {
    return new Integer(CDMA_INVALID_TONE);
  }
  if (signalType != IS95_CONST_IR_SIGNAL_IS54B) {
    alertPitch=TAPIAMSSCDMA_SIGNAL_PITCH_UNKNOWN;
  }
  return new Integer(signalType * 256 * 256 + alertPitch * 256 + signal);
}",0.8620689655172413
183412,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user.
 */
public void handleSslErrorRequest(SslError error){
  int primaryError=error.getPrimaryError();
  if (Config.LOGV) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + primaryError + ""String_Node_Str""+ error.getCertificate());
  }
  eventsReceived[TEST_SSL_CERTIFICATE_ERROR]=true;
  if (notExpecting[TEST_SSL_CERTIFICATE_ERROR]) {
    expectDetails.append(""String_Node_Str"" + ""String_Node_Str"");
    expectDetails.append(""String_Node_Str"");
  }
  if (expectSslErrors != -1) {
    if (expectSslErrors == primaryError) {
      expectSslErrors=-1;
    }
 else {
      expectDetails.append(""String_Node_Str"" + expectSslErrors + ""String_Node_Str""+ primaryError);
      expectDetails.append(""String_Node_Str"");
    }
  }
  if (expectSslErrors == -1)   expects[TEST_SSL_CERTIFICATE_ERROR]=false;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user.
 */
public boolean handleSslErrorRequest(SslError error){
  int primaryError=error.getPrimaryError();
  if (Config.LOGV) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + primaryError + ""String_Node_Str""+ error.getCertificate());
  }
  eventsReceived[TEST_SSL_CERTIFICATE_ERROR]=true;
  if (notExpecting[TEST_SSL_CERTIFICATE_ERROR]) {
    expectDetails.append(""String_Node_Str"" + ""String_Node_Str"");
    expectDetails.append(""String_Node_Str"");
  }
  if (expectSslErrors != -1) {
    if (expectSslErrors == primaryError) {
      expectSslErrors=-1;
    }
 else {
      expectDetails.append(""String_Node_Str"" + expectSslErrors + ""String_Node_Str""+ primaryError);
      expectDetails.append(""String_Node_Str"");
    }
  }
  if (expectSslErrors == -1)   expects[TEST_SSL_CERTIFICATE_ERROR]=false;
  return false;
}",0.984958217270195
183413,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      if (!sIsKillingSynth) {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}",0.9906059182714888
183414,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        if (sIsKillingSynth) {
          Log.v(""String_Node_Str"",""String_Node_Str"");
          result=TextToSpeech.ERROR;
        }
 else {
          result=sNativeSynth.stop();
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}",0.9450867052023122
183415,"@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}","@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
    sIsKillingSynth=false;
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}",0.9784860557768924
183416,"@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  sIsKillingSynth=true;
  Log.i(""String_Node_Str"",""String_Node_Str"");
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}",0.8055555555555556
183417,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9906066536203524
183418,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}",0.9915194346289752
183419,"private void setContentScrollBy(int cx,int cy,boolean animate){
  if (mDrawHistory) {
    return;
  }
  cx=contentToView(cx);
  cy=contentToView(cy);
  if (mHeightCanMeasure) {
    if (cy != 0) {
      Rect tempRect=new Rect();
      calcOurVisibleRect(tempRect);
      tempRect.offset(cx,cy);
      requestRectangleOnScreen(tempRect);
    }
    if (cy == 0 && cx != 0) {
      pinScrollBy(cx,0,animate,0);
    }
  }
 else {
    pinScrollBy(cx,cy,animate,0);
  }
}","private boolean setContentScrollBy(int cx,int cy,boolean animate){
  if (mDrawHistory) {
    return false;
  }
  cx=contentToView(cx);
  cy=contentToView(cy);
  if (mHeightCanMeasure) {
    if (cy != 0) {
      Rect tempRect=new Rect();
      calcOurVisibleRect(tempRect);
      tempRect.offset(cx,cy);
      requestRectangleOnScreen(tempRect);
    }
    return cy == 0 && cx != 0 && pinScrollBy(cx,0,animate,0);
  }
 else {
    return pinScrollBy(cx,cy,animate,0);
  }
}",0.8299465240641711
183420,"@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
try {
mHomeSystemId=sid.length > 0 ? Integer.parseInt(sid[0]) : 0;
}
 catch (NumberFormatException e) {
mHomeSystemId=0;
}
}
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
try {
mHomeNetworkId=nid.length > 0 ? Integer.parseInt(nid[0]) : 0;
}
 catch (NumberFormatException e) {
mHomeNetworkId=0;
}
}
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}","@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=new int[sid.length];
for (int i=0; i < sid.length; i++) {
try {
mHomeSystemId[i]=Integer.parseInt(sid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[1]);
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=new int[nid.length];
for (int i=0; i < nid.length; i++) {
try {
mHomeNetworkId[i]=Integer.parseInt(nid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[2]);
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}",0.6074195820615168
183421,"/** 
 * Handle the result of one of the pollState()-related requests
 */
@Override protected void handlePollStateResult(int what,AsyncResult ar){
  int ints[];
  String states[];
  if (ar.userObj != pollingContext)   return;
  if (ar.exception != null) {
    CommandException.Error err=null;
    if (ar.exception instanceof CommandException) {
      err=((CommandException)(ar.exception)).getCommandError();
    }
    if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
      cancelPollState();
      return;
    }
    if (!cm.getRadioState().isOn()) {
      cancelPollState();
      return;
    }
    if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW && err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
      Log.e(LOG_TAG,""String_Node_Str"",ar.exception);
    }
  }
 else   try {
switch (what) {
case EVENT_POLL_STATE_REGISTRATION_CDMA:
      states=(String[])ar.result;
    int registrationState=4;
  int radioTechnology=-1;
int baseStationId=-1;
int baseStationLatitude=-1;
int baseStationLongitude=-1;
int cssIndicator=0;
int systemId=0;
int networkId=0;
int roamingIndicator=-1;
int systemIsInPrl=0;
int defaultRoamingIndicator=0;
int reasonForDenial=0;
if (states.length == 14) {
try {
registrationState=Integer.parseInt(states[0]);
radioTechnology=Integer.parseInt(states[3]);
baseStationId=Integer.parseInt(states[4]);
baseStationLatitude=Integer.parseInt(states[5],16);
baseStationLongitude=Integer.parseInt(states[6],16);
cssIndicator=Integer.parseInt(states[7]);
systemId=Integer.parseInt(states[8]);
networkId=Integer.parseInt(states[9]);
roamingIndicator=Integer.parseInt(states[10]);
systemIsInPrl=Integer.parseInt(states[11]);
defaultRoamingIndicator=Integer.parseInt(states[12]);
reasonForDenial=Integer.parseInt(states[13]);
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
 else {
throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + states.length);
}
mRegistrationState=registrationState;
mCdmaRoaming=regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(states[10]);
newSS.setState(regCodeToServiceState(registrationState));
this.newCdmaDataConnectionState=radioTechnologyToDataServiceState(radioTechnology);
newSS.setRadioTechnology(radioTechnology);
newNetworkType=radioTechnology;
newSS.setCssIndicator(cssIndicator);
newSS.setSystemAndNetworkId(systemId,networkId);
mRoamingIndicator=roamingIndicator;
mIsInPrl=(systemIsInPrl == 0) ? false : true;
mDefaultRoamingIndicator=defaultRoamingIndicator;
newCellLoc.setCellLocationData(baseStationId,baseStationLatitude,baseStationLongitude,systemId,networkId);
if (reasonForDenial == 0) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_GEN;
}
 else if (reasonForDenial == 1) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_AUTH;
}
 else {
mRegistrationDeniedReason=""String_Node_Str"";
}
if (mRegistrationState == 3) {
if (DBG) log(""String_Node_Str"" + mRegistrationDeniedReason);
}
break;
case EVENT_POLL_STATE_OPERATOR_CDMA:
String opNames[]=(String[])ar.result;
if (opNames != null && opNames.length >= 3) {
if (cm.getRadioState().isNVReady()) {
newSS.setOperatorName(null,opNames[1],opNames[2]);
}
 else {
newSS.setOperatorName(opNames[0],opNames[1],opNames[2]);
}
}
 else {
Log.w(LOG_TAG,""String_Node_Str"");
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"");
break;
}
}
 catch (RuntimeException ex) {
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"",ex);
}
pollingContext[0]--;
if (pollingContext[0] == 0) {
boolean namMatch=false;
if ((mHomeSystemId != 0) && (mHomeSystemId == newSS.getSystemId())) {
namMatch=true;
}
if (isSubscriptionFromRuim) {
newSS.setRoaming(isRoamingBetweenOperators(mCdmaRoaming,newSS));
}
 else {
newSS.setRoaming(mCdmaRoaming);
}
if (mIsInPrl) {
if (namMatch && (mRoamingIndicator <= 2)) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
}
 else {
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
}
}
 else {
if (mRegistrationState == 5) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
}
 else {
}
}
newSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
if (DBG) {
log(""String_Node_Str"" + newSS.getCdmaRoamingIndicator() + ""String_Node_Str""+ mCdmaRoaming+ ""String_Node_Str""+ namMatch+ ""String_Node_Str""+ mIsInPrl+ ""String_Node_Str""+ mRoamingIndicator+ ""String_Node_Str""+ mDefaultRoamingIndicator);
}
pollStateDone();
}
}","/** 
 * Handle the result of one of the pollState()-related requests
 */
@Override protected void handlePollStateResult(int what,AsyncResult ar){
  int ints[];
  String states[];
  if (ar.userObj != pollingContext)   return;
  if (ar.exception != null) {
    CommandException.Error err=null;
    if (ar.exception instanceof CommandException) {
      err=((CommandException)(ar.exception)).getCommandError();
    }
    if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
      cancelPollState();
      return;
    }
    if (!cm.getRadioState().isOn()) {
      cancelPollState();
      return;
    }
    if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW && err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
      Log.e(LOG_TAG,""String_Node_Str"",ar.exception);
    }
  }
 else   try {
switch (what) {
case EVENT_POLL_STATE_REGISTRATION_CDMA:
      states=(String[])ar.result;
    int registrationState=4;
  int radioTechnology=-1;
int baseStationId=-1;
int baseStationLatitude=-1;
int baseStationLongitude=-1;
int cssIndicator=0;
int systemId=0;
int networkId=0;
int roamingIndicator=-1;
int systemIsInPrl=0;
int defaultRoamingIndicator=0;
int reasonForDenial=0;
if (states.length == 14) {
try {
registrationState=Integer.parseInt(states[0]);
radioTechnology=Integer.parseInt(states[3]);
baseStationId=Integer.parseInt(states[4]);
baseStationLatitude=Integer.parseInt(states[5],16);
baseStationLongitude=Integer.parseInt(states[6],16);
cssIndicator=Integer.parseInt(states[7]);
systemId=Integer.parseInt(states[8]);
networkId=Integer.parseInt(states[9]);
roamingIndicator=Integer.parseInt(states[10]);
systemIsInPrl=Integer.parseInt(states[11]);
defaultRoamingIndicator=Integer.parseInt(states[12]);
reasonForDenial=Integer.parseInt(states[13]);
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
 else {
throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + states.length);
}
mRegistrationState=registrationState;
mCdmaRoaming=regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(states[10]);
newSS.setState(regCodeToServiceState(registrationState));
this.newCdmaDataConnectionState=radioTechnologyToDataServiceState(radioTechnology);
newSS.setRadioTechnology(radioTechnology);
newNetworkType=radioTechnology;
newSS.setCssIndicator(cssIndicator);
newSS.setSystemAndNetworkId(systemId,networkId);
mRoamingIndicator=roamingIndicator;
mIsInPrl=(systemIsInPrl == 0) ? false : true;
mDefaultRoamingIndicator=defaultRoamingIndicator;
newCellLoc.setCellLocationData(baseStationId,baseStationLatitude,baseStationLongitude,systemId,networkId);
if (reasonForDenial == 0) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_GEN;
}
 else if (reasonForDenial == 1) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_AUTH;
}
 else {
mRegistrationDeniedReason=""String_Node_Str"";
}
if (mRegistrationState == 3) {
if (DBG) log(""String_Node_Str"" + mRegistrationDeniedReason);
}
break;
case EVENT_POLL_STATE_OPERATOR_CDMA:
String opNames[]=(String[])ar.result;
if (opNames != null && opNames.length >= 3) {
if (cm.getRadioState().isNVReady()) {
newSS.setOperatorName(null,opNames[1],opNames[2]);
}
 else {
newSS.setOperatorName(opNames[0],opNames[1],opNames[2]);
}
}
 else {
Log.w(LOG_TAG,""String_Node_Str"");
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"");
break;
}
}
 catch (RuntimeException ex) {
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"",ex);
}
pollingContext[0]--;
if (pollingContext[0] == 0) {
boolean namMatch=false;
if (!isSidsAllZeros() && isHomeSid(newSS.getSystemId())) {
namMatch=true;
}
if (isSubscriptionFromRuim) {
newSS.setRoaming(isRoamingBetweenOperators(mCdmaRoaming,newSS));
}
 else {
newSS.setRoaming(mCdmaRoaming);
}
newSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
boolean isPrlLoaded=true;
if (TextUtils.isEmpty(mPrlVersion)) {
isPrlLoaded=false;
}
if (!isPrlLoaded) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
}
 else if (!isSidsAllZeros()) {
if (!namMatch && !mIsInPrl) {
newSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
}
 else if (namMatch && !mIsInPrl) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
}
 else if (!namMatch && mIsInPrl) {
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
}
 else {
if ((mRoamingIndicator <= 2)) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
}
 else {
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
}
}
}
if (DBG) {
log(""String_Node_Str"" + newSS.getCdmaRoamingIndicator() + ""String_Node_Str""+ mCdmaRoaming+ ""String_Node_Str""+ isPrlLoaded+ ""String_Node_Str""+ namMatch+ ""String_Node_Str""+ mIsInPrl+ ""String_Node_Str""+ mRoamingIndicator+ ""String_Node_Str""+ mDefaultRoamingIndicator);
}
pollStateDone();
}
}",0.92001298841866
183422,"public void setImageMatrix(Matrix matrix){
  if (matrix != null && matrix.isIdentity()) {
    matrix=null;
  }
  if (matrix == null && !mMatrix.isIdentity() || matrix != null && !mMatrix.equals(matrix)) {
    mMatrix.set(matrix);
    invalidate();
  }
}","public void setImageMatrix(Matrix matrix){
  if (matrix != null && matrix.isIdentity()) {
    matrix=null;
  }
  if (matrix == null && !mMatrix.isIdentity() || matrix != null && !mMatrix.equals(matrix)) {
    mMatrix.set(matrix);
    configureBounds();
    invalidate();
  }
}",0.9565217391304348
183423,"/** 
 * Handle   {@link #MSG_BATTERY_UPDATE}
 */
private void handleBatteryUpdate(int pluggedInStatus,int batteryLevel){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final boolean pluggedIn=isPluggedIn(pluggedInStatus);
  if (isBatteryUpdateInteresting(pluggedIn,batteryLevel)) {
    mBatteryLevel=batteryLevel;
    mDevicePluggedIn=pluggedIn;
    for (int i=0; i < mInfoCallbacks.size(); i++) {
      mInfoCallbacks.get(i).onRefreshBatteryInfo(shouldShowBatteryInfo(),pluggedIn,batteryLevel);
    }
  }
  if (batteryLevel == 0 && pluggedInStatus != BATTERY_STATUS_CHARGING && pluggedInStatus != BATTERY_STATUS_UNKNOWN) {
    ShutdownThread.shutdown(mContext,false);
  }
}","/** 
 * Handle   {@link #MSG_BATTERY_UPDATE}
 */
private void handleBatteryUpdate(int pluggedInStatus,int batteryLevel){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final boolean pluggedIn=isPluggedIn(pluggedInStatus);
  if (isBatteryUpdateInteresting(pluggedIn,batteryLevel)) {
    mBatteryLevel=batteryLevel;
    mDevicePluggedIn=pluggedIn;
    for (int i=0; i < mInfoCallbacks.size(); i++) {
      mInfoCallbacks.get(i).onRefreshBatteryInfo(shouldShowBatteryInfo(),pluggedIn,batteryLevel);
    }
  }
}",0.8585944115156647
183424,"/** 
 * Performs   {@link AccessibilityService}s delayed notification. The delay is configurable and denotes the period after the last event before notifying the service.
 * @param event The event.
 * @param isDefault True to notify default listeners, not default services.
 */
private void notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event,boolean isDefault){
  for (int i=0, count=mServices.size(); i < count; i++) {
    Service service=mServices.get(i);
    if (service.mIsDefault == isDefault) {
      if (canDispathEventLocked(service,event,mHandledFeedbackTypes)) {
        mHandledFeedbackTypes|=service.mFeedbackType;
        notifyAccessibilityServiceDelayedLocked(service,event);
      }
    }
  }
}","/** 
 * Performs   {@link AccessibilityService}s delayed notification. The delay is configurable and denotes the period after the last event before notifying the service.
 * @param event The event.
 * @param isDefault True to notify default listeners, not default services.
 */
private void notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event,boolean isDefault){
  try {
    for (int i=0, count=mServices.size(); i < count; i++) {
      Service service=mServices.get(i);
      if (service.mIsDefault == isDefault) {
        if (canDispathEventLocked(service,event,mHandledFeedbackTypes)) {
          mHandledFeedbackTypes|=service.mFeedbackType;
          notifyAccessibilityServiceDelayedLocked(service,event);
        }
      }
    }
  }
 catch (  IndexOutOfBoundsException oobe) {
    return;
  }
}",0.9415584415584416
183425,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
sendCloseSystemWindows();
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
sendCloseSystemWindows();
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}",0.9896414342629484
183426,"static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    Intent intent=new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    if (reason != null) {
      intent.putExtra(SYSTEM_DIALOG_REASON_KEY,reason);
    }
    context.sendBroadcast(intent);
  }
}","static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(reason);
    }
 catch (    RemoteException e) {
    }
  }
}",0.4682395644283121
183427,"/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}","/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      sendCloseSystemWindows();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  return true;
}",0.9233926128590972
183428,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          mContext.startActivity(mHomeIntent);
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}",0.9173457508731082
183429,"public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}",0.8687258687258688
183430,"/** 
 * Checks whether the speakerphone is on or off.
 * @return true if speakerphone is on, false if it's off
 */
public boolean isSpeakerphoneOn(){
  if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_SPEAKER) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Checks whether the speakerphone is on or off.
 * @return true if speakerphone is on, false if it's off
 */
public boolean isSpeakerphoneOn(){
  IAudioService service=getService();
  try {
    return service.isSpeakerphoneOn();
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}",0.5512820512820513
183431,"/** 
 * Request use of Bluetooth SCO headset for communications.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_BT_SCO);
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
  }
}","/** 
 * Request use of Bluetooth SCO headset for communications.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  IAudioService service=getService();
  try {
    service.setBluetoothScoOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.6524822695035462
183432,"/** 
 * Sets the speakerphone on or off.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_SPEAKER);
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
  }
}","/** 
 * Sets the speakerphone on or off.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  IAudioService service=getService();
  try {
    service.setSpeakerphoneOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.5585331452750353
183433,"/** 
 * Checks whether communications use Bluetooth SCO.
 * @return true if SCO is used for communications;false if otherwise
 */
public boolean isBluetoothScoOn(){
  if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Checks whether communications use Bluetooth SCO.
 * @return true if SCO is used for communications;false if otherwise
 */
public boolean isBluetoothScoOn(){
  IAudioService service=getService();
  try {
    return service.isBluetoothScoOn();
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}",0.5727411944869831
183434,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.SINK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION);
  context.registerReceiver(mReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mMode=AudioSystem.MODE_NORMAL;
  mHeadsetState=0;
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.SINK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION);
  context.registerReceiver(mReceiver,intentFilter);
}",0.9328671328671329
183435,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.SINK_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothA2dp.SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothA2dp.STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
    }
  }
 else   if (action.equals(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothIntent.HEADSET_AUDIO_STATE,BluetoothHeadset.STATE_ERROR);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothHeadset.AUDIO_STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
    }
 else     if (state == BluetoothHeadset.AUDIO_STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_AVAILABLE,address);
    }
  }
 else   if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
    int state=intent.getIntExtra(""String_Node_Str"",0);
    if ((state & BIT_HEADSET) == 0 && (mHeadsetState & BIT_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_HEADSET) != 0 && (mHeadsetState & BIT_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_HEADSET_NO_MIC) == 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_HEADSET_NO_MIC) != 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_TTY) == 0 && (mHeadsetState & BIT_TTY) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_TTY) != 0 && (mHeadsetState & BIT_TTY) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_FM_HEADSET) == 0 && (mHeadsetState & BIT_FM_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_FM_HEADSET) != 0 && (mHeadsetState & BIT_FM_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_FM_SPEAKER) == 0 && (mHeadsetState & BIT_FM_SPEAKER) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_FM_SPEAKER) != 0 && (mHeadsetState & BIT_FM_SPEAKER) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    mHeadsetState=state;
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.SINK_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothA2dp.SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothA2dp.STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
    }
  }
 else   if (action.equals(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothIntent.HEADSET_AUDIO_STATE,BluetoothHeadset.STATE_ERROR);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothHeadset.AUDIO_STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO);
    }
 else     if (state == BluetoothHeadset.AUDIO_STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_AVAILABLE,address);
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO),address);
    }
  }
 else   if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
    int state=intent.getIntExtra(""String_Node_Str"",0);
    if ((state & BIT_HEADSET) == 0 && (mHeadsetState & BIT_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
    }
 else     if ((state & BIT_HEADSET) != 0 && (mHeadsetState & BIT_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
    }
    if ((state & BIT_HEADSET_NO_MIC) == 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
    }
 else     if ((state & BIT_HEADSET_NO_MIC) != 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
    }
    if ((state & BIT_TTY) == 0 && (mHeadsetState & BIT_TTY) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_TTY);
    }
 else     if ((state & BIT_TTY) != 0 && (mHeadsetState & BIT_TTY) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_TTY),""String_Node_Str"");
    }
    if ((state & BIT_FM_HEADSET) == 0 && (mHeadsetState & BIT_FM_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_FM_HEADPHONE);
    }
 else     if ((state & BIT_FM_HEADSET) != 0 && (mHeadsetState & BIT_FM_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_FM_HEADPHONE),""String_Node_Str"");
    }
    if ((state & BIT_FM_SPEAKER) == 0 && (mHeadsetState & BIT_FM_SPEAKER) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_FM_SPEAKER);
    }
 else     if ((state & BIT_FM_SPEAKER) != 0 && (mHeadsetState & BIT_FM_SPEAKER) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_FM_SPEAKER),""String_Node_Str"");
    }
    mHeadsetState=state;
  }
}",0.8498947860649988
183436,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
Log.e(TAG,""String_Node_Str"");
mMediaServerOk=false;
AudioSystem.getMode();
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerMode(mRingerMode);
mMediaServerOk=true;
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
Log.e(TAG,""String_Node_Str"");
mMediaServerOk=false;
AudioSystem.isMusicActive();
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
mMediaServerOk=true;
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}",0.8062325209748302
183437,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
sendCloseSystemWindows();
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
sendCloseSystemWindows();
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}",0.9896414342629484
183438,"static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    Intent intent=new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    if (reason != null) {
      intent.putExtra(SYSTEM_DIALOG_REASON_KEY,reason);
    }
    context.sendBroadcast(intent);
  }
}","static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(reason);
    }
 catch (    RemoteException e) {
    }
  }
}",0.4682395644283121
183439,"/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}","/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      sendCloseSystemWindows();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  return true;
}",0.9233926128590972
183440,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          mContext.startActivity(mHomeIntent);
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}",0.9173457508731082
183441,"public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}",0.8687258687258688
183442,"private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}","private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  if (mBatteryLevel == 0 && isPowered(0xffffffff)) {
    ShutdownThread.shutdown(mContext,false);
  }
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}",0.9869665218502428
183443,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9964831280321748
183444,"final void handleConfigurationChanged(Configuration config){
synchronized (mRelaunchingActivities) {
    if (mPendingConfiguration != null) {
      config=mPendingConfiguration;
      mPendingConfiguration=null;
    }
  }
  ArrayList<ComponentCallbacks> callbacks=new ArrayList<ComponentCallbacks>();
synchronized (mPackages) {
    if (mConfiguration == null) {
      mConfiguration=new Configuration();
    }
    mConfiguration.updateFrom(config);
    DisplayMetrics dm=getDisplayMetricsLocked(true);
    if (config.locale != null) {
      Locale.setDefault(config.locale);
    }
    Resources.updateSystemConfiguration(config,null);
    ApplicationContext.ApplicationPackageManager.configurationChanged();
{
      Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
      while (it.hasNext()) {
        WeakReference<Resources> v=it.next();
        Resources r=v.get();
        if (r != null) {
          r.updateConfiguration(config,dm);
        }
 else {
          it.remove();
        }
      }
    }
    callbacks=collectComponentCallbacksLocked(false,config);
  }
  final int N=callbacks.size();
  for (int i=0; i < N; i++) {
    performConfigurationChanged(callbacks.get(i),config);
  }
}","final void handleConfigurationChanged(Configuration config){
synchronized (mRelaunchingActivities) {
    if (mPendingConfiguration != null) {
      config=mPendingConfiguration;
      mPendingConfiguration=null;
    }
  }
  ArrayList<ComponentCallbacks> callbacks=new ArrayList<ComponentCallbacks>();
synchronized (mPackages) {
    if (mConfiguration == null) {
      mConfiguration=new Configuration();
    }
    mConfiguration.updateFrom(config);
    DisplayMetrics dm=getDisplayMetricsLocked(true);
    if (config.locale != null) {
      Locale.setDefault(config.locale);
    }
    Resources.updateSystemConfiguration(config,dm);
    ApplicationContext.ApplicationPackageManager.configurationChanged();
{
      Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
      while (it.hasNext()) {
        WeakReference<Resources> v=it.next();
        Resources r=v.get();
        if (r != null) {
          r.updateConfiguration(config,dm);
        }
 else {
          it.remove();
        }
      }
    }
    callbacks=collectComponentCallbacksLocked(false,config);
  }
  final int N=callbacks.size();
  for (int i=0; i < N; i++) {
    performConfigurationChanged(callbacks.get(i),config);
  }
}",0.9975389663658736
183445,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          moveInputMethodWindowsIfNeededLocked(true);
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          if (!moveInputMethodWindowsIfNeededLocked(true)) {
            assignLayersLocked();
          }
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}",0.9987747009156326
183446,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          moveInputMethodWindowsIfNeededLocked(true);
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          if (!moveInputMethodWindowsIfNeededLocked(true)) {
            assignLayersLocked();
          }
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}",0.9987747009156326
183447,"/** 
 * Create a new MotionEvent, copying from an existing one.
 */
static public MotionEvent obtain(MotionEvent o){
  MotionEvent ev=obtain();
  ev.mDeviceId=o.mDeviceId;
  ev.mEdgeFlags=o.mEdgeFlags;
  ev.mDownTime=o.mDownTime;
  ev.mEventTimeNano=o.mEventTimeNano;
  ev.mAction=o.mAction;
  ev.mNumPointers=o.mNumPointers;
  ev.mRawX=o.mRawX;
  ev.mRawY=o.mRawY;
  ev.mMetaState=o.mMetaState;
  ev.mXPrecision=o.mXPrecision;
  ev.mYPrecision=o.mYPrecision;
  final int NT=ev.mNumSamples=o.mNumSamples;
  if (ev.mTimeSamples.length < NT) {
    System.arraycopy(o.mTimeSamples,0,ev.mTimeSamples,0,NT);
  }
 else {
    ev.mTimeSamples=(long[])o.mTimeSamples.clone();
  }
  final int NS=(ev.mNumPointers=o.mNumPointers) * NT;
  if (ev.mStateSamples.length < NS) {
    System.arraycopy(o.mStateSamples,0,ev.mStateSamples,0,NS);
  }
 else {
    ev.mStateSamples=(int[])o.mStateSamples.clone();
  }
  final int ND=NS * NUM_SAMPLE_DATA;
  if (ev.mDataSamples.length < ND) {
    System.arraycopy(o.mDataSamples,0,ev.mDataSamples,0,ND);
  }
 else {
    ev.mDataSamples=(float[])o.mDataSamples.clone();
  }
  return ev;
}","/** 
 * Create a new MotionEvent, copying from an existing one.
 */
static public MotionEvent obtain(MotionEvent o){
  MotionEvent ev=obtain();
  ev.mDeviceId=o.mDeviceId;
  ev.mEdgeFlags=o.mEdgeFlags;
  ev.mDownTime=o.mDownTime;
  ev.mEventTimeNano=o.mEventTimeNano;
  ev.mAction=o.mAction;
  ev.mNumPointers=o.mNumPointers;
  ev.mRawX=o.mRawX;
  ev.mRawY=o.mRawY;
  ev.mMetaState=o.mMetaState;
  ev.mXPrecision=o.mXPrecision;
  ev.mYPrecision=o.mYPrecision;
  final int NT=ev.mNumSamples=o.mNumSamples;
  if (ev.mTimeSamples.length >= NT) {
    System.arraycopy(o.mTimeSamples,0,ev.mTimeSamples,0,NT);
  }
 else {
    ev.mTimeSamples=(long[])o.mTimeSamples.clone();
  }
  final int NS=(ev.mNumPointers=o.mNumPointers) * NT;
  if (ev.mStateSamples.length < NS) {
    System.arraycopy(o.mStateSamples,0,ev.mStateSamples,0,NS);
  }
 else {
    ev.mStateSamples=(int[])o.mStateSamples.clone();
  }
  final int ND=NS * NUM_SAMPLE_DATA;
  if (ev.mDataSamples.length < ND) {
    System.arraycopy(o.mDataSamples,0,ev.mDataSamples,0,ND);
  }
 else {
    ev.mDataSamples=(float[])o.mDataSamples.clone();
  }
  return ev;
}",0.998652896273013
183448,"public void handleMessage(Message msg){
  AsyncResult ar;
switch (msg.what) {
case EVENT_POLL_CALLS_RESULT:
{
      Log.d(LOG_TAG,""String_Node_Str"");
      ar=(AsyncResult)msg.obj;
      if (msg == lastRelevantPoll) {
        if (DBG_POLL)         log(""String_Node_Str"");
        needsPoll=false;
        lastRelevantPoll=null;
        handlePollCalls((AsyncResult)msg.obj);
      }
    }
  break;
case EVENT_OPERATION_COMPLETE:
operationComplete();
break;
case EVENT_SWITCH_RESULT:
break;
case EVENT_GET_LAST_CALL_FAIL_CAUSE:
int causeCode;
ar=(AsyncResult)msg.obj;
operationComplete();
if (ar.exception != null) {
causeCode=CallFailCause.NORMAL_CLEARING;
Log.i(LOG_TAG,""String_Node_Str"");
}
 else {
causeCode=((int[])ar.result)[0];
}
for (int i=0, s=droppedDuringPoll.size(); i < s; i++) {
CdmaConnection conn=droppedDuringPoll.get(i);
conn.onRemoteDisconnect(causeCode);
}
updatePhoneState();
phone.notifyPreciseCallStateChanged();
droppedDuringPoll.clear();
break;
case EVENT_REPOLL_AFTER_DELAY:
case EVENT_CALL_STATE_CHANGE:
pollCallsWhenSafe();
break;
case EVENT_RADIO_AVAILABLE:
handleRadioAvailable();
break;
case EVENT_RADIO_NOT_AVAILABLE:
handleRadioNotAvailable();
break;
case EVENT_EXIT_ECM_RESPONSE_CDMA:
if (pendingCallInECM) {
cm.dial(pendingMO.address,pendingCallClirMode,obtainCompleteMessage());
pendingCallInECM=false;
}
phone.unsetOnEcbModeExitResponse(this);
break;
case EVENT_CALL_WAITING_INFO_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
handleCallWaitingInfo((CdmaCallWaitingNotification)ar.result);
Log.d(LOG_TAG,""String_Node_Str"");
}
break;
case EVENT_THREE_WAY_DIAL_L2_RESULT_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
pendingMO.onConnectedInOrOut();
}
break;
default :
{
throw new RuntimeException(""String_Node_Str"");
}
}
}","public void handleMessage(Message msg){
  AsyncResult ar;
switch (msg.what) {
case EVENT_POLL_CALLS_RESULT:
{
      Log.d(LOG_TAG,""String_Node_Str"");
      ar=(AsyncResult)msg.obj;
      if (msg == lastRelevantPoll) {
        if (DBG_POLL)         log(""String_Node_Str"");
        needsPoll=false;
        lastRelevantPoll=null;
        handlePollCalls((AsyncResult)msg.obj);
      }
    }
  break;
case EVENT_OPERATION_COMPLETE:
operationComplete();
break;
case EVENT_SWITCH_RESULT:
break;
case EVENT_GET_LAST_CALL_FAIL_CAUSE:
int causeCode;
ar=(AsyncResult)msg.obj;
operationComplete();
if (ar.exception != null) {
causeCode=CallFailCause.NORMAL_CLEARING;
Log.i(LOG_TAG,""String_Node_Str"");
}
 else {
causeCode=((int[])ar.result)[0];
}
for (int i=0, s=droppedDuringPoll.size(); i < s; i++) {
CdmaConnection conn=droppedDuringPoll.get(i);
conn.onRemoteDisconnect(causeCode);
}
updatePhoneState();
phone.notifyPreciseCallStateChanged();
droppedDuringPoll.clear();
break;
case EVENT_REPOLL_AFTER_DELAY:
case EVENT_CALL_STATE_CHANGE:
pollCallsWhenSafe();
break;
case EVENT_RADIO_AVAILABLE:
handleRadioAvailable();
break;
case EVENT_RADIO_NOT_AVAILABLE:
handleRadioNotAvailable();
break;
case EVENT_EXIT_ECM_RESPONSE_CDMA:
if (pendingCallInECM) {
cm.dial(pendingMO.address,pendingCallClirMode,obtainCompleteMessage());
pendingCallInECM=false;
}
phone.unsetOnEcbModeExitResponse(this);
break;
case EVENT_CALL_WAITING_INFO_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
handleCallWaitingInfo((CdmaCallWaitingNotification)ar.result);
Log.d(LOG_TAG,""String_Node_Str"");
}
break;
case EVENT_THREE_WAY_DIAL_L2_RESULT_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
pendingMO.onConnectedInOrOut();
pendingMO=null;
}
break;
default :
{
throw new RuntimeException(""String_Node_Str"");
}
}
}",0.9955282280603688
183449,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.TTS_ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(1000,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.TTS_SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.TTS_ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.TTS_SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}",0.989667049368542
183450,"private void processSpeechQueue(){
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock();
    if (!speechQueueAvailable) {
      return;
    }
    if (mSpeechQueue.size() < 1) {
      mIsSpeaking=false;
      broadcastTtsQueueProcessingCompleted();
      return;
    }
    mCurrentSpeechItem=mSpeechQueue.get(0);
    mIsSpeaking=true;
    SoundResource sr=getSoundResource(mCurrentSpeechItem);
    Log.i(""String_Node_Str"",""String_Node_Str"" + mCurrentSpeechItem.mText);
    if (sr == null) {
      if (mCurrentSpeechItem.mType == SpeechItem.TEXT) {
        mCurrentSpeechItem=splitCurrentTextIfNeeded(mCurrentSpeechItem);
        speakInternalOnly(mCurrentSpeechItem);
      }
 else       if (mCurrentSpeechItem.mType == SpeechItem.TEXT_TO_FILE) {
        synthToFileInternalOnly(mCurrentSpeechItem);
      }
 else {
        silence(mCurrentSpeechItem);
      }
    }
 else {
      cleanUpPlayer();
      if (sr.mSourcePackageName == PKGNAME) {
        mPlayer=MediaPlayer.create(this,sr.mResId);
      }
 else       if (sr.mSourcePackageName != null) {
        Context ctx;
        try {
          ctx=this.createPackageContext(sr.mSourcePackageName,0);
        }
 catch (        NameNotFoundException e) {
          e.printStackTrace();
          mSpeechQueue.remove(0);
          mIsSpeaking=false;
          return;
        }
        mPlayer=MediaPlayer.create(ctx,sr.mResId);
      }
 else {
        mPlayer=MediaPlayer.create(this,Uri.parse(sr.mFilename));
      }
      if (mPlayer == null) {
        mSpeechQueue.clear();
        mIsSpeaking=false;
        return;
      }
      mPlayer.setOnCompletionListener(this);
      try {
        mPlayer.setAudioStreamType(getStreamTypeFromParams(mCurrentSpeechItem.mParams));
        mPlayer.start();
      }
 catch (      IllegalStateException e) {
        mSpeechQueue.clear();
        mIsSpeaking=false;
        cleanUpPlayer();
        return;
      }
    }
    if (mSpeechQueue.size() > 0) {
      mSpeechQueue.remove(0);
    }
  }
  finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
  }
}","private void processSpeechQueue(){
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (!speechQueueAvailable) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      return;
    }
    if (mSpeechQueue.size() < 1) {
      mIsSpeaking=false;
      broadcastTtsQueueProcessingCompleted();
      return;
    }
    mCurrentSpeechItem=mSpeechQueue.get(0);
    mIsSpeaking=true;
    SoundResource sr=getSoundResource(mCurrentSpeechItem);
    Log.i(""String_Node_Str"",""String_Node_Str"" + mCurrentSpeechItem.mText);
    if (sr == null) {
      if (mCurrentSpeechItem.mType == SpeechItem.TEXT) {
        mCurrentSpeechItem=splitCurrentTextIfNeeded(mCurrentSpeechItem);
        speakInternalOnly(mCurrentSpeechItem);
      }
 else       if (mCurrentSpeechItem.mType == SpeechItem.TEXT_TO_FILE) {
        synthToFileInternalOnly(mCurrentSpeechItem);
      }
 else {
        silence(mCurrentSpeechItem);
      }
    }
 else {
      cleanUpPlayer();
      if (sr.mSourcePackageName == PKGNAME) {
        mPlayer=MediaPlayer.create(this,sr.mResId);
      }
 else       if (sr.mSourcePackageName != null) {
        Context ctx;
        try {
          ctx=this.createPackageContext(sr.mSourcePackageName,0);
        }
 catch (        NameNotFoundException e) {
          e.printStackTrace();
          mSpeechQueue.remove(0);
          mIsSpeaking=false;
          return;
        }
        mPlayer=MediaPlayer.create(ctx,sr.mResId);
      }
 else {
        mPlayer=MediaPlayer.create(this,Uri.parse(sr.mFilename));
      }
      if (mPlayer == null) {
        mSpeechQueue.clear();
        mIsSpeaking=false;
        return;
      }
      mPlayer.setOnCompletionListener(this);
      try {
        mPlayer.setAudioStreamType(getStreamTypeFromParams(mCurrentSpeechItem.mParams));
        mPlayer.start();
      }
 catch (      IllegalStateException e) {
        mSpeechQueue.clear();
        mIsSpeaking=false;
        cleanUpPlayer();
        return;
      }
    }
    if (mSpeechQueue.size() > 0) {
      mSpeechQueue.remove(0);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
  }
}",0.953388876379194
183451,"private Object responseCdmaCallWaiting(Parcel p){
  CdmaCallWaitingNotification notification=new CdmaCallWaitingNotification();
  notification.number=p.readString();
  notification.numberPresentation=p.readInt();
  notification.name=p.readString();
  notification.namePresentation=notification.numberPresentation;
  notification.isPresent=p.readInt();
  notification.signalType=p.readInt();
  notification.alertPitch=p.readInt();
  notification.signal=p.readInt();
  return notification;
}","private Object responseCdmaCallWaiting(Parcel p){
  CdmaCallWaitingNotification notification=new CdmaCallWaitingNotification();
  notification.number=p.readString();
  notification.numberPresentation=notification.presentationFromCLIP(p.readInt());
  notification.name=p.readString();
  notification.namePresentation=notification.numberPresentation;
  notification.isPresent=p.readInt();
  notification.signalType=p.readInt();
  notification.alertPitch=p.readInt();
  notification.signal=p.readInt();
  return notification;
}",0.947680157946693
183452,"private void processUnsolicited(Parcel p){
  int response;
  Object ret;
  response=p.readInt();
  try {
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
      ret=responseVoid(p);
    break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
  ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
ret=responseInts(p);
break;
case RIL_UNSOL_ON_USSD:
ret=responseStrings(p);
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
ret=responseString(p);
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
ret=responseSignalStrength(p);
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
ret=responseDataCallList(p);
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
ret=responseSuppServiceNotification(p);
break;
case RIL_UNSOL_STK_SESSION_END:
ret=responseVoid(p);
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
ret=responseString(p);
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
ret=responseString(p);
break;
case RIL_UNSOL_STK_CALL_SETUP:
ret=responseInts(p);
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_SIM_REFRESH:
ret=responseInts(p);
break;
case RIL_UNSOL_CALL_RING:
ret=responseCallRing(p);
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
ret=responseInts(p);
break;
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
ret=responseCdmaSms(p);
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
ret=responseVoid(p);
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
ret=responseCdmaCallWaiting(p);
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
ret=responseInts(p);
break;
case RIL_UNSOL_CDMA_INFO_REC:
ret=responseCdmaInformationRecord(p);
break;
case RIL_UNSOL_OEM_HOOK_RAW:
ret=responseRaw(p);
break;
default :
throw new RuntimeException(""String_Node_Str"" + response);
}
}
 catch (Throwable tr) {
Log.e(LOG_TAG,""String_Node_Str"" + response + ""String_Node_Str""+ tr.toString());
return;
}
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
setRadioStateFromRILInt(p.readInt());
if (RILJ_LOGD) unsljLogMore(response,mState.toString());
break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mCallStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
{
if (RILJ_LOGD) unsljLog(response);
String a[]=new String[2];
a[1]=(String)ret;
SmsMessage sms;
sms=SmsMessage.newFromCMT(a);
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
}
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSmsStatusRegistrant != null) {
mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
if (RILJ_LOGD) unsljLogRet(response,ret);
int[] smsIndex=(int[])ret;
if (smsIndex.length == 1) {
if (mSmsOnSimRegistrant != null) {
mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null,smsIndex,null));
}
}
 else {
if (RILJ_LOGD) riljLog(""String_Node_Str"" + smsIndex.length);
}
break;
case RIL_UNSOL_ON_USSD:
String[] resp=(String[])ret;
if (resp.length < 2) {
resp=new String[2];
resp[0]=((String[])ret)[0];
resp[1]=null;
}
if (RILJ_LOGD) unsljLogMore(response,resp[0]);
if (mUSSDRegistrant != null) {
mUSSDRegistrant.notifyRegistrant(new AsyncResult(null,resp,null));
}
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
if (RILJ_LOGD) unsljLogRet(response,ret);
long nitzReceiveTime=p.readLong();
Object[] result=new Object[2];
result[0]=ret;
result[1]=Long.valueOf(nitzReceiveTime);
if (mNITZTimeRegistrant != null) {
mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null,result,null));
}
 else {
mLastNITZTimeInfo=result;
}
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
if (RILJ_LOGV) unsljLogvRet(response,ret);
if (mSignalStrengthRegistrant != null) {
mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
if (RILJ_LOGD) unsljLogRet(response,ret);
mDataConnectionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSsnRegistrant != null) {
mSsnRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_SESSION_END:
if (RILJ_LOGD) unsljLog(response);
if (mStkSessionEndRegistrant != null) {
mStkSessionEndRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkProCmdRegistrant != null) {
mStkProCmdRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkEventRegistrant != null) {
mStkEventRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_CALL_SETUP:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkCallSetUpRegistrant != null) {
mStkCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_SIM_REFRESH:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mIccRefreshRegistrant != null) {
mIccRefreshRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CALL_RING:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mRingRegistrant != null) {
mRingRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
if (RILJ_LOGD) unsljLogvRet(response,ret);
if (mRestrictedStateRegistrant != null) {
mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
if (RILJ_LOGD) unsljLog(response);
if (mIccStatusChangedRegistrants != null) {
mIccStatusChangedRegistrants.notifyRegistrants();
}
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
if (RILJ_LOGD) unsljLog(response);
SmsMessage sms=(SmsMessage)ret;
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
if (RILJ_LOGD) unsljLog(response);
if (mGsmBroadcastSmsRegistrant != null) {
mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
if (RILJ_LOGD) unsljLog(response);
if (mEmergencyCallbackModeRegistrant != null) {
mEmergencyCallbackModeRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
if (RILJ_LOGD) unsljLog(response);
if (mCallWaitingInfoRegistrants != null) {
mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mOtaProvisionRegistrants != null) {
mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_INFO_REC:
ArrayList<CdmaInformationRecords> listInfoRecs;
try {
listInfoRecs=(ArrayList<CdmaInformationRecords>)ret;
}
 catch (ClassCastException e) {
Log.e(LOG_TAG,""String_Node_Str"",e);
break;
}
for (CdmaInformationRecords rec : listInfoRecs) {
if (RILJ_LOGD) unsljLogRet(response,rec);
notifyRegistrantsCdmaInfoRec(rec);
}
break;
case RIL_UNSOL_OEM_HOOK_RAW:
if (RILJ_LOGD) unsljLogvRet(response,IccUtils.bytesToHexString((byte[])ret));
if (mUnsolOemHookRawRegistrant != null) {
mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
}
}","private void processUnsolicited(Parcel p){
  int response;
  Object ret;
  response=p.readInt();
  try {
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
      ret=responseVoid(p);
    break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
  ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
ret=responseInts(p);
break;
case RIL_UNSOL_ON_USSD:
ret=responseStrings(p);
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
ret=responseString(p);
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
ret=responseSignalStrength(p);
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
ret=responseDataCallList(p);
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
ret=responseSuppServiceNotification(p);
break;
case RIL_UNSOL_STK_SESSION_END:
ret=responseVoid(p);
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
ret=responseString(p);
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
ret=responseString(p);
break;
case RIL_UNSOL_STK_CALL_SETUP:
ret=responseInts(p);
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_SIM_REFRESH:
ret=responseInts(p);
break;
case RIL_UNSOL_CALL_RING:
ret=responseCallRing(p);
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
ret=responseInts(p);
break;
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
ret=responseCdmaSms(p);
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
ret=responseVoid(p);
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
ret=responseCdmaCallWaiting(p);
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
ret=responseInts(p);
break;
case RIL_UNSOL_CDMA_INFO_REC:
ret=responseCdmaInformationRecord(p);
break;
case RIL_UNSOL_OEM_HOOK_RAW:
ret=responseRaw(p);
break;
default :
throw new RuntimeException(""String_Node_Str"" + response);
}
}
 catch (Throwable tr) {
Log.e(LOG_TAG,""String_Node_Str"" + response + ""String_Node_Str""+ tr.toString());
return;
}
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
setRadioStateFromRILInt(p.readInt());
if (RILJ_LOGD) unsljLogMore(response,mState.toString());
break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mCallStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
{
if (RILJ_LOGD) unsljLog(response);
String a[]=new String[2];
a[1]=(String)ret;
SmsMessage sms;
sms=SmsMessage.newFromCMT(a);
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
}
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSmsStatusRegistrant != null) {
mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
if (RILJ_LOGD) unsljLogRet(response,ret);
int[] smsIndex=(int[])ret;
if (smsIndex.length == 1) {
if (mSmsOnSimRegistrant != null) {
mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null,smsIndex,null));
}
}
 else {
if (RILJ_LOGD) riljLog(""String_Node_Str"" + smsIndex.length);
}
break;
case RIL_UNSOL_ON_USSD:
String[] resp=(String[])ret;
if (resp.length < 2) {
resp=new String[2];
resp[0]=((String[])ret)[0];
resp[1]=null;
}
if (RILJ_LOGD) unsljLogMore(response,resp[0]);
if (mUSSDRegistrant != null) {
mUSSDRegistrant.notifyRegistrant(new AsyncResult(null,resp,null));
}
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
if (RILJ_LOGD) unsljLogRet(response,ret);
long nitzReceiveTime=p.readLong();
Object[] result=new Object[2];
result[0]=ret;
result[1]=Long.valueOf(nitzReceiveTime);
if (mNITZTimeRegistrant != null) {
mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null,result,null));
}
 else {
mLastNITZTimeInfo=result;
}
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
if (RILJ_LOGV) unsljLogvRet(response,ret);
if (mSignalStrengthRegistrant != null) {
mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
if (RILJ_LOGD) unsljLogRet(response,ret);
mDataConnectionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSsnRegistrant != null) {
mSsnRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_SESSION_END:
if (RILJ_LOGD) unsljLog(response);
if (mStkSessionEndRegistrant != null) {
mStkSessionEndRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkProCmdRegistrant != null) {
mStkProCmdRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkEventRegistrant != null) {
mStkEventRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_CALL_SETUP:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkCallSetUpRegistrant != null) {
mStkCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_SIM_REFRESH:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mIccRefreshRegistrant != null) {
mIccRefreshRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CALL_RING:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mRingRegistrant != null) {
mRingRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
if (RILJ_LOGD) unsljLogvRet(response,ret);
if (mRestrictedStateRegistrant != null) {
mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
if (RILJ_LOGD) unsljLog(response);
if (mIccStatusChangedRegistrants != null) {
mIccStatusChangedRegistrants.notifyRegistrants();
}
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
if (RILJ_LOGD) unsljLog(response);
SmsMessage sms=(SmsMessage)ret;
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
if (RILJ_LOGD) unsljLog(response);
if (mGsmBroadcastSmsRegistrant != null) {
mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
if (RILJ_LOGD) unsljLog(response);
if (mEmergencyCallbackModeRegistrant != null) {
mEmergencyCallbackModeRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mCallWaitingInfoRegistrants != null) {
mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mOtaProvisionRegistrants != null) {
mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_INFO_REC:
ArrayList<CdmaInformationRecords> listInfoRecs;
try {
listInfoRecs=(ArrayList<CdmaInformationRecords>)ret;
}
 catch (ClassCastException e) {
Log.e(LOG_TAG,""String_Node_Str"",e);
break;
}
for (CdmaInformationRecords rec : listInfoRecs) {
if (RILJ_LOGD) unsljLogRet(response,rec);
notifyRegistrantsCdmaInfoRec(rec);
}
break;
case RIL_UNSOL_OEM_HOOK_RAW:
if (RILJ_LOGD) unsljLogvRet(response,IccUtils.bytesToHexString((byte[])ret));
if (mUnsolOemHookRawRegistrant != null) {
mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
}
}",0.9984712285207608
183453,"/** 
 * @see AudioManager#reloadAudioSettings() 
 */
public void reloadAudioSettings(){
  readPersistedSettings();
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=0; streamType < numStreamTypes; streamType++) {
    VolumeStreamState streamState=mStreamStates[streamType];
    if (streamType != AudioSystem.STREAM_BLUETOOTH_SCO) {
      String settingName=System.VOLUME_SETTINGS[streamType];
      String lastAudibleSettingName=settingName + System.APPEND_FOR_LAST_AUDIBLE;
      int index=Settings.System.getInt(mContentResolver,settingName,AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
      if (STREAM_VOLUME_ALIAS[streamType] != streamType) {
        index=rescaleIndex(index * 10,STREAM_VOLUME_ALIAS[streamType],streamType);
      }
 else {
        index*=10;
      }
      streamState.mIndex=streamState.getValidIndex(index);
      index=(index + 5) / 10;
      index=Settings.System.getInt(mContentResolver,lastAudibleSettingName,(index > 0) ? index : AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
      if (STREAM_VOLUME_ALIAS[streamType] != streamType) {
        index=rescaleIndex(index * 10,STREAM_VOLUME_ALIAS[streamType],streamType);
      }
 else {
        index*=10;
      }
      streamState.mLastAudibleIndex=streamState.getValidIndex(index);
    }
    if (streamState.muteCount() != 0 && !isStreamAffectedByMute(streamType)) {
      int size=streamState.mDeathHandlers.size();
      for (int i=0; i < size; i++) {
        streamState.mDeathHandlers.get(i).mMuteCount=1;
        streamState.mDeathHandlers.get(i).mute(false);
      }
    }
    if (streamState.muteCount() == 0) {
      setStreamVolumeIndex(streamType,streamState.mIndex);
    }
  }
  setRingerModeInt(getRingerMode(),false);
}","/** 
 * @see AudioManager#reloadAudioSettings() 
 */
public void reloadAudioSettings(){
  readPersistedSettings();
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  for (int streamType=0; streamType < numStreamTypes; streamType++) {
    VolumeStreamState streamState=mStreamStates[streamType];
    String settingName=System.VOLUME_SETTINGS[STREAM_VOLUME_ALIAS[streamType]];
    String lastAudibleSettingName=settingName + System.APPEND_FOR_LAST_AUDIBLE;
    int index=Settings.System.getInt(mContentResolver,settingName,AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
    if (STREAM_VOLUME_ALIAS[streamType] != streamType) {
      index=rescaleIndex(index * 10,STREAM_VOLUME_ALIAS[streamType],streamType);
    }
 else {
      index*=10;
    }
    streamState.mIndex=streamState.getValidIndex(index);
    index=(index + 5) / 10;
    index=Settings.System.getInt(mContentResolver,lastAudibleSettingName,(index > 0) ? index : AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
    if (STREAM_VOLUME_ALIAS[streamType] != streamType) {
      index=rescaleIndex(index * 10,STREAM_VOLUME_ALIAS[streamType],streamType);
    }
 else {
      index*=10;
    }
    streamState.mLastAudibleIndex=streamState.getValidIndex(index);
    if (streamState.muteCount() != 0 && !isStreamAffectedByMute(streamType)) {
      int size=streamState.mDeathHandlers.size();
      for (int i=0; i < size; i++) {
        streamState.mDeathHandlers.get(i).mMuteCount=1;
        streamState.mDeathHandlers.get(i).mute(false);
      }
    }
    if (streamState.muteCount() == 0) {
      setStreamVolumeIndex(streamType,streamState.mIndex);
    }
  }
  setRingerModeInt(getRingerMode(),false);
}",0.9639190378410092
183454,"/** 
 * Recycles an event if it can be safely recycled. The condition is that no not notified service is interested in the event.
 * @param event The event.
 */
private void tryRecycleLocked(AccessibilityEvent event){
  int eventType=event.getEventType();
  List<Service> services=mServices;
  for (int i=0, count=services.size(); i < count; i++) {
    Service service=services.get(i);
    if (service.mPendingEvents.get(eventType) == event) {
      return;
    }
  }
  event.recycle();
}","/** 
 * Recycles an event if it can be safely recycled. The condition is that no not notified service is interested in the event.
 * @param event The event.
 */
private void tryRecycleLocked(AccessibilityEvent event){
  if (event == null) {
    return;
  }
  int eventType=event.getEventType();
  List<Service> services=mServices;
  for (int i=0, count=services.size(); i < count; i++) {
    Service service=services.get(i);
    if (service.mPendingEvents.get(eventType) == event) {
      return;
    }
  }
  event.recycle();
}",0.961576354679803
183455,"/** 
 * Request the device MDN / H_SID / H_NID / MIN. ""response"" is const char  [0] is MDN if CDMA subscription is available [1] is H_SID (Home SID) if CDMA subscription is available [2] is H_NID (Home NID) if CDMA subscription is available [3] is MIN (10 digits, MIN2+MIN1) if CDMA subscription is available
 */
public void getCDMASubscription(Message response);","/** 
 * Request the device MDN / H_SID / H_NID / MIN. ""response"" is const char  [0] is MDN if CDMA subscription is available [1] is H_SID (Home SID) in hexadecimal if CDMA subscription is available [2] is H_NID (Home NID) in hexadecimal if CDMA subscription is available [3] is MIN (10 digits, MIN2+MIN1) if CDMA subscription is available
 */
public void getCDMASubscription(Message response);",0.9603174603174603
183456,"@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=sid.length > 0 ? Integer.parseInt(sid[0]) : 0;
}
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=nid.length > 0 ? Integer.parseInt(nid[0]) : 0;
}
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}","@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=sid.length > 0 ? Integer.parseInt(sid[0],16) : 0;
}
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=nid.length > 0 ? Integer.parseInt(nid[0],16) : 0;
}
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}",0.9992507492507492
183457,"/** 
 * @return Whether music is being played right now.
 */
boolean isMusicActive(){
  final IAudioService audio=getAudioInterface();
  if (audio == null) {
    Log.w(TAG,""String_Node_Str"");
    return false;
  }
  try {
    return audio.isMusicActive();
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"" + e);
    return false;
  }
}","/** 
 * @return Whether music is being played right now.
 */
boolean isMusicActive(){
  final AudioManager am=(AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
  if (am == null) {
    Log.w(TAG,""String_Node_Str"");
    return false;
  }
  return am.isMusicActive();
}",0.5886075949367089
183458,"/** 
 * Check a parcel containing metadata is well formed. The header is checked as well as the individual records format. However, the data inside the record is not checked because we do lazy access (we check/unmarshall only data the user asks for.) Format of a metadata parcel: <pre> 1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                     metadata total size                       | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |     'M'       |     'E'       |     'T'       |     'A'       | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                                                               | |                .... metadata records ....                     | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ </pre>
 * @param parcel With the serialized data. Metadata keeps areference on it to access it later on. The caller should not modify the parcel after this call (and not call recycle on it.)
 * @return false if an error occurred.
 */
public boolean parse(Parcel parcel){
  if (parcel.dataAvail() < kMetaHeaderSize) {
    Log.e(TAG,""String_Node_Str"" + parcel.dataAvail());
    return false;
  }
  final int pin=parcel.dataPosition();
  final int size=parcel.readInt();
  if (parcel.dataAvail() < size || size < kMetaHeaderSize) {
    Log.e(TAG,""String_Node_Str"" + size);
    parcel.setDataPosition(pin);
    return false;
  }
  final int kShouldBeMetaMarker=parcel.readInt();
  if (kShouldBeMetaMarker != kMetaMarker) {
    Log.e(TAG,""String_Node_Str"" + Integer.toHexString(kShouldBeMetaMarker));
    parcel.setDataPosition(pin);
    return false;
  }
  if (!scanAllRecords(parcel,size - kMetaHeaderSize)) {
    parcel.setDataPosition(pin);
    return false;
  }
  mParcel=parcel;
  return true;
}","/** 
 * Check a parcel containing metadata is well formed. The header is checked as well as the individual records format. However, the data inside the record is not checked because we do lazy access (we check/unmarshall only data the user asks for.) Format of a metadata parcel: <pre> 1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                     metadata total size                       | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |     'M'       |     'E'       |     'T'       |     'A'       | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |                                                               | |                .... metadata records ....                     | |                                                               | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ </pre>
 * @param parcel With the serialized data. Metadata keeps areference on it to access it later on. The caller should not modify the parcel after this call (and not call recycle on it.)
 * @return false if an error occurred.
 */
public boolean parse(Parcel parcel){
  if (parcel.dataAvail() < kMetaHeaderSize) {
    Log.e(TAG,""String_Node_Str"" + parcel.dataAvail());
    return false;
  }
  final int pin=parcel.dataPosition();
  final int size=parcel.readInt();
  if (parcel.dataAvail() + 4 < size || size < kMetaHeaderSize) {
    Log.e(TAG,""String_Node_Str"" + size + ""String_Node_Str""+ parcel.dataAvail()+ ""String_Node_Str""+ pin);
    parcel.setDataPosition(pin);
    return false;
  }
  final int kShouldBeMetaMarker=parcel.readInt();
  if (kShouldBeMetaMarker != kMetaMarker) {
    Log.e(TAG,""String_Node_Str"" + Integer.toHexString(kShouldBeMetaMarker));
    parcel.setDataPosition(pin);
    return false;
  }
  if (!scanAllRecords(parcel,size - kMetaHeaderSize)) {
    parcel.setDataPosition(pin);
    return false;
  }
  mParcel=parcel;
  return true;
}",0.9831349206349206
183459,"private void assertParse() throws Exception {
  mParcel.writeInt(kToken);
  mParcel.setDataPosition(0);
  assertTrue(mMetadata.parse(mParcel));
  assertEquals(kToken,mParcel.readInt());
}","private void assertParse() throws Exception {
  mParcel.setDataPosition(0);
  assertTrue(mMetadata.parse(mParcel));
}",0.7697368421052632
183460,"private void persistVolume(VolumeStreamState streamState){
  System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,streamState.mIndex);
  System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,streamState.mLastAudibleIndex);
}","private void persistVolume(VolumeStreamState streamState){
  if (streamState.mStreamType != AudioManager.STREAM_BLUETOOTH_SCO) {
    System.putInt(mContentResolver,streamState.mVolumeIndexSettingName,streamState.mIndex);
    System.putInt(mContentResolver,streamState.mLastAudibleVolumeIndexSettingName,streamState.mLastAudibleIndex);
  }
}",0.8704318936877077
183461,"void acceptCall() throws CallStateException {
  if (ringingCall.getState() == CdmaCall.State.INCOMING) {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    setMute(false);
    cm.acceptCall(obtainCompleteMessage());
  }
 else   if (ringingCall.getState() == CdmaCall.State.WAITING) {
    CdmaConnection cwConn=(CdmaConnection)(ringingCall.getLatestConnection());
    cwConn.updateParent(ringingCall,foregroundCall);
    cwConn.onConnectedInOrOut();
    switchWaitingOrHoldingAndActive();
  }
 else {
    throw new CallStateException(""String_Node_Str"");
  }
}","void acceptCall() throws CallStateException {
  if (ringingCall.getState() == CdmaCall.State.INCOMING) {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    setMute(false);
    cm.acceptCall(obtainCompleteMessage());
  }
 else   if (ringingCall.getState() == CdmaCall.State.WAITING) {
    CdmaConnection cwConn=(CdmaConnection)(ringingCall.getLatestConnection());
    cwConn.updateParent(ringingCall,foregroundCall);
    cwConn.onConnectedInOrOut();
    updatePhoneState();
    switchWaitingOrHoldingAndActive();
  }
 else {
    throw new CallStateException(""String_Node_Str"");
  }
}",0.978984238178634
183462,"protected void handlePollCalls(AsyncResult ar){
  List polledCalls;
  if (ar.exception == null) {
    polledCalls=(List)ar.result;
  }
 else   if (isCommandExceptionRadioNotAvailable(ar.exception)) {
    polledCalls=new ArrayList();
  }
 else {
    pollCallsAfterDelay();
    return;
  }
  Connection newRinging=null;
  boolean hasNonHangupStateChanged=false;
  boolean needsPollDelay=false;
  boolean unknownConnectionAppeared=false;
  for (int i=0, curDC=0, dcSize=polledCalls.size(); i < connections.length; i++) {
    CdmaConnection conn=connections[i];
    DriverCall dc=null;
    if (curDC < dcSize) {
      dc=(DriverCall)polledCalls.get(curDC);
      if (dc.index == i + 1) {
        curDC++;
      }
 else {
        dc=null;
      }
    }
    if (DBG_POLL)     log(""String_Node_Str"" + i + ""String_Node_Str""+ conn+ ""String_Node_Str""+ dc);
    if (conn == null && dc != null) {
      if (pendingMO != null && pendingMO.compareTo(dc)) {
        if (DBG_POLL)         log(""String_Node_Str"" + pendingMO);
        connections[i]=pendingMO;
        pendingMO.index=i;
        pendingMO.update(dc);
        pendingMO=null;
        if (hangupPendingMO) {
          hangupPendingMO=false;
          try {
            if (Phone.DEBUG_PHONE)             log(""String_Node_Str"" + i);
            hangup(connections[i]);
          }
 catch (          CallStateException ex) {
            Log.e(LOG_TAG,""String_Node_Str"");
          }
          return;
        }
      }
 else {
        connections[i]=new CdmaConnection(phone.getContext(),dc,this,i);
        if (connections[i].getCall() == ringingCall) {
          newRinging=connections[i];
        }
 else {
          Log.i(LOG_TAG,""String_Node_Str"" + dc);
          if (dc.state != DriverCall.State.ALERTING && dc.state != DriverCall.State.DIALING) {
            connections[i].connectTime=System.currentTimeMillis();
          }
          unknownConnectionAppeared=true;
        }
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc == null) {
      int count=foregroundCall.connections.size();
      if (count == 0) {
        droppedDuringPoll.add(conn);
      }
 else {
        for (int n=0; n < count; n++) {
          CdmaConnection cn=(CdmaConnection)foregroundCall.connections.get(n);
          droppedDuringPoll.add(cn);
        }
      }
      foregroundCall.setGeneric(false);
      connections[i]=null;
    }
 else     if (conn != null && dc != null && !conn.compareTo(dc)) {
      droppedDuringPoll.add(conn);
      connections[i]=new CdmaConnection(phone.getContext(),dc,this,i);
      if (connections[i].getCall() == ringingCall) {
        newRinging=connections[i];
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc != null) {
      boolean changed;
      changed=conn.update(dc);
      hasNonHangupStateChanged=hasNonHangupStateChanged || changed;
    }
    if (REPEAT_POLLING) {
      if (dc != null) {
        if ((dc.state == DriverCall.State.DIALING) || (dc.state == DriverCall.State.ALERTING) || (dc.state == DriverCall.State.INCOMING)|| (dc.state == DriverCall.State.WAITING)) {
          needsPollDelay=true;
        }
      }
    }
  }
  if (pendingMO != null) {
    Log.d(LOG_TAG,""String_Node_Str"" + foregroundCall.getState());
    droppedDuringPoll.add(pendingMO);
    pendingMO=null;
    hangupPendingMO=false;
    if (pendingCallInECM) {
      pendingCallInECM=false;
    }
  }
  if (newRinging != null) {
    phone.notifyNewRingingConnection(newRinging);
  }
  for (int i=droppedDuringPoll.size() - 1; i >= 0; i--) {
    CdmaConnection conn=droppedDuringPoll.get(i);
    if (conn.isIncoming() && conn.getConnectTime() == 0) {
      Connection.DisconnectCause cause;
      if (conn.cause == Connection.DisconnectCause.LOCAL) {
        cause=Connection.DisconnectCause.INCOMING_REJECTED;
      }
 else {
        cause=Connection.DisconnectCause.INCOMING_MISSED;
      }
      if (Phone.DEBUG_PHONE) {
        log(""String_Node_Str"" + conn.cause);
        log(""String_Node_Str"" + cause);
      }
      droppedDuringPoll.remove(i);
      conn.onDisconnect(cause);
    }
 else     if (conn.cause == Connection.DisconnectCause.LOCAL) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.LOCAL);
    }
 else     if (conn.cause == Connection.DisconnectCause.INVALID_NUMBER) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.INVALID_NUMBER);
    }
  }
  if (droppedDuringPoll.size() > 0) {
    cm.getLastCallFailCause(obtainNoPollCompleteMessage(EVENT_GET_LAST_CALL_FAIL_CAUSE));
  }
  if (needsPollDelay) {
    pollCallsAfterDelay();
  }
  if (newRinging != null || hasNonHangupStateChanged) {
    internalClearDisconnected();
  }
  updatePhoneState();
  if (unknownConnectionAppeared) {
    phone.notifyUnknownConnection();
  }
  if (hasNonHangupStateChanged || newRinging != null) {
    phone.notifyPreciseCallStateChanged();
  }
}","protected void handlePollCalls(AsyncResult ar){
  List polledCalls;
  if (ar.exception == null) {
    polledCalls=(List)ar.result;
  }
 else   if (isCommandExceptionRadioNotAvailable(ar.exception)) {
    polledCalls=new ArrayList();
  }
 else {
    pollCallsAfterDelay();
    return;
  }
  Connection newRinging=null;
  boolean hasNonHangupStateChanged=false;
  boolean needsPollDelay=false;
  boolean unknownConnectionAppeared=false;
  for (int i=0, curDC=0, dcSize=polledCalls.size(); i < connections.length; i++) {
    CdmaConnection conn=connections[i];
    DriverCall dc=null;
    if (curDC < dcSize) {
      dc=(DriverCall)polledCalls.get(curDC);
      if (dc.index == i + 1) {
        curDC++;
      }
 else {
        dc=null;
      }
    }
    if (DBG_POLL)     log(""String_Node_Str"" + i + ""String_Node_Str""+ conn+ ""String_Node_Str""+ dc);
    if (conn == null && dc != null) {
      if (pendingMO != null && pendingMO.compareTo(dc)) {
        if (DBG_POLL)         log(""String_Node_Str"" + pendingMO);
        connections[i]=pendingMO;
        pendingMO.index=i;
        pendingMO.update(dc);
        pendingMO=null;
        if (hangupPendingMO) {
          hangupPendingMO=false;
          try {
            if (Phone.DEBUG_PHONE)             log(""String_Node_Str"" + i);
            hangup(connections[i]);
          }
 catch (          CallStateException ex) {
            Log.e(LOG_TAG,""String_Node_Str"");
          }
          return;
        }
      }
 else {
        connections[i]=new CdmaConnection(phone.getContext(),dc,this,i);
        if (connections[i].getCall() == ringingCall) {
          newRinging=connections[i];
        }
 else {
          Log.i(LOG_TAG,""String_Node_Str"" + dc);
          if (dc.state != DriverCall.State.ALERTING && dc.state != DriverCall.State.DIALING) {
            connections[i].connectTime=System.currentTimeMillis();
          }
          unknownConnectionAppeared=true;
        }
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc == null) {
      int count=foregroundCall.connections.size();
      if (count == 0) {
        droppedDuringPoll.add(conn);
      }
 else {
        for (int n=0; n < count; n++) {
          CdmaConnection cn=(CdmaConnection)foregroundCall.connections.get(n);
          droppedDuringPoll.add(cn);
        }
      }
      foregroundCall.setGeneric(false);
      connections[i]=null;
    }
 else     if (conn != null && dc != null) {
      boolean changed;
      changed=conn.update(dc);
      hasNonHangupStateChanged=hasNonHangupStateChanged || changed;
    }
    if (REPEAT_POLLING) {
      if (dc != null) {
        if ((dc.state == DriverCall.State.DIALING) || (dc.state == DriverCall.State.ALERTING) || (dc.state == DriverCall.State.INCOMING)|| (dc.state == DriverCall.State.WAITING)) {
          needsPollDelay=true;
        }
      }
    }
  }
  if (pendingMO != null) {
    Log.d(LOG_TAG,""String_Node_Str"" + foregroundCall.getState());
    droppedDuringPoll.add(pendingMO);
    pendingMO=null;
    hangupPendingMO=false;
    if (pendingCallInECM) {
      pendingCallInECM=false;
    }
  }
  if (newRinging != null) {
    phone.notifyNewRingingConnection(newRinging);
  }
  for (int i=droppedDuringPoll.size() - 1; i >= 0; i--) {
    CdmaConnection conn=droppedDuringPoll.get(i);
    if (conn.isIncoming() && conn.getConnectTime() == 0) {
      Connection.DisconnectCause cause;
      if (conn.cause == Connection.DisconnectCause.LOCAL) {
        cause=Connection.DisconnectCause.INCOMING_REJECTED;
      }
 else {
        cause=Connection.DisconnectCause.INCOMING_MISSED;
      }
      if (Phone.DEBUG_PHONE) {
        log(""String_Node_Str"" + conn.cause);
        log(""String_Node_Str"" + cause);
      }
      droppedDuringPoll.remove(i);
      conn.onDisconnect(cause);
    }
 else     if (conn.cause == Connection.DisconnectCause.LOCAL) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.LOCAL);
    }
 else     if (conn.cause == Connection.DisconnectCause.INVALID_NUMBER) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.INVALID_NUMBER);
    }
  }
  if (droppedDuringPoll.size() > 0) {
    cm.getLastCallFailCause(obtainNoPollCompleteMessage(EVENT_GET_LAST_CALL_FAIL_CAUSE));
  }
  if (needsPollDelay) {
    pollCallsAfterDelay();
  }
  if (newRinging != null || hasNonHangupStateChanged) {
    internalClearDisconnected();
  }
  updatePhoneState();
  if (unknownConnectionAppeared) {
    phone.notifyUnknownConnection();
  }
  if (hasNonHangupStateChanged || newRinging != null) {
    phone.notifyPreciseCallStateChanged();
  }
}",0.967391304347826
183463,"private void handleCallWaitingInfo(CdmaCallWaitingNotification cw){
  if (foregroundCall.connections.size() > 1) {
    foregroundCall.setGeneric(true);
  }
  ringingCall.setGeneric(false);
  new CdmaConnection(phone.getContext(),cw,this,ringingCall);
  notifyCallWaitingInfo(cw);
}","private void handleCallWaitingInfo(CdmaCallWaitingNotification cw){
  if (foregroundCall.connections.size() > 1) {
    foregroundCall.setGeneric(true);
  }
  ringingCall.setGeneric(false);
  new CdmaConnection(phone.getContext(),cw,this,ringingCall);
  updatePhoneState();
  notifyCallWaitingInfo(cw);
}",0.9623287671232876
183464,"public ConfigurationInfo getDeviceConfigurationInfo(){
  ConfigurationInfo config=new ConfigurationInfo();
synchronized (this) {
    config.reqTouchScreen=mConfiguration.touchscreen;
    config.reqKeyboardType=mConfiguration.keyboard;
    config.reqNavigation=mConfiguration.navigation;
    if (mConfiguration.navigation != Configuration.NAVIGATION_NONAV) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
    }
    if (mConfiguration.keyboard != Configuration.KEYBOARD_UNDEFINED) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
    }
  }
  return config;
}","public ConfigurationInfo getDeviceConfigurationInfo(){
  ConfigurationInfo config=new ConfigurationInfo();
synchronized (this) {
    config.reqTouchScreen=mConfiguration.touchscreen;
    config.reqKeyboardType=mConfiguration.keyboard;
    config.reqNavigation=mConfiguration.navigation;
    if (mConfiguration.navigation == Configuration.NAVIGATION_DPAD || mConfiguration.navigation == Configuration.NAVIGATION_TRACKBALL) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
    }
    if (mConfiguration.keyboard != Configuration.KEYBOARD_UNDEFINED && mConfiguration.keyboard != Configuration.KEYBOARD_NOKEYS) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
    }
  }
  return config;
}",0.7958883994126285
183465,"public ConfigurationInfo getDeviceConfigurationInfo(){
  ConfigurationInfo config=new ConfigurationInfo();
synchronized (this) {
    config.reqTouchScreen=mConfiguration.touchscreen;
    config.reqKeyboardType=mConfiguration.keyboard;
    config.reqNavigation=mConfiguration.navigation;
    if (mConfiguration.navigation != Configuration.NAVIGATION_NONAV) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
    }
    if (mConfiguration.keyboard != Configuration.KEYBOARD_UNDEFINED) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
    }
  }
  return config;
}","public ConfigurationInfo getDeviceConfigurationInfo(){
  ConfigurationInfo config=new ConfigurationInfo();
synchronized (this) {
    config.reqTouchScreen=mConfiguration.touchscreen;
    config.reqKeyboardType=mConfiguration.keyboard;
    config.reqNavigation=mConfiguration.navigation;
    if (mConfiguration.navigation == Configuration.NAVIGATION_DPAD || mConfiguration.navigation == Configuration.NAVIGATION_TRACKBALL) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
    }
    if (mConfiguration.keyboard != Configuration.KEYBOARD_UNDEFINED && mConfiguration.keyboard != Configuration.KEYBOARD_NOKEYS) {
      config.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
    }
  }
  return config;
}",0.7958883994126285
183466,"private Uri endFile(FileCacheEntry entry,boolean ringtones,boolean notifications,boolean alarms,boolean music,boolean podcasts) throws RemoteException {
  Uri tableUri;
  boolean isAudio=MediaFile.isAudioFileType(mFileType);
  boolean isVideo=MediaFile.isVideoFileType(mFileType);
  boolean isImage=MediaFile.isImageFileType(mFileType);
  if (isVideo) {
    tableUri=mVideoUri;
  }
 else   if (isImage) {
    tableUri=mImagesUri;
  }
 else   if (isAudio) {
    tableUri=mAudioUri;
  }
 else {
    return null;
  }
  entry.mTableUri=tableUri;
  if (mArtist == null || mArtist.length() == 0) {
    mArtist=mAlbumArtist;
  }
  ContentValues values=toValues();
  String title=values.getAsString(MediaStore.MediaColumns.TITLE);
  if (TextUtils.isEmpty(title)) {
    title=values.getAsString(MediaStore.MediaColumns.DATA);
    int lastSlash=title.lastIndexOf('/');
    if (lastSlash >= 0) {
      lastSlash++;
      if (lastSlash < title.length()) {
        title=title.substring(lastSlash);
      }
    }
    int lastDot=title.lastIndexOf('.');
    if (lastDot > 0) {
      title=title.substring(0,lastDot);
    }
    values.put(MediaStore.MediaColumns.TITLE,title);
  }
  if (isAudio) {
    values.put(Audio.Media.IS_RINGTONE,ringtones);
    values.put(Audio.Media.IS_NOTIFICATION,notifications);
    values.put(Audio.Media.IS_ALARM,alarms);
    values.put(Audio.Media.IS_MUSIC,music);
    values.put(Audio.Media.IS_PODCAST,podcasts);
  }
 else   if (mFileType == MediaFile.FILE_TYPE_JPEG) {
    HashMap<String,String> exifData=ExifInterface.loadExifData(entry.mPath);
    if (exifData != null) {
      float[] latlng=ExifInterface.getLatLng(exifData);
      if (latlng != null) {
        values.put(Images.Media.LATITUDE,latlng[0]);
        values.put(Images.Media.LONGITUDE,latlng[1]);
      }
    }
  }
  Uri result=null;
  long rowId=entry.mRowId;
  if (rowId == 0) {
    result=mMediaProvider.insert(tableUri,values);
    if (result != null) {
      rowId=ContentUris.parseId(result);
      entry.mRowId=rowId;
    }
  }
 else {
    result=ContentUris.withAppendedId(tableUri,rowId);
    mMediaProvider.update(result,values,null,null);
  }
  if (mProcessGenres && mGenre != null) {
    String genre=mGenre;
    Uri uri=mGenreCache.get(genre);
    if (uri == null) {
      Cursor cursor=null;
      try {
        cursor=mMediaProvider.query(mGenresUri,GENRE_LOOKUP_PROJECTION,MediaStore.Audio.Genres.NAME + ""String_Node_Str"",new String[]{genre},null);
        if (cursor == null || cursor.getCount() == 0) {
          values.clear();
          values.put(MediaStore.Audio.Genres.NAME,genre);
          uri=mMediaProvider.insert(mGenresUri,values);
        }
 else {
          cursor.moveToNext();
          uri=ContentUris.withAppendedId(mGenresUri,cursor.getLong(0));
        }
        if (uri != null) {
          uri=Uri.withAppendedPath(uri,Genres.Members.CONTENT_DIRECTORY);
          mGenreCache.put(genre,uri);
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
    if (uri != null) {
      values.clear();
      values.put(MediaStore.Audio.Genres.Members.AUDIO_ID,Long.valueOf(rowId));
      mMediaProvider.insert(uri,values);
    }
  }
  if (notifications && !mDefaultNotificationSet) {
    if (TextUtils.isEmpty(mDefaultNotificationFilename) || doesPathHaveFilename(entry.mPath,mDefaultNotificationFilename)) {
      setSettingIfNotSet(Settings.System.NOTIFICATION_SOUND,tableUri,rowId);
      mDefaultNotificationSet=true;
    }
  }
 else   if (ringtones && !mDefaultRingtoneSet) {
    if (TextUtils.isEmpty(mDefaultRingtoneFilename) || doesPathHaveFilename(entry.mPath,mDefaultRingtoneFilename)) {
      setSettingIfNotSet(Settings.System.RINGTONE,tableUri,rowId);
      mDefaultRingtoneSet=true;
    }
  }
  return result;
}","private Uri endFile(FileCacheEntry entry,boolean ringtones,boolean notifications,boolean alarms,boolean music,boolean podcasts) throws RemoteException {
  Uri tableUri;
  boolean isAudio=MediaFile.isAudioFileType(mFileType);
  boolean isVideo=MediaFile.isVideoFileType(mFileType);
  boolean isImage=MediaFile.isImageFileType(mFileType);
  if (isVideo) {
    tableUri=mVideoUri;
  }
 else   if (isImage) {
    tableUri=mImagesUri;
  }
 else   if (isAudio) {
    tableUri=mAudioUri;
  }
 else {
    return null;
  }
  entry.mTableUri=tableUri;
  if (mArtist == null || mArtist.length() == 0) {
    mArtist=mAlbumArtist;
  }
  ContentValues values=toValues();
  String title=values.getAsString(MediaStore.MediaColumns.TITLE);
  if (TextUtils.isEmpty(title.trim())) {
    title=values.getAsString(MediaStore.MediaColumns.DATA);
    int lastSlash=title.lastIndexOf('/');
    if (lastSlash >= 0) {
      lastSlash++;
      if (lastSlash < title.length()) {
        title=title.substring(lastSlash);
      }
    }
    int lastDot=title.lastIndexOf('.');
    if (lastDot > 0) {
      title=title.substring(0,lastDot);
    }
    values.put(MediaStore.MediaColumns.TITLE,title);
  }
  if (isAudio) {
    values.put(Audio.Media.IS_RINGTONE,ringtones);
    values.put(Audio.Media.IS_NOTIFICATION,notifications);
    values.put(Audio.Media.IS_ALARM,alarms);
    values.put(Audio.Media.IS_MUSIC,music);
    values.put(Audio.Media.IS_PODCAST,podcasts);
  }
 else   if (mFileType == MediaFile.FILE_TYPE_JPEG) {
    HashMap<String,String> exifData=ExifInterface.loadExifData(entry.mPath);
    if (exifData != null) {
      float[] latlng=ExifInterface.getLatLng(exifData);
      if (latlng != null) {
        values.put(Images.Media.LATITUDE,latlng[0]);
        values.put(Images.Media.LONGITUDE,latlng[1]);
      }
    }
  }
  Uri result=null;
  long rowId=entry.mRowId;
  if (rowId == 0) {
    result=mMediaProvider.insert(tableUri,values);
    if (result != null) {
      rowId=ContentUris.parseId(result);
      entry.mRowId=rowId;
    }
  }
 else {
    result=ContentUris.withAppendedId(tableUri,rowId);
    mMediaProvider.update(result,values,null,null);
  }
  if (mProcessGenres && mGenre != null) {
    String genre=mGenre;
    Uri uri=mGenreCache.get(genre);
    if (uri == null) {
      Cursor cursor=null;
      try {
        cursor=mMediaProvider.query(mGenresUri,GENRE_LOOKUP_PROJECTION,MediaStore.Audio.Genres.NAME + ""String_Node_Str"",new String[]{genre},null);
        if (cursor == null || cursor.getCount() == 0) {
          values.clear();
          values.put(MediaStore.Audio.Genres.NAME,genre);
          uri=mMediaProvider.insert(mGenresUri,values);
        }
 else {
          cursor.moveToNext();
          uri=ContentUris.withAppendedId(mGenresUri,cursor.getLong(0));
        }
        if (uri != null) {
          uri=Uri.withAppendedPath(uri,Genres.Members.CONTENT_DIRECTORY);
          mGenreCache.put(genre,uri);
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
    if (uri != null) {
      values.clear();
      values.put(MediaStore.Audio.Genres.Members.AUDIO_ID,Long.valueOf(rowId));
      mMediaProvider.insert(uri,values);
    }
  }
  if (notifications && !mDefaultNotificationSet) {
    if (TextUtils.isEmpty(mDefaultNotificationFilename) || doesPathHaveFilename(entry.mPath,mDefaultNotificationFilename)) {
      setSettingIfNotSet(Settings.System.NOTIFICATION_SOUND,tableUri,rowId);
      mDefaultNotificationSet=true;
    }
  }
 else   if (ringtones && !mDefaultRingtoneSet) {
    if (TextUtils.isEmpty(mDefaultRingtoneFilename) || doesPathHaveFilename(entry.mPath,mDefaultRingtoneFilename)) {
      setSettingIfNotSet(Settings.System.RINGTONE,tableUri,rowId);
      mDefaultRingtoneSet=true;
    }
  }
  return result;
}",0.999078826161337
183467,"private final void updateBattery(Intent intent){
  mBatteryData.iconId=intent.getIntExtra(""String_Node_Str"",0);
  mBatteryData.iconLevel=intent.getIntExtra(""String_Node_Str"",0);
  mService.updateIcon(mBatteryIcon,mBatteryData,null);
  int plugged=intent.getIntExtra(""String_Node_Str"",0);
  int level=intent.getIntExtra(""String_Node_Str"",-1);
  if (false) {
    Log.d(TAG,""String_Node_Str"" + level + ""String_Node_Str""+ plugged+ ""String_Node_Str""+ mBatteryPlugged+ ""String_Node_Str""+ mBatteryLevel+ ""String_Node_Str""+ mBatteryThreshold+ ""String_Node_Str""+ mBatteryFirst);
  }
  int oldPlugged=mBatteryPlugged;
  int oldThreshold=mBatteryThreshold;
  pickNextBatteryLevel(level);
  mBatteryPlugged=plugged;
  mBatteryLevel=level;
  if (mBatteryFirst) {
    mBatteryFirst=false;
  }
  if (false) {
    Log.d(TAG,""String_Node_Str"" + plugged + ""String_Node_Str""+ oldPlugged+ ""String_Node_Str""+ level+ ""String_Node_Str""+ mBatteryThreshold+ ""String_Node_Str""+ oldThreshold);
  }
  if (plugged == 0 && ((oldPlugged != 0 && level < mBatteryThresholds[BATTERY_THRESHOLD_WARNING]) || (mBatteryThreshold > oldThreshold && mBatteryThreshold > BATTERY_THRESHOLD_WARNING))) {
    mSentLowBatteryBroadcast=true;
    mContext.sendBroadcast(new Intent(Intent.ACTION_BATTERY_LOW));
    if (SHOW_LOW_BATTERY_WARNING) {
      if (false) {
        Log.d(TAG,""String_Node_Str"" + mPhoneState + ""String_Node_Str""+ mLowBatteryDialog+ ""String_Node_Str""+ mBatteryShowLowOnEndCall);
      }
      if (mPhoneState == TelephonyManager.CALL_STATE_IDLE) {
        showLowBatteryWarning();
      }
 else {
        mBatteryShowLowOnEndCall=true;
      }
    }
  }
 else   if (mBatteryThreshold < BATTERY_THRESHOLD_WARNING) {
    if (mSentLowBatteryBroadcast == true) {
      mSentLowBatteryBroadcast=false;
      mContext.sendBroadcast(new Intent(Intent.ACTION_BATTERY_OKAY));
    }
    if (SHOW_LOW_BATTERY_WARNING) {
      if (mLowBatteryDialog != null) {
        mLowBatteryDialog.dismiss();
        mBatteryShowLowOnEndCall=false;
      }
    }
  }
}","private final void updateBattery(Intent intent){
  mBatteryData.iconId=intent.getIntExtra(""String_Node_Str"",0);
  mBatteryData.iconLevel=intent.getIntExtra(""String_Node_Str"",0);
  mService.updateIcon(mBatteryIcon,mBatteryData,null);
  int plugged=intent.getIntExtra(""String_Node_Str"",0);
  int level=intent.getIntExtra(""String_Node_Str"",-1);
  if (false) {
    Log.d(TAG,""String_Node_Str"" + level + ""String_Node_Str""+ plugged+ ""String_Node_Str""+ mBatteryPlugged+ ""String_Node_Str""+ mBatteryLevel+ ""String_Node_Str""+ mBatteryThreshold+ ""String_Node_Str""+ mBatteryFirst);
  }
  int oldPlugged=mBatteryPlugged;
  int oldThreshold=mBatteryThreshold;
  pickNextBatteryLevel(level);
  mBatteryPlugged=plugged;
  mBatteryLevel=level;
  if (mBatteryFirst) {
    mBatteryFirst=false;
  }
  if (false) {
    Log.d(TAG,""String_Node_Str"" + plugged + ""String_Node_Str""+ oldPlugged+ ""String_Node_Str""+ level+ ""String_Node_Str""+ mBatteryThreshold+ ""String_Node_Str""+ oldThreshold);
  }
  if (plugged == 0 && ((oldPlugged != 0 && level < mBatteryThresholds[BATTERY_THRESHOLD_WARNING]) || (mBatteryThreshold > oldThreshold && mBatteryThreshold > BATTERY_THRESHOLD_WARNING))) {
    mSentLowBatteryBroadcast=true;
    Intent batIntent=new Intent(Intent.ACTION_BATTERY_LOW);
    batIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mContext.sendBroadcast(batIntent);
    if (SHOW_LOW_BATTERY_WARNING) {
      if (false) {
        Log.d(TAG,""String_Node_Str"" + mPhoneState + ""String_Node_Str""+ mLowBatteryDialog+ ""String_Node_Str""+ mBatteryShowLowOnEndCall);
      }
      if (mPhoneState == TelephonyManager.CALL_STATE_IDLE) {
        showLowBatteryWarning();
      }
 else {
        mBatteryShowLowOnEndCall=true;
      }
    }
  }
 else   if (mBatteryThreshold < BATTERY_THRESHOLD_WARNING) {
    if (mSentLowBatteryBroadcast == true) {
      mSentLowBatteryBroadcast=false;
      Intent batIntent=new Intent(Intent.ACTION_BATTERY_OKAY);
      batIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      mContext.sendBroadcast(batIntent);
    }
    if (SHOW_LOW_BATTERY_WARNING) {
      if (mLowBatteryDialog != null) {
        mLowBatteryDialog.dismiss();
        mBatteryShowLowOnEndCall=false;
      }
    }
  }
}",0.9275634995296332
183468,"/** 
 * Converts the byte array provided to a unicode string.
 * @param b the byte array to convert to a string
 * @param includesNull determine if the byte string provided contains theUNICODE null character at the end or not; if it does, it will be removed
 * @return a Unicode string
 * @throws IllegalArgumentException if the byte array has an odd length
 */
public static String convertToUnicode(byte[] b,boolean includesNull){
  if (b == null) {
    return null;
  }
  int arrayLength=b.length;
  if (!((arrayLength % 2) == 0)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  arrayLength=(arrayLength >> 1);
  if (includesNull) {
    arrayLength-=1;
  }
  char[] c=new char[arrayLength];
  for (int i=0; i < arrayLength; i++) {
    int upper=b[2 * i];
    int lower=b[(2 * i) + 1];
    if (upper < 0) {
      upper+=256;
    }
    if (lower < 0) {
      lower+=256;
    }
    c[i]=(char)((upper << 8) | lower);
  }
  return new String(c);
}","/** 
 * Converts the byte array provided to a unicode string.
 * @param b the byte array to convert to a string
 * @param includesNull determine if the byte string provided contains theUNICODE null character at the end or not; if it does, it will be removed
 * @return a Unicode string
 * @throws IllegalArgumentException if the byte array has an odd length
 */
public static String convertToUnicode(byte[] b,boolean includesNull){
  if (b == null || b.length == 0) {
    return null;
  }
  int arrayLength=b.length;
  if (!((arrayLength % 2) == 0)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  arrayLength=(arrayLength >> 1);
  if (includesNull) {
    arrayLength-=1;
  }
  char[] c=new char[arrayLength];
  for (int i=0; i < arrayLength; i++) {
    int upper=b[2 * i];
    int lower=b[(2 * i) + 1];
    if (upper < 0) {
      upper+=256;
    }
    if (lower < 0) {
      lower+=256;
    }
    c[i]=(char)((upper << 8) | lower);
  }
  return new String(c);
}",0.9912596401028276
183469,"public void onCompletion(MediaPlayer arg0){
  String callingApp=mCurrentSpeechItem.mCallingApp;
  ArrayList<String> params=mCurrentSpeechItem.mParams;
  String utteranceId=""String_Node_Str"";
  if (params != null) {
    for (int i=0; i < params.size() - 1; i=i + 2) {
      String param=params.get(i);
      if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
        utteranceId=params.get(i + 1);
      }
    }
  }
  if (utteranceId.length() > 0) {
    dispatchUtteranceCompletedCallback(utteranceId,callingApp);
  }
  mCurrentSpeechItem=null;
  processSpeechQueue();
}","public void onCompletion(MediaPlayer arg0){
  String callingApp=mCurrentSpeechItem.mCallingApp;
  ArrayList<String> params=mCurrentSpeechItem.mParams;
  String utteranceId=""String_Node_Str"";
  if (params != null) {
    for (int i=0; i < params.size() - 1; i=i + 2) {
      String param=params.get(i);
      if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
        utteranceId=params.get(i + 1);
      }
    }
  }
  if (utteranceId.length() > 0) {
    dispatchUtteranceCompletedCallback(utteranceId,callingApp);
  }
  processSpeechQueue();
}",0.9764192139737992
183470,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.setPriority(Thread.MIN_PRIORITY);
      synth.start();
      return;
    }
    if (speechItem.mParams != null) {
      String language=""String_Node_Str"";
      String country=""String_Node_Str"";
      String variant=""String_Node_Str"";
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
    }
    nativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    mCurrentSpeechItem=null;
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.setPriority(Thread.MIN_PRIORITY);
      synth.start();
      return;
    }
    if (speechItem.mParams != null) {
      String language=""String_Node_Str"";
      String country=""String_Node_Str"";
      String variant=""String_Node_Str"";
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
    }
    nativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}",0.922696962212892
183471,"private void silence(final SpeechItem speechItem){
class SilenceThread implements Runnable {
    public void run(){
      String utteranceId=""String_Node_Str"";
      if (speechItem.mParams != null) {
        for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
          String param=speechItem.mParams.get(i);
          if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
      try {
        Thread.sleep(speechItem.mDuration);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        mCurrentSpeechItem=null;
        processSpeechQueue();
      }
    }
  }
  Thread slnc=(new Thread(new SilenceThread()));
  slnc.setPriority(Thread.MIN_PRIORITY);
  slnc.start();
}","private void silence(final SpeechItem speechItem){
class SilenceThread implements Runnable {
    public void run(){
      String utteranceId=""String_Node_Str"";
      if (speechItem.mParams != null) {
        for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
          String param=speechItem.mParams.get(i);
          if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
      try {
        Thread.sleep(speechItem.mDuration);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        processSpeechQueue();
      }
    }
  }
  Thread slnc=(new Thread(new SilenceThread()));
  slnc.setPriority(Thread.MIN_PRIORITY);
  slnc.start();
}",0.9823812066203952
183472,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.setPriority(Thread.MIN_PRIORITY);
          synth.start();
          return;
        }
        if (speechItem.mParams != null) {
          String language=""String_Node_Str"";
          String country=""String_Node_Str"";
          String variant=""String_Node_Str"";
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
                setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
        }
        nativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        mCurrentSpeechItem=null;
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MIN_PRIORITY);
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.setPriority(Thread.MIN_PRIORITY);
          synth.start();
          return;
        }
        if (speechItem.mParams != null) {
          String language=""String_Node_Str"";
          String country=""String_Node_Str"";
          String variant=""String_Node_Str"";
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
                setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
        }
        nativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MIN_PRIORITY);
  synth.start();
}",0.9398907103825136
183473,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.setPriority(Thread.MIN_PRIORITY);
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        if (speechItem.mParams != null) {
          String language=""String_Node_Str"";
          String country=""String_Node_Str"";
          String variant=""String_Node_Str"";
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
                setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
        }
        nativeSynth.speak(speechItem.mText,streamType);
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        mCurrentSpeechItem=null;
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MIN_PRIORITY);
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.setPriority(Thread.MIN_PRIORITY);
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        if (speechItem.mParams != null) {
          String language=""String_Node_Str"";
          String country=""String_Node_Str"";
          String variant=""String_Node_Str"";
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
                setSpeechRate(""String_Node_Str"",Integer.parseInt(speechItem.mParams.get(i + 1)));
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
        }
        nativeSynth.speak(speechItem.mText,streamType);
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MIN_PRIORITY);
  synth.start();
}",0.9459901800327332
183474,"public void onChanged(NumberPicker picker,int oldVal,int newVal){
  mYear=newVal;
  if (mOnDateChangedListener != null) {
    mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
  }
}","public void onChanged(NumberPicker picker,int oldVal,int newVal){
  mYear=newVal;
  adjustMaxDay();
  if (mOnDateChangedListener != null) {
    mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
  }
  updateDaySpinner();
}",0.9107142857142856
183475,"public DatePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.date_picker,this,true);
  mDayPicker=(NumberPicker)findViewById(R.id.day);
  mDayPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  mDayPicker.setSpeed(100);
  mDayPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mDay=newVal;
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
    }
  }
);
  mMonthPicker=(NumberPicker)findViewById(R.id.month);
  mMonthPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  DateFormatSymbols dfs=new DateFormatSymbols();
  mMonthPicker.setRange(1,12,dfs.getShortMonths());
  mMonthPicker.setSpeed(200);
  mMonthPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mMonth=newVal - 1;
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
      updateDaySpinner();
    }
  }
);
  mYearPicker=(NumberPicker)findViewById(R.id.year);
  mYearPicker.setSpeed(100);
  mYearPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mYear=newVal;
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
    }
  }
);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.DatePicker);
  int mStartYear=a.getInt(R.styleable.DatePicker_startYear,DEFAULT_START_YEAR);
  int mEndYear=a.getInt(R.styleable.DatePicker_endYear,DEFAULT_END_YEAR);
  mYearPicker.setRange(mStartYear,mEndYear);
  a.recycle();
  Calendar cal=Calendar.getInstance();
  init(cal.get(Calendar.YEAR),cal.get(Calendar.MONTH),cal.get(Calendar.DAY_OF_MONTH),null);
  reorderPickers();
  if (!isEnabled()) {
    setEnabled(false);
  }
}","public DatePicker(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.date_picker,this,true);
  mDayPicker=(NumberPicker)findViewById(R.id.day);
  mDayPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  mDayPicker.setSpeed(100);
  mDayPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mDay=newVal;
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
    }
  }
);
  mMonthPicker=(NumberPicker)findViewById(R.id.month);
  mMonthPicker.setFormatter(NumberPicker.TWO_DIGIT_FORMATTER);
  DateFormatSymbols dfs=new DateFormatSymbols();
  mMonthPicker.setRange(1,12,dfs.getShortMonths());
  mMonthPicker.setSpeed(200);
  mMonthPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mMonth=newVal - 1;
      adjustMaxDay();
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
      updateDaySpinner();
    }
  }
);
  mYearPicker=(NumberPicker)findViewById(R.id.year);
  mYearPicker.setSpeed(100);
  mYearPicker.setOnChangeListener(new OnChangedListener(){
    public void onChanged(    NumberPicker picker,    int oldVal,    int newVal){
      mYear=newVal;
      adjustMaxDay();
      if (mOnDateChangedListener != null) {
        mOnDateChangedListener.onDateChanged(DatePicker.this,mYear,mMonth,mDay);
      }
      updateDaySpinner();
    }
  }
);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.DatePicker);
  int mStartYear=a.getInt(R.styleable.DatePicker_startYear,DEFAULT_START_YEAR);
  int mEndYear=a.getInt(R.styleable.DatePicker_endYear,DEFAULT_END_YEAR);
  mYearPicker.setRange(mStartYear,mEndYear);
  a.recycle();
  Calendar cal=Calendar.getInstance();
  init(cal.get(Calendar.YEAR),cal.get(Calendar.MONTH),cal.get(Calendar.DAY_OF_MONTH),null);
  reorderPickers();
  if (!isEnabled()) {
    setEnabled(false);
  }
}",0.9841125737630504
183476,"private void validateCurrentView(CharSequence str){
  int val=getSelectedPos(str.toString());
  if ((val >= mStart) && (val <= mEnd)) {
    mPrevious=mCurrent;
    mCurrent=val;
    notifyChange();
  }
  updateView();
}","private void validateCurrentView(CharSequence str){
  int val=getSelectedPos(str.toString());
  if ((val >= mStart) && (val <= mEnd)) {
    if (mCurrent != val) {
      mPrevious=mCurrent;
      mCurrent=val;
      notifyChange();
    }
  }
  updateView();
}",0.859538784067086
183477,"private String makeUriString(){
  StringBuilder builder=new StringBuilder();
  if (scheme != null) {
    builder.append(scheme).append(':');
  }
  appendSspTo(builder);
  if (fragment != null && !fragment.isEmpty()) {
    builder.append('#').append(fragment.getEncoded());
  }
  return builder.toString();
}","private String makeUriString(){
  StringBuilder builder=new StringBuilder();
  if (scheme != null) {
    builder.append(scheme).append(':');
  }
  appendSspTo(builder);
  if (!fragment.isEmpty()) {
    builder.append('#').append(fragment.getEncoded());
  }
  return builder.toString();
}",0.9663299663299664
183478,"/** 
 * Searches the query string for parameter values with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return a list of decoded values
 */
public List<String> getQueryParameters(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  String query=getQuery();
  if (query == null) {
    return Collections.emptyList();
  }
  String encodedKey;
  try {
    encodedKey=URLEncoder.encode(key,DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException e) {
    throw new AssertionError(e);
  }
  query=""String_Node_Str"" + query;
  String prefix=""String_Node_Str"" + encodedKey + ""String_Node_Str"";
  ArrayList<String> values=new ArrayList<String>();
  int start=0;
  int length=query.length();
  while (start < length) {
    start=query.indexOf(prefix,start);
    if (start == -1) {
      break;
    }
    start+=prefix.length();
    int end=query.indexOf('&',start);
    if (end == -1) {
      end=query.length();
    }
    String value=query.substring(start,end);
    values.add(decode(value));
    start=end;
  }
  return Collections.unmodifiableList(values);
}","/** 
 * Searches the query string for parameter values with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return a list of decoded values
 */
public List<String> getQueryParameters(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  String query=getEncodedQuery();
  if (query == null) {
    return Collections.emptyList();
  }
  String encodedKey;
  try {
    encodedKey=URLEncoder.encode(key,DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException e) {
    throw new AssertionError(e);
  }
  query=""String_Node_Str"" + query;
  String prefix=""String_Node_Str"" + encodedKey + ""String_Node_Str"";
  ArrayList<String> values=new ArrayList<String>();
  int start=0;
  int length=query.length();
  while (start < length) {
    start=query.indexOf(prefix,start);
    if (start == -1) {
      break;
    }
    start+=prefix.length();
    int end=query.indexOf('&',start);
    if (end == -1) {
      end=query.length();
    }
    String value=query.substring(start,end);
    values.add(decode(value));
    start=end;
  }
  return Collections.unmodifiableList(values);
}",0.9971853638922396
183479,"/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  String query=getQuery();
  if (query == null) {
    return null;
  }
  String encodedKey;
  try {
    encodedKey=URLEncoder.encode(key,DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException e) {
    throw new AssertionError(e);
  }
  String prefix=encodedKey + ""String_Node_Str"";
  if (query.length() < prefix.length()) {
    return null;
  }
  int start;
  if (query.startsWith(prefix)) {
    start=prefix.length();
  }
 else {
    prefix=""String_Node_Str"" + prefix;
    start=query.indexOf(prefix);
    if (start == -1) {
      return null;
    }
    start+=prefix.length();
  }
  int end=query.indexOf('&',start);
  if (end == -1) {
    end=query.length();
  }
  String value=query.substring(start,end);
  return decode(value);
}","/** 
 * Searches the query string for the first value with the given key.
 * @param key which will be encoded
 * @throws UnsupportedOperationException if this isn't a hierarchical URI
 * @throws NullPointerException if key is null
 * @return the decoded value or null if no parameter is found
 */
public String getQueryParameter(String key){
  if (isOpaque()) {
    throw new UnsupportedOperationException(NOT_HIERARCHICAL);
  }
  String query=getEncodedQuery();
  if (query == null) {
    return null;
  }
  String encodedKey;
  try {
    encodedKey=URLEncoder.encode(key,DEFAULT_ENCODING);
  }
 catch (  UnsupportedEncodingException e) {
    throw new AssertionError(e);
  }
  String prefix=encodedKey + ""String_Node_Str"";
  if (query.length() < prefix.length()) {
    return null;
  }
  int start;
  if (query.startsWith(prefix)) {
    start=prefix.length();
  }
 else {
    prefix=""String_Node_Str"" + prefix;
    start=query.indexOf(prefix);
    if (start == -1) {
      return null;
    }
    start+=prefix.length();
  }
  int end=query.indexOf('&',start);
  if (end == -1) {
    end=query.length();
  }
  String value=query.substring(start,end);
  return decode(value);
}",0.9970174691095016
183480,"private void appendSspTo(StringBuilder builder){
  if (authority != null) {
    String encodedAuthority=authority.getEncoded();
    if (encodedAuthority != null) {
      builder.append(""String_Node_Str"").append(encodedAuthority);
    }
  }
  String encodedPath=path.getEncoded();
  if (encodedPath != null) {
    builder.append(encodedPath);
  }
  if (query != null && !query.isEmpty()) {
    builder.append('?').append(query.getEncoded());
  }
}","private void appendSspTo(StringBuilder builder){
  String encodedAuthority=authority.getEncoded();
  if (encodedAuthority != null) {
    builder.append(""String_Node_Str"").append(encodedAuthority);
  }
  String encodedPath=path.getEncoded();
  if (encodedPath != null) {
    builder.append(encodedPath);
  }
  if (!query.isEmpty()) {
    builder.append('?').append(query.getEncoded());
  }
}",0.5789473684210527
183481,"private HierarchicalUri(String scheme,Part authority,PathPart path,Part query,Part fragment){
  this.scheme=scheme;
  this.authority=authority;
  this.path=path;
  this.query=query;
  this.fragment=fragment;
}","private HierarchicalUri(String scheme,Part authority,PathPart path,Part query,Part fragment){
  this.scheme=scheme;
  this.authority=Part.nonNull(authority);
  this.path=path == null ? PathPart.NULL : path;
  this.query=Part.nonNull(query);
  this.fragment=Part.nonNull(fragment);
}",0.7576374745417516
183482,"private void release(){
  if (mMediaPlayer != null) {
    mMediaPlayer.reset();
    mMediaPlayer.release();
    mMediaPlayer=null;
    mCurrentState=STATE_IDLE;
    mTargetState=STATE_IDLE;
  }
}","private void release(boolean cleartargetstate){
  if (mMediaPlayer != null) {
    mMediaPlayer.reset();
    mMediaPlayer.release();
    mMediaPlayer=null;
    mCurrentState=STATE_IDLE;
    if (cleartargetstate) {
      mTargetState=STATE_IDLE;
    }
  }
}",0.8666666666666667
183483,"public void surfaceDestroyed(SurfaceHolder holder){
  mSurfaceHolder=null;
  if (mMediaController != null)   mMediaController.hide();
  release();
}","public void surfaceDestroyed(SurfaceHolder holder){
  mSurfaceHolder=null;
  if (mMediaController != null)   mMediaController.hide();
  release(true);
}",0.9866666666666668
183484,"private void openVideo(){
  if (mUri == null || mSurfaceHolder == null) {
    return;
  }
  Intent i=new Intent(""String_Node_Str"");
  i.putExtra(""String_Node_Str"",""String_Node_Str"");
  mContext.sendBroadcast(i);
  release();
  try {
    mMediaPlayer=new MediaPlayer();
    mMediaPlayer.setOnPreparedListener(mPreparedListener);
    mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
    mDuration=-1;
    mMediaPlayer.setOnCompletionListener(mCompletionListener);
    mMediaPlayer.setOnErrorListener(mErrorListener);
    mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
    mCurrentBufferPercentage=0;
    mMediaPlayer.setDataSource(mContext,mUri);
    mMediaPlayer.setDisplay(mSurfaceHolder);
    mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
    mMediaPlayer.setScreenOnWhilePlaying(true);
    mMediaPlayer.prepareAsync();
    mCurrentState=STATE_PREPARING;
    mTargetState=STATE_PREPARED;
    attachMediaController();
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + mUri,ex);
    mCurrentState=STATE_ERROR;
    mTargetState=STATE_ERROR;
    return;
  }
catch (  IllegalArgumentException ex) {
    Log.w(TAG,""String_Node_Str"" + mUri,ex);
    mCurrentState=STATE_ERROR;
    mTargetState=STATE_ERROR;
    return;
  }
}","private void openVideo(){
  if (mUri == null || mSurfaceHolder == null) {
    return;
  }
  Intent i=new Intent(""String_Node_Str"");
  i.putExtra(""String_Node_Str"",""String_Node_Str"");
  mContext.sendBroadcast(i);
  release(false);
  try {
    mMediaPlayer=new MediaPlayer();
    mMediaPlayer.setOnPreparedListener(mPreparedListener);
    mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
    mDuration=-1;
    mMediaPlayer.setOnCompletionListener(mCompletionListener);
    mMediaPlayer.setOnErrorListener(mErrorListener);
    mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
    mCurrentBufferPercentage=0;
    mMediaPlayer.setDataSource(mContext,mUri);
    mMediaPlayer.setDisplay(mSurfaceHolder);
    mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
    mMediaPlayer.setScreenOnWhilePlaying(true);
    mMediaPlayer.prepareAsync();
    mCurrentState=STATE_PREPARING;
    attachMediaController();
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + mUri,ex);
    mCurrentState=STATE_ERROR;
    mTargetState=STATE_ERROR;
    return;
  }
catch (  IllegalArgumentException ex) {
    Log.w(TAG,""String_Node_Str"" + mUri,ex);
    mCurrentState=STATE_ERROR;
    mTargetState=STATE_ERROR;
    return;
  }
}",0.985062893081761
183485,"@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
  mRingerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
  setRingerModeInt(getRingerMode());
}","@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
  mRingerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
  setRingerModeInt(getRingerMode(),false);
}",0.9875518672199172
183486,"private void setRingerModeInt(int ringerMode){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
      }
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
}","private void setRingerModeInt(int ringerMode,boolean persist){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
      }
    }
  }
  if (persist) {
    sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
  }
}",0.977752424415288
183487,"/** 
 * @see AudioManager#setRingerMode(int) 
 */
public void setRingerMode(int ringerMode){
  if (ringerMode != mRingerMode) {
    setRingerModeInt(ringerMode);
    broadcastRingerMode();
  }
}","/** 
 * @see AudioManager#setRingerMode(int) 
 */
public void setRingerMode(int ringerMode){
  if (ringerMode != mRingerMode) {
    setRingerModeInt(ringerMode,true);
    broadcastRingerMode();
  }
}",0.9872773536895676
183488,"/** 
 * Receives a query request from a client in a local process, and returns a Cursor. This is called internally by the   {@link ContentResolver}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals: Processes and Threads</a>. <p> Example client call:<p> <pre>// Request a specific record. Cursor managedCursor = managedQuery( Contacts.People.CONTENT_URI.addId(2), projection,    // Which columns to return. null,          // WHERE clause. People.NAME + "" ASC"");   // Sort order.</pre> Example implementation:<p> <pre>// SQLiteQueryBuilder is a helper class that creates the // proper SQL syntax for us. SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder(); // Set the table we're querying. qBuilder.setTables(DATABASE_TABLE_NAME); // If the query ends in a specific record number, we're // being asked for a specific record, so set the // WHERE clause in our query. if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){ qBuilder.appendWhere(""_id="" + uri.getPathLeafId()); } // Make the query. Cursor c = qBuilder.query(mDb, projection, selection, selectionArgs, groupBy, having, sortOrder); c.setNotificationUri(getContext().getContentResolver(), uri); return c;</pre>
 * @param uri The URI to query. This will be the full URI sent by the client;if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value.
 * @param projection The list of columns to put into the cursor. Ifnull all columns are included.
 * @param selection A selection criteria to apply when filtering rows.If null then all rows are included.
 * @param sortOrder How the rows in the cursor should be sorted.If null then the provider is free to define the sort order.
 * @return a Cursor or null.
 */
public abstract Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder);","/** 
 * Receives a query request from a client in a local process, and returns a Cursor. This is called internally by the   {@link ContentResolver}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals: Processes and Threads</a>. <p> Example client call:<p> <pre>// Request a specific record. Cursor managedCursor = managedQuery( ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2), projection,    // Which columns to return. null,          // WHERE clause. null,          // WHERE clause value substitution People.NAME + "" ASC"");   // Sort order.</pre> Example implementation:<p> <pre>// SQLiteQueryBuilder is a helper class that creates the // proper SQL syntax for us. SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder(); // Set the table we're querying. qBuilder.setTables(DATABASE_TABLE_NAME); // If the query ends in a specific record number, we're // being asked for a specific record, so set the // WHERE clause in our query. if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){ qBuilder.appendWhere(""_id="" + uri.getPathLeafId()); } // Make the query. Cursor c = qBuilder.query(mDb, projection, selection, selectionArgs, groupBy, having, sortOrder); c.setNotificationUri(getContext().getContentResolver(), uri); return c;</pre>
 * @param uri The URI to query. This will be the full URI sent by the client;if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value.
 * @param projection The list of columns to put into the cursor. Ifnull all columns are included.
 * @param selection A selection criteria to apply when filtering rows.If null then all rows are included.
 * @param selectionArgs You may include ?s in selection, which will be replaced bythe values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
 * @param sortOrder How the rows in the cursor should be sorted.If null then the provider is free to define the sort order.
 * @return a Cursor or null.
 */
public abstract Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder);",0.934640522875817
183489,"public void onCompletion(MediaPlayer mp){
  if (mMediaController != null) {
    mMediaController.hide();
  }
  if (mOnCompletionListener != null) {
    mOnCompletionListener.onCompletion(mMediaPlayer);
  }
}","public void onCompletion(MediaPlayer mp){
  mIsPlaybackCompleted=true;
  if (mMediaController != null) {
    mMediaController.hide();
  }
  if (mOnCompletionListener != null) {
    mOnCompletionListener.onCompletion(mMediaPlayer);
  }
}",0.9345372460496614
183490,"public void surfaceChanged(SurfaceHolder holder,int format,int w,int h){
  mSurfaceWidth=w;
  mSurfaceHeight=h;
  if (mMediaPlayer != null && mIsPrepared && mVideoWidth == w && mVideoHeight == h) {
    if (mSeekWhenPrepared != 0) {
      mMediaPlayer.seekTo(mSeekWhenPrepared);
      mSeekWhenPrepared=0;
    }
    mMediaPlayer.start();
    if (mMediaController != null) {
      mMediaController.show();
    }
  }
}","public void surfaceChanged(SurfaceHolder holder,int format,int w,int h){
  mSurfaceWidth=w;
  mSurfaceHeight=h;
  if (mMediaPlayer != null && mIsPrepared && mVideoWidth == w && mVideoHeight == h) {
    if (mSeekWhenPrepared != 0) {
      mMediaPlayer.seekTo(mSeekWhenPrepared);
      mSeekWhenPrepared=0;
    }
    if (!mIsPlaybackCompleted) {
      start();
    }
    if (mMediaController != null) {
      mMediaController.show();
    }
  }
}",0.7995337995337995
183491,"public void start(){
  if (mMediaPlayer != null && mIsPrepared) {
    mMediaPlayer.start();
    mStartWhenPrepared=false;
  }
 else {
    mStartWhenPrepared=true;
  }
}","public void start(){
  mIsPlaybackCompleted=false;
  if (mMediaPlayer != null && mIsPrepared) {
    mMediaPlayer.start();
    mStartWhenPrepared=false;
  }
 else {
    mStartWhenPrepared=true;
  }
}",0.918032786885246
183492,"public void onPrepared(MediaPlayer mp){
  mIsPrepared=true;
  if (mOnPreparedListener != null) {
    mOnPreparedListener.onPrepared(mMediaPlayer);
  }
  if (mMediaController != null) {
    mMediaController.setEnabled(true);
  }
  mVideoWidth=mp.getVideoWidth();
  mVideoHeight=mp.getVideoHeight();
  if (mVideoWidth != 0 && mVideoHeight != 0) {
    getHolder().setFixedSize(mVideoWidth,mVideoHeight);
    if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
      if (mSeekWhenPrepared != 0) {
        mMediaPlayer.seekTo(mSeekWhenPrepared);
        mSeekWhenPrepared=0;
      }
      if (mStartWhenPrepared) {
        mMediaPlayer.start();
        mStartWhenPrepared=false;
        if (mMediaController != null) {
          mMediaController.show();
        }
      }
 else       if (!isPlaying() && (mSeekWhenPrepared != 0 || getCurrentPosition() > 0)) {
        if (mMediaController != null) {
          mMediaController.show(0);
        }
      }
    }
  }
 else {
    if (mSeekWhenPrepared != 0) {
      mMediaPlayer.seekTo(mSeekWhenPrepared);
      mSeekWhenPrepared=0;
    }
    if (mStartWhenPrepared) {
      mMediaPlayer.start();
      mStartWhenPrepared=false;
    }
  }
}","public void onPrepared(MediaPlayer mp){
  mIsPrepared=true;
  if (mOnPreparedListener != null) {
    mOnPreparedListener.onPrepared(mMediaPlayer);
  }
  if (mMediaController != null) {
    mMediaController.setEnabled(true);
  }
  mVideoWidth=mp.getVideoWidth();
  mVideoHeight=mp.getVideoHeight();
  if (mVideoWidth != 0 && mVideoHeight != 0) {
    getHolder().setFixedSize(mVideoWidth,mVideoHeight);
    if (mSurfaceWidth == mVideoWidth && mSurfaceHeight == mVideoHeight) {
      if (mSeekWhenPrepared != 0) {
        mMediaPlayer.seekTo(mSeekWhenPrepared);
        mSeekWhenPrepared=0;
      }
      if (mStartWhenPrepared) {
        start();
        mStartWhenPrepared=false;
        if (mMediaController != null) {
          mMediaController.show();
        }
      }
 else       if (!isPlaying() && (mSeekWhenPrepared != 0 || getCurrentPosition() > 0)) {
        if (mMediaController != null) {
          mMediaController.show(0);
        }
      }
    }
  }
 else {
    if (mSeekWhenPrepared != 0) {
      mMediaPlayer.seekTo(mSeekWhenPrepared);
      mSeekWhenPrepared=0;
    }
    if (mStartWhenPrepared) {
      start();
      mStartWhenPrepared=false;
    }
  }
}",0.945193929173693
183493,"private void refreshBatteryDisplay(){
  if (!mShowingBatteryInfo || !mSimOk) {
    mBatteryInfoGroup.setVisibility(View.GONE);
    mBatteryInfoSpacer.setVisibility(View.GONE);
    return;
  }
  mBatteryInfoGroup.setVisibility(View.VISIBLE);
  mBatteryInfoSpacer.setVisibility(View.VISIBLE);
  if (mPluggedIn) {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_charging);
    mBatteryInfoText.setText(getContext().getString(R.string.lockscreen_plugged_in,mBatteryLevel));
  }
 else {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_low_battery);
    mBatteryInfoText.setText(R.string.lockscreen_low_battery);
  }
}","private void refreshBatteryDisplay(){
  if (!mShowingBatteryInfo || !mSimOk) {
    mBatteryInfoGroup.setVisibility(View.GONE);
    mBatteryInfoSpacer.setVisibility(View.GONE);
    return;
  }
  mBatteryInfoGroup.setVisibility(View.VISIBLE);
  mBatteryInfoSpacer.setVisibility(View.VISIBLE);
  if (mPluggedIn) {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_charging);
    if (mBatteryLevel >= 100) {
      mBatteryInfoText.setText(R.string.lockscreen_charged);
    }
 else {
      mBatteryInfoText.setText(getContext().getString(R.string.lockscreen_plugged_in,mBatteryLevel));
    }
  }
 else {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_low_battery);
    mBatteryInfoText.setText(R.string.lockscreen_low_battery);
  }
}",0.9175627240143368
183494,"private void refreshBatteryDisplay(){
  if (!mShowingBatteryInfo || !mSimOk) {
    mBatteryInfoGroup.setVisibility(View.GONE);
    mBatteryInfoSpacer.setVisibility(View.GONE);
    return;
  }
  mBatteryInfoGroup.setVisibility(View.VISIBLE);
  mBatteryInfoSpacer.setVisibility(View.VISIBLE);
  if (mPluggedIn) {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_charging);
    mBatteryInfoText.setText(getContext().getString(R.string.lockscreen_plugged_in,mBatteryLevel));
  }
 else {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_low_battery);
    mBatteryInfoText.setText(R.string.lockscreen_low_battery);
  }
}","private void refreshBatteryDisplay(){
  if (!mShowingBatteryInfo || !mSimOk) {
    mBatteryInfoGroup.setVisibility(View.GONE);
    mBatteryInfoSpacer.setVisibility(View.GONE);
    return;
  }
  mBatteryInfoGroup.setVisibility(View.VISIBLE);
  mBatteryInfoSpacer.setVisibility(View.VISIBLE);
  if (mPluggedIn) {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_charging);
    if (mBatteryLevel >= 100) {
      mBatteryInfoText.setText(R.string.lockscreen_charged);
    }
 else {
      mBatteryInfoText.setText(getContext().getString(R.string.lockscreen_plugged_in,mBatteryLevel));
    }
  }
 else {
    mBatteryInfoIcon.setImageResource(R.drawable.ic_lock_idle_low_battery);
    mBatteryInfoText.setText(R.string.lockscreen_low_battery);
  }
}",0.9175627240143368
183495,"private void setDefaultSettings(){
  setLanguage(this.getDefaultLanguage(),getDefaultLanguage(),getDefaultLocVariant());
  setSpeechRate(getDefaultRate());
}","private void setDefaultSettings(){
  setLanguage(this.getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
  setSpeechRate(getDefaultRate());
}",0.9584664536741214
183496,"/** 
 * Returns a constant indicating the type of activity on a data connection (cellular).
 * @see #DATA_ACTIVITY_NONE
 * @see #DATA_ACTIVITY_IN
 * @see #DATA_ACTIVITY_OUT
 * @see #DATA_ACTIVITY_INOUT
 * @see #DATA_ACTIVITY_DORMANT
 */
public int getDataActivity(){
  try {
    return getITelephony().getDataActivity();
  }
 catch (  RemoteException ex) {
    return DATA_ACTIVITY_NONE;
  }
}","/** 
 * Returns a constant indicating the type of activity on a data connection (cellular).
 * @see #DATA_ACTIVITY_NONE
 * @see #DATA_ACTIVITY_IN
 * @see #DATA_ACTIVITY_OUT
 * @see #DATA_ACTIVITY_INOUT
 * @see #DATA_ACTIVITY_DORMANT
 */
public int getDataActivity(){
  try {
    return getITelephony().getDataActivity();
  }
 catch (  RemoteException ex) {
    return DATA_ACTIVITY_NONE;
  }
catch (  NullPointerException ex) {
    return DATA_ACTIVITY_NONE;
  }
}",0.9171528588098016
183497,"/** 
 * Returns a constant indicating the call state (cellular) on the device.
 */
public int getCallState(){
  try {
    return getITelephony().getCallState();
  }
 catch (  RemoteException ex) {
    return CALL_STATE_IDLE;
  }
}","/** 
 * Returns a constant indicating the call state (cellular) on the device.
 */
public int getCallState(){
  try {
    return getITelephony().getCallState();
  }
 catch (  RemoteException ex) {
    return CALL_STATE_IDLE;
  }
catch (  NullPointerException ex) {
    return CALL_STATE_IDLE;
  }
}",0.8674242424242424
183498,"private void setDefaultSettings(){
  setLanguage(this.getDefaultLanguage(),getDefaultLanguage(),getDefaultLocVariant());
  setSpeechRate(getDefaultRate());
}","private void setDefaultSettings(){
  setLanguage(this.getDefaultLanguage(),getDefaultCountry(),getDefaultLocVariant());
  setSpeechRate(getDefaultRate());
}",0.9584664536741214
183499,"public void onChildViewRemoved(View p,View child){
  if (child == this) {
    if (inEditingMode()) {
      clearTextEntry();
    }
  }
}","public void onChildViewRemoved(View p,View child){
  if (child == this) {
    clearTextEntry();
  }
}",0.8523206751054853
183500,"@Override public boolean performLongClick(){
  if (inEditingMode()) {
    return mWebTextView.performLongClick();
  }
 else {
    return super.performLongClick();
  }
}","@Override public boolean performLongClick(){
  if (mNativeClass != 0 && nativeCursorIsTextInput()) {
    mWebViewCore.sendMessage(EventHub.CLICK,nativeCursorFramePointer(),nativeCursorNodePointer());
    rebuildWebTextView();
  }
  if (inEditingMode()) {
    return mWebTextView.performLongClick();
  }
 else {
    return super.performLongClick();
  }
}",0.6449136276391555
183501,"@Override public boolean onTrackballEvent(MotionEvent ev){
  long time=ev.getEventTime();
  if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
    if (ev.getY() > 0)     pageDown(true);
    if (ev.getY() < 0)     pageUp(true);
    return true;
  }
  if (ev.getAction() == MotionEvent.ACTION_DOWN) {
    mPrivateHandler.removeMessages(SWITCH_TO_CLICK);
    mTrackballDown=true;
    if (mNativeClass != 0) {
      nativeRecordButtons(hasFocus() && hasWindowFocus(),true,true);
    }
    if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
      nativeSelectBestAt(mLastCursorBounds);
    }
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time+ ""String_Node_Str""+ mLastCursorTime);
    }
    if (isInTouchMode())     requestFocusFromTouch();
    return false;
  }
  if (ev.getAction() == MotionEvent.ACTION_UP) {
    mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
    mTrackballDown=false;
    mTrackballUpTime=time;
    if (mShiftIsPressed) {
      if (mExtendSelection) {
        commitCopy();
      }
 else {
        mExtendSelection=true;
      }
    }
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time);
    }
    return false;
  }
  if (mMapTrackballToArrowKeys && mShiftIsPressed == false) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return false;
  }
  if (mTouchMode == TOUCH_DOUBLECLICK_MODE) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  if (mTrackballDown) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  switchOutDrawHistory();
  if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + time + ""String_Node_Str""+ mTrackballLastTime);
    }
    mTrackballFirstTime=time;
    mTrackballXMove=mTrackballYMove=0;
  }
  mTrackballLastTime=time;
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time);
  }
  mTrackballRemainsX+=ev.getX();
  mTrackballRemainsY+=ev.getY();
  doTrackball(time);
  return true;
}","@Override public boolean onTrackballEvent(MotionEvent ev){
  long time=ev.getEventTime();
  if ((ev.getMetaState() & KeyEvent.META_ALT_ON) != 0) {
    if (ev.getY() > 0)     pageDown(true);
    if (ev.getY() < 0)     pageUp(true);
    return true;
  }
  if (ev.getAction() == MotionEvent.ACTION_DOWN) {
    mPrivateHandler.removeMessages(SWITCH_TO_CLICK);
    mTrackballDown=true;
    if (mNativeClass == 0) {
      return false;
    }
    nativeRecordButtons(hasFocus() && hasWindowFocus(),true,true);
    if (time - mLastCursorTime <= TRACKBALL_TIMEOUT && !mLastCursorBounds.equals(nativeGetCursorRingBounds())) {
      nativeSelectBestAt(mLastCursorBounds);
    }
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time+ ""String_Node_Str""+ mLastCursorTime);
    }
    if (isInTouchMode())     requestFocusFromTouch();
    return false;
  }
  if (ev.getAction() == MotionEvent.ACTION_UP) {
    mPrivateHandler.removeMessages(LONG_PRESS_CENTER);
    mTrackballDown=false;
    mTrackballUpTime=time;
    if (mShiftIsPressed) {
      if (mExtendSelection) {
        commitCopy();
      }
 else {
        mExtendSelection=true;
      }
    }
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time);
    }
    return false;
  }
  if (mMapTrackballToArrowKeys && mShiftIsPressed == false) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return false;
  }
  if (mTouchMode == TOUCH_DOUBLECLICK_MODE) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  if (mTrackballDown) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  if (time - mTrackballUpTime < TRACKBALL_TIMEOUT) {
    if (DebugFlags.WEB_VIEW)     Log.v(LOGTAG,""String_Node_Str"");
    return true;
  }
  switchOutDrawHistory();
  if (time - mTrackballLastTime > TRACKBALL_TIMEOUT) {
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + time + ""String_Node_Str""+ mTrackballLastTime);
    }
    mTrackballFirstTime=time;
    mTrackballXMove=mTrackballYMove=0;
  }
  mTrackballLastTime=time;
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,""String_Node_Str"" + ev + ""String_Node_Str""+ time);
  }
  mTrackballRemainsX+=ev.getX();
  mTrackballRemainsY+=ev.getY();
  doTrackball(time);
  return true;
}",0.99317697228145
183502,"private static byte[] numberToCalledPartyBCDHelper(byte[] ret,int offset,String number){
  if (hasPlus(number)) {
    number=number.replaceAll(""String_Node_Str"",""String_Node_Str"");
    ret[offset]=(byte)TOA_International;
  }
 else {
    ret[offset]=(byte)TOA_Unknown;
  }
  int size=number.length();
  int curChar=0;
  int countFullBytes=ret.length - offset - 1- ((size - curChar) & 1);
  for (int i=1; i < 1 + countFullBytes; i++) {
    ret[offset + i]=(byte)((charToBCD(number.charAt(curChar++))) | (charToBCD(number.charAt(curChar++))) << 4);
  }
  if (countFullBytes + offset < ret.length - 1) {
    ret[ret.length - 1]=(byte)(charToBCD(number.charAt(curChar)) | (0xf << 4));
  }
  return ret;
}","/** 
 * If includeLength is true, prepend a one-byte length value to the return array.
 */
private static byte[] numberToCalledPartyBCDHelper(String number,boolean includeLength){
  int numberLenReal=number.length();
  int numberLenEffective=numberLenReal;
  boolean hasPlus=number.indexOf('+') != -1;
  if (hasPlus)   numberLenEffective--;
  if (numberLenEffective == 0)   return null;
  int resultLen=(numberLenEffective + 1) / 2;
  int extraBytes=1;
  if (includeLength)   extraBytes++;
  resultLen+=extraBytes;
  byte[] result=new byte[resultLen];
  int digitCount=0;
  for (int i=0; i < numberLenReal; i++) {
    char c=number.charAt(i);
    if (c == '+')     continue;
    int shift=((digitCount & 0x01) == 1) ? 4 : 0;
    result[extraBytes + (digitCount >> 1)]|=(byte)((charToBCD(c) & 0x0F) << shift);
    digitCount++;
  }
  if ((digitCount & 0x01) == 1)   result[extraBytes + (digitCount >> 1)]|=0xF0;
  int offset=0;
  if (includeLength)   result[offset++]=(byte)(resultLen - 1);
  result[offset]=(byte)(hasPlus ? TOA_International : TOA_Unknown);
  return result;
}",0.1137387387387387
183503,"/** 
 * Note: calls extractNetworkPortion(), so do not use for SIM EF[ADN] style records Exceptions thrown if extractNetworkPortion(s).length() == 0
 */
public static byte[] networkPortionToCalledPartyBCD(String s){
  return numberToCalledPartyBCD(extractNetworkPortion(s));
}","/** 
 * Note: calls extractNetworkPortion(), so do not use for SIM EF[ADN] style records Returns null if network portion is empty.
 */
public static byte[] networkPortionToCalledPartyBCD(String s){
  String networkPortion=extractNetworkPortion(s);
  return numberToCalledPartyBCDHelper(networkPortion,false);
}",0.6655290102389079
183504,"/** 
 * Convert a dialing number to BCD byte array
 * @param number dialing number stringif the dialing number starts with '+', set to internationl TOA
 * @return BCD byte array
 */
public static byte[] numberToCalledPartyBCD(String number){
  int size=(hasPlus(number) ? number.length() - 1 : number.length());
  byte[] ret=new byte[(size + 1) / 2 + 1];
  return numberToCalledPartyBCDHelper(ret,0,number);
}","/** 
 * Convert a dialing number to BCD byte array
 * @param number dialing number stringif the dialing number starts with '+', set to internationl TOA
 * @return BCD byte array
 */
public static byte[] numberToCalledPartyBCD(String number){
  return numberToCalledPartyBCDHelper(number,false);
}",0.7063829787234043
183505,"/** 
 * Same as   {@link #networkPortionToCalledPartyBCD}, but includes a one-byte length prefix.
 */
public static byte[] networkPortionToCalledPartyBCDWithLength(String s){
  return numberToCalledPartyBCDWithLength(extractNetworkPortion(s));
}","/** 
 * Same as   {@link #networkPortionToCalledPartyBCD}, but includes a one-byte length prefix.
 */
public static byte[] networkPortionToCalledPartyBCDWithLength(String s){
  String networkPortion=extractNetworkPortion(s);
  return numberToCalledPartyBCDHelper(networkPortion,true);
}",0.6854990583804144
183506,"@SmallTest public void testA() throws Exception {
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  byte[] b=new byte[20];
  b[0]=(byte)0x81;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x91;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  byte[] bRet=PhoneNumberUtils.networkPortionToCalledPartyBCD(""String_Node_Str"");
  assertEquals(7,bRet.length);
  for (int i=0; i < 7; i++) {
    assertEquals(b[i],bRet[i]);
  }
  bRet=PhoneNumberUtils.networkPortionToCalledPartyBCD(""String_Node_Str"");
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(bRet,0,bRet.length));
  b[0]=(byte)0x81;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x91;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2B;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x91;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x81;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,4));
  b[0]=(byte)0x91;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,4));
  b[0]=(byte)0x81;
  b[1]=(byte)0x9A;
  b[2]=(byte)0xA9;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x91;
  b[1]=(byte)0x9A;
  b[2]=(byte)0xA9;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x81;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0x1A;
  b[4]=(byte)0x07;
  b[5]=(byte)0x50;
  b[6]=(byte)0x55;
  b[7]=(byte)0x00;
  b[8]=(byte)0x02;
  b[9]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,10));
  b[0]=(byte)0x91;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0x1A;
  b[4]=(byte)0x07;
  b[5]=(byte)0x50;
  b[6]=(byte)0x55;
  b[7]=(byte)0x00;
  b[8]=(byte)0x02;
  b[9]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,10));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xA1;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x91;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  assertNull(PhoneNumberUtils.extractNetworkPortion(null));
  assertNull(PhoneNumberUtils.extractPostDialPortion(null));
  assertTrue(PhoneNumberUtils.compare(null,null));
  assertFalse(PhoneNumberUtils.compare(null,""String_Node_Str""));
  assertFalse(PhoneNumberUtils.compare(""String_Node_Str"",null));
  assertNull(PhoneNumberUtils.toCallerIDMinMatch(null));
  assertNull(PhoneNumberUtils.getStrippedReversed(null));
  assertNull(PhoneNumberUtils.stringFromStringAndTOA(null,1));
}","@SmallTest public void testA() throws Exception {
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.extractNetworkPortion(""String_Node_Str""));
  byte[] b=new byte[20];
  b[0]=(byte)0x81;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x91;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  byte[] bRet=PhoneNumberUtils.networkPortionToCalledPartyBCD(""String_Node_Str"");
  assertEquals(7,bRet.length);
  for (int i=0; i < 7; i++) {
    assertEquals(b[i],bRet[i]);
  }
  bRet=PhoneNumberUtils.networkPortionToCalledPartyBCDWithLength(""String_Node_Str"");
  assertEquals(8,bRet.length);
  assertEquals(bRet[0],7);
  for (int i=1; i < 8; i++) {
    assertEquals(b[i - 1],bRet[i]);
  }
  bRet=PhoneNumberUtils.networkPortionToCalledPartyBCD(""String_Node_Str"");
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(bRet,0,bRet.length));
  b[0]=(byte)0x81;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x91;
  b[1]=(byte)0x71;
  b[2]=(byte)0x00;
  b[3]=(byte)0x55;
  b[4]=(byte)0x05;
  b[5]=(byte)0x20;
  b[6]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,7));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2B;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x91;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,3));
  b[0]=(byte)0x81;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,4));
  b[0]=(byte)0x91;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,4));
  b[0]=(byte)0x81;
  b[1]=(byte)0x9A;
  b[2]=(byte)0xA9;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x91;
  b[1]=(byte)0x9A;
  b[2]=(byte)0xA9;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xB0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x81;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0x1A;
  b[4]=(byte)0x07;
  b[5]=(byte)0x50;
  b[6]=(byte)0x55;
  b[7]=(byte)0x00;
  b[8]=(byte)0x02;
  b[9]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,10));
  b[0]=(byte)0x91;
  b[1]=(byte)0xAA;
  b[2]=(byte)0x12;
  b[3]=(byte)0x1A;
  b[4]=(byte)0x07;
  b[5]=(byte)0x50;
  b[6]=(byte)0x55;
  b[7]=(byte)0x00;
  b[8]=(byte)0x02;
  b[9]=(byte)0xFB;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,10));
  b[0]=(byte)0x81;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xA1;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  b[0]=(byte)0x91;
  b[1]=(byte)0x2A;
  b[2]=(byte)0xB1;
  b[3]=(byte)0x71;
  b[4]=(byte)0x00;
  b[5]=(byte)0x55;
  b[6]=(byte)0x05;
  b[7]=(byte)0x20;
  b[8]=(byte)0xF0;
  assertEquals(""String_Node_Str"",PhoneNumberUtils.calledPartyBCDToString(b,0,9));
  assertNull(PhoneNumberUtils.extractNetworkPortion(null));
  assertNull(PhoneNumberUtils.extractPostDialPortion(null));
  assertTrue(PhoneNumberUtils.compare(null,null));
  assertFalse(PhoneNumberUtils.compare(null,""String_Node_Str""));
  assertFalse(PhoneNumberUtils.compare(""String_Node_Str"",null));
  assertNull(PhoneNumberUtils.toCallerIDMinMatch(null));
  assertNull(PhoneNumberUtils.getStrippedReversed(null));
  assertNull(PhoneNumberUtils.stringFromStringAndTOA(null,1));
}",0.9790868924889544
183507,"/** 
 * Inject a pointer (touch) event into the UI.
 * @param ev A motion event describing the pointer (touch) action.  (As noted in{@link MotionEvent#obtain(long,long,int,float,float,int)}, be sure to use  {@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectPointerEvent(MotionEvent ev,boolean sync){
  int result=dispatchPointer(null,ev,Binder.getCallingPid(),Binder.getCallingUid());
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true);
  }
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}","/** 
 * Inject a pointer (touch) event into the UI.
 * @param ev A motion event describing the pointer (touch) action.  (As noted in{@link MotionEvent#obtain(long,long,int,float,float,int)}, be sure to use  {@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectPointerEvent(MotionEvent ev,boolean sync){
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  final long ident=Binder.clearCallingIdentity();
  final int result=dispatchPointer(null,ev,pid,uid);
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true,pid,uid);
  }
  Binder.restoreCallingIdentity(ident);
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}",0.8523862375138734
183508,"/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchKey(KeyEvent event,int pid,int uid){
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + event);
  Object focusObj=mKeyWaiter.waitForNextEventTarget(event,null,null,false,false);
  if (focusObj == null) {
    Log.w(TAG,""String_Node_Str"" + event);
    return INJECT_FAILED;
  }
  if (focusObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    return INJECT_SUCCEEDED;
  }
  WindowState focus=(WindowState)focusObj;
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ event);
  if (uid != 0 && uid != focus.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ focus.mSession.mUid);
      return INJECT_NO_PERMISSION;
    }
  }
synchronized (mWindowMap) {
    mKeyWaiter.bindTargetWindowLocked(focus);
  }
  mKeyWaiter.recordDispatchState(event,focus);
  try {
    if (DEBUG_INPUT || DEBUG_FOCUS) {
      Log.v(TAG,""String_Node_Str"" + event.getKeyCode() + ""String_Node_Str""+ focus);
    }
    focus.mClient.dispatchKey(event);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + focus);
    try {
      removeWindow(focus.mSession,focus.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}","/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchKey(KeyEvent event,int pid,int uid){
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + event);
  Object focusObj=mKeyWaiter.waitForNextEventTarget(event,null,null,false,false,pid,uid);
  if (focusObj == null) {
    Log.w(TAG,""String_Node_Str"" + event);
    return INJECT_FAILED;
  }
  if (focusObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    return INJECT_SUCCEEDED;
  }
  WindowState focus=(WindowState)focusObj;
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ event);
  if (uid != 0 && uid != focus.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ focus.mSession.mUid);
      return INJECT_NO_PERMISSION;
    }
  }
synchronized (mWindowMap) {
    mKeyWaiter.bindTargetWindowLocked(focus);
  }
  mKeyWaiter.recordDispatchState(event,focus);
  try {
    if (DEBUG_INPUT || DEBUG_FOCUS) {
      Log.v(TAG,""String_Node_Str"" + event.getKeyCode() + ""String_Node_Str""+ focus);
    }
    focus.mClient.dispatchKey(event);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + focus);
    try {
      removeWindow(focus.mSession,focus.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}",0.9973856209150328
183509,"Object findTargetWindow(KeyEvent nextKey,QueuedEvent qev,MotionEvent nextMotion,boolean isPointerEvent){
  mOutsideTouchTargets=null;
  if (nextKey != null) {
    final int keycode=nextKey.getKeyCode();
    final int repeatCount=nextKey.getRepeatCount();
    final boolean down=nextKey.getAction() != KeyEvent.ACTION_UP;
    boolean dispatch=mKeyWaiter.checkShouldDispatchKey(keycode);
    if (!dispatch) {
      mPolicy.interceptKeyTi(null,keycode,nextKey.getMetaState(),down,repeatCount);
      Log.w(TAG,""String_Node_Str"" + nextKey);
      return SKIP_TARGET_TOKEN;
    }
    WindowState focus=null;
synchronized (mWindowMap) {
      focus=getFocusedWindowLocked();
    }
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    if (mPolicy.interceptKeyTi(focus,keycode,nextKey.getMetaState(),down,repeatCount)) {
      return CONSUMED_EVENT_TOKEN;
    }
    return focus;
  }
 else   if (!isPointerEvent) {
    boolean dispatch=mKeyWaiter.checkShouldDispatchKey(-1);
    if (!dispatch) {
      Log.w(TAG,""String_Node_Str"" + nextMotion);
      return SKIP_TARGET_TOKEN;
    }
    WindowState focus=null;
synchronized (mWindowMap) {
      focus=getFocusedWindowLocked();
    }
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    return focus;
  }
  if (nextMotion == null) {
    return SKIP_TARGET_TOKEN;
  }
  boolean dispatch=mKeyWaiter.checkShouldDispatchKey(KeyEvent.KEYCODE_UNKNOWN);
  if (!dispatch) {
    Log.w(TAG,""String_Node_Str"" + nextMotion);
    return SKIP_TARGET_TOKEN;
  }
  int action=nextMotion.getAction();
  final float xf=nextMotion.getX();
  final float yf=nextMotion.getY();
  final long eventTime=nextMotion.getEventTime();
  final boolean screenWasOff=qev != null && (qev.flags & WindowManagerPolicy.FLAG_BRIGHT_HERE) != 0;
  WindowState target=null;
synchronized (mWindowMap) {
synchronized (this) {
      if (action == MotionEvent.ACTION_DOWN) {
        if (mMotionTarget != null) {
          Log.w(TAG,""String_Node_Str"" + mMotionTarget);
          mMotionTarget=null;
        }
        final int x=(int)xf;
        final int y=(int)yf;
        final ArrayList windows=mWindows;
        final int N=windows.size();
        WindowState topErrWindow=null;
        final Rect tmpRect=mTempRect;
        for (int i=N - 1; i >= 0; i--) {
          WindowState child=(WindowState)windows.get(i);
          final int flags=child.mAttrs.flags;
          if ((flags & WindowManager.LayoutParams.FLAG_SYSTEM_ERROR) != 0) {
            if (topErrWindow == null) {
              topErrWindow=child;
            }
          }
          if (!child.isVisibleLw()) {
            continue;
          }
          if ((flags & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0) {
            if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
              child.mNextOutsideTouch=mOutsideTouchTargets;
              mOutsideTouchTargets=child;
            }
            continue;
          }
          tmpRect.set(child.mFrame);
          if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_CONTENT) {
            tmpRect.left+=child.mGivenContentInsets.left;
            tmpRect.top+=child.mGivenContentInsets.top;
            tmpRect.right-=child.mGivenContentInsets.right;
            tmpRect.bottom-=child.mGivenContentInsets.bottom;
          }
 else           if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_VISIBLE) {
            tmpRect.left+=child.mGivenVisibleInsets.left;
            tmpRect.top+=child.mGivenVisibleInsets.top;
            tmpRect.right-=child.mGivenVisibleInsets.right;
            tmpRect.bottom-=child.mGivenVisibleInsets.bottom;
          }
          final int touchFlags=flags & (WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);
          if (tmpRect.contains(x,y) || touchFlags == 0) {
            if (!screenWasOff || (flags & WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING) != 0) {
              mMotionTarget=child;
            }
 else {
              mMotionTarget=null;
            }
            break;
          }
          if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
            child.mNextOutsideTouch=mOutsideTouchTargets;
            mOutsideTouchTargets=child;
          }
        }
        if (topErrWindow != null && mMotionTarget != topErrWindow) {
          mMotionTarget=null;
        }
      }
      target=mMotionTarget;
    }
  }
  wakeupIfNeeded(target,eventType(nextMotion));
  return target != null ? target : SKIP_TARGET_TOKEN;
}","Object findTargetWindow(KeyEvent nextKey,QueuedEvent qev,MotionEvent nextMotion,boolean isPointerEvent,int callingPid,int callingUid){
  mOutsideTouchTargets=null;
  if (nextKey != null) {
    final int keycode=nextKey.getKeyCode();
    final int repeatCount=nextKey.getRepeatCount();
    final boolean down=nextKey.getAction() != KeyEvent.ACTION_UP;
    boolean dispatch=mKeyWaiter.checkShouldDispatchKey(keycode);
    if (!dispatch) {
      if (callingUid == 0 || mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,callingPid,callingUid) == PackageManager.PERMISSION_GRANTED) {
        mPolicy.interceptKeyTi(null,keycode,nextKey.getMetaState(),down,repeatCount);
      }
      Log.w(TAG,""String_Node_Str"" + nextKey);
      return SKIP_TARGET_TOKEN;
    }
    WindowState focus=null;
synchronized (mWindowMap) {
      focus=getFocusedWindowLocked();
    }
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    if (callingUid == 0 || (focus != null && callingUid == focus.mSession.mUid) || mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,callingPid,callingUid) == PackageManager.PERMISSION_GRANTED) {
      if (mPolicy.interceptKeyTi(focus,keycode,nextKey.getMetaState(),down,repeatCount)) {
        return CONSUMED_EVENT_TOKEN;
      }
    }
    return focus;
  }
 else   if (!isPointerEvent) {
    boolean dispatch=mKeyWaiter.checkShouldDispatchKey(-1);
    if (!dispatch) {
      Log.w(TAG,""String_Node_Str"" + nextMotion);
      return SKIP_TARGET_TOKEN;
    }
    WindowState focus=null;
synchronized (mWindowMap) {
      focus=getFocusedWindowLocked();
    }
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    return focus;
  }
  if (nextMotion == null) {
    return SKIP_TARGET_TOKEN;
  }
  boolean dispatch=mKeyWaiter.checkShouldDispatchKey(KeyEvent.KEYCODE_UNKNOWN);
  if (!dispatch) {
    Log.w(TAG,""String_Node_Str"" + nextMotion);
    return SKIP_TARGET_TOKEN;
  }
  int action=nextMotion.getAction();
  final float xf=nextMotion.getX();
  final float yf=nextMotion.getY();
  final long eventTime=nextMotion.getEventTime();
  final boolean screenWasOff=qev != null && (qev.flags & WindowManagerPolicy.FLAG_BRIGHT_HERE) != 0;
  WindowState target=null;
synchronized (mWindowMap) {
synchronized (this) {
      if (action == MotionEvent.ACTION_DOWN) {
        if (mMotionTarget != null) {
          Log.w(TAG,""String_Node_Str"" + mMotionTarget);
          mMotionTarget=null;
        }
        final int x=(int)xf;
        final int y=(int)yf;
        final ArrayList windows=mWindows;
        final int N=windows.size();
        WindowState topErrWindow=null;
        final Rect tmpRect=mTempRect;
        for (int i=N - 1; i >= 0; i--) {
          WindowState child=(WindowState)windows.get(i);
          final int flags=child.mAttrs.flags;
          if ((flags & WindowManager.LayoutParams.FLAG_SYSTEM_ERROR) != 0) {
            if (topErrWindow == null) {
              topErrWindow=child;
            }
          }
          if (!child.isVisibleLw()) {
            continue;
          }
          if ((flags & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0) {
            if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
              child.mNextOutsideTouch=mOutsideTouchTargets;
              mOutsideTouchTargets=child;
            }
            continue;
          }
          tmpRect.set(child.mFrame);
          if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_CONTENT) {
            tmpRect.left+=child.mGivenContentInsets.left;
            tmpRect.top+=child.mGivenContentInsets.top;
            tmpRect.right-=child.mGivenContentInsets.right;
            tmpRect.bottom-=child.mGivenContentInsets.bottom;
          }
 else           if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_VISIBLE) {
            tmpRect.left+=child.mGivenVisibleInsets.left;
            tmpRect.top+=child.mGivenVisibleInsets.top;
            tmpRect.right-=child.mGivenVisibleInsets.right;
            tmpRect.bottom-=child.mGivenVisibleInsets.bottom;
          }
          final int touchFlags=flags & (WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);
          if (tmpRect.contains(x,y) || touchFlags == 0) {
            if (!screenWasOff || (flags & WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING) != 0) {
              mMotionTarget=child;
            }
 else {
              mMotionTarget=null;
            }
            break;
          }
          if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
            child.mNextOutsideTouch=mOutsideTouchTargets;
            mOutsideTouchTargets=child;
          }
        }
        if (topErrWindow != null && mMotionTarget != topErrWindow) {
          mMotionTarget=null;
        }
      }
      target=mMotionTarget;
    }
  }
  wakeupIfNeeded(target,eventType(nextMotion));
  return target != null ? target : SKIP_TARGET_TOKEN;
}",0.9558425328056654
183510,"/** 
 * Wait for the last event dispatch to complete, then find the next target that should receive the given event and wait for that one to be ready to receive it.
 */
Object waitForNextEventTarget(KeyEvent nextKey,QueuedEvent qev,MotionEvent nextMotion,boolean isPointerEvent,boolean failIfTimeout){
  long startTime=SystemClock.uptimeMillis();
  long keyDispatchingTimeout=5 * 1000;
  long waitedFor=0;
  while (true) {
    WindowState targetWin=mLastWin;
    boolean targetIsNew=targetWin == null;
    if (DEBUG_INPUT)     Log.v(TAG,""String_Node_Str"" + mFinished + ""String_Node_Str""+ mLastWin);
    if (targetIsNew) {
      Object target=findTargetWindow(nextKey,qev,nextMotion,isPointerEvent);
      if (target == SKIP_TARGET_TOKEN) {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
        return null;
      }
      if (target == CONSUMED_EVENT_TOKEN) {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
        return target;
      }
      targetWin=(WindowState)target;
    }
    AppWindowToken targetApp=null;
synchronized (this) {
      if (!targetIsNew && mLastWin == null) {
        continue;
      }
      if (mFinished && !mDisplayFrozen) {
        if (!mEventDispatching) {
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
          return null;
        }
        if (targetWin != null) {
          if (targetIsNew && !targetWin.mToken.paused) {
            return targetWin;
          }
        }
 else         if (mFocusedApp == null) {
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
          return null;
        }
      }
      if (DEBUG_INPUT)       Log.v(TAG,""String_Node_Str"" + mLastBinder + ""String_Node_Str""+ targetWin+ ""String_Node_Str""+ mFinished+ ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ targetIsNew+ ""String_Node_Str""+ (targetWin != null ? targetWin.mToken.paused : false)+ ""String_Node_Str""+ mFocusedApp+ ""String_Node_Str""+ mCurrentFocus);
      targetApp=targetWin != null ? targetWin.mAppToken : mFocusedApp;
      long curTimeout=keyDispatchingTimeout;
      if (mTimeToSwitch != 0) {
        long now=SystemClock.uptimeMillis();
        if (mTimeToSwitch <= now) {
          doFinishedKeyLocked(true);
          continue;
        }
        long switchTimeout=mTimeToSwitch - now;
        if (curTimeout > switchTimeout) {
          curTimeout=switchTimeout;
        }
      }
      try {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + curTimeout);
        wait(curTimeout);
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + SystemClock.uptimeMillis() + ""String_Node_Str""+ startTime+ ""String_Node_Str""+ mTimeToSwitch+ ""String_Node_Str""+ targetWin+ ""String_Node_Str""+ mLastWin+ ""String_Node_Str""+ mLastBinder+ ""String_Node_Str""+ mFinished+ ""String_Node_Str""+ mCurrentFocus);
      }
 catch (      InterruptedException e) {
      }
    }
    if (mWasFrozen) {
      waitedFor=0;
      mWasFrozen=false;
    }
 else {
      waitedFor=SystemClock.uptimeMillis() - startTime;
    }
    if (waitedFor >= keyDispatchingTimeout && mTimeToSwitch == 0) {
      IApplicationToken at=null;
synchronized (this) {
        Log.w(TAG,""String_Node_Str"" + (targetWin != null ? targetWin.mAttrs.getTitle() : ""String_Node_Str""));
        Log.w(TAG,""String_Node_Str"" + mDispatchState);
        Log.w(TAG,""String_Node_Str"" + new DispatchState(nextKey,targetWin));
        if (targetWin != null) {
          at=targetWin.getAppToken();
        }
 else         if (targetApp != null) {
          at=targetApp.appToken;
        }
      }
      boolean abort=true;
      if (at != null) {
        try {
          long timeout=at.getKeyDispatchingTimeout();
          if (timeout > waitedFor) {
            keyDispatchingTimeout=timeout - waitedFor;
            continue;
          }
 else {
            abort=at.keyDispatchingTimedOut();
          }
        }
 catch (        RemoteException ex) {
        }
      }
synchronized (this) {
        if (abort && (mLastWin == targetWin || targetWin == null)) {
          mFinished=true;
          if (mLastWin != null) {
            if (DEBUG_INPUT)             Log.v(TAG,""String_Node_Str"" + mLastWin + ""String_Node_Str"");
            if (mLastWin.mToken.paused) {
              Log.w(TAG,""String_Node_Str"");
              mLastWin.mToken.paused=false;
            }
          }
          if (mMotionTarget == targetWin) {
            mMotionTarget=null;
          }
          mLastWin=null;
          mLastBinder=null;
          if (failIfTimeout || targetWin == null) {
            return null;
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          startTime=SystemClock.uptimeMillis();
        }
      }
    }
  }
}","/** 
 * Wait for the last event dispatch to complete, then find the next target that should receive the given event and wait for that one to be ready to receive it.
 */
Object waitForNextEventTarget(KeyEvent nextKey,QueuedEvent qev,MotionEvent nextMotion,boolean isPointerEvent,boolean failIfTimeout,int callingPid,int callingUid){
  long startTime=SystemClock.uptimeMillis();
  long keyDispatchingTimeout=5 * 1000;
  long waitedFor=0;
  while (true) {
    WindowState targetWin=mLastWin;
    boolean targetIsNew=targetWin == null;
    if (DEBUG_INPUT)     Log.v(TAG,""String_Node_Str"" + mFinished + ""String_Node_Str""+ mLastWin);
    if (targetIsNew) {
      Object target=findTargetWindow(nextKey,qev,nextMotion,isPointerEvent,callingPid,callingUid);
      if (target == SKIP_TARGET_TOKEN) {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
        return null;
      }
      if (target == CONSUMED_EVENT_TOKEN) {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
        return target;
      }
      targetWin=(WindowState)target;
    }
    AppWindowToken targetApp=null;
synchronized (this) {
      if (!targetIsNew && mLastWin == null) {
        continue;
      }
      if (mFinished && !mDisplayFrozen) {
        if (!mEventDispatching) {
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
          return null;
        }
        if (targetWin != null) {
          if (targetIsNew && !targetWin.mToken.paused) {
            return targetWin;
          }
        }
 else         if (mFocusedApp == null) {
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKey + ""String_Node_Str""+ nextMotion);
          return null;
        }
      }
      if (DEBUG_INPUT)       Log.v(TAG,""String_Node_Str"" + mLastBinder + ""String_Node_Str""+ targetWin+ ""String_Node_Str""+ mFinished+ ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ targetIsNew+ ""String_Node_Str""+ (targetWin != null ? targetWin.mToken.paused : false)+ ""String_Node_Str""+ mFocusedApp+ ""String_Node_Str""+ mCurrentFocus);
      targetApp=targetWin != null ? targetWin.mAppToken : mFocusedApp;
      long curTimeout=keyDispatchingTimeout;
      if (mTimeToSwitch != 0) {
        long now=SystemClock.uptimeMillis();
        if (mTimeToSwitch <= now) {
          doFinishedKeyLocked(true);
          continue;
        }
        long switchTimeout=mTimeToSwitch - now;
        if (curTimeout > switchTimeout) {
          curTimeout=switchTimeout;
        }
      }
      try {
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + curTimeout);
        wait(curTimeout);
        if (DEBUG_INPUT)         Log.v(TAG,""String_Node_Str"" + SystemClock.uptimeMillis() + ""String_Node_Str""+ startTime+ ""String_Node_Str""+ mTimeToSwitch+ ""String_Node_Str""+ targetWin+ ""String_Node_Str""+ mLastWin+ ""String_Node_Str""+ mLastBinder+ ""String_Node_Str""+ mFinished+ ""String_Node_Str""+ mCurrentFocus);
      }
 catch (      InterruptedException e) {
      }
    }
    if (mWasFrozen) {
      waitedFor=0;
      mWasFrozen=false;
    }
 else {
      waitedFor=SystemClock.uptimeMillis() - startTime;
    }
    if (waitedFor >= keyDispatchingTimeout && mTimeToSwitch == 0) {
      IApplicationToken at=null;
synchronized (this) {
        Log.w(TAG,""String_Node_Str"" + (targetWin != null ? targetWin.mAttrs.getTitle() : ""String_Node_Str""));
        Log.w(TAG,""String_Node_Str"" + mDispatchState);
        Log.w(TAG,""String_Node_Str"" + new DispatchState(nextKey,targetWin));
        if (targetWin != null) {
          at=targetWin.getAppToken();
        }
 else         if (targetApp != null) {
          at=targetApp.appToken;
        }
      }
      boolean abort=true;
      if (at != null) {
        try {
          long timeout=at.getKeyDispatchingTimeout();
          if (timeout > waitedFor) {
            keyDispatchingTimeout=timeout - waitedFor;
            continue;
          }
 else {
            abort=at.keyDispatchingTimedOut();
          }
        }
 catch (        RemoteException ex) {
        }
      }
synchronized (this) {
        if (abort && (mLastWin == targetWin || targetWin == null)) {
          mFinished=true;
          if (mLastWin != null) {
            if (DEBUG_INPUT)             Log.v(TAG,""String_Node_Str"" + mLastWin + ""String_Node_Str"");
            if (mLastWin.mToken.paused) {
              Log.w(TAG,""String_Node_Str"");
              mLastWin.mToken.paused=false;
            }
          }
          if (mMotionTarget == targetWin) {
            mMotionTarget=null;
          }
          mLastWin=null;
          mLastBinder=null;
          if (failIfTimeout || targetWin == null) {
            return null;
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          startTime=SystemClock.uptimeMillis();
        }
      }
    }
  }
}",0.9946938775510203
183511,"/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchPointer(QueuedEvent qev,MotionEvent ev,int pid,int uid){
  if (DEBUG_INPUT || WindowManagerPolicy.WATCH_POINTER)   Log.v(TAG,""String_Node_Str"" + ev);
  Object targetObj=mKeyWaiter.waitForNextEventTarget(null,qev,ev,true,false);
  int action=ev.getAction();
  if (action == MotionEvent.ACTION_UP) {
    mKeyWaiter.mMotionTarget=null;
    mPowerManager.logPointerUpEvent();
  }
 else   if (action == MotionEvent.ACTION_DOWN) {
    mPowerManager.logPointerDownEvent();
  }
  if (targetObj == null) {
    if (action != MotionEvent.ACTION_MOVE) {
      Log.w(TAG,""String_Node_Str"" + ev.getAction());
    }
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_FAILED;
  }
  if (targetObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_SUCCEEDED;
  }
  WindowState target=(WindowState)targetObj;
  final long eventTime=ev.getEventTime();
  if (uid != 0 && uid != target.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ target+ ""String_Node_Str""+ target.mSession.mUid);
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_NO_PERMISSION;
    }
  }
  if ((target.mAttrs.flags & WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES) != 0) {
    boolean cheekPress=mPolicy.isCheekPressedAgainstScreen(ev);
    boolean returnFlag=false;
    if ((action == MotionEvent.ACTION_DOWN)) {
      mFatTouch=false;
      if (cheekPress) {
        mFatTouch=true;
        returnFlag=true;
      }
    }
 else {
      if (action == MotionEvent.ACTION_UP) {
        if (mFatTouch) {
          mFatTouch=false;
          returnFlag=true;
        }
 else         if (cheekPress) {
          ev.setAction(MotionEvent.ACTION_CANCEL);
          action=MotionEvent.ACTION_CANCEL;
        }
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (mFatTouch) {
          returnFlag=true;
        }
 else         if (cheekPress) {
          ev.setAction(MotionEvent.ACTION_CANCEL);
          action=MotionEvent.ACTION_CANCEL;
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"");
          mFatTouch=true;
        }
      }
    }
    if (returnFlag) {
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_FAILED;
    }
  }
  if (action == MotionEvent.ACTION_DOWN) {
    int max_events_per_sec=35;
    try {
      max_events_per_sec=Integer.parseInt(SystemProperties.get(""String_Node_Str""));
      if (max_events_per_sec < 1) {
        max_events_per_sec=35;
      }
    }
 catch (    NumberFormatException e) {
    }
    mMinWaitTimeBetweenTouchEvents=1000 / max_events_per_sec;
  }
  if (action == MotionEvent.ACTION_MOVE) {
    long nextEventTime=mLastTouchEventTime + mMinWaitTimeBetweenTouchEvents;
    long now=SystemClock.uptimeMillis();
    if (now < nextEventTime) {
      try {
        Thread.sleep(nextEventTime - now);
      }
 catch (      InterruptedException e) {
      }
      mLastTouchEventTime=nextEventTime;
    }
 else {
      mLastTouchEventTime=now;
    }
  }
synchronized (mWindowMap) {
    if (qev != null && action == MotionEvent.ACTION_MOVE) {
      mKeyWaiter.bindTargetWindowLocked(target,KeyWaiter.RETURN_PENDING_POINTER,qev);
      ev=null;
    }
 else {
      if (action == MotionEvent.ACTION_DOWN) {
        WindowState out=mKeyWaiter.mOutsideTouchTargets;
        if (out != null) {
          MotionEvent oev=MotionEvent.obtain(ev);
          oev.setAction(MotionEvent.ACTION_OUTSIDE);
          do {
            final Rect frame=out.mFrame;
            oev.offsetLocation(-(float)frame.left,-(float)frame.top);
            try {
              out.mClient.dispatchPointer(oev,eventTime);
            }
 catch (            android.os.RemoteException e) {
              Log.i(TAG,""String_Node_Str"" + out);
            }
            oev.offsetLocation((float)frame.left,(float)frame.top);
            out=out.mNextOutsideTouch;
          }
 while (out != null);
          mKeyWaiter.mOutsideTouchTargets=null;
        }
      }
      final Rect frame=target.mFrame;
      ev.offsetLocation(-(float)frame.left,-(float)frame.top);
      mKeyWaiter.bindTargetWindowLocked(target);
    }
  }
  try {
    if (DEBUG_INPUT || DEBUG_FOCUS || WindowManagerPolicy.WATCH_POINTER) {
      Log.v(TAG,""String_Node_Str"" + qev + ""String_Node_Str""+ target);
    }
    target.mClient.dispatchPointer(ev,eventTime);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + target);
    mKeyWaiter.mMotionTarget=null;
    try {
      removeWindow(target.mSession,target.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}","/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchPointer(QueuedEvent qev,MotionEvent ev,int pid,int uid){
  if (DEBUG_INPUT || WindowManagerPolicy.WATCH_POINTER)   Log.v(TAG,""String_Node_Str"" + ev);
  Object targetObj=mKeyWaiter.waitForNextEventTarget(null,qev,ev,true,false,pid,uid);
  int action=ev.getAction();
  if (action == MotionEvent.ACTION_UP) {
    mKeyWaiter.mMotionTarget=null;
    mPowerManager.logPointerUpEvent();
  }
 else   if (action == MotionEvent.ACTION_DOWN) {
    mPowerManager.logPointerDownEvent();
  }
  if (targetObj == null) {
    if (action != MotionEvent.ACTION_MOVE) {
      Log.w(TAG,""String_Node_Str"" + ev.getAction());
    }
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_FAILED;
  }
  if (targetObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_SUCCEEDED;
  }
  WindowState target=(WindowState)targetObj;
  final long eventTime=ev.getEventTime();
  if (uid != 0 && uid != target.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ target+ ""String_Node_Str""+ target.mSession.mUid);
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_NO_PERMISSION;
    }
  }
  if ((target.mAttrs.flags & WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES) != 0) {
    boolean cheekPress=mPolicy.isCheekPressedAgainstScreen(ev);
    boolean returnFlag=false;
    if ((action == MotionEvent.ACTION_DOWN)) {
      mFatTouch=false;
      if (cheekPress) {
        mFatTouch=true;
        returnFlag=true;
      }
    }
 else {
      if (action == MotionEvent.ACTION_UP) {
        if (mFatTouch) {
          mFatTouch=false;
          returnFlag=true;
        }
 else         if (cheekPress) {
          ev.setAction(MotionEvent.ACTION_CANCEL);
          action=MotionEvent.ACTION_CANCEL;
        }
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (mFatTouch) {
          returnFlag=true;
        }
 else         if (cheekPress) {
          ev.setAction(MotionEvent.ACTION_CANCEL);
          action=MotionEvent.ACTION_CANCEL;
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"");
          mFatTouch=true;
        }
      }
    }
    if (returnFlag) {
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_FAILED;
    }
  }
  if (action == MotionEvent.ACTION_DOWN) {
    int max_events_per_sec=35;
    try {
      max_events_per_sec=Integer.parseInt(SystemProperties.get(""String_Node_Str""));
      if (max_events_per_sec < 1) {
        max_events_per_sec=35;
      }
    }
 catch (    NumberFormatException e) {
    }
    mMinWaitTimeBetweenTouchEvents=1000 / max_events_per_sec;
  }
  if (action == MotionEvent.ACTION_MOVE) {
    long nextEventTime=mLastTouchEventTime + mMinWaitTimeBetweenTouchEvents;
    long now=SystemClock.uptimeMillis();
    if (now < nextEventTime) {
      try {
        Thread.sleep(nextEventTime - now);
      }
 catch (      InterruptedException e) {
      }
      mLastTouchEventTime=nextEventTime;
    }
 else {
      mLastTouchEventTime=now;
    }
  }
synchronized (mWindowMap) {
    if (qev != null && action == MotionEvent.ACTION_MOVE) {
      mKeyWaiter.bindTargetWindowLocked(target,KeyWaiter.RETURN_PENDING_POINTER,qev);
      ev=null;
    }
 else {
      if (action == MotionEvent.ACTION_DOWN) {
        WindowState out=mKeyWaiter.mOutsideTouchTargets;
        if (out != null) {
          MotionEvent oev=MotionEvent.obtain(ev);
          oev.setAction(MotionEvent.ACTION_OUTSIDE);
          do {
            final Rect frame=out.mFrame;
            oev.offsetLocation(-(float)frame.left,-(float)frame.top);
            try {
              out.mClient.dispatchPointer(oev,eventTime);
            }
 catch (            android.os.RemoteException e) {
              Log.i(TAG,""String_Node_Str"" + out);
            }
            oev.offsetLocation((float)frame.left,(float)frame.top);
            out=out.mNextOutsideTouch;
          }
 while (out != null);
          mKeyWaiter.mOutsideTouchTargets=null;
        }
      }
      final Rect frame=target.mFrame;
      ev.offsetLocation(-(float)frame.left,-(float)frame.top);
      mKeyWaiter.bindTargetWindowLocked(target);
    }
  }
  try {
    if (DEBUG_INPUT || DEBUG_FOCUS || WindowManagerPolicy.WATCH_POINTER) {
      Log.v(TAG,""String_Node_Str"" + qev + ""String_Node_Str""+ target);
    }
    target.mClient.dispatchPointer(ev,eventTime);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + target);
    mKeyWaiter.mMotionTarget=null;
    try {
      removeWindow(target.mSession,target.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}",0.9992110453648916
183512,"/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchTrackball(QueuedEvent qev,MotionEvent ev,int pid,int uid){
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + ev.getAction() + ""String_Node_Str""+ ev.getX()+ ""String_Node_Str""+ ev.getY()+ ""String_Node_Str"");
  Object focusObj=mKeyWaiter.waitForNextEventTarget(null,qev,ev,false,false);
  if (focusObj == null) {
    Log.w(TAG,""String_Node_Str"" + ev);
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_FAILED;
  }
  if (focusObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_SUCCEEDED;
  }
  WindowState focus=(WindowState)focusObj;
  if (uid != 0 && uid != focus.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ focus.mSession.mUid);
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_NO_PERMISSION;
    }
  }
  final long eventTime=ev.getEventTime();
synchronized (mWindowMap) {
    if (qev != null && ev.getAction() == MotionEvent.ACTION_MOVE) {
      mKeyWaiter.bindTargetWindowLocked(focus,KeyWaiter.RETURN_PENDING_TRACKBALL,qev);
      ev=null;
    }
 else {
      mKeyWaiter.bindTargetWindowLocked(focus);
    }
  }
  try {
    focus.mClient.dispatchTrackball(ev,eventTime);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + focus);
    try {
      removeWindow(focus.mSession,focus.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}","/** 
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
private int dispatchTrackball(QueuedEvent qev,MotionEvent ev,int pid,int uid){
  if (DEBUG_INPUT)   Log.v(TAG,""String_Node_Str"" + ev.getAction() + ""String_Node_Str""+ ev.getX()+ ""String_Node_Str""+ ev.getY()+ ""String_Node_Str"");
  Object focusObj=mKeyWaiter.waitForNextEventTarget(null,qev,ev,false,false,pid,uid);
  if (focusObj == null) {
    Log.w(TAG,""String_Node_Str"" + ev);
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_FAILED;
  }
  if (focusObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return INJECT_SUCCEEDED;
  }
  WindowState focus=(WindowState)focusObj;
  if (uid != 0 && uid != focus.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ uid+ ""String_Node_Str""+ focus+ ""String_Node_Str""+ focus.mSession.mUid);
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return INJECT_NO_PERMISSION;
    }
  }
  final long eventTime=ev.getEventTime();
synchronized (mWindowMap) {
    if (qev != null && ev.getAction() == MotionEvent.ACTION_MOVE) {
      mKeyWaiter.bindTargetWindowLocked(focus,KeyWaiter.RETURN_PENDING_TRACKBALL,qev);
      ev=null;
    }
 else {
      mKeyWaiter.bindTargetWindowLocked(focus);
    }
  }
  try {
    focus.mClient.dispatchTrackball(ev,eventTime);
    return INJECT_SUCCEEDED;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,""String_Node_Str"" + focus);
    try {
      removeWindow(focus.mSession,focus.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return INJECT_FAILED;
}",0.9978552278820376
183513,"/** 
 * Inject a trackball (navigation device) event into the UI.
 * @param ev A motion event describing the trackball action.  (As noted in{@link MotionEvent#obtain(long,long,int,float,float,int)}, be sure to use  {@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectTrackballEvent(MotionEvent ev,boolean sync){
  int result=dispatchTrackball(null,ev,Binder.getCallingPid(),Binder.getCallingUid());
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true);
  }
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}","/** 
 * Inject a trackball (navigation device) event into the UI.
 * @param ev A motion event describing the trackball action.  (As noted in{@link MotionEvent#obtain(long,long,int,float,float,int)}, be sure to use  {@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectTrackballEvent(MotionEvent ev,boolean sync){
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  final long ident=Binder.clearCallingIdentity();
  final int result=dispatchTrackball(null,ev,pid,uid);
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true,pid,uid);
  }
  Binder.restoreCallingIdentity(ident);
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}",0.8707557502738226
183514,"/** 
 * Injects a keystroke event into the UI.
 * @param ev A motion event describing the keystroke action.  (Be sure to use{@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectKeyEvent(KeyEvent ev,boolean sync){
  long downTime=ev.getDownTime();
  long eventTime=ev.getEventTime();
  int action=ev.getAction();
  int code=ev.getKeyCode();
  int repeatCount=ev.getRepeatCount();
  int metaState=ev.getMetaState();
  int deviceId=ev.getDeviceId();
  int scancode=ev.getScanCode();
  if (eventTime == 0)   eventTime=SystemClock.uptimeMillis();
  if (downTime == 0)   downTime=eventTime;
  KeyEvent newEvent=new KeyEvent(downTime,eventTime,action,code,repeatCount,metaState,deviceId,scancode,KeyEvent.FLAG_FROM_SYSTEM);
  int result=dispatchKey(newEvent,Binder.getCallingPid(),Binder.getCallingUid());
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true);
  }
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}","/** 
 * Injects a keystroke event into the UI.
 * @param ev A motion event describing the keystroke action.  (Be sure to use{@link SystemClock#uptimeMillis()} as the timebase.)
 * @param sync If true, wait for the event to be completed before returning to the caller.
 * @return Returns true if event was dispatched, false if it was dropped for any reason
 */
public boolean injectKeyEvent(KeyEvent ev,boolean sync){
  long downTime=ev.getDownTime();
  long eventTime=ev.getEventTime();
  int action=ev.getAction();
  int code=ev.getKeyCode();
  int repeatCount=ev.getRepeatCount();
  int metaState=ev.getMetaState();
  int deviceId=ev.getDeviceId();
  int scancode=ev.getScanCode();
  if (eventTime == 0)   eventTime=SystemClock.uptimeMillis();
  if (downTime == 0)   downTime=eventTime;
  KeyEvent newEvent=new KeyEvent(downTime,eventTime,action,code,repeatCount,metaState,deviceId,scancode,KeyEvent.FLAG_FROM_SYSTEM);
  final int pid=Binder.getCallingPid();
  final int uid=Binder.getCallingUid();
  final long ident=Binder.clearCallingIdentity();
  final int result=dispatchKey(newEvent,pid,uid);
  if (sync) {
    mKeyWaiter.waitForNextEventTarget(null,null,null,false,true,pid,uid);
  }
  Binder.restoreCallingIdentity(ident);
switch (result) {
case INJECT_NO_PERMISSION:
    throw new SecurityException(""String_Node_Str"");
case INJECT_SUCCEEDED:
  return true;
}
return false;
}",0.8498475609756098
183515,"private void runProfile(){
  String profileFile=null;
  boolean start=false;
  String process=nextArg();
  if (process == null) {
    System.err.println(""String_Node_Str"");
    showUsage();
    return;
  }
  String cmd=nextArg();
  if (""String_Node_Str"".equals(cmd)) {
    start=true;
    profileFile=nextArg();
    if (profileFile == null) {
      System.err.println(""String_Node_Str"");
      showUsage();
      return;
    }
  }
 else   if (!""String_Node_Str"".equals(cmd)) {
    System.err.println(""String_Node_Str"" + cmd + ""String_Node_Str"");
    showUsage();
    return;
  }
  try {
    if (!mAm.profileControl(process,start,profileFile)) {
      System.out.println(""String_Node_Str"" + process);
      return;
    }
  }
 catch (  IllegalArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  IllegalStateException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  RemoteException e) {
    System.out.println(""String_Node_Str"");
    return;
  }
}","private void runProfile(){
  String profileFile=null;
  boolean start=false;
  String process=nextArg();
  if (process == null) {
    System.err.println(""String_Node_Str"");
    showUsage();
    return;
  }
  ParcelFileDescriptor fd=null;
  String cmd=nextArg();
  if (""String_Node_Str"".equals(cmd)) {
    start=true;
    profileFile=nextArg();
    if (profileFile == null) {
      System.err.println(""String_Node_Str"");
      showUsage();
      return;
    }
    try {
      fd=ParcelFileDescriptor.open(new File(profileFile),ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE | ParcelFileDescriptor.MODE_READ_WRITE);
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + profileFile);
      return;
    }
  }
 else   if (!""String_Node_Str"".equals(cmd)) {
    System.err.println(""String_Node_Str"" + cmd + ""String_Node_Str"");
    showUsage();
    return;
  }
  try {
    if (!mAm.profileControl(process,start,profileFile,fd)) {
      System.err.println(""String_Node_Str"" + process);
      return;
    }
  }
 catch (  IllegalArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  IllegalStateException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  RemoteException e) {
    System.out.println(""String_Node_Str"");
    return;
  }
}",0.8583230070218918
183516,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9984246588342476
183517,"public boolean profileControl(String process,boolean start,String path) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeString(process);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  mRemote.transact(PROFILE_CONTROL_TRANSACTION,data,reply,0);
  reply.readException();
  boolean res=reply.readInt() != 0;
  reply.recycle();
  data.recycle();
  return res;
}","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeString(process);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  if (fd != null) {
    data.writeInt(1);
    fd.writeToParcel(data,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(PROFILE_CONTROL_TRANSACTION,data,reply,0);
  reply.readException();
  boolean res=reply.readInt() != 0;
  reply.recycle();
  data.recycle();
  return res;
}",0.8470380194518126
183518,"final void handleProfilerControl(boolean start,String path){
  if (start) {
    File file=new File(path);
    file.getParentFile().mkdirs();
    try {
      Debug.startMethodTracing(file.toString(),8 * 1024 * 1024);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + path + ""String_Node_Str"");
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}","final void handleProfilerControl(boolean start,ProfilerControlData pcd){
  if (start) {
    try {
      Debug.startMethodTracing(pcd.path,pcd.fd.getFileDescriptor(),8 * 1024 * 1024,0);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + pcd.path + ""String_Node_Str"");
    }
 finally {
      try {
        pcd.fd.close();
      }
 catch (      IOException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}",0.6239813736903376
183519,"public void profilerControl(boolean start,String path){
  queueOrSendMessage(H.PROFILER_CONTROL,path,start ? 1 : 0);
}","public void profilerControl(boolean start,String path,ParcelFileDescriptor fd){
  ProfilerControlData pcd=new ProfilerControlData();
  pcd.path=path;
  pcd.fd=fd;
  queueOrSendMessage(H.PROFILER_CONTROL,pcd,start ? 1 : 0);
}",0.672514619883041
183520,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(String)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
}
}",0.9953297216514104
183521,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
Intent args=Intent.CREATOR.createFromParcel(data);
scheduleServiceArgs(token,startId,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
profilerControl(start,path);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
Intent args=Intent.CREATOR.createFromParcel(data);
scheduleServiceArgs(token,startId,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9950936927351184
183522,"public void profilerControl(boolean start,String path) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  mRemote.transact(PROFILER_CONTROL_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}","public void profilerControl(boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  if (fd != null) {
    data.writeInt(1);
    fd.writeToParcel(data,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(PROFILER_CONTROL_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}",0.7908101571946796
183523,"public boolean profileControl(String process,boolean start,String path) throws RemoteException ;","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException ;",0.8888888888888888
183524,"void profilerControl(boolean start,String path) throws RemoteException ;","void profilerControl(boolean start,String path,ParcelFileDescriptor fd) throws RemoteException ;",0.8571428571428571
183525,"/** 
 * Start method tracing, specifying the trace log file name and the buffer size. The trace files will be put under ""/sdcard"" unless an absolute path is given. See <a href=""  {@docRoot}guide/developing/tools/traceview.html"">Traceview: A Graphical Log Viewer</a> for information about reading trace files. <p> When method tracing is enabled, the VM will run more slowly than usual, so the timings from the trace files should only be considered in relative terms (e.g. was run #1 faster than run #2).  The times for native methods will not change, so don't try to use this to compare the performance of interpreted and native implementations of the same method.  As an alternative, consider using ""native"" tracing in the emulator via   {@link #startNativeTracing()}. </p>
 * @param traceName    Name for the trace log file to create.If no name argument is given, this value defaults to ""/sdcard/dmtrace.trace"". If the files already exist, they will be truncated. If the trace file given does not end in "".trace"", it will be appended for you.
 * @param bufferSize    The maximum amount of trace data we gather. If not given, it defaults to 8MB.
 */
public static void startMethodTracing(String traceName,int bufferSize,int flags){
  String pathName=traceName;
  if (pathName.charAt(0) != '/')   pathName=DEFAULT_TRACE_PATH_PREFIX + pathName;
  if (!pathName.endsWith(DEFAULT_TRACE_EXTENSION))   pathName=pathName + DEFAULT_TRACE_EXTENSION;
  VMDebug.startMethodTracing(pathName,bufferSize,flags);
}","/** 
 * Like startMethodTracing(String, int, int), but taking an already-opened FileDescriptor in which the trace is written.  The file name is also supplied simply for logging.  Makes a dup of the file descriptor. Not exposed in the SDK unless we are really comfortable with supporting this and find it would be useful.
 * @hide
 */
public static void startMethodTracing(String traceName,FileDescriptor fd,int bufferSize,int flags){
  VMDebug.startMethodTracing(traceName,fd,bufferSize,flags);
}",0.1573934837092732
183526,"public boolean profileControl(String process,boolean start,String path) throws RemoteException {
synchronized (this) {
    if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
      throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
    }
    ProcessRecord proc=null;
    try {
      int pid=Integer.parseInt(process);
synchronized (mPidsSelfLocked) {
        proc=mPidsSelfLocked.get(pid);
      }
    }
 catch (    NumberFormatException e) {
    }
    if (proc == null) {
      HashMap<String,SparseArray<ProcessRecord>> all=mProcessNames.getMap();
      SparseArray<ProcessRecord> procs=all.get(process);
      if (procs != null && procs.size() > 0) {
        proc=procs.valueAt(0);
      }
    }
    if (proc == null || proc.thread == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + process);
    }
    boolean isSecure=""String_Node_Str"".equals(SystemProperties.get(SYSTEM_SECURE,""String_Node_Str""));
    if (isSecure) {
      if ((proc.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
        throw new SecurityException(""String_Node_Str"" + proc);
      }
    }
    try {
      proc.thread.profilerControl(start,path);
      return true;
    }
 catch (    RemoteException e) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
}","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  try {
synchronized (this) {
      if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
      }
      if (start && fd == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      ProcessRecord proc=null;
      try {
        int pid=Integer.parseInt(process);
synchronized (mPidsSelfLocked) {
          proc=mPidsSelfLocked.get(pid);
        }
      }
 catch (      NumberFormatException e) {
      }
      if (proc == null) {
        HashMap<String,SparseArray<ProcessRecord>> all=mProcessNames.getMap();
        SparseArray<ProcessRecord> procs=all.get(process);
        if (procs != null && procs.size() > 0) {
          proc=procs.valueAt(0);
        }
      }
      if (proc == null || proc.thread == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + process);
      }
      boolean isSecure=""String_Node_Str"".equals(SystemProperties.get(SYSTEM_SECURE,""String_Node_Str""));
      if (isSecure) {
        if ((proc.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
          throw new SecurityException(""String_Node_Str"" + proc);
        }
      }
      proc.thread.profilerControl(start,path,fd);
      fd=null;
      return true;
    }
  }
 catch (  RemoteException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 finally {
    if (fd != null) {
      try {
        fd.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.7981888745148771
183527,"private void runProfile(){
  String profileFile=null;
  boolean start=false;
  String process=nextArg();
  if (process == null) {
    System.err.println(""String_Node_Str"");
    showUsage();
    return;
  }
  String cmd=nextArg();
  if (""String_Node_Str"".equals(cmd)) {
    start=true;
    profileFile=nextArg();
    if (profileFile == null) {
      System.err.println(""String_Node_Str"");
      showUsage();
      return;
    }
  }
 else   if (!""String_Node_Str"".equals(cmd)) {
    System.err.println(""String_Node_Str"" + cmd + ""String_Node_Str"");
    showUsage();
    return;
  }
  try {
    if (!mAm.profileControl(process,start,profileFile)) {
      System.out.println(""String_Node_Str"" + process);
      return;
    }
  }
 catch (  IllegalArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  IllegalStateException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  RemoteException e) {
    System.out.println(""String_Node_Str"");
    return;
  }
}","private void runProfile(){
  String profileFile=null;
  boolean start=false;
  String process=nextArg();
  if (process == null) {
    System.err.println(""String_Node_Str"");
    showUsage();
    return;
  }
  ParcelFileDescriptor fd=null;
  String cmd=nextArg();
  if (""String_Node_Str"".equals(cmd)) {
    start=true;
    profileFile=nextArg();
    if (profileFile == null) {
      System.err.println(""String_Node_Str"");
      showUsage();
      return;
    }
    try {
      fd=ParcelFileDescriptor.open(new File(profileFile),ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE | ParcelFileDescriptor.MODE_READ_WRITE);
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + profileFile);
      return;
    }
  }
 else   if (!""String_Node_Str"".equals(cmd)) {
    System.err.println(""String_Node_Str"" + cmd + ""String_Node_Str"");
    showUsage();
    return;
  }
  try {
    if (!mAm.profileControl(process,start,profileFile,fd)) {
      System.err.println(""String_Node_Str"" + process);
      return;
    }
  }
 catch (  IllegalArgumentException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  IllegalStateException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    return;
  }
catch (  RemoteException e) {
    System.out.println(""String_Node_Str"");
    return;
  }
}",0.8583230070218918
183528,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9984246588342476
183529,"public boolean profileControl(String process,boolean start,String path) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeString(process);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  mRemote.transact(PROFILE_CONTROL_TRANSACTION,data,reply,0);
  reply.readException();
  boolean res=reply.readInt() != 0;
  reply.recycle();
  data.recycle();
  return res;
}","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeString(process);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  if (fd != null) {
    data.writeInt(1);
    fd.writeToParcel(data,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(PROFILE_CONTROL_TRANSACTION,data,reply,0);
  reply.readException();
  boolean res=reply.readInt() != 0;
  reply.recycle();
  data.recycle();
  return res;
}",0.8470380194518126
183530,"final void handleProfilerControl(boolean start,String path){
  if (start) {
    File file=new File(path);
    file.getParentFile().mkdirs();
    try {
      Debug.startMethodTracing(file.toString(),8 * 1024 * 1024);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + path + ""String_Node_Str"");
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}","final void handleProfilerControl(boolean start,ProfilerControlData pcd){
  if (start) {
    try {
      Debug.startMethodTracing(pcd.path,pcd.fd.getFileDescriptor(),8 * 1024 * 1024,0);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + pcd.path + ""String_Node_Str"");
    }
 finally {
      try {
        pcd.fd.close();
      }
 catch (      IOException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
 else {
    Debug.stopMethodTracing();
  }
}",0.6239813736903376
183531,"public void profilerControl(boolean start,String path){
  queueOrSendMessage(H.PROFILER_CONTROL,path,start ? 1 : 0);
}","public void profilerControl(boolean start,String path,ParcelFileDescriptor fd){
  ProfilerControlData pcd=new ProfilerControlData();
  pcd.path=path;
  pcd.fd=fd;
  queueOrSendMessage(H.PROFILER_CONTROL,pcd,start ? 1 : 0);
}",0.672514619883041
183532,"public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(String)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
}
}","public void handleMessage(Message msg){
switch (msg.what) {
case LAUNCH_ACTIVITY:
{
      ActivityRecord r=(ActivityRecord)msg.obj;
      r.packageInfo=getPackageInfoNoCheck(r.activityInfo.applicationInfo);
      handleLaunchActivity(r,null);
    }
  break;
case RELAUNCH_ACTIVITY:
{
  ActivityRecord r=(ActivityRecord)msg.obj;
  handleRelaunchActivity(r,msg.arg1);
}
break;
case PAUSE_ACTIVITY:
handlePauseActivity((IBinder)msg.obj,false,msg.arg1 != 0,msg.arg2);
break;
case PAUSE_ACTIVITY_FINISHING:
handlePauseActivity((IBinder)msg.obj,true,msg.arg1 != 0,msg.arg2);
break;
case STOP_ACTIVITY_SHOW:
handleStopActivity((IBinder)msg.obj,true,msg.arg2);
break;
case STOP_ACTIVITY_HIDE:
handleStopActivity((IBinder)msg.obj,false,msg.arg2);
break;
case SHOW_WINDOW:
handleWindowVisibility((IBinder)msg.obj,true);
break;
case HIDE_WINDOW:
handleWindowVisibility((IBinder)msg.obj,false);
break;
case RESUME_ACTIVITY:
handleResumeActivity((IBinder)msg.obj,true,msg.arg1 != 0);
break;
case SEND_RESULT:
handleSendResult((ResultData)msg.obj);
break;
case DESTROY_ACTIVITY:
handleDestroyActivity((IBinder)msg.obj,msg.arg1 != 0,msg.arg2,false);
break;
case BIND_APPLICATION:
AppBindData data=(AppBindData)msg.obj;
handleBindApplication(data);
break;
case EXIT_APPLICATION:
if (mInitialApplication != null) {
mInitialApplication.onTerminate();
}
Looper.myLooper().quit();
break;
case NEW_INTENT:
handleNewIntent((NewIntentData)msg.obj);
break;
case RECEIVER:
handleReceiver((ReceiverData)msg.obj);
break;
case CREATE_SERVICE:
handleCreateService((CreateServiceData)msg.obj);
break;
case BIND_SERVICE:
handleBindService((BindServiceData)msg.obj);
break;
case UNBIND_SERVICE:
handleUnbindService((BindServiceData)msg.obj);
break;
case SERVICE_ARGS:
handleServiceArgs((ServiceArgsData)msg.obj);
break;
case STOP_SERVICE:
handleStopService((IBinder)msg.obj);
break;
case REQUEST_THUMBNAIL:
handleRequestThumbnail((IBinder)msg.obj);
break;
case CONFIGURATION_CHANGED:
handleConfigurationChanged((Configuration)msg.obj);
break;
case CLEAN_UP_CONTEXT:
ContextCleanupInfo cci=(ContextCleanupInfo)msg.obj;
cci.context.performFinalCleanup(cci.who,cci.what);
break;
case GC_WHEN_IDLE:
scheduleGcIdler();
break;
case DUMP_SERVICE:
handleDumpService((DumpServiceInfo)msg.obj);
break;
case LOW_MEMORY:
handleLowMemory();
break;
case ACTIVITY_CONFIGURATION_CHANGED:
handleActivityConfigurationChanged((IBinder)msg.obj);
break;
case PROFILER_CONTROL:
handleProfilerControl(msg.arg1 != 0,(ProfilerControlData)msg.obj);
break;
case CREATE_BACKUP_AGENT:
handleCreateBackupAgent((CreateBackupAgentData)msg.obj);
break;
case DESTROY_BACKUP_AGENT:
handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);
break;
}
}",0.9953297216514104
183533,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
Intent args=Intent.CREATOR.createFromParcel(data);
scheduleServiceArgs(token,startId,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
profilerControl(start,path);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
Intent args=Intent.CREATOR.createFromParcel(data);
scheduleServiceArgs(token,startId,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9950936927351184
183534,"public void profilerControl(boolean start,String path) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  mRemote.transact(PROFILER_CONTROL_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}","public void profilerControl(boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeInt(start ? 1 : 0);
  data.writeString(path);
  if (fd != null) {
    data.writeInt(1);
    fd.writeToParcel(data,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(PROFILER_CONTROL_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}",0.7908101571946796
183535,"public boolean profileControl(String process,boolean start,String path) throws RemoteException ;","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException ;",0.8888888888888888
183536,"void profilerControl(boolean start,String path) throws RemoteException ;","void profilerControl(boolean start,String path,ParcelFileDescriptor fd) throws RemoteException ;",0.8571428571428571
183537,"/** 
 * Start method tracing, specifying the trace log file name and the buffer size. The trace files will be put under ""/sdcard"" unless an absolute path is given. See <a href=""  {@docRoot}guide/developing/tools/traceview.html"">Traceview: A Graphical Log Viewer</a> for information about reading trace files. <p> When method tracing is enabled, the VM will run more slowly than usual, so the timings from the trace files should only be considered in relative terms (e.g. was run #1 faster than run #2).  The times for native methods will not change, so don't try to use this to compare the performance of interpreted and native implementations of the same method.  As an alternative, consider using ""native"" tracing in the emulator via   {@link #startNativeTracing()}. </p>
 * @param traceName    Name for the trace log file to create.If no name argument is given, this value defaults to ""/sdcard/dmtrace.trace"". If the files already exist, they will be truncated. If the trace file given does not end in "".trace"", it will be appended for you.
 * @param bufferSize    The maximum amount of trace data we gather. If not given, it defaults to 8MB.
 */
public static void startMethodTracing(String traceName,int bufferSize,int flags){
  String pathName=traceName;
  if (pathName.charAt(0) != '/')   pathName=DEFAULT_TRACE_PATH_PREFIX + pathName;
  if (!pathName.endsWith(DEFAULT_TRACE_EXTENSION))   pathName=pathName + DEFAULT_TRACE_EXTENSION;
  VMDebug.startMethodTracing(pathName,bufferSize,flags);
}","/** 
 * Like startMethodTracing(String, int, int), but taking an already-opened FileDescriptor in which the trace is written.  The file name is also supplied simply for logging.  Makes a dup of the file descriptor. Not exposed in the SDK unless we are really comfortable with supporting this and find it would be useful.
 * @hide
 */
public static void startMethodTracing(String traceName,FileDescriptor fd,int bufferSize,int flags){
  VMDebug.startMethodTracing(traceName,fd,bufferSize,flags);
}",0.1573934837092732
183538,"public boolean profileControl(String process,boolean start,String path) throws RemoteException {
synchronized (this) {
    if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
      throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
    }
    ProcessRecord proc=null;
    try {
      int pid=Integer.parseInt(process);
synchronized (mPidsSelfLocked) {
        proc=mPidsSelfLocked.get(pid);
      }
    }
 catch (    NumberFormatException e) {
    }
    if (proc == null) {
      HashMap<String,SparseArray<ProcessRecord>> all=mProcessNames.getMap();
      SparseArray<ProcessRecord> procs=all.get(process);
      if (procs != null && procs.size() > 0) {
        proc=procs.valueAt(0);
      }
    }
    if (proc == null || proc.thread == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + process);
    }
    boolean isSecure=""String_Node_Str"".equals(SystemProperties.get(SYSTEM_SECURE,""String_Node_Str""));
    if (isSecure) {
      if ((proc.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
        throw new SecurityException(""String_Node_Str"" + proc);
      }
    }
    try {
      proc.thread.profilerControl(start,path);
      return true;
    }
 catch (    RemoteException e) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
}","public boolean profileControl(String process,boolean start,String path,ParcelFileDescriptor fd) throws RemoteException {
  try {
synchronized (this) {
      if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
      }
      if (start && fd == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      ProcessRecord proc=null;
      try {
        int pid=Integer.parseInt(process);
synchronized (mPidsSelfLocked) {
          proc=mPidsSelfLocked.get(pid);
        }
      }
 catch (      NumberFormatException e) {
      }
      if (proc == null) {
        HashMap<String,SparseArray<ProcessRecord>> all=mProcessNames.getMap();
        SparseArray<ProcessRecord> procs=all.get(process);
        if (procs != null && procs.size() > 0) {
          proc=procs.valueAt(0);
        }
      }
      if (proc == null || proc.thread == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + process);
      }
      boolean isSecure=""String_Node_Str"".equals(SystemProperties.get(SYSTEM_SECURE,""String_Node_Str""));
      if (isSecure) {
        if ((proc.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
          throw new SecurityException(""String_Node_Str"" + proc);
        }
      }
      proc.thread.profilerControl(start,path,fd);
      fd=null;
      return true;
    }
  }
 catch (  RemoteException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
 finally {
    if (fd != null) {
      try {
        fd.close();
      }
 catch (      IOException e) {
      }
    }
  }
}",0.7981888745148771
183539,"public void noteAudioOffLocked(int uid){
  if (mAudioOn) {
    mAudioOn=false;
    mAudioOnTimer.stopRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteAudioTurnedOffLocked();
  }
}","public void noteAudioOffLocked(int uid){
  if (mAudioOn) {
    mAudioOn=false;
    mAudioOnTimer.stopRunningLocked(this);
  }
  getUidStatsLocked(uid).noteAudioTurnedOffLocked();
}",0.8775510204081632
183540,"public void noteWifiOffLocked(int uid){
  if (mWifiOn) {
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(this);
  }
  if (mWifiOnUid >= 0) {
    Uid u=mUidStats.get(mWifiOnUid);
    if (u != null) {
      u.noteWifiTurnedOffLocked();
    }
    mWifiOnUid=-1;
  }
}","public void noteWifiOffLocked(int uid){
  if (mWifiOn) {
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(this);
  }
  if (mWifiOnUid >= 0) {
    getUidStatsLocked(mWifiOnUid).noteWifiTurnedOffLocked();
    mWifiOnUid=-1;
  }
}",0.8406374501992032
183541,"public void noteAudioOnLocked(int uid){
  if (!mAudioOn) {
    mAudioOn=true;
    mAudioOnTimer.startRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteAudioTurnedOnLocked();
  }
}","public void noteAudioOnLocked(int uid){
  if (!mAudioOn) {
    mAudioOn=true;
    mAudioOnTimer.startRunningLocked(this);
  }
  getUidStatsLocked(uid).noteAudioTurnedOnLocked();
}",0.8769230769230769
183542,"public void noteVideoOffLocked(int uid){
  if (mVideoOn) {
    mVideoOn=false;
    mVideoOnTimer.stopRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteVideoTurnedOffLocked();
  }
}","public void noteVideoOffLocked(int uid){
  if (mVideoOn) {
    mVideoOn=false;
    mVideoOnTimer.stopRunningLocked(this);
  }
  getUidStatsLocked(uid).noteVideoTurnedOffLocked();
}",0.8775510204081632
183543,"public void noteWifiOnLocked(int uid){
  if (!mWifiOn) {
    mWifiOn=true;
    mWifiOnTimer.startRunningLocked(this);
  }
  if (mWifiOnUid != uid) {
    if (mWifiOnUid >= 0) {
      Uid u=mUidStats.get(mWifiOnUid);
      if (u != null) {
        u.noteWifiTurnedOffLocked();
      }
    }
    mWifiOnUid=uid;
    Uid u=mUidStats.get(uid);
    if (u != null) {
      u.noteWifiTurnedOnLocked();
    }
  }
}","public void noteWifiOnLocked(int uid){
  if (!mWifiOn) {
    mWifiOn=true;
    mWifiOnTimer.startRunningLocked(this);
  }
  if (mWifiOnUid != uid) {
    if (mWifiOnUid >= 0) {
      getUidStatsLocked(mWifiOnUid).noteWifiTurnedOffLocked();
    }
    mWifiOnUid=uid;
    getUidStatsLocked(uid).noteWifiTurnedOnLocked();
  }
}",0.5824175824175825
183544,"public void noteVideoOnLocked(int uid){
  if (!mVideoOn) {
    mVideoOn=true;
    mVideoOnTimer.startRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteVideoTurnedOnLocked();
  }
}","public void noteVideoOnLocked(int uid){
  if (!mVideoOn) {
    mVideoOn=true;
    mVideoOnTimer.startRunningLocked(this);
  }
  getUidStatsLocked(uid).noteVideoTurnedOnLocked();
}",0.8769230769230769
183545,"/** 
 * called from native code to update our status
 */
private void reportStatus(int status){
  if (VERBOSE)   Log.v(TAG,""String_Node_Str"" + status);
  boolean wasNavigating=mNavigating;
  mNavigating=(status == GPS_STATUS_SESSION_BEGIN);
  if (wasNavigating != mNavigating) {
    if (mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.acquire();
    }
synchronized (mListeners) {
      int size=mListeners.size();
      for (int i=0; i < size; i++) {
        Listener listener=mListeners.get(i);
        try {
          if (mNavigating) {
            listener.mListener.onGpsStarted();
          }
 else {
            listener.mListener.onGpsStopped();
          }
        }
 catch (        RemoteException e) {
          Log.w(TAG,""String_Node_Str"");
          mListeners.remove(listener);
          size--;
        }
      }
    }
    try {
      for (int i=mClientUids.size() - 1; i >= 0; i--) {
        int uid=mClientUids.keyAt(i);
        if (mNavigating) {
          mBatteryStats.noteStartGps(uid);
        }
 else {
          mBatteryStats.noteStopGps(uid);
        }
      }
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
    Intent intent=new Intent(GPS_ENABLED_CHANGE_ACTION);
    intent.putExtra(EXTRA_ENABLED,mNavigating);
    mContext.sendBroadcast(intent);
    if (!mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.release();
    }
  }
}","/** 
 * called from native code to update our status
 */
private void reportStatus(int status){
  if (VERBOSE)   Log.v(TAG,""String_Node_Str"" + status);
synchronized (mListeners) {
    boolean wasNavigating=mNavigating;
    mNavigating=(status == GPS_STATUS_SESSION_BEGIN);
    if (wasNavigating == mNavigating) {
      return;
    }
    if (mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.acquire();
    }
    int size=mListeners.size();
    for (int i=0; i < size; i++) {
      Listener listener=mListeners.get(i);
      try {
        if (mNavigating) {
          listener.mListener.onGpsStarted();
        }
 else {
          listener.mListener.onGpsStopped();
        }
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
        mListeners.remove(listener);
        size--;
      }
    }
    try {
      for (int i=mClientUids.size() - 1; i >= 0; i--) {
        int uid=mClientUids.keyAt(i);
        if (mNavigating) {
          mBatteryStats.noteStartGps(uid);
        }
 else {
          mBatteryStats.noteStopGps(uid);
        }
      }
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
    Intent intent=new Intent(GPS_ENABLED_CHANGE_ACTION);
    intent.putExtra(EXTRA_ENABLED,mNavigating);
    mContext.sendBroadcast(intent);
    if (!mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.release();
    }
  }
}",0.7651515151515151
183546,"public void addListener(int uid){
  mClientUids.put(uid,0);
  if (mNavigating) {
    try {
      mBatteryStats.noteStartGps(uid);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
  }
}","public void addListener(int uid){
synchronized (mListeners) {
    if (mClientUids.indexOfKey(uid) >= 0) {
      Log.w(TAG,""String_Node_Str"" + uid);
      return;
    }
    mClientUids.put(uid,0);
    if (mNavigating) {
      try {
        mBatteryStats.noteStartGps(uid);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
      }
    }
  }
}",0.2857142857142857
183547,"public void removeListener(int uid){
  mClientUids.delete(uid);
  if (mNavigating) {
    try {
      mBatteryStats.noteStopGps(uid);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
  }
}","public void removeListener(int uid){
synchronized (mListeners) {
    if (mClientUids.indexOfKey(uid) < 0) {
      Log.w(TAG,""String_Node_Str"" + uid);
      return;
    }
    mClientUids.delete(uid);
    if (mNavigating) {
      try {
        mBatteryStats.noteStopGps(uid);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
      }
    }
  }
}",0.296795952782462
183548,"public void noteAudioOffLocked(int uid){
  if (mAudioOn) {
    mAudioOn=false;
    mAudioOnTimer.stopRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteAudioTurnedOffLocked();
  }
}","public void noteAudioOffLocked(int uid){
  if (mAudioOn) {
    mAudioOn=false;
    mAudioOnTimer.stopRunningLocked(this);
  }
  getUidStatsLocked(uid).noteAudioTurnedOffLocked();
}",0.8775510204081632
183549,"public void noteWifiOffLocked(int uid){
  if (mWifiOn) {
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(this);
  }
  if (mWifiOnUid >= 0) {
    Uid u=mUidStats.get(mWifiOnUid);
    if (u != null) {
      u.noteWifiTurnedOffLocked();
    }
    mWifiOnUid=-1;
  }
}","public void noteWifiOffLocked(int uid){
  if (mWifiOn) {
    mWifiOn=false;
    mWifiOnTimer.stopRunningLocked(this);
  }
  if (mWifiOnUid >= 0) {
    getUidStatsLocked(mWifiOnUid).noteWifiTurnedOffLocked();
    mWifiOnUid=-1;
  }
}",0.8406374501992032
183550,"public void noteAudioOnLocked(int uid){
  if (!mAudioOn) {
    mAudioOn=true;
    mAudioOnTimer.startRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteAudioTurnedOnLocked();
  }
}","public void noteAudioOnLocked(int uid){
  if (!mAudioOn) {
    mAudioOn=true;
    mAudioOnTimer.startRunningLocked(this);
  }
  getUidStatsLocked(uid).noteAudioTurnedOnLocked();
}",0.8769230769230769
183551,"public void noteVideoOffLocked(int uid){
  if (mVideoOn) {
    mVideoOn=false;
    mVideoOnTimer.stopRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteVideoTurnedOffLocked();
  }
}","public void noteVideoOffLocked(int uid){
  if (mVideoOn) {
    mVideoOn=false;
    mVideoOnTimer.stopRunningLocked(this);
  }
  getUidStatsLocked(uid).noteVideoTurnedOffLocked();
}",0.8775510204081632
183552,"public void noteWifiOnLocked(int uid){
  if (!mWifiOn) {
    mWifiOn=true;
    mWifiOnTimer.startRunningLocked(this);
  }
  if (mWifiOnUid != uid) {
    if (mWifiOnUid >= 0) {
      Uid u=mUidStats.get(mWifiOnUid);
      if (u != null) {
        u.noteWifiTurnedOffLocked();
      }
    }
    mWifiOnUid=uid;
    Uid u=mUidStats.get(uid);
    if (u != null) {
      u.noteWifiTurnedOnLocked();
    }
  }
}","public void noteWifiOnLocked(int uid){
  if (!mWifiOn) {
    mWifiOn=true;
    mWifiOnTimer.startRunningLocked(this);
  }
  if (mWifiOnUid != uid) {
    if (mWifiOnUid >= 0) {
      getUidStatsLocked(mWifiOnUid).noteWifiTurnedOffLocked();
    }
    mWifiOnUid=uid;
    getUidStatsLocked(uid).noteWifiTurnedOnLocked();
  }
}",0.5824175824175825
183553,"public void noteVideoOnLocked(int uid){
  if (!mVideoOn) {
    mVideoOn=true;
    mVideoOnTimer.startRunningLocked(this);
  }
  Uid u=mUidStats.get(uid);
  if (u != null) {
    u.noteVideoTurnedOnLocked();
  }
}","public void noteVideoOnLocked(int uid){
  if (!mVideoOn) {
    mVideoOn=true;
    mVideoOnTimer.startRunningLocked(this);
  }
  getUidStatsLocked(uid).noteVideoTurnedOnLocked();
}",0.8769230769230769
183554,"/** 
 * called from native code to update our status
 */
private void reportStatus(int status){
  if (VERBOSE)   Log.v(TAG,""String_Node_Str"" + status);
  boolean wasNavigating=mNavigating;
  mNavigating=(status == GPS_STATUS_SESSION_BEGIN);
  if (wasNavigating != mNavigating) {
    if (mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.acquire();
    }
synchronized (mListeners) {
      int size=mListeners.size();
      for (int i=0; i < size; i++) {
        Listener listener=mListeners.get(i);
        try {
          if (mNavigating) {
            listener.mListener.onGpsStarted();
          }
 else {
            listener.mListener.onGpsStopped();
          }
        }
 catch (        RemoteException e) {
          Log.w(TAG,""String_Node_Str"");
          mListeners.remove(listener);
          size--;
        }
      }
    }
    try {
      for (int i=mClientUids.size() - 1; i >= 0; i--) {
        int uid=mClientUids.keyAt(i);
        if (mNavigating) {
          mBatteryStats.noteStartGps(uid);
        }
 else {
          mBatteryStats.noteStopGps(uid);
        }
      }
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
    Intent intent=new Intent(GPS_ENABLED_CHANGE_ACTION);
    intent.putExtra(EXTRA_ENABLED,mNavigating);
    mContext.sendBroadcast(intent);
    if (!mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.release();
    }
  }
}","/** 
 * called from native code to update our status
 */
private void reportStatus(int status){
  if (VERBOSE)   Log.v(TAG,""String_Node_Str"" + status);
synchronized (mListeners) {
    boolean wasNavigating=mNavigating;
    mNavigating=(status == GPS_STATUS_SESSION_BEGIN);
    if (wasNavigating == mNavigating) {
      return;
    }
    if (mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.acquire();
    }
    int size=mListeners.size();
    for (int i=0; i < size; i++) {
      Listener listener=mListeners.get(i);
      try {
        if (mNavigating) {
          listener.mListener.onGpsStarted();
        }
 else {
          listener.mListener.onGpsStopped();
        }
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
        mListeners.remove(listener);
        size--;
      }
    }
    try {
      for (int i=mClientUids.size() - 1; i >= 0; i--) {
        int uid=mClientUids.keyAt(i);
        if (mNavigating) {
          mBatteryStats.noteStartGps(uid);
        }
 else {
          mBatteryStats.noteStopGps(uid);
        }
      }
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
    Intent intent=new Intent(GPS_ENABLED_CHANGE_ACTION);
    intent.putExtra(EXTRA_ENABLED,mNavigating);
    mContext.sendBroadcast(intent);
    if (!mNavigating) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      mWakeLock.release();
    }
  }
}",0.7651515151515151
183555,"public void addListener(int uid){
  mClientUids.put(uid,0);
  if (mNavigating) {
    try {
      mBatteryStats.noteStartGps(uid);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
  }
}","public void addListener(int uid){
synchronized (mListeners) {
    if (mClientUids.indexOfKey(uid) >= 0) {
      Log.w(TAG,""String_Node_Str"" + uid);
      return;
    }
    mClientUids.put(uid,0);
    if (mNavigating) {
      try {
        mBatteryStats.noteStartGps(uid);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
      }
    }
  }
}",0.2857142857142857
183556,"public void removeListener(int uid){
  mClientUids.delete(uid);
  if (mNavigating) {
    try {
      mBatteryStats.noteStopGps(uid);
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"");
    }
  }
}","public void removeListener(int uid){
synchronized (mListeners) {
    if (mClientUids.indexOfKey(uid) < 0) {
      Log.w(TAG,""String_Node_Str"" + uid);
      return;
    }
    mClientUids.delete(uid);
    if (mNavigating) {
      try {
        mBatteryStats.noteStopGps(uid);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"");
      }
    }
  }
}",0.296795952782462
183557,"@Override public final void setBackgroundDrawable(Drawable drawable){
  if (drawable != mBackgroundDrawable) {
    mBackgroundResource=0;
    mBackgroundDrawable=drawable;
    if (mDecor != null) {
      mDecor.setWindowBackground(drawable);
    }
  }
}","@Override public final void setBackgroundDrawable(Drawable drawable){
  if (drawable != mBackgroundDrawable || mBackgroundResource != 0) {
    mBackgroundResource=0;
    mBackgroundDrawable=drawable;
    if (mDecor != null) {
      mDecor.setWindowBackground(drawable);
    }
  }
}",0.947565543071161
183558,"private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=app.setSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.info.packageName);
    if (app.instrumentationInfo != null) {
      ensurePackageDexOpt(app.instrumentationInfo.packageName);
    }
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Log.v(TAG,""String_Node_Str"" + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}","private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=app.setSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
    if (app.instrumentationClass != null) {
      ensurePackageDexOpt(app.instrumentationClass.getPackageName());
    }
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Log.v(TAG,""String_Node_Str"" + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}",0.9849274812778462
183559,"@Override public final void setBackgroundDrawable(Drawable drawable){
  if (drawable != mBackgroundDrawable) {
    mBackgroundResource=0;
    mBackgroundDrawable=drawable;
    if (mDecor != null) {
      mDecor.setWindowBackground(drawable);
    }
  }
}","@Override public final void setBackgroundDrawable(Drawable drawable){
  if (drawable != mBackgroundDrawable || mBackgroundResource != 0) {
    mBackgroundResource=0;
    mBackgroundDrawable=drawable;
    if (mDecor != null) {
      mDecor.setWindowBackground(drawable);
    }
  }
}",0.947565543071161
183560,"/** 
 * The default implementation returns the given amount of text from the current cursor position in the buffer.
 */
public CharSequence getTextBeforeCursor(int length,int flags){
  final Editable content=getEditable();
  if (content == null)   return null;
  int a=Selection.getSelectionStart(content);
  int b=Selection.getSelectionEnd(content);
  if (a > b) {
    int tmp=a;
    a=b;
    b=tmp;
  }
  if (length > a) {
    length=a;
  }
  if ((flags & GET_TEXT_WITH_STYLES) != 0) {
    return content.subSequence(a - length,a);
  }
  return TextUtils.substring(content,a - length,a);
}","/** 
 * The default implementation returns the given amount of text from the current cursor position in the buffer.
 */
public CharSequence getTextBeforeCursor(int length,int flags){
  final Editable content=getEditable();
  if (content == null)   return null;
  int a=Selection.getSelectionStart(content);
  int b=Selection.getSelectionEnd(content);
  if (a > b) {
    int tmp=a;
    a=b;
    b=tmp;
  }
  if (a <= 0) {
    return ""String_Node_Str"";
  }
  if (length > a) {
    length=a;
  }
  if ((flags & GET_TEXT_WITH_STYLES) != 0) {
    return content.subSequence(a - length,a);
  }
  return TextUtils.substring(content,a - length,a);
}",0.9594155844155844
183561,"private void replaceText(CharSequence text,int newCursorPosition,boolean composing){
  final Editable content=getEditable();
  if (content == null) {
    return;
  }
  beginBatchEdit();
  int a=getComposingSpanStart(content);
  int b=getComposingSpanEnd(content);
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ b);
  if (b < a) {
    int tmp=a;
    a=b;
    b=tmp;
  }
  if (a != -1 && b != -1) {
    removeComposingSpans(content);
  }
 else {
    a=Selection.getSelectionStart(content);
    b=Selection.getSelectionEnd(content);
    if (a >= 0 && b >= 0 && a != b) {
      if (b < a) {
        int tmp=a;
        a=b;
        b=tmp;
      }
    }
  }
  if (composing) {
    Spannable sp=null;
    if (!(text instanceof Spannable)) {
      sp=new SpannableStringBuilder(text);
      text=sp;
      if (mDefaultComposingSpans == null) {
        Context context;
        if (mTargetView != null) {
          context=mTargetView.getContext();
        }
 else         if (mIMM.mServedView != null) {
          context=mIMM.mServedView.getContext();
        }
 else {
          context=null;
        }
        if (context != null) {
          TypedArray ta=context.getTheme().obtainStyledAttributes(new int[]{com.android.internal.R.attr.candidatesTextStyleSpans});
          CharSequence style=ta.getText(0);
          ta.recycle();
          if (style != null && style instanceof Spanned) {
            mDefaultComposingSpans=((Spanned)style).getSpans(0,style.length(),Object.class);
          }
        }
      }
      if (mDefaultComposingSpans != null) {
        for (int i=0; i < mDefaultComposingSpans.length; ++i) {
          sp.setSpan(mDefaultComposingSpans[i],0,sp.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
      }
    }
 else {
      sp=(Spannable)text;
    }
    setComposingSpans(sp);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ b+ ""String_Node_Str""+ text+ ""String_Node_Str""+ composing+ ""String_Node_Str""+ text.getClass().getCanonicalName());
  if (DEBUG) {
    LogPrinter lp=new LogPrinter(Log.VERBOSE,TAG);
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(content,lp,""String_Node_Str"");
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(text,lp,""String_Node_Str"");
  }
  if (newCursorPosition > 0) {
    newCursorPosition+=b - 1;
  }
 else {
    newCursorPosition+=a;
  }
  if (newCursorPosition < 0)   newCursorPosition=0;
  if (newCursorPosition > content.length())   newCursorPosition=content.length();
  Selection.setSelection(content,newCursorPosition);
  content.replace(a,b,text);
  if (DEBUG) {
    LogPrinter lp=new LogPrinter(Log.VERBOSE,TAG);
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(content,lp,""String_Node_Str"");
  }
  endBatchEdit();
}","private void replaceText(CharSequence text,int newCursorPosition,boolean composing){
  final Editable content=getEditable();
  if (content == null) {
    return;
  }
  beginBatchEdit();
  int a=getComposingSpanStart(content);
  int b=getComposingSpanEnd(content);
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ b);
  if (b < a) {
    int tmp=a;
    a=b;
    b=tmp;
  }
  if (a != -1 && b != -1) {
    removeComposingSpans(content);
  }
 else {
    a=Selection.getSelectionStart(content);
    b=Selection.getSelectionEnd(content);
    if (a < 0)     a=0;
    if (b < 0)     b=0;
    if (b < a) {
      int tmp=a;
      a=b;
      b=tmp;
    }
  }
  if (composing) {
    Spannable sp=null;
    if (!(text instanceof Spannable)) {
      sp=new SpannableStringBuilder(text);
      text=sp;
      if (mDefaultComposingSpans == null) {
        Context context;
        if (mTargetView != null) {
          context=mTargetView.getContext();
        }
 else         if (mIMM.mServedView != null) {
          context=mIMM.mServedView.getContext();
        }
 else {
          context=null;
        }
        if (context != null) {
          TypedArray ta=context.getTheme().obtainStyledAttributes(new int[]{com.android.internal.R.attr.candidatesTextStyleSpans});
          CharSequence style=ta.getText(0);
          ta.recycle();
          if (style != null && style instanceof Spanned) {
            mDefaultComposingSpans=((Spanned)style).getSpans(0,style.length(),Object.class);
          }
        }
      }
      if (mDefaultComposingSpans != null) {
        for (int i=0; i < mDefaultComposingSpans.length; ++i) {
          sp.setSpan(mDefaultComposingSpans[i],0,sp.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
      }
    }
 else {
      sp=(Spannable)text;
    }
    setComposingSpans(sp);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ b+ ""String_Node_Str""+ text+ ""String_Node_Str""+ composing+ ""String_Node_Str""+ text.getClass().getCanonicalName());
  if (DEBUG) {
    LogPrinter lp=new LogPrinter(Log.VERBOSE,TAG);
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(content,lp,""String_Node_Str"");
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(text,lp,""String_Node_Str"");
  }
  if (newCursorPosition > 0) {
    newCursorPosition+=b - 1;
  }
 else {
    newCursorPosition+=a;
  }
  if (newCursorPosition < 0)   newCursorPosition=0;
  if (newCursorPosition > content.length())   newCursorPosition=content.length();
  Selection.setSelection(content,newCursorPosition);
  content.replace(a,b,text);
  if (DEBUG) {
    LogPrinter lp=new LogPrinter(Log.VERBOSE,TAG);
    lp.println(""String_Node_Str"");
    TextUtils.dumpSpans(content,lp,""String_Node_Str"");
  }
  endBatchEdit();
}",0.9720406681190996
183562,"protected void onReceiveResult(int resultCode,Bundle resultData){
  if (resultCode != InputMethodManager.RESULT_SHOWN) {
    Selection.setSelection((Spannable)mText,mNewStart,mNewEnd);
  }
}","protected void onReceiveResult(int resultCode,Bundle resultData){
  if (resultCode != InputMethodManager.RESULT_SHOWN) {
    final int len=mText.length();
    if (mNewStart > len) {
      mNewStart=len;
    }
    if (mNewEnd > len) {
      mNewEnd=len;
    }
    Selection.setSelection((Spannable)mText,mNewStart,mNewEnd);
  }
}",0.7335907335907336
183563,"private Rect sendOurVisibleRect(){
  Rect rect=new Rect();
  calcOurContentVisibleRect(rect);
  if (mFindIsUp) {
    rect.bottom-=viewToContent(FIND_HEIGHT);
  }
  if (!rect.equals(mLastVisibleRectSent)) {
    Point pos=new Point(rect.left,rect.top);
    mWebViewCore.sendMessage(EventHub.SET_SCROLL_OFFSET,nativeMoveGeneration(),0,pos);
    mLastVisibleRectSent=rect;
  }
  Rect globalRect=new Rect();
  if (getGlobalVisibleRect(globalRect) && !globalRect.equals(mLastGlobalRect)) {
    mWebViewCore.sendMessage(EventHub.SET_GLOBAL_BOUNDS,globalRect);
    mLastGlobalRect=globalRect;
  }
  return rect;
}","private Rect sendOurVisibleRect(){
  Rect rect=new Rect();
  calcOurContentVisibleRect(rect);
  if (!rect.equals(mLastVisibleRectSent)) {
    Point pos=new Point(rect.left,rect.top);
    mWebViewCore.sendMessage(EventHub.SET_SCROLL_OFFSET,nativeMoveGeneration(),0,pos);
    mLastVisibleRectSent=rect;
  }
  Rect globalRect=new Rect();
  if (getGlobalVisibleRect(globalRect) && !globalRect.equals(mLastGlobalRect)) {
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,""String_Node_Str"" + globalRect.left + ""String_Node_Str""+ globalRect.top+ ""String_Node_Str""+ globalRect.right+ ""String_Node_Str""+ globalRect.bottom);
    }
    mWebViewCore.sendMessage(EventHub.SET_GLOBAL_BOUNDS,globalRect);
    mLastGlobalRect=globalRect;
  }
  return rect;
}",0.7973273942093542
183564,"private void rebuildWebTextView(){
  if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus()) || (mTouchMode >= FIRST_SCROLL_ZOOM && mTouchMode <= LAST_SCROLL_ZOOM)) {
    return;
  }
  boolean alreadyThere=inEditingMode();
  if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
    if (alreadyThere) {
      mWebTextView.remove();
    }
    return;
  }
  if (mWebTextView == null) {
    mWebTextView=new WebTextView(mContext,WebView.this);
    mTextGeneration=0;
  }
  mWebTextView.setTextSize(contentToView(nativeFocusCandidateTextSize()));
  Rect visibleRect=sendOurVisibleRect();
  Rect bounds=nativeFocusCandidateNodeBounds();
  if (!Rect.intersects(bounds,visibleRect)) {
    return;
  }
  String text=nativeFocusCandidateText();
  int nodePointer=nativeFocusCandidatePointer();
  if (alreadyThere && mWebTextView.isSameTextField(nodePointer)) {
    Spannable spannable=(Spannable)mWebTextView.getText();
    int start=Selection.getSelectionStart(spannable);
    int end=Selection.getSelectionEnd(spannable);
    if (text != null && !text.equals(spannable.toString()) && nativeTextGeneration() == mTextGeneration) {
      mWebTextView.setTextAndKeepSelection(text);
    }
 else {
      Selection.setSelection(spannable,start,end);
    }
  }
 else {
    Rect vBox=contentToView(bounds);
    mWebTextView.setRect(vBox.left,vBox.top,vBox.width(),vBox.height());
    mWebTextView.setGravity(nativeFocusCandidateIsRtlText() ? Gravity.RIGHT : Gravity.NO_GRAVITY);
    mWebTextView.setNodePointer(nodePointer);
    int maxLength=-1;
    boolean isTextField=nativeFocusCandidateIsTextField();
    if (isTextField) {
      maxLength=nativeFocusCandidateMaxLength();
      String name=nativeFocusCandidateName();
      if (mWebViewCore.getSettings().getSaveFormData() && name != null) {
        Message update=mPrivateHandler.obtainMessage(REQUEST_FORM_DATA,nodePointer);
        RequestFormData updater=new RequestFormData(name,getUrl(),update);
        Thread t=new Thread(updater);
        t.start();
      }
    }
    mWebTextView.setMaxLength(maxLength);
    AutoCompleteAdapter adapter=null;
    mWebTextView.setAdapterCustom(adapter);
    mWebTextView.setSingleLine(isTextField);
    mWebTextView.setInPassword(nativeFocusCandidateIsPassword());
    if (null == text) {
      mWebTextView.setText(""String_Node_Str"",0,0);
    }
 else {
      if (false) {
        mWebTextView.setText(text,0,text.length());
      }
 else       if (isTextField) {
        int length=text.length();
        mWebTextView.setText(text,length,length);
      }
 else {
        mWebTextView.setText(text,0,0);
      }
    }
    mWebTextView.requestFocus();
  }
}","private void rebuildWebTextView(){
  if (!hasFocus() && (null == mWebTextView || !mWebTextView.hasFocus()) || (mTouchMode >= FIRST_SCROLL_ZOOM && mTouchMode <= LAST_SCROLL_ZOOM)) {
    return;
  }
  boolean alreadyThere=inEditingMode();
  if (0 == mNativeClass || !nativeFocusCandidateIsTextInput()) {
    if (alreadyThere) {
      mWebTextView.remove();
    }
    return;
  }
  if (mWebTextView == null) {
    mWebTextView=new WebTextView(mContext,WebView.this);
    mTextGeneration=0;
  }
  mWebTextView.setTextSize(contentToView(nativeFocusCandidateTextSize()));
  Rect visibleRect=new Rect();
  calcOurContentVisibleRect(visibleRect);
  Rect bounds=nativeFocusCandidateNodeBounds();
  if (!Rect.intersects(bounds,visibleRect)) {
    return;
  }
  String text=nativeFocusCandidateText();
  int nodePointer=nativeFocusCandidatePointer();
  if (alreadyThere && mWebTextView.isSameTextField(nodePointer)) {
    Spannable spannable=(Spannable)mWebTextView.getText();
    int start=Selection.getSelectionStart(spannable);
    int end=Selection.getSelectionEnd(spannable);
    if (text != null && !text.equals(spannable.toString()) && nativeTextGeneration() == mTextGeneration) {
      mWebTextView.setTextAndKeepSelection(text);
    }
 else {
      Selection.setSelection(spannable,start,end);
    }
  }
 else {
    Rect vBox=contentToView(bounds);
    mWebTextView.setRect(vBox.left,vBox.top,vBox.width(),vBox.height());
    mWebTextView.setGravity(nativeFocusCandidateIsRtlText() ? Gravity.RIGHT : Gravity.NO_GRAVITY);
    mWebTextView.setNodePointer(nodePointer);
    int maxLength=-1;
    boolean isTextField=nativeFocusCandidateIsTextField();
    if (isTextField) {
      maxLength=nativeFocusCandidateMaxLength();
      String name=nativeFocusCandidateName();
      if (mWebViewCore.getSettings().getSaveFormData() && name != null) {
        Message update=mPrivateHandler.obtainMessage(REQUEST_FORM_DATA,nodePointer);
        RequestFormData updater=new RequestFormData(name,getUrl(),update);
        Thread t=new Thread(updater);
        t.start();
      }
    }
    mWebTextView.setMaxLength(maxLength);
    AutoCompleteAdapter adapter=null;
    mWebTextView.setAdapterCustom(adapter);
    mWebTextView.setSingleLine(isTextField);
    mWebTextView.setInPassword(nativeFocusCandidateIsPassword());
    if (null == text) {
      mWebTextView.setText(""String_Node_Str"",0,0);
    }
 else {
      if (false) {
        mWebTextView.setText(text,0,text.length());
      }
 else       if (isTextField) {
        int length=text.length();
        mWebTextView.setText(text,length,length);
      }
 else {
        mWebTextView.setText(text,0,0);
      }
    }
    mWebTextView.requestFocus();
  }
}",0.992534527808884
183565,"private void calcOurVisibleRect(Rect r){
  Point p=new Point();
  getGlobalVisibleRect(r,p);
  r.offset(-p.x,-p.y);
}","private void calcOurVisibleRect(Rect r){
  Point p=new Point();
  getGlobalVisibleRect(r,p);
  r.offset(-p.x,-p.y);
  if (mFindIsUp) {
    r.bottom-=FIND_HEIGHT;
  }
}",0.823943661971831
183566,"private void updateSharedUserPerms(PackageSetting deletedPs){
  if ((deletedPs == null) || (deletedPs.pkg == null)) {
    Log.i(TAG,""String_Node_Str"");
    return;
  }
  if (deletedPs.sharedUser == null) {
    return;
  }
  SharedUserSetting sus=deletedPs.sharedUser;
  for (  String eachPerm : deletedPs.pkg.requestedPermissions) {
    boolean used=false;
    if (!sus.grantedPermissions.contains(eachPerm)) {
      continue;
    }
    for (    PackageSetting pkg : sus.packages) {
      if (pkg.grantedPermissions.contains(eachPerm)) {
        used=true;
        break;
      }
    }
    if (!used) {
      sus.grantedPermissions.remove(eachPerm);
      sus.loadedPermissions.remove(eachPerm);
    }
  }
  int newGids[]=null;
  for (  PackageSetting pkg : sus.packages) {
    newGids=appendInts(newGids,pkg.gids);
  }
  sus.gids=newGids;
}","private void updateSharedUserPerms(PackageSetting deletedPs){
  if ((deletedPs == null) || (deletedPs.pkg == null)) {
    Log.i(TAG,""String_Node_Str"");
    return;
  }
  if (deletedPs.sharedUser == null) {
    return;
  }
  SharedUserSetting sus=deletedPs.sharedUser;
  for (  String eachPerm : deletedPs.pkg.requestedPermissions) {
    boolean used=false;
    if (!sus.grantedPermissions.contains(eachPerm)) {
      continue;
    }
    for (    PackageSetting pkg : sus.packages) {
      if (pkg.pkg.requestedPermissions.contains(eachPerm)) {
        used=true;
        break;
      }
    }
    if (!used) {
      sus.grantedPermissions.remove(eachPerm);
      sus.loadedPermissions.remove(eachPerm);
    }
  }
  int newGids[]=null;
  for (  PackageSetting pkg : sus.packages) {
    newGids=appendInts(newGids,pkg.gids);
  }
  sus.gids=newGids;
}",0.9917061611374408
183567,"/** 
 * Start a new activity and wait for it to begin running before returning. In addition to being synchronous, this method as some semantic differences from the standard   {@link Context#startActivity} call: theactivity component is resolved before talking with the activity manager (its class name is specified in the Intent that this method ultimately starts), and it does not allow you to start activities that run in a different process.  In addition, if the given Intent resolves to multiple activities, instead of displaying a dialog for the user to select an activity, an exception will be thrown. <p>The function returns as soon as the activity goes idle following the call to its  {@link Activity#onCreate}.  Generally this means it has gone through the full initialization including   {@link Activity#onResume} anddrawn and displayed its initial window.
 * @param intent Description of the activity to start.
 * @see Context#startActivity
 */
public Activity startActivitySync(Intent intent){
  validateNotAppThread();
synchronized (mSync) {
    intent=new Intent(intent);
    ActivityInfo ai=intent.resolveActivityInfo(getTargetContext().getPackageManager(),0);
    if (ai == null) {
      throw new RuntimeException(""String_Node_Str"" + intent);
    }
    if (!ai.applicationInfo.processName.equals(getTargetContext().getPackageName())) {
      throw new RuntimeException(""String_Node_Str"" + ai.applicationInfo.packageName + ""String_Node_Str""+ intent);
    }
    intent.setComponent(new ComponentName(ai.applicationInfo.packageName,ai.name));
    final ActivityWaiter aw=new ActivityWaiter(intent);
    if (mWaitingActivities == null) {
      mWaitingActivities=new ArrayList();
    }
    mWaitingActivities.add(aw);
    getTargetContext().startActivity(intent);
    do {
      try {
        mSync.wait();
      }
 catch (      InterruptedException e) {
      }
    }
 while (mWaitingActivities.contains(aw));
    return aw.activity;
  }
}","/** 
 * Start a new activity and wait for it to begin running before returning. In addition to being synchronous, this method as some semantic differences from the standard   {@link Context#startActivity} call: theactivity component is resolved before talking with the activity manager (its class name is specified in the Intent that this method ultimately starts), and it does not allow you to start activities that run in a different process.  In addition, if the given Intent resolves to multiple activities, instead of displaying a dialog for the user to select an activity, an exception will be thrown. <p>The function returns as soon as the activity goes idle following the call to its  {@link Activity#onCreate}.  Generally this means it has gone through the full initialization including   {@link Activity#onResume} anddrawn and displayed its initial window.
 * @param intent Description of the activity to start.
 * @see Context#startActivity
 */
public Activity startActivitySync(Intent intent){
  validateNotAppThread();
synchronized (mSync) {
    intent=new Intent(intent);
    ActivityInfo ai=intent.resolveActivityInfo(getTargetContext().getPackageManager(),0);
    if (ai == null) {
      throw new RuntimeException(""String_Node_Str"" + intent);
    }
    String myProc=mThread.getProcessName();
    if (!ai.processName.equals(myProc)) {
      throw new RuntimeException(""String_Node_Str"" + myProc + ""String_Node_Str""+ ai.processName+ ""String_Node_Str""+ intent);
    }
    intent.setComponent(new ComponentName(ai.applicationInfo.packageName,ai.name));
    final ActivityWaiter aw=new ActivityWaiter(intent);
    if (mWaitingActivities == null) {
      mWaitingActivities=new ArrayList();
    }
    mWaitingActivities.add(aw);
    getTargetContext().startActivity(intent);
    do {
      try {
        mSync.wait();
      }
 catch (      InterruptedException e) {
      }
    }
 while (mWaitingActivities.contains(aw));
    return aw.activity;
  }
}",0.95658835546476
183568,"/** 
 * Sends a series of key events through instrumentation and waits for idle. For instance: sendKeys(KEYCODE_DPAD_LEFT, KEYCODE_DPAD_CENTER).
 * @param keys The series of key codes to send through instrumentation.
 */
public void sendKeys(int... keys){
  final int count=keys.length;
  final Instrumentation instrumentation=getInstrumentation();
  for (int i=0; i < count; i++) {
    instrumentation.sendKeyDownUpSync(keys[i]);
  }
  instrumentation.waitForIdleSync();
}","/** 
 * Sends a series of key events through instrumentation and waits for idle. For instance: sendKeys(KEYCODE_DPAD_LEFT, KEYCODE_DPAD_CENTER).
 * @param keys The series of key codes to send through instrumentation.
 */
public void sendKeys(int... keys){
  final int count=keys.length;
  final Instrumentation instrumentation=getInstrumentation();
  for (int i=0; i < count; i++) {
    try {
      instrumentation.sendKeyDownUpSync(keys[i]);
    }
 catch (    SecurityException e) {
    }
  }
  instrumentation.waitForIdleSync();
}",0.9412935323383084
183569,"/** 
 * Sends a series of key events through instrumentation and waits for idle. Each key code must be preceded by the number of times the key code must be sent. For instance: sendRepeatedKeys(1, KEYCODE_DPAD_CENTER, 2, KEYCODE_DPAD_LEFT).
 * @param keys The series of key repeats and codes to send through instrumentation.
 */
public void sendRepeatedKeys(int... keys){
  final int count=keys.length;
  if ((count & 0x1) == 0x1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final Instrumentation instrumentation=getInstrumentation();
  for (int i=0; i < count; i+=2) {
    final int keyCount=keys[i];
    final int keyCode=keys[i + 1];
    for (int j=0; j < keyCount; j++) {
      instrumentation.sendKeyDownUpSync(keyCode);
    }
  }
  instrumentation.waitForIdleSync();
}","/** 
 * Sends a series of key events through instrumentation and waits for idle. Each key code must be preceded by the number of times the key code must be sent. For instance: sendRepeatedKeys(1, KEYCODE_DPAD_CENTER, 2, KEYCODE_DPAD_LEFT).
 * @param keys The series of key repeats and codes to send through instrumentation.
 */
public void sendRepeatedKeys(int... keys){
  final int count=keys.length;
  if ((count & 0x1) == 0x1) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final Instrumentation instrumentation=getInstrumentation();
  for (int i=0; i < count; i+=2) {
    final int keyCount=keys[i];
    final int keyCode=keys[i + 1];
    for (int j=0; j < keyCount; j++) {
      try {
        instrumentation.sendKeyDownUpSync(keyCode);
      }
 catch (      SecurityException e) {
      }
    }
  }
  instrumentation.waitForIdleSync();
}",0.9605650382577988
183570,"TimeStats(Parcel in){
  final int[] localTimes=times;
  for (int i=0; i < NUM_LAUNCH_TIME_BINS; i++) {
    localTimes[i]=in.readInt();
  }
}","TimeStats(Parcel in){
  count=in.readInt();
  final int[] localTimes=times;
  for (int i=0; i < NUM_LAUNCH_TIME_BINS; i++) {
    localTimes[i]=in.readInt();
  }
}",0.9271523178807948
183571,"public void noteResumeComponent(ComponentName componentName){
  enforceCallingPermission();
  String pkgName;
  if ((componentName == null) || ((pkgName=componentName.getPackageName()) == null)) {
    return;
  }
  if ((mResumedPkg != null) && (mResumedPkg.equalsIgnoreCase(pkgName))) {
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + pkgName);
synchronized (mStatsLock) {
    PkgUsageStatsExtended pus=mStats.get(pkgName);
    if (pus == null) {
      pus=new PkgUsageStatsExtended();
      mStats.put(pkgName,pus);
    }
    pus.updateResume();
  }
  mResumedPkg=pkgName;
}","public void noteResumeComponent(ComponentName componentName){
  enforceCallingPermission();
  String pkgName;
synchronized (mStatsLock) {
    if ((componentName == null) || ((pkgName=componentName.getPackageName()) == null)) {
      return;
    }
    final boolean samePackage=pkgName.equals(mLastResumedPkg);
    if (mIsResumed) {
      if (samePackage) {
        Log.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
        return;
      }
      if (mLastResumedPkg != null) {
        Log.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str""+ mLastResumedPkg);
        PkgUsageStatsExtended pus=mStats.get(mLastResumedPkg);
        if (pus != null) {
          pus.updatePause();
        }
      }
    }
    final boolean sameComp=samePackage && componentName.getClassName().equals(mLastResumedComp);
    mIsResumed=true;
    mLastResumedPkg=pkgName;
    mLastResumedComp=componentName.getClassName();
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PkgUsageStatsExtended pus=mStats.get(pkgName);
    if (pus == null) {
      pus=new PkgUsageStatsExtended();
      mStats.put(pkgName,pus);
    }
    pus.updateResume(!samePackage);
    if (!sameComp) {
      pus.addLaunchCount(mLastResumedComp);
    }
  }
}",0.4756697648988518
183572,"private void collectDumpInfoFromParcelFLOCK(Parcel in,PrintWriter pw,String date,boolean isCompactOutput){
  StringBuilder sb=new StringBuilder(512);
  if (isCompactOutput) {
    sb.append(""String_Node_Str"");
    sb.append(CHECKIN_VERSION);
    sb.append(',');
  }
 else {
    sb.append(""String_Node_Str"");
  }
  sb.append(date);
  int vers=in.readInt();
  if (vers != VERSION) {
    sb.append(""String_Node_Str"");
    pw.println(sb.toString());
    return;
  }
  pw.println(sb.toString());
  int N=in.readInt();
  while (N > 0) {
    N--;
    String pkgName=in.readString();
    if (pkgName == null) {
      break;
    }
    sb.setLength(0);
    PkgUsageStatsExtended pus=new PkgUsageStatsExtended(in);
    if (isCompactOutput) {
      sb.append(""String_Node_Str"");
      sb.append(pkgName);
      sb.append(""String_Node_Str"");
      sb.append(pus.mLaunchCount);
      sb.append(""String_Node_Str"");
      sb.append(pus.mUsageTime);
      sb.append('\n');
      final int NC=pus.mLaunchTimes.size();
      if (NC > 0) {
        for (        Map.Entry<String,TimeStats> ent : pus.mLaunchTimes.entrySet()) {
          sb.append(""String_Node_Str"");
          sb.append(ent.getKey());
          TimeStats times=ent.getValue();
          for (int i=0; i < NUM_LAUNCH_TIME_BINS; i++) {
            sb.append(""String_Node_Str"");
            sb.append(times.times[i]);
          }
          sb.append('\n');
        }
      }
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(pkgName);
      sb.append(""String_Node_Str"");
      sb.append(pus.mLaunchCount);
      sb.append(""String_Node_Str"");
      sb.append(pus.mUsageTime);
      sb.append(""String_Node_Str"");
      sb.append('\n');
      final int NC=pus.mLaunchTimes.size();
      if (NC > 0) {
        for (        Map.Entry<String,TimeStats> ent : pus.mLaunchTimes.entrySet()) {
          sb.append(""String_Node_Str"");
          sb.append(ent.getKey());
          TimeStats times=ent.getValue();
          int lastBin=0;
          boolean first=true;
          for (int i=0; i < NUM_LAUNCH_TIME_BINS - 1; i++) {
            if (times.times[i] != 0) {
              sb.append(first ? ""String_Node_Str"" : ""String_Node_Str"");
              sb.append(lastBin);
              sb.append('-');
              sb.append(LAUNCH_TIME_BINS[i]);
              sb.append('=');
              sb.append(times.times[i]);
              first=false;
            }
            lastBin=LAUNCH_TIME_BINS[i];
          }
          if (times.times[NUM_LAUNCH_TIME_BINS - 1] != 0) {
            sb.append(first ? ""String_Node_Str"" : ""String_Node_Str"");
            sb.append(""String_Node_Str"");
            sb.append(lastBin);
            sb.append('=');
            sb.append(times.times[NUM_LAUNCH_TIME_BINS - 1]);
          }
          sb.append('\n');
        }
      }
    }
    pw.write(sb.toString());
  }
}","private void collectDumpInfoFromParcelFLOCK(Parcel in,PrintWriter pw,String date,boolean isCompactOutput){
  StringBuilder sb=new StringBuilder(512);
  if (isCompactOutput) {
    sb.append(""String_Node_Str"");
    sb.append(CHECKIN_VERSION);
    sb.append(',');
  }
 else {
    sb.append(""String_Node_Str"");
  }
  sb.append(date);
  int vers=in.readInt();
  if (vers != VERSION) {
    sb.append(""String_Node_Str"");
    pw.println(sb.toString());
    return;
  }
  pw.println(sb.toString());
  int N=in.readInt();
  while (N > 0) {
    N--;
    String pkgName=in.readString();
    if (pkgName == null) {
      break;
    }
    sb.setLength(0);
    PkgUsageStatsExtended pus=new PkgUsageStatsExtended(in);
    if (isCompactOutput) {
      sb.append(""String_Node_Str"");
      sb.append(pkgName);
      sb.append(',');
      sb.append(pus.mLaunchCount);
      sb.append(',');
      sb.append(pus.mUsageTime);
      sb.append('\n');
      final int NC=pus.mLaunchTimes.size();
      if (NC > 0) {
        for (        Map.Entry<String,TimeStats> ent : pus.mLaunchTimes.entrySet()) {
          sb.append(""String_Node_Str"");
          sb.append(ent.getKey());
          TimeStats times=ent.getValue();
          sb.append(',');
          sb.append(times.count);
          for (int i=0; i < NUM_LAUNCH_TIME_BINS; i++) {
            sb.append(""String_Node_Str"");
            sb.append(times.times[i]);
          }
          sb.append('\n');
        }
      }
    }
 else {
      sb.append(""String_Node_Str"");
      sb.append(pkgName);
      sb.append(""String_Node_Str"");
      sb.append(pus.mLaunchCount);
      sb.append(""String_Node_Str"");
      sb.append(pus.mUsageTime);
      sb.append(""String_Node_Str"");
      sb.append('\n');
      final int NC=pus.mLaunchTimes.size();
      if (NC > 0) {
        for (        Map.Entry<String,TimeStats> ent : pus.mLaunchTimes.entrySet()) {
          sb.append(""String_Node_Str"");
          sb.append(ent.getKey());
          TimeStats times=ent.getValue();
          sb.append(""String_Node_Str"");
          sb.append(times.count);
          sb.append(""String_Node_Str"");
          int lastBin=0;
          for (int i=0; i < NUM_LAUNCH_TIME_BINS - 1; i++) {
            if (times.times[i] != 0) {
              sb.append(""String_Node_Str"");
              sb.append(lastBin);
              sb.append('-');
              sb.append(LAUNCH_TIME_BINS[i]);
              sb.append(""String_Node_Str"");
              sb.append(times.times[i]);
            }
            lastBin=LAUNCH_TIME_BINS[i];
          }
          if (times.times[NUM_LAUNCH_TIME_BINS - 1] != 0) {
            sb.append(""String_Node_Str"");
            sb.append(""String_Node_Str"");
            sb.append(lastBin);
            sb.append(""String_Node_Str"");
            sb.append(times.times[NUM_LAUNCH_TIME_BINS - 1]);
          }
          sb.append('\n');
        }
      }
    }
    pw.write(sb.toString());
  }
}",0.9363399826539462
183573,"public void notePauseComponent(ComponentName componentName){
  enforceCallingPermission();
  String pkgName;
  if ((componentName == null) || ((pkgName=componentName.getPackageName()) == null)) {
    return;
  }
  if ((mResumedPkg == null) || (!pkgName.equalsIgnoreCase(mResumedPkg))) {
    Log.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + pkgName);
  writeStatsToFile(false);
synchronized (mStatsLock) {
    PkgUsageStatsExtended pus=mStats.get(pkgName);
    if (pus == null) {
      Log.w(TAG,""String_Node_Str"" + pkgName);
      return;
    }
    pus.updatePause();
  }
}","public void notePauseComponent(ComponentName componentName){
  enforceCallingPermission();
synchronized (mStatsLock) {
    String pkgName;
    if ((componentName == null) || ((pkgName=componentName.getPackageName()) == null)) {
      return;
    }
    if (!mIsResumed) {
      Log.w(TAG,""String_Node_Str"" + pkgName + ""String_Node_Str"");
      return;
    }
    mIsResumed=false;
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + pkgName);
    PkgUsageStatsExtended pus=mStats.get(pkgName);
    if (pus == null) {
      Log.w(TAG,""String_Node_Str"" + pkgName);
      return;
    }
    pus.updatePause();
  }
  writeStatsToFile(false);
}",0.7807153965785381
183574,"void updateResume(){
  mLaunchCount++;
  mResumedTime=SystemClock.elapsedRealtime();
}","void updateResume(boolean launched){
  if (launched) {
    mLaunchCount++;
  }
  mResumedTime=SystemClock.elapsedRealtime();
}",0.8113207547169812
183575,"/** 
 * @see AudioManager#setRouting(int,int,int) 
 */
public void setRouting(int mode,int routes,int mask){
  int incallMask=0;
  int ringtoneMask=0;
  int normalMask=0;
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_INVALID) {
switch (mask) {
case AudioSystem.ROUTE_SPEAKER:
        if (routes != 0 && !mSpeakerIsOn) {
          mSpeakerIsOn=true;
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
          incallMask=AudioSystem.ROUTE_ALL;
        }
 else         if (mSpeakerIsOn) {
          mSpeakerIsOn=false;
          if (mBluetoothScoIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
          }
 else           if (mHeadsetIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
          }
 else {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
          }
          incallMask=AudioSystem.ROUTE_ALL;
        }
      break;
case AudioSystem.ROUTE_BLUETOOTH_SCO:
    if (routes != 0 && !mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=true;
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
 else     if (mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=false;
      if (mHeadsetIsConnected) {
        mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
      }
 else {
        if (mSpeakerIsOn) {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
        }
 else {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
        }
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
      }
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
  break;
case AudioSystem.ROUTE_HEADSET:
if (routes != 0 && !mHeadsetIsConnected) {
  mHeadsetIsConnected=true;
  if (!mBluetoothScoIsConnected) {
    mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
 else if (mHeadsetIsConnected) {
  mHeadsetIsConnected=false;
  if (!mBluetoothScoIsConnected) {
    if (mSpeakerIsOn) {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
    }
 else {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
    }
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
break;
case AudioSystem.ROUTE_BLUETOOTH_A2DP:
if (routes != 0 && !mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=true;
mRoutes[AudioSystem.MODE_RINGTONE]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
 else if (mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=false;
mRoutes[AudioSystem.MODE_RINGTONE]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
break;
}
if (incallMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_IN_CALL,mRoutes[AudioSystem.MODE_IN_CALL],incallMask);
}
if (ringtoneMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_RINGTONE,mRoutes[AudioSystem.MODE_RINGTONE],ringtoneMask);
}
if (normalMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_NORMAL,mRoutes[AudioSystem.MODE_NORMAL],normalMask);
}
int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
int index=mStreamStates[streamType].mIndex;
syncRingerAndNotificationStreamVolume(streamType,index,true);
setStreamVolumeInt(streamType,index,true,true);
}
}
}","/** 
 * @see AudioManager#setRouting(int,int,int) 
 */
public void setRouting(int mode,int routes,int mask){
  int incallMask=0;
  int ringtoneMask=0;
  int normalMask=0;
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_INVALID) {
switch (mask) {
case AudioSystem.ROUTE_SPEAKER:
        if (routes != 0 && !mSpeakerIsOn) {
          mSpeakerIsOn=true;
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
          incallMask=AudioSystem.ROUTE_ALL;
        }
 else         if (routes == 0 && mSpeakerIsOn) {
          mSpeakerIsOn=false;
          if (mBluetoothScoIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
          }
 else           if (mHeadsetIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
          }
 else {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
          }
          incallMask=AudioSystem.ROUTE_ALL;
        }
      break;
case AudioSystem.ROUTE_BLUETOOTH_SCO:
    if (routes != 0 && !mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=true;
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
 else     if (routes == 0 && mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=false;
      if (mHeadsetIsConnected) {
        mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
      }
 else {
        if (mSpeakerIsOn) {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
        }
 else {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
        }
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
      }
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
  break;
case AudioSystem.ROUTE_HEADSET:
if (routes != 0 && !mHeadsetIsConnected) {
  mHeadsetIsConnected=true;
  if (!mBluetoothScoIsConnected) {
    mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
 else if (routes == 0 && mHeadsetIsConnected) {
  mHeadsetIsConnected=false;
  if (!mBluetoothScoIsConnected) {
    if (mSpeakerIsOn) {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
    }
 else {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
    }
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
break;
case AudioSystem.ROUTE_BLUETOOTH_A2DP:
if (routes != 0 && !mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=true;
mRoutes[AudioSystem.MODE_RINGTONE]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
 else if (routes == 0 && mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=false;
mRoutes[AudioSystem.MODE_RINGTONE]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
break;
}
if (incallMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_IN_CALL,mRoutes[AudioSystem.MODE_IN_CALL],incallMask);
}
if (ringtoneMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_RINGTONE,mRoutes[AudioSystem.MODE_RINGTONE],ringtoneMask);
}
if (normalMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_NORMAL,mRoutes[AudioSystem.MODE_NORMAL],normalMask);
}
int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
int index=mStreamStates[streamType].mIndex;
syncRingerAndNotificationStreamVolume(streamType,index,true);
setStreamVolumeInt(streamType,index,true,true);
}
}
}",0.9947423764458464
183576,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  for (  DataConnection connBase : dataConnectionList) {
    CdmaDataConnection conn=(CdmaDataConnection)connBase;
    if (conn != null) {
      if (tearDown) {
        Message msg=obtainMessage(EVENT_DISCONNECT_DONE,reason);
        conn.disconnect(msg);
      }
 else {
        conn.clearSettings();
      }
    }
  }
  stopNetStatPoll();
  if (!tearDown) {
    setState(State.IDLE);
    phone.notifyDataConnection(reason);
  }
 else   if (state != State.IDLE) {
    setState(State.DISCONNECTING);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying DataConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  for (  DataConnection connBase : dataConnectionList) {
    CdmaDataConnection conn=(CdmaDataConnection)connBase;
    if (conn != null) {
      if (tearDown) {
        Message msg=obtainMessage(EVENT_DISCONNECT_DONE,reason);
        conn.disconnect(msg);
      }
 else {
        conn.clearSettings();
      }
    }
  }
  stopNetStatPoll();
  if (!tearDown) {
    setState(State.IDLE);
    phone.notifyDataConnection(reason);
  }
}",0.9548713622943904
183577,"/** 
 * @override com.android.internal.telephony.DataConnectionTracker
 */
protected void onVoiceCallEnded(){
  if (state == State.CONNECTED) {
    if (!mCdmaPhone.mSST.isConcurrentVoiceAndData()) {
      startNetStatPoll();
      phone.notifyDataConnection(Phone.REASON_VOICE_CALL_ENDED);
    }
 else {
      resetPollStats();
    }
  }
 else {
    trySetupData(Phone.REASON_VOICE_CALL_ENDED);
  }
}","/** 
 * @override com.android.internal.telephony.DataConnectionTracker
 */
protected void onVoiceCallEnded(){
  if (state == State.CONNECTED) {
    if (!mCdmaPhone.mSST.isConcurrentVoiceAndData()) {
      startNetStatPoll();
      phone.notifyDataConnection(Phone.REASON_VOICE_CALL_ENDED);
    }
 else {
      resetPollStats();
    }
  }
 else {
    nextReconnectDelay=RECONNECT_DELAY_INITIAL_MILLIS;
    trySetupData(Phone.REASON_VOICE_CALL_ENDED);
  }
}",0.935672514619883
183578,"/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying PdpConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  for (  DataConnection conn : pdpList) {
    PdpConnection pdp=(PdpConnection)conn;
    if (tearDown) {
      Message msg=obtainMessage(EVENT_DISCONNECT_DONE,reason);
      pdp.disconnect(msg);
    }
 else {
      pdp.clearSettings();
    }
  }
  stopNetStatPoll();
  if (!tearDown) {
    setState(State.IDLE);
    phone.notifyDataConnection(reason);
    mActiveApn=null;
  }
 else   if (state != State.IDLE) {
    setState(State.DISCONNECTING);
  }
}","/** 
 * If tearDown is true, this only tears down a CONNECTED session. Presently, there is no mechanism for abandoning an INITING/CONNECTING session, but would likely involve cancelling pending async requests or setting a flag or new state to ignore them when they came in
 * @param tearDown true if the underlying PdpConnection should bedisconnected.
 * @param reason reason for the clean up.
 */
private void cleanUpConnection(boolean tearDown,String reason){
  if (DBG)   log(""String_Node_Str"" + reason);
  if (mReconnectIntent != null) {
    AlarmManager am=(AlarmManager)phone.getContext().getSystemService(Context.ALARM_SERVICE);
    am.cancel(mReconnectIntent);
    mReconnectIntent=null;
  }
  setState(State.DISCONNECTING);
  for (  DataConnection conn : pdpList) {
    PdpConnection pdp=(PdpConnection)conn;
    if (tearDown) {
      Message msg=obtainMessage(EVENT_DISCONNECT_DONE,reason);
      pdp.disconnect(msg);
    }
 else {
      pdp.clearSettings();
    }
  }
  stopNetStatPoll();
  if (!tearDown) {
    setState(State.IDLE);
    phone.notifyDataConnection(reason);
    mActiveApn=null;
  }
}",0.9527176314626602
183579,"/** 
 * Handles changes to the APN database.
 */
private void onApnChanged(){
  boolean isConnected;
  isConnected=(state != State.IDLE && state != State.FAILED);
  ((GSMPhone)phone).updateCurrentCarrierInProvider();
  createAllApnList();
  if (state != State.DISCONNECTING) {
    cleanUpConnection(isConnected,Phone.REASON_APN_CHANGED);
    if (!isConnected) {
      trySetupData(Phone.REASON_APN_CHANGED);
    }
  }
}","/** 
 * Handles changes to the APN database.
 */
private void onApnChanged(){
  boolean isConnected;
  isConnected=(state != State.IDLE && state != State.FAILED);
  ((GSMPhone)phone).updateCurrentCarrierInProvider();
  createAllApnList();
  if (state != State.DISCONNECTING) {
    cleanUpConnection(isConnected,Phone.REASON_APN_CHANGED);
    if (!isConnected) {
      nextReconnectDelay=RECONNECT_DELAY_INITIAL_MILLIS;
      trySetupData(Phone.REASON_APN_CHANGED);
    }
  }
}",0.9318435754189944
183580,"protected void onVoiceCallEnded(){
  if (state == State.CONNECTED) {
    if (!((GSMPhone)phone).mSST.isConcurrentVoiceAndData()) {
      startNetStatPoll();
      phone.notifyDataConnection(Phone.REASON_VOICE_CALL_ENDED);
    }
 else {
      resetPollStats();
    }
  }
 else {
    trySetupData(Phone.REASON_VOICE_CALL_ENDED);
  }
}","protected void onVoiceCallEnded(){
  if (state == State.CONNECTED) {
    if (!((GSMPhone)phone).mSST.isConcurrentVoiceAndData()) {
      startNetStatPoll();
      phone.notifyDataConnection(Phone.REASON_VOICE_CALL_ENDED);
    }
 else {
      resetPollStats();
    }
  }
 else {
    nextReconnectDelay=RECONNECT_DELAY_INITIAL_MILLIS;
    trySetupData(Phone.REASON_VOICE_CALL_ENDED);
  }
}",0.9235048678720446
183581,"public int performBackup(PackageInfo packageInfo,ParcelFileDescriptor data) throws RemoteException {
  File packageDir=new File(mDataDir,packageInfo.packageName);
  File imageFileName=new File(packageDir,DATA_FILE_NAME);
  return -1;
}","public int performBackup(PackageInfo packageInfo,ParcelFileDescriptor data) throws RemoteException {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + packageInfo.packageName);
  int err=0;
  File packageDir=new File(mDataDir,packageInfo.packageName);
  packageDir.mkdirs();
  BackupDataInput changeSet=new BackupDataInput(data.getFileDescriptor());
  try {
    int bufSize=512;
    byte[] buf=new byte[bufSize];
    while (changeSet.readNextHeader()) {
      String key=changeSet.getKey();
      int dataSize=changeSet.getDataSize();
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ dataSize);
      if (dataSize > bufSize) {
        bufSize=dataSize;
        buf=new byte[bufSize];
      }
      changeSet.readEntityData(buf,dataSize);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + dataSize);
      File entityFile=new File(packageDir,key);
      FileOutputStream entity=new FileOutputStream(entityFile);
      try {
        entity.write(buf,0,dataSize);
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"" + entityFile.getAbsolutePath());
        err=-1;
      }
 finally {
        entity.close();
      }
    }
  }
 catch (  IOException e) {
    Log.v(TAG,""String_Node_Str"");
    e.printStackTrace();
    err=-1;
  }
  return err;
}",0.1495081967213114
183582,"public int endSession() throws RemoteException {
  return 0;
}","public int endSession() throws RemoteException {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  return 0;
}",0.7337278106508875
183583,"public int startSession() throws RemoteException {
  return 0;
}","public int startSession() throws RemoteException {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  mDataDir.mkdirs();
  return 0;
}",0.6597938144329897
183584,"public int getRestoreData(int token,PackageInfo packageInfo,ParcelFileDescriptor output) throws android.os.RemoteException {
  if (token != 0)   return -1;
  File packageDir=new File(mDataDir,packageInfo.packageName);
  File imageFile=new File(packageDir,DATA_FILE_NAME);
  return copyFileToFD(imageFile,output);
}","public int getRestoreData(int token,PackageInfo packageInfo,ParcelFileDescriptor output) throws android.os.RemoteException {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ packageInfo.packageName);
  if (token != 0)   return -1;
  File packageDir=new File(mDataDir,packageInfo.packageName);
  File[] blobs=packageDir.listFiles();
  int err=0;
  if (blobs != null && blobs.length > 0) {
    for (    File f : blobs) {
      err=copyFileToFD(f,output);
      if (err != 0)       break;
    }
  }
  return err;
}",0.5330188679245284
183585,"public PackageInfo[] getAppSet(int token) throws android.os.RemoteException {
  File[] packageDirs=mDataDir.listFiles(mDirFileFilter);
  ArrayList<PackageInfo> packages=new ArrayList<PackageInfo>();
  for (  File dir : packageDirs) {
    try {
      PackageInfo pkg=mPackageManager.getPackageInfo(dir.getName(),PackageManager.GET_SIGNATURES);
      if (pkg != null) {
        packages.add(pkg);
      }
    }
 catch (    NameNotFoundException e) {
    }
  }
  Log.v(TAG,""String_Node_Str"" + packages.size() + ""String_Node_Str"");
  for (  PackageInfo p : packages) {
    Log.v(TAG,""String_Node_Str"" + p.packageName);
  }
  PackageInfo[] result=new PackageInfo[packages.size()];
  return packages.toArray(result);
}","public PackageInfo[] getAppSet(int token) throws android.os.RemoteException {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + token);
  File[] packageDirs=mDataDir.listFiles(mDirFileFilter);
  ArrayList<PackageInfo> packages=new ArrayList<PackageInfo>();
  for (  File dir : packageDirs) {
    try {
      PackageInfo pkg=mPackageManager.getPackageInfo(dir.getName(),PackageManager.GET_SIGNATURES);
      if (pkg != null) {
        packages.add(pkg);
      }
    }
 catch (    NameNotFoundException e) {
    }
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + packages.size() + ""String_Node_Str"");
    for (    PackageInfo p : packages) {
      Log.v(TAG,""String_Node_Str"" + p.packageName);
    }
  }
  PackageInfo[] result=new PackageInfo[packages.size()];
  return packages.toArray(result);
}",0.9389110225763612
183586,"public LocalTransport(Context context){
  mContext=context;
  mPackageManager=context.getPackageManager();
}","public LocalTransport(Context context){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  mContext=context;
  mPackageManager=context.getPackageManager();
}",0.8275862068965517
183587,"@Override public void onBackup(ParcelFileDescriptor oldState,BackupDataOutput data,ParcelFileDescriptor newState){
  LinkedList<File> dirsToScan=new LinkedList<File>();
  ArrayList<String> allFiles=new ArrayList<String>();
  dirsToScan.add(getFilesDir());
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + getFilesDir().getAbsolutePath() + ""String_Node_Str"");
  while (dirsToScan.size() > 0) {
    File dir=dirsToScan.removeFirst();
    File[] contents=dir.listFiles();
    if (contents != null) {
      for (      File f : contents) {
        if (f.isDirectory()) {
          dirsToScan.add(f);
        }
 else         if (f.isFile()) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + f.getAbsolutePath());
          allFiles.add(f.getAbsolutePath());
        }
      }
    }
  }
  FileBackupHelper.performBackup(this,oldState,data,newState,(String[])allFiles.toArray());
}","@Override public void onBackup(ParcelFileDescriptor oldState,BackupDataOutput data,ParcelFileDescriptor newState){
  LinkedList<File> dirsToScan=new LinkedList<File>();
  ArrayList<String> allFiles=new ArrayList<String>();
  dirsToScan.add(getFilesDir());
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + getFilesDir().getAbsolutePath() + ""String_Node_Str"");
  while (dirsToScan.size() > 0) {
    File dir=dirsToScan.removeFirst();
    File[] contents=dir.listFiles();
    if (contents != null) {
      for (      File f : contents) {
        if (f.isDirectory()) {
          dirsToScan.add(f);
        }
 else         if (f.isFile()) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + f.getAbsolutePath());
          allFiles.add(f.getAbsolutePath());
        }
      }
    }
  }
  FileBackupHelper helper=new FileBackupHelper(this);
  helper.performBackup(oldState,data,newState,(String[])allFiles.toArray());
}",0.9728230726566832
183588,"/** 
 * Based on oldState, determine which of the files from the application's data directory need to be backed up, write them to the data stream, and fill in newState with the state as it exists now.
 */
public static void performBackup(Context context,ParcelFileDescriptor oldState,BackupDataOutput data,ParcelFileDescriptor newState,String[] files){
  File base=context.getFilesDir();
  final int N=files.length;
  String[] fullPaths=new String[N];
  for (int i=0; i < N; i++) {
    fullPaths[i]=(new File(base,files[i])).getAbsolutePath();
  }
  performBackup_checked(oldState,data,newState,fullPaths,files);
}","/** 
 * Based on oldState, determine which of the files from the application's data directory need to be backed up, write them to the data stream, and fill in newState with the state as it exists now.
 */
public void performBackup(ParcelFileDescriptor oldState,BackupDataOutput data,ParcelFileDescriptor newState,String[] files){
  File base=mContext.getFilesDir();
  final int N=files.length;
  String[] fullPaths=new String[N];
  for (int i=0; i < N; i++) {
    fullPaths[i]=(new File(base,files[i])).getAbsolutePath();
  }
  String[] keys=makeKeys(mKeyPrefix,files);
  performBackup_checked(oldState,data,newState,fullPaths,keys);
}",0.9383506805444356
183589,"public static void performBackup(Context context,ParcelFileDescriptor oldSnapshot,ParcelFileDescriptor newSnapshot,BackupDataOutput data,String[] prefGroups){
  final int N=prefGroups.length;
  String[] files=new String[N];
  for (int i=0; i < N; i++) {
    files[i]=context.getSharedPrefsFile(prefGroups[i]).toString();
  }
  FileBackupHelper.performBackup_checked(oldSnapshot,data,newSnapshot,files,prefGroups);
}","public void performBackup(ParcelFileDescriptor oldSnapshot,ParcelFileDescriptor newSnapshot,BackupDataOutput data,String[] prefGroups){
  Context context=mContext;
  final int N=prefGroups.length;
  String[] files=new String[N];
  for (int i=0; i < N; i++) {
    files[i]=context.getSharedPrefsFile(prefGroups[i]).getAbsolutePath();
  }
  String[] keys=FileBackupHelper.makeKeys(mKeyPrefix,prefGroups);
  FileBackupHelper.performBackup_checked(oldSnapshot,data,newSnapshot,files,prefGroups);
}",0.6387665198237885
183590,"public final void finishSubActivity(IBinder token,String resultWho,int requestCode){
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index < 0) {
      return;
    }
    HistoryRecord self=(HistoryRecord)mHistory.get(index);
    final long origId=Binder.clearCallingIdentity();
    int i;
    for (i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.resultTo == self && r.requestCode == requestCode) {
        if ((r.resultWho == null && resultWho == null) || (r.resultWho != null && r.resultWho.equals(resultWho))) {
          finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
        }
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}","public final void finishSubActivity(IBinder token,String resultWho,int requestCode){
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index < 0) {
      return;
    }
    HistoryRecord self=(HistoryRecord)mHistory.get(index);
    final long origId=Binder.clearCallingIdentity();
    int i;
    for (i=mHistory.size() - 1; i >= 0; i--) {
      HistoryRecord r=(HistoryRecord)mHistory.get(i);
      if (r.resultTo == self && r.requestCode == requestCode) {
        if ((r.resultWho == null && resultWho == null) || (r.resultWho != null && r.resultWho.equals(resultWho))) {
          finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"");
        }
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}",0.99601593625498
183591,"public void setPersistent(IBinder token,boolean isPersistent){
  if (checkCallingPermission(android.Manifest.permission.PERSISTENT_ACTIVITY) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.PERSISTENT_ACTIVITY;
    Log.w(TAG,msg);
    throw new SecurityException(msg);
  }
synchronized (this) {
    int index=indexOfTokenLocked(token,true);
    if (index < 0) {
      return;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    ProcessRecord app=r.app;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + isPersistent + ""String_Node_Str""+ r);
    if (isPersistent) {
      if (r.persistent) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      r.persistent=true;
      app.persistentActivities++;
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + app.persistentActivities);
      if (app.persistentActivities > 1) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      if (app.persistent) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      final long origId=Binder.clearCallingIdentity();
      updateOomAdjLocked();
      Binder.restoreCallingIdentity(origId);
    }
 else {
      if (!r.persistent) {
        return;
      }
      r.persistent=false;
      final long origId=Binder.clearCallingIdentity();
      decPersistentCountLocked(app);
      Binder.restoreCallingIdentity(origId);
    }
  }
}","public void setPersistent(IBinder token,boolean isPersistent){
  if (checkCallingPermission(android.Manifest.permission.PERSISTENT_ACTIVITY) != PackageManager.PERMISSION_GRANTED) {
    String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.PERSISTENT_ACTIVITY;
    Log.w(TAG,msg);
    throw new SecurityException(msg);
  }
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index < 0) {
      return;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    ProcessRecord app=r.app;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + isPersistent + ""String_Node_Str""+ r);
    if (isPersistent) {
      if (r.persistent) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      r.persistent=true;
      app.persistentActivities++;
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + app.persistentActivities);
      if (app.persistentActivities > 1) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      if (app.persistent) {
        if (localLOGV)         Log.v(TAG,""String_Node_Str"");
        return;
      }
      final long origId=Binder.clearCallingIdentity();
      updateOomAdjLocked();
      Binder.restoreCallingIdentity(origId);
    }
 else {
      if (!r.persistent) {
        return;
      }
      r.persistent=false;
      final long origId=Binder.clearCallingIdentity();
      decPersistentCountLocked(app);
      Binder.restoreCallingIdentity(origId);
    }
  }
}",0.9984192222573506
183592,"public final void activityDestroyed(IBinder token){
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + token);
synchronized (this) {
    mHandler.removeMessages(DESTROY_TIMEOUT_MSG,token);
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      if (r.state == ActivityState.DESTROYING) {
        final long origId=Binder.clearCallingIdentity();
        removeActivityFromHistoryLocked(r);
        Binder.restoreCallingIdentity(origId);
      }
    }
  }
}","public final void activityDestroyed(IBinder token){
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + token);
synchronized (this) {
    mHandler.removeMessages(DESTROY_TIMEOUT_MSG,token);
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      if (r.state == ActivityState.DESTROYING) {
        final long origId=Binder.clearCallingIdentity();
        removeActivityFromHistoryLocked(r);
        Binder.restoreCallingIdentity(origId);
      }
    }
  }
}",0.9943396226415094
183593,"/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret,false);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}","/** 
 * Perform clear operation as requested by  {@link Intent#FLAG_ACTIVITY_CLEAR_TOP}: search from the top of the stack to the given task, then look for an instance of that activity in the stack and, if found, finish all activities on top of it and return the instance.
 * @param newR Description of the new activity being started.
 * @return Returns the old activity that should be continue to be used,or null if none was found.
 */
private final HistoryRecord performClearTaskLocked(int taskId,HistoryRecord newR,boolean doClear){
  int i=mHistory.size();
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.task.taskId == taskId) {
      i++;
      break;
    }
  }
  while (i > 0) {
    i--;
    HistoryRecord r=(HistoryRecord)mHistory.get(i);
    if (r.finishing) {
      continue;
    }
    if (r.task.taskId != taskId) {
      return null;
    }
    if (r.realActivity.equals(newR.realActivity)) {
      HistoryRecord ret=r;
      if (doClear) {
        while (i < (mHistory.size() - 1)) {
          i++;
          r=(HistoryRecord)mHistory.get(i);
          if (r.finishing) {
            continue;
          }
          if (finishActivityLocked(r,i,Activity.RESULT_CANCELED,null,""String_Node_Str"")) {
            i--;
          }
        }
      }
      if (ret.launchMode == ActivityInfo.LAUNCH_MULTIPLE) {
        if (!ret.finishing) {
          int index=indexOfTokenLocked(ret);
          if (index >= 0) {
            finishActivityLocked(ret,0,Activity.RESULT_CANCELED,null,""String_Node_Str"");
          }
          return null;
        }
      }
      return ret;
    }
  }
  return null;
}",0.9981796116504854
183594,"private final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,boolean onlyIfNeeded,boolean componentSpecified){
  Log.i(TAG,""String_Node_Str"" + intent);
  HistoryRecord sourceRecord=null;
  HistoryRecord resultRecord=null;
  if (resultTo != null) {
    int index=indexOfTokenLocked(resultTo,false);
    if (DEBUG_RESULTS)     Log.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ index+ ""String_Node_Str"");
    if (index >= 0) {
      sourceRecord=(HistoryRecord)mHistory.get(index);
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      return START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  int err=START_SUCCESS;
  if (intent.getComponent() == null) {
    err=START_INTENT_NOT_RESOLVED;
  }
  if (err == START_SUCCESS && aInfo == null) {
    err=START_CLASS_NOT_FOUND;
  }
  ProcessRecord callerApp=null;
  if (err == START_SUCCESS && caller != null) {
    callerApp=getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=START_PERMISSION_DENIED;
    }
  }
  if (err != START_SUCCESS) {
    if (resultRecord != null) {
      sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    return err;
  }
  final int perm=checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.exported ? -1 : aInfo.applicationInfo.uid);
  if (perm != PackageManager.PERMISSION_GRANTED) {
    if (resultRecord != null) {
      sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    String msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    Log.w(TAG,msg);
    throw new SecurityException(msg);
  }
  if (mWatcher != null) {
    boolean abort=false;
    try {
      Intent watchIntent=intent.cloneFilter();
      abort=!mWatcher.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mWatcher=null;
    }
    if (abort) {
      if (resultRecord != null) {
        sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
      }
      return START_SUCCESS;
    }
  }
  HistoryRecord r=new HistoryRecord(this,callerApp,callingUid,intent,resolvedType,aInfo,mConfiguration,resultRecord,resultWho,requestCode,componentSpecified);
  if (mResumedActivity == null || mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch();
      pal.r=r;
      pal.sourceRecord=sourceRecord;
      pal.grantedUriPermissions=grantedUriPermissions;
      pal.grantedMode=grantedMode;
      pal.onlyIfNeeded=onlyIfNeeded;
      mPendingActivityLaunches.add(pal);
      return START_SWITCHES_CANCELED;
    }
  }
  if (mDidAppSwitch) {
    mAppSwitchesAllowedTime=0;
  }
 else {
    mDidAppSwitch=true;
  }
  doPendingActivityLaunchesLocked(false);
  return startActivityUncheckedLocked(r,sourceRecord,grantedUriPermissions,grantedMode,onlyIfNeeded,true);
}","private final int startActivityLocked(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,ActivityInfo aInfo,IBinder resultTo,String resultWho,int requestCode,int callingPid,int callingUid,boolean onlyIfNeeded,boolean componentSpecified){
  Log.i(TAG,""String_Node_Str"" + intent);
  HistoryRecord sourceRecord=null;
  HistoryRecord resultRecord=null;
  if (resultTo != null) {
    int index=indexOfTokenLocked(resultTo);
    if (DEBUG_RESULTS)     Log.v(TAG,""String_Node_Str"" + resultTo + ""String_Node_Str""+ index+ ""String_Node_Str"");
    if (index >= 0) {
      sourceRecord=(HistoryRecord)mHistory.get(index);
      if (requestCode >= 0 && !sourceRecord.finishing) {
        resultRecord=sourceRecord;
      }
    }
  }
  int launchFlags=intent.getFlags();
  if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
    if (requestCode >= 0) {
      return START_FORWARD_AND_REQUEST_CONFLICT;
    }
    resultRecord=sourceRecord.resultTo;
    resultWho=sourceRecord.resultWho;
    requestCode=sourceRecord.requestCode;
    sourceRecord.resultTo=null;
    if (resultRecord != null) {
      resultRecord.removeResultsLocked(sourceRecord,resultWho,requestCode);
    }
  }
  int err=START_SUCCESS;
  if (intent.getComponent() == null) {
    err=START_INTENT_NOT_RESOLVED;
  }
  if (err == START_SUCCESS && aInfo == null) {
    err=START_CLASS_NOT_FOUND;
  }
  ProcessRecord callerApp=null;
  if (err == START_SUCCESS && caller != null) {
    callerApp=getRecordForAppLocked(caller);
    if (callerApp != null) {
      callingPid=callerApp.pid;
      callingUid=callerApp.info.uid;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + caller + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ intent.toString());
      err=START_PERMISSION_DENIED;
    }
  }
  if (err != START_SUCCESS) {
    if (resultRecord != null) {
      sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    return err;
  }
  final int perm=checkComponentPermission(aInfo.permission,callingPid,callingUid,aInfo.exported ? -1 : aInfo.applicationInfo.uid);
  if (perm != PackageManager.PERMISSION_GRANTED) {
    if (resultRecord != null) {
      sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
    }
    String msg=""String_Node_Str"" + intent.toString() + ""String_Node_Str""+ callerApp+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ aInfo.permission;
    Log.w(TAG,msg);
    throw new SecurityException(msg);
  }
  if (mWatcher != null) {
    boolean abort=false;
    try {
      Intent watchIntent=intent.cloneFilter();
      abort=!mWatcher.activityStarting(watchIntent,aInfo.applicationInfo.packageName);
    }
 catch (    RemoteException e) {
      mWatcher=null;
    }
    if (abort) {
      if (resultRecord != null) {
        sendActivityResultLocked(-1,resultRecord,resultWho,requestCode,Activity.RESULT_CANCELED,null);
      }
      return START_SUCCESS;
    }
  }
  HistoryRecord r=new HistoryRecord(this,callerApp,callingUid,intent,resolvedType,aInfo,mConfiguration,resultRecord,resultWho,requestCode,componentSpecified);
  if (mResumedActivity == null || mResumedActivity.info.applicationInfo.uid != callingUid) {
    if (!checkAppSwitchAllowedLocked(callingPid,callingUid,""String_Node_Str"")) {
      PendingActivityLaunch pal=new PendingActivityLaunch();
      pal.r=r;
      pal.sourceRecord=sourceRecord;
      pal.grantedUriPermissions=grantedUriPermissions;
      pal.grantedMode=grantedMode;
      pal.onlyIfNeeded=onlyIfNeeded;
      mPendingActivityLaunches.add(pal);
      return START_SWITCHES_CANCELED;
    }
  }
  if (mDidAppSwitch) {
    mAppSwitchesAllowedTime=0;
  }
 else {
    mDidAppSwitch=true;
  }
  doPendingActivityLaunchesLocked(false);
  return startActivityUncheckedLocked(r,sourceRecord,grantedUriPermissions,grantedMode,onlyIfNeeded,true);
}",0.9992462311557788
183595,"private final int indexOfTokenLocked(IBinder token,boolean required){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  if (index < 0 && required) {
    RuntimeInit.crash(TAG,new InvalidTokenException(token));
  }
  return index;
}","private final int indexOfTokenLocked(IBinder token){
  int count=mHistory.size();
  HistoryRecord r=null;
  int index=-1;
  for (int i=count - 1; i >= 0; i--) {
    Object o=mHistory.get(i);
    if (o == token) {
      r=(HistoryRecord)o;
      index=i;
      break;
    }
  }
  return index;
}",0.7988587731811697
183596,"public int getRequestedOrientation(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index < 0) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    return mWindowManager.getAppOrientation(r);
  }
}","public int getRequestedOrientation(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index < 0) {
      return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    return mWindowManager.getAppOrientation(r);
  }
}",0.990353697749196
183597,"public final void activityStopped(IBinder token,Bitmap thumbnail,CharSequence description){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + token);
  HistoryRecord r=null;
  final long origId=Binder.clearCallingIdentity();
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      r=(HistoryRecord)mHistory.get(index);
      r.thumbnail=thumbnail;
      r.description=description;
      r.stopped=true;
      r.state=ActivityState.STOPPED;
      if (!r.finishing) {
        if (r.configDestroy) {
          destroyActivityLocked(r,true);
          resumeTopActivityLocked(null);
        }
      }
    }
  }
  if (r != null) {
    sendPendingThumbnail(r,null,null,null,false);
  }
  trimApplications();
  Binder.restoreCallingIdentity(origId);
}","public final void activityStopped(IBinder token,Bitmap thumbnail,CharSequence description){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + token);
  HistoryRecord r=null;
  final long origId=Binder.clearCallingIdentity();
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      r=(HistoryRecord)mHistory.get(index);
      r.thumbnail=thumbnail;
      r.description=description;
      r.stopped=true;
      r.state=ActivityState.STOPPED;
      if (!r.finishing) {
        if (r.configDestroy) {
          destroyActivityLocked(r,true);
          resumeTopActivityLocked(null);
        }
      }
    }
  }
  if (r != null) {
    sendPendingThumbnail(r,null,null,null,false);
  }
  trimApplications();
  Binder.restoreCallingIdentity(origId);
}",0.9961587708066582
183598,"public void setRequestedOrientation(IBinder token,int requestedOrientation){
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index < 0) {
      return;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    final long origId=Binder.clearCallingIdentity();
    mWindowManager.setAppOrientation(r,requestedOrientation);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,r.mayFreezeScreenLocked(r.app) ? r : null);
    if (config != null) {
      r.frozenBeforeDestroy=true;
      if (!updateConfigurationLocked(config,r)) {
        resumeTopActivityLocked(null);
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}","public void setRequestedOrientation(IBinder token,int requestedOrientation){
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index < 0) {
      return;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    final long origId=Binder.clearCallingIdentity();
    mWindowManager.setAppOrientation(r,requestedOrientation);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,r.mayFreezeScreenLocked(r.app) ? r : null);
    if (config != null) {
      r.frozenBeforeDestroy=true;
      if (!updateConfigurationLocked(config,r)) {
        resumeTopActivityLocked(null);
      }
    }
    Binder.restoreCallingIdentity(origId);
  }
}",0.9956896551724138
183599,"public ComponentName getActivityClassForToken(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      return r.intent.getComponent();
    }
    return null;
  }
}","public ComponentName getActivityClassForToken(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      return r.intent.getComponent();
    }
    return null;
  }
}",0.9890510948905108
183600,"final void activityIdleInternal(IBinder token,boolean fromTimeout){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + token);
  ArrayList<HistoryRecord> stops=null;
  ArrayList<HistoryRecord> finishes=null;
  ArrayList<HistoryRecord> thumbnails=null;
  int NS=0;
  int NF=0;
  int NT=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
synchronized (this) {
    if (token != null) {
      mHandler.removeMessages(IDLE_TIMEOUT_MSG,token);
    }
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      if (mResumedActivity == r && mLaunchingActivity.isHeld()) {
        mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);
        mLaunchingActivity.release();
      }
      r.idle=true;
      scheduleAppGcsLocked();
      if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
        sendThumbnail=r.app.thread;
        r.thumbnailNeeded=false;
      }
      if (DEBUG_VISBILITY)       Log.v(TAG,""String_Node_Str"" + r);
      ensureActivitiesVisibleLocked(null,0);
      if (!mBooted && !fromTimeout) {
        mBooted=true;
        enableScreen=true;
      }
    }
    stops=processStoppingActivitiesLocked(true);
    NS=stops != null ? stops.size() : 0;
    if ((NF=mFinishingActivities.size()) > 0) {
      finishes=new ArrayList<HistoryRecord>(mFinishingActivities);
      mFinishingActivities.clear();
    }
    if ((NT=mCancelledThumbnails.size()) > 0) {
      thumbnails=new ArrayList<HistoryRecord>(mCancelledThumbnails);
      mCancelledThumbnails.clear();
    }
    booting=mBooting;
    mBooting=false;
  }
  int i;
  if (sendThumbnail != null) {
    try {
      sendThumbnail.requestThumbnail(token);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"",e);
      sendPendingThumbnail(null,token,null,null,true);
    }
  }
  for (i=0; i < NS; i++) {
    HistoryRecord r=(HistoryRecord)stops.get(i);
synchronized (this) {
      if (r.finishing) {
        finishCurrentActivityLocked(r,FINISH_IMMEDIATELY);
      }
 else {
        stopActivityLocked(r);
      }
    }
  }
  for (i=0; i < NF; i++) {
    HistoryRecord r=(HistoryRecord)finishes.get(i);
synchronized (this) {
      destroyActivityLocked(r,true);
    }
  }
  for (i=0; i < NT; i++) {
    HistoryRecord r=(HistoryRecord)thumbnails.get(i);
    sendPendingThumbnail(r,null,null,null,true);
  }
  if (booting) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        this.startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
synchronized (this) {
        broadcastIntentLocked(null,null,new Intent(Intent.ACTION_BOOT_COMPLETED,null),null,null,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,false,false,MY_PID,Process.SYSTEM_UID);
      }
    }
  }
  trimApplications();
  if (enableScreen) {
    EventLog.writeEvent(LOG_BOOT_PROGRESS_ENABLE_SCREEN,SystemClock.uptimeMillis());
    enableScreenAfterBoot();
  }
}","final void activityIdleInternal(IBinder token,boolean fromTimeout){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + token);
  ArrayList<HistoryRecord> stops=null;
  ArrayList<HistoryRecord> finishes=null;
  ArrayList<HistoryRecord> thumbnails=null;
  int NS=0;
  int NF=0;
  int NT=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
synchronized (this) {
    if (token != null) {
      mHandler.removeMessages(IDLE_TIMEOUT_MSG,token);
    }
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      if (mResumedActivity == r && mLaunchingActivity.isHeld()) {
        mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);
        mLaunchingActivity.release();
      }
      r.idle=true;
      scheduleAppGcsLocked();
      if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
        sendThumbnail=r.app.thread;
        r.thumbnailNeeded=false;
      }
      if (DEBUG_VISBILITY)       Log.v(TAG,""String_Node_Str"" + r);
      ensureActivitiesVisibleLocked(null,0);
      if (!mBooted && !fromTimeout) {
        mBooted=true;
        enableScreen=true;
      }
    }
    stops=processStoppingActivitiesLocked(true);
    NS=stops != null ? stops.size() : 0;
    if ((NF=mFinishingActivities.size()) > 0) {
      finishes=new ArrayList<HistoryRecord>(mFinishingActivities);
      mFinishingActivities.clear();
    }
    if ((NT=mCancelledThumbnails.size()) > 0) {
      thumbnails=new ArrayList<HistoryRecord>(mCancelledThumbnails);
      mCancelledThumbnails.clear();
    }
    booting=mBooting;
    mBooting=false;
  }
  int i;
  if (sendThumbnail != null) {
    try {
      sendThumbnail.requestThumbnail(token);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"",e);
      sendPendingThumbnail(null,token,null,null,true);
    }
  }
  for (i=0; i < NS; i++) {
    HistoryRecord r=(HistoryRecord)stops.get(i);
synchronized (this) {
      if (r.finishing) {
        finishCurrentActivityLocked(r,FINISH_IMMEDIATELY);
      }
 else {
        stopActivityLocked(r);
      }
    }
  }
  for (i=0; i < NF; i++) {
    HistoryRecord r=(HistoryRecord)finishes.get(i);
synchronized (this) {
      destroyActivityLocked(r,true);
    }
  }
  for (i=0; i < NT; i++) {
    HistoryRecord r=(HistoryRecord)thumbnails.get(i);
    sendPendingThumbnail(r,null,null,null,true);
  }
  if (booting) {
    final int NP=mProcessesOnHold.size();
    if (NP > 0) {
      ArrayList<ProcessRecord> procs=new ArrayList<ProcessRecord>(mProcessesOnHold);
      for (int ip=0; ip < NP; ip++) {
        this.startProcessLocked(procs.get(ip),""String_Node_Str"",null);
      }
    }
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
synchronized (this) {
        broadcastIntentLocked(null,null,new Intent(Intent.ACTION_BOOT_COMPLETED,null),null,null,0,null,null,android.Manifest.permission.RECEIVE_BOOT_COMPLETED,false,false,MY_PID,Process.SYSTEM_UID);
      }
    }
  }
  trimApplications();
  if (enableScreen) {
    EventLog.writeEvent(LOG_BOOT_PROGRESS_ENABLE_SCREEN,SystemClock.uptimeMillis());
    enableScreenAfterBoot();
  }
}",0.9990482233502538
183601,"public int bindService(IApplicationThread caller,IBinder token,Intent service,String resolvedType,IServiceConnection connection,int flags){
  if (service != null && service.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
    final ProcessRecord callerApp=getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    HistoryRecord activity=null;
    if (token != null) {
      int aindex=indexOfTokenLocked(token,false);
      if (aindex < 0) {
        Log.w(TAG,""String_Node_Str"" + token);
        return 0;
      }
      activity=(HistoryRecord)mHistory.get(aindex);
    }
    ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,Binder.getCallingPid(),Binder.getCallingUid());
    if (res == null) {
      return 0;
    }
    if (res.record == null) {
      return -1;
    }
    ServiceRecord s=res.record;
    final long origId=Binder.clearCallingIdentity();
    if (unscheduleServiceRestartLocked(s)) {
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + s.shortName);
    }
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags);
    IBinder binder=connection.asBinder();
    s.connections.put(binder,c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    mServiceConnections.put(binder,c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!bringUpServiceLocked(s,service.getFlags(),false)) {
        return 0;
      }
    }
    if (s.app != null) {
      updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,false);
    }
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}","public int bindService(IApplicationThread caller,IBinder token,Intent service,String resolvedType,IServiceConnection connection,int flags){
  if (service != null && service.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ connection.asBinder()+ ""String_Node_Str""+ Integer.toHexString(flags));
    final ProcessRecord callerApp=getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    HistoryRecord activity=null;
    if (token != null) {
      int aindex=indexOfTokenLocked(token);
      if (aindex < 0) {
        Log.w(TAG,""String_Node_Str"" + token);
        return 0;
      }
      activity=(HistoryRecord)mHistory.get(aindex);
    }
    ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,Binder.getCallingPid(),Binder.getCallingUid());
    if (res == null) {
      return 0;
    }
    if (res.record == null) {
      return -1;
    }
    ServiceRecord s=res.record;
    final long origId=Binder.clearCallingIdentity();
    if (unscheduleServiceRestartLocked(s)) {
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + s.shortName);
    }
    AppBindRecord b=s.retrieveAppBindingLocked(service,callerApp);
    ConnectionRecord c=new ConnectionRecord(b,activity,connection,flags);
    IBinder binder=connection.asBinder();
    s.connections.put(binder,c);
    b.connections.add(c);
    if (activity != null) {
      if (activity.connections == null) {
        activity.connections=new HashSet<ConnectionRecord>();
      }
      activity.connections.add(c);
    }
    b.client.connections.add(c);
    mServiceConnections.put(binder,c);
    if ((flags & Context.BIND_AUTO_CREATE) != 0) {
      s.lastActivity=SystemClock.uptimeMillis();
      if (!bringUpServiceLocked(s,service.getFlags(),false)) {
        return 0;
      }
    }
    if (s.app != null) {
      updateOomAdjLocked(s.app);
    }
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + s + ""String_Node_Str""+ b+ ""String_Node_Str""+ b.intent.received+ ""String_Node_Str""+ b.intent.apps.size()+ ""String_Node_Str""+ b.intent.doRebind);
    if (s.app != null && b.intent.received) {
      try {
        c.conn.connected(s.name,b.intent.binder);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + s.shortName + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
      if (b.intent.apps.size() == 1 && b.intent.doRebind) {
        requestServiceBindingLocked(s,b.intent,true);
      }
    }
 else     if (!b.intent.requested) {
      requestServiceBindingLocked(s,b.intent,false);
    }
    Binder.restoreCallingIdentity(origId);
  }
  return 1;
}",0.998984771573604
183602,"public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity,false);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}","public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}",0.9986388384754992
183603,"/** 
 * @return Returns true if the activity is being finished, false if forsome reason it is being left as-is.
 */
private final boolean requestFinishActivityLocked(IBinder token,int resultCode,Intent resultData,String reason){
  if (DEBUG_RESULTS)   Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
  int index=indexOfTokenLocked(token,false);
  if (index < 0) {
    return false;
  }
  HistoryRecord r=(HistoryRecord)mHistory.get(index);
  boolean lastActivity=true;
  for (int i=mHistory.size() - 1; i >= 0; i--) {
    HistoryRecord p=(HistoryRecord)mHistory.get(i);
    if (!p.finishing && p != r) {
      lastActivity=false;
      break;
    }
  }
  if (lastActivity) {
    if (r.intent.hasCategory(Intent.CATEGORY_HOME)) {
      return false;
    }
  }
  finishActivityLocked(r,index,resultCode,resultData,reason);
  return true;
}","/** 
 * @return Returns true if the activity is being finished, false if forsome reason it is being left as-is.
 */
private final boolean requestFinishActivityLocked(IBinder token,int resultCode,Intent resultData,String reason){
  if (DEBUG_RESULTS)   Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ resultCode+ ""String_Node_Str""+ resultData);
  int index=indexOfTokenLocked(token);
  if (index < 0) {
    return false;
  }
  HistoryRecord r=(HistoryRecord)mHistory.get(index);
  boolean lastActivity=true;
  for (int i=mHistory.size() - 1; i >= 0; i--) {
    HistoryRecord p=(HistoryRecord)mHistory.get(i);
    if (!p.finishing && p != r) {
      lastActivity=false;
      break;
    }
  }
  if (lastActivity) {
    if (r.intent.hasCategory(Intent.CATEGORY_HOME)) {
      return false;
    }
  }
  finishActivityLocked(r,index,resultCode,resultData,reason);
  return true;
}",0.9966178128523112
183604,"private HistoryRecord getCallingRecordLocked(IBinder token){
  int index=indexOfTokenLocked(token,true);
  if (index >= 0) {
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r != null) {
      return r.resultTo;
    }
  }
  return null;
}","private HistoryRecord getCallingRecordLocked(IBinder token){
  int index=indexOfTokenLocked(token);
  if (index >= 0) {
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r != null) {
      return r.resultTo;
    }
  }
  return null;
}",0.9900199600798404
183605,"public String getPackageForToken(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      return r.packageName;
    }
    return null;
  }
}","public String getPackageForToken(IBinder token){
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      HistoryRecord r=(HistoryRecord)mHistory.get(index);
      return r.packageName;
    }
    return null;
  }
}",0.9880478087649402
183606,"public IIntentSender getIntentSender(int type,String packageName,IBinder token,String resultWho,int requestCode,Intent intent,String resolvedType,int flags){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int callingUid=Binder.getCallingUid();
    try {
      if (callingUid != 0 && callingUid != Process.SYSTEM_UID && Process.supportsProcesses()) {
        int uid=ActivityThread.getPackageManager().getPackageUid(packageName);
        if (uid != Binder.getCallingUid()) {
          String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ ""String_Node_Str""+ packageName;
          Log.w(TAG,msg);
          throw new SecurityException(msg);
        }
      }
    }
 catch (    RemoteException e) {
      throw new SecurityException(e);
    }
    HistoryRecord activity=null;
    if (type == INTENT_SENDER_ACTIVITY_RESULT) {
      int index=indexOfTokenLocked(token,false);
      if (index < 0) {
        return null;
      }
      activity=(HistoryRecord)mHistory.get(index);
      if (activity.finishing) {
        return null;
      }
    }
    final boolean noCreate=(flags & PendingIntent.FLAG_NO_CREATE) != 0;
    final boolean cancelCurrent=(flags & PendingIntent.FLAG_CANCEL_CURRENT) != 0;
    final boolean updateCurrent=(flags & PendingIntent.FLAG_UPDATE_CURRENT) != 0;
    flags&=~(PendingIntent.FLAG_NO_CREATE | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_UPDATE_CURRENT);
    PendingIntentRecord.Key key=new PendingIntentRecord.Key(type,packageName,activity,resultWho,requestCode,intent,resolvedType,flags);
    WeakReference<PendingIntentRecord> ref;
    ref=mIntentSenderRecords.get(key);
    PendingIntentRecord rec=ref != null ? ref.get() : null;
    if (rec != null) {
      if (!cancelCurrent) {
        if (updateCurrent) {
          rec.key.requestIntent.replaceExtras(intent);
        }
        return rec;
      }
      rec.canceled=true;
      mIntentSenderRecords.remove(key);
    }
    if (noCreate) {
      return rec;
    }
    rec=new PendingIntentRecord(this,key,callingUid);
    mIntentSenderRecords.put(key,rec.ref);
    if (type == INTENT_SENDER_ACTIVITY_RESULT) {
      if (activity.pendingResults == null) {
        activity.pendingResults=new HashSet<WeakReference<PendingIntentRecord>>();
      }
      activity.pendingResults.add(rec.ref);
    }
    return rec;
  }
}","public IIntentSender getIntentSender(int type,String packageName,IBinder token,String resultWho,int requestCode,Intent intent,String resolvedType,int flags){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int callingUid=Binder.getCallingUid();
    try {
      if (callingUid != 0 && callingUid != Process.SYSTEM_UID && Process.supportsProcesses()) {
        int uid=ActivityThread.getPackageManager().getPackageUid(packageName);
        if (uid != Binder.getCallingUid()) {
          String msg=""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ uid+ ""String_Node_Str""+ ""String_Node_Str""+ packageName;
          Log.w(TAG,msg);
          throw new SecurityException(msg);
        }
      }
    }
 catch (    RemoteException e) {
      throw new SecurityException(e);
    }
    HistoryRecord activity=null;
    if (type == INTENT_SENDER_ACTIVITY_RESULT) {
      int index=indexOfTokenLocked(token);
      if (index < 0) {
        return null;
      }
      activity=(HistoryRecord)mHistory.get(index);
      if (activity.finishing) {
        return null;
      }
    }
    final boolean noCreate=(flags & PendingIntent.FLAG_NO_CREATE) != 0;
    final boolean cancelCurrent=(flags & PendingIntent.FLAG_CANCEL_CURRENT) != 0;
    final boolean updateCurrent=(flags & PendingIntent.FLAG_UPDATE_CURRENT) != 0;
    flags&=~(PendingIntent.FLAG_NO_CREATE | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_UPDATE_CURRENT);
    PendingIntentRecord.Key key=new PendingIntentRecord.Key(type,packageName,activity,resultWho,requestCode,intent,resolvedType,flags);
    WeakReference<PendingIntentRecord> ref;
    ref=mIntentSenderRecords.get(key);
    PendingIntentRecord rec=ref != null ? ref.get() : null;
    if (rec != null) {
      if (!cancelCurrent) {
        if (updateCurrent) {
          rec.key.requestIntent.replaceExtras(intent);
        }
        return rec;
      }
      rec.canceled=true;
      mIntentSenderRecords.remove(key);
    }
    if (noCreate) {
      return rec;
    }
    rec=new PendingIntentRecord(this,key,callingUid);
    mIntentSenderRecords.put(key,rec.ref);
    if (type == INTENT_SENDER_ACTIVITY_RESULT) {
      if (activity.pendingResults == null) {
        activity.pendingResults=new HashSet<WeakReference<PendingIntentRecord>>();
      }
      activity.pendingResults.add(rec.ref);
    }
    return rec;
  }
}",0.9988019169329072
183607,"final void sendPendingThumbnail(HistoryRecord r,IBinder token,Bitmap thumbnail,CharSequence description,boolean always){
  TaskRecord task=null;
  ArrayList receivers=null;
synchronized (this) {
    if (r == null) {
      int index=indexOfTokenLocked(token,false);
      if (index < 0) {
        return;
      }
      r=(HistoryRecord)mHistory.get(index);
    }
    if (thumbnail == null) {
      thumbnail=r.thumbnail;
      description=r.description;
    }
    if (thumbnail == null && !always) {
      return;
    }
    task=r.task;
    int N=mPendingThumbnails.size();
    int i=0;
    while (i < N) {
      PendingThumbnailsRecord pr=(PendingThumbnailsRecord)mPendingThumbnails.get(i);
      if (pr.pendingRecords.remove(r)) {
        if (receivers == null) {
          receivers=new ArrayList();
        }
        receivers.add(pr);
        if (pr.pendingRecords.size() == 0) {
          pr.finished=true;
          mPendingThumbnails.remove(i);
          N--;
          continue;
        }
      }
      i++;
    }
  }
  if (receivers != null) {
    final int N=receivers.size();
    for (int i=0; i < N; i++) {
      try {
        PendingThumbnailsRecord pr=(PendingThumbnailsRecord)receivers.get(i);
        pr.receiver.newThumbnail(task != null ? task.taskId : -1,thumbnail,description);
        if (pr.finished) {
          pr.receiver.finished();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}","final void sendPendingThumbnail(HistoryRecord r,IBinder token,Bitmap thumbnail,CharSequence description,boolean always){
  TaskRecord task=null;
  ArrayList receivers=null;
synchronized (this) {
    if (r == null) {
      int index=indexOfTokenLocked(token);
      if (index < 0) {
        return;
      }
      r=(HistoryRecord)mHistory.get(index);
    }
    if (thumbnail == null) {
      thumbnail=r.thumbnail;
      description=r.description;
    }
    if (thumbnail == null && !always) {
      return;
    }
    task=r.task;
    int N=mPendingThumbnails.size();
    int i=0;
    while (i < N) {
      PendingThumbnailsRecord pr=(PendingThumbnailsRecord)mPendingThumbnails.get(i);
      if (pr.pendingRecords.remove(r)) {
        if (receivers == null) {
          receivers=new ArrayList();
        }
        receivers.add(pr);
        if (pr.pendingRecords.size() == 0) {
          pr.finished=true;
          mPendingThumbnails.remove(i);
          N--;
          continue;
        }
      }
      i++;
    }
  }
  if (receivers != null) {
    final int N=receivers.size();
    for (int i=0; i < N; i++) {
      try {
        PendingThumbnailsRecord pr=(PendingThumbnailsRecord)receivers.get(i);
        pr.receiver.newThumbnail(task != null ? task.taskId : -1,thumbnail,description);
        if (pr.finished) {
          pr.receiver.finished();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}",0.9979480164158688
183608,"final void activityPaused(IBinder token,Bundle icicle,boolean timeout){
  if (DEBUG_PAUSE)   Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ icicle+ ""String_Node_Str""+ timeout);
  HistoryRecord r=null;
synchronized (this) {
    int index=indexOfTokenLocked(token,false);
    if (index >= 0) {
      r=(HistoryRecord)mHistory.get(index);
      if (!timeout) {
        r.icicle=icicle;
        r.haveState=true;
      }
      mHandler.removeMessages(PAUSE_TIMEOUT_MSG,r);
      if (mPausingActivity == r) {
        r.state=ActivityState.PAUSED;
        completePauseLocked();
      }
 else {
        EventLog.writeEvent(LOG_AM_FAILED_TO_PAUSE_ACTIVITY,System.identityHashCode(r),r.shortComponentName,mPausingActivity != null ? mPausingActivity.shortComponentName : ""String_Node_Str"");
      }
    }
  }
}","final void activityPaused(IBinder token,Bundle icicle,boolean timeout){
  if (DEBUG_PAUSE)   Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ icicle+ ""String_Node_Str""+ timeout);
  HistoryRecord r=null;
synchronized (this) {
    int index=indexOfTokenLocked(token);
    if (index >= 0) {
      r=(HistoryRecord)mHistory.get(index);
      if (!timeout) {
        r.icicle=icicle;
        r.haveState=true;
      }
      mHandler.removeMessages(PAUSE_TIMEOUT_MSG,r);
      if (mPausingActivity == r) {
        r.state=ActivityState.PAUSED;
        completePauseLocked();
      }
 else {
        EventLog.writeEvent(LOG_AM_FAILED_TO_PAUSE_ACTIVITY,System.identityHashCode(r),r.shortComponentName,mPausingActivity != null ? mPausingActivity.shortComponentName : ""String_Node_Str"");
      }
    }
  }
}",0.9962871287128712
183609,"public boolean isStreamAffectedByRingerMode(int streamType){
  int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
  return (ringerModeAffectedStreams & (1 << streamType)) != 0;
}","public boolean isStreamAffectedByRingerMode(int streamType){
  return (mRingerModeAffectedStreams & (1 << streamType)) != 0;
}",0.6666666666666666
183610,"/** 
 * Sync the STREAM_RING and STREAM_NOTIFICATION volumes if mandated by the value in Settings.
 * @param streamType Type of the stream
 * @param index Volume index for the stream
 * @param force If true, set the volume even if the current and desiredvolume as same
 */
private void syncRingerAndNotificationStreamVolume(int streamType,int index,boolean force){
  boolean notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1) == 1;
  if (notificationsUseRingVolume) {
    if (streamType == AudioManager.STREAM_NOTIFICATION) {
      streamType=AudioManager.STREAM_RING;
    }
    if (streamType == AudioManager.STREAM_RING) {
      setStreamVolumeInt(AudioManager.STREAM_NOTIFICATION,index,force);
    }
  }
}","/** 
 * Sync the STREAM_RING and STREAM_NOTIFICATION volumes if mandated by the value in Settings.
 * @param streamType Type of the stream
 * @param index Volume index for the stream
 * @param force If true, set the volume even if the current and desiredvolume as same
 */
private void syncRingerAndNotificationStreamVolume(int streamType,int index,boolean force){
  boolean notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1) == 1;
  if (notificationsUseRingVolume) {
    if (streamType == AudioManager.STREAM_NOTIFICATION) {
      streamType=AudioManager.STREAM_RING;
    }
    if (streamType == AudioManager.STREAM_RING) {
      setStreamVolumeInt(AudioManager.STREAM_NOTIFICATION,index,force,true);
    }
  }
}",0.996776273372018
183611,"@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
  setRingerModeInt(getRingerMode());
}","@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
  mRingerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
  setRingerModeInt(getRingerMode());
}",0.5139664804469274
183612,"/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 */
private void setStreamVolumeInt(int streamType,int index,boolean force){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index) || force) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}","/** 
 * Sets the stream state's index, and posts a message to set system volume. This will not call out to the UI. Assumes a valid stream type.
 * @param streamType Type of the stream
 * @param index Desired volume index of the stream
 * @param force If true, set the volume even if the desired volume is sameas the current volume.
 * @param lastAudible If true, stores new index as last audible one
 */
private void setStreamVolumeInt(int streamType,int index,boolean force,boolean lastAudible){
  VolumeStreamState streamState=mStreamStates[streamType];
  if (streamState.setIndex(index,lastAudible) || force) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,streamType,SENDMSG_NOOP,0,0,streamState,0);
    }
  }
}",0.9294781382228492
183613,"public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          mICallback.linkToDeath(this,0);
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          mICallback.unlinkToDeath(this,0);
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}","public void mute(boolean state){
synchronized (mDeathHandlers) {
    if (state) {
      if (mMuteCount == 0) {
        try {
          mICallback.linkToDeath(this,0);
          mDeathHandlers.add(this);
          if (muteCount() == 0) {
            setIndex(0,false);
            sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
          }
        }
 catch (        RemoteException e) {
          binderDied();
          mDeathHandlers.notify();
          return;
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"" + mStreamType + ""String_Node_Str"");
      }
      mMuteCount++;
    }
 else {
      if (mMuteCount == 0) {
        Log.e(TAG,""String_Node_Str"" + mStreamType);
      }
 else {
        mMuteCount--;
        if (mMuteCount == 0) {
          mDeathHandlers.remove(this);
          mICallback.unlinkToDeath(this,0);
          if (muteCount() == 0) {
            if (!isStreamAffectedByRingerMode(mStreamType) || mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
              setIndex(mLastAudibleIndex,false);
              sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,mStreamType,SENDMSG_NOOP,0,0,VolumeStreamState.this,0);
            }
          }
        }
      }
    }
    mDeathHandlers.notify();
  }
}",0.9952978056426331
183614,"public boolean adjustIndex(int deltaIndex){
  return setIndex(mIndex + deltaIndex);
}","public boolean adjustIndex(int deltaIndex){
  return setIndex(mIndex + deltaIndex,true);
}",0.9714285714285714
183615,"private void setRingerModeInt(int ringerMode){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,0,false);
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
}","private void setRingerModeInt(int ringerMode){
  mRingerMode=ringerMode;
  int numStreamTypes=AudioSystem.getNumStreamTypes();
  if (mRingerMode == AudioManager.RINGER_MODE_NORMAL) {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (!isStreamAffectedByRingerMode(streamType))       continue;
      setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
    }
  }
 else {
    for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
      if (isStreamAffectedByRingerMode(streamType)) {
        setStreamVolumeInt(streamType,0,false,false);
      }
 else {
        setStreamVolumeInt(streamType,mStreamStates[streamType].mLastAudibleIndex,false,false);
      }
    }
  }
  sendMsg(mAudioHandler,MSG_PERSIST_RINGER_MODE,SHARED_MSG,SENDMSG_REPLACE,0,0,null,PERSIST_DELAY);
}",0.9015673981191222
183616,"public boolean setIndex(int index){
  int oldIndex=mIndex;
  mIndex=getValidIndex(index);
  if (oldIndex != mIndex) {
    if (mIndex > 0) {
      mLastAudibleIndex=mIndex;
    }
    return true;
  }
 else {
    return false;
  }
}","public boolean setIndex(int index,boolean lastAudible){
  int oldIndex=mIndex;
  mIndex=getValidIndex(index);
  if (oldIndex != mIndex) {
    if (lastAudible) {
      mLastAudibleIndex=mIndex;
    }
    return true;
  }
 else {
    return false;
  }
}",0.9147609147609148
183617,"/** 
 * @see AudioManager#setRouting(int,int,int) 
 */
public void setRouting(int mode,int routes,int mask){
  int incallMask=0;
  int ringtoneMask=0;
  int normalMask=0;
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_INVALID) {
switch (mask) {
case AudioSystem.ROUTE_SPEAKER:
        if (routes != 0 && !mSpeakerIsOn) {
          mSpeakerIsOn=true;
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
          incallMask=AudioSystem.ROUTE_ALL;
        }
 else         if (mSpeakerIsOn) {
          mSpeakerIsOn=false;
          if (mBluetoothScoIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
          }
 else           if (mHeadsetIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
          }
 else {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
          }
          incallMask=AudioSystem.ROUTE_ALL;
        }
      break;
case AudioSystem.ROUTE_BLUETOOTH_SCO:
    if (routes != 0 && !mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=true;
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
 else     if (mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=false;
      if (mHeadsetIsConnected) {
        mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
      }
 else {
        if (mSpeakerIsOn) {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
        }
 else {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
        }
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
      }
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
  break;
case AudioSystem.ROUTE_HEADSET:
if (routes != 0 && !mHeadsetIsConnected) {
  mHeadsetIsConnected=true;
  if (!mBluetoothScoIsConnected) {
    mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
 else if (mHeadsetIsConnected) {
  mHeadsetIsConnected=false;
  if (!mBluetoothScoIsConnected) {
    if (mSpeakerIsOn) {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
    }
 else {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
    }
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
break;
case AudioSystem.ROUTE_BLUETOOTH_A2DP:
if (routes != 0 && !mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=true;
mRoutes[AudioSystem.MODE_RINGTONE]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
 else if (mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=false;
mRoutes[AudioSystem.MODE_RINGTONE]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
break;
}
if (incallMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_IN_CALL,mRoutes[AudioSystem.MODE_IN_CALL],incallMask);
}
if (ringtoneMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_RINGTONE,mRoutes[AudioSystem.MODE_RINGTONE],ringtoneMask);
}
if (normalMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_NORMAL,mRoutes[AudioSystem.MODE_NORMAL],normalMask);
}
int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
int index=mStreamStates[streamType].mIndex;
syncRingerAndNotificationStreamVolume(streamType,index,true);
setStreamVolumeInt(streamType,index,true);
}
}
}","/** 
 * @see AudioManager#setRouting(int,int,int) 
 */
public void setRouting(int mode,int routes,int mask){
  int incallMask=0;
  int ringtoneMask=0;
  int normalMask=0;
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_INVALID) {
switch (mask) {
case AudioSystem.ROUTE_SPEAKER:
        if (routes != 0 && !mSpeakerIsOn) {
          mSpeakerIsOn=true;
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
          incallMask=AudioSystem.ROUTE_ALL;
        }
 else         if (mSpeakerIsOn) {
          mSpeakerIsOn=false;
          if (mBluetoothScoIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
          }
 else           if (mHeadsetIsConnected) {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
          }
 else {
            mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
          }
          incallMask=AudioSystem.ROUTE_ALL;
        }
      break;
case AudioSystem.ROUTE_BLUETOOTH_SCO:
    if (routes != 0 && !mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=true;
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_BLUETOOTH_SCO;
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
 else     if (mBluetoothScoIsConnected) {
      mBluetoothScoIsConnected=false;
      if (mHeadsetIsConnected) {
        mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
      }
 else {
        if (mSpeakerIsOn) {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
        }
 else {
          mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
        }
        mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
        mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
      }
      incallMask=AudioSystem.ROUTE_ALL;
      ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
      normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    }
  break;
case AudioSystem.ROUTE_HEADSET:
if (routes != 0 && !mHeadsetIsConnected) {
  mHeadsetIsConnected=true;
  if (!mBluetoothScoIsConnected) {
    mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_HEADSET;
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | (AudioSystem.ROUTE_HEADSET | AudioSystem.ROUTE_SPEAKER);
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_HEADSET;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
 else if (mHeadsetIsConnected) {
  mHeadsetIsConnected=false;
  if (!mBluetoothScoIsConnected) {
    if (mSpeakerIsOn) {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_SPEAKER;
    }
 else {
      mRoutes[AudioSystem.MODE_IN_CALL]=AudioSystem.ROUTE_EARPIECE;
    }
    mRoutes[AudioSystem.MODE_RINGTONE]=(mRoutes[AudioSystem.MODE_RINGTONE] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    mRoutes[AudioSystem.MODE_NORMAL]=(mRoutes[AudioSystem.MODE_NORMAL] & AudioSystem.ROUTE_BLUETOOTH_A2DP) | AudioSystem.ROUTE_SPEAKER;
    incallMask=AudioSystem.ROUTE_ALL;
    ringtoneMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
    normalMask=AudioSystem.ROUTE_ALL & ~AudioSystem.ROUTE_BLUETOOTH_A2DP;
  }
}
break;
case AudioSystem.ROUTE_BLUETOOTH_A2DP:
if (routes != 0 && !mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=true;
mRoutes[AudioSystem.MODE_RINGTONE]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]|=AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
 else if (mBluetoothA2dpIsConnected) {
mBluetoothA2dpIsConnected=false;
mRoutes[AudioSystem.MODE_RINGTONE]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
mRoutes[AudioSystem.MODE_NORMAL]&=~AudioSystem.ROUTE_BLUETOOTH_A2DP;
ringtoneMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
normalMask=AudioSystem.ROUTE_BLUETOOTH_A2DP;
}
break;
}
if (incallMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_IN_CALL,mRoutes[AudioSystem.MODE_IN_CALL],incallMask);
}
if (ringtoneMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_RINGTONE,mRoutes[AudioSystem.MODE_RINGTONE],ringtoneMask);
}
if (normalMask != 0) {
AudioSystem.setRouting(AudioSystem.MODE_NORMAL,mRoutes[AudioSystem.MODE_NORMAL],normalMask);
}
int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
int index=mStreamStates[streamType].mIndex;
syncRingerAndNotificationStreamVolume(streamType,index,true);
setStreamVolumeInt(streamType,index,true,true);
}
}
}",0.9995593548955672
183618,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode != mMode) {
      if (AudioSystem.setMode(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[streamType].mIndex;
    syncRingerAndNotificationStreamVolume(streamType,index,true);
    setStreamVolumeInt(streamType,index,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode != mMode) {
      if (AudioSystem.setMode(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[streamType].mIndex;
    syncRingerAndNotificationStreamVolume(streamType,index,true);
    setStreamVolumeInt(streamType,index,true,true);
  }
}",0.9954995499549956
183619,"private void readPersistedSettings(){
  final ContentResolver cr=mContentResolver;
  mRingerMode=System.getInt(cr,System.MODE_RINGER,AudioManager.RINGER_MODE_NORMAL);
  mVibrateSetting=System.getInt(cr,System.VIBRATE_ON,0);
  mMuteAffectedStreams=System.getInt(cr,System.MUTE_STREAMS_AFFECTED,((1 << AudioSystem.STREAM_MUSIC) | (1 << AudioSystem.STREAM_RING) | (1 << AudioSystem.STREAM_SYSTEM)));
  broadcastRingerMode();
  broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
  broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
}","private void readPersistedSettings(){
  final ContentResolver cr=mContentResolver;
  mRingerMode=System.getInt(cr,System.MODE_RINGER,AudioManager.RINGER_MODE_NORMAL);
  mVibrateSetting=System.getInt(cr,System.VIBRATE_ON,0);
  mRingerModeAffectedStreams=Settings.System.getInt(cr,Settings.System.MODE_RINGER_STREAMS_AFFECTED,((1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)));
  mMuteAffectedStreams=System.getInt(cr,System.MUTE_STREAMS_AFFECTED,((1 << AudioSystem.STREAM_MUSIC) | (1 << AudioSystem.STREAM_RING) | (1 << AudioSystem.STREAM_SYSTEM)));
  broadcastRingerMode();
  broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
  broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
}",0.817629179331307
183620,"/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  syncRingerAndNotificationStreamVolume(streamType,index,false);
  setStreamVolumeInt(streamType,index,false);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}","/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  syncRingerAndNotificationStreamVolume(streamType,index,false);
  setStreamVolumeInt(streamType,index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}",0.9930651872399444
183621,"private void updateProviderListenersLocked(String provider,boolean enabled){
  int listeners=0;
  LocationProviderProxy p=mProvidersByName.get(provider);
  if (p == null) {
    return;
  }
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records != null) {
    final int N=records.size();
    for (int i=0; i < N; i++) {
      UpdateRecord record=records.get(i);
      if (!record.mReceiver.callProviderEnabledLocked(provider,enabled)) {
        if (deadReceivers == null) {
          deadReceivers=new ArrayList<Receiver>();
          deadReceivers.add(record.mReceiver);
        }
      }
      listeners++;
    }
  }
  if (deadReceivers != null) {
    for (int i=deadReceivers.size() - 1; i >= 0; i--) {
      removeUpdatesLocked(deadReceivers.get(i));
    }
  }
  if (enabled) {
    p.enable();
    if (listeners > 0) {
      p.setMinTime(getMinTimeLocked(provider));
      p.enableLocationTracking(true);
    }
  }
 else {
    p.enableLocationTracking(false);
    p.disable();
  }
}","private void updateProviderListenersLocked(String provider,boolean enabled){
  int listeners=0;
  LocationProviderProxy p=mProvidersByName.get(provider);
  if (p == null) {
    return;
  }
  ArrayList<Receiver> deadReceivers=null;
  ArrayList<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records != null) {
    final int N=records.size();
    for (int i=0; i < N; i++) {
      UpdateRecord record=records.get(i);
      if (!record.mReceiver.callProviderEnabledLocked(provider,enabled)) {
        if (deadReceivers == null) {
          deadReceivers=new ArrayList<Receiver>();
        }
        deadReceivers.add(record.mReceiver);
      }
      listeners++;
    }
  }
  if (deadReceivers != null) {
    for (int i=deadReceivers.size() - 1; i >= 0; i--) {
      removeUpdatesLocked(deadReceivers.get(i));
    }
  }
  if (enabled) {
    p.enable();
    if (listeners > 0) {
      p.setMinTime(getMinTimeLocked(provider));
      p.enableLocationTracking(true);
    }
  }
 else {
    p.enableLocationTracking(false);
    p.disable();
  }
}",0.9914529914529916
183622,"/** 
 * Formats a date or a time range according to the local conventions. <p> Example output strings (date formats in these examples are shown using the US date format convention but that may change depending on the local settings): <ul> <li>10:15am</li> <li>3:00pm - 4:00pm</li> <li>3pm - 4pm</li> <li>3PM - 4PM</li> <li>08:00 - 17:00</li> <li>Oct 9</li> <li>Tue, Oct 9</li> <li>October 9, 2007</li> <li>Oct 9 - 10</li> <li>Oct 9 - 10, 2007</li> <li>Oct 28 - Nov 3, 2007</li> <li>Dec 31, 2007 - Jan 1, 2008</li> <li>Oct 9, 8:00am - Oct 10, 5:00pm</li> <li>12/31/2007 - 01/01/2008</li> </ul> <p> The flags argument is a bitmask of options from the following list: <ul> <li>FORMAT_SHOW_TIME</li> <li>FORMAT_SHOW_WEEKDAY</li> <li>FORMAT_SHOW_YEAR</li> <li>FORMAT_NO_YEAR</li> <li>FORMAT_SHOW_DATE</li> <li>FORMAT_NO_MONTH_DAY</li> <li>FORMAT_12HOUR</li> <li>FORMAT_24HOUR</li> <li>FORMAT_CAP_AMPM</li> <li>FORMAT_NO_NOON</li> <li>FORMAT_CAP_NOON</li> <li>FORMAT_NO_MIDNIGHT</li> <li>FORMAT_CAP_MIDNIGHT</li> <li>FORMAT_UTC</li> <li>FORMAT_ABBREV_TIME</li> <li>FORMAT_ABBREV_WEEKDAY</li> <li>FORMAT_ABBREV_MONTH</li> <li>FORMAT_ABBREV_ALL</li> <li>FORMAT_NUMERIC_DATE</li> </ul> <p> If FORMAT_SHOW_TIME is set, the time is shown as part of the date range. If the start and end time are the same, then just the start time is shown. <p> If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown. <p> If FORMAT_SHOW_YEAR is set, then the year is always shown. If FORMAT_NO_YEAR is set, then the year is not shown. If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year is shown only if it is different from the current year, or if the start and end dates fall on different years.  If both are set, FORMAT_SHOW_YEAR takes precedence. <p> Normally the date is shown unless the start and end day are the same. If FORMAT_SHOW_DATE is set, then the date is always shown, even for same day ranges. <p> If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the month name will be shown, not the day of the month.  For example, ""January, 2008"" instead of ""January 6 - 12, 2008"". <p> If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM"" and ""PM"" are capitalized. <p> If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is shown instead of ""noon"". <p> If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is shown instead of ""noon"". <p> If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is shown instead of ""midnight"". <p> If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Midnight"" is shown instead of ""midnight"". <p> If FORMAT_12HOUR is set and the time is shown, then the time is shown in the 12-hour time format. You should not normally set this. Instead, let the time format be chosen automatically according to the system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then FORMAT_24HOUR takes precedence. <p> If FORMAT_24HOUR is set and the time is shown, then the time is shown in the 24-hour time format. You should not normally set this. Instead, let the time format be chosen automatically according to the system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then FORMAT_24HOUR takes precedence. <p> If FORMAT_UTC is set, then the UTC timezone is used for the start and end milliseconds. <p> If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the start and end times (if shown) are abbreviated by not showing the minutes if they are zero.  For example, instead of ""3:00pm"" the time would be abbreviated to ""3pm"". <p> If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is abbreviated to a 3-letter string. <p> If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated to a 3-letter string. <p> If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown) are abbreviated to 3-letter strings. <p> If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format instead of using the name of the month.  For example, ""12/31/2008"" instead of ""December 31, 2008"".
 * @param context the context is required only if the time is shown
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @return a string containing the formatted date/time range.
 */
public static String formatDateRange(Context context,long startMillis,long endMillis,int flags){
  Resources res=Resources.getSystem();
  boolean showTime=(flags & FORMAT_SHOW_TIME) != 0;
  boolean showWeekDay=(flags & FORMAT_SHOW_WEEKDAY) != 0;
  boolean showYear=(flags & FORMAT_SHOW_YEAR) != 0;
  boolean noYear=(flags & FORMAT_NO_YEAR) != 0;
  boolean useUTC=(flags & FORMAT_UTC) != 0;
  boolean abbrevWeekDay=(flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
  boolean abbrevMonth=(flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
  boolean noMonthDay=(flags & FORMAT_NO_MONTH_DAY) != 0;
  boolean numericDate=(flags & FORMAT_NUMERIC_DATE) != 0;
  boolean isInstant=(startMillis == endMillis);
  Time startDate=useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
  startDate.set(startMillis);
  Time endDate;
  int dayDistance;
  if (isInstant) {
    endDate=startDate;
    dayDistance=0;
  }
 else {
    endDate=useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
    endDate.set(endMillis);
    int startJulianDay=Time.getJulianDay(startMillis,startDate.gmtoff);
    int endJulianDay=Time.getJulianDay(endMillis,endDate.gmtoff);
    dayDistance=endJulianDay - startJulianDay;
  }
  if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
    endDate.monthDay-=1;
    endDate.normalize(true);
  }
  int startDay=startDate.monthDay;
  int startMonthNum=startDate.month;
  int startYear=startDate.year;
  int endDay=endDate.monthDay;
  int endMonthNum=endDate.month;
  int endYear=endDate.year;
  String startWeekDayString=""String_Node_Str"";
  String endWeekDayString=""String_Node_Str"";
  if (showWeekDay) {
    String weekDayFormat=""String_Node_Str"";
    if (abbrevWeekDay) {
      weekDayFormat=ABBREV_WEEKDAY_FORMAT;
    }
 else {
      weekDayFormat=WEEKDAY_FORMAT;
    }
    startWeekDayString=startDate.format(weekDayFormat);
    endWeekDayString=isInstant ? startWeekDayString : endDate.format(weekDayFormat);
  }
  String startTimeString=""String_Node_Str"";
  String endTimeString=""String_Node_Str"";
  if (showTime) {
    String startTimeFormat=""String_Node_Str"";
    String endTimeFormat=""String_Node_Str"";
    boolean force24Hour=(flags & FORMAT_24HOUR) != 0;
    boolean force12Hour=(flags & FORMAT_12HOUR) != 0;
    boolean use24Hour;
    if (force24Hour) {
      use24Hour=true;
    }
 else     if (force12Hour) {
      use24Hour=false;
    }
 else {
      use24Hour=DateFormat.is24HourFormat(context);
    }
    if (use24Hour) {
      startTimeFormat=HOUR_MINUTE_24;
      endTimeFormat=HOUR_MINUTE_24;
    }
 else {
      boolean abbrevTime=(flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
      boolean capAMPM=(flags & FORMAT_CAP_AMPM) != 0;
      boolean noNoon=(flags & FORMAT_NO_NOON) != 0;
      boolean capNoon=(flags & FORMAT_CAP_NOON) != 0;
      boolean noMidnight=(flags & FORMAT_NO_MIDNIGHT) != 0;
      boolean capMidnight=(flags & FORMAT_CAP_MIDNIGHT) != 0;
      boolean startOnTheHour=startDate.minute == 0 && startDate.second == 0;
      boolean endOnTheHour=endDate.minute == 0 && endDate.second == 0;
      if (abbrevTime && startOnTheHour) {
        if (capAMPM) {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_cap_ampm);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_ampm);
        }
      }
 else {
        if (capAMPM) {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_minute_ampm);
        }
      }
      if (!isInstant) {
        if (abbrevTime && endOnTheHour) {
          if (capAMPM) {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_cap_ampm);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_ampm);
          }
        }
 else {
          if (capAMPM) {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_minute_ampm);
          }
        }
        if (endDate.hour == 12 && endOnTheHour && !noNoon) {
          if (capNoon) {
            endTimeFormat=res.getString(com.android.internal.R.string.Noon);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.noon);
          }
        }
 else         if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
          if (capMidnight) {
            endTimeFormat=res.getString(com.android.internal.R.string.Midnight);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.midnight);
          }
        }
      }
      if (startDate.hour == 12 && startOnTheHour && !noNoon) {
        if (capNoon) {
          startTimeFormat=res.getString(com.android.internal.R.string.Noon);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.noon);
        }
      }
    }
    startTimeString=startDate.format(startTimeFormat);
    endTimeString=isInstant ? startTimeString : endDate.format(endTimeFormat);
  }
  if (showYear) {
  }
 else   if (noYear) {
    showYear=false;
  }
 else   if (startYear != endYear) {
    showYear=true;
  }
 else {
    Time currentTime=new Time();
    currentTime.setToNow();
    showYear=startYear != currentTime.year;
  }
  String defaultDateFormat, fullFormat, dateRange;
  if (numericDate) {
    defaultDateFormat=res.getString(com.android.internal.R.string.numeric_date);
  }
 else   if (showYear) {
    if (abbrevMonth) {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_year);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_day_year);
      }
    }
 else {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_year);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_day_year);
      }
    }
  }
 else {
    if (abbrevMonth) {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_day);
      }
    }
 else {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.month);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_day);
      }
    }
  }
  if (showWeekDay) {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
    }
 else {
      fullFormat=res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
    }
  }
 else {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.date1_time1_date2_time2);
    }
 else {
      fullFormat=res.getString(com.android.internal.R.string.date1_date2);
    }
  }
  if (noMonthDay && startMonthNum == endMonthNum) {
    String startDateString=startDate.format(defaultDateFormat);
    return startDateString;
  }
  if (startYear != endYear || noMonthDay) {
    String startDateString=startDate.format(defaultDateFormat);
    String endDateString=endDate.format(defaultDateFormat);
    dateRange=String.format(fullFormat,startWeekDayString,startDateString,startTimeString,endWeekDayString,endDateString,endTimeString);
    return dateRange;
  }
  String monthFormat;
  if (numericDate) {
    monthFormat=NUMERIC_MONTH_FORMAT;
  }
 else   if (abbrevMonth) {
    monthFormat=ABBREV_MONTH_FORMAT;
  }
 else {
    monthFormat=MONTH_FORMAT;
  }
  String startMonthString=startDate.format(monthFormat);
  String startMonthDayString=startDate.format(MONTH_DAY_FORMAT);
  String startYearString=startDate.format(YEAR_FORMAT);
  String endMonthString=isInstant ? null : endDate.format(monthFormat);
  String endMonthDayString=isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
  String endYearString=isInstant ? null : endDate.format(YEAR_FORMAT);
  if (startMonthNum != endMonthNum) {
    int index=0;
    if (showWeekDay)     index=1;
    if (showYear)     index+=2;
    if (showTime)     index+=4;
    if (numericDate)     index+=8;
    int resId=sameYearTable[index];
    fullFormat=res.getString(resId);
    dateRange=String.format(fullFormat,startWeekDayString,startMonthString,startMonthDayString,startYearString,startTimeString,endWeekDayString,endMonthString,endMonthDayString,endYearString,endTimeString);
    return dateRange;
  }
  if (startDay != endDay) {
    int index=0;
    if (showWeekDay)     index=1;
    if (showYear)     index+=2;
    if (showTime)     index+=4;
    if (numericDate)     index+=8;
    int resId=sameMonthTable[index];
    fullFormat=res.getString(resId);
    dateRange=String.format(fullFormat,startWeekDayString,startMonthString,startMonthDayString,startYearString,startTimeString,endWeekDayString,endMonthString,endMonthDayString,endYearString,endTimeString);
    return dateRange;
  }
  boolean showDate=(flags & FORMAT_SHOW_DATE) != 0;
  if (!showTime && !showDate && !showWeekDay)   showDate=true;
  String timeString=""String_Node_Str"";
  if (showTime) {
    if (isInstant) {
      timeString=startTimeString;
    }
 else {
      String timeFormat=res.getString(com.android.internal.R.string.time1_time2);
      timeString=String.format(timeFormat,startTimeString,endTimeString);
    }
  }
  fullFormat=""String_Node_Str"";
  String dateString=""String_Node_Str"";
  if (showDate) {
    dateString=startDate.format(defaultDateFormat);
    if (showWeekDay) {
      if (showTime) {
        fullFormat=res.getString(com.android.internal.R.string.time_wday_date);
      }
 else {
        fullFormat=res.getString(com.android.internal.R.string.wday_date);
      }
    }
 else {
      if (showTime) {
        fullFormat=res.getString(com.android.internal.R.string.time_date);
      }
 else {
        return dateString;
      }
    }
  }
 else   if (showWeekDay) {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.time_wday);
    }
 else {
      return startWeekDayString;
    }
  }
 else   if (showTime) {
    return timeString;
  }
  dateRange=String.format(fullFormat,timeString,startWeekDayString,dateString);
  return dateRange;
}","/** 
 * Formats a date or a time range according to the local conventions. <p> Example output strings (date formats in these examples are shown using the US date format convention but that may change depending on the local settings): <ul> <li>10:15am</li> <li>3:00pm - 4:00pm</li> <li>3pm - 4pm</li> <li>3PM - 4PM</li> <li>08:00 - 17:00</li> <li>Oct 9</li> <li>Tue, Oct 9</li> <li>October 9, 2007</li> <li>Oct 9 - 10</li> <li>Oct 9 - 10, 2007</li> <li>Oct 28 - Nov 3, 2007</li> <li>Dec 31, 2007 - Jan 1, 2008</li> <li>Oct 9, 8:00am - Oct 10, 5:00pm</li> <li>12/31/2007 - 01/01/2008</li> </ul> <p> The flags argument is a bitmask of options from the following list: <ul> <li>FORMAT_SHOW_TIME</li> <li>FORMAT_SHOW_WEEKDAY</li> <li>FORMAT_SHOW_YEAR</li> <li>FORMAT_NO_YEAR</li> <li>FORMAT_SHOW_DATE</li> <li>FORMAT_NO_MONTH_DAY</li> <li>FORMAT_12HOUR</li> <li>FORMAT_24HOUR</li> <li>FORMAT_CAP_AMPM</li> <li>FORMAT_NO_NOON</li> <li>FORMAT_CAP_NOON</li> <li>FORMAT_NO_MIDNIGHT</li> <li>FORMAT_CAP_MIDNIGHT</li> <li>FORMAT_UTC</li> <li>FORMAT_ABBREV_TIME</li> <li>FORMAT_ABBREV_WEEKDAY</li> <li>FORMAT_ABBREV_MONTH</li> <li>FORMAT_ABBREV_ALL</li> <li>FORMAT_NUMERIC_DATE</li> </ul> <p> If FORMAT_SHOW_TIME is set, the time is shown as part of the date range. If the start and end time are the same, then just the start time is shown. <p> If FORMAT_SHOW_WEEKDAY is set, then the weekday is shown. <p> If FORMAT_SHOW_YEAR is set, then the year is always shown. If FORMAT_NO_YEAR is set, then the year is not shown. If neither FORMAT_SHOW_YEAR nor FORMAT_NO_YEAR are set, then the year is shown only if it is different from the current year, or if the start and end dates fall on different years.  If both are set, FORMAT_SHOW_YEAR takes precedence. <p> Normally the date is shown unless the start and end day are the same. If FORMAT_SHOW_DATE is set, then the date is always shown, even for same day ranges. <p> If FORMAT_NO_MONTH_DAY is set, then if the date is shown, just the month name will be shown, not the day of the month.  For example, ""January, 2008"" instead of ""January 6 - 12, 2008"". <p> If FORMAT_CAP_AMPM is set and 12-hour time is used, then the ""AM"" and ""PM"" are capitalized.  You should not use this flag because in some locales these terms cannot be capitalized, and in many others it doesn't make sense to do so even though it is possible. <p> If FORMAT_NO_NOON is set and 12-hour time is used, then ""12pm"" is shown instead of ""noon"". <p> If FORMAT_CAP_NOON is set and 12-hour time is used, then ""Noon"" is shown instead of ""noon"".  You should probably not use this flag because in many locales it will not make sense to capitalize the term. <p> If FORMAT_NO_MIDNIGHT is set and 12-hour time is used, then ""12am"" is shown instead of ""midnight"". <p> If FORMAT_CAP_MIDNIGHT is set and 12-hour time is used, then ""Midnight"" is shown instead of ""midnight"".  You should probably not use this flag because in many locales it will not make sense to capitalize the term. <p> If FORMAT_12HOUR is set and the time is shown, then the time is shown in the 12-hour time format. You should not normally set this. Instead, let the time format be chosen automatically according to the system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then FORMAT_24HOUR takes precedence. <p> If FORMAT_24HOUR is set and the time is shown, then the time is shown in the 24-hour time format. You should not normally set this. Instead, let the time format be chosen automatically according to the system settings. If both FORMAT_12HOUR and FORMAT_24HOUR are set, then FORMAT_24HOUR takes precedence. <p> If FORMAT_UTC is set, then the UTC timezone is used for the start and end milliseconds. <p> If FORMAT_ABBREV_TIME is set and 12-hour time format is used, then the start and end times (if shown) are abbreviated by not showing the minutes if they are zero.  For example, instead of ""3:00pm"" the time would be abbreviated to ""3pm"". <p> If FORMAT_ABBREV_WEEKDAY is set, then the weekday (if shown) is abbreviated to a 3-letter string. <p> If FORMAT_ABBREV_MONTH is set, then the month (if shown) is abbreviated to a 3-letter string. <p> If FORMAT_ABBREV_ALL is set, then the weekday and the month (if shown) are abbreviated to 3-letter strings. <p> If FORMAT_NUMERIC_DATE is set, then the date is shown in numeric format instead of using the name of the month.  For example, ""12/31/2008"" instead of ""December 31, 2008"".
 * @param context the context is required only if the time is shown
 * @param startMillis the start time in UTC milliseconds
 * @param endMillis the end time in UTC milliseconds
 * @param flags a bit mask of options
 * @return a string containing the formatted date/time range.
 */
public static String formatDateRange(Context context,long startMillis,long endMillis,int flags){
  Resources res=Resources.getSystem();
  boolean showTime=(flags & FORMAT_SHOW_TIME) != 0;
  boolean showWeekDay=(flags & FORMAT_SHOW_WEEKDAY) != 0;
  boolean showYear=(flags & FORMAT_SHOW_YEAR) != 0;
  boolean noYear=(flags & FORMAT_NO_YEAR) != 0;
  boolean useUTC=(flags & FORMAT_UTC) != 0;
  boolean abbrevWeekDay=(flags & (FORMAT_ABBREV_WEEKDAY | FORMAT_ABBREV_ALL)) != 0;
  boolean abbrevMonth=(flags & (FORMAT_ABBREV_MONTH | FORMAT_ABBREV_ALL)) != 0;
  boolean noMonthDay=(flags & FORMAT_NO_MONTH_DAY) != 0;
  boolean numericDate=(flags & FORMAT_NUMERIC_DATE) != 0;
  boolean isInstant=(startMillis == endMillis);
  Time startDate=useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
  startDate.set(startMillis);
  Time endDate;
  int dayDistance;
  if (isInstant) {
    endDate=startDate;
    dayDistance=0;
  }
 else {
    endDate=useUTC ? new Time(Time.TIMEZONE_UTC) : new Time();
    endDate.set(endMillis);
    int startJulianDay=Time.getJulianDay(startMillis,startDate.gmtoff);
    int endJulianDay=Time.getJulianDay(endMillis,endDate.gmtoff);
    dayDistance=endJulianDay - startJulianDay;
  }
  if (!isInstant && (endDate.hour | endDate.minute | endDate.second) == 0 && (!showTime || dayDistance <= 1)) {
    endDate.monthDay-=1;
    endDate.normalize(true);
  }
  int startDay=startDate.monthDay;
  int startMonthNum=startDate.month;
  int startYear=startDate.year;
  int endDay=endDate.monthDay;
  int endMonthNum=endDate.month;
  int endYear=endDate.year;
  String startWeekDayString=""String_Node_Str"";
  String endWeekDayString=""String_Node_Str"";
  if (showWeekDay) {
    String weekDayFormat=""String_Node_Str"";
    if (abbrevWeekDay) {
      weekDayFormat=ABBREV_WEEKDAY_FORMAT;
    }
 else {
      weekDayFormat=WEEKDAY_FORMAT;
    }
    startWeekDayString=startDate.format(weekDayFormat);
    endWeekDayString=isInstant ? startWeekDayString : endDate.format(weekDayFormat);
  }
  String startTimeString=""String_Node_Str"";
  String endTimeString=""String_Node_Str"";
  if (showTime) {
    String startTimeFormat=""String_Node_Str"";
    String endTimeFormat=""String_Node_Str"";
    boolean force24Hour=(flags & FORMAT_24HOUR) != 0;
    boolean force12Hour=(flags & FORMAT_12HOUR) != 0;
    boolean use24Hour;
    if (force24Hour) {
      use24Hour=true;
    }
 else     if (force12Hour) {
      use24Hour=false;
    }
 else {
      use24Hour=DateFormat.is24HourFormat(context);
    }
    if (use24Hour) {
      startTimeFormat=endTimeFormat=res.getString(com.android.internal.R.string.hour_minute_24);
    }
 else {
      boolean abbrevTime=(flags & (FORMAT_ABBREV_TIME | FORMAT_ABBREV_ALL)) != 0;
      boolean capAMPM=(flags & FORMAT_CAP_AMPM) != 0;
      boolean noNoon=(flags & FORMAT_NO_NOON) != 0;
      boolean capNoon=(flags & FORMAT_CAP_NOON) != 0;
      boolean noMidnight=(flags & FORMAT_NO_MIDNIGHT) != 0;
      boolean capMidnight=(flags & FORMAT_CAP_MIDNIGHT) != 0;
      boolean startOnTheHour=startDate.minute == 0 && startDate.second == 0;
      boolean endOnTheHour=endDate.minute == 0 && endDate.second == 0;
      if (abbrevTime && startOnTheHour) {
        if (capAMPM) {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_cap_ampm);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_ampm);
        }
      }
 else {
        if (capAMPM) {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.hour_minute_ampm);
        }
      }
      if (!isInstant) {
        if (abbrevTime && endOnTheHour) {
          if (capAMPM) {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_cap_ampm);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_ampm);
          }
        }
 else {
          if (capAMPM) {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_minute_cap_ampm);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.hour_minute_ampm);
          }
        }
        if (endDate.hour == 12 && endOnTheHour && !noNoon) {
          if (capNoon) {
            endTimeFormat=res.getString(com.android.internal.R.string.Noon);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.noon);
          }
        }
 else         if (endDate.hour == 0 && endOnTheHour && !noMidnight) {
          if (capMidnight) {
            endTimeFormat=res.getString(com.android.internal.R.string.Midnight);
          }
 else {
            endTimeFormat=res.getString(com.android.internal.R.string.midnight);
          }
        }
      }
      if (startDate.hour == 12 && startOnTheHour && !noNoon) {
        if (capNoon) {
          startTimeFormat=res.getString(com.android.internal.R.string.Noon);
        }
 else {
          startTimeFormat=res.getString(com.android.internal.R.string.noon);
        }
      }
    }
    startTimeString=startDate.format(startTimeFormat);
    endTimeString=isInstant ? startTimeString : endDate.format(endTimeFormat);
  }
  if (showYear) {
  }
 else   if (noYear) {
    showYear=false;
  }
 else   if (startYear != endYear) {
    showYear=true;
  }
 else {
    Time currentTime=new Time();
    currentTime.setToNow();
    showYear=startYear != currentTime.year;
  }
  String defaultDateFormat, fullFormat, dateRange;
  if (numericDate) {
    defaultDateFormat=res.getString(com.android.internal.R.string.numeric_date);
  }
 else   if (showYear) {
    if (abbrevMonth) {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_year);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_day_year);
      }
    }
 else {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_year);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_day_year);
      }
    }
  }
 else {
    if (abbrevMonth) {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.abbrev_month_day);
      }
    }
 else {
      if (noMonthDay) {
        defaultDateFormat=res.getString(com.android.internal.R.string.month);
      }
 else {
        defaultDateFormat=res.getString(com.android.internal.R.string.month_day);
      }
    }
  }
  if (showWeekDay) {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.wday1_date1_time1_wday2_date2_time2);
    }
 else {
      fullFormat=res.getString(com.android.internal.R.string.wday1_date1_wday2_date2);
    }
  }
 else {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.date1_time1_date2_time2);
    }
 else {
      fullFormat=res.getString(com.android.internal.R.string.date1_date2);
    }
  }
  if (noMonthDay && startMonthNum == endMonthNum) {
    String startDateString=startDate.format(defaultDateFormat);
    return startDateString;
  }
  if (startYear != endYear || noMonthDay) {
    String startDateString=startDate.format(defaultDateFormat);
    String endDateString=endDate.format(defaultDateFormat);
    dateRange=String.format(fullFormat,startWeekDayString,startDateString,startTimeString,endWeekDayString,endDateString,endTimeString);
    return dateRange;
  }
  String monthFormat;
  if (numericDate) {
    monthFormat=NUMERIC_MONTH_FORMAT;
  }
 else   if (abbrevMonth) {
    monthFormat=ABBREV_MONTH_FORMAT;
  }
 else {
    monthFormat=MONTH_FORMAT;
  }
  String startMonthString=startDate.format(monthFormat);
  String startMonthDayString=startDate.format(MONTH_DAY_FORMAT);
  String startYearString=startDate.format(YEAR_FORMAT);
  String endMonthString=isInstant ? null : endDate.format(monthFormat);
  String endMonthDayString=isInstant ? null : endDate.format(MONTH_DAY_FORMAT);
  String endYearString=isInstant ? null : endDate.format(YEAR_FORMAT);
  if (startMonthNum != endMonthNum) {
    int index=0;
    if (showWeekDay)     index=1;
    if (showYear)     index+=2;
    if (showTime)     index+=4;
    if (numericDate)     index+=8;
    int resId=sameYearTable[index];
    fullFormat=res.getString(resId);
    dateRange=String.format(fullFormat,startWeekDayString,startMonthString,startMonthDayString,startYearString,startTimeString,endWeekDayString,endMonthString,endMonthDayString,endYearString,endTimeString);
    return dateRange;
  }
  if (startDay != endDay) {
    int index=0;
    if (showWeekDay)     index=1;
    if (showYear)     index+=2;
    if (showTime)     index+=4;
    if (numericDate)     index+=8;
    int resId=sameMonthTable[index];
    fullFormat=res.getString(resId);
    dateRange=String.format(fullFormat,startWeekDayString,startMonthString,startMonthDayString,startYearString,startTimeString,endWeekDayString,endMonthString,endMonthDayString,endYearString,endTimeString);
    return dateRange;
  }
  boolean showDate=(flags & FORMAT_SHOW_DATE) != 0;
  if (!showTime && !showDate && !showWeekDay)   showDate=true;
  String timeString=""String_Node_Str"";
  if (showTime) {
    if (isInstant) {
      timeString=startTimeString;
    }
 else {
      String timeFormat=res.getString(com.android.internal.R.string.time1_time2);
      timeString=String.format(timeFormat,startTimeString,endTimeString);
    }
  }
  fullFormat=""String_Node_Str"";
  String dateString=""String_Node_Str"";
  if (showDate) {
    dateString=startDate.format(defaultDateFormat);
    if (showWeekDay) {
      if (showTime) {
        fullFormat=res.getString(com.android.internal.R.string.time_wday_date);
      }
 else {
        fullFormat=res.getString(com.android.internal.R.string.wday_date);
      }
    }
 else {
      if (showTime) {
        fullFormat=res.getString(com.android.internal.R.string.time_date);
      }
 else {
        return dateString;
      }
    }
  }
 else   if (showWeekDay) {
    if (showTime) {
      fullFormat=res.getString(com.android.internal.R.string.time_wday);
    }
 else {
      return startWeekDayString;
    }
  }
 else   if (showTime) {
    return timeString;
  }
  dateRange=String.format(fullFormat,timeString,startWeekDayString,dateString);
  return dateRange;
}",0.9827678691162666
183623,"public void save(OutputStream stream,boolean closeStream) throws IOException {
  if (!mChanged) {
    return;
  }
  DataOutputStream out=null;
  try {
    long start;
    if (PROFILE_LOADING_SAVING) {
      start=SystemClock.elapsedRealtime();
    }
    final HashMap<String,ArrayList<Gesture>> maps=mNamedGestures;
    out=new DataOutputStream((stream instanceof BufferedOutputStream) ? out : new BufferedOutputStream(out,GestureConstants.IO_BUFFER_SIZE));
    out.writeShort(FILE_FORMAT_VERSION);
    out.writeInt(maps.size());
    for (    Map.Entry<String,ArrayList<Gesture>> entry : maps.entrySet()) {
      final String key=entry.getKey();
      final ArrayList<Gesture> examples=entry.getValue();
      final int count=examples.size();
      out.writeUTF(key);
      out.writeInt(count);
      for (int i=0; i < count; i++) {
        examples.get(i).serialize(out);
      }
    }
    out.flush();
    if (PROFILE_LOADING_SAVING) {
      long end=SystemClock.elapsedRealtime();
      Log.d(LOG_TAG,""String_Node_Str"" + (end - start) + ""String_Node_Str"");
    }
    mChanged=false;
  }
  finally {
    if (closeStream)     GestureUtilities.closeStream(out);
  }
}","public void save(OutputStream stream,boolean closeStream) throws IOException {
  if (!mChanged) {
    return;
  }
  DataOutputStream out=null;
  try {
    long start;
    if (PROFILE_LOADING_SAVING) {
      start=SystemClock.elapsedRealtime();
    }
    final HashMap<String,ArrayList<Gesture>> maps=mNamedGestures;
    out=new DataOutputStream((stream instanceof BufferedOutputStream) ? stream : new BufferedOutputStream(stream,GestureConstants.IO_BUFFER_SIZE));
    out.writeShort(FILE_FORMAT_VERSION);
    out.writeInt(maps.size());
    for (    Map.Entry<String,ArrayList<Gesture>> entry : maps.entrySet()) {
      final String key=entry.getKey();
      final ArrayList<Gesture> examples=entry.getValue();
      final int count=examples.size();
      out.writeUTF(key);
      out.writeInt(count);
      for (int i=0; i < count; i++) {
        examples.get(i).serialize(out);
      }
    }
    out.flush();
    if (PROFILE_LOADING_SAVING) {
      long end=SystemClock.elapsedRealtime();
      Log.d(LOG_TAG,""String_Node_Str"" + (end - start) + ""String_Node_Str"");
    }
    mChanged=false;
  }
  finally {
    if (closeStream)     GestureUtilities.closeStream(out);
  }
}",0.9923076923076924
183624,"@Override protected void runTest() throws Throwable {
  ReliabilityTestActivity activity=getActivity();
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  File testListFile=new File(TEST_LIST_FILE);
  if (!testListFile.exists())   throw new FileNotFoundException(""String_Node_Str"");
  BufferedReader listReader=new BufferedReader(new FileReader(testListFile));
  String lastUrl=readTestStatus();
  if (lastUrl != null && !TEST_DONE.equals(lastUrl))   fastForward(listReader,lastUrl);
  String url=null;
  Handler handler=null;
  boolean timeoutFlag=false;
  long start, elapsed;
  while ((url=listReader.readLine()) != null) {
    start=System.currentTimeMillis();
    Log.v(LOGTAG,""String_Node_Str"" + url);
    updateTestStatus(url);
    activity.reset();
    handler=activity.getHandler();
    handler.sendMessage(handler.obtainMessage(ReliabilityTestActivity.MSG_NAVIGATE,runner.mTimeoutInMillis,0,url));
    timeoutFlag=activity.waitUntilDone();
    elapsed=System.currentTimeMillis() - start;
    if (elapsed < 1000) {
      Log.w(LOGTAG,""String_Node_Str"" + elapsed + ""String_Node_Str"");
    }
 else {
      Log.v(LOGTAG,""String_Node_Str"" + elapsed + ""String_Node_Str"");
    }
    if (timeoutFlag) {
      writeTimeoutFile(url);
    }
    System.runFinalization();
    System.gc();
    System.gc();
  }
  activity.finish();
  listReader.close();
}","@Override protected void runTest() throws Throwable {
  ReliabilityTestActivity activity=getActivity();
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  File testListFile=new File(TEST_LIST_FILE);
  if (!testListFile.exists())   throw new FileNotFoundException(""String_Node_Str"");
  BufferedReader listReader=new BufferedReader(new FileReader(testListFile));
  String lastUrl=readTestStatus();
  if (lastUrl != null && !TEST_DONE.equals(lastUrl))   fastForward(listReader,lastUrl);
  String url=null;
  Handler handler=null;
  boolean timeoutFlag=false;
  long start, elapsed;
  while ((url=listReader.readLine()) != null) {
    start=System.currentTimeMillis();
    Log.v(LOGTAG,""String_Node_Str"" + url);
    updateTestStatus(url);
    activity.reset();
    handler=activity.getHandler();
    handler.sendMessage(handler.obtainMessage(ReliabilityTestActivity.MSG_NAVIGATE,runner.mTimeoutInMillis,0,url));
    timeoutFlag=activity.waitUntilDone();
    elapsed=System.currentTimeMillis() - start;
    if (elapsed < 1000) {
      Log.w(LOGTAG,""String_Node_Str"" + elapsed + ""String_Node_Str"");
    }
 else {
      Log.v(LOGTAG,""String_Node_Str"" + elapsed + ""String_Node_Str"");
    }
    if (timeoutFlag) {
      writeTimeoutFile(url);
    }
    System.runFinalization();
    System.gc();
    System.gc();
  }
  updateTestStatus(TEST_DONE);
  activity.finish();
  listReader.close();
}",0.9888849049838652
183625,"private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}","private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}",0.9786931818181818
183626,"/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,gesture,entryName));
  mChanged=true;
}","/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,entryName));
  mChanged=true;
}",0.9829545454545454
183627,"/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}","/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,mOrientationStyle,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}",0.9731343283582088
183628,"/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  final Matrix matrix=new Matrix();
  matrix.setTranslate(-rect.left,-rect.top);
  matrix.postScale(width / rect.width(),height / rect.height());
  matrix.mapPoints(pts);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}","/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  GestureUtilities.translate(pts,-rect.left,-rect.top);
  float sx=width / rect.width();
  float sy=height / rect.height();
  float scale=sx > sy ? sy : sx;
  GestureUtilities.scale(pts,scale,scale);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}",0.8662816525988449
183629,"static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  Matrix tr=new Matrix();
  tr.setTranslate(-centroid[0],-centroid[1]);
  tr.mapPoints(points);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=-90;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    angle=(float)(180 * angle / Math.PI);
    Matrix trans=new Matrix();
    trans.setRotate(-angle);
    trans.mapPoints(points);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}","static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  translate(points,-centroid[0],-centroid[1]);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=(float)-Math.PI / 2;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    rotate(points,-angle);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}",0.8041440552540701
183630,"/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int samplingType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (samplingType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(samplingType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}","/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int sequenceType,int orientationType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(orientationType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}",0.9402319357716324
183631,"private static float[] temporalSampler(int samplingType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  orientation*=180 / Math.PI;
  float adjustment=-orientation;
  if (samplingType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  Matrix m=new Matrix();
  m.setTranslate(-center[0],-center[1]);
  m.postRotate(adjustment);
  m.mapPoints(pts);
  return pts;
}","private static float[] temporalSampler(int orientationType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  float adjustment=-orientation;
  if (orientationType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  GestureUtilities.translate(pts,-center[0],-center[1]);
  GestureUtilities.rotate(pts,adjustment);
  return pts;
}",0.8548812664907651
183632,"@Override ArrayList<Prediction> classify(int gestureType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (gestureType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}","@Override ArrayList<Prediction> classify(int sequenceType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}",0.9918032786885246
183633,"private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}","private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}",0.9786931818181818
183634,"/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,gesture,entryName));
  mChanged=true;
}","/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,entryName));
  mChanged=true;
}",0.9829545454545454
183635,"/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}","/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,mOrientationStyle,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}",0.9731343283582088
183636,"/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  final Matrix matrix=new Matrix();
  matrix.setTranslate(-rect.left,-rect.top);
  matrix.postScale(width / rect.width(),height / rect.height());
  matrix.mapPoints(pts);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}","/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  GestureUtilities.translate(pts,-rect.left,-rect.top);
  float sx=width / rect.width();
  float sy=height / rect.height();
  float scale=sx > sy ? sy : sx;
  GestureUtilities.scale(pts,scale,scale);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}",0.8662816525988449
183637,"static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  Matrix tr=new Matrix();
  tr.setTranslate(-centroid[0],-centroid[1]);
  tr.mapPoints(points);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=-90;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    angle=(float)(180 * angle / Math.PI);
    Matrix trans=new Matrix();
    trans.setRotate(-angle);
    trans.mapPoints(points);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}","static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  translate(points,-centroid[0],-centroid[1]);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=(float)-Math.PI / 2;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    rotate(points,-angle);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}",0.8041440552540701
183638,"/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int samplingType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (samplingType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(samplingType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}","/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int sequenceType,int orientationType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(orientationType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}",0.9402319357716324
183639,"private static float[] temporalSampler(int samplingType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  orientation*=180 / Math.PI;
  float adjustment=-orientation;
  if (samplingType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  Matrix m=new Matrix();
  m.setTranslate(-center[0],-center[1]);
  m.postRotate(adjustment);
  m.mapPoints(pts);
  return pts;
}","private static float[] temporalSampler(int orientationType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  float adjustment=-orientation;
  if (orientationType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  GestureUtilities.translate(pts,-center[0],-center[1]);
  GestureUtilities.rotate(pts,adjustment);
  return pts;
}",0.8548812664907651
183640,"@Override ArrayList<Prediction> classify(int gestureType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (gestureType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}","@Override ArrayList<Prediction> classify(int sequenceType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}",0.9918032786885246
183641,"private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}","private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}",0.9076704545454546
183642,"/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,entryName));
  mChanged=true;
}","/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,gesture,entryName));
  mChanged=true;
}",0.9829545454545454
183643,"/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,mOrientationStyle,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}","/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}",0.9731343283582088
183644,"/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  GestureUtilities.translate(pts,-rect.left,-rect.top);
  float sx=width / rect.width();
  float sy=height / rect.height();
  float scale=sx > sy ? sy : sx;
  GestureUtilities.scale(pts,scale,scale);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}","/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  final Matrix matrix=new Matrix();
  matrix.setTranslate(-rect.left,-rect.top);
  matrix.postScale(width / rect.width(),height / rect.height());
  matrix.mapPoints(pts);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}",0.8565082185695246
183645,"static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  translate(points,-centroid[0],-centroid[1]);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=(float)-Math.PI / 2;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    rotate(points,-angle);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}","static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  Matrix tr=new Matrix();
  tr.setTranslate(-centroid[0],-centroid[1]);
  tr.mapPoints(points);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=-90;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    angle=(float)(180 * angle / Math.PI);
    Matrix trans=new Matrix();
    trans.setRotate(-angle);
    trans.mapPoints(points);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}",0.8041440552540701
183646,"/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int sequenceType,int orientationType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(orientationType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}","/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int samplingType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (samplingType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(samplingType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}",0.9402319357716324
183647,"private static float[] temporalSampler(int orientationType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  float adjustment=-orientation;
  if (orientationType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  GestureUtilities.translate(pts,-center[0],-center[1]);
  GestureUtilities.rotate(pts,adjustment);
  return pts;
}","private static float[] temporalSampler(int samplingType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  orientation*=180 / Math.PI;
  float adjustment=-orientation;
  if (samplingType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  Matrix m=new Matrix();
  m.setTranslate(-center[0],-center[1]);
  m.postRotate(adjustment);
  m.mapPoints(pts);
  return pts;
}",0.8548812664907651
183648,"@Override ArrayList<Prediction> classify(int sequenceType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}","@Override ArrayList<Prediction> classify(int gestureType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (gestureType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}",0.9918032786885246
183649,"private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}","private void readFormatV1(DataInputStream in) throws IOException {
  final Learner classifier=mClassifier;
  final HashMap<String,ArrayList<Gesture>> namedGestures=mNamedGestures;
  namedGestures.clear();
  final int entriesCount=in.readInt();
  for (int i=0; i < entriesCount; i++) {
    final String name=in.readUTF();
    final int gestureCount=in.readInt();
    final ArrayList<Gesture> gestures=new ArrayList<Gesture>(gestureCount);
    for (int j=0; j < gestureCount; j++) {
      final Gesture gesture=Gesture.deserialize(in);
      gestures.add(gesture);
      classifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,name));
    }
    namedGestures.put(name,gestures);
  }
}",0.9786931818181818
183650,"/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,gesture,entryName));
  mChanged=true;
}","/** 
 * Add a gesture for the entry
 * @param entryName entry name
 * @param gesture
 */
public void addGesture(String entryName,Gesture gesture){
  if (entryName == null || entryName.length() == 0) {
    return;
  }
  ArrayList<Gesture> gestures=mNamedGestures.get(entryName);
  if (gestures == null) {
    gestures=new ArrayList<Gesture>();
    mNamedGestures.put(entryName,gestures);
  }
  gestures.add(gesture);
  mClassifier.addInstance(Instance.createInstance(mSequenceType,mOrientationStyle,gesture,entryName));
  mChanged=true;
}",0.9829545454545454
183651,"/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}","/** 
 * Recognize a gesture
 * @param gesture the query
 * @return a list of predictions of possible entries for a given gesture
 */
public ArrayList<Prediction> recognize(Gesture gesture){
  Instance instance=Instance.createInstance(mSequenceType,mOrientationStyle,gesture,null);
  return mClassifier.classify(mSequenceType,instance.vector);
}",0.9731343283582088
183652,"/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  final Matrix matrix=new Matrix();
  matrix.setTranslate(-rect.left,-rect.top);
  matrix.postScale(width / rect.width(),height / rect.height());
  matrix.mapPoints(pts);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}","/** 
 * Convert the stroke to a Path based on the number of points
 * @param width the width of the bounding box of the target path
 * @param height the height of the bounding box of the target path
 * @param numSample the number of points needed
 * @return the path
 */
public Path toPath(float width,float height,int numSample){
  final float[] pts=GestureUtilities.temporalSampling(this,numSample);
  final RectF rect=boundingBox;
  GestureUtilities.translate(pts,-rect.left,-rect.top);
  float sx=width / rect.width();
  float sy=height / rect.height();
  float scale=sx > sy ? sy : sx;
  GestureUtilities.scale(pts,scale,scale);
  float mX=0;
  float mY=0;
  Path path=null;
  final int count=pts.length;
  for (int i=0; i < count; i+=2) {
    float x=pts[i];
    float y=pts[i + 1];
    if (path == null) {
      path=new Path();
      path.moveTo(x,y);
      mX=x;
      mY=y;
    }
 else {
      float dx=Math.abs(x - mX);
      float dy=Math.abs(y - mY);
      if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
        path.quadTo(mX,mY,(x + mX) / 2,(y + mY) / 2);
        mX=x;
        mY=y;
      }
    }
  }
  return path;
}",0.8662816525988449
183653,"static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  Matrix tr=new Matrix();
  tr.setTranslate(-centroid[0],-centroid[1]);
  tr.mapPoints(points);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=-90;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    angle=(float)(180 * angle / Math.PI);
    Matrix trans=new Matrix();
    trans.setRotate(-angle);
    trans.mapPoints(points);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}","static OrientedBoundingBox computeOrientedBoundingBox(float[] points,float[] centroid){
  translate(points,-centroid[0],-centroid[1]);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=(float)-Math.PI / 2;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    rotate(points,-angle);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}",0.8041440552540701
183654,"/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int samplingType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (samplingType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(samplingType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}","/** 
 * create a learning instance for a single stroke gesture
 * @param gesture
 * @param label
 * @return the instance
 */
static Instance createInstance(int sequenceType,int orientationType,Gesture gesture,String label){
  float[] pts;
  Instance instance;
  if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
    pts=temporalSampler(orientationType,gesture);
    instance=new Instance(gesture.getID(),pts,label);
    instance.normalize();
  }
 else {
    pts=spatialSampler(gesture);
    instance=new Instance(gesture.getID(),pts,label);
  }
  return instance;
}",0.9402319357716324
183655,"private static float[] temporalSampler(int samplingType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  orientation*=180 / Math.PI;
  float adjustment=-orientation;
  if (samplingType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  Matrix m=new Matrix();
  m.setTranslate(-center[0],-center[1]);
  m.postRotate(adjustment);
  m.mapPoints(pts);
  return pts;
}","private static float[] temporalSampler(int orientationType,Gesture gesture){
  float[] pts=GestureUtilities.temporalSampling(gesture.getStrokes().get(0),SEQUENCE_SAMPLE_SIZE);
  float[] center=GestureUtilities.computeCentroid(pts);
  float orientation=(float)Math.atan2(pts[1] - center[1],pts[0] - center[0]);
  float adjustment=-orientation;
  if (orientationType == GestureLibrary.ORIENTATION_SENSITIVE) {
    int count=ORIENTATIONS.length;
    for (int i=0; i < count; i++) {
      float delta=ORIENTATIONS[i] - orientation;
      if (Math.abs(delta) < Math.abs(adjustment)) {
        adjustment=delta;
      }
    }
  }
  GestureUtilities.translate(pts,-center[0],-center[1]);
  GestureUtilities.rotate(pts,adjustment);
  return pts;
}",0.8548812664907651
183656,"@Override ArrayList<Prediction> classify(int gestureType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (gestureType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}","@Override ArrayList<Prediction> classify(int sequenceType,float[] vector){
  ArrayList<Prediction> predictions=new ArrayList<Prediction>();
  ArrayList<Instance> instances=getInstances();
  int count=instances.size();
  TreeMap<String,Double> label2score=new TreeMap<String,Double>();
  for (int i=0; i < count; i++) {
    Instance sample=instances.get(i);
    if (sample.vector.length != vector.length) {
      continue;
    }
    double distance;
    if (sequenceType == GestureLibrary.SEQUENCE_SENSITIVE) {
      distance=GestureUtilities.cosineDistance(sample.vector,vector);
    }
 else {
      distance=GestureUtilities.squaredEuclideanDistance(sample.vector,vector);
    }
    double weight;
    if (distance == 0) {
      weight=Double.MAX_VALUE;
    }
 else {
      weight=1 / distance;
    }
    Double score=label2score.get(sample.label);
    if (score == null || weight > score) {
      label2score.put(sample.label,weight);
    }
  }
  double sum=0;
  for (  String name : label2score.keySet()) {
    double score=label2score.get(name);
    sum+=score;
    predictions.add(new Prediction(name,score));
  }
  for (  Prediction prediction : predictions) {
    prediction.score/=sum;
  }
  Collections.sort(predictions,new Comparator<Prediction>(){
    public int compare(    Prediction object1,    Prediction object2){
      double score1=object1.score;
      double score2=object2.score;
      if (score1 > score2) {
        return -1;
      }
 else       if (score1 < score2) {
        return 1;
      }
 else {
        return 0;
      }
    }
  }
);
  return predictions;
}",0.9918032786885246
183657,"private void getPermissionsForPackage(String packageName,Set<PermissionInfo> permSet){
  PackageInfo pkgInfo;
  try {
    pkgInfo=mPm.getPackageInfo(packageName,PackageManager.GET_PERMISSIONS);
  }
 catch (  NameNotFoundException e) {
    Log.w(TAG,""String_Node_Str"" + packageName);
    return;
  }
  if (pkgInfo == null) {
    return;
  }
  String strList[]=pkgInfo.requestedPermissions;
  if (strList == null) {
    return;
  }
  extractPerms(strList,permSet);
}","private void getPermissionsForPackage(String packageName,Set<PermissionInfo> permSet){
  PackageInfo pkgInfo;
  try {
    pkgInfo=mPm.getPackageInfo(packageName,PackageManager.GET_PERMISSIONS);
  }
 catch (  NameNotFoundException e) {
    Log.w(TAG,""String_Node_Str"" + packageName);
    return;
  }
  if ((pkgInfo != null) && (pkgInfo.requestedPermissions != null)) {
    extractPerms(pkgInfo.requestedPermissions,permSet);
  }
}",0.8107502799552072
183658,"public AppSecurityPermissions(Context context,PackageParser.Package pkg){
  mContext=context;
  mPm=mContext.getPackageManager();
  mPermsList=new ArrayList<PermissionInfo>();
  Set<PermissionInfo> permSet=new HashSet<PermissionInfo>();
  if (pkg == null) {
    return;
  }
  if (pkg.mSharedUserId != null) {
    int sharedUid;
    try {
      sharedUid=mPm.getUidForSharedUser(pkg.mSharedUserId);
    }
 catch (    NameNotFoundException e) {
      Log.w(TAG,""String_Node_Str"" + pkg.packageName);
      return;
    }
    getAllUsedPermissions(sharedUid,permSet);
  }
 else {
    ArrayList<String> strList=pkg.requestedPermissions;
    int size;
    if ((strList == null) || ((size=strList.size()) == 0)) {
      return;
    }
    extractPerms(strList.toArray(new String[size]),permSet);
  }
  for (  PermissionInfo tmpInfo : permSet) {
    mPermsList.add(tmpInfo);
  }
}","public AppSecurityPermissions(Context context,PackageParser.Package pkg){
  mContext=context;
  mPm=mContext.getPackageManager();
  mPermsList=new ArrayList<PermissionInfo>();
  Set<PermissionInfo> permSet=new HashSet<PermissionInfo>();
  if (pkg == null) {
    return;
  }
  if (pkg.requestedPermissions != null) {
    ArrayList<String> strList=pkg.requestedPermissions;
    int size=strList.size();
    if (size > 0) {
      extractPerms(strList.toArray(new String[size]),permSet);
    }
  }
  if (pkg.mSharedUserId != null) {
    int sharedUid;
    try {
      sharedUid=mPm.getUidForSharedUser(pkg.mSharedUserId);
      getAllUsedPermissions(sharedUid,permSet);
    }
 catch (    NameNotFoundException e) {
      Log.w(TAG,""String_Node_Str"" + pkg.packageName);
    }
  }
  for (  PermissionInfo tmpInfo : permSet) {
    mPermsList.add(tmpInfo);
  }
}",0.5870069605568445
183659,"/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  parcel.writeBundle(this);
}","/** 
 * Writes the Bundle contents to a Parcel, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */
public void writeToParcel(Parcel parcel,int flags){
  if (mParcelledData != null) {
    int length=mParcelledData.dataSize();
    parcel.writeInt(length);
    parcel.writeInt(0x4C444E42);
    parcel.appendFrom(mParcelledData,0,length);
  }
 else {
    parcel.writeInt(-1);
    parcel.writeInt(0x4C444E42);
    int oldPos=parcel.dataPosition();
    parcel.writeMapInternal(mMap);
    int newPos=parcel.dataPosition();
    parcel.setDataPosition(oldPos - 8);
    int length=newPos - oldPos;
    parcel.writeInt(length);
    parcel.setDataPosition(newPos);
  }
}",0.4655870445344129
183660,"/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    return;
  }
  mParcelledData.setDataPosition(0);
  Bundle b=mParcelledData.readBundleUnpacked(mClassLoader);
  mMap=b.mMap;
  mHasFds=mParcelledData.hasFileDescriptors();
  mFdsKnown=true;
  mParcelledData.recycle();
  mParcelledData=null;
}","/** 
 * If the underlying data are stored as a Parcel, unparcel them using the currently assigned class loader.
 */
synchronized void unparcel(){
  if (mParcelledData == null) {
    return;
  }
  int N=mParcelledData.readInt();
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new HashMap<String,Object>();
  }
  mParcelledData.readMapInternal(mMap,N,mClassLoader);
  mParcelledData.recycle();
  mParcelledData=null;
}",0.6112412177985949
183661,"/** 
 * Reads the Parcel contents into this Bundle, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */
public void readFromParcel(Parcel parcel){
  mParcelledData=parcel;
  mHasFds=mParcelledData.hasFileDescriptors();
  mFdsKnown=true;
}","/** 
 * Reads the Parcel contents into this Bundle, typically in order for it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */
public void readFromParcel(Parcel parcel){
  int length=parcel.readInt();
  if (length < 0) {
    throw new RuntimeException(""String_Node_Str"" + length);
  }
  readFromParcelInner(parcel,length);
}",0.6847360912981455
183662,"private void readMapInternal(Map outVal,int N,ClassLoader loader){
  while (N > 0) {
    Object key=readValue(loader);
    Object value=readValue(loader);
    outVal.put(key,value);
    N--;
  }
}","void readMapInternal(Map outVal,int N,ClassLoader loader){
  while (N > 0) {
    Object key=readValue(loader);
    Object value=readValue(loader);
    outVal.put(key,value);
    N--;
  }
}",0.9791666666666666
183663,"/** 
 * Flatten a Bundle into the parcel at the current dataPosition(), growing dataCapacity() if needed.
 */
public final void writeBundle(Bundle val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  if (val.mParcelledData != null) {
    int length=val.mParcelledData.dataSize();
    appendFrom(val.mParcelledData,0,length);
  }
 else {
    writeInt(-1);
    int oldPos=dataPosition();
    writeInt(0x4C444E42);
    writeMapInternal(val.mMap);
    int newPos=dataPosition();
    setDataPosition(oldPos - 4);
    int length=newPos - oldPos;
    writeInt(length);
    setDataPosition(newPos);
  }
}","/** 
 * Flatten a Bundle into the parcel at the current dataPosition(), growing dataCapacity() if needed.
 */
public final void writeBundle(Bundle val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  val.writeToParcel(this,0);
}",0.5402843601895735
183664,"/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int offset=dataPosition();
  int length=readInt();
  if (length < 0) {
    return null;
  }
  int magic=readInt();
  if (magic != 0x4C444E42) {
    String st=Log.getStackTraceString(new RuntimeException());
    Log.e(""String_Node_Str"",""String_Node_Str"");
    Log.e(""String_Node_Str"",""String_Node_Str"" + st);
  }
  setDataPosition(offset + length + 4);
  Parcel p=new Parcel(0);
  p.setDataPosition(0);
  p.appendFrom(this,offset,length + 4);
  p.setDataPosition(0);
  final Bundle bundle=new Bundle(p);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}","/** 
 * Read and return a new Bundle object from the parcel at the current dataPosition(), using the given class loader to initialize the class loader of the Bundle for later retrieval of Parcelable objects. Returns null if the previously written Bundle object was null.
 */
public final Bundle readBundle(ClassLoader loader){
  int length=readInt();
  if (length < 0) {
    return null;
  }
  final Bundle bundle=new Bundle(this,length);
  if (loader != null) {
    bundle.setClassLoader(loader);
  }
  return bundle;
}",0.520586182833217
183665,"/** 
 * Flatten a Map into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
private void writeMapInternal(Map<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  Set<Map.Entry<String,Object>> entries=val.entrySet();
  writeInt(entries.size());
  for (  Map.Entry<String,Object> e : entries) {
    writeValue(e.getKey());
    writeValue(e.getValue());
  }
}","/** 
 * Flatten a Map into the parcel at the current dataPosition(), growing dataCapacity() if needed.  The Map keys must be String objects.
 */
void writeMapInternal(Map<String,Object> val){
  if (val == null) {
    writeInt(-1);
    return;
  }
  Set<Map.Entry<String,Object>> entries=val.entrySet();
  writeInt(entries.size());
  for (  Map.Entry<String,Object> e : entries) {
    writeValue(e.getKey());
    writeValue(e.getValue());
  }
}",0.9910514541387024
183666,"private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    p.sharedUser=sharedUser;
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}",0.991995583770356
183667,"void replaceTextfieldText(int oldStart,int oldEnd,String replace,int newStart,int newEnd){
  HashMap arg=new HashMap();
  arg.put(""String_Node_Str"",new WebViewCore.FocusData(mFocusData));
  arg.put(""String_Node_Str"",replace);
  arg.put(""String_Node_Str"",new Integer(newStart));
  arg.put(""String_Node_Str"",new Integer(newEnd));
  mTextGeneration++;
  mWebViewCore.sendMessage(EventHub.REPLACE_TEXT,oldStart,oldEnd,arg);
}","void replaceTextfieldText(int oldStart,int oldEnd,String replace,int newStart,int newEnd){
  HashMap arg=new HashMap();
  arg.put(""String_Node_Str"",new WebViewCore.FocusData(mFocusData));
  arg.put(""String_Node_Str"",replace);
  arg.put(""String_Node_Str"",Integer.valueOf(newStart));
  arg.put(""String_Node_Str"",Integer.valueOf(newEnd));
  mTextGeneration++;
  mWebViewCore.sendMessage(EventHub.REPLACE_TEXT,oldStart,oldEnd,arg);
}",0.971764705882353
183668,"/** 
 * Build an SQL query string from the given clauses.
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param tables The table names to compile the query against.
 * @param columns A list of which columns to return. Passing null willreturn all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
 * @param where A filter declaring which rows to return, formatted as an SQLWHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URL.
 * @param groupBy A filter declaring how to group rows, formatted as an SQLGROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause(excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the SQL query string
 */
public static String buildQueryString(boolean distinct,String tables,String[] columns,String where,String groupBy,String having,String orderBy,String limit){
  if (TextUtils.isEmpty(groupBy) && !TextUtils.isEmpty(having)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  StringBuilder query=new StringBuilder(120);
  query.append(""String_Node_Str"");
  if (distinct) {
    query.append(""String_Node_Str"");
  }
  if (columns != null && columns.length != 0) {
    appendColumns(query,columns);
  }
 else {
    query.append(""String_Node_Str"");
  }
  query.append(""String_Node_Str"");
  query.append(tables);
  appendClause(query,""String_Node_Str"",where);
  appendClause(query,""String_Node_Str"",groupBy);
  appendClause(query,""String_Node_Str"",having);
  appendClause(query,""String_Node_Str"",orderBy);
  appendClauseEscapeClause(query,""String_Node_Str"",limit);
  return query.toString();
}","/** 
 * Build an SQL query string from the given clauses.
 * @param distinct true if you want each row to be unique, false otherwise.
 * @param tables The table names to compile the query against.
 * @param columns A list of which columns to return. Passing null willreturn all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
 * @param where A filter declaring which rows to return, formatted as an SQLWHERE clause (excluding the WHERE itself). Passing null will return all rows for the given URL.
 * @param groupBy A filter declaring how to group rows, formatted as an SQLGROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include in the cursor,if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
 * @param orderBy How to order the rows, formatted as an SQL ORDER BY clause(excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the SQL query string
 */
public static String buildQueryString(boolean distinct,String tables,String[] columns,String where,String groupBy,String having,String orderBy,String limit){
  if (TextUtils.isEmpty(groupBy) && !TextUtils.isEmpty(having)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!TextUtils.isEmpty(limit) && !sLimitPattern.matcher(limit).matches()) {
    throw new IllegalArgumentException(""String_Node_Str"" + limit);
  }
  StringBuilder query=new StringBuilder(120);
  query.append(""String_Node_Str"");
  if (distinct) {
    query.append(""String_Node_Str"");
  }
  if (columns != null && columns.length != 0) {
    appendColumns(query,columns);
  }
 else {
    query.append(""String_Node_Str"");
  }
  query.append(""String_Node_Str"");
  query.append(tables);
  appendClause(query,""String_Node_Str"",where);
  appendClause(query,""String_Node_Str"",groupBy);
  appendClause(query,""String_Node_Str"",having);
  appendClause(query,""String_Node_Str"",orderBy);
  appendClause(query,""String_Node_Str"",limit);
  return query.toString();
}",0.9652342906499676
183669,"/** 
 * Receives a query request from a client in a local process, and returns a Cursor. This is called internally by the   {@link ContentResolver}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals: Processes and Threads</a>. <p> Example client call:<p> <pre>// Request a specific record. Cursor managedCursor = managedQuery( Contacts.People.CONTENT_URI.addId(2), projection,    // Which columns to return. null,          // WHERE clause. People.NAME + "" ASC"");   // Sort order.</pre> Example implementation:<p> <pre>// SQLiteQueryBuilder is a helper class that creates the // proper SQL syntax for us. SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder(); // Set the table we're querying. qBuilder.setTables(DATABASE_TABLE_NAME); // If the query ends in a specific record number, we're // being asked for a specific record, so set the // WHERE clause in our query. if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){ qBuilder.appendWhere(""_id="" + uri.getPathLeafId()); } // Make the query. Cursor c = qBuilder.query(mDb, projection, selection, selectionArgs, groupBy, having, sortOrder); c.setNotificationUri(getContext().getContentResolver(), uri); return c;</pre>
 * @param uri The URI to query. This will be the full URI sent by the client;if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value.
 * @param projection The list of columns to put into the cursor. Ifnull all columns are included.
 * @param selection A selection criteria to apply when filtering rows.If null then all rows are included.
 * @param sortOrder How the rows in the cursor should be sorted.If null then the provider is free to define the sort order.
 * @return a Cursor or null.
 */
public abstract Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder);","/** 
 * Receives a query request from a client in a local process, and returns a Cursor. This is called internally by the   {@link ContentResolver}. This method can be called from multiple threads, as described in <a href=""  {@docRoot}guide/topics/fundamentals.html#procthread"">Application Fundamentals: Processes and Threads</a>. <p> Example client call:<p> <pre>// Request a specific record. Cursor managedCursor = managedQuery( ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2), projection,    // Which columns to return. null,          // WHERE clause. null,          // WHERE clause value substitution People.NAME + "" ASC"");   // Sort order.</pre> Example implementation:<p> <pre>// SQLiteQueryBuilder is a helper class that creates the // proper SQL syntax for us. SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder(); // Set the table we're querying. qBuilder.setTables(DATABASE_TABLE_NAME); // If the query ends in a specific record number, we're // being asked for a specific record, so set the // WHERE clause in our query. if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){ qBuilder.appendWhere(""_id="" + uri.getPathLeafId()); } // Make the query. Cursor c = qBuilder.query(mDb, projection, selection, selectionArgs, groupBy, having, sortOrder); c.setNotificationUri(getContext().getContentResolver(), uri); return c;</pre>
 * @param uri The URI to query. This will be the full URI sent by the client;if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value.
 * @param projection The list of columns to put into the cursor. Ifnull all columns are included.
 * @param selection A selection criteria to apply when filtering rows.If null then all rows are included.
 * @param selectionArgs You may include ?s in selection, which will be replaced bythe values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
 * @param sortOrder How the rows in the cursor should be sorted.If null then the provider is free to define the sort order.
 * @return a Cursor or null.
 */
public abstract Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder);",0.934640522875817
183670,"private void runStart(){
  Intent intent=makeIntent();
  if (intent != null) {
    System.out.println(""String_Node_Str"" + intent);
    try {
      intent.addFlags(intent.FLAG_ACTIVITY_NEW_TASK);
      int res=mAm.startActivity(null,intent,intent.getType(),null,0,null,null,0,false,mDebugOption);
switch (res) {
case IActivityManager.START_SUCCESS:
        break;
case IActivityManager.START_CLASS_NOT_FOUND:
      System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + intent.getComponent().toShortString() + ""String_Node_Str"");
  break;
case IActivityManager.START_DELIVERED_TO_TOP:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_INTENT_NOT_RESOLVED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + intent.toString());
break;
case IActivityManager.START_RETURN_INTENT_TO_CALLER:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_TASK_TO_FRONT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
default :
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + res);
break;
}
}
 catch (RemoteException e) {
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
}
}
}","private void runStart(){
  Intent intent=makeIntent();
  if (intent != null) {
    System.out.println(""String_Node_Str"" + intent);
    try {
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      int res=mAm.startActivity(null,intent,intent.getType(),null,0,null,null,0,false,mDebugOption);
switch (res) {
case IActivityManager.START_SUCCESS:
        break;
case IActivityManager.START_SWITCHES_CANCELED:
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    break;
case IActivityManager.START_DELIVERED_TO_TOP:
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_RETURN_INTENT_TO_CALLER:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_TASK_TO_FRONT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_INTENT_NOT_RESOLVED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + intent.toString());
break;
case IActivityManager.START_CLASS_NOT_FOUND:
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + intent.getComponent().toShortString() + ""String_Node_Str"");
break;
case IActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_PERMISSION_DENIED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
default :
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + res);
break;
}
}
 catch (RemoteException e) {
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
}
}
}",0.5306930693069307
183671,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9940025252525252
183672,"protected void onHandleIntent(Intent intent){
  if (REMOTE_INTENT_ACTION.equals(intent.getAction())) {
    boolean fromTrustedServer=intent.getBooleanExtra(""String_Node_Str"",false);
    if (fromTrustedServer) {
      String accountName=intent.getStringExtra(""String_Node_Str"");
      String token=intent.getStringExtra(""String_Node_Str"");
      if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(token)) {
        if (Config.LOGD) {
          Log.d(TAG,""String_Node_Str"");
        }
        return;
      }
      if (Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ token);
      }
      handleTickle(this,accountName,token);
    }
 else {
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    }
  }
 else   if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    long refreshTime=getSharedPreferences(sSubscribedFeedsPrefs,Context.MODE_WORLD_READABLE).getLong(sRefreshTime,0);
    scheduleRefresh(this,refreshTime);
  }
 else   if (SUBSCRIBED_FEEDS_REFRESH_ACTION.equals(intent.getAction())) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    handleRefreshAlarm(this);
  }
}","protected void onHandleIntent(Intent intent){
  if (REMOTE_INTENT_ACTION.equals(intent.getAction())) {
    boolean fromTrustedServer=intent.getBooleanExtra(""String_Node_Str"",false);
    if (fromTrustedServer) {
      String accountName=intent.getStringExtra(""String_Node_Str"");
      String token=intent.getStringExtra(Intent.EXTRA_REMOTE_INTENT_TOKEN);
      if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(token)) {
        if (Config.LOGD) {
          Log.d(TAG,""String_Node_Str"");
        }
        return;
      }
      if (Config.LOGD) {
        Log.d(TAG,""String_Node_Str"" + accountName + ""String_Node_Str""+ token);
      }
      handleTickle(this,accountName,token);
    }
 else {
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    }
  }
 else   if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    long refreshTime=getSharedPreferences(sSubscribedFeedsPrefs,Context.MODE_WORLD_READABLE).getLong(sRefreshTime,0);
    scheduleRefresh(this,refreshTime);
  }
 else   if (SUBSCRIBED_FEEDS_REFRESH_ACTION.equals(intent.getAction())) {
    if (Config.LOGD) {
      Log.d(TAG,""String_Node_Str"");
    }
    handleRefreshAlarm(this);
  }
}",0.9805786761791518
183673,"/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}","/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}",0.8603351955307262
183674,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}",0.821673525377229
183675,"public void onKeyguardExitResult(boolean success){
  if (success) {
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}",0.7146401985111662
183676,"/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}","/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}",0.8603351955307262
183677,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}",0.821673525377229
183678,"public void onKeyguardExitResult(boolean success){
  if (success) {
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}",0.7146401985111662
183679,"private void runStart(){
  Intent intent=makeIntent();
  if (intent != null) {
    System.out.println(""String_Node_Str"" + intent);
    try {
      intent.addFlags(intent.FLAG_ACTIVITY_NEW_TASK);
      int res=mAm.startActivity(null,intent,intent.getType(),null,0,null,null,0,false,mDebugOption);
switch (res) {
case IActivityManager.START_SUCCESS:
        break;
case IActivityManager.START_CLASS_NOT_FOUND:
      System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"" + intent.getComponent().toShortString() + ""String_Node_Str"");
  break;
case IActivityManager.START_DELIVERED_TO_TOP:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_INTENT_NOT_RESOLVED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + intent.toString());
break;
case IActivityManager.START_RETURN_INTENT_TO_CALLER:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_TASK_TO_FRONT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
default :
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + res);
break;
}
}
 catch (RemoteException e) {
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
}
}
}","private void runStart(){
  Intent intent=makeIntent();
  if (intent != null) {
    System.out.println(""String_Node_Str"" + intent);
    try {
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      int res=mAm.startActivity(null,intent,intent.getType(),null,0,null,null,0,false,mDebugOption);
switch (res) {
case IActivityManager.START_SUCCESS:
        break;
case IActivityManager.START_SWITCHES_CANCELED:
      System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    break;
case IActivityManager.START_DELIVERED_TO_TOP:
  System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_RETURN_INTENT_TO_CALLER:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_TASK_TO_FRONT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_INTENT_NOT_RESOLVED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + intent.toString());
break;
case IActivityManager.START_CLASS_NOT_FOUND:
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + intent.getComponent().toShortString() + ""String_Node_Str"");
break;
case IActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
case IActivityManager.START_PERMISSION_DENIED:
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
break;
default :
System.err.println(""String_Node_Str"" + ""String_Node_Str"" + res);
break;
}
}
 catch (RemoteException e) {
System.err.println(""String_Node_Str"");
System.err.println(""String_Node_Str"" + ""String_Node_Str"");
}
}
}",0.5306930693069307
183680,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
setActivityWatcher(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
boolean res=profileControl(process,start,path);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9940025252525252
183681,"/** 
 * <p> Call mDb.endTransaction(). If successful is true, try to call mDb.setTransactionSuccessful() before calling mDb.endTransaction(). This method MUST be used with   {@link #beginBatch()}. </p>
 * @hide This method must be used with {@link #beginTransaction}
 */
public final void endBatch(boolean successful){
  try {
    if (successful) {
      mDb.setTransactionSuccessful();
    }
  }
  finally {
    mApplyingBatch.set(false);
    getDatabase().endTransaction();
    for (    Uri url : mPendingBatchNotifications.get()) {
      getContext().getContentResolver().notifyChange(url,null,changeRequiresLocalSync(url));
    }
    mDb.endTransaction();
  }
}","/** 
 * <p> Finish batch transaction. If ""successful"" is true, try to call mDb.setTransactionSuccessful() before calling mDb.endTransaction(). This method MUST be used with   {@link #beginBatch()}. </p>
 * @hide This method must be used with {@link #beginTransaction}
 */
public final void endBatch(boolean successful){
  try {
    if (successful) {
      mDb.setTransactionSuccessful();
    }
  }
  finally {
    mApplyingBatch.set(false);
    getDatabase().endTransaction();
    for (    Uri url : mPendingBatchNotifications.get()) {
      getContext().getContentResolver().notifyChange(url,null,changeRequiresLocalSync(url));
    }
  }
}",0.9256704980842912
183682,"/** 
 * <p> Call mOpenHelper.getWritableDatabase() and mDb.beginTransaction().  {@link #endTransaction} MUST be called after calling this method.Those methods should be used like this: </p> <pre class=""prettyprint""> boolean successful = false; if (!beginTransaction()) { return; } try { // Do something related to mDb successful = true; return ret; } finally { endTransaction(successful); } </pre>
 * @hide This method should be used only when {@link #applyBatch} is not enough and must beused with  {@link #endTransaction}. e.g. If returned value has to be used during one transaction, this method might be useful.
 */
public final void beginBatch(){
  if (mApplyingBatch.get() == null) {
    mApplyingBatch.set(false);
    mPendingBatchNotifications.set(new HashSet<Uri>());
  }
  if (applyingBatch()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  SQLiteDatabase db=getDatabase();
  db.beginTransaction();
  boolean successful=false;
  try {
    mApplyingBatch.set(true);
    successful=true;
  }
  finally {
    if (!successful) {
      db.endTransaction();
    }
  }
}","/** 
 * <p> Start batch transaction.   {@link #endTransaction} MUST be called after calling this method. Those methods should be used like this: </p> <pre class=""prettyprint""> boolean successful = false; beginBatch() try { // Do something related to mDb successful = true; return ret; } finally { endBatch(successful); } </pre>
 * @hide This method should be used only when {@link #applyBatch} is not enough and must beused with  {@link #endBatch}. e.g. If returned value has to be used during one transaction, this method might be useful.
 */
public final void beginBatch(){
  if (mApplyingBatch.get() == null) {
    mApplyingBatch.set(false);
    mPendingBatchNotifications.set(new HashSet<Uri>());
  }
  if (applyingBatch()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  SQLiteDatabase db=getDatabase();
  db.beginTransaction();
  boolean successful=false;
  try {
    mApplyingBatch.set(true);
    successful=true;
  }
  finally {
    if (!successful) {
      db.endTransaction();
    }
  }
}",0.9182509505703422
183683,"private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,vc,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,vc,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    p.sharedUser=sharedUser;
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}",0.9920395278616524
183684,"static void addFileType(String extension,int fileType,String mimeType){
  sFileTypeMap.put(extension,new MediaFileType(fileType,mimeType));
  sMimeTypeMap.put(mimeType,new Integer(fileType));
}","static void addFileType(String extension,int fileType,String mimeType){
  sFileTypeMap.put(extension,new MediaFileType(fileType,mimeType));
  sMimeTypeMap.put(mimeType,Integer.valueOf(fileType));
}",0.9692307692307692
183685,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  if (mRequestedWidth <= 0) {
    myWidth*=mAppScale;
    myHeight*=mAppScale;
  }
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=(int)(getWidth() * mAppScale);
      mLayout.height=(int)(getHeight() * mAppScale);
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurface);
      mContentInsets.scale(mAppScaleInverted);
      mVisibleInsets.scale(mAppScaleInverted);
      mWinFrame.scale(mAppScaleInverted);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      mSurfaceFrame.right=mWinFrame.width();
      mSurfaceFrame.bottom=mWinFrame.height();
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  if (mRequestedWidth <= 0) {
    myWidth*=mAppScale;
    myHeight*=mAppScale;
  }
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=(int)(mLeft * mAppScale);
      mLayout.y=(int)(mTop * mAppScale);
      mLayout.width=(int)(getWidth() * mAppScale);
      mLayout.height=(int)(getHeight() * mAppScale);
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurface);
      mContentInsets.scale(mAppScaleInverted);
      mVisibleInsets.scale(mAppScaleInverted);
      mWinFrame.scale(mAppScaleInverted);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      mSurfaceFrame.right=mWinFrame.width();
      mSurfaceFrame.bottom=mWinFrame.height();
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}",0.9894153225806452
183686,"void setLayoutParams(WindowManager.LayoutParams attrs,boolean newView){
synchronized (this) {
    int oldSoftInputMode=mWindowAttributes.softInputMode;
    mWindowAttributes.copyFrom(attrs);
    mWindowAttributes.scale(mAppScale);
    if (newView) {
      mSoftInputMode=attrs.softInputMode;
      requestLayout();
    }
    if ((attrs.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      mWindowAttributes.softInputMode=(mWindowAttributes.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | (oldSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST);
    }
    mWindowAttributesChanged=true;
    scheduleTraversals();
  }
}","void setLayoutParams(WindowManager.LayoutParams attrs,boolean newView){
synchronized (this) {
    int oldSoftInputMode=mWindowAttributes.softInputMode;
    mWindowAttributes.copyFrom(attrs);
    if (newView) {
      mSoftInputMode=attrs.softInputMode;
      requestLayout();
    }
    if ((attrs.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      mWindowAttributes.softInputMode=(mWindowAttributes.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | (oldSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST);
    }
    mWindowAttributesChanged=true;
    scheduleTraversals();
  }
}",0.9721059972105998
183687,"private int relayoutWindow(WindowManager.LayoutParams params,int viewVisibility,boolean insetsPending) throws RemoteException {
  int relayoutResult=sWindowSession.relayout(mWindow,params,(int)(mView.mMeasuredWidth * mAppScale),(int)(mView.mMeasuredHeight * mAppScale),viewVisibility,insetsPending,mWinFrame,mPendingContentInsets,mPendingVisibleInsets,mSurface);
  mPendingContentInsets.scale(mAppScaleInverted);
  mPendingVisibleInsets.scale(mAppScaleInverted);
  mWinFrame.scale(mAppScaleInverted);
  return relayoutResult;
}","private int relayoutWindow(WindowManager.LayoutParams params,int viewVisibility,boolean insetsPending) throws RemoteException {
  boolean restore=false;
  if (params != null && mAppScale != 1.0f) {
    restore=true;
    params.scale(mAppScale,mWindowLayoutParamsBackup);
  }
  int relayoutResult=sWindowSession.relayout(mWindow,params,(int)(mView.mMeasuredWidth * mAppScale),(int)(mView.mMeasuredHeight * mAppScale),viewVisibility,insetsPending,mWinFrame,mPendingContentInsets,mPendingVisibleInsets,mSurface);
  if (restore) {
    params.restore(mWindowLayoutParamsBackup);
  }
  mPendingContentInsets.scale(mAppScaleInverted);
  mPendingVisibleInsets.scale(mAppScaleInverted);
  mWinFrame.scale(mAppScaleInverted);
  return relayoutResult;
}",0.830575256107171
183688,"/** 
 * We have one child
 */
public void setView(View view,WindowManager.LayoutParams attrs,View panelParentView){
synchronized (this) {
    if (mView == null) {
      mView=view;
      mAppScale=mView.getContext().getApplicationScale();
      mAppScaleInverted=1.0f / mAppScale;
      mWindowAttributes.copyFrom(attrs);
      mSoftInputMode=attrs.softInputMode;
      mWindowAttributesChanged=true;
      mAttachInfo.mRootView=view;
      if (panelParentView != null) {
        mAttachInfo.mPanelParentWindowToken=panelParentView.getApplicationWindowToken();
      }
      mAdded=true;
      int res;
      requestLayout();
      try {
        res=sWindowSession.add(mWindow,attrs,getHostVisibility(),mAttachInfo.mContentInsets);
      }
 catch (      RemoteException e) {
        mAdded=false;
        mView=null;
        mAttachInfo.mRootView=null;
        unscheduleTraversals();
        throw new RuntimeException(""String_Node_Str"",e);
      }
      mAttachInfo.mContentInsets.scale(mAppScaleInverted);
      mPendingContentInsets.set(mAttachInfo.mContentInsets);
      mPendingVisibleInsets.set(0,0,0,0);
      if (Config.LOGV)       Log.v(""String_Node_Str"",""String_Node_Str"" + mWindow);
      if (res < WindowManagerImpl.ADD_OKAY) {
        mView=null;
        mAttachInfo.mRootView=null;
        mAdded=false;
        unscheduleTraversals();
switch (res) {
case WindowManagerImpl.ADD_BAD_APP_TOKEN:
case WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN:
          throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_NOT_APP_TOKEN:
        throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_APP_EXITING:
      throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_DUPLICATE_ADD:
    throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
case WindowManagerImpl.ADD_STARTING_NOT_NEEDED:
  return;
case WindowManagerImpl.ADD_MULTIPLE_SINGLETON:
throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
case WindowManagerImpl.ADD_PERMISSION_DENIED:
throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
}
throw new RuntimeException(""String_Node_Str"" + res);
}
view.assignParent(this);
mAddedTouchMode=(res & WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE) != 0;
mAppVisible=(res & WindowManagerImpl.ADD_FLAG_APP_VISIBLE) != 0;
}
}
}","/** 
 * We have one child
 */
public void setView(View view,WindowManager.LayoutParams attrs,View panelParentView){
synchronized (this) {
    if (mView == null) {
      mView=view;
      mAppScale=mView.getContext().getApplicationScale();
      if (mAppScale != 1.0f) {
        mWindowLayoutParamsBackup=new int[4];
      }
      mAppScaleInverted=1.0f / mAppScale;
      mWindowAttributes.copyFrom(attrs);
      mSoftInputMode=attrs.softInputMode;
      mWindowAttributesChanged=true;
      mAttachInfo.mRootView=view;
      if (panelParentView != null) {
        mAttachInfo.mPanelParentWindowToken=panelParentView.getApplicationWindowToken();
      }
      mAdded=true;
      int res;
      requestLayout();
      try {
        res=sWindowSession.add(mWindow,attrs,getHostVisibility(),mAttachInfo.mContentInsets);
      }
 catch (      RemoteException e) {
        mAdded=false;
        mView=null;
        mAttachInfo.mRootView=null;
        unscheduleTraversals();
        throw new RuntimeException(""String_Node_Str"",e);
      }
      mAttachInfo.mContentInsets.scale(mAppScaleInverted);
      mPendingContentInsets.set(mAttachInfo.mContentInsets);
      mPendingVisibleInsets.set(0,0,0,0);
      if (Config.LOGV)       Log.v(""String_Node_Str"",""String_Node_Str"" + mWindow);
      if (res < WindowManagerImpl.ADD_OKAY) {
        mView=null;
        mAttachInfo.mRootView=null;
        mAdded=false;
        unscheduleTraversals();
switch (res) {
case WindowManagerImpl.ADD_BAD_APP_TOKEN:
case WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN:
          throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_NOT_APP_TOKEN:
        throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_APP_EXITING:
      throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + attrs.token + ""String_Node_Str"");
case WindowManagerImpl.ADD_DUPLICATE_ADD:
    throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
case WindowManagerImpl.ADD_STARTING_NOT_NEEDED:
  return;
case WindowManagerImpl.ADD_MULTIPLE_SINGLETON:
throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
case WindowManagerImpl.ADD_PERMISSION_DENIED:
throw new WindowManagerImpl.BadTokenException(""String_Node_Str"" + mWindow + ""String_Node_Str"");
}
throw new RuntimeException(""String_Node_Str"" + res);
}
view.assignParent(this);
mAddedTouchMode=(res & WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE) != 0;
mAppVisible=(res & WindowManagerImpl.ADD_FLAG_APP_VISIBLE) != 0;
}
}
}",0.983732057416268
183689,"void scale(float scale){
  if (scale != 1.0f) {
    x*=scale;
    y*=scale;
    if (width > 0) {
      width*=scale;
    }
    if (height > 0) {
      height*=scale;
    }
  }
}","/** 
 * Scale the layout params' coordinates and size. Returns the original info as a backup so that the caller can restore the layout params;
 */
void scale(float scale,int[] backup){
  if (scale != 1.0f) {
    backup[0]=x;
    backup[1]=y;
    x*=scale;
    y*=scale;
    if (width > 0) {
      backup[2]=width;
      width*=scale;
    }
    if (height > 0) {
      backup[3]=height;
      height*=scale;
    }
  }
}",0.5949579831932773
183690,"private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    p.sharedUser=sharedUser;
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}",0.991995583770356
183691,"private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,vc,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      PackageSetting ps=mDisabledSysPackages.get(name);
      if ((ps != null) && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        return p;
      }
 else       if ((p.pkg != null) && (p.pkg.applicationInfo != null) && ((p.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0)) {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
        p=null;
      }
    }
 else     if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    p=new PackageSetting(name,codePath,resourcePath,vc,pkgFlags);
    p.setTimeStamp(codePath.lastModified());
    p.sharedUser=sharedUser;
    if (sharedUser != null) {
      p.userId=sharedUser.userId;
    }
 else     if (MULTIPLE_APPLICATION_UIDS) {
      p.userId=newUserIdLP(p);
    }
 else {
      p.userId=FIRST_APPLICATION_UID;
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      insertPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}",0.9920395278616524
183692,"public void setSyncProviderAutomatically(String account,String providerName,boolean sync){
synchronized (mAuthorities) {
    if (account != null) {
      AuthorityInfo authority=getAuthorityLocked(account,providerName,""String_Node_Str"");
      if (authority != null) {
        authority.enabled=sync;
      }
    }
 else {
      int i=mAuthorities.size();
      while (i > 0) {
        i--;
        AuthorityInfo authority=mAuthorities.get(i);
        if (authority.account.equals(account) && authority.authority.equals(providerName)) {
          authority.enabled=sync;
        }
      }
    }
    writeAccountInfoLocked();
  }
  reportChange(CHANGE_SETTINGS);
}","public void setSyncProviderAutomatically(String account,String providerName,boolean sync){
synchronized (mAuthorities) {
    if (account != null) {
      AuthorityInfo authority=getAuthorityLocked(account,providerName,""String_Node_Str"");
      if (authority != null) {
        authority.enabled=sync;
      }
    }
 else {
      int i=mAuthorities.size();
      while (i > 0) {
        i--;
        AuthorityInfo authority=mAuthorities.get(i);
        if (authority.authority.equals(providerName)) {
          authority.enabled=sync;
        }
      }
    }
    writeAccountInfoLocked();
  }
  reportChange(CHANGE_SETTINGS);
}",0.9712955779674166
183693,"private final List generateApplicationProvidersLocked(ProcessRecord app){
  List providers=null;
  try {
    providers=ActivityThread.getPackageManager().queryContentProviders(app.processName,app.info.uid,PackageManager.GET_SHARED_LIBRARY_FILES | PackageManager.GET_URI_PERMISSION_PATTERNS);
  }
 catch (  RemoteException ex) {
  }
  if (providers != null) {
    final int N=providers.size();
    for (int i=0; i < N; i++) {
      ProviderInfo cpi=(ProviderInfo)providers.get(i);
      ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      if (cpr == null) {
        cpr=new ContentProviderRecord(cpi,app.info);
        mProvidersByClass.put(cpi.name,cpr);
      }
      app.pubProviders.put(cpi.name,cpr);
      app.addPackage(cpi.applicationInfo.packageName);
    }
  }
  return providers;
}","private final List generateApplicationProvidersLocked(ProcessRecord app){
  List providers=null;
  try {
    providers=ActivityThread.getPackageManager().queryContentProviders(app.processName,app.info.uid,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
  }
 catch (  RemoteException ex) {
  }
  if (providers != null) {
    final int N=providers.size();
    for (int i=0; i < N; i++) {
      ProviderInfo cpi=(ProviderInfo)providers.get(i);
      ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      if (cpr == null) {
        cpr=new ContentProviderRecord(cpi,app.info);
        mProvidersByClass.put(cpi.name,cpr);
      }
      app.pubProviders.put(cpi.name,cpr);
      app.addPackage(cpi.applicationInfo.packageName);
    }
  }
  return providers;
}",0.9736034376918354
183694,"private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    thread.bindApplication(processName,app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}","private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}",0.9929955638571096
183695,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher){
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,0);
      ai=mContext.getPackageManager().getApplicationInfo(ii.targetPackage,PackageManager.GET_SHARED_LIBRARY_FILES);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    uninstallPackageLocked(ii.targetPackage,-1,true);
    ProcessRecord app=addAppLocked(ai);
    app.instrumentationClass=className;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher){
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=mContext.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    uninstallPackageLocked(ii.targetPackage,-1,true);
    ProcessRecord app=addAppLocked(ai);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9676002196595276
183696,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,PackageManager.GET_SHARED_LIBRARY_FILES);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9903279075253596
183697,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  app.instrumentationWatcher=null;
  app.instrumentationClass=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  uninstallPackageLocked(app.processName,-1,false);
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  app.instrumentationWatcher=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  uninstallPackageLocked(app.processName,-1,false);
}",0.9681274900398408
183698,"final int startActivityInPackage(int uid,Intent intent,String resolvedType,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded){
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
  }
synchronized (this) {
    return startActivityLocked(null,intent,resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,uid,onlyIfNeeded,componentSpecified);
  }
}","final int startActivityInPackage(int uid,Intent intent,String resolvedType,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded){
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
  }
synchronized (this) {
    return startActivityLocked(null,intent,resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,uid,onlyIfNeeded,componentSpecified);
  }
}",0.9750759878419452
183699,"public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",PackageManager.GET_SHARED_LIBRARY_FILES);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",STOCK_PM_FLAGS);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.9825602968460112
183700,"public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}",0.7618680046314165
183701,"public void systemReady(){
  if (!Process.supportsProcesses()) {
    mStartRunning=true;
    mTopAction=Intent.ACTION_MAIN;
  }
synchronized (this) {
    if (mSystemReady) {
      return;
    }
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  if (Config.LOGD)   Log.d(TAG,""String_Node_Str"");
  EventLog.writeEvent(LOG_BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),0);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=ActivityThread.getPackageManager().getPersistentApplications(PackageManager.GET_SHARED_LIBRARY_FILES);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    try {
      if (ActivityThread.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    mBooting=true;
    resumeTopActivityLocked(null);
  }
}","public void systemReady(){
  if (!Process.supportsProcesses()) {
    mStartRunning=true;
    mTopAction=Intent.ACTION_MAIN;
  }
synchronized (this) {
    if (mSystemReady) {
      return;
    }
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  if (Config.LOGD)   Log.d(TAG,""String_Node_Str"");
  EventLog.writeEvent(LOG_BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=ActivityThread.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    try {
      if (ActivityThread.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    mBooting=true;
    resumeTopActivityLocked(null);
  }
}",0.9876084262701365
183702,"public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity,false);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}","public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity,false);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}",0.9907636855147556
183703,"/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
private final boolean resumeTopActivityLocked(HistoryRecord prev){
  HistoryRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL && mTopAction == null) {
      return false;
    }
    Intent intent=new Intent(mTopAction,mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      intent.addCategory(Intent.CATEGORY_HOME);
    }
    ActivityInfo aInfo=intent.resolveActivityInfo(mContext.getPackageManager(),PackageManager.GET_SHARED_LIBRARY_FILES);
    if (aInfo != null) {
      intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
      ProcessRecord app=getProcessRecordLocked(aInfo.processName,aInfo.applicationInfo.uid);
      if (app == null || app.instrumentationClass == null) {
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivityLocked(null,intent,null,null,0,aInfo,null,null,0,0,0,false,false);
      }
    }
    return true;
  }
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  if ((mSleeping || mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Log.v(TAG,""String_Node_Str"");
    mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next,true);
    HistoryRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    updateLRUListLocked(next.app,true);
    updateLRUListLocked(next);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
    if (config != null) {
      next.frozenBeforeDestroy=true;
    }
    if (!updateConfigurationLocked(config,next)) {
      HistoryRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Log.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      mWindowManager.executeAppTransition();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Log.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(LOG_AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      updateUsageStats(next,true);
      next.app.thread.scheduleResumeActivity(next,isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_ICON) {
          mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_ICON) {
        mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}","/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
private final boolean resumeTopActivityLocked(HistoryRecord prev){
  HistoryRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL && mTopAction == null) {
      return false;
    }
    Intent intent=new Intent(mTopAction,mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      intent.addCategory(Intent.CATEGORY_HOME);
    }
    ActivityInfo aInfo=intent.resolveActivityInfo(mContext.getPackageManager(),STOCK_PM_FLAGS);
    if (aInfo != null) {
      intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
      ProcessRecord app=getProcessRecordLocked(aInfo.processName,aInfo.applicationInfo.uid);
      if (app == null || app.instrumentationClass == null) {
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivityLocked(null,intent,null,null,0,aInfo,null,null,0,0,0,false,false);
      }
    }
    return true;
  }
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  if ((mSleeping || mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Log.v(TAG,""String_Node_Str"");
    mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next,true);
    HistoryRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    updateLRUListLocked(next.app,true);
    updateLRUListLocked(next);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
    if (config != null) {
      next.frozenBeforeDestroy=true;
    }
    if (!updateConfigurationLocked(config,next)) {
      HistoryRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Log.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      mWindowManager.executeAppTransition();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Log.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(LOG_AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      updateUsageStats(next,true);
      next.app.thread.scheduleResumeActivity(next,isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_ICON) {
          mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_ICON) {
        mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}",0.9966792118662828
183704,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST)   Log.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        Uri data=intent.getData();
        String ssp;
        if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
          if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
            uninstallPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false);
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  final ContentResolver resolver=mContext.getContentResolver();
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),0);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,PackageManager.GET_SHARED_LIBRARY_FILES);
      }
      registeredReceivers=mReceiverResolver.queryIntent(resolver,intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    mParallelBroadcasts.add(r);
    scheduleBroadcastsLocked();
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    boolean skip=false;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      skip=true;
    }
    String skipPackage=(skip && intent.getData() != null) ? intent.getData().getSchemeSpecificPart() : null;
    if (skipPackage != null && receivers != null) {
      int NT=receivers.size();
      for (int it=0; it < NT; it++) {
        ResolveInfo curt=(ResolveInfo)receivers.get(it);
        if (curt.activityInfo.packageName.equals(skipPackage)) {
          receivers.remove(it);
          it--;
          NT--;
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Log.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    mOrderedBroadcasts.add(r);
    scheduleBroadcastsLocked();
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST)   Log.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        Uri data=intent.getData();
        String ssp;
        if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
          if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
            uninstallPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false);
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  final ContentResolver resolver=mContext.getContentResolver();
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(resolver,intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    mParallelBroadcasts.add(r);
    scheduleBroadcastsLocked();
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    boolean skip=false;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      skip=true;
    }
    String skipPackage=(skip && intent.getData() != null) ? intent.getData().getSchemeSpecificPart() : null;
    if (skipPackage != null && receivers != null) {
      int NT=receivers.size();
      for (int it=0; it < NT; it++) {
        ResolveInfo curt=(ResolveInfo)receivers.get(it);
        if (curt.activityInfo.packageName.equals(skipPackage)) {
          receivers.remove(it);
          it--;
          NT--;
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Log.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    mOrderedBroadcasts.add(r);
    scheduleBroadcastsLocked();
  }
  return BROADCAST_SUCCESS;
}",0.9954037076758082
183705,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,PackageManager.GET_SHARED_LIBRARY_FILES);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name));
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name));
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.992707826932426
183706,"void dump(PrintWriter pw,String prefix){
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(isForeground);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.println(bad);
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(isForeground);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.println(bad);
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}",0.9680456490727531
183707,"private final List generateApplicationProvidersLocked(ProcessRecord app){
  List providers=null;
  try {
    providers=ActivityThread.getPackageManager().queryContentProviders(app.processName,app.info.uid,PackageManager.GET_SHARED_LIBRARY_FILES | PackageManager.GET_URI_PERMISSION_PATTERNS);
  }
 catch (  RemoteException ex) {
  }
  if (providers != null) {
    final int N=providers.size();
    for (int i=0; i < N; i++) {
      ProviderInfo cpi=(ProviderInfo)providers.get(i);
      ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      if (cpr == null) {
        cpr=new ContentProviderRecord(cpi,app.info);
        mProvidersByClass.put(cpi.name,cpr);
      }
      app.pubProviders.put(cpi.name,cpr);
      app.addPackage(cpi.applicationInfo.packageName);
    }
  }
  return providers;
}","private final List generateApplicationProvidersLocked(ProcessRecord app){
  List providers=null;
  try {
    providers=ActivityThread.getPackageManager().queryContentProviders(app.processName,app.info.uid,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
  }
 catch (  RemoteException ex) {
  }
  if (providers != null) {
    final int N=providers.size();
    for (int i=0; i < N; i++) {
      ProviderInfo cpi=(ProviderInfo)providers.get(i);
      ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      if (cpr == null) {
        cpr=new ContentProviderRecord(cpi,app.info);
        mProvidersByClass.put(cpi.name,cpr);
      }
      app.pubProviders.put(cpi.name,cpr);
      app.addPackage(cpi.applicationInfo.packageName);
    }
  }
  return providers;
}",0.9736034376918354
183708,"private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    thread.bindApplication(processName,app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}","private final boolean attachApplicationLocked(IApplicationThread thread,int pid){
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Log.w(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ thread+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + pid + ""String_Node_Str""+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  EventLog.writeEvent(LOG_AM_PROCESS_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  List providers=generateApplicationProvidersLocked(app);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ thread.asBinder()+ ""String_Node_Str""+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    thread.bindApplication(processName,app.instrumentationInfo != null ? app.instrumentationInfo : app.info,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,mConfiguration,getCommonServicesLocked());
    updateLRUListLocked(app,false);
    app.lastRequestedGc=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"",e);
    app.resetPackageList();
    startProcessLocked(app,""String_Node_Str"",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  HistoryRecord hr=topRunningActivityLocked(null);
  if (hr != null) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscard(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}",0.9929955638571096
183709,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher){
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,0);
      ai=mContext.getPackageManager().getApplicationInfo(ii.targetPackage,PackageManager.GET_SHARED_LIBRARY_FILES);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    uninstallPackageLocked(ii.targetPackage,-1,true);
    ProcessRecord app=addAppLocked(ai);
    app.instrumentationClass=className;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher){
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=mContext.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    uninstallPackageLocked(ii.targetPackage,-1,true);
    ProcessRecord app=addAppLocked(ai);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9676002196595276
183710,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,PackageManager.GET_SHARED_LIBRARY_FILES);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9903279075253596
183711,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  app.instrumentationWatcher=null;
  app.instrumentationClass=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  uninstallPackageLocked(app.processName,-1,false);
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  app.instrumentationWatcher=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  uninstallPackageLocked(app.processName,-1,false);
}",0.9681274900398408
183712,"final int startActivityInPackage(int uid,Intent intent,String resolvedType,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded){
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
  }
synchronized (this) {
    return startActivityLocked(null,intent,resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,uid,onlyIfNeeded,componentSpecified);
  }
}","final int startActivityInPackage(int uid,Intent intent,String resolvedType,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded){
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
  }
synchronized (this) {
    return startActivityLocked(null,intent,resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,uid,onlyIfNeeded,componentSpecified);
  }
}",0.9750759878419452
183713,"public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",PackageManager.GET_SHARED_LIBRARY_FILES);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",STOCK_PM_FLAGS);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.9825602968460112
183714,"public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}",0.7618680046314165
183715,"public void systemReady(){
  if (!Process.supportsProcesses()) {
    mStartRunning=true;
    mTopAction=Intent.ACTION_MAIN;
  }
synchronized (this) {
    if (mSystemReady) {
      return;
    }
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  if (Config.LOGD)   Log.d(TAG,""String_Node_Str"");
  EventLog.writeEvent(LOG_BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),0);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=ActivityThread.getPackageManager().getPersistentApplications(PackageManager.GET_SHARED_LIBRARY_FILES);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    try {
      if (ActivityThread.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    mBooting=true;
    resumeTopActivityLocked(null);
  }
}","public void systemReady(){
  if (!Process.supportsProcesses()) {
    mStartRunning=true;
    mTopAction=Intent.ACTION_MAIN;
  }
synchronized (this) {
    if (mSystemReady) {
      return;
    }
    mSystemReady=true;
    if (!mStartRunning) {
      return;
    }
  }
  if (Config.LOGD)   Log.d(TAG,""String_Node_Str"");
  EventLog.writeEvent(LOG_BOOT_PROGRESS_AMS_READY,SystemClock.uptimeMillis());
synchronized (this) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
      ResolveInfo ri=mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST),STOCK_PM_FLAGS);
      CharSequence errorMsg=null;
      if (ri != null) {
        ActivityInfo ai=ri.activityInfo;
        ApplicationInfo app=ai.applicationInfo;
        if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
          mTopAction=Intent.ACTION_FACTORY_TEST;
          mTopData=null;
          mTopComponent=new ComponentName(app.packageName,ai.name);
        }
 else {
          errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
        }
      }
 else {
        errorMsg=mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
      }
      if (errorMsg != null) {
        mTopAction=null;
        mTopData=null;
        mTopComponent=null;
        Message msg=Message.obtain();
        msg.what=SHOW_FACTORY_ERROR_MSG;
        msg.getData().putCharSequence(""String_Node_Str"",errorMsg);
        mHandler.sendMessage(msg);
      }
    }
  }
  retrieveSettings();
synchronized (this) {
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      try {
        List apps=ActivityThread.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
        if (apps != null) {
          int N=apps.size();
          int i;
          for (i=0; i < N; i++) {
            ApplicationInfo info=(ApplicationInfo)apps.get(i);
            if (info != null && !info.packageName.equals(""String_Node_Str"")) {
              addAppLocked(info);
            }
          }
        }
      }
 catch (      RemoteException ex) {
      }
    }
    try {
      if (ActivityThread.getPackageManager().hasSystemUidErrors()) {
        Message msg=Message.obtain();
        msg.what=SHOW_UID_ERROR_MSG;
        mHandler.sendMessage(msg);
      }
    }
 catch (    RemoteException e) {
    }
    mBooting=true;
    resumeTopActivityLocked(null);
  }
}",0.9876084262701365
183716,"public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity,false);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | PackageManager.GET_SHARED_LIBRARY_FILES);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}","public boolean startNextMatchingActivity(IBinder callingActivity,Intent intent){
  if (intent != null && intent.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    int index=indexOfTokenLocked(callingActivity,false);
    if (index < 0) {
      return false;
    }
    HistoryRecord r=(HistoryRecord)mHistory.get(index);
    if (r.app == null || r.app.thread == null) {
      return false;
    }
    intent=new Intent(intent);
    intent.setDataAndType(r.intent.getData(),r.intent.getType());
    intent.setComponent(null);
    ActivityInfo aInfo=null;
    try {
      List<ResolveInfo> resolves=ActivityThread.getPackageManager().queryIntentActivities(intent,r.resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
      final int N=resolves != null ? resolves.size() : 0;
      for (int i=0; i < N; i++) {
        ResolveInfo rInfo=resolves.get(i);
        if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
          i++;
          if (i < N) {
            aInfo=resolves.get(i).activityInfo;
          }
          break;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (aInfo == null) {
      return false;
    }
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK| Intent.FLAG_ACTIVITY_NEW_TASK));
    final boolean wasFinishing=r.finishing;
    r.finishing=true;
    final HistoryRecord resultTo=r.resultTo;
    final String resultWho=r.resultWho;
    final int requestCode=r.requestCode;
    r.resultTo=null;
    if (resultTo != null) {
      resultTo.removeResultsLocked(r,resultWho,requestCode);
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(r.app.thread,intent,r.resolvedType,null,0,aInfo,resultTo,resultWho,requestCode,-1,r.launchedFromUid,false,false);
    Binder.restoreCallingIdentity(origId);
    r.finishing=wasFinishing;
    if (res != START_SUCCESS) {
      return false;
    }
    return true;
  }
}",0.9907636855147556
183717,"/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
private final boolean resumeTopActivityLocked(HistoryRecord prev){
  HistoryRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL && mTopAction == null) {
      return false;
    }
    Intent intent=new Intent(mTopAction,mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      intent.addCategory(Intent.CATEGORY_HOME);
    }
    ActivityInfo aInfo=intent.resolveActivityInfo(mContext.getPackageManager(),PackageManager.GET_SHARED_LIBRARY_FILES);
    if (aInfo != null) {
      intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
      ProcessRecord app=getProcessRecordLocked(aInfo.processName,aInfo.applicationInfo.uid);
      if (app == null || app.instrumentationClass == null) {
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivityLocked(null,intent,null,null,0,aInfo,null,null,0,0,0,false,false);
      }
    }
    return true;
  }
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  if ((mSleeping || mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Log.v(TAG,""String_Node_Str"");
    mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next,true);
    HistoryRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    updateLRUListLocked(next.app,true);
    updateLRUListLocked(next);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
    if (config != null) {
      next.frozenBeforeDestroy=true;
    }
    if (!updateConfigurationLocked(config,next)) {
      HistoryRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Log.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      mWindowManager.executeAppTransition();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Log.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(LOG_AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      updateUsageStats(next,true);
      next.app.thread.scheduleResumeActivity(next,isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_ICON) {
          mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_ICON) {
        mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}","/** 
 * Ensure that the top activity in the stack is resumed.
 * @param prev The previously resumed activity, for when in the processof pausing; can be null to call from elsewhere.
 * @return Returns true if something is being resumed, or false ifnothing happened.
 */
private final boolean resumeTopActivityLocked(HistoryRecord prev){
  HistoryRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mFactoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL && mTopAction == null) {
      return false;
    }
    Intent intent=new Intent(mTopAction,mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    if (mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL) {
      intent.addCategory(Intent.CATEGORY_HOME);
    }
    ActivityInfo aInfo=intent.resolveActivityInfo(mContext.getPackageManager(),STOCK_PM_FLAGS);
    if (aInfo != null) {
      intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
      ProcessRecord app=getProcessRecordLocked(aInfo.processName,aInfo.applicationInfo.uid);
      if (app == null || app.instrumentationClass == null) {
        intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivityLocked(null,intent,null,null,0,aInfo,null,null,0,0,0,false,false);
      }
    }
    return true;
  }
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  if ((mSleeping || mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mWindowManager.executeAppTransition();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + mPausingActivity);
    return false;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + prev);
    }
 else {
      if (prev.finishing) {
        mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Log.v(TAG,""String_Node_Str"" + prev + ""String_Node_Str""+ (prev != null ? prev.waitingVisible : null)+ ""String_Node_Str""+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Log.v(TAG,""String_Node_Str"" + prev);
      mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
    }
    if (false) {
      mWindowManager.setAppWillBeHidden(prev);
      mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Log.v(TAG,""String_Node_Str"");
    mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Log.v(TAG,""String_Node_Str"" + next);
    mWindowManager.setAppVisibility(next,true);
    HistoryRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    updateLRUListLocked(next.app,true);
    updateLRUListLocked(next);
    Configuration config=mWindowManager.updateOrientationFromAppTokens(mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
    if (config != null) {
      next.frozenBeforeDestroy=true;
    }
    if (!updateConfigurationLocked(config,next)) {
      HistoryRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Log.i(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      mWindowManager.executeAppTransition();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Log.v(TAG,""String_Node_Str"" + next + ""String_Node_Str""+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(LOG_AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      updateUsageStats(next,true);
      next.app.thread.scheduleResumeActivity(next,isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      if (Config.LOGD)       Log.d(TAG,""String_Node_Str"" + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_ICON) {
          mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"" + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,""String_Node_Str"");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_ICON) {
        mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Log.v(TAG,""String_Node_Str"" + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}",0.9966792118662828
183718,"private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST)   Log.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        Uri data=intent.getData();
        String ssp;
        if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
          if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
            uninstallPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false);
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  final ContentResolver resolver=mContext.getContentResolver();
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),0);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,PackageManager.GET_SHARED_LIBRARY_FILES);
      }
      registeredReceivers=mReceiverResolver.queryIntent(resolver,intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    mParallelBroadcasts.add(r);
    scheduleBroadcastsLocked();
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    boolean skip=false;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      skip=true;
    }
    String skipPackage=(skip && intent.getData() != null) ? intent.getData().getSchemeSpecificPart() : null;
    if (skipPackage != null && receivers != null) {
      int NT=receivers.size();
      for (int it=0; it < NT; it++) {
        ResolveInfo curt=(ResolveInfo)receivers.get(it);
        if (curt.activityInfo.packageName.equals(skipPackage)) {
          receivers.remove(it);
          it--;
          NT--;
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Log.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    mOrderedBroadcasts.add(r);
    scheduleBroadcastsLocked();
  }
  return BROADCAST_SUCCESS;
}","private final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle map,String requiredPermission,boolean ordered,boolean sticky,int callingPid,int callingUid){
  intent=new Intent(intent);
  if (DEBUG_BROADCAST)   Log.v(TAG,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered);
  if ((resultTo != null) && !ordered) {
    Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  final boolean uidRemoved=intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
        }
      }
 else {
        Uri data=intent.getData();
        String ssp;
        if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
          if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
            uninstallPackageLocked(ssp,intent.getIntExtra(Intent.EXTRA_UID,-1),false);
          }
        }
      }
    }
 else {
      String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ requiredPermission);
      return BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException(""String_Node_Str"");
    }
    ArrayList<Intent> list=mStickyBroadcasts.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      mStickyBroadcasts.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  final ContentResolver resolver=mContext.getContentResolver();
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  try {
    if (intent.getComponent() != null) {
      ActivityInfo ai=ActivityThread.getPackageManager().getReceiverInfo(intent.getComponent(),STOCK_PM_FLAGS);
      if (ai != null) {
        receivers=new ArrayList();
        ResolveInfo ri=new ResolveInfo();
        ri.activityInfo=ai;
        receivers.add(ri);
      }
    }
 else {
      if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers=ActivityThread.getPackageManager().queryIntentReceivers(intent,resolvedType,STOCK_PM_FLAGS);
      }
      registeredReceivers=mReceiverResolver.queryIntent(resolver,intent,resolvedType,false);
    }
  }
 catch (  RemoteException ex) {
  }
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,registeredReceivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mParallelBroadcasts.size());
    mParallelBroadcasts.add(r);
    scheduleBroadcastsLocked();
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    boolean skip=false;
    if (intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())) {
      skip=true;
    }
 else     if (intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      skip=true;
    }
    String skipPackage=(skip && intent.getData() != null) ? intent.getData().getSchemeSpecificPart() : null;
    if (skipPackage != null && receivers != null) {
      int NT=receivers.size();
      for (int it=0; it < NT; it++) {
        ResolveInfo curt=(ResolveInfo)receivers.get(it);
        if (curt.activityInfo.packageName.equals(skipPackage)) {
          receivers.remove(it);
          it--;
          NT--;
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastRecord r=new BroadcastRecord(intent,callerApp,callerPackage,callingPid,callingUid,requiredPermission,receivers,resultTo,resultCode,resultData,map,ordered);
    if (DEBUG_BROADCAST)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra(""String_Node_Str"",-1);
      Log.i(TAG,""String_Node_Str"" + r.intent.getAction() + ""String_Node_Str""+ seq);
    }
    mOrderedBroadcasts.add(r);
    scheduleBroadcastsLocked();
  }
  return BROADCAST_SUCCESS;
}",0.9954037076758082
183719,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,PackageManager.GET_SHARED_LIBRARY_FILES);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name));
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name));
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}",0.992707826932426
183720,"void dump(PrintWriter pw,String prefix){
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(isForeground);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.println(bad);
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}","void dump(PrintWriter pw,String prefix){
  if (info.className != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.className);
  }
  if (info.manageSpaceActivityName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(info.manageSpaceActivityName);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(info.sourceDir);
  pw.print(""String_Node_Str"");
  pw.print(info.publicSourceDir);
  pw.print(""String_Node_Str"");
  pw.println(info.dataDir);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(pkgList);
  if (instrumentationClass != null || instrumentationProfileFile != null || instrumentationArguments != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(instrumentationClass);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationProfileFile);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationArguments);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(instrumentationInfo);
    if (instrumentationInfo != null) {
      instrumentationInfo.dump(new PrintWriterPrinter(pw),prefix + ""String_Node_Str"");
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(thread);
  pw.print(""String_Node_Str"");
  pw.println(curReceiver);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(pid);
  pw.print(""String_Node_Str"");
  pw.print(starting);
  pw.print(""String_Node_Str"");
  pw.println(lastPss);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(maxAdj);
  pw.print(""String_Node_Str"");
  pw.print(hiddenAdj);
  pw.print(""String_Node_Str"");
  pw.print(curRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(setRawAdj);
  pw.print(""String_Node_Str"");
  pw.print(curAdj);
  pw.print(""String_Node_Str"");
  pw.println(setAdj);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(isForeground);
  pw.print(""String_Node_Str"");
  pw.print(setIsForeground);
  pw.print(""String_Node_Str"");
  pw.print(foregroundServices);
  pw.print(""String_Node_Str"");
  pw.println(forcingToForeground);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(persistent);
  pw.print(""String_Node_Str"");
  pw.print(removed);
  pw.print(""String_Node_Str"");
  pw.println(persistentActivities);
  if (debugging || crashing || crashDialog != null || notResponding || anrDialog != null || bad) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(debugging);
    pw.print(""String_Node_Str"");
    pw.print(crashing);
    pw.print(""String_Node_Str"");
    pw.print(crashDialog);
    pw.print(""String_Node_Str"");
    pw.print(notResponding);
    pw.print(""String_Node_Str"");
    pw.print(anrDialog);
    pw.print(""String_Node_Str"");
    pw.println(bad);
  }
  if (activities.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(activities);
  }
  if (services.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(services);
  }
  if (executingServices.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(executingServices);
  }
  if (connections.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
  if (pubProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pubProviders);
  }
  if (conProviders.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(conProviders);
  }
  if (receivers.size() > 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(receivers);
  }
}",0.9680456490727531
183721,"@Suppress public void testStartUpTime() throws Exception {
  createDB();
  audioPlaybackStartupTime(MediaNames.MP3FILES);
  audioPlaybackStartupTime(MediaNames.AACFILES);
}","@Suppress public void testStartUpTime() throws Exception {
  createDB();
  audioPlaybackStartupTime(MediaNames.MP3FILES);
  audioPlaybackStartupTime(MediaNames.AACFILES);
  if (mDB.isOpen()) {
    mDB.close();
  }
}",0.8888888888888888
183722,"public void createDB(){
  mDB=SQLiteDatabase.openOrCreateDatabase(""String_Node_Str"",null);
  mDB.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void createDB(){
  mDB=SQLiteDatabase.openOrCreateDatabase(""String_Node_Str"",null);
  mDB.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  mDB.execSQL(""String_Node_Str"");
}",0.9291666666666668
183723,"@SuppressWarnings({""String_Node_Str""}) protected void performFiltering(CharSequence text,int keyCode){
  mFilter.filter(text,this);
}","/** 
 * <p>Starts filtering the content of the drop down list. The filtering pattern is the content of the edit box. Subclasses should override this method to filter with a different pattern, for instance a substring of <code>text</code>.</p>
 * @param text the filtering pattern
 * @param keyCode the last character inserted in the edit box; beware thatthis will be null when text is being added through a soft input method.
 */
@SuppressWarnings({""String_Node_Str""}) protected void performFiltering(CharSequence text,int keyCode){
  mFilter.filter(text,this);
}",0.382183908045977
183724,"@Override public void handleMessage(Message msg){
  try {
    if (msg.what == MESSAGE_LOCATION_CHANGED) {
synchronized (mLock) {
        Location location=(Location)msg.obj;
        if (mCollector != null && LocationManager.GPS_PROVIDER.equals(location.getProvider())) {
          try {
            mCollector.updateLocation(location);
          }
 catch (          RemoteException e) {
            Log.w(TAG,""String_Node_Str"");
          }
        }
        String provider=location.getProvider();
        if (!isAllowedBySettingsLocked(provider)) {
          return;
        }
        if (mWakeLockAcquireTime != 0) {
          handleLocationChangedLocked(location);
        }
        if ((mWakeLockAcquireTime != 0) && (SystemClock.elapsedRealtime() - mWakeLockAcquireTime > MAX_TIME_FOR_WAKE_LOCK)) {
          removeMessages(MESSAGE_RELEASE_WAKE_LOCK);
          log(""String_Node_Str"");
          Message m=Message.obtain(this,MESSAGE_RELEASE_WAKE_LOCK);
          sendMessageAtFrontOfQueue(m);
        }
 else         if (mWakeLockAcquireTime != 0 && mWakeLockGpsReceived && mWakeLockNetworkReceived) {
          removeMessages(MESSAGE_RELEASE_WAKE_LOCK);
          log(""String_Node_Str"");
          mWakeLockAcquireTime=0;
          Message m=Message.obtain(this,MESSAGE_RELEASE_WAKE_LOCK);
          sendMessageDelayed(m,TIME_AFTER_WAKE_LOCK);
        }
      }
    }
 else     if (msg.what == MESSAGE_RELEASE_WAKE_LOCK) {
      log(""String_Node_Str"");
synchronized (mLock) {
        updateWakelockStatusLocked();
        releaseWakeLockLocked();
      }
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","@Override public void handleMessage(Message msg){
  try {
    if (msg.what == MESSAGE_LOCATION_CHANGED) {
synchronized (mLock) {
        Location location=(Location)msg.obj;
        if (mCollector != null && LocationManager.GPS_PROVIDER.equals(location.getProvider())) {
          try {
            mCollector.updateLocation(location);
          }
 catch (          RemoteException e) {
            Log.w(TAG,""String_Node_Str"");
          }
        }
        String provider=location.getProvider();
        if (!isAllowedBySettingsLocked(provider)) {
          return;
        }
        handleLocationChangedLocked(location);
        if ((mWakeLockAcquireTime != 0) && (SystemClock.elapsedRealtime() - mWakeLockAcquireTime > MAX_TIME_FOR_WAKE_LOCK)) {
          removeMessages(MESSAGE_RELEASE_WAKE_LOCK);
          log(""String_Node_Str"");
          Message m=Message.obtain(this,MESSAGE_RELEASE_WAKE_LOCK);
          sendMessageAtFrontOfQueue(m);
        }
 else         if (mWakeLockAcquireTime != 0 && mWakeLockGpsReceived && mWakeLockNetworkReceived) {
          removeMessages(MESSAGE_RELEASE_WAKE_LOCK);
          log(""String_Node_Str"");
          mWakeLockAcquireTime=0;
          Message m=Message.obtain(this,MESSAGE_RELEASE_WAKE_LOCK);
          sendMessageDelayed(m,TIME_AFTER_WAKE_LOCK);
        }
      }
    }
 else     if (msg.what == MESSAGE_RELEASE_WAKE_LOCK) {
      log(""String_Node_Str"");
synchronized (mLock) {
        updateWakelockStatusLocked();
        releaseWakeLockLocked();
      }
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9835658914728682
183725,"/** 
 * Play a sound from a sound ID <p>Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded.</p>
 * @param soundID a soundID returned by the load() function
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);","/** 
 * Play a sound from a sound ID. Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means play back at the original frequency. A value of 2.0 means play back twice as fast, and a value of 0.5 means playback at half speed.
 * @param soundID a soundID returned by the load() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 * @param priority stream priority (0 = lowest priority)
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);",0.6243441762854145
183726,"/** 
 * Resume a playback stream <p>Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);","/** 
 * Resume a playback stream. Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);",0.9868766404199476
183727,public native final void release();,"/** 
 * Release the SoundPool resources. Release all memory and native resources used by the SoundPool object. The SoundPool can no longer be used and the reference should be set to null.
 */
public native final void release();",0.2671755725190839
183728,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setLoop(int streamID,int loop);","/** 
 * Set loop mode. Change the loop mode. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 */
public native final void setLoop(int streamID,int loop);",0.2051948051948052
183729,"/** 
 * Set stream volume <p>Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);","/** 
 * Set stream volume. Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);",0.9901960784313726
183730,"public native final void setRate(int streamID,float rate);","/** 
 * Change playback rate. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means playback at the original frequency. A value of 2.0 means playback twice as fast, and a value of 0.5 means playback at half speed. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 */
public native final void setRate(int streamID,float rate);",0.2010398613518197
183731,"/** 
 * Pause a playback stream <p>Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);","/** 
 * Pause a playback stream. Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);",0.9875930521091812
183732,"/** 
 * Load the sound from a FileDescriptor <p>This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.</p>
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}","/** 
 * Load the sound from a FileDescriptor. This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect. Usea value of 1 for future compatibility.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}",0.96048632218845
183733,"/** 
 * Stop a playback stream <p>Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);","/** 
 * Stop a playback stream. Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);",0.9876847290640394
183734,"/** 
 * Unload a sound from a sound ID <p>Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.</p>
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);","/** 
 * Unload a sound from a sound ID. Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);",0.8842364532019704
183735,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);","/** 
 * Change stream priority. Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);",0.91869918699187
183736,"/** 
 * Play a sound from a sound ID <p>Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded.</p>
 * @param soundID a soundID returned by the load() function
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);","/** 
 * Play a sound from a sound ID. Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means play back at the original frequency. A value of 2.0 means play back twice as fast, and a value of 0.5 means playback at half speed.
 * @param soundID a soundID returned by the load() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 * @param priority stream priority (0 = lowest priority)
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);",0.6243441762854145
183737,"/** 
 * Resume a playback stream <p>Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);","/** 
 * Resume a playback stream. Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);",0.9868766404199476
183738,public native final void release();,"/** 
 * Release the SoundPool resources. Release all memory and native resources used by the SoundPool object. The SoundPool can no longer be used and the reference should be set to null.
 */
public native final void release();",0.2671755725190839
183739,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setLoop(int streamID,int loop);","/** 
 * Set loop mode. Change the loop mode. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 */
public native final void setLoop(int streamID,int loop);",0.2051948051948052
183740,"/** 
 * Set stream volume <p>Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);","/** 
 * Set stream volume. Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);",0.9901960784313726
183741,"public native final void setRate(int streamID,float rate);","/** 
 * Change playback rate. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means playback at the original frequency. A value of 2.0 means playback twice as fast, and a value of 0.5 means playback at half speed. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 */
public native final void setRate(int streamID,float rate);",0.2010398613518197
183742,"/** 
 * Pause a playback stream <p>Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);","/** 
 * Pause a playback stream. Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);",0.9875930521091812
183743,"/** 
 * Load the sound from a FileDescriptor <p>This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.</p>
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}","/** 
 * Load the sound from a FileDescriptor. This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect. Usea value of 1 for future compatibility.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}",0.96048632218845
183744,"/** 
 * Stop a playback stream <p>Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);","/** 
 * Stop a playback stream. Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);",0.9876847290640394
183745,"/** 
 * Unload a sound from a sound ID <p>Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.</p>
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);","/** 
 * Unload a sound from a sound ID. Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);",0.8842364532019704
183746,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);","/** 
 * Change stream priority. Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);",0.91869918699187
183747,"/** 
 * Play a sound from a sound ID <p>Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded.</p>
 * @param soundID a soundID returned by the load() function
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);","/** 
 * Play a sound from a sound ID. Play the sound specified by the soundID. This is the value  returned by the load() function. Returns a non-zero streamID if successful, zero if it fails. The streamID can be used to further control playback. Note that calling play() may cause another sound to stop playing if the maximum number of active streams is exceeded. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means play back at the original frequency. A value of 2.0 means play back twice as fast, and a value of 0.5 means playback at half speed.
 * @param soundID a soundID returned by the load() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 * @param priority stream priority (0 = lowest priority)
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 * @return non-zero streamID if successful, zero if failed
 */
public native final int play(int soundID,float leftVolume,float rightVolume,int priority,int loop,float rate);",0.6243441762854145
183748,"/** 
 * Resume a playback stream <p>Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);","/** 
 * Resume a playback stream. Resume the stream specified by the streamID. This is the value returned by the play() function. If the stream is paused, this will resume playback. If the stream was not previously paused, calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void resume(int streamID);",0.9868766404199476
183749,public native final void release();,"/** 
 * Release the SoundPool resources. Release all memory and native resources used by the SoundPool object. The SoundPool can no longer be used and the reference should be set to null.
 */
public native final void release();",0.2671755725190839
183750,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setLoop(int streamID,int loop);","/** 
 * Set loop mode. Change the loop mode. A loop value of -1 means loop forever, a value of 0 means don't loop, other values indicate the number of repeats, e.g. a value of 1 plays the audio twice. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 */
public native final void setLoop(int streamID,int loop);",0.2051948051948052
183751,"/** 
 * Set stream volume <p>Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);","/** 
 * Set stream volume. Sets the volume on the stream specified by the streamID. This is the value returned by the play() function. The value must be in the range of 0.0 to 1.0. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 */
public native final void setVolume(int streamID,float leftVolume,float rightVolume);",0.9901960784313726
183752,"public native final void setRate(int streamID,float rate);","/** 
 * Change playback rate. The playback rate allows the application to vary the playback rate (pitch) of the sound. A value of 1.0 means playback at the original frequency. A value of 2.0 means playback twice as fast, and a value of 0.5 means playback at half speed. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 */
public native final void setRate(int streamID,float rate);",0.2010398613518197
183753,"/** 
 * Pause a playback stream <p>Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);","/** 
 * Pause a playback stream. Pause the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be paused. If the stream is not playing (e.g. is stopped or was previously paused), calling this function will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void pause(int streamID);",0.9875930521091812
183754,"/** 
 * Load the sound from a FileDescriptor <p>This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.</p>
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}","/** 
 * Load the sound from a FileDescriptor. This version is useful if you store multiple sounds in a single binary. The offset specifies the offset from the start of the file and the length specifies the length of the sound within the file.
 * @param fd a FileDescriptor object
 * @param offset offset to the start of the sound
 * @param length length of the sound
 * @param priority the priority of the sound. Currently has no effect. Usea value of 1 for future compatibility.
 * @return a sound ID. This value can be used to play or unload the sound.
 */
public int load(FileDescriptor fd,long offset,long length,int priority){
  return _load(fd,offset,length,priority);
}",0.96048632218845
183755,"/** 
 * Stop a playback stream <p>Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.</p>
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);","/** 
 * Stop a playback stream. Stop the stream specified by the streamID. This is the value returned by the play() function. If the stream is playing, it will be stopped. It also releases any native resources associated with this stream. If the stream is not playing, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void stop(int streamID);",0.9876847290640394
183756,"/** 
 * Unload a sound from a sound ID <p>Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.</p>
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);","/** 
 * Unload a sound from a sound ID. Unloads the sound specified by the soundID. This is the value returned by the load() function. Returns true if the sound is successfully unloaded, false if the sound was already unloaded.
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */
public native final boolean unload(int soundID);",0.8842364532019704
183757,"/** 
 * Change stream priority <p>Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);","/** 
 * Change stream priority. Change the priority of the stream specified by the streamID. This is the value returned by the play() function. Affects the order in which streams are re-used to play new sounds. If the stream does not exist, it will have no effect.
 * @param streamID a streamID returned by the play() function
 */
public native final void setPriority(int streamID,int priority);",0.91869918699187
183758,"public void dump(boolean timeout,String webkitData){
  if (mResultFile == null || mResultFile.length() == 0) {
    finished();
    return;
  }
  try {
    File parentDir=new File(mResultFile).getParentFile();
    if (!parentDir.exists()) {
      parentDir.mkdirs();
    }
    FileOutputStream os=new FileOutputStream(mResultFile);
    if (timeout) {
      Log.w(""String_Node_Str"",mResultFile);
      os.write(TIMEOUT_STR.getBytes());
      os.write('\n');
    }
    if (mDumpTitleChanges)     os.write(mTitleChanges.toString().getBytes());
    if (mDialogStrings != null)     os.write(mDialogStrings.toString().getBytes());
    mDialogStrings=null;
    os.write(webkitData.getBytes());
    os.flush();
    os.close();
  }
 catch (  IOException ex) {
    Log.e(LOGTAG,""String_Node_Str"" + mResultFile + ""String_Node_Str""+ ex.getMessage());
  }
  finished();
}","public void dump(boolean timeout,String webkitData){
  if (mResultFile == null || mResultFile.length() == 0) {
    finished();
    return;
  }
  try {
    File parentDir=new File(mResultFile).getParentFile();
    if (!parentDir.exists()) {
      parentDir.mkdirs();
    }
    FileOutputStream os=new FileOutputStream(mResultFile);
    if (timeout) {
      Log.w(""String_Node_Str"",mResultFile);
      os.write(TIMEOUT_STR.getBytes());
      os.write('\n');
    }
    if (mDumpTitleChanges)     os.write(mTitleChanges.toString().getBytes());
    if (mDialogStrings != null)     os.write(mDialogStrings.toString().getBytes());
    mDialogStrings=null;
    if (webkitData != null)     os.write(webkitData.getBytes());
    os.flush();
    os.close();
  }
 catch (  IOException ex) {
    Log.e(LOGTAG,""String_Node_Str"" + mResultFile + ""String_Node_Str""+ ex.getMessage());
  }
  finished();
}",0.983926521239954
183759,"@Override protected void finalize() throws Throwable {
  clear();
}","@Override protected void finalize() throws Throwable {
  release();
}",0.9558823529411764
183760,"/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}.
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}","/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}. <p><em>Note: scheme and host name matching in the Android framework is case-sensitive, unlike the formal RFC.  As a result, you should always ensure that you write your Uri with these elements using lower case letters, and normalize any Uris you receive from outside of Android to ensure the scheme and host is lower case.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}",0.7256198347107438
183761,"/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here.
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}","/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here. <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}",0.6683260734287492
183762,"/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}","/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}",0.7829727843684577
183763,"/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match.
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}","/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match. <p><em>Note: host name in the Android framework is case-sensitive, unlike formal RFC host names.  As a result, you should always write your host names with lower case letters, and any host names you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}",0.8480885311871227
183764,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Note that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well).
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9326629556473336
183765,"/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data.
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}","/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data. <p><em>Note: scheme matching in the Android framework is case-sensitive, unlike formal RFC schemes.  As a result, you should always write your schemes with lower case letters, and any schemes you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}",0.7910552061495457
183766,"/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}","/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p> <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}",0.8815238095238095
183767,"/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}.
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}","/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}. <p><em>Note: scheme and host name matching in the Android framework is case-sensitive, unlike the formal RFC.  As a result, you should always ensure that you write your Uri with these elements using lower case letters, and normalize any Uris you receive from outside of Android to ensure the scheme and host is lower case.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}",0.7256198347107438
183768,"/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here.
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}","/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here. <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}",0.6683260734287492
183769,"/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}","/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}",0.7829727843684577
183770,"/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match.
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}","/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match. <p><em>Note: host name in the Android framework is case-sensitive, unlike formal RFC host names.  As a result, you should always write your host names with lower case letters, and any host names you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}",0.8480885311871227
183771,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Note that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well).
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9326629556473336
183772,"/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data.
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}","/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data. <p><em>Note: scheme matching in the Android framework is case-sensitive, unlike formal RFC schemes.  As a result, you should always write your schemes with lower case letters, and any schemes you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}",0.7910552061495457
183773,"/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}","/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p> <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}",0.8815238095238095
183774,"/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}.
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}","/** 
 * Set the data this intent is operating on.  This method automatically clears any type that was previously set by   {@link #setType}. <p><em>Note: scheme and host name matching in the Android framework is case-sensitive, unlike the formal RFC.  As a result, you should always ensure that you write your Uri with these elements using lower case letters, and normalize any Uris you receive from outside of Android to ensure the scheme and host is lower case.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getData
 * @see #setType
 * @see #setDataAndType
 */
public Intent setData(Uri data){
  mData=data;
  mType=null;
  return this;
}",0.7256198347107438
183775,"/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here.
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}","/** 
 * (Usually optional) Set the data for the intent along with an explicit MIME data type.  This method should very rarely be used -- it allows you to override the MIME type that would ordinarily be inferred from the data with your own type given here. <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param data The URI of the data this intent is now targeting.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #setData
 * @see #setType
 */
public Intent setDataAndType(Uri data,String type){
  mData=data;
  mType=type;
  return this;
}",0.6683260734287492
183776,"/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}.
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}","/** 
 * Set an explicit MIME data type.  This is used to create intents that only specify a type and not data, for example to indicate the type of data to return.  This method automatically clears any data that was previously set by   {@link #setData}. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param type The MIME type of the data being handled by this intent.
 * @return Returns the same Intent object, for chaining multiple callsinto a single statement.
 * @see #getType
 * @see #setData
 * @see #setDataAndType
 */
public Intent setType(String type){
  mData=null;
  mType=type;
  return this;
}",0.7829727843684577
183777,"/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match.
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}","/** 
 * Add a new Intent data authority to match against.  The filter must include one or more schemes (via   {@link #addDataScheme}) for the authority to be considered.  If any authorities are included in the filter, then an Intent's data must match one of them.  If no authorities are included, then only the scheme must match. <p><em>Note: host name in the Android framework is case-sensitive, unlike formal RFC host names.  As a result, you should always write your host names with lower case letters, and any host names you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param host The host part of the authority to match.  May start with asingle '*' to wildcard the front of the host name.
 * @param port Optional port part of the authority to match.  If null, anyport is allowed.
 * @see #matchData
 * @see #addDataScheme
 */
public final void addDataAuthority(String host,String port){
  if (mDataAuthorities == null)   mDataAuthorities=new ArrayList<AuthorityEntry>();
  if (port != null)   port=port.intern();
  mDataAuthorities.add(new AuthorityEntry(host.intern(),port));
}",0.8480885311871227
183778,"/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Note that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well).
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}","/** 
 * Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. <p>Be aware that to match against an authority, you must also specify a base scheme the authority is in.  To match against a data path, both a scheme and authority must be specified.  If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). <p><em>Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.</em></p>
 * @param type The desired data type to look for, as returned byIntent.resolveType().
 * @param scheme The desired data scheme to look for, as returned byIntent.getScheme().
 * @param data The full data string to match against, as supplied inIntent.data.
 * @return Returns either a valid match constant (a combination of{@link #MATCH_CATEGORY_MASK} and {@link #MATCH_ADJUSTMENT_MASK}), or one of the error codes   {@link #NO_MATCH_TYPE} if the type didn't matchor  {@link #NO_MATCH_DATA} if the scheme/path didn't match.
 * @see #match
 */
public final int matchData(String type,String scheme,Uri data){
  final ArrayList<String> types=mDataTypes;
  final ArrayList<String> schemes=mDataSchemes;
  final ArrayList<AuthorityEntry> authorities=mDataAuthorities;
  final ArrayList<PatternMatcher> paths=mDataPaths;
  int match=MATCH_CATEGORY_EMPTY;
  if (types == null && schemes == null) {
    return ((type == null && data == null) ? (MATCH_CATEGORY_EMPTY + MATCH_ADJUSTMENT_NORMAL) : NO_MATCH_DATA);
  }
  if (schemes != null) {
    if (schemes.contains(scheme != null ? scheme : ""String_Node_Str"")) {
      match=MATCH_CATEGORY_SCHEME;
    }
 else {
      return NO_MATCH_DATA;
    }
    if (authorities != null) {
      int authMatch=matchDataAuthority(data);
      if (authMatch >= 0) {
        if (paths == null) {
          match=authMatch;
        }
 else         if (hasDataPath(data.getPath())) {
          match=MATCH_CATEGORY_PATH;
        }
 else {
          return NO_MATCH_DATA;
        }
      }
 else {
        return NO_MATCH_DATA;
      }
    }
  }
 else {
    if (scheme != null && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme) && !""String_Node_Str"".equals(scheme)) {
      return NO_MATCH_DATA;
    }
  }
  if (types != null) {
    if (findMimeType(type)) {
      match=MATCH_CATEGORY_TYPE;
    }
 else {
      return NO_MATCH_TYPE;
    }
  }
 else {
    if (type != null) {
      return NO_MATCH_TYPE;
    }
  }
  return match + MATCH_ADJUSTMENT_NORMAL;
}",0.9326629556473336
183779,"/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data.
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}","/** 
 * Add a new Intent data scheme to match against.  If any schemes are included in the filter, then an Intent's data must be <em>either</em> one of these schemes <em>or</em> a matching data type.  If no schemes are included, then an Intent will match only if it includes no data. <p><em>Note: scheme matching in the Android framework is case-sensitive, unlike formal RFC schemes.  As a result, you should always write your schemes with lower case letters, and any schemes you receive from outside of Android should be converted to lower case before supplying them here.</em></p>
 * @param scheme Name of the scheme to match, i.e. ""http"".
 * @see #matchData
 */
public final void addDataScheme(String scheme){
  if (mDataSchemes == null)   mDataSchemes=new ArrayList<String>();
  if (!mDataSchemes.contains(scheme)) {
    mDataSchemes.add(scheme.intern());
  }
}",0.7910552061495457
183780,"/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}","/** 
 * Add a new Intent data type to match against.  If any types are included in the filter, then an Intent's data must be <em>either</em> one of these types <em>or</em> a matching scheme.  If no data types are included, then an Intent will only match if it specifies no data. <p><em>Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types.  As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here.</em></p> <p>Throws   {@link MalformedMimeTypeException} if the given MIME type isnot syntactically correct.
 * @param type Name of the data type to match, i.e. ""vnd.android.cursor.dir/person"".
 * @see #matchData
 */
public final void addDataType(String type) throws MalformedMimeTypeException {
  final int slashpos=type.indexOf('/');
  final int typelen=type.length();
  if (slashpos > 0 && typelen >= slashpos + 2) {
    if (mDataTypes == null)     mDataTypes=new ArrayList<String>();
    if (typelen == slashpos + 2 && type.charAt(slashpos + 1) == '*') {
      String str=type.substring(0,slashpos);
      if (!mDataTypes.contains(str)) {
        mDataTypes.add(str.intern());
      }
      mHasPartialTypes=true;
    }
 else {
      if (!mDataTypes.contains(type)) {
        mDataTypes.add(type.intern());
      }
    }
    return;
  }
  throw new MalformedMimeTypeException(type);
}",0.8815238095238095
183781,"/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called from the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);","/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called within the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}. <p>The Intent filters used in   {@link android.content.Context#registerReceiver}and in application manifests are <em>not</em> guaranteed to be exclusive. They are hints to the operating system about how to find suitable recipients. It is possible for senders to force delivery to specific recipients, bypassing filter resolution.  For this reason,   {@link #onReceive(Context,Intent) onReceive()}implementations should respond only to known actions, ignoring any unexpected Intents that they may receive.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);",0.8259547144305509
183782,"/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called from the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);","/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called within the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}. <p>The Intent filters used in   {@link android.content.Context#registerReceiver}and in application manifests are <em>not</em> guaranteed to be exclusive. They are hints to the operating system about how to find suitable recipients. It is possible for senders to force delivery to specific recipients, bypassing filter resolution.  For this reason,   {@link #onReceive(Context,Intent) onReceive()}implementations should respond only to known actions, ignoring any unexpected Intents that they may receive.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);",0.8259547144305509
183783,"/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called from the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);","/** 
 * This method is called when the BroadcastReceiver is receiving an Intent broadcast.  During this time you can use the other methods on BroadcastReceiver to view/modify the current result values.  The function is normally called within the main thread of its process, so you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). <p><b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag, then the object is no longer alive after returning from this function.</b>  This means you should not perform any operations that return a result to you asynchronously -- in particular, for interacting with services, you should use  {@link Context#startService(Intent)} instead of{@link Context#bindService(Intent,ServiceConnection,int)}.  If you wish to interact with a service that is already running, you can use  {@link #peekService}. <p>The Intent filters used in   {@link android.content.Context#registerReceiver}and in application manifests are <em>not</em> guaranteed to be exclusive. They are hints to the operating system about how to find suitable recipients. It is possible for senders to force delivery to specific recipients, bypassing filter resolution.  For this reason,   {@link #onReceive(Context,Intent) onReceive()}implementations should respond only to known actions, ignoring any unexpected Intents that they may receive.
 * @param context The Context in which the receiver is running.
 * @param intent The Intent being received.
 */
public abstract void onReceive(Context context,Intent intent);",0.8259547144305509
183784,"/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}","/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster. The value must be one of  {@link #SENSOR_DELAY_NORMAL},   {@link #SENSOR_DELAY_UI},   {@link #SENSOR_DELAY_GAME}, or  {@link #SENSOR_DELAY_FASTEST}.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}",0.6645282010157711
183785,"/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}","/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster. The value must be one of  {@link #SENSOR_DELAY_NORMAL},   {@link #SENSOR_DELAY_UI},   {@link #SENSOR_DELAY_GAME}, or  {@link #SENSOR_DELAY_FASTEST}.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}",0.6645282010157711
183786,"/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && i <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}","/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}",0.997995991983968
183787,"/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}","/** 
 * Registers a   {@link android.hardware.SensorEventListener SensorEventListener}for the given sensor.
 * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
 * @param sensor The {@link android.hardware.Sensor Sensor} to register to.
 * @param rate The rate {@link android.hardware.SensorEvent sensor events} are delivered at.This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster. The value must be one of  {@link #SENSOR_DELAY_NORMAL},   {@link #SENSOR_DELAY_UI},   {@link #SENSOR_DELAY_GAME}, or  {@link #SENSOR_DELAY_FASTEST}.
 * @param handler The {@link android.os.Handler Handler} the{@link android.hardware.SensorEvent sensor events} will be delivered to.
 * @return true if the sensor is supported and successfully enabled.
 */
public boolean registerListener(SensorEventListener listener,Sensor sensor,int rate,Handler handler){
  if (listener == null || sensor == null) {
    return false;
  }
  boolean result;
  int delay=-1;
switch (rate) {
case SENSOR_DELAY_FASTEST:
    delay=0;
  break;
case SENSOR_DELAY_GAME:
delay=20;
break;
case SENSOR_DELAY_UI:
delay=60;
break;
case SENSOR_DELAY_NORMAL:
delay=200;
break;
default :
return false;
}
try {
synchronized (sListeners) {
ListenerDelegate l=null;
for (ListenerDelegate i : sListeners) {
if (i.getListener() == listener) {
l=i;
break;
}
}
String name=sensor.getName();
int handle=sensor.getHandle();
if (l == null) {
l=new ListenerDelegate(listener,sensor,handler);
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
sListeners.add(l);
sListeners.notify();
}
if (!sListeners.isEmpty()) {
sSensorThread.startLocked(mSensorService);
}
}
 else {
result=mSensorService.enableSensor(l,name,handle,delay);
if (result) {
l.addSensor(sensor);
}
}
}
}
 catch (RemoteException e) {
Log.e(TAG,""String_Node_Str"",e);
result=false;
}
return result;
}",0.6645282010157711
183788,"/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && i <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}","/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}",0.997995991983968
183789,"/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && i <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}","/** 
 * Returns the name, conservatively quoting it if there are any characters that are likely to cause trouble outside of a quoted string, or returning it literally if it seems safe.
 */
public static String quoteNameIfNecessary(String name){
  int len=name.length();
  for (int i=0; i < len; i++) {
    char c=name.charAt(i);
    if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c == ' ')|| (c >= '0' && c <= '9'))) {
      return '""' + quoteName(name) + '""';
    }
  }
  return name;
}",0.997995991983968
183790,"/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) >= ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}","/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}",0.9998218421521468
183791,"public void run(){
  try {
    if (!hasCache) {
      captureView.buildDrawingCache();
    }
    cache[0]=captureView.getDrawingCache();
  }
  finally {
    latch.countDown();
  }
}","public void run(){
  try {
    cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
  }
 catch (  OutOfMemoryError e) {
    try {
      cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
    }
 catch (    OutOfMemoryError e2) {
      Log.w(""String_Node_Str"",""String_Node_Str"");
    }
  }
 finally {
    latch.countDown();
  }
}",0.3684210526315789
183792,"private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    final boolean hasCache=captureView.isDrawingCacheEnabled();
    final boolean willNotCache=captureView.willNotCacheDrawing();
    if (willNotCache) {
      captureView.setWillNotCacheDrawing(false);
    }
    root.post(new Runnable(){
      public void run(){
        try {
          if (!hasCache) {
            captureView.buildDrawingCache();
          }
          cache[0]=captureView.getDrawingCache();
        }
  finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
        }
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
 finally {
      if (willNotCache) {
        captureView.setWillNotCacheDrawing(true);
      }
      if (!hasCache) {
        captureView.destroyDrawingCache();
      }
    }
  }
}","private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    root.post(new Runnable(){
      public void run(){
        try {
          cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
        }
 catch (        OutOfMemoryError e) {
          try {
            cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
          }
 catch (          OutOfMemoryError e2) {
            Log.w(""String_Node_Str"",""String_Node_Str"");
          }
        }
 finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
          cache[0].recycle();
        }
      }
 else {
        Log.w(""String_Node_Str"",""String_Node_Str"");
        clientStream.close();
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
  }
}",0.6561450638012088
183793,"/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 */
public void finishLayoutLw();","/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 * @return Return true if layout state may have changed (so that another layout will be performed).
 */
public boolean finishLayoutLw();",0.7793240556660039
183794,"/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}","/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  mForegroundBoundsChanged=true;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}",0.9908764169200996
183795,"/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    mForeground.draw(canvas);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    final Drawable foreground=mForeground;
    if (mForegroundBoundsChanged) {
      mForegroundBoundsChanged=false;
      if (foreground != null) {
        final Rect selfBounds=mSelfBounds;
        final Rect overlayBounds=mOverlayBounds;
        final int w=mRight - mLeft;
        final int h=mBottom - mTop;
        if (mForegroundInPadding) {
          selfBounds.set(0,0,w,h);
        }
 else {
          selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
        }
        Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
        foreground.setBounds(overlayBounds);
      }
    }
    foreground.draw(canvas);
  }
}",0.286
183796,"/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  final Drawable foreground=mForeground;
  if (foreground != null) {
    final Rect selfBounds=mSelfBounds;
    final Rect overlayBounds=mOverlayBounds;
    if (mForegroundInPadding) {
      selfBounds.set(0,0,w,h);
    }
 else {
      selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
    }
    Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
    foreground.setBounds(overlayBounds);
  }
}","/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  mForegroundBoundsChanged=true;
}",0.3984962406015037
183797,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  if (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    mPolicy.finishLayoutLw();
    mLayoutNeeded=false;
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    if (!mPolicy.finishLayoutLw()) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
    }
 else {
      repeats++;
    }
  }
}",0.8470195914964569
183798,"/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) >= ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}","/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}",0.9998218421521468
183799,"public void run(){
  try {
    if (!hasCache) {
      captureView.buildDrawingCache();
    }
    cache[0]=captureView.getDrawingCache();
  }
  finally {
    latch.countDown();
  }
}","public void run(){
  try {
    cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
  }
 catch (  OutOfMemoryError e) {
    try {
      cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
    }
 catch (    OutOfMemoryError e2) {
      Log.w(""String_Node_Str"",""String_Node_Str"");
    }
  }
 finally {
    latch.countDown();
  }
}",0.3684210526315789
183800,"private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    final boolean hasCache=captureView.isDrawingCacheEnabled();
    final boolean willNotCache=captureView.willNotCacheDrawing();
    if (willNotCache) {
      captureView.setWillNotCacheDrawing(false);
    }
    root.post(new Runnable(){
      public void run(){
        try {
          if (!hasCache) {
            captureView.buildDrawingCache();
          }
          cache[0]=captureView.getDrawingCache();
        }
  finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
        }
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
 finally {
      if (willNotCache) {
        captureView.setWillNotCacheDrawing(true);
      }
      if (!hasCache) {
        captureView.destroyDrawingCache();
      }
    }
  }
}","private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    root.post(new Runnable(){
      public void run(){
        try {
          cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
        }
 catch (        OutOfMemoryError e) {
          try {
            cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
          }
 catch (          OutOfMemoryError e2) {
            Log.w(""String_Node_Str"",""String_Node_Str"");
          }
        }
 finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
          cache[0].recycle();
        }
      }
 else {
        Log.w(""String_Node_Str"",""String_Node_Str"");
        clientStream.close();
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
  }
}",0.6561450638012088
183801,"/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 */
public void finishLayoutLw();","/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 * @return Return true if layout state may have changed (so that another layout will be performed).
 */
public boolean finishLayoutLw();",0.7793240556660039
183802,"/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}","/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  mForegroundBoundsChanged=true;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}",0.9908764169200996
183803,"/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    mForeground.draw(canvas);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    final Drawable foreground=mForeground;
    if (mForegroundBoundsChanged) {
      mForegroundBoundsChanged=false;
      if (foreground != null) {
        final Rect selfBounds=mSelfBounds;
        final Rect overlayBounds=mOverlayBounds;
        final int w=mRight - mLeft;
        final int h=mBottom - mTop;
        if (mForegroundInPadding) {
          selfBounds.set(0,0,w,h);
        }
 else {
          selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
        }
        Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
        foreground.setBounds(overlayBounds);
      }
    }
    foreground.draw(canvas);
  }
}",0.286
183804,"/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  final Drawable foreground=mForeground;
  if (foreground != null) {
    final Rect selfBounds=mSelfBounds;
    final Rect overlayBounds=mOverlayBounds;
    if (mForegroundInPadding) {
      selfBounds.set(0,0,w,h);
    }
 else {
      selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
    }
    Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
    foreground.setBounds(overlayBounds);
  }
}","/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  mForegroundBoundsChanged=true;
}",0.3984962406015037
183805,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  if (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    mPolicy.finishLayoutLw();
    mLayoutNeeded=false;
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    if (!mPolicy.finishLayoutLw()) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
    }
 else {
      repeats++;
    }
  }
}",0.8470195914964569
183806,"/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}","/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  return false;
}",0.160337552742616
183807,"/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}","/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,false,false)) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
    }
  }
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}",0.8763145861911295
183808,"/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}",0.9658074697527615
183809,"/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
}","/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
}",0.7430830039525692
183810,"/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,true,false) && win.isVisibleLw()) {
      mTopFullscreenOpaqueWindowState=win;
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
}",0.3694915254237288
183811,"/** 
 * {@inheritDoc} 
 */
public void finishLayoutLw(){
}","/** 
 * {@inheritDoc} 
 */
public boolean finishLayoutLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"");
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}",0.081008100810081
183812,"/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) >= ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}","/** 
 * <p>Forces the drawing cache to be built if the drawing cache is invalid.</p> <p>If you call   {@link #buildDrawingCache()} manually without calling{@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you should cleanup the cache by calling   {@link #destroyDrawingCache()} afterwards.</p>
 * @see #getDrawingCache()
 * @see #destroyDrawingCache()
 */
public void buildDrawingCache(){
  if ((mPrivateFlags & DRAWING_CACHE_VALID) == 0 || mDrawingCache == null || mDrawingCache.get() == null) {
    if (ViewDebug.TRACE_HIERARCHY) {
      ViewDebug.trace(this,ViewDebug.HierarchyTraceType.BUILD_CACHE);
    }
    if (ViewRoot.PROFILE_DRAWING) {
      EventLog.writeEvent(60002,hashCode());
    }
    final int width=mRight - mLeft;
    final int height=mBottom - mTop;
    final int drawingCacheBackgroundColor=mDrawingCacheBackgroundColor;
    final boolean opaque=drawingCacheBackgroundColor != 0 || (mBGDrawable != null && mBGDrawable.getOpacity() == PixelFormat.OPAQUE);
    if (width <= 0 || height <= 0 || (width * height * (opaque ? 2 : 4) > ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {
      destroyDrawingCache();
      return;
    }
    boolean clear=true;
    Bitmap bitmap=mDrawingCache == null ? null : mDrawingCache.get();
    if (bitmap == null || bitmap.getWidth() != width || bitmap.getHeight() != height) {
      Bitmap.Config quality;
      if (!opaque) {
switch (mViewFlags & DRAWING_CACHE_QUALITY_MASK) {
case DRAWING_CACHE_QUALITY_AUTO:
          quality=Bitmap.Config.ARGB_8888;
        break;
case DRAWING_CACHE_QUALITY_LOW:
      quality=Bitmap.Config.ARGB_4444;
    break;
case DRAWING_CACHE_QUALITY_HIGH:
  quality=Bitmap.Config.ARGB_8888;
break;
default :
quality=Bitmap.Config.ARGB_8888;
break;
}
}
 else {
quality=Bitmap.Config.RGB_565;
}
if (bitmap != null) bitmap.recycle();
try {
bitmap=Bitmap.createBitmap(width,height,quality);
mDrawingCache=new SoftReference<Bitmap>(bitmap);
}
 catch (OutOfMemoryError e) {
mDrawingCache=null;
return;
}
clear=drawingCacheBackgroundColor != 0;
}
Canvas canvas;
final AttachInfo attachInfo=mAttachInfo;
if (attachInfo != null) {
canvas=attachInfo.mCanvas;
if (canvas == null) {
canvas=new Canvas();
}
canvas.setBitmap(bitmap);
attachInfo.mCanvas=null;
}
 else {
canvas=new Canvas(bitmap);
}
if (clear) {
bitmap.eraseColor(drawingCacheBackgroundColor);
}
computeScroll();
final int restoreCount=canvas.save();
canvas.translate(-mScrollX,-mScrollY);
mPrivateFlags|=DRAWN;
if ((mPrivateFlags & SKIP_DRAW) == SKIP_DRAW) {
if (ViewDebug.TRACE_HIERARCHY) {
ViewDebug.trace(this,ViewDebug.HierarchyTraceType.DRAW);
}
dispatchDraw(canvas);
}
 else {
draw(canvas);
}
canvas.restoreToCount(restoreCount);
if (attachInfo != null) {
attachInfo.mCanvas=canvas;
}
mPrivateFlags|=DRAWING_CACHE_VALID;
}
}",0.9998218421521468
183813,"public void run(){
  try {
    if (!hasCache) {
      captureView.buildDrawingCache();
    }
    cache[0]=captureView.getDrawingCache();
  }
  finally {
    latch.countDown();
  }
}","public void run(){
  try {
    cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
  }
 catch (  OutOfMemoryError e) {
    try {
      cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
    }
 catch (    OutOfMemoryError e2) {
      Log.w(""String_Node_Str"",""String_Node_Str"");
    }
  }
 finally {
    latch.countDown();
  }
}",0.3684210526315789
183814,"private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    final boolean hasCache=captureView.isDrawingCacheEnabled();
    final boolean willNotCache=captureView.willNotCacheDrawing();
    if (willNotCache) {
      captureView.setWillNotCacheDrawing(false);
    }
    root.post(new Runnable(){
      public void run(){
        try {
          if (!hasCache) {
            captureView.buildDrawingCache();
          }
          cache[0]=captureView.getDrawingCache();
        }
  finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
        }
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
 finally {
      if (willNotCache) {
        captureView.setWillNotCacheDrawing(true);
      }
      if (!hasCache) {
        captureView.destroyDrawingCache();
      }
    }
  }
}","private static void capture(View root,final OutputStream clientStream,String parameter) throws IOException {
  final View captureView=findView(root,parameter);
  if (captureView != null) {
    final CountDownLatch latch=new CountDownLatch(1);
    final Bitmap[] cache=new Bitmap[1];
    root.post(new Runnable(){
      public void run(){
        try {
          cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_8888,0);
        }
 catch (        OutOfMemoryError e) {
          try {
            cache[0]=captureView.createSnapshot(Bitmap.Config.ARGB_4444,0);
          }
 catch (          OutOfMemoryError e2) {
            Log.w(""String_Node_Str"",""String_Node_Str"");
          }
        }
 finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(CAPTURE_TIMEOUT,TimeUnit.MILLISECONDS);
      if (cache[0] != null) {
        BufferedOutputStream out=null;
        try {
          out=new BufferedOutputStream(clientStream,32 * 1024);
          cache[0].compress(Bitmap.CompressFormat.PNG,100,out);
          out.flush();
        }
  finally {
          if (out != null) {
            out.close();
          }
          cache[0].recycle();
        }
      }
 else {
        Log.w(""String_Node_Str"",""String_Node_Str"");
        clientStream.close();
      }
    }
 catch (    InterruptedException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"" + captureView);
      Thread.currentThread().interrupt();
    }
  }
}",0.6561450638012088
183815,"/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 */
public void finishLayoutLw();","/** 
 * Called when layout of the windows is finished.  After this function has returned, all windows given to layoutWindow() <em>must</em> have had a frame assigned.
 * @return Return true if layout state may have changed (so that another layout will be performed).
 */
public boolean finishLayoutLw();",0.7793240556660039
183816,"/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}","/** 
 * {@inheritDoc}
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  final int count=getChildCount();
  final int parentLeft=mPaddingLeft + mForegroundPaddingLeft;
  final int parentRight=right - left - mPaddingRight- mForegroundPaddingRight;
  final int parentTop=mPaddingTop + mForegroundPaddingTop;
  final int parentBottom=bottom - top - mPaddingBottom- mForegroundPaddingBottom;
  mForegroundBoundsChanged=true;
  for (int i=0; i < count; i++) {
    final View child=getChildAt(i);
    if (child.getVisibility() != GONE) {
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      final int width=child.getMeasuredWidth();
      final int height=child.getMeasuredHeight();
      int childLeft=parentLeft;
      int childTop=parentTop;
      final int gravity=lp.gravity;
      if (gravity != -1) {
        final int horizontalGravity=gravity & Gravity.HORIZONTAL_GRAVITY_MASK;
        final int verticalGravity=gravity & Gravity.VERTICAL_GRAVITY_MASK;
switch (horizontalGravity) {
case Gravity.LEFT:
          childLeft=parentLeft + lp.leftMargin;
        break;
case Gravity.CENTER_HORIZONTAL:
      childLeft=parentLeft + (parentRight - parentLeft + lp.leftMargin + lp.rightMargin - width) / 2;
    break;
case Gravity.RIGHT:
  childLeft=parentRight - width - lp.rightMargin;
break;
default :
childLeft=parentLeft + lp.leftMargin;
}
switch (verticalGravity) {
case Gravity.TOP:
childTop=parentTop + lp.topMargin;
break;
case Gravity.CENTER_VERTICAL:
childTop=parentTop + (parentBottom - parentTop + lp.topMargin + lp.bottomMargin - height) / 2;
break;
case Gravity.BOTTOM:
childTop=parentBottom - height - lp.bottomMargin;
break;
default :
childTop=parentTop + lp.topMargin;
}
}
child.layout(childLeft,childTop,childLeft + width,childTop + height);
}
}
}",0.9908764169200996
183817,"/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    mForeground.draw(canvas);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void draw(Canvas canvas){
  super.draw(canvas);
  if (mForeground != null) {
    final Drawable foreground=mForeground;
    if (mForegroundBoundsChanged) {
      mForegroundBoundsChanged=false;
      if (foreground != null) {
        final Rect selfBounds=mSelfBounds;
        final Rect overlayBounds=mOverlayBounds;
        final int w=mRight - mLeft;
        final int h=mBottom - mTop;
        if (mForegroundInPadding) {
          selfBounds.set(0,0,w,h);
        }
 else {
          selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
        }
        Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
        foreground.setBounds(overlayBounds);
      }
    }
    foreground.draw(canvas);
  }
}",0.286
183818,"/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  final Drawable foreground=mForeground;
  if (foreground != null) {
    final Rect selfBounds=mSelfBounds;
    final Rect overlayBounds=mOverlayBounds;
    if (mForegroundInPadding) {
      selfBounds.set(0,0,w,h);
    }
 else {
      selfBounds.set(mPaddingLeft,mPaddingTop,w - mPaddingRight,h - mPaddingBottom);
    }
    Gravity.apply(mForegroundGravity,foreground.getIntrinsicWidth(),foreground.getIntrinsicHeight(),selfBounds,overlayBounds);
    foreground.setBounds(overlayBounds);
  }
}","/** 
 * {@inheritDoc}
 */
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  mForegroundBoundsChanged=true;
}",0.3984962406015037
183819,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  if (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    mPolicy.finishLayoutLw();
    mLayoutNeeded=false;
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    if (!mPolicy.finishLayoutLw()) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
    }
 else {
      repeats++;
    }
  }
}",0.8470195914964569
183820,"/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}","/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  return false;
}",0.160337552742616
183821,"/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}","/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,false,false)) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
    }
  }
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}",0.8763145861911295
183822,"/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}",0.9658074697527615
183823,"/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
}","/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
}",0.7430830039525692
183824,"/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,true,false) && win.isVisibleLw()) {
      mTopFullscreenOpaqueWindowState=win;
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
}",0.3694915254237288
183825,"/** 
 * {@inheritDoc} 
 */
public void finishLayoutLw(){
}","/** 
 * {@inheritDoc} 
 */
public boolean finishLayoutLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"");
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}",0.081008100810081
183826,"/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}","/** 
 * {@inheritDoc} 
 */
public boolean finishAnimationLw(){
  return false;
}",0.160337552742616
183827,"/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}","/** 
 * {@inheritDoc} 
 */
public void layoutWindowLw(WindowState win,WindowManager.LayoutParams attrs,WindowState attached){
  if (win == mStatusBar) {
    return;
  }
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      Log.i(TAG,""String_Node_Str"");
    }
  }
  final int fl=attrs.flags;
  final int sim=attrs.softInputMode;
  final Rect pf=mTmpParentFrame;
  final Rect df=mTmpDisplayFrame;
  final Rect cf=mTmpContentFrame;
  final Rect vf=mTmpVisibleFrame;
  if (attrs.type == TYPE_INPUT_METHOD) {
    pf.left=df.left=cf.left=vf.left=mDockLeft;
    pf.top=df.top=cf.top=vf.top=mDockTop;
    pf.right=df.right=cf.right=vf.right=mDockRight;
    pf.bottom=df.bottom=cf.bottom=vf.bottom=mDockBottom;
    attrs.gravity=Gravity.BOTTOM;
    mDockLayer=win.getSurfaceLayer();
  }
 else {
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
      if (attached != null) {
        setAttachedWindowFrames(win,fl,sim,attached,true,pf,df,cf,vf);
      }
 else {
        pf.left=df.left=0;
        pf.top=df.top=0;
        pf.right=df.right=mW;
        pf.bottom=df.bottom=mH;
        if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
          cf.left=mDockLeft;
          cf.top=mDockTop;
          cf.right=mDockRight;
          cf.bottom=mDockBottom;
        }
 else {
          cf.left=mContentLeft;
          cf.top=mContentTop;
          cf.right=mContentRight;
          cf.bottom=mContentBottom;
        }
        vf.left=mCurLeft;
        vf.top=mCurTop;
        vf.right=mCurRight;
        vf.bottom=mCurBottom;
      }
    }
 else     if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0) {
      pf.left=df.left=cf.left=0;
      pf.top=df.top=cf.top=0;
      pf.right=df.right=cf.right=mW;
      pf.bottom=df.bottom=cf.bottom=mH;
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
 else     if (attached != null) {
      setAttachedWindowFrames(win,fl,sim,attached,false,pf,df,cf,vf);
    }
 else {
      pf.left=mContentLeft;
      pf.top=mContentTop;
      pf.right=mContentRight;
      pf.bottom=mContentBottom;
      if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
        df.left=cf.left=mDockLeft;
        df.top=cf.top=mDockTop;
        df.right=cf.right=mDockRight;
        df.bottom=cf.bottom=mDockBottom;
      }
 else {
        df.left=cf.left=mContentLeft;
        df.top=cf.top=mContentTop;
        df.right=cf.right=mContentRight;
        df.bottom=cf.bottom=mContentBottom;
      }
      vf.left=mCurLeft;
      vf.top=mCurTop;
      vf.right=mCurRight;
      vf.bottom=mCurBottom;
    }
  }
  if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
    df.left=df.top=cf.left=cf.top=vf.left=vf.top=-10000;
    df.right=df.bottom=cf.right=cf.bottom=vf.right=vf.bottom=10000;
  }
  if (DEBUG_LAYOUT)   Log.v(TAG,""String_Node_Str"" + attrs.getTitle() + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
  if (false) {
    if (""String_Node_Str"".equals(attrs.packageName) && attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
      if (true || localLOGV)       Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ Integer.toHexString(sim)+ ""String_Node_Str""+ pf.toShortString()+ ""String_Node_Str""+ df.toShortString()+ ""String_Node_Str""+ cf.toShortString()+ ""String_Node_Str""+ vf.toShortString());
    }
  }
  win.computeFrameLw(pf,df,cf,vf);
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,false,false)) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + win);
      mTopFullscreenOpaqueWindowState=win;
    }
  }
  if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
    int top=win.getContentFrameLw().top;
    top+=win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
      mContentBottom=top;
    }
    top=win.getVisibleFrameLw().top;
    top+=win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
      mCurBottom=top;
    }
    if (DEBUG_LAYOUT)     Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
  }
}",0.8763145861911295
183828,"/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void beginLayoutLw(int displayWidth,int displayHeight){
  mW=displayWidth;
  mH=displayHeight;
  mDockLeft=mContentLeft=mCurLeft=0;
  mDockTop=mContentTop=mCurTop=0;
  mDockRight=mContentRight=mCurRight=displayWidth;
  mDockBottom=mContentBottom=mCurBottom=displayHeight;
  mDockLayer=0x10000000;
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
  if (mStatusBar != null) {
    final Rect pf=mTmpParentFrame;
    final Rect df=mTmpDisplayFrame;
    final Rect vf=mTmpVisibleFrame;
    pf.left=df.left=vf.left=0;
    pf.top=df.top=vf.top=0;
    pf.right=df.right=vf.right=displayWidth;
    pf.bottom=df.bottom=vf.bottom=displayHeight;
    mStatusBar.computeFrameLw(pf,df,vf,vf);
    if (mStatusBar.isVisibleLw()) {
      mDockTop=mContentTop=mCurTop=mStatusBar.getFrameLw().bottom;
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + mDockBottom + ""String_Node_Str""+ mContentBottom+ ""String_Node_Str""+ mCurBottom);
    }
  }
}",0.9658074697527615
183829,"/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
  mTopFullscreenOpaqueWindowState=null;
  mForceStatusBar=false;
}","/** 
 * {@inheritDoc} 
 */
public void beginAnimationLw(int displayWidth,int displayHeight){
}",0.7430830039525692
183830,"/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
  if (win.isVisibleLw()) {
    if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
      mForceStatusBar=true;
    }
 else     if (mTopFullscreenOpaqueWindowState == null && attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type <= LAST_APPLICATION_WINDOW && win.fillsScreenLw(mW,mH,true,false) && win.isVisibleLw()) {
      mTopFullscreenOpaqueWindowState=win;
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public void animatingWindowLw(WindowState win,WindowManager.LayoutParams attrs){
}",0.3694915254237288
183831,"/** 
 * {@inheritDoc} 
 */
public void finishLayoutLw(){
}","/** 
 * {@inheritDoc} 
 */
public boolean finishLayoutLw(){
  boolean changed=false;
  boolean hiding=false;
  if (mStatusBar != null) {
    if (mForceStatusBar) {
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"");
      changed|=mStatusBar.showLw(true);
    }
 else     if (mTopFullscreenOpaqueWindowState != null) {
      WindowManager.LayoutParams lp=mTopFullscreenOpaqueWindowState.getAttrs();
      boolean hideStatusBar=(lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
      if (hideStatusBar) {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.hideLw(true);
        hiding=true;
      }
 else {
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"");
        changed|=mStatusBar.showLw(true);
      }
    }
  }
  if (changed && hiding) {
    IStatusBar sbs=IStatusBar.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
    if (sbs != null) {
      try {
        sbs.deactivate();
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}",0.081008100810081
183832,"@Override public boolean requestChildRectangleOnScreen(View child,Rect rect,boolean immediate){
  rect.offset(child.getLeft() - child.getScrollX(),child.getTop() - child.getScrollY());
  int height=getHeight() - getHorizontalScrollbarHeight();
  int screenTop=mScrollY;
  int screenBottom=screenTop + height;
  int scrollYDelta=0;
  if (rect.bottom > screenBottom && rect.top > screenTop) {
    if (rect.height() > height) {
      scrollYDelta+=(rect.top - screenTop);
    }
 else {
      scrollYDelta+=(rect.bottom - screenBottom);
    }
  }
 else   if (rect.top < screenTop) {
    scrollYDelta-=(screenTop - rect.top);
  }
  int width=getWidth() - getVerticalScrollbarWidth();
  int screenLeft=mScrollX;
  int screenRight=screenLeft + width;
  int scrollXDelta=0;
  if (rect.right > screenRight && rect.left > screenLeft) {
    if (rect.width() > width) {
      scrollXDelta+=(rect.left - screenLeft);
    }
 else {
      scrollXDelta+=(rect.right - screenRight);
    }
  }
 else   if (rect.left < screenLeft) {
    scrollXDelta-=(screenLeft - rect.left);
  }
  if ((scrollYDelta | scrollXDelta) != 0) {
    return pinScrollBy(scrollXDelta,scrollYDelta,!immediate,0);
  }
  return false;
}","@Override public boolean requestChildRectangleOnScreen(View child,Rect rect,boolean immediate){
  rect.offset(child.getLeft() - child.getScrollX(),child.getTop() - child.getScrollY());
  int height=getHeight() - getHorizontalScrollbarHeight();
  int screenTop=mScrollY;
  int screenBottom=screenTop + height;
  int scrollYDelta=0;
  if (rect.bottom > screenBottom) {
    int oneThirdOfScreenHeight=height / 3;
    if (rect.height() > 2 * oneThirdOfScreenHeight) {
      scrollYDelta=rect.top - screenTop;
    }
 else {
      scrollYDelta=rect.top - (screenTop + oneThirdOfScreenHeight);
    }
  }
 else   if (rect.top < screenTop) {
    scrollYDelta=rect.top - screenTop;
  }
  int width=getWidth() - getVerticalScrollbarWidth();
  int screenLeft=mScrollX;
  int screenRight=screenLeft + width;
  int scrollXDelta=0;
  if (rect.right > screenRight && rect.left > screenLeft) {
    if (rect.width() > width) {
      scrollXDelta+=(rect.left - screenLeft);
    }
 else {
      scrollXDelta+=(rect.right - screenRight);
    }
  }
 else   if (rect.left < screenLeft) {
    scrollXDelta-=(screenLeft - rect.left);
  }
  if ((scrollYDelta | scrollXDelta) != 0) {
    return pinScrollBy(scrollXDelta,scrollYDelta,!immediate,0);
  }
  return false;
}",0.3904644471845458
183833,"private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
      mBatteryStats.noteFullWifiLockAcquired(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
    mBatteryStats.noteScanWifiLockAcquired(uid);
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}","private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
      ++mFullLocksAcquired;
    mBatteryStats.noteFullWifiLockAcquired(uid);
  break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
++mScanLocksAcquired;
mBatteryStats.noteScanWifiLockAcquired(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}",0.9217557251908396
183834,"private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
        mBatteryStats.noteFullWifiLockReleased(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
      mBatteryStats.noteScanWifiLockReleased(uid);
  }
}
 catch (RemoteException e) {
}
 finally {
  Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}","private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
        ++mFullLocksReleased;
      mBatteryStats.noteFullWifiLockReleased(uid);
    break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
  ++mScanLocksReleased;
mBatteryStats.noteScanWifiLockReleased(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}",0.927536231884058
183835,"public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    return WifiNative.disconnectCommand();
  }
 else {
    releaseWakeLock();
  }
  return true;
}","/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return WifiNative.stopDriverCommand();
    }
 else {
      return WifiNative.disconnectCommand();
    }
  }
 else {
    releaseWakeLock();
  }
  return true;
}",0.5276190476190477
183836,"@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName).append(""String_Node_Str"").append(mRunState).append(LS);
  sb.append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName);
  sb.append(""String_Node_Str"");
  if (mRunState >= 1 && mRunState <= mRunStateNames.length) {
    sb.append(mRunStateNames[mRunState - 1]);
  }
 else {
    sb.append(mRunState);
  }
  sb.append(LS).append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}",0.8253205128205128
183837,"private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
      mBatteryStats.noteFullWifiLockAcquired(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
    mBatteryStats.noteScanWifiLockAcquired(uid);
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}","private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
      ++mFullLocksAcquired;
    mBatteryStats.noteFullWifiLockAcquired(uid);
  break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
++mScanLocksAcquired;
mBatteryStats.noteScanWifiLockAcquired(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}",0.9217557251908396
183838,"private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
        mBatteryStats.noteFullWifiLockReleased(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
      mBatteryStats.noteScanWifiLockReleased(uid);
  }
}
 catch (RemoteException e) {
}
 finally {
  Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}","private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
        ++mFullLocksReleased;
      mBatteryStats.noteFullWifiLockReleased(uid);
    break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
  ++mScanLocksReleased;
mBatteryStats.noteScanWifiLockReleased(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}",0.927536231884058
183839,"public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    return WifiNative.disconnectCommand();
  }
 else {
    releaseWakeLock();
  }
  return true;
}","/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return WifiNative.stopDriverCommand();
    }
 else {
      return WifiNative.disconnectCommand();
    }
  }
 else {
    releaseWakeLock();
  }
  return true;
}",0.5276190476190477
183840,"@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName).append(""String_Node_Str"").append(mRunState).append(LS);
  sb.append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName);
  sb.append(""String_Node_Str"");
  if (mRunState >= 1 && mRunState <= mRunStateNames.length) {
    sb.append(mRunStateNames[mRunState - 1]);
  }
 else {
    sb.append(mRunState);
  }
  sb.append(LS).append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}",0.8253205128205128
183841,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(0);
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
  boolean updateRotation=false;
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation=true;
    }
  }
  if (updateRotation) {
    updateRotation(0);
  }
}",0.9463198671831764
183842,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(0);
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
  boolean updateRotation=false;
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation=true;
    }
  }
  if (updateRotation) {
    updateRotation(0);
  }
}",0.9463198671831764
183843,"/** 
 * Called when the dependency changes.
 * @param dependency The Preference that this Preference depends on.
 * @param disableDependent Set true to disable this Preference.
 */
public void onDependencyChanged(Preference dependency,boolean disableDependent){
  setEnabled(!disableDependent);
}","/** 
 * Called when the dependency changes.
 * @param dependency The Preference that this Preference depends on.
 * @param disableDependent Set true to disable this Preference.
 */
public void onDependencyChanged(Preference dependency,boolean disableDependent){
  if (mDependencyMet == disableDependent) {
    mDependencyMet=!disableDependent;
    notifyDependencyChange(shouldDisableDependents());
    notifyChanged();
  }
}",0.7933425797503467
183844,"/** 
 * Checks whether this Preference should be enabled in the list.
 * @return True if this Preference is enabled, false otherwise.
 */
public boolean isEnabled(){
  return mEnabled;
}","/** 
 * Checks whether this Preference should be enabled in the list.
 * @return True if this Preference is enabled, false otherwise.
 */
public boolean isEnabled(){
  return mEnabled && mDependencyMet;
}",0.953846153846154
183845,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(0);
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
  boolean updateRotation=false;
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation=true;
    }
  }
  if (updateRotation) {
    updateRotation(0);
  }
}",0.9463198671831764
183846,"void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,animFlags);
  }
 catch (  RemoteException e) {
  }
}","void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,mFancyRotationAnimation | animFlags);
  }
 catch (  RemoteException e) {
  }
}",0.95578231292517
183847,"/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(0);
}","/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.824
183848,"@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,1);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,mFancyRotationAnimation);
  }
 catch (  RemoteException e) {
  }
}",0.934065934065934
183849,"/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(0);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}",0.9667170953101362
183850,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(1);
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(0);
    }
  }
}",0.9894490035169988
183851,"@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,1);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,mFancyRotationAnimation);
  }
 catch (  RemoteException e) {
  }
}",0.945945945945946
183852,"void observe(){
  ContentResolver resolver=mContext.getContentResolver();
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION),false,this);
  resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD),false,this);
  update();
}","void observe(){
  ContentResolver resolver=mContext.getContentResolver();
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION),false,this);
  resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(""String_Node_Str""),false,this);
  update();
}",0.9011689691817216
183853,"void updateRotation(){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true);
  }
 catch (  RemoteException e) {
  }
}","void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,animFlags);
  }
 catch (  RemoteException e) {
  }
}",0.9573283858998144
183854,"/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation();
}","/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(0);
}",0.9951690821256038
183855,"@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,1);
  }
 catch (  RemoteException e) {
  }
}",0.9941176470588236
183856,"/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation();
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(0);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}",0.9992181391712276
183857,"public int rotationForOrientationLw(int orientation,int lastRotation,boolean displayEnabled){
synchronized (mLock) {
switch (orientation) {
case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
      return Surface.ROTATION_90;
case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
    return Surface.ROTATION_0;
}
if (mLidOpen) {
  return Surface.ROTATION_90;
}
 else {
  if (useSensorForOrientationLp()) {
    return mSensorRotation >= 0 ? mSensorRotation : lastRotation;
  }
  return Surface.ROTATION_0;
}
}
}","public int rotationForOrientationLw(int orientation,int lastRotation,boolean displayEnabled){
synchronized (mLock) {
switch (orientation) {
case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
      return Surface.ROTATION_90;
case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
    return Surface.ROTATION_0;
}
if (mLidOpen) {
  return Surface.ROTATION_90;
}
 else {
  if (useSensorForOrientationLp(orientation)) {
    int curRotation=mOrientationListener.getCurrentRotation();
    return curRotation >= 0 ? curRotation : lastRotation;
  }
  return Surface.ROTATION_0;
}
}
}",0.9041353383458648
183858,"void updateOrientationListenerLp(){
  if (!mOrientationListener.canDetectOrientation()) {
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + mScreenOn + ""String_Node_Str""+ mCurrentAppOrientation+ ""String_Node_Str""+ mOrientationSensorEnabled);
  boolean disable=true;
  if (mScreenOn) {
    if (needSensorRunningLp()) {
      disable=false;
      if (!mOrientationSensorEnabled) {
        mOrientationListener.enable();
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        mSensorRotation=-1;
        mOrientationSensorEnabled=true;
      }
    }
  }
  if (disable && mOrientationSensorEnabled) {
    mOrientationListener.disable();
    if (localLOGV)     Log.i(TAG,""String_Node_Str"");
    mSensorRotation=-1;
    mOrientationSensorEnabled=false;
  }
}","void updateOrientationListenerLp(){
  if (!mOrientationListener.canDetectOrientation()) {
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + mScreenOn + ""String_Node_Str""+ mCurrentAppOrientation+ ""String_Node_Str""+ mOrientationSensorEnabled);
  boolean disable=true;
  if (mScreenOn) {
    if (needSensorRunningLp()) {
      disable=false;
      if (!mOrientationSensorEnabled) {
        mOrientationListener.enable();
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        mOrientationSensorEnabled=true;
      }
    }
  }
  if (disable && mOrientationSensorEnabled) {
    mOrientationListener.disable();
    if (localLOGV)     Log.i(TAG,""String_Node_Str"");
    mOrientationSensorEnabled=false;
  }
}",0.933774834437086
183859,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation();
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(1);
    }
  }
}",0.9483509645301804
183860,"boolean useSensorForOrientationLp(){
  if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR) {
    return true;
  }
  if (mAccelerometerDefault != 0 && (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_USER || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)) {
    return true;
  }
  return false;
}","boolean useSensorForOrientationLp(int appOrientation){
  if (appOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR) {
    return true;
  }
  if (mAccelerometerDefault != 0 && (appOrientation == ActivityInfo.SCREEN_ORIENTATION_USER || appOrientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)) {
    return true;
  }
  return false;
}",0.9302325581395348
183861,"@Override public void onOrientationChanged(int rotation){
  if (rotation != mSensorRotation) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mSensorRotation);
    mSensorRotation=rotation;
    try {
      mWindowManager.setRotation(rotation,false);
    }
 catch (    RemoteException e) {
    }
  }
}","@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,1);
  }
 catch (  RemoteException e) {
  }
}",0.7458866544789763
183862,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,0);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9712007089056268
183863,"public boolean setRotationUncheckedLocked(int rotation,int animFlags){
  boolean changed;
  if (rotation == WindowManagerPolicy.USE_LAST_ROTATION) {
    rotation=mRequestedRotation;
  }
 else {
    mRequestedRotation=rotation;
  }
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  rotation=mPolicy.rotationForOrientationLw(mForcedAppOrientation,mRotation,mDisplayEnabled);
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  changed=mDisplayEnabled && mRotation != rotation;
  if (changed) {
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mRotation+ ""String_Node_Str""+ mForcedAppOrientation+ ""String_Node_Str""+ mRequestedRotation+ ""String_Node_Str"");
    mRotation=rotation;
    mWindowsFreezingScreen=true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
    startFreezingDisplayLocked();
    Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ animFlags);
    mQueue.setOrientation(rotation);
    if (mDisplayEnabled) {
      Surface.setOrientation(0,rotation);
    }
    for (int i=mWindows.size() - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.mSurface != null) {
        w.mOrientationChanging=true;
      }
    }
    for (int i=mRotationWatchers.size() - 1; i >= 0; i--) {
      try {
        mRotationWatchers.get(i).onRotationChanged(rotation);
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}","public boolean setRotationUncheckedLocked(int rotation,int animFlags){
  boolean changed;
  if (rotation == WindowManagerPolicy.USE_LAST_ROTATION) {
    rotation=mRequestedRotation;
  }
 else {
    mRequestedRotation=rotation;
    mLastRotationFlags=animFlags;
  }
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  rotation=mPolicy.rotationForOrientationLw(mForcedAppOrientation,mRotation,mDisplayEnabled);
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  changed=mDisplayEnabled && mRotation != rotation;
  if (changed) {
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mRotation+ ""String_Node_Str""+ mForcedAppOrientation+ ""String_Node_Str""+ mRequestedRotation+ ""String_Node_Str"");
    mRotation=rotation;
    mWindowsFreezingScreen=true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
    startFreezingDisplayLocked();
    Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ animFlags);
    mQueue.setOrientation(rotation);
    if (mDisplayEnabled) {
      Surface.setOrientation(0,rotation,animFlags);
    }
    for (int i=mWindows.size() - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.mSurface != null) {
        w.mOrientationChanging=true;
      }
    }
    for (int i=mRotationWatchers.size() - 1; i >= 0; i--) {
      try {
        mRotationWatchers.get(i).onRotationChanged(rotation);
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}",0.9858520900321543
183864,"Configuration updateOrientationFromAppTokensLocked(Configuration appConfig,IBinder freezeThisOneIfNeeded){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      changed=true;
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
    }
    if (changed) {
      changed=setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,1);
      if (changed) {
        if (freezeThisOneIfNeeded != null) {
          AppWindowToken wtoken=findAppWindowToken(freezeThisOneIfNeeded);
          if (wtoken != null) {
            startAppFreezingScreenLocked(wtoken,ActivityInfo.CONFIG_ORIENTATION);
          }
        }
        return computeNewConfigurationLocked();
      }
    }
    if (appConfig != null) {
      mTempConfiguration.setToDefaults();
      if (computeNewConfigurationLocked(mTempConfiguration)) {
        if (appConfig.diff(mTempConfiguration) != 0) {
          Log.i(TAG,""String_Node_Str"" + mTempConfiguration);
          return new Configuration(mTempConfiguration);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return null;
}","Configuration updateOrientationFromAppTokensLocked(Configuration appConfig,IBinder freezeThisOneIfNeeded){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      changed=true;
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
    }
    if (changed) {
      changed=setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags & (~Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE));
      if (changed) {
        if (freezeThisOneIfNeeded != null) {
          AppWindowToken wtoken=findAppWindowToken(freezeThisOneIfNeeded);
          if (wtoken != null) {
            startAppFreezingScreenLocked(wtoken,ActivityInfo.CONFIG_ORIENTATION);
          }
        }
        return computeNewConfigurationLocked();
      }
    }
    if (appConfig != null) {
      mTempConfiguration.setToDefaults();
      if (computeNewConfigurationLocked(mTempConfiguration)) {
        if (appConfig.diff(mTempConfiguration) != 0) {
          Log.i(TAG,""String_Node_Str"" + mTempConfiguration);
          return new Configuration(mTempConfiguration);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return null;
}",0.972972972972973
183865,"public void onSensorChanged(SensorEvent event){
  float[] values=event.values;
  float X=values[_DATA_X];
  float Y=values[_DATA_Y];
  float Z=values[_DATA_Z];
  float OneEightyOverPi=57.29577957855f;
  float gravity=(float)Math.sqrt(X * X + Y * Y + Z * Z);
  float zyangle=(float)Math.asin(Z / gravity) * OneEightyOverPi;
  int rotation=mSensorRotation;
  if ((zyangle <= PIVOT_UPPER) && (zyangle >= PIVOT_LOWER)) {
    float angle=(float)Math.atan2(Y,-X) * OneEightyOverPi;
    int orientation=90 - (int)Math.round(angle);
    while (orientation >= 360) {
      orientation-=360;
    }
    while (orientation < 0) {
      orientation+=360;
    }
    float delta=zyangle - PIVOT;
    if (((orientation >= 0) && (orientation <= LP_UPPER)) || (orientation >= PL_LOWER)) {
      float threshold;
      if (mSensorRotation == Surface.ROTATION_90) {
        if (delta < 0) {
          threshold=LP_LOWER - (LP_LF_LOWER * delta);
        }
 else {
          threshold=LP_LOWER + (LP_LF_UPPER * delta);
        }
      }
 else {
        if (delta < 0) {
          threshold=PL_UPPER + (PL_LF_LOWER * delta);
        }
 else {
          threshold=PL_UPPER - (PL_LF_UPPER * delta);
        }
      }
      rotation=(orientation >= PL_LOWER && orientation <= threshold) ? Surface.ROTATION_90 : Surface.ROTATION_0;
    }
  }
  if (rotation != mSensorRotation) {
    mSensorRotation=rotation;
    onOrientationChanged(mSensorRotation);
  }
}","public void onSensorChanged(SensorEvent event){
  float[] values=event.values;
  float X=values[_DATA_X];
  float Y=values[_DATA_Y];
  float Z=values[_DATA_Z];
  float OneEightyOverPi=57.29577957855f;
  float gravity=(float)Math.sqrt(X * X + Y * Y + Z * Z);
  float zyangle=(float)Math.asin(Z / gravity) * OneEightyOverPi;
  int rotation=-1;
  if ((zyangle <= PIVOT_UPPER) && (zyangle >= PIVOT_LOWER)) {
    float angle=(float)Math.atan2(Y,-X) * OneEightyOverPi;
    int orientation=90 - (int)Math.round(angle);
    while (orientation >= 360) {
      orientation-=360;
    }
    while (orientation < 0) {
      orientation+=360;
    }
    if ((orientation >= PL_LOWER) && (orientation <= LP_UPPER)) {
      float threshold;
      float delta=zyangle - PIVOT;
      if (mSensorRotation == Surface.ROTATION_90) {
        if (delta < 0) {
          threshold=LP_LOWER - (LP_LF_LOWER * delta);
        }
 else {
          threshold=LP_LOWER + (LP_LF_UPPER * delta);
        }
        rotation=(orientation >= threshold) ? Surface.ROTATION_0 : Surface.ROTATION_90;
      }
 else {
        if (delta < 0) {
          threshold=PL_UPPER + (PL_LF_LOWER * delta);
        }
 else {
          threshold=PL_UPPER - (PL_LF_UPPER * delta);
        }
        rotation=(orientation <= threshold) ? Surface.ROTATION_90 : Surface.ROTATION_0;
      }
    }
 else     if ((orientation >= LANDSCAPE_LOWER) && (orientation < LP_LOWER)) {
      rotation=Surface.ROTATION_90;
    }
 else     if ((orientation >= PL_UPPER) || (orientation <= PORTRAIT_LOWER)) {
      rotation=Surface.ROTATION_0;
    }
    if ((rotation != -1) && (rotation != mSensorRotation)) {
      mSensorRotation=rotation;
      onOrientationChanged(mSensorRotation);
    }
  }
}",0.5112448527082674
183866,"void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,animFlags);
  }
 catch (  RemoteException e) {
  }
}","void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,mFancyRotationAnimation | animFlags);
  }
 catch (  RemoteException e) {
  }
}",0.95578231292517
183867,"/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(0);
}","/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.824
183868,"@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,1);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,mFancyRotationAnimation);
  }
 catch (  RemoteException e) {
  }
}",0.934065934065934
183869,"/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(0);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}",0.9667170953101362
183870,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(1);
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0) != 0 ? 0x80 : 0;
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(0);
    }
  }
}",0.9894490035169988
183871,"@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,1);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,mFancyRotationAnimation);
  }
 catch (  RemoteException e) {
  }
}",0.945945945945946
183872,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,0);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}",0.9712007089056268
183873,"public boolean setRotationUncheckedLocked(int rotation,int animFlags){
  boolean changed;
  if (rotation == WindowManagerPolicy.USE_LAST_ROTATION) {
    rotation=mRequestedRotation;
  }
 else {
    mRequestedRotation=rotation;
  }
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  rotation=mPolicy.rotationForOrientationLw(mForcedAppOrientation,mRotation,mDisplayEnabled);
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  changed=mDisplayEnabled && mRotation != rotation;
  if (changed) {
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mRotation+ ""String_Node_Str""+ mForcedAppOrientation+ ""String_Node_Str""+ mRequestedRotation+ ""String_Node_Str"");
    mRotation=rotation;
    mWindowsFreezingScreen=true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
    startFreezingDisplayLocked();
    Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ animFlags);
    mQueue.setOrientation(rotation);
    if (mDisplayEnabled) {
      Surface.setOrientation(0,rotation);
    }
    for (int i=mWindows.size() - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.mSurface != null) {
        w.mOrientationChanging=true;
      }
    }
    for (int i=mRotationWatchers.size() - 1; i >= 0; i--) {
      try {
        mRotationWatchers.get(i).onRotationChanged(rotation);
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}","public boolean setRotationUncheckedLocked(int rotation,int animFlags){
  boolean changed;
  if (rotation == WindowManagerPolicy.USE_LAST_ROTATION) {
    rotation=mRequestedRotation;
  }
 else {
    mRequestedRotation=rotation;
    mLastRotationFlags=animFlags;
  }
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  rotation=mPolicy.rotationForOrientationLw(mForcedAppOrientation,mRotation,mDisplayEnabled);
  if (DEBUG_ORIENTATION)   Log.v(TAG,""String_Node_Str"" + rotation);
  changed=mDisplayEnabled && mRotation != rotation;
  if (changed) {
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mRotation+ ""String_Node_Str""+ mForcedAppOrientation+ ""String_Node_Str""+ mRequestedRotation+ ""String_Node_Str"");
    mRotation=rotation;
    mWindowsFreezingScreen=true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
    startFreezingDisplayLocked();
    Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ animFlags);
    mQueue.setOrientation(rotation);
    if (mDisplayEnabled) {
      Surface.setOrientation(0,rotation,animFlags);
    }
    for (int i=mWindows.size() - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.mSurface != null) {
        w.mOrientationChanging=true;
      }
    }
    for (int i=mRotationWatchers.size() - 1; i >= 0; i--) {
      try {
        mRotationWatchers.get(i).onRotationChanged(rotation);
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}",0.9858520900321543
183874,"Configuration updateOrientationFromAppTokensLocked(Configuration appConfig,IBinder freezeThisOneIfNeeded){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      changed=true;
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
    }
    if (changed) {
      changed=setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,1);
      if (changed) {
        if (freezeThisOneIfNeeded != null) {
          AppWindowToken wtoken=findAppWindowToken(freezeThisOneIfNeeded);
          if (wtoken != null) {
            startAppFreezingScreenLocked(wtoken,ActivityInfo.CONFIG_ORIENTATION);
          }
        }
        return computeNewConfigurationLocked();
      }
    }
    if (appConfig != null) {
      mTempConfiguration.setToDefaults();
      if (computeNewConfigurationLocked(mTempConfiguration)) {
        if (appConfig.diff(mTempConfiguration) != 0) {
          Log.i(TAG,""String_Node_Str"" + mTempConfiguration);
          return new Configuration(mTempConfiguration);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return null;
}","Configuration updateOrientationFromAppTokensLocked(Configuration appConfig,IBinder freezeThisOneIfNeeded){
  boolean changed=false;
  long ident=Binder.clearCallingIdentity();
  try {
    int req=computeForcedAppOrientationLocked();
    if (req != mForcedAppOrientation) {
      changed=true;
      mForcedAppOrientation=req;
      mPolicy.setCurrentOrientationLw(req);
    }
    if (changed) {
      changed=setRotationUncheckedLocked(WindowManagerPolicy.USE_LAST_ROTATION,mLastRotationFlags & (~Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE));
      if (changed) {
        if (freezeThisOneIfNeeded != null) {
          AppWindowToken wtoken=findAppWindowToken(freezeThisOneIfNeeded);
          if (wtoken != null) {
            startAppFreezingScreenLocked(wtoken,ActivityInfo.CONFIG_ORIENTATION);
          }
        }
        return computeNewConfigurationLocked();
      }
    }
    if (appConfig != null) {
      mTempConfiguration.setToDefaults();
      if (computeNewConfigurationLocked(mTempConfiguration)) {
        if (appConfig.diff(mTempConfiguration) != 0) {
          Log.i(TAG,""String_Node_Str"" + mTempConfiguration);
          return new Configuration(mTempConfiguration);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  return null;
}",0.972972972972973
183875,"public void onSensorChanged(SensorEvent event){
  float[] values=event.values;
  float X=values[_DATA_X];
  float Y=values[_DATA_Y];
  float Z=values[_DATA_Z];
  float OneEightyOverPi=57.29577957855f;
  float gravity=(float)Math.sqrt(X * X + Y * Y + Z * Z);
  float zyangle=(float)Math.asin(Z / gravity) * OneEightyOverPi;
  int rotation=mSensorRotation;
  if ((zyangle <= PIVOT_UPPER) && (zyangle >= PIVOT_LOWER)) {
    float angle=(float)Math.atan2(Y,-X) * OneEightyOverPi;
    int orientation=90 - (int)Math.round(angle);
    while (orientation >= 360) {
      orientation-=360;
    }
    while (orientation < 0) {
      orientation+=360;
    }
    float delta=zyangle - PIVOT;
    if (((orientation >= 0) && (orientation <= LP_UPPER)) || (orientation >= PL_LOWER)) {
      float threshold;
      if (mSensorRotation == Surface.ROTATION_90) {
        if (delta < 0) {
          threshold=LP_LOWER - (LP_LF_LOWER * delta);
        }
 else {
          threshold=LP_LOWER + (LP_LF_UPPER * delta);
        }
      }
 else {
        if (delta < 0) {
          threshold=PL_UPPER + (PL_LF_LOWER * delta);
        }
 else {
          threshold=PL_UPPER - (PL_LF_UPPER * delta);
        }
      }
      rotation=(orientation >= PL_LOWER && orientation <= threshold) ? Surface.ROTATION_90 : Surface.ROTATION_0;
    }
  }
  if (rotation != mSensorRotation) {
    mSensorRotation=rotation;
    onOrientationChanged(mSensorRotation);
  }
}","public void onSensorChanged(SensorEvent event){
  float[] values=event.values;
  float X=values[_DATA_X];
  float Y=values[_DATA_Y];
  float Z=values[_DATA_Z];
  float OneEightyOverPi=57.29577957855f;
  float gravity=(float)Math.sqrt(X * X + Y * Y + Z * Z);
  float zyangle=(float)Math.asin(Z / gravity) * OneEightyOverPi;
  int rotation=-1;
  if ((zyangle <= PIVOT_UPPER) && (zyangle >= PIVOT_LOWER)) {
    float angle=(float)Math.atan2(Y,-X) * OneEightyOverPi;
    int orientation=90 - (int)Math.round(angle);
    while (orientation >= 360) {
      orientation-=360;
    }
    while (orientation < 0) {
      orientation+=360;
    }
    if ((orientation >= PL_LOWER) && (orientation <= LP_UPPER)) {
      float threshold;
      float delta=zyangle - PIVOT;
      if (mSensorRotation == Surface.ROTATION_90) {
        if (delta < 0) {
          threshold=LP_LOWER - (LP_LF_LOWER * delta);
        }
 else {
          threshold=LP_LOWER + (LP_LF_UPPER * delta);
        }
        rotation=(orientation >= threshold) ? Surface.ROTATION_0 : Surface.ROTATION_90;
      }
 else {
        if (delta < 0) {
          threshold=PL_UPPER + (PL_LF_LOWER * delta);
        }
 else {
          threshold=PL_UPPER - (PL_LF_UPPER * delta);
        }
        rotation=(orientation <= threshold) ? Surface.ROTATION_90 : Surface.ROTATION_0;
      }
    }
 else     if ((orientation >= LANDSCAPE_LOWER) && (orientation < LP_LOWER)) {
      rotation=Surface.ROTATION_90;
    }
 else     if ((orientation >= PL_UPPER) || (orientation <= PORTRAIT_LOWER)) {
      rotation=Surface.ROTATION_0;
    }
    if ((rotation != -1) && (rotation != mSensorRotation)) {
      mSensorRotation=rotation;
      onOrientationChanged(mSensorRotation);
    }
  }
}",0.5112448527082674
183876,"void observe(){
  ContentResolver resolver=mContext.getContentResolver();
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION),false,this);
  resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD),false,this);
  update();
}","void observe(){
  ContentResolver resolver=mContext.getContentResolver();
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION),false,this);
  resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD),false,this);
  resolver.registerContentObserver(Settings.System.getUriFor(""String_Node_Str""),false,this);
  update();
}",0.9011689691817216
183877,"void updateRotation(){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true);
  }
 catch (  RemoteException e) {
  }
}","void updateRotation(int animFlags){
  mPowerManager.setKeyboardVisibility(mLidOpen);
  int rotation=Surface.ROTATION_0;
  if (mLidOpen) {
    rotation=Surface.ROTATION_90;
  }
  try {
    mWindowManager.setRotation(rotation,true,animFlags);
  }
 catch (  RemoteException e) {
  }
}",0.9573283858998144
183878,"/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation();
}","/** 
 * {@inheritDoc} 
 */
public void enableScreenAfterBoot(){
  readLidState();
  updateRotation(0);
}",0.9951690821256038
183879,"@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false);
  }
 catch (  RemoteException e) {
  }
}","@Override public void onChange(boolean selfChange){
  update();
  try {
    mWindowManager.setRotation(USE_LAST_ROTATION,false,1);
  }
 catch (  RemoteException e) {
  }
}",0.9941176470588236
183880,"/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation();
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean preprocessInputEventTq(RawInputEvent event){
switch (event.type) {
case RawInputEvent.EV_SW:
    if (event.keycode == 0) {
      mLidOpen=event.value == 0;
      updateRotation(0);
      if (keyguardIsShowingTq()) {
        if (mLidOpen) {
          mKeyguardMediator.pokeWakelock();
        }
      }
 else {
        if (mLidOpen) {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT);
        }
 else {
          mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.OTHER_EVENT);
        }
      }
    }
}
return false;
}",0.9992181391712276
183881,"public int rotationForOrientationLw(int orientation,int lastRotation,boolean displayEnabled){
synchronized (mLock) {
switch (orientation) {
case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
      return Surface.ROTATION_90;
case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
    return Surface.ROTATION_0;
}
if (mLidOpen) {
  return Surface.ROTATION_90;
}
 else {
  if (useSensorForOrientationLp()) {
    return mSensorRotation >= 0 ? mSensorRotation : lastRotation;
  }
  return Surface.ROTATION_0;
}
}
}","public int rotationForOrientationLw(int orientation,int lastRotation,boolean displayEnabled){
synchronized (mLock) {
switch (orientation) {
case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
      return Surface.ROTATION_90;
case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
    return Surface.ROTATION_0;
}
if (mLidOpen) {
  return Surface.ROTATION_90;
}
 else {
  if (useSensorForOrientationLp(orientation)) {
    int curRotation=mOrientationListener.getCurrentRotation();
    return curRotation >= 0 ? curRotation : lastRotation;
  }
  return Surface.ROTATION_0;
}
}
}",0.9041353383458648
183882,"void updateOrientationListenerLp(){
  if (!mOrientationListener.canDetectOrientation()) {
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + mScreenOn + ""String_Node_Str""+ mCurrentAppOrientation+ ""String_Node_Str""+ mOrientationSensorEnabled);
  boolean disable=true;
  if (mScreenOn) {
    if (needSensorRunningLp()) {
      disable=false;
      if (!mOrientationSensorEnabled) {
        mOrientationListener.enable();
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        mSensorRotation=-1;
        mOrientationSensorEnabled=true;
      }
    }
  }
  if (disable && mOrientationSensorEnabled) {
    mOrientationListener.disable();
    if (localLOGV)     Log.i(TAG,""String_Node_Str"");
    mSensorRotation=-1;
    mOrientationSensorEnabled=false;
  }
}","void updateOrientationListenerLp(){
  if (!mOrientationListener.canDetectOrientation()) {
    return;
  }
  if (localLOGV)   Log.i(TAG,""String_Node_Str"" + mScreenOn + ""String_Node_Str""+ mCurrentAppOrientation+ ""String_Node_Str""+ mOrientationSensorEnabled);
  boolean disable=true;
  if (mScreenOn) {
    if (needSensorRunningLp()) {
      disable=false;
      if (!mOrientationSensorEnabled) {
        mOrientationListener.enable();
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        mOrientationSensorEnabled=true;
      }
    }
  }
  if (disable && mOrientationSensorEnabled) {
    mOrientationListener.disable();
    if (localLOGV)     Log.i(TAG,""String_Node_Str"");
    mOrientationSensorEnabled=false;
  }
}",0.933774834437086
183883,"public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation();
    }
  }
}","public void update(){
  ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    mEndcallBehavior=Settings.System.getInt(resolver,Settings.System.END_BUTTON_BEHAVIOR,DEFAULT_ENDCALL_BEHAVIOR);
    mFancyRotationAnimation=Settings.System.getInt(resolver,""String_Node_Str"",0);
    int accelerometerDefault=Settings.System.getInt(resolver,Settings.System.ACCELEROMETER_ROTATION,DEFAULT_ACCELEROMETER_ROTATION);
    if (mAccelerometerDefault != accelerometerDefault) {
      mAccelerometerDefault=accelerometerDefault;
      updateOrientationListenerLp();
    }
    String imId=Settings.Secure.getString(resolver,Settings.Secure.DEFAULT_INPUT_METHOD);
    boolean hasSoftInput=imId != null && imId.length() > 0;
    if (mHasSoftInput != hasSoftInput) {
      mHasSoftInput=hasSoftInput;
      updateRotation(1);
    }
  }
}",0.9483509645301804
183884,"boolean useSensorForOrientationLp(){
  if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR) {
    return true;
  }
  if (mAccelerometerDefault != 0 && (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_USER || mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)) {
    return true;
  }
  return false;
}","boolean useSensorForOrientationLp(int appOrientation){
  if (appOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR) {
    return true;
  }
  if (mAccelerometerDefault != 0 && (appOrientation == ActivityInfo.SCREEN_ORIENTATION_USER || appOrientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)) {
    return true;
  }
  return false;
}",0.9302325581395348
183885,"@Override public void onOrientationChanged(int rotation){
  if (rotation != mSensorRotation) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + rotation + ""String_Node_Str""+ mSensorRotation);
    mSensorRotation=rotation;
    try {
      mWindowManager.setRotation(rotation,false);
    }
 catch (    RemoteException e) {
    }
  }
}","@Override public void onOrientationChanged(int rotation){
  if (true)   Log.i(TAG,""String_Node_Str"" + rotation);
  try {
    mWindowManager.setRotation(rotation,false,1);
  }
 catch (  RemoteException e) {
  }
}",0.7458866544789763
183886,"/** 
 * Called when the dependency changes.
 * @param dependency The Preference that this Preference depends on.
 * @param disableDependent Set true to disable this Preference.
 */
public void onDependencyChanged(Preference dependency,boolean disableDependent){
  setEnabled(!disableDependent);
}","/** 
 * Called when the dependency changes.
 * @param dependency The Preference that this Preference depends on.
 * @param disableDependent Set true to disable this Preference.
 */
public void onDependencyChanged(Preference dependency,boolean disableDependent){
  if (mDependencyMet == disableDependent) {
    mDependencyMet=!disableDependent;
    notifyDependencyChange(shouldDisableDependents());
    notifyChanged();
  }
}",0.7933425797503467
183887,"/** 
 * Checks whether this Preference should be enabled in the list.
 * @return True if this Preference is enabled, false otherwise.
 */
public boolean isEnabled(){
  return mEnabled;
}","/** 
 * Checks whether this Preference should be enabled in the list.
 * @return True if this Preference is enabled, false otherwise.
 */
public boolean isEnabled(){
  return mEnabled && mDependencyMet;
}",0.953846153846154
183888,"private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
      mBatteryStats.noteFullWifiLockAcquired(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
    mBatteryStats.noteScanWifiLockAcquired(uid);
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}","private boolean acquireWifiLockLocked(WifiLock wifiLock){
  mLocks.addLock(wifiLock);
  int uid=Binder.getCallingUid();
  long ident=Binder.clearCallingIdentity();
  try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
      ++mFullLocksAcquired;
    mBatteryStats.noteFullWifiLockAcquired(uid);
  break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
++mScanLocksAcquired;
mBatteryStats.noteScanWifiLockAcquired(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
updateWifiState();
return true;
}",0.9217557251908396
183889,"private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case (WifiManager.WIFI_MODE_FULL):
        mBatteryStats.noteFullWifiLockReleased(uid);
case (WifiManager.WIFI_MODE_SCAN_ONLY):
      mBatteryStats.noteScanWifiLockReleased(uid);
  }
}
 catch (RemoteException e) {
}
 finally {
  Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}","private boolean releaseWifiLockLocked(IBinder lock){
  boolean hadLock;
  WifiLock wifiLock=mLocks.removeLock(lock);
  hadLock=(wifiLock != null);
  if (hadLock) {
    int uid=Binder.getCallingUid();
    long ident=Binder.clearCallingIdentity();
    try {
switch (wifiLock.mLockMode) {
case WifiManager.WIFI_MODE_FULL:
        ++mFullLocksReleased;
      mBatteryStats.noteFullWifiLockReleased(uid);
    break;
case WifiManager.WIFI_MODE_SCAN_ONLY:
  ++mScanLocksReleased;
mBatteryStats.noteScanWifiLockReleased(uid);
break;
}
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(ident);
}
}
updateWifiState();
return hadLock;
}",0.927536231884058
183890,"public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    return WifiNative.disconnectCommand();
  }
 else {
    releaseWakeLock();
  }
  return true;
}","/** 
 * We want to stop the driver, but if we're connected to a network, we first want to disconnect, so that the supplicant is always in a known state (DISCONNECTED) when the driver is stopped.
 * @return {@code true} if the operation succeeds, which means that thedisconnect or stop command was initiated.
 */
public synchronized boolean disconnectAndStop(){
  if (mRunState != RUN_STATE_STOPPING && mRunState != RUN_STATE_STOPPED) {
    setNotificationVisible(false,0,false,0);
    mRunState=RUN_STATE_STOPPING;
    if (mWifiInfo.getSupplicantState() == SupplicantState.DORMANT) {
      return WifiNative.stopDriverCommand();
    }
 else {
      return WifiNative.disconnectCommand();
    }
  }
 else {
    releaseWakeLock();
  }
  return true;
}",0.5276190476190477
183891,"@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName).append(""String_Node_Str"").append(mRunState).append(LS);
  sb.append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}","@Override public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"").append(mInterfaceName);
  sb.append(""String_Node_Str"");
  if (mRunState >= 1 && mRunState <= mRunStateNames.length) {
    sb.append(mRunStateNames[mRunState - 1]);
  }
 else {
    sb.append(mRunState);
  }
  sb.append(LS).append(mWifiInfo).append(LS);
  sb.append(mDhcpInfo).append(LS);
  sb.append(""String_Node_Str"").append(mHaveIPAddress).append(""String_Node_Str"").append(mObtainingIPAddress).append(""String_Node_Str"").append(mIsScanModeActive).append(LS).append(""String_Node_Str"").append(mLastSignalLevel).append(""String_Node_Str"").append(mTornDownByConnMgr);
  return sb.toString();
}",0.8253205128205128
183892,"/** 
 * Construct a SELECT statement suitable for use in a group of SELECT statements that will be joined through UNION operators in buildUnionQuery.
 * @param projectionIn A list of which columns to return. Passingnull will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,formatted as an SQL WHERE clause (excluding the WHERE itself).  Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, whichwill be replaced by the values from selectionArgs, in order that they appear in the selection.  The values will be bound as Strings.
 * @param groupBy A filter declaring how to group rows, formattedas an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include inthe cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself).  Passing null will cause all row groups to be included, and is required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQLORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the resulting SQL SELECT statement
 */
public String buildQuery(String[] projectionIn,String selection,String[] selectionArgs,String groupBy,String having,String sortOrder,String limit){
  String[] projection=computeProjection(projectionIn);
  if (mWhereClause.length() > 0) {
    mWhereClause.append(')');
  }
  if (selection != null && selection.length() > 0) {
    if (mWhereClause.length() > 0) {
      mWhereClause.append(""String_Node_Str"");
    }
    mWhereClause.append('(');
    mWhereClause.append(selection);
    mWhereClause.append(')');
  }
  return buildQueryString(mDistinct,mTables,projection,mWhereClause.toString(),groupBy,having,sortOrder,limit);
}","/** 
 * Construct a SELECT statement suitable for use in a group of SELECT statements that will be joined through UNION operators in buildUnionQuery.
 * @param projectionIn A list of which columns to return. Passingnull will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
 * @param selection A filter declaring which rows to return,formatted as an SQL WHERE clause (excluding the WHERE itself).  Passing null will return all rows for the given URL.
 * @param selectionArgs You may include ?s in selection, whichwill be replaced by the values from selectionArgs, in order that they appear in the selection.  The values will be bound as Strings.
 * @param groupBy A filter declaring how to group rows, formattedas an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
 * @param having A filter declare which row groups to include inthe cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself).  Passing null will cause all row groups to be included, and is required when row grouping is not being used.
 * @param sortOrder How to order the rows, formatted as an SQLORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
 * @param limit Limits the number of rows returned by the query,formatted as LIMIT clause. Passing null denotes no LIMIT clause.
 * @return the resulting SQL SELECT statement
 */
public String buildQuery(String[] projectionIn,String selection,String[] selectionArgs,String groupBy,String having,String sortOrder,String limit){
  String[] projection=computeProjection(projectionIn);
  StringBuilder where=new StringBuilder();
  if (mWhereClause.length() > 0) {
    where.append(mWhereClause.toString());
    where.append(')');
  }
  if (selection != null && selection.length() > 0) {
    if (mWhereClause.length() > 0) {
      where.append(""String_Node_Str"");
    }
    where.append('(');
    where.append(selection);
    where.append(')');
  }
  return buildQueryString(mDistinct,mTables,projection,where.toString(),groupBy,having,sortOrder,limit);
}",0.964516129032258
183893,"public void dispatchKey(KeyEvent event){
  if (mSession != null && mSurface != null) {
    try {
      mSession.finishKey(mWindow);
    }
 catch (    RemoteException ex) {
    }
  }
}","public void dispatchKey(KeyEvent event){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (surfaceView.mSession != null && surfaceView.mSurface != null) {
      try {
        surfaceView.mSession.finishKey(surfaceView.mWindow);
      }
 catch (      RemoteException ex) {
      }
    }
  }
}",0.6469428007889546
183894,"public void dispatchGetNewSurface(){
  Message msg=mHandler.obtainMessage(GET_NEW_SURFACE_MSG);
  mHandler.sendMessage(msg);
}","public void dispatchGetNewSurface(){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    Message msg=surfaceView.mHandler.obtainMessage(GET_NEW_SURFACE_MSG);
    surfaceView.mHandler.sendMessage(msg);
  }
}",0.6406685236768802
183895,"public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw){
  if (localLOGV)   Log.v(""String_Node_Str"",SurfaceView.this + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
    if (mCurWidth != w || mCurHeight != h) {
      mCurWidth=w;
      mCurHeight=h;
    }
    if (reportDraw) {
      try {
        mSession.finishDrawing(mWindow);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void resized(int w,int h,Rect coveredInsets,Rect visibleInsets,boolean reportDraw){
  SurfaceView surfaceView=mSurfaceView.get();
  if (surfaceView != null) {
    if (localLOGV)     Log.v(""String_Node_Str"",surfaceView + ""String_Node_Str"" + w+ ""String_Node_Str""+ h+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight);
synchronized (this) {
      if (mCurWidth != w || mCurHeight != h) {
        mCurWidth=w;
        mCurHeight=h;
      }
      if (reportDraw) {
        try {
          surfaceView.mSession.finishDrawing(surfaceView.mWindow);
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}",0.8479020979020979
183896,"private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow();
        mLayout.type=WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      mSurfaceFrame.right=mWinFrame.width();
      mSurfaceFrame.bottom=mWinFrame.height();
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}","private void updateWindow(boolean force){
  if (!mHaveFrame) {
    return;
  }
  int myWidth=mRequestedWidth;
  if (myWidth <= 0)   myWidth=getWidth();
  int myHeight=mRequestedHeight;
  if (myHeight <= 0)   myHeight=getHeight();
  getLocationInWindow(mLocation);
  final boolean creating=mWindow == null;
  final boolean formatChanged=mFormat != mRequestedFormat;
  final boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean visibleChanged=mVisible != mRequestedVisible || mNewSurfaceNeeded;
  final boolean typeChanged=mType != mRequestedType;
  if (force || creating || formatChanged|| sizeChanged|| visibleChanged|| typeChanged|| mLeft != mLocation[0] || mTop != mLocation[1]) {
    if (localLOGV)     Log.i(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged+ ""String_Node_Str""+ visibleChanged+ ""String_Node_Str""+ (mLeft != mLocation[0])+ ""String_Node_Str""+ (mTop != mLocation[1]));
    try {
      final boolean visible=mVisible=mRequestedVisible;
      mLeft=mLocation[0];
      mTop=mLocation[1];
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mRequestedFormat;
      mType=mRequestedType;
      mLayout.x=mLeft;
      mLayout.y=mTop;
      mLayout.width=getWidth();
      mLayout.height=getHeight();
      mLayout.format=mRequestedFormat;
      mLayout.flags|=WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE| WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
      mLayout.memoryType=mRequestedType;
      if (mWindow == null) {
        mWindow=new MyWindow(this);
        mLayout.type=WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mSession.add(mWindow,mLayout,mVisible ? VISIBLE : GONE,mContentInsets);
      }
      if (visibleChanged && (!visible || mNewSurfaceNeeded)) {
        reportSurfaceDestroyed();
      }
      mNewSurfaceNeeded=false;
      mSurfaceLock.lock();
      mDrawingStopped=!visible;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,visible ? VISIBLE : GONE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurface);
      if (localLOGV)       Log.i(TAG,""String_Node_Str"" + mSurface + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mWinFrame);
      mSurfaceFrame.left=0;
      mSurfaceFrame.top=0;
      mSurfaceFrame.right=mWinFrame.width();
      mSurfaceFrame.bottom=mWinFrame.height();
      mSurfaceLock.unlock();
      try {
        if (visible) {
          mDestroyReportNeeded=true;
          SurfaceHolder.Callback callbacks[];
synchronized (mCallbacks) {
            callbacks=new SurfaceHolder.Callback[mCallbacks.size()];
            mCallbacks.toArray(callbacks);
          }
          if (visibleChanged) {
            mIsCreating=true;
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          if (creating || formatChanged || sizeChanged|| visibleChanged) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mWidth,mHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height+ ""String_Node_Str""+ mSurfaceFrame);
  }
}",0.9994579945799458
183897,"/** 
 * {@inheritDoc} 
 */
public void systemReady(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    Log.i(TAG,""String_Node_Str"" + menuState);
    if (menuState > 0) {
      ActivityManagerNative.getDefault().enterSafeMode();
    }
 else {
      mKeyguardMediator.onSystemReady();
      android.os.SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  RemoteException e) {
  }
}","/** 
 * {@inheritDoc} 
 */
public void systemReady(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    Log.i(TAG,""String_Node_Str"" + menuState);
    if (menuState > 0) {
      ActivityManagerNative.getDefault().enterSafeMode();
    }
    mKeyguardMediator.onSystemReady();
    android.os.SystemProperties.set(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  RemoteException e) {
  }
}",0.9791666666666666
183898,"public static final CharSequence getDisplayLabel(Context context,int type,CharSequence label){
  CharSequence display=""String_Node_Str"";
  if (type != TYPE_CUSTOM) {
    CharSequence[] labels=context.getResources().getTextArray(com.android.internal.R.array.organizationTypes);
    try {
      display=labels[type - 1];
    }
 catch (    ArrayIndexOutOfBoundsException e) {
      display=labels[People.Phones.TYPE_HOME - 1];
    }
  }
 else {
    if (!TextUtils.isEmpty(label)) {
      display=label;
    }
  }
  return display;
}","public static final CharSequence getDisplayLabel(Context context,int type,CharSequence label){
  CharSequence display=""String_Node_Str"";
  if (type != TYPE_CUSTOM) {
    CharSequence[] labels=context.getResources().getTextArray(com.android.internal.R.array.organizationTypes);
    try {
      display=labels[type - 1];
    }
 catch (    ArrayIndexOutOfBoundsException e) {
      display=labels[Organizations.TYPE_WORK - 1];
    }
  }
 else {
    if (!TextUtils.isEmpty(label)) {
      display=label;
    }
  }
  return display;
}",0.9716446124763704
183899,"public String execute(Map params,String body,RenderContext renderContext) throws MacroException {
  String picasaUser=(String)params.get(PICASAUSER_PARAM);
  int maxEntries=-1;
  try {
    maxEntries=Integer.parseInt((String)params.get(MAXENTRIES_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  int thumbnailCount=5;
  try {
    thumbnailCount=Integer.parseInt((String)params.get(THUMBNAILS_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  int imageSize=640;
  try {
    imageSize=Integer.parseInt((String)params.get(IMAGESIZE_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  if (picasaUser == null) {
    throw new MacroException(""String_Node_Str"");
  }
  HttpServletRequest request=ServletActionContext.getRequest();
  String albumId=null;
  String photoId=null;
  int page=0;
  int pageId=0;
  boolean flushCache=false;
  if (request != null) {
    albumId=request.getParameter(""String_Node_Str"");
    photoId=request.getParameter(""String_Node_Str"");
    try {
      page=Integer.parseInt(request.getParameter(""String_Node_Str"")) - 1;
    }
 catch (    NumberFormatException e) {
    }
    try {
      pageId=Integer.parseInt(request.getParameter(""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
    }
    try {
      flushCache=Boolean.parseBoolean(request.getParameter(""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
    }
  }
  CacheFactory cacheFactory=(CacheFactory)ContainerManager.getComponent(""String_Node_Str"");
  Cache cache=cacheFactory.getCache(""String_Node_Str"");
  if (flushCache) {
    cache.removeAll();
  }
  UserFeed userFeed;
  try {
    userFeed=PicasaHelper.getUserFeed(picasaUser,cache);
  }
 catch (  IOException e) {
    throw new MacroException(""String_Node_Str"");
  }
  AlbumFeed albumFeed=null;
  AlbumEntry albumEntry=null;
  if (albumId != null && (userFeed.albums != null)) {
    for (    AlbumEntry entry : userFeed.albums) {
      if (entry.id.equals(albumId)) {
        albumEntry=entry;
        break;
      }
    }
    if (albumEntry != null) {
      try {
        albumFeed=PicasaHelper.getAlbumFeed(picasaUser,albumEntry.id,cache);
      }
 catch (      IOException e) {
        throw new MacroException(""String_Node_Str"");
      }
    }
  }
  PhotoEntry photoEntry=null;
  List<PhotoEntry> thumbnails=null;
  int photoIndex=0;
  if (photoId != null && albumFeed != null && albumFeed.photos != null) {
    for (int i=0, n=albumFeed.photos.size(); i != n; ++i) {
      PhotoEntry photo=albumFeed.photos.get(i);
      if (photoId.equals(photo.id)) {
        int begin=(int)Math.max(0,i - Math.floor(thumbnailCount / 2.0f));
        int end=(int)Math.min(albumFeed.photos.size(),i + Math.ceil(thumbnailCount / 2.0f));
        photoEntry=photo;
        photoIndex=i;
        thumbnails=albumFeed.photos.subList(begin,end);
        break;
      }
    }
  }
  StringBuilder builder=new StringBuilder();
  Map context=MacroUtils.defaultVelocityContext();
  if (pageId > 0) {
    context.put(""String_Node_Str"",""String_Node_Str"" + pageId + ""String_Node_Str"");
  }
 else {
    context.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (photoEntry != null) {
    context.put(""String_Node_Str"",photoIndex + 1);
    context.put(""String_Node_Str"",albumFeed.photos.size());
    if (photoIndex > 0) {
      context.put(""String_Node_Str"",albumFeed.photos.get(photoIndex - 1).id);
    }
    if (photoIndex < albumFeed.photos.size() - 1) {
      context.put(""String_Node_Str"",albumFeed.photos.get(photoIndex + 1).id);
    }
    context.put(""String_Node_Str"",GalleryHelper.buildPhotoEntry(photoEntry,imageSize));
    context.put(""String_Node_Str"",GalleryHelper.buildAlbumEntry(albumEntry));
    context.put(""String_Node_Str"",pageId);
    if (thumbnails != null) {
      context.put(""String_Node_Str"",GalleryHelper.buildPhotoList(thumbnails,0));
    }
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
 else   if (albumFeed != null && albumFeed.photos != null) {
    int begin=0;
    int end=albumFeed.photos.size();
    if (maxEntries > 0) {
      context.put(""String_Node_Str"",page + 1);
      context.put(""String_Node_Str"",(end + maxEntries - 1) / maxEntries);
      begin=Math.min(end,page * maxEntries);
      end=Math.min(end,begin + maxEntries);
    }
    context.put(""String_Node_Str"",GalleryHelper.buildPhotoList(albumFeed.photos.subList(begin,end),1));
    context.put(""String_Node_Str"",GalleryHelper.buildAlbumEntry(albumEntry));
    context.put(""String_Node_Str"",pageId);
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
 else   if (userFeed.albums != null) {
    int begin=0;
    int end=userFeed.albums.size();
    if (maxEntries > 0) {
      context.put(""String_Node_Str"",Integer.toString(page + 1));
      context.put(""String_Node_Str"",(end + maxEntries - 1) / maxEntries);
      begin=Math.min(end,page * maxEntries);
      end=Math.min(end,begin + maxEntries);
    }
    context.put(""String_Node_Str"",GalleryHelper.buildAlbumList(userFeed.albums.subList(begin,end)));
    context.put(""String_Node_Str"",pageId);
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
  return builder.toString();
}","public String execute(Map params,String body,RenderContext renderContext) throws MacroException {
  String picasaUser=(String)params.get(PICASAUSER_PARAM);
  int maxEntries=-1;
  try {
    maxEntries=Integer.parseInt((String)params.get(MAXENTRIES_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  int thumbnailCount=5;
  try {
    thumbnailCount=Integer.parseInt((String)params.get(THUMBNAILS_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  int imageSize=640;
  try {
    imageSize=Integer.parseInt((String)params.get(IMAGESIZE_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  if (picasaUser == null) {
    throw new MacroException(""String_Node_Str"");
  }
  HttpServletRequest request=ServletActionContext.getRequest();
  String albumId=null;
  String photoId=null;
  int pageIndex=0;
  int pageId=0;
  boolean flushCache=false;
  if (request != null) {
    albumId=request.getParameter(""String_Node_Str"");
    photoId=request.getParameter(""String_Node_Str"");
    try {
      pageIndex=Integer.parseInt(request.getParameter(""String_Node_Str"")) - 1;
    }
 catch (    NumberFormatException e) {
    }
    try {
      pageId=Integer.parseInt(request.getParameter(""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
    }
    try {
      flushCache=Boolean.parseBoolean(request.getParameter(""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
    }
  }
  CacheFactory cacheFactory=(CacheFactory)ContainerManager.getComponent(""String_Node_Str"");
  Cache cache=cacheFactory.getCache(""String_Node_Str"");
  if (flushCache) {
    cache.removeAll();
  }
  UserFeed userFeed;
  try {
    userFeed=PicasaHelper.getUserFeed(picasaUser,cache);
  }
 catch (  IOException e) {
    throw new MacroException(""String_Node_Str"");
  }
  AlbumFeed albumFeed=null;
  AlbumEntry albumEntry=null;
  if (albumId != null && (userFeed.albums != null)) {
    for (    AlbumEntry entry : userFeed.albums) {
      if (entry.id.equals(albumId)) {
        albumEntry=entry;
        break;
      }
    }
    if (albumEntry != null) {
      try {
        albumFeed=PicasaHelper.getAlbumFeed(picasaUser,albumEntry.id,cache);
      }
 catch (      IOException e) {
        throw new MacroException(""String_Node_Str"");
      }
    }
  }
  PhotoEntry photoEntry=null;
  List<PhotoEntry> thumbnails=null;
  int photoIndex=0;
  if (photoId != null && albumFeed != null && albumFeed.photos != null) {
    for (int i=0, n=albumFeed.photos.size(); i != n; ++i) {
      PhotoEntry photo=albumFeed.photos.get(i);
      if (photoId.equals(photo.id)) {
        int begin=(int)Math.max(0,i - Math.floor(thumbnailCount / 2.0f));
        int end=(int)Math.min(albumFeed.photos.size(),i + Math.ceil(thumbnailCount / 2.0f));
        photoEntry=photo;
        photoIndex=i;
        thumbnails=albumFeed.photos.subList(begin,end);
        break;
      }
    }
  }
  StringBuilder builder=new StringBuilder();
  Map context=MacroUtils.defaultVelocityContext();
  if (pageId > 0) {
    context.put(""String_Node_Str"",""String_Node_Str"" + pageId + ""String_Node_Str"");
  }
 else {
    context.put(""String_Node_Str"",""String_Node_Str"");
  }
  PageContext pageContext=(PageContext)renderContext;
  Page page=(pageContext.getEntity() != null && pageContext.getEntity() instanceof Page) ? (Page)pageContext.getEntity() : null;
  if (page != null) {
    context.put(""String_Node_Str"",page.getTitle());
  }
  if (photoEntry != null) {
    context.put(""String_Node_Str"",photoIndex + 1);
    context.put(""String_Node_Str"",albumFeed.photos.size());
    if (photoIndex > 0) {
      context.put(""String_Node_Str"",albumFeed.photos.get(photoIndex - 1).id);
    }
    if (photoIndex < albumFeed.photos.size() - 1) {
      context.put(""String_Node_Str"",albumFeed.photos.get(photoIndex + 1).id);
    }
    context.put(""String_Node_Str"",GalleryHelper.buildPhotoEntry(photoEntry,imageSize));
    context.put(""String_Node_Str"",GalleryHelper.buildAlbumEntry(albumEntry));
    context.put(""String_Node_Str"",pageId);
    if (thumbnails != null) {
      context.put(""String_Node_Str"",GalleryHelper.buildPhotoList(thumbnails,0));
    }
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
 else   if (albumFeed != null && albumFeed.photos != null) {
    int begin=0;
    int end=albumFeed.photos.size();
    if (maxEntries > 0) {
      context.put(""String_Node_Str"",pageIndex + 1);
      context.put(""String_Node_Str"",(end + maxEntries - 1) / maxEntries);
      begin=Math.min(end,pageIndex * maxEntries);
      end=Math.min(end,begin + maxEntries);
    }
    context.put(""String_Node_Str"",GalleryHelper.buildPhotoList(albumFeed.photos.subList(begin,end),1));
    context.put(""String_Node_Str"",GalleryHelper.buildAlbumEntry(albumEntry));
    context.put(""String_Node_Str"",pageId);
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
 else   if (userFeed.albums != null) {
    int begin=0;
    int end=userFeed.albums.size();
    if (maxEntries > 0) {
      context.put(""String_Node_Str"",Integer.toString(pageIndex + 1));
      context.put(""String_Node_Str"",(end + maxEntries - 1) / maxEntries);
      begin=Math.min(end,pageIndex * maxEntries);
      end=Math.min(end,begin + maxEntries);
    }
    context.put(""String_Node_Str"",GalleryHelper.buildAlbumList(userFeed.albums.subList(begin,end)));
    context.put(""String_Node_Str"",pageId);
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
  return builder.toString();
}",0.9727553599850202
183900,"public String execute(Map params,String body,RenderContext renderContext) throws MacroException {
  String user=(String)params.get(USER_PARAM);
  if (user == null) {
    throw new MacroException(""String_Node_Str"");
  }
  int maxEntries=-1;
  try {
    maxEntries=Integer.parseInt((String)params.get(MAXENTRIES_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  int thumbnailCount=5;
  try {
    thumbnailCount=Integer.parseInt((String)params.get(THUMBNAILS_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  boolean reverse=false;
  try {
    reverse=Boolean.parseBoolean((String)params.get(REVERSE_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  HttpServletRequest request=ServletActionContext.getRequest();
  String playlistId=null;
  String videoId=null;
  int page=0;
  int pageId=0;
  boolean flushCache=false;
  if (request != null) {
    playlistId=request.getParameter(""String_Node_Str"");
    videoId=request.getParameter(""String_Node_Str"");
    try {
      page=Integer.parseInt(request.getParameter(""String_Node_Str"")) - 1;
    }
 catch (    NumberFormatException e) {
    }
    try {
      pageId=Integer.parseInt(request.getParameter(""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
    }
    try {
      flushCache=Boolean.parseBoolean(request.getParameter(""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
    }
  }
  CacheFactory cacheFactory=(CacheFactory)ContainerManager.getComponent(""String_Node_Str"");
  Cache cache=cacheFactory.getCache(""String_Node_Str"");
  if (flushCache) {
    cache.removeAll();
  }
  PlaylistsFeed playlistsFeed;
  try {
    playlistsFeed=YoutubeHelper.getPlaylistsFeed(user,cache);
  }
 catch (  IOException e) {
    throw new MacroException(""String_Node_Str"");
  }
  VideoFeed videoFeed=null;
  PlaylistEntry playlistEntry=null;
  if ((playlistId != null) && (playlistsFeed.playlists != null)) {
    for (    PlaylistEntry entry : playlistsFeed.playlists) {
      if (entry.id.equals(playlistId)) {
        playlistEntry=entry;
        break;
      }
    }
    if (playlistEntry != null) {
      try {
        videoFeed=YoutubeHelper.getPlaylistFeed(playlistEntry.id,cache);
        PlaylistSummary summary=new PlaylistSummary(playlistEntry.summary);
        summary.patchVideos(videoFeed.videos);
      }
 catch (      IOException e) {
        throw new MacroException(""String_Node_Str"");
      }
    }
  }
  VideoEntry videoEntry=null;
  List<VideoEntry> thumbnails=null;
  int videoIndex=0;
  if (videoId != null && (videoFeed != null) && (videoFeed.videos != null)) {
    for (int i=0, n=videoFeed.videos.size(); i != n; ++i) {
      VideoEntry video=videoFeed.videos.get(i);
      if (videoId.equals(video.group.id)) {
        int begin=(int)Math.max(0,i - Math.floor(thumbnailCount / 2.0f));
        int end=(int)Math.min(videoFeed.videos.size(),i + Math.ceil(thumbnailCount / 2.0f));
        videoEntry=video;
        videoIndex=i;
        thumbnails=videoFeed.videos.subList(begin,end);
        break;
      }
    }
  }
  StringBuilder builder=new StringBuilder();
  Map context=MacroUtils.defaultVelocityContext();
  if (pageId > 0) {
    context.put(""String_Node_Str"",""String_Node_Str"" + pageId + ""String_Node_Str"");
  }
 else {
    context.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (videoEntry != null) {
    context.put(""String_Node_Str"",videoIndex + 1);
    context.put(""String_Node_Str"",videoFeed.videos.size());
    if (videoIndex > 0) {
      context.put(""String_Node_Str"",videoFeed.videos.get(videoIndex - 1).group.id);
    }
    if (videoIndex < videoFeed.videos.size() - 1) {
      context.put(""String_Node_Str"",videoFeed.videos.get(videoIndex + 1).group.id);
    }
    context.put(""String_Node_Str"",PlaylistHelper.buildVideoEntry(videoEntry));
    context.put(""String_Node_Str"",PlaylistHelper.buildPlaylist(playlistEntry));
    if (thumbnails != null) {
      context.put(""String_Node_Str"",PlaylistHelper.buildVideoList(thumbnails));
    }
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
 else   if ((videoFeed != null) && (videoFeed.videos != null)) {
    int begin=0;
    int end=videoFeed.videos.size();
    if (maxEntries > 0) {
      context.put(""String_Node_Str"",page + 1);
      context.put(""String_Node_Str"",(end + maxEntries - 1) / maxEntries);
      begin=Math.min(end,page * maxEntries);
      end=Math.min(end,begin + maxEntries);
    }
    context.put(""String_Node_Str"",PlaylistHelper.buildVideoList(videoFeed.videos.subList(begin,end)));
    context.put(""String_Node_Str"",PlaylistHelper.buildPlaylist(playlistEntry));
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
 else   if (playlistsFeed.playlists != null) {
    ArrayList<PlaylistEntry> playlists=new ArrayList<PlaylistEntry>(playlistsFeed.playlists);
    int begin=0;
    int end=playlists.size();
    if (!reverse) {
      Collections.reverse(playlists);
    }
    if (maxEntries > 0) {
      context.put(""String_Node_Str"",Integer.toString(page + 1));
      context.put(""String_Node_Str"",(end + maxEntries - 1) / maxEntries);
      begin=Math.min(end,page * maxEntries);
      end=Math.min(end,begin + maxEntries);
    }
    context.put(""String_Node_Str"",PlaylistHelper.buildPlaylists(playlists.subList(begin,end)));
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
  return builder.toString();
}","public String execute(Map params,String body,RenderContext renderContext) throws MacroException {
  String user=(String)params.get(USER_PARAM);
  if (user == null) {
    throw new MacroException(""String_Node_Str"");
  }
  int maxEntries=-1;
  try {
    maxEntries=Integer.parseInt((String)params.get(MAXENTRIES_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  int thumbnailCount=5;
  try {
    thumbnailCount=Integer.parseInt((String)params.get(THUMBNAILS_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  boolean reverse=false;
  try {
    reverse=Boolean.parseBoolean((String)params.get(REVERSE_PARAM));
  }
 catch (  NumberFormatException e) {
  }
  HttpServletRequest request=ServletActionContext.getRequest();
  String playlistId=null;
  String videoId=null;
  int pageIndex=0;
  int pageId=0;
  boolean flushCache=false;
  if (request != null) {
    playlistId=request.getParameter(""String_Node_Str"");
    videoId=request.getParameter(""String_Node_Str"");
    try {
      pageIndex=Integer.parseInt(request.getParameter(""String_Node_Str"")) - 1;
    }
 catch (    NumberFormatException e) {
    }
    try {
      pageId=Integer.parseInt(request.getParameter(""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
    }
    try {
      flushCache=Boolean.parseBoolean(request.getParameter(""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
    }
  }
  CacheFactory cacheFactory=(CacheFactory)ContainerManager.getComponent(""String_Node_Str"");
  Cache cache=cacheFactory.getCache(""String_Node_Str"");
  if (flushCache) {
    cache.removeAll();
  }
  PlaylistsFeed playlistsFeed;
  try {
    playlistsFeed=YoutubeHelper.getPlaylistsFeed(user,cache);
  }
 catch (  IOException e) {
    throw new MacroException(""String_Node_Str"");
  }
  VideoFeed videoFeed=null;
  PlaylistEntry playlistEntry=null;
  if ((playlistId != null) && (playlistsFeed.playlists != null)) {
    for (    PlaylistEntry entry : playlistsFeed.playlists) {
      if (entry.id.equals(playlistId)) {
        playlistEntry=entry;
        break;
      }
    }
    if (playlistEntry != null) {
      try {
        videoFeed=YoutubeHelper.getPlaylistFeed(playlistEntry.id,cache);
        PlaylistSummary summary=new PlaylistSummary(playlistEntry.summary);
        summary.patchVideos(videoFeed.videos);
      }
 catch (      IOException e) {
        throw new MacroException(""String_Node_Str"");
      }
    }
  }
  VideoEntry videoEntry=null;
  List<VideoEntry> thumbnails=null;
  int videoIndex=0;
  if (videoId != null && (videoFeed != null) && (videoFeed.videos != null)) {
    for (int i=0, n=videoFeed.videos.size(); i != n; ++i) {
      VideoEntry video=videoFeed.videos.get(i);
      if (videoId.equals(video.group.id)) {
        int begin=(int)Math.max(0,i - Math.floor(thumbnailCount / 2.0f));
        int end=(int)Math.min(videoFeed.videos.size(),i + Math.ceil(thumbnailCount / 2.0f));
        videoEntry=video;
        videoIndex=i;
        thumbnails=videoFeed.videos.subList(begin,end);
        break;
      }
    }
  }
  StringBuilder builder=new StringBuilder();
  Map context=MacroUtils.defaultVelocityContext();
  PageContext pageContext=(PageContext)renderContext;
  Page page=(pageContext.getEntity() != null && pageContext.getEntity() instanceof Page) ? (Page)pageContext.getEntity() : null;
  if (page != null) {
    context.put(""String_Node_Str"",page.getTitle());
  }
  if (pageId > 0) {
    context.put(""String_Node_Str"",""String_Node_Str"" + pageId + ""String_Node_Str"");
  }
 else {
    context.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (videoEntry != null) {
    context.put(""String_Node_Str"",videoIndex + 1);
    context.put(""String_Node_Str"",videoFeed.videos.size());
    if (videoIndex > 0) {
      context.put(""String_Node_Str"",videoFeed.videos.get(videoIndex - 1).group.id);
    }
    if (videoIndex < videoFeed.videos.size() - 1) {
      context.put(""String_Node_Str"",videoFeed.videos.get(videoIndex + 1).group.id);
    }
    context.put(""String_Node_Str"",PlaylistHelper.buildVideoEntry(videoEntry));
    context.put(""String_Node_Str"",PlaylistHelper.buildPlaylist(playlistEntry));
    if (thumbnails != null) {
      context.put(""String_Node_Str"",PlaylistHelper.buildVideoList(thumbnails));
    }
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
 else   if ((videoFeed != null) && (videoFeed.videos != null)) {
    int begin=0;
    int end=videoFeed.videos.size();
    if (maxEntries > 0) {
      context.put(""String_Node_Str"",pageIndex + 1);
      context.put(""String_Node_Str"",(end + maxEntries - 1) / maxEntries);
      begin=Math.min(end,pageIndex * maxEntries);
      end=Math.min(end,begin + maxEntries);
    }
    context.put(""String_Node_Str"",PlaylistHelper.buildVideoList(videoFeed.videos.subList(begin,end)));
    context.put(""String_Node_Str"",PlaylistHelper.buildPlaylist(playlistEntry));
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
 else   if (playlistsFeed.playlists != null) {
    ArrayList<PlaylistEntry> playlists=new ArrayList<PlaylistEntry>(playlistsFeed.playlists);
    int begin=0;
    int end=playlists.size();
    if (!reverse) {
      Collections.reverse(playlists);
    }
    if (maxEntries > 0) {
      context.put(""String_Node_Str"",Integer.toString(pageIndex + 1));
      context.put(""String_Node_Str"",(end + maxEntries - 1) / maxEntries);
      begin=Math.min(end,pageIndex * maxEntries);
      end=Math.min(end,begin + maxEntries);
    }
    context.put(""String_Node_Str"",PlaylistHelper.buildPlaylists(playlists.subList(begin,end)));
    builder.append(VelocityUtils.getRenderedTemplate(""String_Node_Str"",context));
  }
  return builder.toString();
}",0.973786145392307
183901,"@Override public void onEntityDeath(EntityDeathEvent e){
  if (e.getEntity() instanceof HumanEntity)   return;
  if (e.getEntity() instanceof LivingEntity) {
    if (e.getDrops().size() > 0) {
      Location loc=e.getEntity().getLocation();
      EntityDeathPoint p=new EntityDeathPoint(loc.getX(),loc.getY(),loc.getZ());
      EntityDeathBox box=new EntityDeathBox(loc.getX(),loc.getY(),loc.getZ(),radius);
      int r=generator.nextInt(maxDeaths) + minDeaths;
      int deathCount=getNearbyDeathCount(p);
      if (deathCount > r) {
        if (this.debug) {
          System.out.println(String.format(""String_Node_Str"",p.x,p.y,p.z,deathCount,r,e.getEntity().toString(),nearbyDeaths.size()));
        }
        e.getDrops().clear();
        return;
      }
      this.nearbyDeaths.add(box);
    }
  }
}","@Override public void onEntityDeath(EntityDeathEvent e){
  if (e.getEntity() instanceof HumanEntity)   return;
  if (e.getEntity() instanceof LivingEntity) {
    if (e.getDrops().size() > 0) {
      Location loc=e.getEntity().getLocation();
      EntityDeathPoint p=new EntityDeathPoint(loc.getX(),loc.getY(),loc.getZ());
      EntityDeathBox box=new EntityDeathBox(loc.getX(),loc.getY(),loc.getZ(),radius);
      int r=generator.nextInt(maxDeaths) + minDeaths;
      int deathCount=getNearbyDeathCount(p);
      if (deathCount > r) {
        if (this.debug) {
          System.out.println(String.format(""String_Node_Str"",p.x,p.y,p.z,e.getEntity().toString(),deathCount,r,nearbyDeaths.size()));
        }
        e.getDrops().clear();
        return;
      }
      this.nearbyDeaths.add(box);
    }
  }
}",0.968905472636816
183902,"public boolean setUseGlobalBlockBlacklist(CommandSender sender,String[] args){
  hasPermission=checkPerm(sender,""String_Node_Str"");
  if (!hasPermission) {
    return false;
  }
  if (args.length < 4) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (this.server.getWorld(args[1]) == null) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (ConfigBuffer.MobMap.containsKey(args[2])) {
    if (args[3].equals(""String_Node_Str"")) {
      config.set(""String_Node_Str"" + args[1] + ""String_Node_Str""+ args[2]+ ""String_Node_Str"",true);
      cb.plugin.sendNospawnMessage(sender,args[2] + ""String_Node_Str"",ChatColor.GREEN);
      saveConfig();
      cb.readConfig();
    }
 else     if (args[3].equals(""String_Node_Str"")) {
      config.set(""String_Node_Str"" + args[1] + ""String_Node_Str""+ args[2]+ ""String_Node_Str"",false);
      cb.plugin.sendNospawnMessage(sender,args[2] + ""String_Node_Str"",ChatColor.GREEN);
      saveConfig();
      cb.readConfig();
    }
    return true;
  }
 else {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + args[2] + ""String_Node_Str"",ChatColor.RED);
    return false;
  }
}","public boolean setUseGlobalBlockBlacklist(CommandSender sender,String[] args){
  hasPermission=checkPerm(sender,""String_Node_Str"");
  String mob=Character.toUpperCase(args[2].charAt(0)) + args[2].substring(1,args[2].length()).toLowerCase();
  if (args[2].toLowerCase().equals(""String_Node_Str"")) {
    mob=""String_Node_Str"";
  }
  if (!hasPermission) {
    return false;
  }
  if (args.length < 4) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (this.server.getWorld(args[1]) == null) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (ConfigBuffer.MobMap.containsKey(mob)) {
    if (args[3].equals(""String_Node_Str"")) {
      config.set(""String_Node_Str"" + args[1] + ""String_Node_Str""+ mob+ ""String_Node_Str"",true);
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"" + args[1]+ ""String_Node_Str"",ChatColor.GREEN);
      saveConfig();
      cb.readConfig();
    }
 else     if (args[3].equals(""String_Node_Str"")) {
      config.set(""String_Node_Str"" + args[1] + ""String_Node_Str""+ mob+ ""String_Node_Str"",false);
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"" + args[1]+ ""String_Node_Str"",ChatColor.GREEN);
      saveConfig();
      cb.readConfig();
    }
    return true;
  }
 else {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + mob + ""String_Node_Str"",ChatColor.RED);
    return false;
  }
}",0.7853128512551517
183903,"public static boolean has(Player player,String node){
  if (player.isOp()) {
    return true;
  }
 else   if (PermissionsMode == PermissionsType.NONE) {
    return false;
  }
 else   if (PermissionsMode == PermissionsType.Vault) {
    ((Permission)Permissions).has(player,node);
  }
 else   if (PermissionsMode == PermissionsType.BukkitPermissions) {
    player.hasPermission(node);
  }
  return false;
}","public static boolean has(Player player,String node){
  if (player.isOp()) {
    return true;
  }
 else   if (PermissionsMode == PermissionsType.NONE) {
    return false;
  }
 else   if (PermissionsMode == PermissionsType.Vault) {
    return ((Permission)Permissions).has(player,node);
  }
 else   if (PermissionsMode == PermissionsType.BukkitPermissions) {
    return player.hasPermission(node);
  }
  return false;
}",0.9829683698296836
183904,"private String ConvertMobname(String s){
  String ret=""String_Node_Str"";
  s=s.toLowerCase();
  if (s.contains(""String_Node_Str"")) {
    String[] s_arr=s.split(""String_Node_Str"");
    char[] ch_arr1, ch_arr2;
    ch_arr1=s_arr[0].toCharArray();
    ch_arr2=s_arr[1].toCharArray();
    if ((int)ch_arr1[0] < 97) {
      ch_arr1[0]=(char)((int)ch_arr1[0] + 32);
    }
    if ((int)ch_arr2[0] < 97) {
      ch_arr2[0]=(char)((int)ch_arr2[0] + 32);
    }
    for (    char c : ch_arr1) {
      ret+=c;
    }
    ret+=""String_Node_Str"";
    for (    char c : ch_arr2) {
      ret+=c;
    }
  }
 else {
    char[] ch_arr1=s.toCharArray();
    if ((int)ch_arr1[0] < 97) {
      ch_arr1[0]=(char)((int)ch_arr1[0] + 32);
    }
    for (    char c : ch_arr1) {
      ret+=c;
    }
  }
  return ret;
}","private String ConvertMobname(String s){
  String ret;
  s=s.toLowerCase();
  if (s.contains(""String_Node_Str"")) {
    String[] s_arr=s.split(""String_Node_Str"");
    ret=Character.toUpperCase(s_arr[0].charAt(0)) + s_arr[0].substring(1,s_arr[0].length()).toLowerCase() + ""String_Node_Str""+ Character.toUpperCase(s_arr[1].charAt(0))+ s_arr[1].substring(1,s_arr[1].length()).toLowerCase();
  }
 else {
    ret=Character.toUpperCase(s.charAt(0)) + s.substring(1,s.length()).toLowerCase();
  }
  return ret;
}",0.142194744976816
183905,"private boolean setConf(CommandSender sender,String[] args,String operation){
  String mob=Character.toUpperCase(args[2].charAt(0)) + args[2].substring(1,args[2].length()).toLowerCase();
  if (args[2].toLowerCase().equals(""String_Node_Str"")) {
    mob=""String_Node_Str"";
  }
  String w=args[1];
  if (this.server.getWorld(args[1]) == null) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (ConfigBuffer.MobMap.containsKey(mob)) {
    if (operation.equals(""String_Node_Str"")) {
      cb.config.set(""String_Node_Str"" + w + ""String_Node_Str""+ mob+ ""String_Node_Str"",true);
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"",ChatColor.GREEN);
    }
 else     if (operation.equals(""String_Node_Str"")) {
      cb.config.set(""String_Node_Str"" + w + ""String_Node_Str""+ mob+ ""String_Node_Str"",false);
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"",ChatColor.GREEN);
    }
 else     if (operation.equals(""String_Node_Str"")) {
      cb.config.set(""String_Node_Str"" + w + ""String_Node_Str""+ mob+ ""String_Node_Str"",Integer.parseInt(args[3]));
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"" + args[3]+ ""String_Node_Str"",ChatColor.GREEN);
    }
    saveConfig();
    cb.readConfig();
    return true;
  }
 else {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + args[2] + ""String_Node_Str"",ChatColor.RED);
    return false;
  }
}","private boolean setConf(CommandSender sender,String[] args,String operation){
  String mob=Character.toUpperCase(args[2].charAt(0)) + args[2].substring(1,args[2].length()).toLowerCase();
  if (args[2].toLowerCase().equals(""String_Node_Str"")) {
    mob=""String_Node_Str"";
  }
  String w=args[1];
  if (this.server.getWorld(args[1]) == null) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (MobExists(sender,args[2])) {
    if (operation.equals(""String_Node_Str"")) {
      cb.config.set(""String_Node_Str"" + w + ""String_Node_Str""+ mob+ ""String_Node_Str"",true);
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"",ChatColor.GREEN);
    }
 else     if (operation.equals(""String_Node_Str"")) {
      cb.config.set(""String_Node_Str"" + w + ""String_Node_Str""+ mob+ ""String_Node_Str"",false);
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"",ChatColor.GREEN);
    }
 else     if (operation.equals(""String_Node_Str"")) {
      cb.config.set(""String_Node_Str"" + w + ""String_Node_Str""+ mob+ ""String_Node_Str"",Integer.parseInt(args[3]));
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"" + args[3]+ ""String_Node_Str"",ChatColor.GREEN);
    }
    saveConfig();
    cb.readConfig();
    return true;
  }
 else {
    return false;
  }
}",0.9428883230265552
183906,"public boolean editBlockBlacklist(CommandSender sender,String[] args){
  hasPermission=checkPerm(sender,""String_Node_Str"");
  String mob=Character.toUpperCase(args[2].charAt(0)) + args[2].substring(1,args[2].length()).toLowerCase();
  if (args[2].toLowerCase().equals(""String_Node_Str"")) {
    mob=""String_Node_Str"";
  }
  if (!hasPermission) {
    return false;
  }
  if (args.length < 4) {
    if (args[0].contains(""String_Node_Str"")) {
      cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    }
 else     if (args[0].contains(""String_Node_Str"")) {
      cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    }
    return false;
  }
  if (!isInt(args[3])) {
    cb.plugin.sendNospawnMessage(sender,args[3] + ""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (ConfigBuffer.MobMap.containsKey(mob)) {
    if (args[0].contains(""String_Node_Str"")) {
      if (addBlacklistElement(""String_Node_Str"" + args[1] + ""String_Node_Str""+ mob+ ""String_Node_Str"",Integer.parseInt(args[3]))) {
        cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + args[3] + ""String_Node_Str""+ mob+ ""String_Node_Str""+ args[1],ChatColor.GREEN);
      }
 else {
        cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + mob + ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ args[3],ChatColor.RED);
      }
    }
 else     if (args[0].contains(""String_Node_Str"")) {
      if (deleteBlacklistElement(""String_Node_Str"" + args[1] + ""String_Node_Str""+ mob+ ""String_Node_Str"",Integer.parseInt(args[3]))) {
        cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + args[3] + ""String_Node_Str""+ mob+ ""String_Node_Str""+ args[1],ChatColor.GREEN);
      }
 else {
        cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + mob + ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ args[3],ChatColor.RED);
      }
    }
  }
 else {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + mob + ""String_Node_Str"",ChatColor.RED);
    return false;
  }
  return true;
}","public boolean editBlockBlacklist(CommandSender sender,String[] args){
  hasPermission=checkPerm(sender,""String_Node_Str"");
  String mob=Character.toUpperCase(args[2].charAt(0)) + args[2].substring(1,args[2].length()).toLowerCase();
  if (args[2].toLowerCase().equals(""String_Node_Str"")) {
    mob=""String_Node_Str"";
  }
  if (!hasPermission) {
    return false;
  }
  if (args.length < 4) {
    if (args[0].contains(""String_Node_Str"")) {
      cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    }
 else     if (args[0].contains(""String_Node_Str"")) {
      cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    }
    return false;
  }
  if (!isInt(args[3])) {
    cb.plugin.sendNospawnMessage(sender,args[3] + ""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (MobExists(sender,mob)) {
    if (args[0].contains(""String_Node_Str"")) {
      if (addBlacklistElement(""String_Node_Str"" + args[1] + ""String_Node_Str""+ mob+ ""String_Node_Str"",Integer.parseInt(args[3]))) {
        cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + args[3] + ""String_Node_Str""+ mob+ ""String_Node_Str""+ args[1],ChatColor.GREEN);
      }
 else {
        cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + mob + ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ args[3],ChatColor.RED);
      }
    }
 else     if (args[0].contains(""String_Node_Str"")) {
      if (deleteBlacklistElement(""String_Node_Str"" + args[1] + ""String_Node_Str""+ mob+ ""String_Node_Str"",Integer.parseInt(args[3]))) {
        cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + args[3] + ""String_Node_Str""+ mob+ ""String_Node_Str""+ args[1],ChatColor.GREEN);
      }
 else {
        cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + mob + ""String_Node_Str""+ args[1]+ ""String_Node_Str""+ args[3],ChatColor.RED);
      }
    }
  }
 else {
    return false;
  }
  return true;
}",0.954954954954955
183907,"public boolean setUseGlobalBlockBlacklist(CommandSender sender,String[] args){
  hasPermission=checkPerm(sender,""String_Node_Str"");
  String mob=Character.toUpperCase(args[2].charAt(0)) + args[2].substring(1,args[2].length()).toLowerCase();
  if (args[2].toLowerCase().equals(""String_Node_Str"")) {
    mob=""String_Node_Str"";
  }
  if (!hasPermission) {
    return false;
  }
  if (args.length < 4) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (this.server.getWorld(args[1]) == null) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (ConfigBuffer.MobMap.containsKey(mob)) {
    if (args[3].equals(""String_Node_Str"")) {
      cb.config.set(""String_Node_Str"" + args[1] + ""String_Node_Str""+ mob+ ""String_Node_Str"",true);
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"" + args[1]+ ""String_Node_Str"",ChatColor.GREEN);
      saveConfig();
      cb.readConfig();
    }
 else     if (args[3].equals(""String_Node_Str"")) {
      cb.config.set(""String_Node_Str"" + args[1] + ""String_Node_Str""+ mob+ ""String_Node_Str"",false);
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"" + args[1]+ ""String_Node_Str"",ChatColor.GREEN);
      saveConfig();
      cb.readConfig();
    }
    return true;
  }
 else {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + mob + ""String_Node_Str"",ChatColor.RED);
    return false;
  }
}","public boolean setUseGlobalBlockBlacklist(CommandSender sender,String[] args){
  hasPermission=checkPerm(sender,""String_Node_Str"");
  String mob=Character.toUpperCase(args[2].charAt(0)) + args[2].substring(1,args[2].length()).toLowerCase();
  if (args[2].toLowerCase().equals(""String_Node_Str"")) {
    mob=""String_Node_Str"";
  }
  if (!hasPermission) {
    return false;
  }
  if (args.length < 4) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (this.server.getWorld(args[1]) == null) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  if (MobExists(sender,mob)) {
    if (args[3].equals(""String_Node_Str"")) {
      cb.config.set(""String_Node_Str"" + args[1] + ""String_Node_Str""+ mob+ ""String_Node_Str"",true);
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"" + args[1]+ ""String_Node_Str"",ChatColor.GREEN);
      saveConfig();
      cb.readConfig();
    }
 else     if (args[3].equals(""String_Node_Str"")) {
      cb.config.set(""String_Node_Str"" + args[1] + ""String_Node_Str""+ mob+ ""String_Node_Str"",false);
      cb.plugin.sendNospawnMessage(sender,mob + ""String_Node_Str"" + args[1]+ ""String_Node_Str"",ChatColor.GREEN);
      saveConfig();
      cb.readConfig();
    }
    return true;
  }
 else {
    return false;
  }
}",0.948873793350018
183908,"public boolean despawnMobs(CommandSender sender,String[] args){
  hasPermission=checkPerm(sender,""String_Node_Str"");
  int killcount=0;
  if (!hasPermission) {
    return false;
  }
  List<Entity> le;
  if (args.length < 3) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  String mob=ConvertMobname(args[2]);
  String w=args[1];
  if (this.server.getWorld(args[1]) == null) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
 else {
    le=server.getWorld(w).getEntities();
  }
  if (!ConfigBuffer.MobMap.containsKey(mob)) {
    String mobtypes=""String_Node_Str"";
    for (    String s : ConfigBuffer.MobMap.keySet()) {
      mobtypes+=s + ""String_Node_Str"";
    }
    mobtypes=mobtypes.substring(mobtypes.length() - 2);
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + mobtypes,ChatColor.RED);
    return false;
  }
  for (  Entity e : le) {
    if (e.getType() == ConfigBuffer.MobMap.get(mob)) {
      e.remove();
      killcount++;
    }
  }
  cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + killcount + ""String_Node_Str""+ mob+ ""String_Node_Str""+ w,ChatColor.GREEN);
  return true;
}","public boolean despawnMobs(CommandSender sender,String[] args){
  hasPermission=checkPerm(sender,""String_Node_Str"");
  int killcount=0;
  if (!hasPermission) {
    return false;
  }
  List<Entity> le;
  if (args.length < 3) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
  String mob=ConvertMobname(args[2]);
  String w=args[1];
  if (this.server.getWorld(args[1]) == null) {
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"",ChatColor.RED);
    return false;
  }
 else {
    le=server.getWorld(w).getEntities();
  }
  if (mob.equals(""String_Node_Str"")) {
    for (    Entity e : le) {
      if (!(e instanceof Player)) {
        e.remove();
        killcount++;
      }
    }
    cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + killcount + ""String_Node_Str""+ w,ChatColor.GREEN);
    return true;
  }
  if (!MobExists(sender,mob))   return false;
  for (  Entity e : le) {
    if (e.getType() == ConfigBuffer.MobMap.get(mob)) {
      e.remove();
      killcount++;
    }
  }
  server.getScheduler().cancelTasks(cb.plugin);
  cb.plugin.mc.runSchedueler();
  cb.plugin.sendNospawnMessage(sender,""String_Node_Str"" + killcount + ""String_Node_Str""+ mob+ ""String_Node_Str""+ w,ChatColor.GREEN);
  return true;
}",0.6063055780113177
183909,"public void runSchedueler(){
  server.getScheduler().scheduleSyncRepeatingTask(cb.plugin,new Runnable(){
    public void run(){
      for (      World w : server.getWorlds()) {
        for (        EntityType e : ConfigBuffer.MobMap.values()) {
          cb.worldSpawns.get(w).CurrentMobCount.put(e,0);
        }
        for (        LivingEntity e : w.getLivingEntities()) {
          cb.worldSpawns.get(w).CurrentMobCount.put(e.getType(),cb.worldSpawns.get(w).CurrentMobCount.get(e.getType()) + 1);
        }
      }
    }
  }
,0,((cb.CountTimer / 1000) * 20));
}","public void runSchedueler(){
  server.getScheduler().scheduleSyncRepeatingTask(cb.plugin,new Runnable(){
    public void run(){
      for (      World w : server.getWorlds()) {
        for (        EntityType e : ConfigBuffer.MobMap.values()) {
          cb.worldSpawns.get(w).CurrentMobCount.put(e,0);
        }
        for (        LivingEntity e : w.getLivingEntities()) {
          if (!(e instanceof Player)) {
            cb.worldSpawns.get(w).CurrentMobCount.put(e.getType(),(cb.worldSpawns.get(w).CurrentMobCount.get(e.getType()) + 1));
          }
        }
      }
    }
  }
,0,((cb.CountTimer / 1000) * 20));
}",0.9527824620573356
183910,"public void run(){
  for (  World w : server.getWorlds()) {
    for (    EntityType e : ConfigBuffer.MobMap.values()) {
      cb.worldSpawns.get(w).CurrentMobCount.put(e,0);
    }
    for (    LivingEntity e : w.getLivingEntities()) {
      cb.worldSpawns.get(w).CurrentMobCount.put(e.getType(),cb.worldSpawns.get(w).CurrentMobCount.get(e.getType()) + 1);
    }
  }
}","public void run(){
  for (  World w : server.getWorlds()) {
    for (    EntityType e : ConfigBuffer.MobMap.values()) {
      cb.worldSpawns.get(w).CurrentMobCount.put(e,0);
    }
    for (    LivingEntity e : w.getLivingEntities()) {
      if (!(e instanceof Player)) {
        cb.worldSpawns.get(w).CurrentMobCount.put(e.getType(),(cb.worldSpawns.get(w).CurrentMobCount.get(e.getType()) + 1));
      }
    }
  }
}",0.938618925831202
183911,"public boolean isSpawnAllowed(EntityType type,Block block){
  if ((getCurrentTotalMobsCount() >= TotalMobLimit) && TotalMobLimit != 0) {
    return false;
  }
  if ((CurrentMobCount.get(type) >= MobLimit.get(type)) && MobLimit.get(type) != 0) {
    return false;
  }
  if (SpawnAllowed.containsKey(type) && SpawnAllowed.get(type)) {
    if (UseGlobalBlockBlacklist.get(type) != null && GlobalBlockBlacklist != null) {
      if (UseGlobalBlockBlacklist.get(type) && GlobalBlockBlacklist.contains(block.getTypeId())) {
        return false;
      }
    }
    if (BlockBlacklist.get(type) != null) {
      if (BlockBlacklist.get(type).contains(block.getTypeId())) {
        return false;
      }
    }
    return true;
  }
 else {
    return false;
  }
}","public boolean isSpawnAllowed(EntityType type,Block block){
  if ((getCurrentTotalMobsCount() >= TotalMobLimit) && TotalMobLimit != 0) {
    NoSpawnDebugLogger.debugmsg(""String_Node_Str"" + getCurrentTotalMobsCount() + ""String_Node_Str""+ TotalMobLimit+ ""String_Node_Str"");
    return false;
  }
  if ((CurrentMobCount.get(type) >= MobLimit.get(type)) && MobLimit.get(type) != 0) {
    NoSpawnDebugLogger.debugmsg(""String_Node_Str"" + type.getName() + ""String_Node_Str""+ MobLimit.get(type)+ ""String_Node_Str""+ CurrentMobCount.get(type)+ ""String_Node_Str"");
    return false;
  }
  if (SpawnAllowed.containsKey(type) && SpawnAllowed.get(type)) {
    if (UseGlobalBlockBlacklist.get(type) != null && GlobalBlockBlacklist != null) {
      if (UseGlobalBlockBlacklist.get(type) && GlobalBlockBlacklist.contains(block.getTypeId())) {
        NoSpawnDebugLogger.debugmsg(""String_Node_Str"" + type.getName() + ""String_Node_Str"");
        return false;
      }
    }
    if (BlockBlacklist.get(type) != null) {
      if (BlockBlacklist.get(type).contains(block.getTypeId())) {
        NoSpawnDebugLogger.debugmsg(""String_Node_Str"" + type.getName() + ""String_Node_Str"");
        return false;
      }
    }
    return true;
  }
 else {
    NoSpawnDebugLogger.debugmsg(""String_Node_Str"" + type.getName() + ""String_Node_Str"");
    return false;
  }
}",0.7200383509108341
183912,"public CommandHandler(Server server,ConfigBuffer cb,Configuration config){
  this.server=server;
  this.cb=cb;
  this.config=config;
}","public CommandHandler(Server server,ConfigBuffer cb){
  this.server=server;
  this.cb=cb;
  this.config=cb.plugin.getConfiguration();
}",0.8401486988847584
183913,"public boolean despawnMobs(CommandSender sender,String[] args){
  Player player;
  String mob=args[2].toLowerCase();
  String w=args[1];
  List<Entity> le=new LinkedList<Entity>();
  if (sender instanceof Player) {
    player=(Player)sender;
    if (cb.Permissions == null) {
      if (!player.isOp()) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return false;
      }
    }
 else {
      if (!(cb.Permissions.has(player,""String_Node_Str""))) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return false;
      }
    }
  }
 else {
    player=null;
    return false;
  }
  if (args.length < 3) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return false;
  }
  if (this.server.getWorld(args[1]) == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return false;
  }
 else {
    le=server.getWorld(w).getEntities();
  }
  if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Pig) {
        le.get(i).remove();
        ;
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Sheep) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Cow) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Chicken) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof PigZombie) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Squid) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Wolf) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Zombie) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Skeleton) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Spider) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Creeper) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Slime) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Ghast) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Giant) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[2]+ ""String_Node_Str"");
    return false;
  }
}","public boolean despawnMobs(CommandSender sender,String[] args){
  Player player;
  List<Entity> le=new LinkedList<Entity>();
  if (sender instanceof Player) {
    player=(Player)sender;
    if (cb.Permissions == null) {
      if (!player.isOp()) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return false;
      }
    }
 else {
      if (!(cb.Permissions.has(player,""String_Node_Str""))) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        return false;
      }
    }
  }
 else {
    player=null;
    return false;
  }
  if (args.length < 3) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return false;
  }
  String mob=args[2].toLowerCase();
  String w=args[1];
  if (this.server.getWorld(args[1]) == null) {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return false;
  }
 else {
    le=server.getWorld(w).getEntities();
  }
  if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Pig) {
        le.get(i).remove();
        ;
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Sheep) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Cow) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Chicken) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof PigZombie) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Squid) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Wolf) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Zombie) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Skeleton) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Spider) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Creeper) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Slime) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Ghast) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else   if (mob.equals(""String_Node_Str"")) {
    for (int i=0; i < le.size(); i++) {
      if (le.get(i) instanceof Giant) {
        le.get(i).remove();
      }
    }
    player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + w);
    return true;
  }
 else {
    player.sendMessage(ChatColor.RED + ""String_Node_Str"" + args[2]+ ""String_Node_Str"");
    return false;
  }
}",0.8710170231340026
183914,"@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (command.getName().equals(""String_Node_Str"")) {
    if (args[0].equals(""String_Node_Str"")) {
      return cmh.setMob(sender,args);
    }
 else     if (args[0].equals(""String_Node_Str"")) {
      return cmh.despawnMobs(sender,args);
    }
 else {
      return false;
    }
  }
  return false;
}","@Override public boolean onCommand(CommandSender sender,Command command,String commandLabel,String[] args){
  if (command.getName().equals(""String_Node_Str"")) {
    if (args[0].equals(""String_Node_Str"")) {
      return cmh.setMob(sender,args);
    }
 else     if (args[0].equals(""String_Node_Str"")) {
      return cmh.despawnMobs(sender,args);
    }
 else {
      if (sender instanceof Player) {
        Player player=(Player)sender;
        player.sendMessage(args[0] + ""String_Node_Str"");
      }
      return false;
    }
  }
  return false;
}",0.8264984227129337
183915,"public void onEnable(){
  for (  World w : this.getServer().getWorlds()) {
    cb.worldSpawns.put(w,new Spawns());
  }
  config=getConfiguration();
  File ft=new File(configfile);
  if (!ft.exists()) {
    for (    World w : this.getServer().getWorlds()) {
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str"");
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str"");
    }
    config.save();
    System.out.println(""String_Node_Str"");
  }
 else {
    for (    World w : this.getServer().getWorlds()) {
      if (config.getKeys(""String_Node_Str"") != null && config.getKeys(""String_Node_Str"").contains(w.getName())) {
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SHEEP,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.COW,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CHICKEN,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG_ZOMBIE,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SQUID,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.WOLF,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.ZOMBIE,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SKELETON,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SPIDER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CREEPER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SLIME,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GHAST,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SPIDER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GIANT,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).AnimalBlockBlackList=getBlacklist(config.getString(""String_Node_Str"",""String_Node_Str""));
        this.cb.worldSpawns.get(w).MonterBlockBlacklist=getBlacklist(config.getString(""String_Node_Str"",""String_Node_Str""));
      }
    }
  }
  this.el=new NoSpawnEntityListener(this.cb,config);
  wl=new NoSpawnWorldListener(cb,config);
  this.cmh=new CommandHandler(this.getServer(),this.cb,this.config);
  PluginDescriptionFile pdfFile=getDescription();
  if (setupPermissions()) {
    System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  System.out.println(pdfFile.getName() + ""String_Node_Str"" + pdfFile.getVersion()+ ""String_Node_Str"");
  getServer().getPluginManager().registerEvent(Event.Type.CREATURE_SPAWN,this.el,Event.Priority.Normal,this);
  getServer().getPluginManager().registerEvent(Event.Type.WORLD_LOAD,this.wl,Event.Priority.Normal,this);
}","public void onEnable(){
  for (  World w : this.getServer().getWorlds()) {
    cb.worldSpawns.put(w,new Spawns());
  }
  config=getConfiguration();
  File ft=new File(configfile);
  if (!ft.exists()) {
    for (    World w : this.getServer().getWorlds()) {
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str"");
      config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str"");
    }
    config.save();
    System.out.println(""String_Node_Str"");
  }
 else {
    for (    World w : this.getServer().getWorlds()) {
      if (config.getKeys(""String_Node_Str"") != null && config.getKeys(""String_Node_Str"").contains(w.getName())) {
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SHEEP,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.COW,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CHICKEN,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG_ZOMBIE,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SQUID,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.WOLF,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.ZOMBIE,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SKELETON,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SPIDER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CREEPER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SLIME,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GHAST,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SPIDER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GIANT,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
        this.cb.worldSpawns.get(w).AnimalBlockBlackList=getBlacklist(config.getString(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str""));
        this.cb.worldSpawns.get(w).MonterBlockBlacklist=getBlacklist(config.getString(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str""));
      }
    }
  }
  cb.plugin=this;
  this.el=new NoSpawnEntityListener(this.cb,config);
  wl=new NoSpawnWorldListener(cb);
  this.cmh=new CommandHandler(this.getServer(),this.cb);
  PluginDescriptionFile pdfFile=getDescription();
  if (setupPermissions()) {
    System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  System.out.println(pdfFile.getName() + ""String_Node_Str"" + pdfFile.getVersion()+ ""String_Node_Str"");
  getServer().getPluginManager().registerEvent(Event.Type.CREATURE_SPAWN,this.el,Event.Priority.Normal,this);
  getServer().getPluginManager().registerEvent(Event.Type.WORLD_LOAD,this.wl,Event.Priority.Normal,this);
}",0.9903234724910146
183916,"public void onWorldLoad(WorldLoadEvent event){
  World w=event.getWorld();
  cb.worldSpawns.put(w,new Spawns());
  if (config.getKeys(""String_Node_Str"") != null && config.getKeys(""String_Node_Str"").contains(w.getName())) {
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SHEEP,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.COW,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CHICKEN,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG_ZOMBIE,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SQUID,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.WOLF,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.ZOMBIE,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SKELETON,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SPIDER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CREEPER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SLIME,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GHAST,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SPIDER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GIANT,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).AnimalBlockBlackList=getBlacklist(config.getString(""String_Node_Str"",""String_Node_Str""));
    this.cb.worldSpawns.get(w).MonterBlockBlacklist=getBlacklist(config.getString(""String_Node_Str"",""String_Node_Str""));
  }
 else {
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str"");
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str"");
    config.save();
    System.out.println(""String_Node_Str"" + w.getName() + ""String_Node_Str"");
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SHEEP,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.COW,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CHICKEN,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG_ZOMBIE,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SQUID,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.WOLF,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.ZOMBIE,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SKELETON,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SPIDER,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CREEPER,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SLIME,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GHAST,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GIANT,true);
    this.cb.worldSpawns.get(w).AnimalBlockBlackList=getBlacklist(config.getString(""String_Node_Str"",""String_Node_Str""));
    this.cb.worldSpawns.get(w).MonterBlockBlacklist=getBlacklist(config.getString(""String_Node_Str"",""String_Node_Str""));
  }
}","public void onWorldLoad(WorldLoadEvent event){
  World w=event.getWorld();
  cb.worldSpawns.put(w,new Spawns());
  if (config.getKeys(""String_Node_Str"") != null && config.getKeys(""String_Node_Str"").contains(w.getName())) {
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SHEEP,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.COW,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CHICKEN,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG_ZOMBIE,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SQUID,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.WOLF,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.ZOMBIE,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SKELETON,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SPIDER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CREEPER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SLIME,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GHAST,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SPIDER,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GIANT,config.getBoolean(""String_Node_Str"" + w.getName() + ""String_Node_Str"",true));
    this.cb.worldSpawns.get(w).AnimalBlockBlackList=getBlacklist(config.getString(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str""));
    this.cb.worldSpawns.get(w).MonterBlockBlacklist=getBlacklist(config.getString(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str""));
  }
 else {
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",Boolean.valueOf(true));
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str"");
    config.setProperty(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str"");
    config.save();
    System.out.println(""String_Node_Str"" + w.getName() + ""String_Node_Str"");
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SHEEP,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.COW,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CHICKEN,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.PIG_ZOMBIE,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SQUID,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.WOLF,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.ZOMBIE,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SKELETON,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SPIDER,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.CREEPER,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.SLIME,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GHAST,true);
    this.cb.worldSpawns.get(w).SpawnAllowed.put(CreatureType.GIANT,true);
    this.cb.worldSpawns.get(w).AnimalBlockBlackList=getBlacklist(config.getString(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str""));
    this.cb.worldSpawns.get(w).MonterBlockBlacklist=getBlacklist(config.getString(""String_Node_Str"" + w.getName() + ""String_Node_Str"",""String_Node_Str""));
  }
}",0.9882616951493182
183917,"public NoSpawnWorldListener(ConfigBuffer cb,Configuration config){
  this.cb=cb;
  this.config=config;
}","public NoSpawnWorldListener(ConfigBuffer cb){
  this.cb=cb;
  this.config=cb.plugin.getConfiguration();
}",0.7942583732057417
183918,"public void addSample(double sample){
  sample=Model.airAbsoption(this.dist,sample);
  delayLine[currentSampleIndex]=delayLine[currentSampleIndex] + sample;
}","public void addSample(double sample){
  delayLine[currentSampleIndex]=delayLine[currentSampleIndex] + sample;
}",0.8252788104089219
183919,"public double getCurrentSample(){
  double ret=0.0;
  if (currentSampleIndex + 1 == delayLine.length - 1) {
    ret=(delayLine[delayLine.length - 1]) * 0.5;
    int index=(currentSampleIndex + 1) % (delayLine.length - 1);
    ret=ret + (delayLine[index] * 0.5);
  }
 else {
    int index=(currentSampleIndex + 1) % (delayLine.length - 1);
    ret=delayLine[index];
  }
  return ret;
}","public double getCurrentSample(){
  double ret=0.0;
  if (currentSampleIndex + 1 == delayLine.length - 1) {
    ret=(delayLine[delayLine.length - 1]) * 0.5;
    int index=(currentSampleIndex + 1) % (delayLine.length - 1);
    ret=ret + (delayLine[index] * 0.5);
  }
 else {
    int index=(currentSampleIndex + 1) % (delayLine.length - 1);
    ret=delayLine[index];
  }
  ret=Model.airAbsoption(this.dist,ret);
  return ret;
}",0.9493201483312732
183920,"public void keyPressed(){
  if (key == 's') {
    Processor proc=new Processor(this.model);
    Thread procThread=new Thread(proc);
    procThread.start();
  }
}","public void keyPressed(){
  if (key == 's') {
    Processor proc=new Processor(this.model);
    Thread procThread=new Thread(proc);
    procThread.start();
  }
  if (key == 'd') {
    drawDelaylines=drawDelaylines ^ true;
  }
}",0.8298969072164949
183921,"public void draw(){
  background(32);
  lights();
  pushMatrix();
  translate(width / 2,height / 2,0);
  rotateX(rotY);
  rotateY(rotX);
  scale(1.5f);
  for (int j=0; j < model.getSegmentCount(); j++) {
    Segment segment=model.getSegment(j);
    Face[] faces=segment.getFaces();
    drawFaces(faces);
  }
  scale(3.0f);
  stroke(0,0,255);
  Collection<Edge> edges=model.getGraph().getEdges();
  for (  Edge<Double> e : edges) {
    beginShape(LINES);
    Pair<Node> nodes=model.getGraph().getEndpoints(e);
    Node src=nodes.getFirst();
    Node dst=nodes.getSecond();
    if (!e.visited) {
      if (src.type == Node.NodeType.wall) {
        stroke(255,255,255);
      }
 else       if (dst.type == Node.NodeType.wall) {
        stroke(0,255,255);
      }
 else {
        stroke(255,255,0);
      }
    }
 else {
      stroke(255,0,0);
    }
    vertex(src.pos.x,src.pos.y,src.pos.z);
    vertex(dst.pos.x,dst.pos.y,dst.pos.z);
    endShape();
    if (dst.type == Node.NodeType.listener) {
      fill(255,0,0);
      pushMatrix();
      drawPoint(dst.pos);
      popMatrix();
    }
 else     if (src.type == Node.NodeType.source) {
      fill(0,255,0);
      pushMatrix();
      drawPoint(src.pos);
      popMatrix();
    }
  }
  popMatrix();
}","public void draw(){
  background(32);
  lights();
  pushMatrix();
  translate(width / 2,height / 2,0);
  rotateX(rotY);
  rotateY(rotX);
  scale(1.5f);
  for (int j=0; j < model.getSegmentCount(); j++) {
    Segment segment=model.getSegment(j);
    Face[] faces=segment.getFaces();
    drawFaces(faces);
  }
  scale(3.0f);
  stroke(0,0,255);
  Collection<Edge> edges=model.getGraph().getEdges();
  for (  Edge<Double> e : edges) {
    Pair<Node> nodes=model.getGraph().getEndpoints(e);
    Node src=nodes.getFirst();
    Node dst=nodes.getSecond();
    if (drawDelaylines) {
      pushMatrix();
      beginShape(LINES);
      if (!e.visited) {
        if (src.type == Node.NodeType.wall) {
          stroke(255,255,255);
        }
 else         if (dst.type == Node.NodeType.wall) {
          stroke(0,255,255);
        }
 else {
          stroke(255,255,0);
        }
      }
 else {
        stroke(255,0,0);
      }
      vertex(src.pos.x,src.pos.y,src.pos.z);
      vertex(dst.pos.x,dst.pos.y,dst.pos.z);
      endShape();
    }
    if (dst.type == Node.NodeType.listener) {
      fill(255,0,0);
      pushMatrix();
      drawPoint(dst.pos);
      popMatrix();
    }
 else     if (src.type == Node.NodeType.source) {
      fill(0,255,0);
      pushMatrix();
      drawPoint(src.pos);
      popMatrix();
    }
    if (drawDelaylines) {
      popMatrix();
    }
  }
  popMatrix();
}",0.8605093120486507
183922,"/** 
 * analyze, as its name suggests, analyzes a RevisionNode list and finds helpful data on the revisions as a whole data found includes: max/min/average relevance rating max/min/average number of files changed i a revision average number of relevant files file groupings
 */
public void analyze(){
  String previousRev=""String_Node_Str"";
  Iterator<RevisionNode> runThrough=toAnalyze.iterator();
  RevisionNode next=null;
  while (runThrough.hasNext()) {
    next=runThrough.next();
    revisions[toAnalyze.indexOf(next)]=""String_Node_Str"" + next.getRevision();
    relevants[toAnalyze.indexOf(next)]=Integer.toString(next.getNumberOfRelevants());
    if (next.getTotalChanges() - next.getNumberOfRelevants() >= 0) {
      irrelevants[toAnalyze.indexOf(next)]=Integer.toString(next.getTotalChanges() - next.getNumberOfRelevants());
    }
 else {
      irrelevants[toAnalyze.indexOf(next)]=""String_Node_Str"";
    }
    ratings[toAnalyze.indexOf(next)]=Double.toString(next.getRating());
    Calendar thisTime=new GregorianCalendar(Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[1]) - 1,Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[2]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[1]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[2]));
    if (highestRating == -1) {
      lastTime=new GregorianCalendar(Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[1]) - 1,Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[2]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[1]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[2]));
      now=""String_Node_Str"" + next.getRevision() + ""String_Node_Str""+ next.getDate()+ ""String_Node_Str"";
      previousRev=next.getRevision();
    }
 else {
      long timeDiff=lastTime.getTimeInMillis() - thisTime.getTimeInMillis();
      flowOfTime[toAnalyze.indexOf(next) - 1]=Long.toString(timeDiff / 1000 / 60/ 60);
      revisionsToo[toAnalyze.indexOf(next) - 1]=next.getRevision() + ""String_Node_Str"" + previousRev;
      if (timeDiff > timeDiffHigh) {
        timeDiffHigh=timeDiff;
        revisionReference[4]=next.getRevision() + ""String_Node_Str"" + previousRev;
      }
      if (timeDiff < timeDiffLow) {
        timeDiffLow=timeDiff;
        revisionReference[5]=next.getRevision() + ""String_Node_Str"" + previousRev;
      }
      timeDiffAverage+=timeDiff;
      lastTime=thisTime;
    }
    relevantPresent[next.getNumberOfRelevants() - 1]+=1;
    if ((next.getTotalChanges() - next.getNumberOfRelevants()) < (10 * next.getNumberOfRelevants())) {
      irrelevantPresent[next.getNumberOfRelevants() - 1]+=1;
    }
    String files=""String_Node_Str"";
    Iterator<String> listIt=next.getRelevantFiles().iterator();
    while (listIt.hasNext()) {
      String nextFile=listIt.next();
      nextFile=nextFile.substring(nextFile.lastIndexOf('/') + 1);
      if (listIt.hasNext()) {
        files+=nextFile + ""String_Node_Str"";
      }
 else {
        files+=nextFile;
      }
    }
    grouping.newInput(files);
    relevantAverage+=next.getNumberOfRelevants();
    ratingAverage+=next.getRating();
    nFilesAverage+=next.getTotalChanges();
    if (next.getRating() > highestRating) {
      highestRating=next.getRating() * 100000;
      highestRating=Math.round(highestRating);
      highestRating/=100000;
      revisionReference[0]=next.getRevision();
    }
    if (next.getRating() < lowestRating) {
      lowestRating=next.getRating() * 100000;
      lowestRating=Math.round(lowestRating);
      lowestRating/=100000;
      revisionReference[1]=next.getRevision();
    }
    if (next.getTotalChanges() > highestFileNumber) {
      highestFileNumber=next.getTotalChanges();
      revisionReference[2]=next.getRevision();
    }
    if (next.getTotalChanges() < lowestFileNumber) {
      lowestFileNumber=next.getTotalChanges();
      revisionReference[3]=next.getRevision();
    }
    previousRev=next.getRevision();
  }
  if (next != null) {
    then=""String_Node_Str"" + next.getRevision() + ""String_Node_Str""+ next.getDate()+ ""String_Node_Str"";
    ratingAverage=(ratingAverage / revisionTotal) * 100000;
    ratingAverage=Math.round(ratingAverage);
    ratingAverage/=100000;
    nFilesAverage=nFilesAverage / revisionTotal;
    relevantAverage=relevantAverage / revisionTotal;
    timeDiffAverage=(((timeDiffAverage / (revisionTotal - 1)) / 1000) / 60) / 60;
  }
}","/** 
 * analyze, as its name suggests, analyzes a RevisionNode list and finds helpful data on the revisions as a whole data found includes: max/min/average relevance rating max/min/average number of files changed i a revision average number of relevant files file groupings
 */
public void analyze(){
  String previousRev=""String_Node_Str"";
  Iterator<RevisionNode> runThrough=toAnalyze.iterator();
  RevisionNode next=null;
  while (runThrough.hasNext()) {
    next=runThrough.next();
    revisions[toAnalyze.indexOf(next)]=""String_Node_Str"" + next.getRevision();
    relevants[toAnalyze.indexOf(next)]=Integer.toString(next.getNumberOfRelevants());
    if (next.getTotalChanges() - next.getNumberOfRelevants() >= 0) {
      irrelevants[toAnalyze.indexOf(next)]=Integer.toString(next.getTotalChanges() - next.getNumberOfRelevants());
    }
 else {
      irrelevants[toAnalyze.indexOf(next)]=""String_Node_Str"";
    }
    ratings[toAnalyze.indexOf(next)]=Double.toString(next.getRating());
    Calendar thisTime=new GregorianCalendar(Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[1]) - 1,Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[2]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[1]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[2]));
    if (highestRating == -1) {
      lastTime=new GregorianCalendar(Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[1]) - 1,Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[2]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[1]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[2]));
      now=""String_Node_Str"" + next.getRevision() + ""String_Node_Str""+ next.getDate()+ ""String_Node_Str"";
      previousRev=next.getRevision();
    }
 else {
      long timeDiff=lastTime.getTimeInMillis() - thisTime.getTimeInMillis();
      flowOfTime[toAnalyze.indexOf(next) - 1]=Long.toString(timeDiff / 1000 / 60/ 60);
      revisionsToo[toAnalyze.indexOf(next) - 1]=next.getRevision() + ""String_Node_Str"" + previousRev;
      if (timeDiff > timeDiffHigh) {
        timeDiffHigh=timeDiff;
        revisionReference[4]=next.getRevision() + ""String_Node_Str"" + previousRev;
      }
      if (timeDiff < timeDiffLow) {
        timeDiffLow=timeDiff;
        revisionReference[5]=next.getRevision() + ""String_Node_Str"" + previousRev;
      }
      timeDiffAverage+=timeDiff;
      lastTime=thisTime;
    }
    relevantPresent[next.getNumberOfRelevants() - 1]+=1;
    if ((next.getTotalChanges() - next.getNumberOfRelevants()) < (10 * next.getNumberOfRelevants())) {
      irrelevantPresent[next.getNumberOfRelevants() - 1]+=1;
    }
    String files=""String_Node_Str"";
    Iterator<String> listIt=next.getRelevantFiles().iterator();
    while (listIt.hasNext()) {
      String nextFile=listIt.next();
      nextFile=nextFile.substring(nextFile.lastIndexOf('/') + 1);
      if (listIt.hasNext()) {
        files+=nextFile + ""String_Node_Str"";
      }
 else {
        files+=nextFile;
      }
    }
    grouping.newInput(files);
    relevantAverage+=next.getNumberOfRelevants();
    ratingAverage+=next.getRating();
    nFilesAverage+=next.getTotalChanges();
    if (next.getRating() > highestRating) {
      highestRating=next.getRating() * 100000;
      highestRating=Math.round(highestRating);
      highestRating/=100000;
      revisionReference[0]=next.getRevision();
    }
    if (next.getRating() < lowestRating) {
      lowestRating=next.getRating() * 100000;
      lowestRating=Math.round(lowestRating);
      lowestRating/=100000;
      revisionReference[1]=next.getRevision();
    }
    if (next.getTotalChanges() > highestFileNumber) {
      highestFileNumber=next.getTotalChanges();
      revisionReference[2]=next.getRevision();
    }
    if (next.getTotalChanges() < lowestFileNumber) {
      lowestFileNumber=next.getTotalChanges();
      revisionReference[3]=next.getRevision();
    }
    previousRev=next.getRevision();
  }
  if (next != null) {
    then=""String_Node_Str"" + next.getRevision() + ""String_Node_Str""+ next.getDate()+ ""String_Node_Str"";
    ratingAverage=(ratingAverage / revisionTotal) * 100000;
    ratingAverage=Math.round(ratingAverage);
    ratingAverage/=100000;
    nFilesAverage=nFilesAverage / revisionTotal;
    relevantAverage=relevantAverage / revisionTotal;
    if (revisionTotal > 1) {
      timeDiffAverage=timeDiffAverage / (revisionTotal - 1);
    }
 else {
      timeDiffLow=0;
      timeDiffHigh=0;
      revisionReference[4]=""String_Node_Str"";
      revisionReference[5]=""String_Node_Str"";
    }
  }
}",0.979292579015159
183923,"/** 
 * prints out all of the statistics that have been gathered from the log analysis and grouping code
 * @throws IOException 
 */
public void statsOut() throws IOException {
  analyze();
  int i;
  if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") | bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
  }
  if (lowestRating == 2) {
    System.out.println(""String_Node_Str"");
  }
 else {
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + then + ""String_Node_Str""+ now+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + revisionTotal);
      System.out.println(""String_Node_Str"" + Math.round(relevantAverage) + ""String_Node_Str"");
      for (i=0; i < args.length; i++) {
        System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ relevantPresent[i]);
        System.out.println(""String_Node_Str"" + (10 * (i + 1)) + ""String_Node_Str""+ irrelevantPresent[i]+ ""String_Node_Str"");
      }
      System.out.println();
      System.out.println(""String_Node_Str"" + timeDiffAverage + ""String_Node_Str"");
      if (timeDiffLow / 1000 / 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 + ""String_Node_Str"" + revisionReference[5]);
      }
 else       if (timeDiffLow / 1000 / 60/ 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 / 60 + ""String_Node_Str"" + revisionReference[5]);
      }
 else {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 / 60/ 60 + ""String_Node_Str"" + revisionReference[5]);
      }
      System.out.println(""String_Node_Str"" + timeDiffHigh / 1000 / 60/ 60 + ""String_Node_Str"" + revisionReference[4] + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + ratingAverage);
      System.out.println(""String_Node_Str"" + lowestRating + ""String_Node_Str""+ revisionReference[1]);
      System.out.println(""String_Node_Str"" + highestRating + ""String_Node_Str""+ revisionReference[0]+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + nFilesAverage);
      System.out.println(""String_Node_Str"" + lowestFileNumber + ""String_Node_Str""+ revisionReference[3]);
      System.out.println(""String_Node_Str"" + highestFileNumber + ""String_Node_Str""+ revisionReference[2]+ ""String_Node_Str"");
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      grouping.currentOutput();
    }
    if (args.length > 1) {
      if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
        percentages(args);
      }
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      System.out.println();
      FileWriter f=new FileWriter(bundle.getString(""String_Node_Str""));
      PrintWriter p=new PrintWriter(f);
      Object[][] input={revisionsToo,flowOfTime};
      CSVWork(input,p,f);
      Object[][] nextInput={revisions,ratings};
      CSVWork(nextInput,p,f);
      nextInput[1]=irrelevants;
      CSVWork(nextInput,p,f);
      nextInput[1]=relevants;
      CSVWork(nextInput,p,f);
      nextInput[0]=intervals;
      nextInput[1]=commits;
      CSVWork(nextInput,p,f);
      p.flush();
      p.close();
      f.close();
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      int j;
      String pathFull=""String_Node_Str"";
      DiffParser dp=new DiffParser(args);
      String path=bundle.getString(bundle.getString(""String_Node_Str""));
      System.out.print(""String_Node_Str"");
      for (i=0; i < args.length; i++) {
        System.out.print(""String_Node_Str"" + args[i].substring(args[i].lastIndexOf('/')));
      }
      System.out.println(""String_Node_Str"");
      for (i=0; i < revisionsToo.length - 1; i++) {
        System.out.print(""String_Node_Str"" + revisionsToo[i] + ""String_Node_Str"");
        for (j=0; j < args.length; j++) {
          pathFull=path + args[j] + ""String_Node_Str"";
          Process exec=Runtime.getRuntime().exec(""String_Node_Str"" + revisionsToo[i].split(""String_Node_Str"")[0] + ""String_Node_Str""+ revisionsToo[i].split(""String_Node_Str"")[1]+ ""String_Node_Str""+ pathFull);
          dp.diffOut(exec);
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
  if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") | bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * prints out all of the statistics that have been gathered from the log analysis and grouping code
 * @throws IOException 
 */
public void statsOut() throws IOException {
  analyze();
  int i;
  if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") | bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
  }
  if (lowestRating == 2) {
    System.out.println(""String_Node_Str"");
  }
 else {
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + then + ""String_Node_Str""+ now+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + revisionTotal);
      System.out.println(""String_Node_Str"" + Math.round(relevantAverage) + ""String_Node_Str"");
      for (i=0; i < args.length; i++) {
        System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ relevantPresent[i]);
        System.out.println(""String_Node_Str"" + (10 * (i + 1)) + ""String_Node_Str""+ irrelevantPresent[i]+ ""String_Node_Str"");
      }
      System.out.println();
      if (timeDiffLow / 1000 / 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffAverage / 1000 + ""String_Node_Str"");
      }
 else       if (timeDiffLow / 1000 / 60/ 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffAverage / 1000 / 60 + ""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"" + timeDiffAverage / 1000 / 60/ 60 + ""String_Node_Str"");
      }
      if (timeDiffLow / 1000 / 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 + ""String_Node_Str"" + revisionReference[5]);
      }
 else       if (timeDiffLow / 1000 / 60/ 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 / 60 + ""String_Node_Str"" + revisionReference[5]);
      }
 else {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 / 60/ 60 + ""String_Node_Str"" + revisionReference[5]);
      }
      if (timeDiffHigh / 1000 / 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffHigh / 1000 + ""String_Node_Str"" + revisionReference[4]);
      }
 else       if (timeDiffHigh / 1000 / 60/ 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffHigh / 1000 / 60 + ""String_Node_Str"" + revisionReference[4]);
      }
 else {
        System.out.println(""String_Node_Str"" + timeDiffHigh / 1000 / 60/ 60 + ""String_Node_Str"" + revisionReference[4]);
      }
      System.out.println(""String_Node_Str"" + ratingAverage);
      System.out.println(""String_Node_Str"" + lowestRating + ""String_Node_Str""+ revisionReference[1]);
      System.out.println(""String_Node_Str"" + highestRating + ""String_Node_Str""+ revisionReference[0]+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + nFilesAverage);
      System.out.println(""String_Node_Str"" + lowestFileNumber + ""String_Node_Str""+ revisionReference[3]);
      System.out.println(""String_Node_Str"" + highestFileNumber + ""String_Node_Str""+ revisionReference[2]+ ""String_Node_Str"");
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      grouping.currentOutput();
    }
    if (args.length > 1) {
      if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
        percentages(args);
      }
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      System.out.println();
      FileWriter f=new FileWriter(bundle.getString(""String_Node_Str""));
      PrintWriter p=new PrintWriter(f);
      Object[][] input={revisionsToo,flowOfTime};
      CSVWork(input,p,f);
      Object[][] nextInput={revisions,ratings};
      CSVWork(nextInput,p,f);
      nextInput[1]=irrelevants;
      CSVWork(nextInput,p,f);
      nextInput[1]=relevants;
      CSVWork(nextInput,p,f);
      nextInput[0]=intervals;
      nextInput[1]=commits;
      CSVWork(nextInput,p,f);
      p.flush();
      p.close();
      f.close();
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") && revisionTotal > 1) {
      int j;
      String pathFull=""String_Node_Str"";
      DiffParser dp=new DiffParser(args);
      String path=bundle.getString(bundle.getString(""String_Node_Str""));
      System.out.print(""String_Node_Str"");
      for (i=0; i < args.length; i++) {
        System.out.print(""String_Node_Str"" + args[i].substring(args[i].lastIndexOf('/')));
      }
      System.out.println(""String_Node_Str"");
      for (i=0; i < revisionsToo.length - 1; i++) {
        System.out.print(""String_Node_Str"" + revisionsToo[i] + ""String_Node_Str"");
        for (j=0; j < args.length; j++) {
          pathFull=path + args[j] + ""String_Node_Str"";
          Process exec=Runtime.getRuntime().exec(""String_Node_Str"" + revisionsToo[i].split(""String_Node_Str"")[0] + ""String_Node_Str""+ revisionsToo[i].split(""String_Node_Str"")[1]+ ""String_Node_Str""+ pathFull);
          dp.diffOut(exec);
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
  if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") | bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
  }
}",0.921508462832822
183924,"/** 
 * prints out all of the statistics that have been gathered from the log analysis and grouping code
 * @throws IOException 
 */
public void statsOut() throws IOException {
  analyze();
  int i;
  if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") | bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
  }
  if (lowestRating == 2) {
    System.out.println(""String_Node_Str"");
  }
 else {
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + then + ""String_Node_Str""+ now+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + revisionTotal);
      System.out.println(""String_Node_Str"" + Math.round(relevantAverage) + ""String_Node_Str"");
      for (i=0; i < args.length; i++) {
        System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ relevantPresent[i]);
        System.out.println(""String_Node_Str"" + (10 * (i + 1)) + ""String_Node_Str""+ irrelevantPresent[i]+ ""String_Node_Str"");
      }
      System.out.println();
      if (timeDiffLow / 1000 / 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffAverage / 1000 + ""String_Node_Str"");
      }
 else       if (timeDiffLow / 1000 / 60/ 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffAverage / 1000 / 60 + ""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"" + timeDiffAverage / 1000 / 60/ 60 + ""String_Node_Str"");
      }
      if (timeDiffLow / 1000 / 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 + ""String_Node_Str"" + revisionReference[5]);
      }
 else       if (timeDiffLow / 1000 / 60/ 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 / 60 + ""String_Node_Str"" + revisionReference[5]);
      }
 else {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 / 60/ 60 + ""String_Node_Str"" + revisionReference[5]);
      }
      if (timeDiffHigh / 1000 / 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffHigh / 1000 + ""String_Node_Str"" + revisionReference[4]);
      }
 else       if (timeDiffHigh / 1000 / 60/ 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffHigh / 1000 / 60 + ""String_Node_Str"" + revisionReference[4]);
      }
 else {
        System.out.println(""String_Node_Str"" + timeDiffHigh / 1000 / 60/ 60 + ""String_Node_Str"" + revisionReference[4]);
      }
      System.out.println(""String_Node_Str"" + ratingAverage);
      System.out.println(""String_Node_Str"" + lowestRating + ""String_Node_Str""+ revisionReference[1]);
      System.out.println(""String_Node_Str"" + highestRating + ""String_Node_Str""+ revisionReference[0]+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + nFilesAverage);
      System.out.println(""String_Node_Str"" + lowestFileNumber + ""String_Node_Str""+ revisionReference[3]);
      System.out.println(""String_Node_Str"" + highestFileNumber + ""String_Node_Str""+ revisionReference[2]+ ""String_Node_Str"");
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      grouping.currentOutput();
    }
    if (args.length > 1) {
      if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
        percentages(args);
      }
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      System.out.println();
      FileWriter f=new FileWriter(bundle.getString(""String_Node_Str""));
      PrintWriter p=new PrintWriter(f);
      Object[][] input={revisionsToo,flowOfTime};
      CSVWork(input,p,f);
      Object[][] nextInput={revisions,ratings};
      CSVWork(nextInput,p,f);
      nextInput[1]=irrelevants;
      CSVWork(nextInput,p,f);
      nextInput[1]=relevants;
      CSVWork(nextInput,p,f);
      nextInput[0]=intervals;
      nextInput[1]=commits;
      CSVWork(nextInput,p,f);
      p.flush();
      p.close();
      f.close();
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") && revisionTotal > 1) {
      int j;
      String pathFull=""String_Node_Str"";
      DiffParser dp=new DiffParser(args);
      String path=bundle.getString(bundle.getString(""String_Node_Str""));
      System.out.print(""String_Node_Str"");
      for (i=0; i < args.length; i++) {
        System.out.print(""String_Node_Str"" + args[i].substring(args[i].lastIndexOf('/')));
      }
      System.out.println(""String_Node_Str"");
      for (i=0; i < revisionsToo.length - 1; i++) {
        System.out.print(""String_Node_Str"" + revisionsToo[i] + ""String_Node_Str"");
        for (j=0; j < args.length; j++) {
          pathFull=path + args[j] + ""String_Node_Str"";
          Process exec=Runtime.getRuntime().exec(""String_Node_Str"" + revisionsToo[i].split(""String_Node_Str"")[0] + ""String_Node_Str""+ revisionsToo[i].split(""String_Node_Str"")[1]+ ""String_Node_Str""+ pathFull);
          dp.diffOut(exec);
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
  if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") | bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * prints out all of the statistics that have been gathered from the log analysis and grouping code
 * @throws IOException 
 */
public void statsOut() throws IOException {
  analyze();
  int i;
  if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") | bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
  }
  if (lowestRating == 2) {
    System.out.println(""String_Node_Str"");
  }
 else {
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"" + then + ""String_Node_Str""+ now+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + revisionTotal);
      System.out.println(""String_Node_Str"" + Math.round(relevantAverage) + ""String_Node_Str"");
      for (i=0; i < args.length; i++) {
        System.out.println(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ relevantPresent[i]);
        System.out.println(""String_Node_Str"" + (10 * (i + 1)) + ""String_Node_Str""+ irrelevantPresent[i]+ ""String_Node_Str"");
      }
      System.out.println();
      if (timeDiffAverage / 1000 / 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffAverage / 1000 + ""String_Node_Str"");
      }
 else       if (timeDiffAverage / 1000 / 60/ 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffAverage / 1000 / 60 + ""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"" + timeDiffAverage / 1000 / 60/ 60 + ""String_Node_Str"");
      }
      if (timeDiffLow / 1000 / 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 + ""String_Node_Str"" + revisionReference[5]);
      }
 else       if (timeDiffLow / 1000 / 60/ 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 / 60 + ""String_Node_Str"" + revisionReference[5]);
      }
 else {
        System.out.println(""String_Node_Str"" + timeDiffLow / 1000 / 60/ 60 + ""String_Node_Str"" + revisionReference[5]);
      }
      if (timeDiffHigh / 1000 / 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffHigh / 1000 + ""String_Node_Str"" + revisionReference[4]);
      }
 else       if (timeDiffHigh / 1000 / 60/ 60 < 1) {
        System.out.println(""String_Node_Str"" + timeDiffHigh / 1000 / 60 + ""String_Node_Str"" + revisionReference[4]);
      }
 else {
        System.out.println(""String_Node_Str"" + timeDiffHigh / 1000 / 60/ 60 + ""String_Node_Str"" + revisionReference[4]);
      }
      System.out.println(""String_Node_Str"" + ratingAverage);
      System.out.println(""String_Node_Str"" + lowestRating + ""String_Node_Str""+ revisionReference[1]);
      System.out.println(""String_Node_Str"" + highestRating + ""String_Node_Str""+ revisionReference[0]+ ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + nFilesAverage);
      System.out.println(""String_Node_Str"" + lowestFileNumber + ""String_Node_Str""+ revisionReference[3]);
      System.out.println(""String_Node_Str"" + highestFileNumber + ""String_Node_Str""+ revisionReference[2]+ ""String_Node_Str"");
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      grouping.currentOutput();
    }
    if (args.length > 1) {
      if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
        percentages(args);
      }
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      System.out.println();
      FileWriter f=new FileWriter(bundle.getString(""String_Node_Str""));
      PrintWriter p=new PrintWriter(f);
      Object[][] input={revisionsToo,flowOfTime};
      CSVWork(input,p,f);
      Object[][] nextInput={revisions,ratings};
      CSVWork(nextInput,p,f);
      nextInput[1]=irrelevants;
      CSVWork(nextInput,p,f);
      nextInput[1]=relevants;
      CSVWork(nextInput,p,f);
      nextInput[0]=intervals;
      nextInput[1]=commits;
      CSVWork(nextInput,p,f);
      p.flush();
      p.close();
      f.close();
    }
    if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") && revisionTotal > 1) {
      int j;
      String pathFull=""String_Node_Str"";
      DiffParser dp=new DiffParser(args);
      String path=bundle.getString(bundle.getString(""String_Node_Str""));
      System.out.print(""String_Node_Str"");
      for (i=0; i < args.length; i++) {
        System.out.print(""String_Node_Str"" + args[i].substring(args[i].lastIndexOf('/')));
      }
      System.out.println(""String_Node_Str"");
      for (i=0; i < revisionsToo.length - 1; i++) {
        System.out.print(""String_Node_Str"" + revisionsToo[i] + ""String_Node_Str"");
        for (j=0; j < args.length; j++) {
          pathFull=path + args[j] + ""String_Node_Str"";
          Process exec=Runtime.getRuntime().exec(""String_Node_Str"" + revisionsToo[i].split(""String_Node_Str"")[0] + ""String_Node_Str""+ revisionsToo[i].split(""String_Node_Str"")[1]+ ""String_Node_Str""+ pathFull);
          dp.diffOut(exec);
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
  if (bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") || bundle.getString(""String_Node_Str"").equals(""String_Node_Str"") | bundle.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
  }
}",0.9842592592592592
183925,"/** 
 * String representation of the node
 * @return all data in String form
 */
public String toString(){
  String out=""String_Node_Str"";
  String files=""String_Node_Str"";
  Iterator<String> listIt=this.getRelevantFiles().iterator();
  while (listIt.hasNext()) {
    String nextFile=listIt.next();
    nextFile=nextFile.substring(nextFile.lastIndexOf('/'));
    files+=nextFile + ""String_Node_Str"";
  }
  String use=user;
  if (use.length() < 8) {
    use+=""String_Node_Str"";
  }
  double rat=this.getRating() * 100000;
  rat=Math.round(rat);
  rat/=100000;
  out=revision + ""String_Node_Str"" + use+ ""String_Node_Str""+ date+ ""String_Node_Str""+ Integer.toString(numberOfRelevants)+ ""String_Node_Str""+ Integer.toString(totalQuery)+ ""String_Node_Str""+ Integer.toString(totalChanges)+ ""String_Node_Str""+ rat+ ""String_Node_Str""+ ratingComment+ ""String_Node_Str""+ files;
  return out;
}","/** 
 * String representation of the node
 * @return all data in String form
 */
public String toString(){
  String out=""String_Node_Str"";
  String files=""String_Node_Str"";
  Iterator<String> listIt=this.getRelevantFiles().iterator();
  while (listIt.hasNext()) {
    String nextFile=listIt.next();
    nextFile=nextFile.substring(nextFile.lastIndexOf('/'));
    if (listIt.hasNext()) {
      files+=nextFile + ""String_Node_Str"";
    }
 else {
      files+=nextFile;
    }
  }
  String use=user;
  if (use.length() < 8) {
    use+=""String_Node_Str"";
  }
  double rat=this.getRating() * 100000;
  rat=Math.round(rat);
  rat/=100000;
  out=revision + ""String_Node_Str"" + use+ ""String_Node_Str""+ date+ ""String_Node_Str""+ Integer.toString(numberOfRelevants)+ ""String_Node_Str""+ Integer.toString(totalQuery)+ ""String_Node_Str""+ Integer.toString(totalChanges)+ ""String_Node_Str""+ rat+ ""String_Node_Str""+ ratingComment+ ""String_Node_Str""+ files;
  return out;
}",0.9525885558583106
183926,"/** 
 * String representation of the node
 * @return all data in String form
 */
public String toString(){
  String out=""String_Node_Str"";
  String files=""String_Node_Str"";
  Iterator<String> listIt=this.getRelevantFiles().iterator();
  while (listIt.hasNext()) {
    String nextFile=listIt.next();
    nextFile=nextFile.substring(nextFile.lastIndexOf('/'));
    if (listIt.hasNext()) {
      files+=nextFile + ""String_Node_Str"";
    }
 else {
      files+=nextFile;
    }
  }
  String use=user;
  if (use.length() < 8) {
    use+=""String_Node_Str"";
  }
  double rat=this.getRating() * 100000;
  rat=Math.round(rat);
  rat/=100000;
  out=revision + ""String_Node_Str"" + use+ ""String_Node_Str""+ date+ ""String_Node_Str""+ Integer.toString(numberOfRelevants)+ ""String_Node_Str""+ Integer.toString(totalQuery)+ ""String_Node_Str""+ Integer.toString(totalChanges)+ ""String_Node_Str""+ rat+ ""String_Node_Str""+ ratingComment+ ""String_Node_Str""+ files;
  return out;
}","/** 
 * String representation of the node
 * @return all data in String form
 */
public String toString(){
  String out=""String_Node_Str"";
  String files=""String_Node_Str"";
  Iterator<String> listIt=this.getRelevantFiles().iterator();
  while (listIt.hasNext()) {
    String nextFile=listIt.next();
    nextFile=nextFile.substring(nextFile.lastIndexOf('/') + 1);
    if (listIt.hasNext()) {
      files+=nextFile + ""String_Node_Str"";
    }
 else {
      files+=nextFile;
    }
  }
  String use=user;
  if (use.length() < 8) {
    use+=""String_Node_Str"";
  }
  double rat=this.getRating() * 100000;
  rat=Math.round(rat);
  rat/=100000;
  out=revision + ""String_Node_Str"" + use+ ""String_Node_Str""+ date+ ""String_Node_Str""+ Integer.toString(numberOfRelevants)+ ""String_Node_Str""+ Integer.toString(totalQuery)+ ""String_Node_Str""+ Integer.toString(totalChanges)+ ""String_Node_Str""+ rat+ ""String_Node_Str""+ ratingComment+ ""String_Node_Str""+ files;
  return out;
}",0.997907949790795
183927,"/** 
 * analyze, as its name suggests, analyzes a RevisionNode list and finds helpful data on the revisions as a whole data found includes: max/min/average relevance rating max/min/average number of files changed i a revision average number of relevant files file groupings
 */
public void analyze(){
  String previousRev=""String_Node_Str"";
  Iterator<RevisionNode> runThrough=toAnalyze.iterator();
  RevisionNode next=null;
  while (runThrough.hasNext()) {
    next=runThrough.next();
    revisions[toAnalyze.indexOf(next)]=""String_Node_Str"" + next.getRevision();
    relevants[toAnalyze.indexOf(next)]=Integer.toString(next.getNumberOfRelevants());
    irrelevants[toAnalyze.indexOf(next)]=Integer.toString(next.getTotalChanges() - next.getNumberOfRelevants());
    ratings[toAnalyze.indexOf(next)]=Double.toString(next.getRating());
    Calendar thisTime=new GregorianCalendar(Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[1]) - 1,Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[2]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[1]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[2]));
    if (highestRating == -1) {
      lastTime=new GregorianCalendar(Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[1]) - 1,Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[2]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[1]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[2]));
      now=""String_Node_Str"" + next.getRevision() + ""String_Node_Str""+ next.getDate()+ ""String_Node_Str"";
      previousRev=next.getRevision();
    }
 else {
      long timeDiff=lastTime.getTimeInMillis() - thisTime.getTimeInMillis();
      flowOfTime[toAnalyze.indexOf(next) - 1]=Long.toString(timeDiff / 1000 / 60/ 60);
      revisionsToo[toAnalyze.indexOf(next) - 1]=next.getRevision() + ""String_Node_Str"" + previousRev;
      if (timeDiff > timeDiffHigh) {
        timeDiffHigh=timeDiff;
        revisionReference[4]=next.getRevision() + ""String_Node_Str"" + previousRev;
      }
      if (timeDiff < timeDiffLow) {
        timeDiffLow=timeDiff;
        revisionReference[5]=next.getRevision() + ""String_Node_Str"" + previousRev;
      }
      timeDiffAverage+=timeDiff;
      lastTime=thisTime;
    }
    relevantPresent[next.getNumberOfRelevants() - 1]+=1;
    if ((next.getTotalChanges() - next.getNumberOfRelevants()) < (10 * next.getNumberOfRelevants())) {
      irrelevantPresent[next.getNumberOfRelevants() - 1]+=1;
    }
    String files=""String_Node_Str"";
    Iterator<String> listIt=next.getRelevantFiles().iterator();
    while (listIt.hasNext()) {
      String nextFile=listIt.next();
      nextFile=nextFile.substring(nextFile.lastIndexOf('/') + 1);
      if (listIt.hasNext()) {
        files+=nextFile + ""String_Node_Str"";
      }
 else {
        files+=nextFile;
      }
    }
    grouping.newInput(files);
    relevantAverage+=next.getNumberOfRelevants();
    ratingAverage+=next.getRating();
    nFilesAverage+=next.getTotalChanges();
    if (next.getRating() > highestRating) {
      highestRating=next.getRating() * 100000;
      highestRating=Math.round(highestRating);
      highestRating/=100000;
      revisionReference[0]=next.getRevision();
    }
    if (next.getRating() < lowestRating) {
      lowestRating=next.getRating() * 100000;
      lowestRating=Math.round(lowestRating);
      lowestRating/=100000;
      revisionReference[1]=next.getRevision();
    }
    if (next.getTotalChanges() > highestFileNumber) {
      highestFileNumber=next.getTotalChanges();
      revisionReference[2]=next.getRevision();
    }
    if (next.getTotalChanges() < lowestFileNumber) {
      lowestFileNumber=next.getTotalChanges();
      revisionReference[3]=next.getRevision();
    }
    previousRev=next.getRevision();
  }
  if (next != null) {
    then=""String_Node_Str"" + next.getRevision() + ""String_Node_Str""+ next.getDate()+ ""String_Node_Str"";
    ratingAverage=(ratingAverage / revisionTotal) * 100000;
    ratingAverage=Math.round(ratingAverage);
    ratingAverage/=100000;
    nFilesAverage=nFilesAverage / revisionTotal;
    relevantAverage=relevantAverage / revisionTotal;
    timeDiffAverage=(((timeDiffAverage / (revisionTotal - 1)) / 1000) / 60) / 60;
  }
}","/** 
 * analyze, as its name suggests, analyzes a RevisionNode list and finds helpful data on the revisions as a whole data found includes: max/min/average relevance rating max/min/average number of files changed i a revision average number of relevant files file groupings
 */
public void analyze(){
  String previousRev=""String_Node_Str"";
  Iterator<RevisionNode> runThrough=toAnalyze.iterator();
  RevisionNode next=null;
  while (runThrough.hasNext()) {
    next=runThrough.next();
    revisions[toAnalyze.indexOf(next)]=""String_Node_Str"" + next.getRevision();
    relevants[toAnalyze.indexOf(next)]=Integer.toString(next.getNumberOfRelevants());
    if (next.getTotalChanges() - next.getNumberOfRelevants() >= 0) {
      irrelevants[toAnalyze.indexOf(next)]=Integer.toString(next.getTotalChanges() - next.getNumberOfRelevants());
    }
 else {
      irrelevants[toAnalyze.indexOf(next)]=""String_Node_Str"";
    }
    ratings[toAnalyze.indexOf(next)]=Double.toString(next.getRating());
    Calendar thisTime=new GregorianCalendar(Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[1]) - 1,Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[2]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[1]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[2]));
    if (highestRating == -1) {
      lastTime=new GregorianCalendar(Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[1]) - 1,Integer.parseInt(next.getDate().split(""String_Node_Str"")[0].split(""String_Node_Str"")[2]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[0]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[1]),Integer.parseInt(next.getDate().split(""String_Node_Str"")[1].split(""String_Node_Str"")[2]));
      now=""String_Node_Str"" + next.getRevision() + ""String_Node_Str""+ next.getDate()+ ""String_Node_Str"";
      previousRev=next.getRevision();
    }
 else {
      long timeDiff=lastTime.getTimeInMillis() - thisTime.getTimeInMillis();
      flowOfTime[toAnalyze.indexOf(next) - 1]=Long.toString(timeDiff / 1000 / 60/ 60);
      revisionsToo[toAnalyze.indexOf(next) - 1]=next.getRevision() + ""String_Node_Str"" + previousRev;
      if (timeDiff > timeDiffHigh) {
        timeDiffHigh=timeDiff;
        revisionReference[4]=next.getRevision() + ""String_Node_Str"" + previousRev;
      }
      if (timeDiff < timeDiffLow) {
        timeDiffLow=timeDiff;
        revisionReference[5]=next.getRevision() + ""String_Node_Str"" + previousRev;
      }
      timeDiffAverage+=timeDiff;
      lastTime=thisTime;
    }
    relevantPresent[next.getNumberOfRelevants() - 1]+=1;
    if ((next.getTotalChanges() - next.getNumberOfRelevants()) < (10 * next.getNumberOfRelevants())) {
      irrelevantPresent[next.getNumberOfRelevants() - 1]+=1;
    }
    String files=""String_Node_Str"";
    Iterator<String> listIt=next.getRelevantFiles().iterator();
    while (listIt.hasNext()) {
      String nextFile=listIt.next();
      nextFile=nextFile.substring(nextFile.lastIndexOf('/') + 1);
      if (listIt.hasNext()) {
        files+=nextFile + ""String_Node_Str"";
      }
 else {
        files+=nextFile;
      }
    }
    grouping.newInput(files);
    relevantAverage+=next.getNumberOfRelevants();
    ratingAverage+=next.getRating();
    nFilesAverage+=next.getTotalChanges();
    if (next.getRating() > highestRating) {
      highestRating=next.getRating() * 100000;
      highestRating=Math.round(highestRating);
      highestRating/=100000;
      revisionReference[0]=next.getRevision();
    }
    if (next.getRating() < lowestRating) {
      lowestRating=next.getRating() * 100000;
      lowestRating=Math.round(lowestRating);
      lowestRating/=100000;
      revisionReference[1]=next.getRevision();
    }
    if (next.getTotalChanges() > highestFileNumber) {
      highestFileNumber=next.getTotalChanges();
      revisionReference[2]=next.getRevision();
    }
    if (next.getTotalChanges() < lowestFileNumber) {
      lowestFileNumber=next.getTotalChanges();
      revisionReference[3]=next.getRevision();
    }
    previousRev=next.getRevision();
  }
  if (next != null) {
    then=""String_Node_Str"" + next.getRevision() + ""String_Node_Str""+ next.getDate()+ ""String_Node_Str"";
    ratingAverage=(ratingAverage / revisionTotal) * 100000;
    ratingAverage=Math.round(ratingAverage);
    ratingAverage/=100000;
    nFilesAverage=nFilesAverage / revisionTotal;
    relevantAverage=relevantAverage / revisionTotal;
    timeDiffAverage=(((timeDiffAverage / (revisionTotal - 1)) / 1000) / 60) / 60;
  }
}",0.9733046946916232
183928,"public T create(T model){
  String sql=createStatement.replace(""String_Node_Str"",C.eList(values(model)).map(new Function<Pair,String>(){
    @Override public String apply(    Pair t){
      return t.key;
    }
  }
).mkString(""String_Node_Str""));
  sql(sql).executeUpdate();
  return findById(model.getId()).get();
}","public T create(T model){
  String sql=createStatement.replace(""String_Node_Str"",C.eList(values(model)).map(new Function<Pair,String>(){
    @Override public String apply(    Pair t){
      if (t.value.getClass().equals(String.class)) {
        return ""String_Node_Str"" + t.value.toString() + ""String_Node_Str"";
      }
      if (t.value.getClass().equals(Integer.class)) {
        return t.value.toString();
      }
      if (t.value.getClass().equals(Long.class)) {
        return t.value.toString();
      }
      if (t.value.getClass().equals(Double.class)) {
        return t.value.toString();
      }
      if (t.value.getClass().equals(Boolean.class)) {
        return ((Boolean)t.value) ? ""String_Node_Str"" : ""String_Node_Str"";
      }
      return ""String_Node_Str"" + t.value.toString() + ""String_Node_Str"";
    }
  }
).mkString(""String_Node_Str""));
  sql(sql).executeUpdate();
  return findById(model.getId()).get();
}",0.4875301689460981
183929,"public <A extends Table<T>>A init(Class<T> clazz,String tableName){
  this.tableName=tableName;
  this.clazz=clazz;
  this.extractors=all().extractors;
  ExtractorSeq<T> extr=all();
  if (extr.map.isDefined()) {
    this.parser=DB.parser(clazz,extractors).map(extr.map.get());
  }
 else {
    this.parser=DB.parser(clazz,extractors).mapWithFieldsReflection();
  }
  System.out.println(extractors);
  selectAllStatement=C.eList(extractors).map(new Function<Extractor<?>,String>(){
    @Override public String apply(    Extractor<?> t){
      return ""String_Node_Str"" + t.name();
    }
  }
).mkString(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tableName + ""String_Node_Str"");
  findWhereStatement=C.eList(extractors).map(new Function<Extractor<?>,String>(){
    @Override public String apply(    Extractor<?> t){
      return ""String_Node_Str"" + t.name();
    }
  }
).mkString(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tableName + ""String_Node_Str"");
  selectByIdStatement=C.eList(extractors).map(new Function<Extractor<?>,String>(){
    @Override public String apply(    Extractor<?> t){
      return ""String_Node_Str"" + t.name();
    }
  }
).mkString(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tableName + ""String_Node_Str"");
  deleteAllStatement=""String_Node_Str"" + tableName;
  deleteStatement=""String_Node_Str"" + tableName + ""String_Node_Str"";
  createStatement=C.eList(extractors).map(new Function<Extractor<?>,String>(){
    @Override public String apply(    Extractor<?> t){
      return t.name();
    }
  }
).mkString(""String_Node_Str"" + tableName + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  updateStatement=""String_Node_Str"" + tableName + ""String_Node_Str"";
  countStatement=""String_Node_Str"" + tableName;
  return (A)this;
}","public <A extends Table<T>>A init(Class<T> clazz,String tableName){
  this.tableName=tableName;
  this.clazz=clazz;
  this.extractors=all().extractors;
  ExtractorSeq<T> extr=all();
  if (extr.map.isDefined()) {
    this.parser=DB.parser(clazz,extractors).map(extr.map.get());
  }
 else {
    this.parser=DB.parser(clazz,extractors).mapWithFieldsReflection();
  }
  System.out.println(extractors);
  selectAllStatement=C.eList(extractors).map(new Function<Extractor<?>,String>(){
    @Override public String apply(    Extractor<?> t){
      return ""String_Node_Str"" + t.name();
    }
  }
).mkString(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tableName + ""String_Node_Str"");
  findWhereStatement=C.eList(extractors).map(new Function<Extractor<?>,String>(){
    @Override public String apply(    Extractor<?> t){
      return ""String_Node_Str"" + t.name();
    }
  }
).mkString(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tableName + ""String_Node_Str"");
  selectByIdStatement=C.eList(extractors).map(new Function<Extractor<?>,String>(){
    @Override public String apply(    Extractor<?> t){
      return ""String_Node_Str"" + t.name();
    }
  }
).mkString(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + tableName + ""String_Node_Str"");
  deleteAllStatement=""String_Node_Str"" + tableName;
  deleteStatement=""String_Node_Str"" + tableName + ""String_Node_Str"";
  createStatement=C.eList(extractors).map(new Function<Extractor<?>,String>(){
    @Override public String apply(    Extractor<?> t){
      return t.name();
    }
  }
).mkString(""String_Node_Str"" + tableName + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  updateStatement=""String_Node_Str"" + tableName + ""String_Node_Str"";
  countStatement=""String_Node_Str"" + tableName;
  ddlDelete=""String_Node_Str"" + tableName + ""String_Node_Str"";
  return (A)this;
}",0.98269706124691
183930,"private List<Pair> values(T model){
  List<Pair> ret=new ArrayList<Pair>();
  Set<Field> fields=new HashSet<Field>(Arrays.asList(clazz.getDeclaredFields()));
  fields.addAll(Arrays.asList(clazz.getFields()));
  for (  Field field : fields) {
    field.setAccessible(true);
    for (    Extractor e : extractors) {
      if (e.name().toLowerCase().equals(field.getName().toLowerCase())) {
        try {
          ret.add(pair(e.name(),field.get(model)));
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
  }
  return ret;
}","private List<Pair> values(T model){
  List<Pair> ret=new ArrayList<Pair>();
  Set<Field> fields=new HashSet<Field>(Arrays.asList(clazz.getDeclaredFields()));
  fields.addAll(Arrays.asList(clazz.getFields()));
  for (  Extractor e : extractors) {
    for (    Field field : fields) {
      field.setAccessible(true);
      if (e.name().toLowerCase().equals(field.getName().toLowerCase())) {
        try {
          ret.add(pair(e.name(),field.get(model)));
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
  }
  return ret;
}",0.8793706293706294
183931,"public T update(T model){
  String sql=updateStatement.replace(""String_Node_Str"",C.eList(values(model)).map(new Function<Pair,String>(){
    @Override public String apply(    Pair t){
      return t.key + ""String_Node_Str"" + t.value;
    }
  }
).mkString(""String_Node_Str""));
  sql(sql).on(pair(""String_Node_Str"",model.getId())).executeUpdate();
  return findById(model.getId()).get();
}","public T update(T model){
  String sql=updateStatement.replace(""String_Node_Str"",C.eList(values(model)).map(new Function<Pair,String>(){
    @Override public String apply(    Pair t){
      if (t.value.getClass().equals(String.class)) {
        return t.key + ""String_Node_Str"" + ""String_Node_Str""+ t.value.toString()+ ""String_Node_Str"";
      }
      if (t.value.getClass().equals(Integer.class)) {
        return t.key + ""String_Node_Str"" + t.value.toString();
      }
      if (t.value.getClass().equals(Long.class)) {
        return t.key + ""String_Node_Str"" + t.value.toString();
      }
      if (t.value.getClass().equals(Double.class)) {
        return t.key + ""String_Node_Str"" + t.value.toString();
      }
      if (t.value.getClass().equals(Boolean.class)) {
        return t.key + ""String_Node_Str"" + (((Boolean)t.value) ? ""String_Node_Str"" : ""String_Node_Str"");
      }
      return t.key + ""String_Node_Str"" + ""String_Node_Str""+ t.value.toString()+ ""String_Node_Str"";
    }
  }
).mkString(""String_Node_Str""));
  sql(sql).on(pair(""String_Node_Str"",model.getId())).executeUpdate();
  return findById(model.getId()).get();
}",0.4990151017728168
183932,"@Override public String apply(Pair t){
  return t.key + ""String_Node_Str"" + t.value;
}","@Override public String apply(Pair t){
  if (t.value.getClass().equals(String.class)) {
    return t.key + ""String_Node_Str"" + ""String_Node_Str""+ t.value.toString()+ ""String_Node_Str"";
  }
  if (t.value.getClass().equals(Integer.class)) {
    return t.key + ""String_Node_Str"" + t.value.toString();
  }
  if (t.value.getClass().equals(Long.class)) {
    return t.key + ""String_Node_Str"" + t.value.toString();
  }
  if (t.value.getClass().equals(Double.class)) {
    return t.key + ""String_Node_Str"" + t.value.toString();
  }
  if (t.value.getClass().equals(Boolean.class)) {
    return t.key + ""String_Node_Str"" + (((Boolean)t.value) ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  return t.key + ""String_Node_Str"" + ""String_Node_Str""+ t.value.toString()+ ""String_Node_Str"";
}",0.1835075493612079
183933,"@Test public void testParser(){
  SimpleLogger.enableTrace(true);
  DB.withConnection(new Function<Connection,Unit>(){
    @Override public Unit apply(    Connection _){
      SQL(""String_Node_Str"").executeUpdate();
      SQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").executeUpdate();
      SQL(""String_Node_Str"").on(pair(""String_Node_Str"",1),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",42),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str"")).executeUpdate();
      SQL(""String_Node_Str"").on(pair(""String_Node_Str"",2),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",16),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str"")).executeUpdate();
      SQL(""String_Node_Str"").on(pair(""String_Node_Str"",3),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",90),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str"")).executeUpdate();
      return Unit.unit();
    }
  }
);
  setParser(Person.personParser);
  Assert.assertEquals(3,Person.findAll().size());
  Assert.assertEquals(1,Person.findAllBetween(18,80).size());
  Assert.assertEquals(2,Person.findAllBetween(18,100).size());
  Assert.assertEquals(2,Person.findAllBetween(10,80).size());
  Assert.assertEquals(3,Person.findAllBetween(10,100).size());
  setParser(Person.personParserRefl);
  Assert.assertEquals(3,Person.findAll().size());
  Assert.assertEquals(1,Person.findAllBetween(18,80).size());
  Assert.assertEquals(2,Person.findAllBetween(18,100).size());
  Assert.assertEquals(2,Person.findAllBetween(10,80).size());
  Assert.assertEquals(3,Person.findAllBetween(10,100).size());
  Assert.assertEquals(3,Person.count());
  DB.withConnection(new Function<Connection,Unit>(){
    @Override public Unit apply(    Connection _){
      Assert.assertEquals(3,Persons._.findAll().size());
      Assert.assertEquals(1,Persons.findAllBetween(18,80).size());
      Assert.assertEquals(2,Persons.findAllBetween(18,100).size());
      Assert.assertEquals(2,Persons.findAllBetween(10,80).size());
      Assert.assertEquals(3,Persons.findAllBetween(10,100).size());
      Assert.assertEquals(3,Persons._.count());
      Persons._.deleteAll();
      Assert.assertEquals(0,Persons._.count());
      return Unit.unit();
    }
  }
);
}","@Test public void testParser(){
  SimpleLogger.enableTrace(true);
  DB.withConnection(new Function<Connection,Unit>(){
    @Override public Unit apply(    Connection _){
      SQL(""String_Node_Str"").executeUpdate();
      SQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").executeUpdate();
      SQL(""String_Node_Str"").on(pair(""String_Node_Str"",1),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",42),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str"")).executeUpdate();
      SQL(""String_Node_Str"").on(pair(""String_Node_Str"",2),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",16),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str"")).executeUpdate();
      SQL(""String_Node_Str"").on(pair(""String_Node_Str"",3),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",90),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str""),pair(""String_Node_Str"",""String_Node_Str"")).executeUpdate();
      return Unit.unit();
    }
  }
);
  setParser(Person.personParser);
  Assert.assertEquals(3,Person.findAll().size());
  Assert.assertEquals(1,Person.findAllBetween(18,80).size());
  Assert.assertEquals(2,Person.findAllBetween(18,100).size());
  Assert.assertEquals(2,Person.findAllBetween(10,80).size());
  Assert.assertEquals(3,Person.findAllBetween(10,100).size());
  setParser(Person.personParserRefl);
  Assert.assertEquals(3,Person.findAll().size());
  Assert.assertEquals(1,Person.findAllBetween(18,80).size());
  Assert.assertEquals(2,Person.findAllBetween(18,100).size());
  Assert.assertEquals(2,Person.findAllBetween(10,80).size());
  Assert.assertEquals(3,Person.findAllBetween(10,100).size());
  Assert.assertEquals(3,Person.count());
}",0.877294287481955
183934,"public static EnhancedList<Person> findAllBetween(int low,int high){
  return _.filter(_.age.between(low,high)).list();
}","public static List<Person> findAllBetween(final int low,final int high){
  return DB.withConnection(new Function<Connection,List<Person>>(){
    @Override public List<Person> apply(    Connection conn){
      return sql(conn,""String_Node_Str"" + ""String_Node_Str"").on(pair(""String_Node_Str"",low),pair(""String_Node_Str"",high)).asList(getParser());
    }
  }
);
}",0.2869022869022869
183935,"public void broadcast(){
  enumerator=context.create(fromEnumerator,UUID.randomUUID().toString());
  enumerator.tell(Run.INSTANCE,internalIteratee);
}","public void broadcast(){
  enumerator=context.create(fromEnumerator,UUID.randomUUID().toString());
  fromEnumerator.context=context;
  fromEnumerator.enumerator=enumerator;
  fromEnumerator.iteratee=internalIteratee;
  enumerator.tell(Run.INSTANCE,internalIteratee);
  if (fromEnumerator instanceof CallbackPushEnumerator) {
    final CallbackPushEnumerator<T> p=(CallbackPushEnumerator<T>)fromEnumerator;
    context.schedule(p.every,p.unit,new Runnable(){
      @Override public void run(){
        Option<T> opt=p.callback.apply(Unit.unit());
        for (        T elem : opt) {
          p.push(elem);
        }
      }
    }
);
  }
}",0.3802281368821292
183936,"@Override public void run(){
  pushEnum.push(el);
}","@Override public void run(){
  Option<T> opt=p.callback.apply(Unit.unit());
  for (  T elem : opt) {
    p.push(elem);
  }
}",0.5371428571428571
183937,"public void push(T elem){
  pushQueue.offer(elem);
  try {
    if (enumerator != null) {
      enumerator.tell(Cont.INSTANCE,iteratee);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void push(T elem){
  pushQueue.offer(elem);
  try {
    if (enumerator != null) {
      enumerator.tell(Cont.INSTANCE,iteratee);
    }
 else {
      System.err.println(""String_Node_Str"" + elem.toString() + ""String_Node_Str""+ enumerator);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.786692759295499
183938,"public static <T>PushEnumerator<T> fromCallback(long every,TimeUnit unit,final Function<Unit,Option<T>> callback){
  final PushEnumerator<T> pushEnum=new PushEnumerator<T>();
  final ActorContext ctx=Actors.newContext();
  final ExecutorService exec=Executors.newCachedThreadPool();
  ctx.schedule(every,unit,new Runnable(){
    @Override public void run(){
      Option<T> opt=callback.apply(Unit.unit());
      for (      T elem : opt) {
        final T el=elem;
        Runnable r=new Runnable(){
          @Override public void run(){
            pushEnum.push(el);
          }
        }
;
        exec.execute(r);
      }
    }
  }
);
  return pushEnum;
}","public static <T>PushEnumerator<T> fromCallback(long every,TimeUnit unit,final Function<Unit,Option<T>> callback){
  return new CallbackPushEnumerator<T>(every,unit,callback);
}",0.3918757467144564
183939,"/** 
 * Method to loop the reception function to read all messages in the mailbox one by one.  Once launch, the loop will end with the stopActor method or with a poison pill.
 */
public final void loop(Action react){
  this.react=react;
  while (started.get()) {
    Message ret=mailbox.poll();
    if (ret != null) {
      if (ret.payload.getClass().equals(PoisonPill.class)) {
        stopActor();
      }
 else {
        sender=ret.sender;
        buzy.compareAndSet(false,true);
        react.apply(ret.payload);
        buzy.compareAndSet(true,false);
        sender=Option.none();
      }
    }
 else {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException ex) {
        ex.printStackTrace();
      }
    }
  }
}","/** 
 * Method to loop the reception function to read all messages in the mailbox one by one.  Once launch, the loop will end with the stopActor method or with a poison pill.
 */
public final void loop(Action react){
  this.react=react;
  while (started.get()) {
    Message ret=mailbox.poll();
    if (ret != null) {
      if (ret.payload.getClass().equals(PoisonPill.class)) {
        stopActor();
      }
 else {
        sender=ret.sender;
        buzy.compareAndSet(false,true);
        react.apply(ret.payload);
        buzy.compareAndSet(true,false);
        sender=Option.none();
      }
    }
 else {
      while (mailbox.isEmpty() && started.get()) {
        try {
          Thread.sleep(10);
        }
 catch (        InterruptedException ex) {
        }
      }
    }
  }
}",0.8887434554973822
183940,"public static void stopRemoting(){
  new Thread(){
    @Override public void run(){
      channel.unbind().awaitUninterruptibly();
      bootstrap.releaseExternalResources();
      remotingServerExecutor.shutdown();
      bossServerExecutor.shutdown();
      clientServerExecutor.shutdown();
      clientBossServerExecutor.shutdown();
      remotingServerExecutor.shutdownNow();
      bossServerExecutor.shutdownNow();
      clientServerExecutor.shutdownNow();
      clientBossServerExecutor.shutdownNow();
      remotingServerExecutor=Executors.newCachedThreadPool();
      bossServerExecutor=Executors.newCachedThreadPool();
      clientServerExecutor=Executors.newCachedThreadPool();
      clientBossServerExecutor=Executors.newCachedThreadPool();
    }
  }
.start();
}","public static void stopRemoting(){
  new Thread(){
    @Override public void run(){
      try {
        channel.unbind().awaitUninterruptibly();
      }
 catch (      Throwable t) {
      }
      try {
        bootstrap.releaseExternalResources();
      }
 catch (      Throwable t) {
      }
      try {
        remotingServerExecutor.shutdown();
        bossServerExecutor.shutdown();
        clientServerExecutor.shutdown();
        clientBossServerExecutor.shutdown();
        remotingServerExecutor.shutdownNow();
        bossServerExecutor.shutdownNow();
        clientServerExecutor.shutdownNow();
        clientBossServerExecutor.shutdownNow();
      }
 catch (      Throwable t) {
      }
      remotingServerExecutor=Executors.newCachedThreadPool();
      bossServerExecutor=Executors.newCachedThreadPool();
      clientServerExecutor=Executors.newCachedThreadPool();
      clientBossServerExecutor=Executors.newCachedThreadPool();
    }
  }
.start();
}",0.809221902017291
183941,"@Override public ActorURL asRemoteURL(){
  return new RemoteActorURL(Actors.host,Actors.port,name);
}","@Override public ActorURL asRemoteURL(){
  return new RemoteActorURL(host,String.valueOf(port),name);
}",0.8823529411764706
183942,"@Override public ActorURL asLocalURL(){
  return new LocalActorURL(Actors.host,Actors.port,name);
}","@Override public ActorURL asLocalURL(){
  return new RemoteActorURL(host,String.valueOf(port),name);
}",0.835820895522388
183943,"public void testChatRoom() throws Exception {
  User user1=new User(""String_Node_Str"");
  User user2=new User(""String_Node_Str"");
  User user3=new User(""String_Node_Str"");
  ChatRoom room=new ChatRoom();
  room.startActor();
  room.send(new Suscribe(user1));
  room.send(new Suscribe(user2));
  room.send(new Suscribe(user3));
  Thread.sleep(200);
  user1.send(""String_Node_Str"",room);
  Thread.sleep(200);
  user2.send(""String_Node_Str"",room);
  Thread.sleep(200);
  user3.send(""String_Node_Str"",room);
  Thread.sleep(200);
  room.send(new Unsuscribe(user1));
  Thread.sleep(200);
  room.send(new Unsuscribe(user2));
  Thread.sleep(200);
  room.send(new Unsuscribe(user3));
  Thread.sleep(200);
  userlatch.await();
  room.stopSession();
  room.stopActor();
  Actors.shutdownAll();
}","@Test @Ignore public void testChatRoom() throws Exception {
  User user1=new User(""String_Node_Str"");
  User user2=new User(""String_Node_Str"");
  User user3=new User(""String_Node_Str"");
  ChatRoom room=new ChatRoom();
  try {
    room.startActor();
    room.send(new Suscribe(user1));
    room.send(new Suscribe(user2));
    room.send(new Suscribe(user3));
    Thread.sleep(200);
    user1.send(""String_Node_Str"",room);
    Thread.sleep(200);
    user2.send(""String_Node_Str"",room);
    Thread.sleep(200);
    user3.send(""String_Node_Str"",room);
    Thread.sleep(200);
    room.send(new Unsuscribe(user1));
    Thread.sleep(200);
    room.send(new Unsuscribe(user2));
    Thread.sleep(200);
    room.send(new Unsuscribe(user3));
    Thread.sleep(200);
    userlatch.await();
  }
 catch (  Throwable t) {
  }
  try {
    room.stopSession();
    room.stopActor();
  }
 catch (  Throwable t) {
  }
  Actors.shutdownAll();
}",0.8720657276995305
183944,"public void testPingPong() throws Exception {
  Pong pong=new Pong();
  Ping ping=new Ping(pong);
  pong.startActor();
  ping.startActor();
  down.await();
  pong.stopActor();
  ping.stopActor();
  Actors.shutdownAll();
}","@Test @Ignore public void testPingPong() throws Exception {
  Pong pong=new Pong();
  Ping ping=new Ping(pong);
  try {
    pong.startActor();
    ping.startActor();
    down.await();
  }
 catch (  Throwable t) {
  }
  pong.stopActor();
  ping.stopActor();
  Actors.shutdownAll();
}",0.7196819085487077
183945,"/** 
 * Read only one message in the mailbox with the function.
 */
public final void react(Action<Object> react){
  this.react=react;
  Message ret=mailbox.poll();
  if (ret != null) {
    if (ret.payload.getClass().equals(PoisonPill.class)) {
      stopActor();
    }
 else {
      sender=ret.sender;
      buzy.compareAndSet(false,true);
      react.apply(ret.payload);
      buzy.compareAndSet(true,false);
      sender=Option.none();
    }
  }
}","/** 
 * Read only one message in the mailbox with the function.
 */
public final void react(Action<Object> react){
  this.react=react;
  waitIfMailboxIsEmpty();
  Message ret=mailbox.poll();
  if (ret != null) {
    if (ret.payload.getClass().equals(PoisonPill.class)) {
      stopActor();
    }
 else {
      sender=ret.sender;
      buzy.compareAndSet(false,true);
      react.apply(ret.payload);
      buzy.compareAndSet(true,false);
      sender=Option.none();
    }
  }
}",0.9719222462203024
183946,"/** 
 * Method to loop the reception function to read all messages in the mailbox one by one.  Once launch, the loop will end with the stopActor method or with a poison pill.
 */
public final void loop(Action react){
  this.react=react;
  while (started.get()) {
    Message ret=mailbox.poll();
    if (ret != null) {
      if (ret.payload.getClass().equals(PoisonPill.class)) {
        stopActor();
      }
 else {
        sender=ret.sender;
        buzy.compareAndSet(false,true);
        react.apply(ret.payload);
        buzy.compareAndSet(true,false);
        sender=Option.none();
      }
    }
 else {
      while (mailbox.isEmpty() && started.get()) {
        try {
          Thread.sleep(10);
        }
 catch (        InterruptedException ex) {
        }
      }
    }
  }
}","/** 
 * Method to loop the reception function to read all messages in the mailbox one by one.  Once launch, the loop will end with the stopActor method or with a poison pill.
 */
public final void loop(Action react){
  this.react=react;
  while (started.get()) {
    waitIfMailboxIsEmpty();
    Message ret=mailbox.poll();
    if (ret != null) {
      if (ret.payload.getClass().equals(PoisonPill.class)) {
        stopActor();
      }
 else {
        sender=ret.sender;
        buzy.compareAndSet(false,true);
        react.apply(ret.payload);
        buzy.compareAndSet(true,false);
        sender=Option.none();
      }
    }
  }
}",0.8547249647390691
183947,"@Test @Ignore public void testChatRoom() throws Exception {
  User user1=new User(""String_Node_Str"");
  User user2=new User(""String_Node_Str"");
  User user3=new User(""String_Node_Str"");
  ChatRoom room=new ChatRoom();
  try {
    room.startActor();
    room.send(new Suscribe(user1));
    room.send(new Suscribe(user2));
    room.send(new Suscribe(user3));
    Thread.sleep(200);
    user1.send(""String_Node_Str"",room);
    Thread.sleep(200);
    user2.send(""String_Node_Str"",room);
    Thread.sleep(200);
    user3.send(""String_Node_Str"",room);
    Thread.sleep(200);
    room.send(new Unsuscribe(user1));
    Thread.sleep(200);
    room.send(new Unsuscribe(user2));
    Thread.sleep(200);
    room.send(new Unsuscribe(user3));
    Thread.sleep(200);
    userlatch.await();
  }
 catch (  Throwable t) {
  }
  try {
    room.stopSession();
    room.stopActor();
  }
 catch (  Throwable t) {
  }
  Actors.shutdownAll();
}","@Test public void testChatRoom() throws Exception {
  User user1=new User(""String_Node_Str"");
  User user2=new User(""String_Node_Str"");
  User user3=new User(""String_Node_Str"");
  ChatRoom room=new ChatRoom();
  try {
    room.startActor();
    room.send(new Suscribe(user1));
    room.send(new Suscribe(user2));
    room.send(new Suscribe(user3));
    Thread.sleep(200);
    user1.send(""String_Node_Str"",room);
    Thread.sleep(200);
    user2.send(""String_Node_Str"",room);
    Thread.sleep(200);
    user3.send(""String_Node_Str"",room);
    Thread.sleep(200);
    room.send(new Unsuscribe(user1));
    Thread.sleep(200);
    room.send(new Unsuscribe(user2));
    Thread.sleep(200);
    room.send(new Unsuscribe(user3));
    Thread.sleep(200);
    userlatch.await();
  }
 catch (  Throwable t) {
  }
  try {
    room.stopSession();
    room.stopActor();
  }
 catch (  Throwable t) {
  }
  Actors.shutdownAll();
}",0.9956331877729258
183948,"@Test @Ignore public void testPingPong() throws Exception {
  Pong pong=new Pong();
  Ping ping=new Ping(pong);
  try {
    pong.startActor();
    ping.startActor();
    down.await();
  }
 catch (  Throwable t) {
  }
  pong.stopActor();
  ping.stopActor();
  Actors.shutdownAll();
}","@Test public void testPingPong() throws Exception {
  Pong pong=new Pong();
  Ping ping=new Ping(pong);
  try {
    pong.startActor();
    ping.startActor();
    down.await();
  }
 catch (  Throwable t) {
  }
  pong.stopActor();
  ping.stopActor();
  Actors.shutdownAll();
}",0.9856115107913668
183949,"private int run() throws Exception {
  List<TravelingTournamentProblem.Neighborhood> neighborhoods=new ArrayList<TravelingTournamentProblem.Neighborhood>();
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.TWO_OPT_SWAP_ROUNDS);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.TWO_OPT_SWAP_TEAMS);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SWAP_HOME_VISITOR);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SHIFT_ROUND);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SWAP_MATCH_ROUND);
  File baselineOutDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  TTPParameters baseline=new TTPParameters(method,neighborhoods,TravelingTournamentProblem.ConstructionHeuristic.GRASP,VirtualScheduleConstructionMethod.FIRSTPOLYGONTHENGREEK,50,40,500,40,instanceFile,baselineOutDir,5 * 6 * 1000);
  TravelingTournamentProblem travelingTournamentProblem=new TravelingTournamentProblem();
  travelingTournamentProblem.run(baseline);
  boolean headerWritten=false;
  File sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  File avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  File intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (int i=0; i <= 80; i+=10) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
    TTPParameters current=new TTPParameters(baseline);
    current.setTabuListLength(i);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + i,result);
    writeResultAvg(avgFile,""String_Node_Str"" + i,result);
  }
  if (method == TravelingTournamentProblem.Method.GRASP) {
    headerWritten=false;
    sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    for (int i=10; i <= 80; i+=10) {
      File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
      TTPParameters current=new TTPParameters(baseline);
      current.setGraspTries(Math.max(i,1));
      current.setThreadCount(Math.max(i,1));
      current.setOutputDirectory(subOutDir);
      TTPResult result=travelingTournamentProblem.run(current);
      if (!headerWritten) {
        writeResultHeader(sumFile,""String_Node_Str"",result);
        writeResultHeader(avgFile,""String_Node_Str"",result);
        headerWritten=true;
      }
      writeResultSum(sumFile,""String_Node_Str"" + i,result);
      writeResultAvg(avgFile,""String_Node_Str"" + i,result);
    }
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (int i=100; i <= 600; i+=50) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
    TTPParameters current=new TTPParameters(baseline);
    current.setIterationsWithoutImprovement(i);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + i,result);
    writeResultAvg(avgFile,""String_Node_Str"" + i,result);
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  TravelingTournamentProblem.ConstructionHeuristic constructionHeuristic : TravelingTournamentProblem.ConstructionHeuristic.values()) {
    if (constructionHeuristic == TravelingTournamentProblem.ConstructionHeuristic.GRASP)     continue;
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + constructionHeuristic);
    TTPParameters current=new TTPParameters(baseline);
    current.setConstructionHeuristic(constructionHeuristic);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + constructionHeuristic,result);
    writeResultAvg(avgFile,""String_Node_Str"" + constructionHeuristic,result);
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  VirtualScheduleConstructionMethod virtualScheduleConstructionMethod : VirtualScheduleConstructionMethod.values()) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + virtualScheduleConstructionMethod);
    TTPParameters current=new TTPParameters(baseline);
    current.setVirtualScheduleConstructionMethod(virtualScheduleConstructionMethod);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + virtualScheduleConstructionMethod,result);
    writeResultAvg(avgFile,""String_Node_Str"" + virtualScheduleConstructionMethod,result);
  }
  Set<TravelingTournamentProblem.Neighborhood> neighborhoodsBase=new HashSet<TravelingTournamentProblem.Neighborhood>(neighborhoods);
  Set<Set<TravelingTournamentProblem.Neighborhood>> neighborhoodsPowerSet=powerSet(neighborhoodsBase);
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  Set<TravelingTournamentProblem.Neighborhood> neighborhoodSet : neighborhoodsPowerSet) {
    if (neighborhoodSet.size() == 0)     continue;
    List<TravelingTournamentProblem.Neighborhood> currentNeighborhoods=new ArrayList<TravelingTournamentProblem.Neighborhood>(neighborhoodSet);
    String neighborhoodNames=""String_Node_Str"";
    for (    TravelingTournamentProblem.Neighborhood currentNeighborhood : currentNeighborhoods)     neighborhoodNames+=""String_Node_Str"" + currentNeighborhood;
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + neighborhoodNames);
    neighborhoodNames=neighborhoodNames.replaceAll(""String_Node_Str"",""String_Node_Str"");
    TTPParameters current=new TTPParameters(baseline);
    current.setNeighborhoods(currentNeighborhoods);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + neighborhoodNames,result);
    writeResultAvg(avgFile,""String_Node_Str"" + neighborhoodNames,result);
  }
  return 0;
}","private int run() throws Exception {
  List<TravelingTournamentProblem.Neighborhood> neighborhoods=new ArrayList<TravelingTournamentProblem.Neighborhood>();
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.TWO_OPT_SWAP_ROUNDS);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.TWO_OPT_SWAP_TEAMS);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SWAP_HOME_VISITOR);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SHIFT_ROUND);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SWAP_MATCH_ROUND);
  File baselineOutDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  TTPParameters baseline=new TTPParameters(method,neighborhoods,TravelingTournamentProblem.ConstructionHeuristic.GRASP,VirtualScheduleConstructionMethod.FIRSTPOLYGONTHENGREEK,50,40,500,40,instanceFile,baselineOutDir,5L * 60L * 1000L);
  TravelingTournamentProblem travelingTournamentProblem=new TravelingTournamentProblem();
  travelingTournamentProblem.run(baseline);
  boolean headerWritten=false;
  File sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  File avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  File intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (int i=0; i <= 80; i+=10) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
    TTPParameters current=new TTPParameters(baseline);
    current.setTabuListLength(i);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + i,result);
    writeResultAvg(avgFile,""String_Node_Str"" + i,result);
  }
  if (method == TravelingTournamentProblem.Method.GRASP) {
    headerWritten=false;
    sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    for (int i=10; i <= 80; i+=10) {
      File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
      TTPParameters current=new TTPParameters(baseline);
      current.setGraspTries(Math.max(i,1));
      current.setThreadCount(Math.max(i,1));
      current.setOutputDirectory(subOutDir);
      TTPResult result=travelingTournamentProblem.run(current);
      if (!headerWritten) {
        writeResultHeader(sumFile,""String_Node_Str"",result);
        writeResultHeader(avgFile,""String_Node_Str"",result);
        headerWritten=true;
      }
      writeResultSum(sumFile,""String_Node_Str"" + i,result);
      writeResultAvg(avgFile,""String_Node_Str"" + i,result);
    }
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (int i=100; i <= 600; i+=50) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
    TTPParameters current=new TTPParameters(baseline);
    current.setIterationsWithoutImprovement(i);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + i,result);
    writeResultAvg(avgFile,""String_Node_Str"" + i,result);
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  TravelingTournamentProblem.ConstructionHeuristic constructionHeuristic : TravelingTournamentProblem.ConstructionHeuristic.values()) {
    if (constructionHeuristic == TravelingTournamentProblem.ConstructionHeuristic.GRASP)     continue;
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + constructionHeuristic);
    TTPParameters current=new TTPParameters(baseline);
    current.setConstructionHeuristic(constructionHeuristic);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + constructionHeuristic,result);
    writeResultAvg(avgFile,""String_Node_Str"" + constructionHeuristic,result);
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  VirtualScheduleConstructionMethod virtualScheduleConstructionMethod : VirtualScheduleConstructionMethod.values()) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + virtualScheduleConstructionMethod);
    TTPParameters current=new TTPParameters(baseline);
    current.setVirtualScheduleConstructionMethod(virtualScheduleConstructionMethod);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + virtualScheduleConstructionMethod,result);
    writeResultAvg(avgFile,""String_Node_Str"" + virtualScheduleConstructionMethod,result);
  }
  Set<TravelingTournamentProblem.Neighborhood> neighborhoodsBase=new HashSet<TravelingTournamentProblem.Neighborhood>(neighborhoods);
  Set<Set<TravelingTournamentProblem.Neighborhood>> neighborhoodsPowerSet=powerSet(neighborhoodsBase);
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  Set<TravelingTournamentProblem.Neighborhood> neighborhoodSet : neighborhoodsPowerSet) {
    if (neighborhoodSet.size() == 0)     continue;
    List<TravelingTournamentProblem.Neighborhood> currentNeighborhoods=new ArrayList<TravelingTournamentProblem.Neighborhood>(neighborhoodSet);
    String neighborhoodNames=""String_Node_Str"";
    for (    TravelingTournamentProblem.Neighborhood currentNeighborhood : currentNeighborhoods)     neighborhoodNames+=""String_Node_Str"" + currentNeighborhood;
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + neighborhoodNames);
    neighborhoodNames=neighborhoodNames.replaceAll(""String_Node_Str"",""String_Node_Str"");
    TTPParameters current=new TTPParameters(baseline);
    current.setNeighborhoods(currentNeighborhoods);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + neighborhoodNames,result);
    writeResultAvg(avgFile,""String_Node_Str"" + neighborhoodNames,result);
  }
  return 0;
}",0.9997481742634096
183950,"private boolean generateSchedule(final List<Integer> possibleChoices,Set<IntPair> positions,int[][] schedule){
  if (positions == null || positions.size() == 0)   return true;
  IntPair minPosition=positions.iterator().next();
  for (  IntPair position : positions)   if (position.getFirst() < minPosition.getFirst() || (position.getFirst() == minPosition.getFirst() && position.getSecond() < minPosition.getSecond()))   minPosition=position;
  int t=minPosition.getFirst();
  int w=minPosition.getSecond();
  List<Integer> choices=new ArrayList<Integer>(possibleChoices);
  int indexToRemove=(Math.abs(t) - 1) * 2;
  choices.remove(indexToRemove);
  choices.remove(indexToRemove);
  Collections.shuffle(choices);
  for (  Integer o : choices) {
    IntPair randomChoice=new IntPair(o,w);
    if (positions.contains(randomChoice))     continue;
    schedule[w][t - 1]=o;
    if (o > 0)     schedule[w][o - 1]=-t;
 else     schedule[w][-o - 1]=t;
    Set<IntPair> newPositions=new HashSet<IntPair>(positions);
    IntPair absoluteRandomChoice=new IntPair(Math.abs(o),w);
    newPositions.remove(absoluteRandomChoice);
    newPositions.remove(minPosition);
    if (generateSchedule(possibleChoices,newPositions,schedule))     return true;
  }
  return false;
}","private boolean generateSchedule(final List<Integer> possibleChoices,Set<IntPair> positions,int[][] schedule){
  if (positions == null || positions.size() == 0)   return true;
  IntPair minPosition=positions.iterator().next();
  for (  IntPair position : positions)   if (position.getFirst() < minPosition.getFirst() || (position.getFirst() == minPosition.getFirst() && position.getSecond() < minPosition.getSecond()))   minPosition=position;
  int t=minPosition.getFirst();
  int w=minPosition.getSecond();
  List<Integer> choices=new ArrayList<Integer>(possibleChoices);
  int indexToRemove=(Math.abs(t) - 1) * 2;
  choices.remove(indexToRemove);
  choices.remove(indexToRemove);
  Collections.shuffle(choices);
  for (  Integer o : choices) {
    IntPair randomChoice=new IntPair(o,w);
    IntPair absoluteRandomChoice=new IntPair(Math.abs(o),w);
    if (!positions.contains(absoluteRandomChoice))     continue;
    boolean found=false;
    for (int i=0; i < w; i++) {
      if (schedule[i][t - 1] == o.intValue()) {
        found=true;
        break;
      }
    }
    if (found)     continue;
    schedule[w][t - 1]=o;
    if (o > 0)     schedule[w][o - 1]=-t;
 else     schedule[w][-o - 1]=t;
    Set<IntPair> newPositions=new HashSet<IntPair>(positions);
    newPositions.remove(absoluteRandomChoice);
    newPositions.remove(minPosition);
    if (generateSchedule(possibleChoices,newPositions,schedule))     return true;
  }
  return false;
}",0.7865583456425406
183951,"/** 
 * @param args
 */
public static void main(String[] args){
  ISearch<TTPInstance,TTPSolution> search=null;
  boolean multithreading=false;
  int noThreads=1;
  String path=""String_Node_Str"";
  for (int i=0; i < args.length; i++) {
    if (args[i].equals(""String_Node_Str"")) {
      path=args[i + 1];
      i++;
    }
    if (args[i].equals(METHOD)) {
      String method=args[i + 1];
      i++;
      if (method.equals(GRASP)) {
        search=new ttp.metaheuristic.GRASP();
      }
 else       if (method.equals(TABU)) {
      }
 else {
        logger.error(""String_Node_Str"" + METHOD);
      }
    }
    if (args[i].equals(NEIGHBORHOOD)) {
      String n=args[i + 1];
      i++;
      String[] neighborhoods=n.split(""String_Node_Str"");
      for (      String s : neighborhoods) {
        if (s.equals(SWAPHOME)) {
        }
 else         if (s.equals(SWAPTEAM)) {
        }
        if (s.equals(SWAPROUND)) {
        }
        if (s.equals(SWAPPARTIALROUND)) {
        }
        if (s.equals(SWAPPARTIALTEAM)) {
        }
        if (s.equals(SHIFTROUNDS)) {
        }
 else {
          logger.error(""String_Node_Str"" + s);
        }
      }
    }
    if (args[i].equals(CONSTRUCTIONHEURISTIC)) {
      String constHeuStr=args[i + 1];
      i++;
      if (constHeuStr.equals(CONSTR_HEUR_RANDOM)) {
      }
 else       if (constHeuStr.equals(GREEDY)) {
      }
 else {
        logger.error(""String_Node_Str"" + constHeuStr);
      }
    }
    if (args[i].equals(NOTHREADS)) {
      String no=args[i + 1];
      i++;
      multithreading=true;
      noThreads=Integer.parseInt(no);
    }
  }
  File file=new File(path);
  if (!file.exists()) {
    logger.error(""String_Node_Str"");
    System.exit(1);
  }
  if (search == null) {
    logger.error(""String_Node_Str"");
  }
  try {
    TTPInstance instance=TTPProblemInstanceReader.readProblemInstance(file);
    TTPSolution result=search.doSearch(instance);
    logger.info(""String_Node_Str"");
    logger.info(result.toString());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}","/** 
 * @param args
 */
public static void main(String[] args){
  ISearch<TTPInstance,TTPSolution> search=new GRASP();
  boolean multithreading=false;
  int noThreads=1;
  String path=""String_Node_Str"";
  for (int i=0; i < args.length; i++) {
    if (args[i].equals(""String_Node_Str"")) {
      path=args[i + 1];
      i++;
    }
    if (args[i].equals(METHOD)) {
      String method=args[i + 1];
      i++;
      if (method.equals(GRASP)) {
        GRASP grasp=new GRASP();
        grasp.setConstructionHeuristic(new TtpRandomConstructionHeuristic());
        TabuSearch taubSearch=new TabuSearch();
        NeighborhoodUnion<TTPSolution> neighborhood=new NeighborhoodUnion<TTPSolution>();
        neighborhood.addNeighborhood(new TwoOptSwapRoundsNeighborhood());
        neighborhood.addNeighborhood(new TwoOptSwapTeamsNeighborhood());
        neighborhood.addNeighborhood(new SwapHomeVisitorNeighborhood());
        neighborhood.addNeighborhood(new ShiftRoundNeighborhood());
        neighborhood.addNeighborhood(new SwapMatchRoundNeighborhood());
        taubSearch.setNeighborhood(neighborhood);
        taubSearch.setTabuListLength(50);
        grasp.setLocalSearch(taubSearch);
        grasp.setNoTries(10);
        search=grasp;
      }
 else       if (method.equals(TABU)) {
      }
 else {
        logger.error(""String_Node_Str"" + METHOD);
      }
    }
    if (args[i].equals(NEIGHBORHOOD)) {
      String n=args[i + 1];
      i++;
      String[] neighborhoods=n.split(""String_Node_Str"");
      for (      String s : neighborhoods) {
        if (s.equals(SWAPHOME)) {
        }
 else         if (s.equals(SWAPTEAM)) {
        }
        if (s.equals(SWAPROUND)) {
        }
        if (s.equals(SWAPPARTIALROUND)) {
        }
        if (s.equals(SWAPPARTIALTEAM)) {
        }
        if (s.equals(SHIFTROUNDS)) {
        }
 else {
          logger.error(""String_Node_Str"" + s);
        }
      }
    }
    if (args[i].equals(CONSTRUCTIONHEURISTIC)) {
      String constHeuStr=args[i + 1];
      i++;
      if (constHeuStr.equals(CONSTR_HEUR_RANDOM)) {
      }
 else       if (constHeuStr.equals(GREEDY)) {
      }
 else {
        logger.error(""String_Node_Str"" + constHeuStr);
      }
    }
    if (args[i].equals(NOTHREADS)) {
      String no=args[i + 1];
      i++;
      multithreading=true;
      noThreads=Integer.parseInt(no);
    }
  }
  File file=new File(path);
  if (!file.exists()) {
    logger.error(""String_Node_Str"");
    System.exit(1);
  }
  if (search == null) {
    logger.error(""String_Node_Str"");
  }
  try {
    TTPInstance instance=TTPProblemInstanceReader.readProblemInstance(file);
    TTPSolution result=search.doSearch(instance);
    logger.info(""String_Node_Str"");
    logger.info(result.toString());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}",0.8306617344841759
183952,"private static void writeResultHeader(File outputFile,String prefix,TTPResult result) throws IOException {
  if (!outputFile.exists()) {
    if (!outputFile.createNewFile()) {
      System.err.println(""String_Node_Str"" + outputFile.getCanonicalPath());
      return;
    }
  }
  PrintWriter writer=new PrintWriter(outputFile,""String_Node_Str"");
  writer.print(prefix);
  writer.print(',');
  if (result.getLocalSearchStatistics() != null) {
    result.getLocalSearchStatistics().writeInformationHeader(writer);
  }
 else   if (result.getSearchStatistics() != null) {
    result.getSearchStatistics().writeStatisticsHeader(writer);
  }
  writer.close();
}","private static void writeResultHeader(File outputFile,String prefix,TTPResult result) throws IOException {
  if (!outputFile.exists()) {
    if (!outputFile.createNewFile()) {
      System.err.println(""String_Node_Str"" + outputFile.getCanonicalPath());
      return;
    }
  }
  PrintWriter writer=new PrintWriter(outputFile,""String_Node_Str"");
  writer.print(prefix);
  writer.print(',');
  if (result.getLocalSearchStatistics() != null) {
    result.getLocalSearchStatistics().writeInformationHeader(writer);
  }
 else   if (result.getSearchStatistics() != null) {
    if (result.getSearchStatistics().getSolution() == null)     writer.println();
 else     result.getSearchStatistics().writeStatisticsHeader(writer);
  }
  writer.close();
}",0.9369627507163324
183953,"private int run() throws Exception {
  List<TravelingTournamentProblem.Neighborhood> neighborhoods=new ArrayList<TravelingTournamentProblem.Neighborhood>();
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.TWO_OPT_SWAP_ROUNDS);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.TWO_OPT_SWAP_TEAMS);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SWAP_HOME_VISITOR);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SHIFT_ROUND);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SWAP_MATCH_ROUND);
  File baselineOutDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  TTPParameters baseline=new TTPParameters(method,neighborhoods,TravelingTournamentProblem.ConstructionHeuristic.GRASP,VirtualScheduleConstructionMethod.FIRSTPOLYGONTHENGREEK,50,10,250,10,instanceFile,baselineOutDir);
  TravelingTournamentProblem travelingTournamentProblem=new TravelingTournamentProblem();
  travelingTournamentProblem.run(baseline);
  boolean headerWritten=false;
  File sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  File avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  File intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (int i=0; i <= 200; i+=10) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
    TTPParameters current=new TTPParameters(baseline);
    current.setTabuListLength(i);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + i,result);
    writeResultAvg(avgFile,""String_Node_Str"" + i,result);
  }
  if (method == TravelingTournamentProblem.Method.GRASP) {
    headerWritten=false;
    sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    for (int i=0; i <= 100; i+=10) {
      File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
      TTPParameters current=new TTPParameters(baseline);
      current.setGraspTries(Math.max(i,1));
      current.setThreadCount(Math.max(i,1));
      current.setOutputDirectory(subOutDir);
      TTPResult result=travelingTournamentProblem.run(current);
      if (!headerWritten) {
        writeResultHeader(sumFile,""String_Node_Str"",result);
        writeResultHeader(avgFile,""String_Node_Str"",result);
        headerWritten=true;
      }
      writeResultSum(sumFile,""String_Node_Str"" + i,result);
      writeResultAvg(avgFile,""String_Node_Str"" + i,result);
    }
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (int i=0; i <= 500; i+=50) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
    TTPParameters current=new TTPParameters(baseline);
    current.setIterationsWithoutImprovement(i);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + i,result);
    writeResultAvg(avgFile,""String_Node_Str"" + i,result);
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  TravelingTournamentProblem.ConstructionHeuristic constructionHeuristic : TravelingTournamentProblem.ConstructionHeuristic.values()) {
    if (constructionHeuristic == TravelingTournamentProblem.ConstructionHeuristic.GRASP)     continue;
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + constructionHeuristic);
    TTPParameters current=new TTPParameters(baseline);
    current.setConstructionHeuristic(constructionHeuristic);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + constructionHeuristic,result);
    writeResultAvg(avgFile,""String_Node_Str"" + constructionHeuristic,result);
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  VirtualScheduleConstructionMethod virtualScheduleConstructionMethod : VirtualScheduleConstructionMethod.values()) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + virtualScheduleConstructionMethod);
    TTPParameters current=new TTPParameters(baseline);
    current.setVirtualScheduleConstructionMethod(virtualScheduleConstructionMethod);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + virtualScheduleConstructionMethod,result);
    writeResultAvg(avgFile,""String_Node_Str"" + virtualScheduleConstructionMethod,result);
  }
  Set<TravelingTournamentProblem.Neighborhood> neighborhoodsBase=new HashSet<TravelingTournamentProblem.Neighborhood>(neighborhoods);
  Set<Set<TravelingTournamentProblem.Neighborhood>> neighborhoodsPowerSet=powerSet(neighborhoodsBase);
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  Set<TravelingTournamentProblem.Neighborhood> neighborhoodSet : neighborhoodsPowerSet) {
    if (neighborhoodSet.size() == 0)     continue;
    List<TravelingTournamentProblem.Neighborhood> currentNeighborhoods=new ArrayList<TravelingTournamentProblem.Neighborhood>(neighborhoodSet);
    String neighborhoodNames=""String_Node_Str"";
    for (    TravelingTournamentProblem.Neighborhood currentNeighborhood : currentNeighborhoods)     neighborhoodNames+=""String_Node_Str"" + currentNeighborhood;
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + neighborhoodNames);
    neighborhoodNames=neighborhoodNames.replaceAll(""String_Node_Str"",""String_Node_Str"");
    TTPParameters current=new TTPParameters(baseline);
    current.setNeighborhoods(currentNeighborhoods);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + neighborhoodNames,result);
    writeResultAvg(avgFile,""String_Node_Str"" + neighborhoodNames,result);
  }
  return 0;
}","private int run() throws Exception {
  List<TravelingTournamentProblem.Neighborhood> neighborhoods=new ArrayList<TravelingTournamentProblem.Neighborhood>();
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.TWO_OPT_SWAP_ROUNDS);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.TWO_OPT_SWAP_TEAMS);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SWAP_HOME_VISITOR);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SHIFT_ROUND);
  neighborhoods.add(TravelingTournamentProblem.Neighborhood.SWAP_MATCH_ROUND);
  File baselineOutDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  TTPParameters baseline=new TTPParameters(method,neighborhoods,TravelingTournamentProblem.ConstructionHeuristic.GRASP,VirtualScheduleConstructionMethod.FIRSTPOLYGONTHENGREEK,50,10,250,10,instanceFile,baselineOutDir);
  TravelingTournamentProblem travelingTournamentProblem=new TravelingTournamentProblem();
  travelingTournamentProblem.run(baseline);
  boolean headerWritten=false;
  File sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  File avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  File intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (int i=0; i <= 200; i+=10) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
    TTPParameters current=new TTPParameters(baseline);
    current.setTabuListLength(i);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + i,result);
    writeResultAvg(avgFile,""String_Node_Str"" + i,result);
  }
  if (method == TravelingTournamentProblem.Method.GRASP) {
    headerWritten=false;
    sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
    for (int i=0; i <= 100; i+=10) {
      File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
      TTPParameters current=new TTPParameters(baseline);
      current.setGraspTries(Math.max(i,1));
      current.setThreadCount(Math.max(i,1));
      current.setOutputDirectory(subOutDir);
      TTPResult result=travelingTournamentProblem.run(current);
      if (!headerWritten) {
        writeResultHeader(sumFile,""String_Node_Str"",result);
        writeResultHeader(avgFile,""String_Node_Str"",result);
        headerWritten=true;
      }
      writeResultSum(sumFile,""String_Node_Str"" + i,result);
      writeResultAvg(avgFile,""String_Node_Str"" + i,result);
    }
  }
  System.exit(0);
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (int i=0; i <= 500; i+=50) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + i);
    TTPParameters current=new TTPParameters(baseline);
    current.setIterationsWithoutImprovement(i);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + i,result);
    writeResultAvg(avgFile,""String_Node_Str"" + i,result);
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  TravelingTournamentProblem.ConstructionHeuristic constructionHeuristic : TravelingTournamentProblem.ConstructionHeuristic.values()) {
    if (constructionHeuristic == TravelingTournamentProblem.ConstructionHeuristic.GRASP)     continue;
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + constructionHeuristic);
    TTPParameters current=new TTPParameters(baseline);
    current.setConstructionHeuristic(constructionHeuristic);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + constructionHeuristic,result);
    writeResultAvg(avgFile,""String_Node_Str"" + constructionHeuristic,result);
  }
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  VirtualScheduleConstructionMethod virtualScheduleConstructionMethod : VirtualScheduleConstructionMethod.values()) {
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + virtualScheduleConstructionMethod);
    TTPParameters current=new TTPParameters(baseline);
    current.setVirtualScheduleConstructionMethod(virtualScheduleConstructionMethod);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + virtualScheduleConstructionMethod,result);
    writeResultAvg(avgFile,""String_Node_Str"" + virtualScheduleConstructionMethod,result);
  }
  Set<TravelingTournamentProblem.Neighborhood> neighborhoodsBase=new HashSet<TravelingTournamentProblem.Neighborhood>(neighborhoods);
  Set<Set<TravelingTournamentProblem.Neighborhood>> neighborhoodsPowerSet=powerSet(neighborhoodsBase);
  headerWritten=false;
  sumFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  avgFile=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  intermediateDir=new File(outputDirectory,instanceFile.getName() + ""String_Node_Str"");
  for (  Set<TravelingTournamentProblem.Neighborhood> neighborhoodSet : neighborhoodsPowerSet) {
    if (neighborhoodSet.size() == 0)     continue;
    List<TravelingTournamentProblem.Neighborhood> currentNeighborhoods=new ArrayList<TravelingTournamentProblem.Neighborhood>(neighborhoodSet);
    String neighborhoodNames=""String_Node_Str"";
    for (    TravelingTournamentProblem.Neighborhood currentNeighborhood : currentNeighborhoods)     neighborhoodNames+=""String_Node_Str"" + currentNeighborhood;
    File subOutDir=new File(intermediateDir,instanceFile.getName() + ""String_Node_Str"" + neighborhoodNames);
    neighborhoodNames=neighborhoodNames.replaceAll(""String_Node_Str"",""String_Node_Str"");
    TTPParameters current=new TTPParameters(baseline);
    current.setNeighborhoods(currentNeighborhoods);
    current.setOutputDirectory(subOutDir);
    TTPResult result=travelingTournamentProblem.run(current);
    if (!headerWritten) {
      writeResultHeader(sumFile,""String_Node_Str"",result);
      writeResultHeader(avgFile,""String_Node_Str"",result);
      headerWritten=true;
    }
    writeResultSum(sumFile,""String_Node_Str"" + neighborhoodNames,result);
    writeResultAvg(avgFile,""String_Node_Str"" + neighborhoodNames,result);
  }
  return 0;
}",0.9988657844990548
183954,"private static void writeGraspIterations(SearchStatistics searchStatistics,final File outputDirectory) throws IOException {
  File localSearchesOutFile=new File(outputDirectory,""String_Node_Str"");
  PrintWriter localSearchesWriter=null;
  if (!localSearchesOutFile.createNewFile()) {
    System.err.println(""String_Node_Str"" + localSearchesOutFile.getCanonicalPath());
  }
 else {
    localSearchesWriter=new PrintWriter(localSearchesOutFile,""String_Node_Str"");
    searchStatistics.getLocalSearchStatistics().entrySet().iterator().next().getValue().writeInformationHeader(localSearchesWriter);
  }
  for (  Map.Entry<Integer,LocalSearchStatistics> localSearch : searchStatistics.getLocalSearchStatistics().entrySet()) {
    int iteration=localSearch.getKey();
    LocalSearchStatistics localSearchStatistics=localSearch.getValue();
    writeLocalSearchIteration(iteration,localSearchStatistics,outputDirectory);
    localSearchStatistics.writeInformation(localSearchesWriter);
  }
  if (localSearchesWriter != null)   localSearchesWriter.close();
}","private static void writeGraspIterations(SearchStatistics searchStatistics,final File outputDirectory) throws IOException {
  File localSearchesOutFile=new File(outputDirectory,""String_Node_Str"");
  PrintWriter localSearchesWriter=null;
  if (searchStatistics.getLocalSearchStatistics().size() > 0)   if (!localSearchesOutFile.createNewFile()) {
    System.err.println(""String_Node_Str"" + localSearchesOutFile.getCanonicalPath());
  }
 else {
    localSearchesWriter=new PrintWriter(localSearchesOutFile,""String_Node_Str"");
    searchStatistics.getLocalSearchStatistics().entrySet().iterator().next().getValue().writeInformationHeader(localSearchesWriter);
  }
 else   return;
  for (  Map.Entry<Integer,LocalSearchStatistics> localSearch : searchStatistics.getLocalSearchStatistics().entrySet()) {
    int iteration=localSearch.getKey();
    LocalSearchStatistics localSearchStatistics=localSearch.getValue();
    writeLocalSearchIteration(iteration,localSearchStatistics,outputDirectory);
    localSearchStatistics.writeInformation(localSearchesWriter);
  }
  if (localSearchesWriter != null)   localSearchesWriter.close();
}",0.9641544117647058
183955,"private static void writeResultsFile(TTPSolution solution,SearchStatistics searchStatistics,LocalSearchStatistics localSearchStatistics,final File outputDirectory) throws IOException {
  File resultOutFile=new File(outputDirectory,""String_Node_Str"");
  if (resultOutFile.createNewFile()) {
    PrintWriter resultWriter=new PrintWriter(resultOutFile,""String_Node_Str"");
    resultWriter.println(solution.toString());
    resultWriter.println(""String_Node_Str"" + solution.getCost());
    resultWriter.println(""String_Node_Str"" + solution.getCostWithPenalty());
    resultWriter.println(""String_Node_Str"" + solution.getPenalty());
    resultWriter.println(""String_Node_Str"" + solution.getScTotal());
    if (searchStatistics != null) {
      resultWriter.println(""String_Node_Str"" + searchStatistics.getStart());
      resultWriter.println(""String_Node_Str"" + searchStatistics.getEnd());
      resultWriter.println(""String_Node_Str"" + searchStatistics.getDurationInMilliSeconds() + ""String_Node_Str"");
      resultWriter.println(""String_Node_Str"");
      searchStatistics.writeStatisticSum(resultWriter);
      resultWriter.println(""String_Node_Str"");
      searchStatistics.writeStatisticAverage(resultWriter);
    }
    if (localSearchStatistics != null) {
      localSearchStatistics.writeInformationHeader(resultWriter);
      localSearchStatistics.writeInformation(resultWriter);
    }
    resultWriter.close();
  }
 else   System.err.println(""String_Node_Str"" + resultOutFile.getCanonicalPath());
}","private static void writeResultsFile(TTPSolution solution,SearchStatistics searchStatistics,LocalSearchStatistics localSearchStatistics,final File outputDirectory) throws IOException {
  File resultOutFile=new File(outputDirectory,""String_Node_Str"");
  if (solution == null)   return;
  if (resultOutFile.createNewFile()) {
    PrintWriter resultWriter=new PrintWriter(resultOutFile,""String_Node_Str"");
    resultWriter.println(solution.toString());
    resultWriter.println(""String_Node_Str"" + solution.getCost());
    resultWriter.println(""String_Node_Str"" + solution.getCostWithPenalty());
    resultWriter.println(""String_Node_Str"" + solution.getPenalty());
    resultWriter.println(""String_Node_Str"" + solution.getScTotal());
    if (searchStatistics != null) {
      resultWriter.println(""String_Node_Str"" + searchStatistics.getStart());
      resultWriter.println(""String_Node_Str"" + searchStatistics.getEnd());
      resultWriter.println(""String_Node_Str"" + searchStatistics.getDurationInMilliSeconds() + ""String_Node_Str"");
      resultWriter.println(""String_Node_Str"");
      searchStatistics.writeStatisticSum(resultWriter);
      resultWriter.println(""String_Node_Str"");
      searchStatistics.writeStatisticAverage(resultWriter);
    }
    if (localSearchStatistics != null) {
      localSearchStatistics.writeInformationHeader(resultWriter);
      localSearchStatistics.writeInformation(resultWriter);
    }
    resultWriter.close();
  }
 else   System.err.println(""String_Node_Str"" + resultOutFile.getCanonicalPath());
}",0.9888010540184452
183956,"@Override public TTPSolution getNext(){
  TTPSolution next=new TTPSolution(baseSolution);
  int[][] schedule=next.getSchedule();
  int tmp;
  for (int i=0; i < totalGames; i++) {
    if (schedule[i][index1] == (index2 + 1)) {
      schedule[i][index1]=-(index2 + 1);
      schedule[i][index2]=(index1 + 1);
    }
 else     if (schedule[i][index1] == -(index2 + 1)) {
      schedule[i][index1]=(index2 + 1);
      schedule[i][index2]=-(index1 + 1);
    }
 else {
      tmp=schedule[i][index1];
      schedule[i][index1]=schedule[i][index2];
      schedule[i][index2]=tmp;
      if (schedule[i][index1] < 0)       schedule[i][-schedule[i][index1] - 1]=index1 + 1;
 else       schedule[i][schedule[i][index1] - 1]=-(index1 + 1);
      if (schedule[i][index2] < 0)       schedule[i][-schedule[i][index2] - 1]=index2 + 1;
 else       schedule[i][schedule[i][index2] - 1]=-(index2 + 1);
    }
  }
  next.setSchedule(schedule);
  TtpSolutionHelper.updateTeam(next,index1 + 1);
  TtpSolutionHelper.updateTeam(next,index2 + 1);
  index2++;
  if (index2 == totalTeams) {
    index1++;
    index2=index1 + 1;
  }
  return next;
}","@Override public TTPSolution getNext(){
  TTPSolution next=new TTPSolution(baseSolution);
  int[][] schedule=next.getSchedule();
  int tmp;
  for (int i=0; i < totalGames; i++) {
    if (schedule[i][index1] == (index2 + 1)) {
      schedule[i][index1]=-(index2 + 1);
      schedule[i][index2]=(index1 + 1);
    }
 else     if (schedule[i][index1] == -(index2 + 1)) {
      schedule[i][index1]=(index2 + 1);
      schedule[i][index2]=-(index1 + 1);
    }
 else {
      tmp=schedule[i][index1];
      schedule[i][index1]=schedule[i][index2];
      schedule[i][index2]=tmp;
      if (schedule[i][index1] < 0)       schedule[i][-schedule[i][index1] - 1]=index1 + 1;
 else       schedule[i][schedule[i][index1] - 1]=-(index1 + 1);
      if (schedule[i][index2] < 0)       schedule[i][-schedule[i][index2] - 1]=index2 + 1;
 else       schedule[i][schedule[i][index2] - 1]=-(index2 + 1);
    }
  }
  next.setSchedule(schedule);
  TtpSolutionHelper.updateAll(next);
  index2++;
  if (index2 == totalTeams) {
    index1++;
    index2=index1 + 1;
  }
  return next;
}",0.8763218390804598
183957,"public void setCost(int cost){
  this.cost=cost;
  if (cost < 0) {
    int wtf=0;
    wtf++;
  }
}","public void setCost(int cost){
  this.cost=cost;
}",0.6756756756756757
183958,"public static void updateAll(TTPSolution next){
  for (int i=0; i < next.getSchedule()[0].length; i++) {
    updateTeam(next,i + 1);
  }
}","public static void updateAll(TTPSolution sol){
  int costs=0;
  for (int i=0; i < sol.getSchedule()[0].length; i++) {
    sol.getTeamCost()[i]=calculateTeamCosts(i + 1,sol);
    costs+=sol.getTeamCost()[i];
    sol.updateSoftConstraintsViolations(i,calculateWeakViolations(i + 1,sol));
  }
  sol.setCost(costs);
}",0.4922394678492239
183959,"@Test public void testTabuSearch_ShouldReturnSolution_1(){
  sc.setProblemInstance(instance);
  TTPSolution sol=sc.getInitialSolution();
  int[][] schedule={{-5,-3,2,6,1,-4},{-3,6,1,-5,4,-2},{2,-1,-4,3,-6,5},{4,-5,6,-1,2,-3},{-6,3,-2,5,-4,1},{-4,-6,5,1,-3,2},{-2,1,4,-3,6,-5},{3,5,-1,-6,-2,4},{6,4,-5,-2,3,-1},{5,-4,-6,2,-1,3}};
  sol.setSchedule(schedule);
  TtpSolutionHelper.initializeSolution(sol,instance);
  System.out.println(""String_Node_Str"" + sol.getCost() + ""String_Node_Str""+ sol.isLegal());
  TTPSolution tabuSol=ts.doLocalSearch(sol);
  assertThat(tabuSol,notNullValue());
  assertThat(TtpSolutionHelper.checkSolution(tabuSol),is(true));
  System.out.println(""String_Node_Str"" + tabuSol.getCost() + ""String_Node_Str""+ tabuSol.isLegal());
}","@Test public void testTabuSearch_ShouldReturnSolution_1(){
  sc.setProblemInstance(instance);
  TTPSolution sol=sc.getInitialSolution();
  TtpSolutionHelper.initializeSolution(sol,instance);
  System.out.println(""String_Node_Str"" + sol.getCost() + ""String_Node_Str""+ sol.isLegal());
  TTPSolution tabuSol=ts.doLocalSearch(sol);
  assertThat(tabuSol,notNullValue());
  assertThat(TtpSolutionHelper.checkSolution(tabuSol),is(true));
  int costs=TtpSolutionHelper.calculateCosts(tabuSol.getSchedule(),instance);
  assertThat(tabuSol.getCost(),is(costs));
  System.out.println(""String_Node_Str"" + tabuSol.getCost() + ""String_Node_Str""+ tabuSol.isLegal());
}",0.2062588904694167
183960,"@Before public void setUp() throws Exception {
  File file=new File(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  instance=TTPProblemInstanceReader.readProblemInstance(file);
  sc=new SimpleConstruction();
  ts=new TabuSearch();
  NeighborhoodUnion<TTPSolution> neighborhood=new NeighborhoodUnion<TTPSolution>();
  neighborhood.addNeighborhood(new TwoOptSwapRoundsNeighborhood());
  neighborhood.addNeighborhood(new TwoOptSwapTeamsNeighborhood());
  neighborhood.addNeighborhood(new SwapHomeVisitorNeighborhood());
  ts.setNeighborhood(neighborhood);
}","@Before public void setUp() throws Exception {
  File file=new File(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  instance=TTPProblemInstanceReader.readProblemInstance(file);
  sc=new SimpleConstruction();
  ts=new TabuSearch();
  ts.setTabuListLength(50);
  ts.setMaxNoImprovement(500);
  NeighborhoodUnion<TTPSolution> neighborhood=new NeighborhoodUnion<TTPSolution>();
  neighborhood.addNeighborhood(new TwoOptSwapRoundsNeighborhood());
  neighborhood.addNeighborhood(new TwoOptSwapTeamsNeighborhood());
  neighborhood.addNeighborhood(new SwapHomeVisitorNeighborhood());
  ts.setNeighborhood(neighborhood);
}",0.9503784693019344
183961,"@Test public void testCalculateCosts_shouldReturn23916() throws Exception {
  File file=new File(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  instance=TTPProblemInstanceReader.readProblemInstance(file);
  sc.setProblemInstance(instance);
  TTPSolution sol=sc.getInitialSolution();
  int[][] schedule={{5,-6,-4,3,-1,2},{2,-1,5,-6,-3,4},{6,-5,4,-3,2,-1},{-3,4,1,-2,6,-5},{-4,5,-6,1,-2,3},{-6,-3,2,5,-4,1},{3,-4,-1,2,-6,5},{4,6,-5,-1,3,-2},{-2,1,6,-5,4,-3},{-5,3,-2,6,1,-4}};
  int result=TtpSolutionHelper.calculateCosts(schedule,instance);
  assertThat(result,is(23916));
}","@Test public void testCalculateCosts_shouldReturn23916() throws Exception {
  File file=new File(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  instance=TTPProblemInstanceReader.readProblemInstance(file);
  int[][] schedule={{5,-6,-4,3,-1,2},{2,-1,5,-6,-3,4},{6,-5,4,-3,2,-1},{-3,4,1,-2,6,-5},{-4,5,-6,1,-2,3},{-6,-3,2,5,-4,1},{3,-4,-1,2,-6,5},{4,6,-5,-1,3,-2},{-2,1,6,-5,4,-3},{-5,3,-2,6,1,-4}};
  int result=TtpSolutionHelper.calculateCosts(schedule,instance);
  assertThat(result,is(23916));
}",0.9287020109689214
183962,"@Test public void testCalculateCosts_shouldReturn8276(){
  sc.setProblemInstance(instance);
  TTPSolution sol=sc.getInitialSolution();
  int[][] schedule={{3,4,-1,-2},{2,-1,4,-3},{4,-3,2,-1},{-3,-4,1,2},{-2,1,-4,3},{-4,3,-2,1}};
  int result=TtpSolutionHelper.calculateCosts(schedule,instance);
  assertThat(result,is(8276));
}","@Test public void testCalculateCosts_shouldReturn8276(){
  int[][] schedule={{3,4,-1,-2},{2,-1,4,-3},{4,-3,2,-1},{-3,-4,1,2},{-2,1,-4,3},{-4,3,-2,1}};
  int result=TtpSolutionHelper.calculateCosts(schedule,instance);
  assertThat(result,is(8276));
}",0.8645833333333334
183963,"@Test public void testCalculateCosts_shouldReturn23978() throws Exception {
  File file=new File(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  instance=TTPProblemInstanceReader.readProblemInstance(file);
  sc.setProblemInstance(instance);
  TTPSolution sol=sc.getInitialSolution();
  int[][] schedule={{-5,-3,2,6,1,-4},{-3,6,1,-5,4,-2},{4,-5,6,-1,2,-3},{2,-1,-4,3,-6,5},{-6,3,-2,5,-4,1},{-4,-6,5,1,-3,2},{-2,1,4,-3,6,-5},{6,4,-5,-2,3,-1},{3,5,-1,-6,-2,4},{5,-4,-6,2,-1,3}};
  int result=TtpSolutionHelper.calculateCosts(schedule,instance);
  assertThat(result,is(23978));
}","@Test public void testCalculateCosts_shouldReturn23978() throws Exception {
  File file=new File(""String_Node_Str"" + File.separator + ""String_Node_Str"");
  instance=TTPProblemInstanceReader.readProblemInstance(file);
  int[][] schedule={{-5,-3,2,6,1,-4},{-3,6,1,-5,4,-2},{4,-5,6,-1,2,-3},{2,-1,-4,3,-6,5},{-6,3,-2,5,-4,1},{-4,-6,5,1,-3,2},{-2,1,4,-3,6,-5},{6,4,-5,-2,3,-1},{3,5,-1,-6,-2,4},{5,-4,-6,2,-1,3}};
  int result=TtpSolutionHelper.calculateCosts(schedule,instance);
  assertThat(result,is(23978));
}",0.9287020109689214
183964,"@Override public void init(T solution){
  this.baseSolution=solution;
  neighborhood_one.init(baseSolution);
  currentBase=null;
}","@Override public void init(T solution){
  lastSolution=solution;
  newNeighborhood=true;
  nIndex=0;
}",0.75
183965,"@Override public boolean hasNext(){
  if (currentBase == null) {
    if (neighborhood_one.hasNext()) {
      return true;
    }
 else     return false;
  }
 else {
    if (neighborhood_Two.hasNext()) {
      return true;
    }
 else {
      if (neighborhood_one.hasNext()) {
        return true;
      }
 else       return false;
    }
  }
}","@Override public boolean hasNext(){
  if (currentNeighborhood != null) {
    while (!currentNeighborhood.hasNext() && !newNeighborhood) {
      nIndex--;
      newNeighborhood=false;
      if (nIndex < 0)       break;
      currentNeighborhood=neighborhoods.get(nIndex);
    }
  }
  if (nIndex >= 0)   return true;
  return false;
}",0.1961367013372957
183966,"@Override public T getNext(){
  if (currentBase == null) {
    if (neighborhood_one.hasNext()) {
      currentBase=neighborhood_one.getNext();
      neighborhood_Two.init(currentBase);
      return currentBase;
    }
 else     return null;
  }
 else {
    if (neighborhood_Two.hasNext()) {
      return neighborhood_Two.getNext();
    }
 else {
      if (neighborhood_one.hasNext()) {
        currentBase=neighborhood_one.getNext();
        neighborhood_Two.init(currentBase);
        return currentBase;
      }
 else       return null;
    }
  }
}","@Override public T getNext(){
  if (newNeighborhood) {
    currentNeighborhood=neighborhoods.get(nIndex);
    currentNeighborhood.init(lastSolution);
    if ((nIndex + 1) < neighborhoods.size()) {
      nIndex++;
      newNeighborhood=true;
      return getNext();
    }
 else {
      newNeighborhood=false;
      lastSolution=currentNeighborhood.getNext();
      return lastSolution;
    }
  }
 else {
    while (!currentNeighborhood.hasNext()) {
      nIndex--;
      newNeighborhood=false;
      if (nIndex < 0)       break;
      currentNeighborhood=neighborhoods.get(nIndex);
    }
    if (nIndex >= 0) {
      lastSolution=currentNeighborhood.getNext();
      if ((nIndex + 1) < neighborhoods.size()) {
        nIndex++;
        newNeighborhood=true;
      }
      return lastSolution;
    }
 else     return null;
  }
}",0.1570909090909091
183967,"public static boolean checkSolution(TTPSolution next){
  for (int i=0; i < next.getSchedule().length; i++) {
    for (int j=0; j < next.getSchedule()[i].length; j++) {
      int enemy=next.getSchedule()[i][j];
      if (enemy < 0) {
        if (next.getSchedule()[i][-enemy - 1] != j + 1)         return false;
        if (-enemy == j + 1)         return false;
      }
 else {
        if (next.getSchedule()[i][enemy - 1] != -(j + 1))         return false;
        if (enemy == j + 1)         return false;
      }
    }
  }
  return true;
}","public static boolean checkSolution(TTPSolution next){
  for (int i=0; i < next.getSchedule().length; i++) {
    for (int j=0; j < next.getSchedule()[i].length; j++) {
      int enemy=next.getSchedule()[i][j];
      if (enemy < 0) {
        if (next.getSchedule()[i][-enemy - 1] != j + 1)         return false;
        if (-enemy == j + 1)         return false;
      }
 else {
        if (next.getSchedule()[i][enemy - 1] != -(j + 1))         return false;
        if (enemy == j + 1)         return false;
      }
    }
  }
  for (int i=0; i < next.getSchedule()[0].length; i++) {
    boolean[] homeGames=new boolean[next.getSchedule()[i].length];
    boolean[] visitorGames=new boolean[next.getSchedule()[i].length];
    for (int j=0; j < next.getSchedule().length; j++) {
      if (next.getSchedule()[j][i] > 0) {
        homeGames[next.getSchedule()[j][i] - 1]=true;
      }
 else {
        visitorGames[-next.getSchedule()[j][i] - 1]=true;
      }
    }
    for (int k=0; k < next.getSchedule()[i].length - 1; k++) {
      if (k == i)       continue;
      if (!homeGames[k])       return false;
      if (!visitorGames[k])       return false;
    }
  }
  return true;
}",0.6158323632130385
183968,"public SlapCommand(SlapPlugin plugin){
  this.plugin=plugin;
}","public SlapCommand(SlapPlugin plugin){
  this.plugin=plugin;
  this.methods=new SlapMethods(plugin);
}",0.7560975609756098
183969,"@Override public boolean onCommand(CommandSender slapper,Command command,String label,String[] split){
  if (plugin.usePermissions) {
    if (slapper instanceof Player && !(plugin.permissionHandler.has((Player)slapper,""String_Node_Str""))) {
      slapper.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return true;
    }
  }
 else   if (!(slapper.isOp())) {
    slapper.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
  String slapperName;
  if (slapper instanceof Player) {
    Player slapperCast=(Player)slapper;
    slapperName=slapperCast.getDisplayName();
  }
 else   if (slapper instanceof ConsoleCommandSender) {
    slapperName=""String_Node_Str"";
  }
 else {
    slapperName=""String_Node_Str"";
  }
  if (split.length == 1 || split.length == 2) {
    List<Player> matchedPlayers=plugin.getServer().matchPlayer(split[0]);
    String slappeeName=split[0];
    if (matchedPlayers.size() == 1) {
      if (split.length == 1) {
        slapPlayer(matchedPlayers.get(0),2,slapperName);
      }
 else {
        float force;
        try {
          force=Float.parseFloat(split[1]);
        }
 catch (        NumberFormatException e) {
          slapper.sendMessage(""String_Node_Str"");
          return true;
        }
        if (force > 10) {
          force=10;
        }
 else         if (force <= 0) {
          force=0.1f;
        }
        slapPlayer(matchedPlayers.get(0),force,slapperName);
      }
    }
 else     if (matchedPlayers.isEmpty()) {
      slapper.sendMessage(""String_Node_Str"" + slappeeName + ""String_Node_Str"");
    }
 else     if (matchedPlayers.size() > 1) {
      slapper.sendMessage(slappeeName + ""String_Node_Str"");
    }
 else {
      slapper.sendMessage(""String_Node_Str"");
    }
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean onCommand(CommandSender slapper,Command command,String label,String[] split){
  String slapperName;
  if (slapper instanceof Player) {
    Player slapperCast=(Player)slapper;
    slapperName=slapperCast.getDisplayName();
  }
 else   if (slapper instanceof ConsoleCommandSender) {
    slapperName=""String_Node_Str"";
  }
 else {
    slapperName=""String_Node_Str"";
  }
  if (split.length == 1 || split.length == 2) {
    List<Player> matchedPlayers=plugin.getServer().matchPlayer(split[0]);
    String slappeeName=split[0];
    if (matchedPlayers.size() == 1) {
      slappeeName=matchedPlayers.get(0).getDisplayName();
      float force;
      if (split.length == 1) {
        force=2;
      }
 else {
        force=methods.getForce(split[1]);
        if (force == -1) {
          slapper.sendMessage(""String_Node_Str"");
          return true;
        }
      }
      methods.slapPlayer(matchedPlayers.get(0),force,slapperName,true);
    }
 else     if (matchedPlayers.isEmpty()) {
      slapper.sendMessage(""String_Node_Str"" + slappeeName + ""String_Node_Str"");
    }
 else     if (matchedPlayers.size() > 1) {
      slapper.sendMessage(slappeeName + ""String_Node_Str"");
    }
 else {
      slapper.sendMessage(""String_Node_Str"");
    }
    return true;
  }
 else {
    return false;
  }
}",0.4622823984526112
183970,"/** 
 * Load and parse the YAML config file
 */
public static void load(){
  File dataDirectory=new File(""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator);
  dataDirectory.mkdirs();
  File file=new File(""String_Node_Str"" + File.separator + ""String_Node_Str"",""String_Node_Str"");
  config=new Configuration(file);
  config.load();
  if (!file.exists()) {
    config.setProperty(""String_Node_Str"",getDefaultMessages());
    config.setProperty(""String_Node_Str"",debugMode);
    config.save();
  }
  setSettings();
}","public void load(){
  plugin.reloadConfig();
  config=plugin.getConfig();
  config.addDefault(""String_Node_Str"",false);
  config.addDefault(""String_Node_Str"",""String_Node_Str"");
  config.addDefault(""String_Node_Str"",""String_Node_Str"");
  config.addDefault(""String_Node_Str"",""String_Node_Str"");
  config.addDefault(""String_Node_Str"",""String_Node_Str"");
  config.addDefault(""String_Node_Str"",""String_Node_Str"");
  config.options().copyDefaults(true);
  loadMessages();
  isDebug=config.getBoolean(""String_Node_Str"");
  plugin.saveConfig();
}",0.0205223880597014
183971,"public void debug(String s){
  if (SlapConfig.debugMode) {
    logger.log(Level.INFO,""String_Node_Str"" + s);
  }
}","public void debug(String s){
  if (plugin.config.isDebug()) {
    logger.log(Level.INFO,""String_Node_Str"" + s);
  }
}",0.9090909090909092
183972,"@Override public boolean onCommand(CommandSender slapper,Command command,String label,String[] split){
  if (plugin.usePermissions) {
    if (!(plugin.permissionHandler.has((Player)slapper,""String_Node_Str""))) {
      slapper.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return true;
    }
  }
 else   if (!(slapper.isOp())) {
    slapper.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
  String slapperName;
  if (slapper instanceof Player) {
    Player slapperCast=(Player)slapper;
    slapperName=slapperCast.getDisplayName();
  }
 else   if (slapper instanceof ConsoleCommandSender) {
    slapperName=""String_Node_Str"";
  }
 else {
    slapperName=""String_Node_Str"";
  }
  if (split.length == 1 || split.length == 2) {
    List<Player> matchedPlayers=plugin.getServer().matchPlayer(split[0]);
    String slappeeName=split[0];
    if (matchedPlayers.size() == 1) {
      if (split.length == 1) {
        slapPlayer(matchedPlayers.get(0),2,slapperName);
      }
 else {
        float force=Float.parseFloat(split[1]);
        if (force > 10) {
          force=10;
        }
 else         if (force <= 0) {
          force=0.1f;
        }
        slapPlayer(matchedPlayers.get(0),force,slapperName);
      }
    }
 else     if (matchedPlayers.isEmpty()) {
      slapper.sendMessage(""String_Node_Str"" + slappeeName + ""String_Node_Str"");
    }
 else     if (matchedPlayers.size() > 1) {
      slapper.sendMessage(slappeeName + ""String_Node_Str"");
    }
 else {
      slapper.sendMessage(""String_Node_Str"");
    }
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean onCommand(CommandSender slapper,Command command,String label,String[] split){
  if (plugin.usePermissions) {
    if (!(plugin.permissionHandler.has((Player)slapper,""String_Node_Str""))) {
      slapper.sendMessage(ChatColor.RED + ""String_Node_Str"");
      return true;
    }
  }
 else   if (!(slapper.isOp())) {
    slapper.sendMessage(ChatColor.RED + ""String_Node_Str"");
    return true;
  }
  String slapperName;
  if (slapper instanceof Player) {
    Player slapperCast=(Player)slapper;
    slapperName=slapperCast.getDisplayName();
  }
 else   if (slapper instanceof ConsoleCommandSender) {
    slapperName=""String_Node_Str"";
  }
 else {
    slapperName=""String_Node_Str"";
  }
  if (split.length == 1 || split.length == 2) {
    List<Player> matchedPlayers=plugin.getServer().matchPlayer(split[0]);
    String slappeeName=split[0];
    if (matchedPlayers.size() == 1) {
      if (split.length == 1) {
        slapPlayer(matchedPlayers.get(0),2,slapperName);
      }
 else {
        float force;
        try {
          force=Float.parseFloat(split[1]);
        }
 catch (        NumberFormatException e) {
          slapper.sendMessage(""String_Node_Str"");
          return true;
        }
        if (force > 10) {
          force=10;
        }
 else         if (force <= 0) {
          force=0.1f;
        }
        slapPlayer(matchedPlayers.get(0),force,slapperName);
      }
    }
 else     if (matchedPlayers.isEmpty()) {
      slapper.sendMessage(""String_Node_Str"" + slappeeName + ""String_Node_Str"");
    }
 else     if (matchedPlayers.size() > 1) {
      slapper.sendMessage(slappeeName + ""String_Node_Str"");
    }
 else {
      slapper.sendMessage(""String_Node_Str"");
    }
    return true;
  }
 else {
    return false;
  }
}",0.9502235469448584
183973,"/** 
 * Build up the entries to display on the screen.
 * @param personCursor the URI for the contact being displayed
 */
private final void buildEntries(){
  final int numSections=mSections.size();
  for (int i=0; i < numSections; i++) {
    mSections.get(i).clear();
  }
  mRawContactIds.clear();
  mReadOnlySourcesCnt=0;
  mWritableSourcesCnt=0;
  mAllRestricted=true;
  mPrimaryPhoneUri=null;
  mWritableRawContactIds.clear();
  final Context context=this;
  final Sources sources=Sources.getInstance(context);
  if (mLookupUri != null) {
    for (    Entity entity : mEntities) {
      final ContentValues entValues=entity.getEntityValues();
      final String accountType=entValues.getAsString(RawContacts.ACCOUNT_TYPE);
      final long rawContactId=entValues.getAsLong(RawContacts._ID);
      final boolean isRestricted=entValues.getAsInteger(RawContacts.IS_RESTRICTED) != 0;
      if (!isRestricted)       mAllRestricted=false;
      if (!mRawContactIds.contains(rawContactId)) {
        mRawContactIds.add(rawContactId);
      }
      ContactsSource contactsSource=sources.getInflatedSource(accountType,ContactsSource.LEVEL_SUMMARY);
      if (contactsSource != null && contactsSource.readOnly) {
        mReadOnlySourcesCnt+=1;
      }
 else {
        mWritableSourcesCnt+=1;
        mWritableRawContactIds.add(rawContactId);
      }
      for (      NamedContentValues subValue : entity.getSubValues()) {
        final ContentValues entryValues=subValue.values;
        entryValues.put(Data.RAW_CONTACT_ID,rawContactId);
        final long dataId=entryValues.getAsLong(Data._ID);
        final String mimeType=entryValues.getAsString(Data.MIMETYPE);
        if (mimeType == null)         continue;
        final DataKind kind=sources.getKindOrFallback(accountType,mimeType,this,ContactsSource.LEVEL_MIMETYPES);
        if (kind == null)         continue;
        final ViewEntry entry=ViewEntry.fromValues(context,mimeType,kind,rawContactId,dataId,entryValues);
        final boolean hasData=!TextUtils.isEmpty(entry.data);
        final boolean isSuperPrimary=entryValues.getAsInteger(Data.IS_SUPER_PRIMARY) != 0;
        if (Phone.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          mNumPhoneNumbers++;
          entry.intent=new Intent(Intent.ACTION_CALL_PRIVILEGED,Uri.fromParts(Constants.SCHEME_TEL,entry.data,null));
          entry.secondaryIntent=new Intent(Intent.ACTION_SENDTO,Uri.fromParts(Constants.SCHEME_SMSTO,entry.data,null));
          if (isSuperPrimary)           mPrimaryPhoneUri=entry.uri;
          entry.isPrimary=isSuperPrimary;
          mPhoneEntries.add(entry);
          Integer type;
          try {
            type=entryValues.getAsInteger(Phone.TYPE);
          }
 catch (          NullPointerException e) {
            type=CommonDataKinds.Phone.TYPE_HOME;
          }
          if (type == CommonDataKinds.Phone.TYPE_MOBILE || mShowSmsLinksForAllPhones) {
            if (kind.iconAltRes > 0) {
              entry.secondaryActionIcon=kind.iconAltRes;
            }
          }
        }
 else         if (Email.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.intent=new Intent(Intent.ACTION_SENDTO,Uri.fromParts(Constants.SCHEME_MAILTO,entry.data,null));
          entry.isPrimary=isSuperPrimary;
          mEmailEntries.add(entry);
          final DataStatus status=mStatuses.get(entry.id);
          if (status != null) {
            final String imMime=Im.CONTENT_ITEM_TYPE;
            final DataKind imKind=sources.getKindOrFallback(accountType,imMime,this,ContactsSource.LEVEL_MIMETYPES);
            final ViewEntry imEntry=ViewEntry.fromValues(context,imMime,imKind,rawContactId,dataId,entryValues);
            imEntry.intent=ContactsUtils.buildImIntent(entryValues);
            imEntry.applyStatus(status,false);
            mImEntries.add(imEntry);
          }
        }
 else         if (StructuredPostal.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.maxLines=4;
          entry.intent=new Intent(Intent.ACTION_VIEW,entry.uri);
          Intent i=startNavigation(entry.data);
          if (i != null) {
            entry.secondaryIntent=i;
            if (kind.iconAltRes > 0) {
              entry.secondaryActionIcon=kind.iconAltRes;
            }
          }
          mPostalEntries.add(entry);
        }
 else         if (Im.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.intent=ContactsUtils.buildImIntent(entryValues);
          if (TextUtils.isEmpty(entry.label)) {
            entry.label=getString(R.string.chat).toLowerCase();
          }
          final DataStatus status=mStatuses.get(entry.id);
          if (status != null) {
            entry.applyStatus(status,false);
          }
          mImEntries.add(entry);
        }
 else         if (Organization.CONTENT_ITEM_TYPE.equals(mimeType) && (hasData || !TextUtils.isEmpty(entry.label))) {
          final boolean isNameRawContact=(mNameRawContactId == rawContactId);
          final boolean duplicatesTitle=isNameRawContact && mDisplayNameSource == DisplayNameSources.ORGANIZATION && (!hasData || TextUtils.isEmpty(entry.label));
          if (!duplicatesTitle) {
            entry.uri=null;
            if (TextUtils.isEmpty(entry.label)) {
              entry.label=entry.data;
              entry.data=""String_Node_Str"";
            }
            mOrganizationEntries.add(entry);
          }
        }
 else         if (Nickname.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          final boolean isNameRawContact=(mNameRawContactId == rawContactId);
          final boolean duplicatesTitle=isNameRawContact && mDisplayNameSource == DisplayNameSources.NICKNAME;
          if (!duplicatesTitle) {
            entry.uri=null;
            mNicknameEntries.add(entry);
          }
        }
 else         if (Note.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.uri=null;
          entry.maxLines=100;
          mOtherEntries.add(entry);
        }
 else         if (Website.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.uri=null;
          entry.maxLines=10;
          try {
            WebAddress webAddress=new WebAddress(entry.data);
            entry.intent=new Intent(Intent.ACTION_VIEW,Uri.parse(webAddress.toString()));
          }
 catch (          ParseException e) {
            Log.e(TAG,""String_Node_Str"" + entry.data);
          }
          mOtherEntries.add(entry);
        }
 else {
          entry.intent=new Intent(Intent.ACTION_VIEW,entry.uri);
          final DataStatus status=mStatuses.get(entry.id);
          final boolean hasSocial=kind.actionBodySocial && status != null;
          if (hasSocial) {
            entry.applyStatus(status,true);
          }
          if (hasSocial || hasData) {
            mOtherEntries.add(entry);
          }
        }
      }
    }
  }
}","/** 
 * Build up the entries to display on the screen.
 * @param personCursor the URI for the contact being displayed
 */
private final void buildEntries(){
  final int numSections=mSections.size();
  for (int i=0; i < numSections; i++) {
    mSections.get(i).clear();
  }
  mRawContactIds.clear();
  mReadOnlySourcesCnt=0;
  mWritableSourcesCnt=0;
  mAllRestricted=true;
  mPrimaryPhoneUri=null;
  mWritableRawContactIds.clear();
  final Context context=this;
  final Sources sources=Sources.getInstance(context);
  if (mLookupUri != null) {
    for (    Entity entity : mEntities) {
      final ContentValues entValues=entity.getEntityValues();
      final String accountType=entValues.getAsString(RawContacts.ACCOUNT_TYPE);
      final long rawContactId=entValues.getAsLong(RawContacts._ID);
      final boolean isRestricted=entValues.getAsInteger(RawContacts.IS_RESTRICTED) != 0;
      if (!isRestricted)       mAllRestricted=false;
      if (!mRawContactIds.contains(rawContactId)) {
        mRawContactIds.add(rawContactId);
      }
      ContactsSource contactsSource=sources.getInflatedSource(accountType,ContactsSource.LEVEL_SUMMARY);
      if (contactsSource != null && contactsSource.readOnly) {
        mReadOnlySourcesCnt+=1;
      }
 else {
        mWritableSourcesCnt+=1;
        mWritableRawContactIds.add(rawContactId);
      }
      for (      NamedContentValues subValue : entity.getSubValues()) {
        final ContentValues entryValues=subValue.values;
        entryValues.put(Data.RAW_CONTACT_ID,rawContactId);
        final long dataId=entryValues.getAsLong(Data._ID);
        final String mimeType=entryValues.getAsString(Data.MIMETYPE);
        if (mimeType == null)         continue;
        final DataKind kind=sources.getKindOrFallback(accountType,mimeType,this,ContactsSource.LEVEL_MIMETYPES);
        if (kind == null)         continue;
        final ViewEntry entry=ViewEntry.fromValues(context,mimeType,kind,rawContactId,dataId,entryValues);
        final boolean hasData=!TextUtils.isEmpty(entry.data);
        final boolean isSuperPrimary=entryValues.getAsInteger(Data.IS_SUPER_PRIMARY) != 0;
        if (Phone.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          mNumPhoneNumbers++;
          entry.intent=new Intent(Intent.ACTION_CALL_PRIVILEGED,Uri.fromParts(Constants.SCHEME_TEL,entry.data,null));
          entry.secondaryIntent=new Intent(Intent.ACTION_SENDTO,Uri.fromParts(Constants.SCHEME_SMSTO,entry.data,null));
          if (isSuperPrimary)           mPrimaryPhoneUri=entry.uri;
          entry.isPrimary=isSuperPrimary;
          mPhoneEntries.add(entry);
          Integer type=entryValues.getAsInteger(Phone.TYPE);
          if (type.intValue() == (CommonDataKinds.Phone.TYPE_MOBILE) || mShowSmsLinksForAllPhones) {
            if (kind.iconAltRes > 0) {
              entry.secondaryActionIcon=kind.iconAltRes;
            }
          }
        }
 else         if (Email.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.intent=new Intent(Intent.ACTION_SENDTO,Uri.fromParts(Constants.SCHEME_MAILTO,entry.data,null));
          entry.isPrimary=isSuperPrimary;
          mEmailEntries.add(entry);
          final DataStatus status=mStatuses.get(entry.id);
          if (status != null) {
            final String imMime=Im.CONTENT_ITEM_TYPE;
            final DataKind imKind=sources.getKindOrFallback(accountType,imMime,this,ContactsSource.LEVEL_MIMETYPES);
            final ViewEntry imEntry=ViewEntry.fromValues(context,imMime,imKind,rawContactId,dataId,entryValues);
            imEntry.intent=ContactsUtils.buildImIntent(entryValues);
            imEntry.applyStatus(status,false);
            mImEntries.add(imEntry);
          }
        }
 else         if (StructuredPostal.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.maxLines=4;
          entry.intent=new Intent(Intent.ACTION_VIEW,entry.uri);
          Intent i=startNavigation(entry.data);
          if (i != null) {
            entry.secondaryIntent=i;
            if (kind.iconAltRes > 0) {
              entry.secondaryActionIcon=kind.iconAltRes;
            }
          }
          mPostalEntries.add(entry);
        }
 else         if (Im.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.intent=ContactsUtils.buildImIntent(entryValues);
          if (TextUtils.isEmpty(entry.label)) {
            entry.label=getString(R.string.chat).toLowerCase();
          }
          final DataStatus status=mStatuses.get(entry.id);
          if (status != null) {
            entry.applyStatus(status,false);
          }
          mImEntries.add(entry);
        }
 else         if (Organization.CONTENT_ITEM_TYPE.equals(mimeType) && (hasData || !TextUtils.isEmpty(entry.label))) {
          final boolean isNameRawContact=(mNameRawContactId == rawContactId);
          final boolean duplicatesTitle=isNameRawContact && mDisplayNameSource == DisplayNameSources.ORGANIZATION && (!hasData || TextUtils.isEmpty(entry.label));
          if (!duplicatesTitle) {
            entry.uri=null;
            if (TextUtils.isEmpty(entry.label)) {
              entry.label=entry.data;
              entry.data=""String_Node_Str"";
            }
            mOrganizationEntries.add(entry);
          }
        }
 else         if (Nickname.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          final boolean isNameRawContact=(mNameRawContactId == rawContactId);
          final boolean duplicatesTitle=isNameRawContact && mDisplayNameSource == DisplayNameSources.NICKNAME;
          if (!duplicatesTitle) {
            entry.uri=null;
            mNicknameEntries.add(entry);
          }
        }
 else         if (Note.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.uri=null;
          entry.maxLines=100;
          mOtherEntries.add(entry);
        }
 else         if (Website.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.uri=null;
          entry.maxLines=10;
          try {
            WebAddress webAddress=new WebAddress(entry.data);
            entry.intent=new Intent(Intent.ACTION_VIEW,Uri.parse(webAddress.toString()));
          }
 catch (          ParseException e) {
            Log.e(TAG,""String_Node_Str"" + entry.data);
          }
          mOtherEntries.add(entry);
        }
 else {
          entry.intent=new Intent(Intent.ACTION_VIEW,entry.uri);
          final DataStatus status=mStatuses.get(entry.id);
          final boolean hasSocial=kind.actionBodySocial && status != null;
          if (hasSocial) {
            entry.applyStatus(status,true);
          }
          if (hasSocial || hasData) {
            mOtherEntries.add(entry);
          }
        }
      }
    }
  }
}",0.9861635220125786
183974,"/** 
 * Build up the entries to display on the screen.
 * @param personCursor the URI for the contact being displayed
 */
private final void buildEntries(){
  final int numSections=mSections.size();
  for (int i=0; i < numSections; i++) {
    mSections.get(i).clear();
  }
  mRawContactIds.clear();
  mReadOnlySourcesCnt=0;
  mWritableSourcesCnt=0;
  mAllRestricted=true;
  mPrimaryPhoneUri=null;
  mWritableRawContactIds.clear();
  final Context context=this;
  final Sources sources=Sources.getInstance(context);
  if (mLookupUri != null) {
    for (    Entity entity : mEntities) {
      final ContentValues entValues=entity.getEntityValues();
      final String accountType=entValues.getAsString(RawContacts.ACCOUNT_TYPE);
      final long rawContactId=entValues.getAsLong(RawContacts._ID);
      final boolean isRestricted=entValues.getAsInteger(RawContacts.IS_RESTRICTED) != 0;
      if (!isRestricted)       mAllRestricted=false;
      if (!mRawContactIds.contains(rawContactId)) {
        mRawContactIds.add(rawContactId);
      }
      ContactsSource contactsSource=sources.getInflatedSource(accountType,ContactsSource.LEVEL_SUMMARY);
      if (contactsSource != null && contactsSource.readOnly) {
        mReadOnlySourcesCnt+=1;
      }
 else {
        mWritableSourcesCnt+=1;
        mWritableRawContactIds.add(rawContactId);
      }
      for (      NamedContentValues subValue : entity.getSubValues()) {
        final ContentValues entryValues=subValue.values;
        entryValues.put(Data.RAW_CONTACT_ID,rawContactId);
        final long dataId=entryValues.getAsLong(Data._ID);
        final String mimeType=entryValues.getAsString(Data.MIMETYPE);
        if (mimeType == null)         continue;
        final DataKind kind=sources.getKindOrFallback(accountType,mimeType,this,ContactsSource.LEVEL_MIMETYPES);
        if (kind == null)         continue;
        final ViewEntry entry=ViewEntry.fromValues(context,mimeType,kind,rawContactId,dataId,entryValues);
        final boolean hasData=!TextUtils.isEmpty(entry.data);
        final boolean isSuperPrimary=entryValues.getAsInteger(Data.IS_SUPER_PRIMARY) != 0;
        if (Phone.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          mNumPhoneNumbers++;
          entry.intent=new Intent(Intent.ACTION_CALL_PRIVILEGED,Uri.fromParts(Constants.SCHEME_TEL,entry.data,null));
          entry.secondaryIntent=new Intent(Intent.ACTION_SENDTO,Uri.fromParts(Constants.SCHEME_SMSTO,entry.data,null));
          if (isSuperPrimary)           mPrimaryPhoneUri=entry.uri;
          entry.isPrimary=isSuperPrimary;
          mPhoneEntries.add(entry);
          final Integer type=entryValues.getAsInteger(Phone.TYPE);
          if (type == CommonDataKinds.Phone.TYPE_MOBILE || mShowSmsLinksForAllPhones) {
            if (kind.iconAltRes > 0) {
              entry.secondaryActionIcon=kind.iconAltRes;
            }
          }
        }
 else         if (Email.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.intent=new Intent(Intent.ACTION_SENDTO,Uri.fromParts(Constants.SCHEME_MAILTO,entry.data,null));
          entry.isPrimary=isSuperPrimary;
          mEmailEntries.add(entry);
          final DataStatus status=mStatuses.get(entry.id);
          if (status != null) {
            final String imMime=Im.CONTENT_ITEM_TYPE;
            final DataKind imKind=sources.getKindOrFallback(accountType,imMime,this,ContactsSource.LEVEL_MIMETYPES);
            final ViewEntry imEntry=ViewEntry.fromValues(context,imMime,imKind,rawContactId,dataId,entryValues);
            imEntry.intent=ContactsUtils.buildImIntent(entryValues);
            imEntry.applyStatus(status,false);
            mImEntries.add(imEntry);
          }
        }
 else         if (StructuredPostal.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.maxLines=4;
          entry.intent=new Intent(Intent.ACTION_VIEW,entry.uri);
          Intent i=startNavigation(entry.data);
          if (i != null) {
            entry.secondaryIntent=i;
            if (kind.iconAltRes > 0) {
              entry.secondaryActionIcon=kind.iconAltRes;
            }
          }
          mPostalEntries.add(entry);
        }
 else         if (Im.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.intent=ContactsUtils.buildImIntent(entryValues);
          if (TextUtils.isEmpty(entry.label)) {
            entry.label=getString(R.string.chat).toLowerCase();
          }
          final DataStatus status=mStatuses.get(entry.id);
          if (status != null) {
            entry.applyStatus(status,false);
          }
          mImEntries.add(entry);
        }
 else         if (Organization.CONTENT_ITEM_TYPE.equals(mimeType) && (hasData || !TextUtils.isEmpty(entry.label))) {
          final boolean isNameRawContact=(mNameRawContactId == rawContactId);
          final boolean duplicatesTitle=isNameRawContact && mDisplayNameSource == DisplayNameSources.ORGANIZATION && (!hasData || TextUtils.isEmpty(entry.label));
          if (!duplicatesTitle) {
            entry.uri=null;
            if (TextUtils.isEmpty(entry.label)) {
              entry.label=entry.data;
              entry.data=""String_Node_Str"";
            }
            mOrganizationEntries.add(entry);
          }
        }
 else         if (Nickname.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          final boolean isNameRawContact=(mNameRawContactId == rawContactId);
          final boolean duplicatesTitle=isNameRawContact && mDisplayNameSource == DisplayNameSources.NICKNAME;
          if (!duplicatesTitle) {
            entry.uri=null;
            mNicknameEntries.add(entry);
          }
        }
 else         if (Note.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.uri=null;
          entry.maxLines=100;
          mOtherEntries.add(entry);
        }
 else         if (Website.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.uri=null;
          entry.maxLines=10;
          try {
            WebAddress webAddress=new WebAddress(entry.data);
            entry.intent=new Intent(Intent.ACTION_VIEW,Uri.parse(webAddress.toString()));
          }
 catch (          ParseException e) {
            Log.e(TAG,""String_Node_Str"" + entry.data);
          }
          mOtherEntries.add(entry);
        }
 else {
          entry.intent=new Intent(Intent.ACTION_VIEW,entry.uri);
          final DataStatus status=mStatuses.get(entry.id);
          final boolean hasSocial=kind.actionBodySocial && status != null;
          if (hasSocial) {
            entry.applyStatus(status,true);
          }
          if (hasSocial || hasData) {
            mOtherEntries.add(entry);
          }
        }
      }
    }
  }
}","/** 
 * Build up the entries to display on the screen.
 * @param personCursor the URI for the contact being displayed
 */
private final void buildEntries(){
  final int numSections=mSections.size();
  for (int i=0; i < numSections; i++) {
    mSections.get(i).clear();
  }
  mRawContactIds.clear();
  mReadOnlySourcesCnt=0;
  mWritableSourcesCnt=0;
  mAllRestricted=true;
  mPrimaryPhoneUri=null;
  mWritableRawContactIds.clear();
  final Context context=this;
  final Sources sources=Sources.getInstance(context);
  if (mLookupUri != null) {
    for (    Entity entity : mEntities) {
      final ContentValues entValues=entity.getEntityValues();
      final String accountType=entValues.getAsString(RawContacts.ACCOUNT_TYPE);
      final long rawContactId=entValues.getAsLong(RawContacts._ID);
      final boolean isRestricted=entValues.getAsInteger(RawContacts.IS_RESTRICTED) != 0;
      if (!isRestricted)       mAllRestricted=false;
      if (!mRawContactIds.contains(rawContactId)) {
        mRawContactIds.add(rawContactId);
      }
      ContactsSource contactsSource=sources.getInflatedSource(accountType,ContactsSource.LEVEL_SUMMARY);
      if (contactsSource != null && contactsSource.readOnly) {
        mReadOnlySourcesCnt+=1;
      }
 else {
        mWritableSourcesCnt+=1;
        mWritableRawContactIds.add(rawContactId);
      }
      for (      NamedContentValues subValue : entity.getSubValues()) {
        final ContentValues entryValues=subValue.values;
        entryValues.put(Data.RAW_CONTACT_ID,rawContactId);
        final long dataId=entryValues.getAsLong(Data._ID);
        final String mimeType=entryValues.getAsString(Data.MIMETYPE);
        if (mimeType == null)         continue;
        final DataKind kind=sources.getKindOrFallback(accountType,mimeType,this,ContactsSource.LEVEL_MIMETYPES);
        if (kind == null)         continue;
        final ViewEntry entry=ViewEntry.fromValues(context,mimeType,kind,rawContactId,dataId,entryValues);
        final boolean hasData=!TextUtils.isEmpty(entry.data);
        final boolean isSuperPrimary=entryValues.getAsInteger(Data.IS_SUPER_PRIMARY) != 0;
        if (Phone.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          mNumPhoneNumbers++;
          entry.intent=new Intent(Intent.ACTION_CALL_PRIVILEGED,Uri.fromParts(Constants.SCHEME_TEL,entry.data,null));
          entry.secondaryIntent=new Intent(Intent.ACTION_SENDTO,Uri.fromParts(Constants.SCHEME_SMSTO,entry.data,null));
          if (isSuperPrimary)           mPrimaryPhoneUri=entry.uri;
          entry.isPrimary=isSuperPrimary;
          mPhoneEntries.add(entry);
          Integer type;
          try {
            type=entryValues.getAsInteger(Phone.TYPE);
          }
 catch (          NullPointerException e) {
            type=CommonDataKinds.Phone.TYPE_HOME;
          }
          if (type == CommonDataKinds.Phone.TYPE_MOBILE || mShowSmsLinksForAllPhones) {
            if (kind.iconAltRes > 0) {
              entry.secondaryActionIcon=kind.iconAltRes;
            }
          }
        }
 else         if (Email.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.intent=new Intent(Intent.ACTION_SENDTO,Uri.fromParts(Constants.SCHEME_MAILTO,entry.data,null));
          entry.isPrimary=isSuperPrimary;
          mEmailEntries.add(entry);
          final DataStatus status=mStatuses.get(entry.id);
          if (status != null) {
            final String imMime=Im.CONTENT_ITEM_TYPE;
            final DataKind imKind=sources.getKindOrFallback(accountType,imMime,this,ContactsSource.LEVEL_MIMETYPES);
            final ViewEntry imEntry=ViewEntry.fromValues(context,imMime,imKind,rawContactId,dataId,entryValues);
            imEntry.intent=ContactsUtils.buildImIntent(entryValues);
            imEntry.applyStatus(status,false);
            mImEntries.add(imEntry);
          }
        }
 else         if (StructuredPostal.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.maxLines=4;
          entry.intent=new Intent(Intent.ACTION_VIEW,entry.uri);
          Intent i=startNavigation(entry.data);
          if (i != null) {
            entry.secondaryIntent=i;
            if (kind.iconAltRes > 0) {
              entry.secondaryActionIcon=kind.iconAltRes;
            }
          }
          mPostalEntries.add(entry);
        }
 else         if (Im.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.intent=ContactsUtils.buildImIntent(entryValues);
          if (TextUtils.isEmpty(entry.label)) {
            entry.label=getString(R.string.chat).toLowerCase();
          }
          final DataStatus status=mStatuses.get(entry.id);
          if (status != null) {
            entry.applyStatus(status,false);
          }
          mImEntries.add(entry);
        }
 else         if (Organization.CONTENT_ITEM_TYPE.equals(mimeType) && (hasData || !TextUtils.isEmpty(entry.label))) {
          final boolean isNameRawContact=(mNameRawContactId == rawContactId);
          final boolean duplicatesTitle=isNameRawContact && mDisplayNameSource == DisplayNameSources.ORGANIZATION && (!hasData || TextUtils.isEmpty(entry.label));
          if (!duplicatesTitle) {
            entry.uri=null;
            if (TextUtils.isEmpty(entry.label)) {
              entry.label=entry.data;
              entry.data=""String_Node_Str"";
            }
            mOrganizationEntries.add(entry);
          }
        }
 else         if (Nickname.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          final boolean isNameRawContact=(mNameRawContactId == rawContactId);
          final boolean duplicatesTitle=isNameRawContact && mDisplayNameSource == DisplayNameSources.NICKNAME;
          if (!duplicatesTitle) {
            entry.uri=null;
            mNicknameEntries.add(entry);
          }
        }
 else         if (Note.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.uri=null;
          entry.maxLines=100;
          mOtherEntries.add(entry);
        }
 else         if (Website.CONTENT_ITEM_TYPE.equals(mimeType) && hasData) {
          entry.uri=null;
          entry.maxLines=10;
          try {
            WebAddress webAddress=new WebAddress(entry.data);
            entry.intent=new Intent(Intent.ACTION_VIEW,Uri.parse(webAddress.toString()));
          }
 catch (          ParseException e) {
            Log.e(TAG,""String_Node_Str"" + entry.data);
          }
          mOtherEntries.add(entry);
        }
 else {
          entry.intent=new Intent(Intent.ACTION_VIEW,entry.uri);
          final DataStatus status=mStatuses.get(entry.id);
          final boolean hasSocial=kind.actionBodySocial && status != null;
          if (hasSocial) {
            entry.applyStatus(status,true);
          }
          if (hasSocial || hasData) {
            mOtherEntries.add(entry);
          }
        }
      }
    }
  }
}",0.9883032277169084
183975,"public void readFromParcel(Parcel source){
  final int size=source.readInt();
  for (int i=0; i < size; i++) {
    this.add(source.<EntityDelta>readParcelable(null));
  }
}","public void readFromParcel(Parcel source){
  final ClassLoader loader=getClass().getClassLoader();
  final int size=source.readInt();
  for (int i=0; i < size; i++) {
    this.add(source.<EntityDelta>readParcelable(loader));
  }
}",0.835820895522388
183976,"public void onClick(DialogInterface dialog,int which){
  dialog.dismiss();
  final ValuesDelta structuredName=allNames.get(which);
  structuredName.put(Data.IS_PRIMARY,1);
  structuredName.put(Data.IS_SUPER_PRIMARY,1);
}","public void onClick(DialogInterface dialog,int which){
  dialog.dismiss();
  final Account account=accountAdapter.getItem(which);
  createContact(account);
}",0.6047745358090185
183977,"@Override protected AlertDialog.Builder doInBackground(final EditContactActivity target,Void... params){
  final Sources sources=Sources.getInstance(target);
  final Context dialogContext=new ContextThemeWrapper(target,android.R.style.Theme_Light);
  final LayoutInflater dialogInflater=(LayoutInflater)dialogContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final ArrayList<Account> writable=sources.getAccounts(true);
  if (writable.isEmpty()) {
    selectAccount(null);
    return null;
  }
  if (writable.size() == 1) {
    selectAccount(writable.get(0));
    return null;
  }
  final ArrayAdapter<Account> accountAdapter=new ArrayAdapter<Account>(target,android.R.layout.simple_list_item_2,writable){
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      if (convertView == null) {
        convertView=dialogInflater.inflate(android.R.layout.simple_list_item_2,parent,false);
      }
      final TextView text1=(TextView)convertView.findViewById(android.R.id.text1);
      final TextView text2=(TextView)convertView.findViewById(android.R.id.text2);
      final Account account=this.getItem(position);
      final ContactsSource source=sources.getInflatedSource(account.type,ContactsSource.LEVEL_SUMMARY);
      text1.setText(account.name);
      text2.setText(source.getDisplayLabel(target));
      return convertView;
    }
  }
;
  final DialogInterface.OnClickListener clickListener=new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      dialog.dismiss();
      final Account account=accountAdapter.getItem(which);
      selectAccount(account);
      EditContactActivity target=mTarget.get();
      if (target != null) {
        target.bindEditors();
      }
    }
  }
;
  final DialogInterface.OnCancelListener cancelListener=new DialogInterface.OnCancelListener(){
    public void onCancel(    DialogInterface dialog){
      if (!target.hasValidState()) {
        target.finish();
      }
    }
  }
;
  final AlertDialog.Builder builder=new AlertDialog.Builder(target);
  builder.setTitle(R.string.dialog_new_contact_account);
  builder.setSingleChoiceItems(accountAdapter,0,clickListener);
  builder.setOnCancelListener(cancelListener);
  return builder;
}","@Override protected ArrayList<Account> doInBackground(final EditContactActivity target,Void... params){
  return Sources.getInstance(target).getAccounts(true);
}",0.1178878428162095
183978,"@Override protected void onPostExecute(EditContactActivity target,AlertDialog.Builder result){
  if (result != null) {
    target.showAndManageDialog(result.create());
  }
 else {
    target.bindEditors();
  }
}","@Override protected void onPostExecute(final EditContactActivity target,ArrayList<Account> accounts){
  target.selectAccountAndCreateContact(accounts);
}",0.5494505494505495
183979,"@Override public View getView(int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=dialogInflater.inflate(android.R.layout.simple_list_item_1,parent,false);
  }
  final ValuesDelta structuredName=this.getItem(position);
  final String displayName=structuredName.getAsString(StructuredName.DISPLAY_NAME);
  ((TextView)convertView).setText(displayName);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=dialogInflater.inflate(android.R.layout.simple_list_item_2,parent,false);
  }
  final TextView text1=(TextView)convertView.findViewById(android.R.id.text1);
  final TextView text2=(TextView)convertView.findViewById(android.R.id.text2);
  final Account account=this.getItem(position);
  final ContactsSource source=sources.getInflatedSource(account.type,ContactsSource.LEVEL_SUMMARY);
  text1.setText(account.name);
  text2.setText(source.getDisplayLabel(EditContactActivity.this));
  return convertView;
}",0.3521531100478469
183980,"public void onCancel(DialogInterface dialog){
  if (!target.hasValidState()) {
    target.finish();
  }
}","public void onCancel(DialogInterface dialog){
  if (!hasValidState()) {
    finish();
  }
}",0.9285714285714286
183981,"/** 
 * Return   {@link ContactsSource} for the given account type.
 */
public ContactsSource getInflatedSource(String accountType,int inflateLevel){
  ContactsSource source=mSources.get(accountType);
  if (source == null)   source=mFallbackSource;
  if (source.isInflated(inflateLevel)) {
    return source;
  }
 else {
    source.ensureInflated(mApplicationContext,inflateLevel);
    return source;
  }
}","/** 
 * Return   {@link ContactsSource} for the given account type.
 */
public ContactsSource getInflatedSource(String accountType,int inflateLevel){
  ContactsSource source=mSources.get(accountType);
  if (source == null)   source=mFallbackSource;
  if (source.isInflated(inflateLevel)) {
    return source;
  }
 else {
    source.ensureInflated(mContext,inflateLevel);
    return source;
  }
}",0.9862671660424468
183982,"/** 
 * @param contactUri In most cases, this should be a lookup {@link Uri}, possibly generated through   {@link Contacts#getLookupUri(long,String)}.
 */
private void returnPickerResult(Cursor c,String name,Uri contactUri){
  final Intent intent=new Intent();
  if (mShortcutAction != null) {
    Intent shortcutIntent;
    if (Intent.ACTION_VIEW.equals(mShortcutAction)) {
      shortcutIntent=new Intent(ContactsContract.QuickContact.ACTION_QUICK_CONTACT);
      shortcutIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
      shortcutIntent.setData(contactUri);
      shortcutIntent.putExtra(ContactsContract.QuickContact.EXTRA_MODE,ContactsContract.QuickContact.MODE_LARGE);
      shortcutIntent.putExtra(ContactsContract.QuickContact.EXTRA_EXCLUDE_MIMES,(String[])null);
      final Bitmap icon=framePhoto(loadContactPhoto(contactUri,null));
      if (icon != null) {
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON,scaleToAppIconSize(icon));
      }
 else {
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE,Intent.ShortcutIconResource.fromContext(this,R.drawable.ic_launcher_shortcut_contact));
      }
    }
 else {
      String number=c.getString(PHONE_NUMBER_COLUMN_INDEX);
      int type=c.getInt(PHONE_TYPE_COLUMN_INDEX);
      String scheme;
      int resid;
      if (Intent.ACTION_CALL.equals(mShortcutAction)) {
        scheme=Constants.SCHEME_TEL;
        resid=R.drawable.badge_action_call;
      }
 else {
        scheme=Constants.SCHEME_SMSTO;
        resid=R.drawable.badge_action_sms;
      }
      Uri phoneUri=Uri.fromParts(scheme,number,null);
      shortcutIntent=new Intent(mShortcutAction,phoneUri);
      intent.putExtra(Intent.EXTRA_SHORTCUT_ICON,generatePhoneNumberIcon(contactUri,type,resid));
    }
    shortcutIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT,shortcutIntent);
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME,name);
    setResult(RESULT_OK,intent);
  }
 else {
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME,name);
    setResult(RESULT_OK,intent.setData(contactUri));
  }
  finish();
}","/** 
 * @param selectedUri In most cases, this should be a lookup {@link Uri}, possibly generated through   {@link Contacts#getLookupUri(long,String)}.
 */
private void returnPickerResult(Cursor c,String name,Uri selectedUri){
  final Intent intent=new Intent();
  if (mShortcutAction != null) {
    Intent shortcutIntent;
    if (Intent.ACTION_VIEW.equals(mShortcutAction)) {
      shortcutIntent=new Intent(ContactsContract.QuickContact.ACTION_QUICK_CONTACT);
      shortcutIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
      shortcutIntent.setData(selectedUri);
      shortcutIntent.putExtra(ContactsContract.QuickContact.EXTRA_MODE,ContactsContract.QuickContact.MODE_LARGE);
      shortcutIntent.putExtra(ContactsContract.QuickContact.EXTRA_EXCLUDE_MIMES,(String[])null);
      final Bitmap icon=framePhoto(loadContactPhoto(selectedUri,null));
      if (icon != null) {
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON,scaleToAppIconSize(icon));
      }
 else {
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE,Intent.ShortcutIconResource.fromContext(this,R.drawable.ic_launcher_shortcut_contact));
      }
    }
 else {
      String number=c.getString(PHONE_NUMBER_COLUMN_INDEX);
      int type=c.getInt(PHONE_TYPE_COLUMN_INDEX);
      String scheme;
      int resid;
      if (Intent.ACTION_CALL.equals(mShortcutAction)) {
        scheme=Constants.SCHEME_TEL;
        resid=R.drawable.badge_action_call;
      }
 else {
        scheme=Constants.SCHEME_SMSTO;
        resid=R.drawable.badge_action_sms;
      }
      Uri phoneUri=Uri.fromParts(scheme,number,null);
      shortcutIntent=new Intent(mShortcutAction,phoneUri);
      intent.putExtra(Intent.EXTRA_SHORTCUT_ICON,generatePhoneNumberIcon(selectedUri,type,resid));
    }
    shortcutIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT,shortcutIntent);
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME,name);
    setResult(RESULT_OK,intent);
  }
 else {
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME,name);
    setResult(RESULT_OK,intent.setData(selectedUri));
  }
  finish();
}",0.9793008279668812
183983,"@Override protected void onListItemClick(ListView l,View v,int position,long id){
  hideSoftKeyboard();
  if (mSearchMode && mAdapter.isSearchAllContactsItemPosition(position)) {
    doSearch();
  }
 else   if (mMode == MODE_INSERT_OR_EDIT_CONTACT || mMode == MODE_QUERY_PICK_TO_EDIT) {
    Intent intent;
    if (position == 0 && !mSearchMode && mMode != MODE_QUERY_PICK_TO_EDIT) {
      intent=new Intent(Intent.ACTION_INSERT,Contacts.CONTENT_URI);
    }
 else {
      intent=new Intent(Intent.ACTION_EDIT,getSelectedUri(position));
    }
    intent.setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
    Bundle extras=getIntent().getExtras();
    if (extras != null) {
      intent.putExtras(extras);
    }
    intent.putExtra(KEY_PICKER_MODE,(mMode & MODE_MASK_PICKER) == MODE_MASK_PICKER);
    startActivity(intent);
    finish();
  }
 else   if ((mMode & MODE_MASK_CREATE_NEW) == MODE_MASK_CREATE_NEW && position == 0) {
    Intent newContact=new Intent(Intents.Insert.ACTION,Contacts.CONTENT_URI);
    startActivityForResult(newContact,SUBACTIVITY_NEW_CONTACT);
  }
 else   if (mMode == MODE_JOIN_CONTACT && id == JOIN_MODE_SHOW_ALL_CONTACTS_ID) {
    mJoinModeShowAllContacts=false;
    startQuery();
  }
 else   if (id > 0) {
    final Uri uri=getSelectedUri(position);
    if ((mMode & MODE_MASK_PICKER) == 0) {
      final Intent intent=new Intent(Intent.ACTION_VIEW,uri);
      startActivityForResult(intent,SUBACTIVITY_VIEW_CONTACT);
    }
 else     if (mMode == MODE_JOIN_CONTACT) {
      returnPickerResult(null,null,uri);
    }
 else     if (mMode == MODE_QUERY_PICK_TO_VIEW) {
      final Intent intent=new Intent(Intent.ACTION_VIEW,uri);
      startActivity(intent);
      finish();
    }
 else     if (mMode == MODE_PICK_PHONE || mMode == MODE_QUERY_PICK_PHONE) {
      Cursor c=(Cursor)mAdapter.getItem(position);
      long contactId=c.getLong(PHONE_CONTACT_ID_COLUMN_INDEX);
      returnPickerResult(c,c.getString(PHONE_DISPLAY_NAME_COLUMN_INDEX),ContentUris.withAppendedId(Contacts.CONTENT_URI,contactId));
    }
 else     if ((mMode & MODE_MASK_PICKER) != 0) {
      Cursor c=(Cursor)mAdapter.getItem(position);
      returnPickerResult(c,c.getString(getSummaryDisplayNameColumnIndex()),uri);
    }
 else     if (mMode == MODE_PICK_POSTAL || mMode == MODE_LEGACY_PICK_POSTAL || mMode == MODE_LEGACY_PICK_PHONE) {
      returnPickerResult(null,null,uri);
    }
  }
 else {
    signalError();
  }
}","@Override protected void onListItemClick(ListView l,View v,int position,long id){
  hideSoftKeyboard();
  if (mSearchMode && mAdapter.isSearchAllContactsItemPosition(position)) {
    doSearch();
  }
 else   if (mMode == MODE_INSERT_OR_EDIT_CONTACT || mMode == MODE_QUERY_PICK_TO_EDIT) {
    Intent intent;
    if (position == 0 && !mSearchMode && mMode != MODE_QUERY_PICK_TO_EDIT) {
      intent=new Intent(Intent.ACTION_INSERT,Contacts.CONTENT_URI);
    }
 else {
      intent=new Intent(Intent.ACTION_EDIT,getSelectedUri(position));
    }
    intent.setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
    Bundle extras=getIntent().getExtras();
    if (extras != null) {
      intent.putExtras(extras);
    }
    intent.putExtra(KEY_PICKER_MODE,(mMode & MODE_MASK_PICKER) == MODE_MASK_PICKER);
    startActivity(intent);
    finish();
  }
 else   if ((mMode & MODE_MASK_CREATE_NEW) == MODE_MASK_CREATE_NEW && position == 0) {
    Intent newContact=new Intent(Intents.Insert.ACTION,Contacts.CONTENT_URI);
    startActivityForResult(newContact,SUBACTIVITY_NEW_CONTACT);
  }
 else   if (mMode == MODE_JOIN_CONTACT && id == JOIN_MODE_SHOW_ALL_CONTACTS_ID) {
    mJoinModeShowAllContacts=false;
    startQuery();
  }
 else   if (id > 0) {
    final Uri uri=getSelectedUri(position);
    if ((mMode & MODE_MASK_PICKER) == 0) {
      final Intent intent=new Intent(Intent.ACTION_VIEW,uri);
      startActivityForResult(intent,SUBACTIVITY_VIEW_CONTACT);
    }
 else     if (mMode == MODE_JOIN_CONTACT) {
      returnPickerResult(null,null,uri);
    }
 else     if (mMode == MODE_QUERY_PICK_TO_VIEW) {
      final Intent intent=new Intent(Intent.ACTION_VIEW,uri);
      startActivity(intent);
      finish();
    }
 else     if (mMode == MODE_PICK_PHONE || mMode == MODE_QUERY_PICK_PHONE) {
      Cursor c=(Cursor)mAdapter.getItem(position);
      returnPickerResult(c,c.getString(PHONE_DISPLAY_NAME_COLUMN_INDEX),uri);
    }
 else     if ((mMode & MODE_MASK_PICKER) != 0) {
      Cursor c=(Cursor)mAdapter.getItem(position);
      returnPickerResult(c,c.getString(getSummaryDisplayNameColumnIndex()),uri);
    }
 else     if (mMode == MODE_PICK_POSTAL || mMode == MODE_LEGACY_PICK_POSTAL || mMode == MODE_LEGACY_PICK_PHONE) {
      returnPickerResult(null,null,uri);
    }
  }
 else {
    signalError();
  }
}",0.8985999151463725
183984,"private Bitmap loadContactPhoto(Uri lookupUri,BitmapFactory.Options options){
  Cursor cursor=null;
  Bitmap bm=null;
  try {
    Uri contactUri=Contacts.lookupContact(getContentResolver(),lookupUri);
    Uri photoUri=Uri.withAppendedPath(contactUri,Contacts.Photo.CONTENT_DIRECTORY);
    cursor=getContentResolver().query(photoUri,new String[]{Photo.PHOTO},null,null,null);
    if (cursor != null && cursor.moveToFirst()) {
      bm=ContactsUtils.loadContactPhoto(cursor,0,options);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  if (bm == null) {
    final int[] fallbacks={R.drawable.ic_contact_picture,R.drawable.ic_contact_picture_2,R.drawable.ic_contact_picture_3};
    bm=BitmapFactory.decodeResource(getResources(),fallbacks[new Random().nextInt(fallbacks.length)]);
  }
  return bm;
}","private Bitmap loadContactPhoto(Uri selectedUri,BitmapFactory.Options options){
  Uri contactUri=null;
  if (Contacts.CONTENT_ITEM_TYPE.equals(getContentResolver().getType(selectedUri))) {
    contactUri=Contacts.lookupContact(getContentResolver(),selectedUri);
  }
 else {
    Cursor cursor=getContentResolver().query(selectedUri,new String[]{Data.CONTACT_ID},null,null,null);
    try {
      if (cursor != null && cursor.moveToFirst()) {
        final long contactId=cursor.getLong(0);
        contactUri=ContentUris.withAppendedId(Contacts.CONTENT_URI,contactId);
      }
    }
  finally {
      if (cursor != null)       cursor.close();
    }
  }
  Cursor cursor=null;
  Bitmap bm=null;
  try {
    Uri photoUri=Uri.withAppendedPath(contactUri,Contacts.Photo.CONTENT_DIRECTORY);
    cursor=getContentResolver().query(photoUri,new String[]{Photo.PHOTO},null,null,null);
    if (cursor != null && cursor.moveToFirst()) {
      bm=ContactsUtils.loadContactPhoto(cursor,0,options);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  if (bm == null) {
    final int[] fallbacks={R.drawable.ic_contact_picture,R.drawable.ic_contact_picture_2,R.drawable.ic_contact_picture_3};
    bm=BitmapFactory.decodeResource(getResources(),fallbacks[new Random().nextInt(fallbacks.length)]);
  }
  return bm;
}",0.6703806870937791
183985,"@Override public Object getItem(int pos){
  if (mSuggestionsCursorCount != 0 && pos <= mSuggestionsCursorCount) {
    mSuggestionsCursor.moveToPosition(getRealPosition(pos));
    return mSuggestionsCursor;
  }
 else {
    return super.getItem(getRealPosition(pos));
  }
}","@Override public Object getItem(int pos){
  if (mSuggestionsCursorCount != 0 && pos <= mSuggestionsCursorCount) {
    mSuggestionsCursor.moveToPosition(getRealPosition(pos));
    return mSuggestionsCursor;
  }
 else   if (isSearchAllContactsItemPosition(pos)) {
    return null;
  }
 else {
    return super.getItem(getRealPosition(pos));
  }
}",0.8813008130081301
183986,"@Override public long getItemId(int pos){
  if (mSuggestionsCursorCount != 0 && pos < mSuggestionsCursorCount + 2) {
    if (mSuggestionsCursor.moveToPosition(pos - 1)) {
      return mSuggestionsCursor.getLong(mRowIDColumn);
    }
 else {
      return 0;
    }
  }
  return super.getItemId(getRealPosition(pos));
}","@Override public long getItemId(int pos){
  if (mSuggestionsCursorCount != 0 && pos < mSuggestionsCursorCount + 2) {
    if (mSuggestionsCursor.moveToPosition(pos - 1)) {
      return mSuggestionsCursor.getLong(mRowIDColumn);
    }
 else {
      return 0;
    }
  }
 else   if (isSearchAllContactsItemPosition(pos)) {
    return 0;
  }
  return super.getItemId(getRealPosition(pos));
}",0.9
183987,"/** 
 * @param contactUri In most cases, this should be a lookup {@link Uri}, possibly generated through   {@link Contacts#getLookupUri(long,String)}.
 */
private void returnPickerResult(Cursor c,String name,Uri contactUri){
  final Intent intent=new Intent();
  if (mShortcutAction != null) {
    Intent shortcutIntent;
    if (Intent.ACTION_VIEW.equals(mShortcutAction)) {
      shortcutIntent=new Intent(ContactsContract.QuickContact.ACTION_QUICK_CONTACT);
      shortcutIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
      shortcutIntent.setData(contactUri);
      shortcutIntent.putExtra(ContactsContract.QuickContact.EXTRA_MODE,ContactsContract.QuickContact.MODE_LARGE);
      shortcutIntent.putExtra(ContactsContract.QuickContact.EXTRA_EXCLUDE_MIMES,(String[])null);
      final Bitmap icon=framePhoto(loadContactPhoto(contactUri,null));
      if (icon != null) {
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON,scaleToAppIconSize(icon));
      }
 else {
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE,Intent.ShortcutIconResource.fromContext(this,R.drawable.ic_launcher_shortcut_contact));
      }
    }
 else {
      String number=c.getString(PHONE_NUMBER_COLUMN_INDEX);
      int type=c.getInt(PHONE_TYPE_COLUMN_INDEX);
      String scheme;
      int resid;
      if (Intent.ACTION_CALL.equals(mShortcutAction)) {
        scheme=Constants.SCHEME_TEL;
        resid=R.drawable.badge_action_call;
      }
 else {
        scheme=Constants.SCHEME_SMSTO;
        resid=R.drawable.badge_action_sms;
      }
      Uri phoneUri=Uri.fromParts(scheme,number,null);
      shortcutIntent=new Intent(mShortcutAction,phoneUri);
      intent.putExtra(Intent.EXTRA_SHORTCUT_ICON,generatePhoneNumberIcon(contactUri,type,resid));
    }
    shortcutIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT,shortcutIntent);
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME,name);
    setResult(RESULT_OK,intent);
  }
 else {
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME,name);
    setResult(RESULT_OK,intent.setData(contactUri));
  }
  finish();
}","/** 
 * @param selectedUri In most cases, this should be a lookup {@link Uri}, possibly generated through   {@link Contacts#getLookupUri(long,String)}.
 */
private void returnPickerResult(Cursor c,String name,Uri selectedUri){
  final Intent intent=new Intent();
  if (mShortcutAction != null) {
    Intent shortcutIntent;
    if (Intent.ACTION_VIEW.equals(mShortcutAction)) {
      shortcutIntent=new Intent(ContactsContract.QuickContact.ACTION_QUICK_CONTACT);
      shortcutIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
      shortcutIntent.setData(selectedUri);
      shortcutIntent.putExtra(ContactsContract.QuickContact.EXTRA_MODE,ContactsContract.QuickContact.MODE_LARGE);
      shortcutIntent.putExtra(ContactsContract.QuickContact.EXTRA_EXCLUDE_MIMES,(String[])null);
      final Bitmap icon=framePhoto(loadContactPhoto(selectedUri,null));
      if (icon != null) {
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON,scaleToAppIconSize(icon));
      }
 else {
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE,Intent.ShortcutIconResource.fromContext(this,R.drawable.ic_launcher_shortcut_contact));
      }
    }
 else {
      String number=c.getString(PHONE_NUMBER_COLUMN_INDEX);
      int type=c.getInt(PHONE_TYPE_COLUMN_INDEX);
      String scheme;
      int resid;
      if (Intent.ACTION_CALL.equals(mShortcutAction)) {
        scheme=Constants.SCHEME_TEL;
        resid=R.drawable.badge_action_call;
      }
 else {
        scheme=Constants.SCHEME_SMSTO;
        resid=R.drawable.badge_action_sms;
      }
      Uri phoneUri=Uri.fromParts(scheme,number,null);
      shortcutIntent=new Intent(mShortcutAction,phoneUri);
      intent.putExtra(Intent.EXTRA_SHORTCUT_ICON,generatePhoneNumberIcon(selectedUri,type,resid));
    }
    shortcutIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT,shortcutIntent);
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME,name);
    setResult(RESULT_OK,intent);
  }
 else {
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME,name);
    setResult(RESULT_OK,intent.setData(selectedUri));
  }
  finish();
}",0.9793008279668812
183988,"@Override protected void onListItemClick(ListView l,View v,int position,long id){
  hideSoftKeyboard();
  if (mSearchMode && mAdapter.isSearchAllContactsItemPosition(position)) {
    doSearch();
  }
 else   if (mMode == MODE_INSERT_OR_EDIT_CONTACT || mMode == MODE_QUERY_PICK_TO_EDIT) {
    Intent intent;
    if (position == 0 && !mSearchMode && mMode != MODE_QUERY_PICK_TO_EDIT) {
      intent=new Intent(Intent.ACTION_INSERT,Contacts.CONTENT_URI);
    }
 else {
      intent=new Intent(Intent.ACTION_EDIT,getSelectedUri(position));
    }
    intent.setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
    Bundle extras=getIntent().getExtras();
    if (extras != null) {
      intent.putExtras(extras);
    }
    intent.putExtra(KEY_PICKER_MODE,(mMode & MODE_MASK_PICKER) == MODE_MASK_PICKER);
    startActivity(intent);
    finish();
  }
 else   if ((mMode & MODE_MASK_CREATE_NEW) == MODE_MASK_CREATE_NEW && position == 0) {
    Intent newContact=new Intent(Intents.Insert.ACTION,Contacts.CONTENT_URI);
    startActivityForResult(newContact,SUBACTIVITY_NEW_CONTACT);
  }
 else   if (mMode == MODE_JOIN_CONTACT && id == JOIN_MODE_SHOW_ALL_CONTACTS_ID) {
    mJoinModeShowAllContacts=false;
    startQuery();
  }
 else   if (id > 0) {
    final Uri uri=getSelectedUri(position);
    if ((mMode & MODE_MASK_PICKER) == 0) {
      final Intent intent=new Intent(Intent.ACTION_VIEW,uri);
      startActivityForResult(intent,SUBACTIVITY_VIEW_CONTACT);
    }
 else     if (mMode == MODE_JOIN_CONTACT) {
      returnPickerResult(null,null,uri);
    }
 else     if (mMode == MODE_QUERY_PICK_TO_VIEW) {
      final Intent intent=new Intent(Intent.ACTION_VIEW,uri);
      startActivity(intent);
      finish();
    }
 else     if (mMode == MODE_PICK_PHONE || mMode == MODE_QUERY_PICK_PHONE) {
      Cursor c=(Cursor)mAdapter.getItem(position);
      long contactId=c.getLong(PHONE_CONTACT_ID_COLUMN_INDEX);
      returnPickerResult(c,c.getString(PHONE_DISPLAY_NAME_COLUMN_INDEX),ContentUris.withAppendedId(Contacts.CONTENT_URI,contactId));
    }
 else     if ((mMode & MODE_MASK_PICKER) != 0) {
      Cursor c=(Cursor)mAdapter.getItem(position);
      returnPickerResult(c,c.getString(getSummaryDisplayNameColumnIndex()),uri);
    }
 else     if (mMode == MODE_PICK_POSTAL || mMode == MODE_LEGACY_PICK_POSTAL || mMode == MODE_LEGACY_PICK_PHONE) {
      returnPickerResult(null,null,uri);
    }
  }
 else {
    signalError();
  }
}","@Override protected void onListItemClick(ListView l,View v,int position,long id){
  hideSoftKeyboard();
  if (mSearchMode && mAdapter.isSearchAllContactsItemPosition(position)) {
    doSearch();
  }
 else   if (mMode == MODE_INSERT_OR_EDIT_CONTACT || mMode == MODE_QUERY_PICK_TO_EDIT) {
    Intent intent;
    if (position == 0 && !mSearchMode && mMode != MODE_QUERY_PICK_TO_EDIT) {
      intent=new Intent(Intent.ACTION_INSERT,Contacts.CONTENT_URI);
    }
 else {
      intent=new Intent(Intent.ACTION_EDIT,getSelectedUri(position));
    }
    intent.setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
    Bundle extras=getIntent().getExtras();
    if (extras != null) {
      intent.putExtras(extras);
    }
    intent.putExtra(KEY_PICKER_MODE,(mMode & MODE_MASK_PICKER) == MODE_MASK_PICKER);
    startActivity(intent);
    finish();
  }
 else   if ((mMode & MODE_MASK_CREATE_NEW) == MODE_MASK_CREATE_NEW && position == 0) {
    Intent newContact=new Intent(Intents.Insert.ACTION,Contacts.CONTENT_URI);
    startActivityForResult(newContact,SUBACTIVITY_NEW_CONTACT);
  }
 else   if (mMode == MODE_JOIN_CONTACT && id == JOIN_MODE_SHOW_ALL_CONTACTS_ID) {
    mJoinModeShowAllContacts=false;
    startQuery();
  }
 else   if (id > 0) {
    final Uri uri=getSelectedUri(position);
    if ((mMode & MODE_MASK_PICKER) == 0) {
      final Intent intent=new Intent(Intent.ACTION_VIEW,uri);
      startActivityForResult(intent,SUBACTIVITY_VIEW_CONTACT);
    }
 else     if (mMode == MODE_JOIN_CONTACT) {
      returnPickerResult(null,null,uri);
    }
 else     if (mMode == MODE_QUERY_PICK_TO_VIEW) {
      final Intent intent=new Intent(Intent.ACTION_VIEW,uri);
      startActivity(intent);
      finish();
    }
 else     if (mMode == MODE_PICK_PHONE || mMode == MODE_QUERY_PICK_PHONE) {
      Cursor c=(Cursor)mAdapter.getItem(position);
      returnPickerResult(c,c.getString(PHONE_DISPLAY_NAME_COLUMN_INDEX),uri);
    }
 else     if ((mMode & MODE_MASK_PICKER) != 0) {
      Cursor c=(Cursor)mAdapter.getItem(position);
      returnPickerResult(c,c.getString(getSummaryDisplayNameColumnIndex()),uri);
    }
 else     if (mMode == MODE_PICK_POSTAL || mMode == MODE_LEGACY_PICK_POSTAL || mMode == MODE_LEGACY_PICK_PHONE) {
      returnPickerResult(null,null,uri);
    }
  }
 else {
    signalError();
  }
}",0.8985999151463725
183989,"private Bitmap loadContactPhoto(Uri lookupUri,BitmapFactory.Options options){
  Cursor cursor=null;
  Bitmap bm=null;
  try {
    Uri contactUri=Contacts.lookupContact(getContentResolver(),lookupUri);
    Uri photoUri=Uri.withAppendedPath(contactUri,Contacts.Photo.CONTENT_DIRECTORY);
    cursor=getContentResolver().query(photoUri,new String[]{Photo.PHOTO},null,null,null);
    if (cursor != null && cursor.moveToFirst()) {
      bm=ContactsUtils.loadContactPhoto(cursor,0,options);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  if (bm == null) {
    final int[] fallbacks={R.drawable.ic_contact_picture,R.drawable.ic_contact_picture_2,R.drawable.ic_contact_picture_3};
    bm=BitmapFactory.decodeResource(getResources(),fallbacks[new Random().nextInt(fallbacks.length)]);
  }
  return bm;
}","private Bitmap loadContactPhoto(Uri selectedUri,BitmapFactory.Options options){
  Uri contactUri=null;
  if (Contacts.CONTENT_ITEM_TYPE.equals(getContentResolver().getType(selectedUri))) {
    contactUri=Contacts.lookupContact(getContentResolver(),selectedUri);
  }
 else {
    Cursor cursor=getContentResolver().query(selectedUri,new String[]{Data.CONTACT_ID},null,null,null);
    try {
      if (cursor != null && cursor.moveToFirst()) {
        final long contactId=cursor.getLong(0);
        contactUri=ContentUris.withAppendedId(Contacts.CONTENT_URI,contactId);
      }
    }
  finally {
      if (cursor != null)       cursor.close();
    }
  }
  Cursor cursor=null;
  Bitmap bm=null;
  try {
    Uri photoUri=Uri.withAppendedPath(contactUri,Contacts.Photo.CONTENT_DIRECTORY);
    cursor=getContentResolver().query(photoUri,new String[]{Photo.PHOTO},null,null,null);
    if (cursor != null && cursor.moveToFirst()) {
      bm=ContactsUtils.loadContactPhoto(cursor,0,options);
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  if (bm == null) {
    final int[] fallbacks={R.drawable.ic_contact_picture,R.drawable.ic_contact_picture_2,R.drawable.ic_contact_picture_3};
    bm=BitmapFactory.decodeResource(getResources(),fallbacks[new Random().nextInt(fallbacks.length)]);
  }
  return bm;
}",0.6703806870937791
183990,"private void sendFetchImageMessage(ImageView view){
  final PhotoInfo info=(PhotoInfo)view.getTag();
  if (info == null) {
    return;
  }
  final long photoId=info.photoId;
  if (photoId == 0) {
    return;
  }
  mImageFetcher=new ImageDbFetcher(photoId,view);
synchronized (ContactsListActivity.this) {
    if (sImageFetchThreadPool == null) {
      sImageFetchThreadPool=Executors.newFixedThreadPool(3);
    }
    sImageFetchThreadPool.execute(mImageFetcher);
  }
}","private void sendFetchImageMessage(ImageView view){
  final PhotoInfo info=(PhotoInfo)view.getTag();
  if (info == null) {
    return;
  }
  final long photoId=info.photoId;
  if (photoId == 0) {
    return;
  }
  mImageFetcher=new ImageDbFetcher(photoId,view);
synchronized (ContactsListActivity.this) {
    if (sImageFetchThreadPool == null) {
      sImageFetchThreadPool=Executors.newFixedThreadPool(1);
    }
    sImageFetchThreadPool.execute(mImageFetcher);
  }
}",0.997863247863248
183991,"private void sendFetchImageMessage(ImageView view){
  final PhotoInfo info=(PhotoInfo)view.getTag();
  if (info == null) {
    return;
  }
  final long photoId=info.photoId;
  if (photoId == 0) {
    return;
  }
  mImageFetcher=new ImageDbFetcher(photoId,view);
synchronized (ContactsListActivity.this) {
    if (sImageFetchThreadPool == null) {
      sImageFetchThreadPool=Executors.newFixedThreadPool(3);
    }
    sImageFetchThreadPool.execute(mImageFetcher);
  }
}","private void sendFetchImageMessage(ImageView view){
  final PhotoInfo info=(PhotoInfo)view.getTag();
  if (info == null) {
    return;
  }
  final long photoId=info.photoId;
  if (photoId == 0) {
    return;
  }
  mImageFetcher=new ImageDbFetcher(photoId,view);
synchronized (ContactsListActivity.this) {
    if (sImageFetchThreadPool == null) {
      sImageFetchThreadPool=Executors.newFixedThreadPool(1);
    }
    sImageFetchThreadPool.execute(mImageFetcher);
  }
}",0.997863247863248
183992,"/** 
 * @return true if the widget with the phone number digits is empty.
 */
private boolean isDigitsEmpty(){
  return mDigits.length() != 0;
}","/** 
 * @return true if the widget with the phone number digits is empty.
 */
private boolean isDigitsEmpty(){
  return mDigits.length() == 0;
}",0.9930555555555556
183993,"/** 
 * Set the visibility of secondary sections, along with header icon. <p>If the source is read-only and there's no secondary fields, the entire secondary section will be hidden.
 */
private void setSecondaryVisible(boolean makeVisible){
  mSecondaryVisible=makeVisible;
  if (!mIsSourceReadOnly && mSecondary.getChildCount() > 0) {
    mSecondary.setVisibility(makeVisible ? View.VISIBLE : View.GONE);
    mSecondaryHeader.setCompoundDrawablesWithIntrinsicBounds(makeVisible ? mSecondaryOpen : mSecondaryClosed,null,null,null);
  }
 else {
    mSecondaryHeader.setVisibility(View.GONE);
    mSecondary.setVisibility(View.GONE);
  }
}","/** 
 * Set the visibility of secondary sections, along with header icon. <p>If the source is read-only and there's no secondary fields, the entire secondary section will be hidden.
 */
private void setSecondaryVisible(boolean makeVisible){
  mSecondaryVisible=makeVisible;
  if (!mIsSourceReadOnly && mSecondary.getChildCount() > 0) {
    mSecondaryHeader.setVisibility(View.VISIBLE);
    mSecondaryHeader.setCompoundDrawablesWithIntrinsicBounds(makeVisible ? mSecondaryOpen : mSecondaryClosed,null,null,null);
    mSecondary.setVisibility(makeVisible ? View.VISIBLE : View.GONE);
  }
 else {
    mSecondaryHeader.setVisibility(View.GONE);
    mSecondary.setVisibility(View.GONE);
  }
}",0.7280966767371602
183994,"@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(AudioManager.STREAM_DTMF,TONE_RELATIVE_VOLUME);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
  updateDialAndDeleteButtonStateEnabledAttr();
}","@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(DIAL_TONE_STREAM_TYPE,TONE_RELATIVE_VOLUME);
        setVolumeControlStream(DIAL_TONE_STREAM_TYPE);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
  updateDialAndDeleteButtonStateEnabledAttr();
}",0.9533394327538884
183995,"@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(AudioManager.STREAM_DTMF,TONE_RELATIVE_VOLUME);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
  updateDialAndDeleteButtonStateEnabledAttr();
}","@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(DIAL_TONE_STREAM_TYPE,TONE_RELATIVE_VOLUME);
        setVolumeControlStream(DIAL_TONE_STREAM_TYPE);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
  updateDialAndDeleteButtonStateEnabledAttr();
}",0.9533394327538884
183996,"@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(AudioManager.STREAM_DTMF,TONE_RELATIVE_VOLUME);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
  updateDialAndDeleteButtonStateEnabledAttr();
}","@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(DIAL_TONE_STREAM_TYPE,TONE_RELATIVE_VOLUME);
        setVolumeControlStream(DIAL_TONE_STREAM_TYPE);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
  updateDialAndDeleteButtonStateEnabledAttr();
}",0.9533394327538884
183997,"@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(AudioManager.STREAM_DTMF,TONE_RELATIVE_VOLUME);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
  updateDialAndDeleteButtonStateEnabledAttr();
}","@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(DIAL_TONE_STREAM_TYPE,TONE_RELATIVE_VOLUME);
        setVolumeControlStream(DIAL_TONE_STREAM_TYPE);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
  updateDialAndDeleteButtonStateEnabledAttr();
}",0.9533394327538884
183998,"@Override protected void onCreate(Bundle icicle){
  super.onCreate(icicle);
  setContentView(getContentViewResource());
  Resources r=getResources();
  mDigitsBackground=r.getDrawable(R.drawable.btn_dial_textfield_active);
  mDigitsEmptyBackground=r.getDrawable(R.drawable.btn_dial_textfield);
  mDeleteBackground=r.getDrawable(R.drawable.btn_dial_delete_active);
  mDeleteEmptyBackground=r.getDrawable(R.drawable.btn_dial_delete);
  mDigits=(EditText)findViewById(R.id.digits);
  mDigits.setKeyListener(DialerKeyListener.getInstance());
  mDigits.setOnClickListener(this);
  mDigits.setOnKeyListener(this);
  maybeAddNumberFormatting();
  View view=findViewById(R.id.one);
  if (view != null) {
    setupKeypad();
  }
  view=findViewById(R.id.backspace);
  view.setOnClickListener(this);
  view.setOnLongClickListener(this);
  mDelete=view;
  mDigitsAndBackspace=(View)findViewById(R.id.digitsAndBackspace);
  mDialpad=(View)findViewById(R.id.dialpad);
  mDialpadChooser=(ListView)findViewById(R.id.dialpadChooser);
  mDialpadChooser.setOnItemClickListener(this);
  if (!resolveIntent() && icicle != null) {
    super.onRestoreInstanceState(icicle);
  }
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(AudioManager.STREAM_VOICE_CALL,TONE_RELATIVE_VOLUME);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
}","@Override protected void onCreate(Bundle icicle){
  super.onCreate(icicle);
  setContentView(getContentViewResource());
  Resources r=getResources();
  mDigitsBackground=r.getDrawable(R.drawable.btn_dial_textfield_active);
  mDigitsEmptyBackground=r.getDrawable(R.drawable.btn_dial_textfield);
  mDeleteBackground=r.getDrawable(R.drawable.btn_dial_delete_active);
  mDeleteEmptyBackground=r.getDrawable(R.drawable.btn_dial_delete);
  mDigits=(EditText)findViewById(R.id.digits);
  mDigits.setKeyListener(DialerKeyListener.getInstance());
  mDigits.setOnClickListener(this);
  mDigits.setOnKeyListener(this);
  maybeAddNumberFormatting();
  View view=findViewById(R.id.one);
  if (view != null) {
    setupKeypad();
  }
  view=findViewById(R.id.backspace);
  view.setOnClickListener(this);
  view.setOnLongClickListener(this);
  mDelete=view;
  mDigitsAndBackspace=(View)findViewById(R.id.digitsAndBackspace);
  mDialpad=(View)findViewById(R.id.dialpad);
  mDialpadChooser=(ListView)findViewById(R.id.dialpadChooser);
  mDialpadChooser.setOnItemClickListener(this);
  if (!resolveIntent() && icicle != null) {
    super.onRestoreInstanceState(icicle);
  }
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(AudioManager.STREAM_RING,TONE_RELATIVE_VOLUME);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
}",0.9958988380041012
183999,"@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(AudioManager.STREAM_VOICE_CALL,TONE_RELATIVE_VOLUME);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
}","@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(AudioManager.STREAM_RING,TONE_RELATIVE_VOLUME);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
}",0.9941348973607038
184000,"@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(AudioManager.STREAM_DTMF,TONE_RELATIVE_VOLUME);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
  updateDialAndDeleteButtonStateEnabledAttr();
}","@Override protected void onResume(){
  super.onResume();
  mDTMFToneEnabled=Settings.System.getInt(getContentResolver(),Settings.System.DTMF_TONE_WHEN_DIALING,1) == 1;
synchronized (mToneGeneratorLock) {
    if (mToneGenerator == null) {
      try {
        mToneGenerator=new ToneGenerator(DIAL_TONE_STREAM_TYPE,TONE_RELATIVE_VOLUME);
        setVolumeControlStream(DIAL_TONE_STREAM_TYPE);
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + e);
        mToneGenerator=null;
      }
    }
  }
  Activity parent=getParent();
  if (parent != null && parent instanceof DialtactsActivity) {
    Uri dialUri=((DialtactsActivity)parent).getAndClearDialUri();
    if (dialUri != null) {
      resolveIntent();
    }
  }
  TelephonyManager telephonyManager=(TelephonyManager)getSystemService(TELEPHONY_SERVICE);
  telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
  if (phoneIsInUse()) {
    mDigits.setHint(R.string.dialerDialpadHintText);
  }
 else {
    mDigits.setHint(null);
    showDialpadChooser(false);
  }
  updateDialAndDeleteButtonStateEnabledAttr();
}",0.9533394327538884
