record_number,buggy_code,fixed_code,code_similarity
4001,"public void removeAllActions(){
  this.isMenuUpdated=false;
  this.hasSize=false;
  this.actions.clear();
}","public void removeAllActions(){
  this.isMenuUpdated=false;
  this.hasSize=false;
  this.actions.clear();
  this.selectedAction=null;
  this.selectedComponent=null;
}",0.7838827838827839
4002,"public void removeAction(Action action){
  this.isMenuUpdated=false;
  this.hasSize=false;
  this.actions.remove(action);
}","public void removeAction(Action action){
  this.isMenuUpdated=false;
  this.hasSize=false;
  this.actions.remove(action);
  if (action == this.selectedAction) {
    this.selectedAction=null;
    this.selectedComponent=null;
  }
}",0.6988636363636364
4003,"private void updateSize(){
  if (this.getText() == null && this.actions.isEmpty())   return;
  if (this.getGraphics() == null)   return;
  this.hasSize=true;
  Rectangle2D labelRect=null;
  if (this.getText() != null && !this.getText().isEmpty()) {
    labelRect=this.getLongestTextArea(this.getText());
  }
 else {
    labelRect=this.getLongestTextArea(this.actions.toArray());
  }
  int ix1=0;
  int ix2=0;
  int iy1=0;
  int iy2=0;
  if (this.getBorder() != null) {
    Insets insets=this.getBorder().getBorderInsets(this);
    ix1=insets.left;
    ix2=insets.right;
    iy1=insets.top;
    iy2=insets.bottom;
  }
  this.setPreferredSize(new Dimension((int)labelRect.getWidth() + ix1 + ix2,(int)labelRect.getHeight() + iy1 + iy2));
  this.setSize(this.getPreferredSize());
  this.invalidate();
}","private void updateSize(){
  if (this.getText() == null && this.actions.isEmpty())   return;
  if (this.getGraphics() == null)   return;
  this.hasSize=true;
  Rectangle2D labelRect=null;
  if (this.getText() != null && !this.getText().isEmpty()) {
    labelRect=this.getLongestTextArea(this.getText());
  }
 else {
    labelRect=this.getLongestTextArea(this.actions.toArray());
  }
  int ix1=0;
  int ix2=0;
  int iy1=0;
  int iy2=0;
  if (this.getBorder() != null) {
    Insets insets=this.getBorder().getBorderInsets(this);
    ix1=insets.left;
    ix2=insets.right;
    iy1=insets.top;
    iy2=insets.bottom;
  }
  this.setPreferredSize(new Dimension((int)labelRect.getWidth() + ix1 + ix2,(int)labelRect.getHeight() + iy1 + iy2));
  this.setSize(this.getPreferredSize());
  this.repaint();
}",0.9893283113622096
4004,"private String unpackText(Object object){
  if (object instanceof Action)   return ((Action)object).getValue(""String_Node_Str"").toString();
 else   return object.toString();
}","private String unpackText(Object object){
  if (object == null)   return null;
  if (object instanceof Action)   return ((Action)object).getValue(""String_Node_Str"").toString();
 else   return object.toString();
}",0.9043927648578812
4005,"public void addAction(Action action){
  if (action == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.isMenuUpdated=false;
  this.hasSize=false;
  this.actions.add(action);
}","public void addAction(Action action){
  if (action == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.isMenuUpdated=false;
  this.hasSize=false;
  this.actions.add(action);
  if (this.selectedAction == null)   this.selectedAction=actions.get(0);
  this.updateSize();
}",0.8065843621399177
4006,"LimeComboBox(List<Action> actions){
  final Color ITEM_BACK=(Color)UIManager.get(""String_Node_Str"");
  this.setText(null);
  this.actions=new LinkedList<Action>();
  this.addActions(actions);
  if (!this.actions.isEmpty())   this.selectedAction=actions.get(0);
 else   this.selectedAction=null;
  this.setModel(this.getModel());
  this.menu=new JPopupMenu();
  this.initMenu();
  this.addMouseListener(new MouseAdapter(){
    @Override public void mouseEntered(    MouseEvent e){
    }
    @Override public void mouseExited(    MouseEvent e){
    }
    @Override public void mousePressed(    MouseEvent e){
      if (menu.isEnabled()) {
        menu.setVisible(false);
        menu.setEnabled(false);
        return;
      }
      updateMenu();
      if (getText() == null)       menu.setPreferredSize(new Dimension(getWidth(),(int)menu.getPreferredSize().getHeight()));
      menu.show((Component)e.getSource(),0,getHeight() - 1);
      menu.setEnabled(true);
    }
  }
);
}","LimeComboBox(List<Action> actions){
  final Color ITEM_BACK=(Color)UIManager.get(""String_Node_Str"");
  this.setText(null);
  this.actions=new LinkedList<Action>();
  this.addActions(actions);
  if (!this.actions.isEmpty())   this.selectedAction=actions.get(0);
 else   this.selectedAction=null;
  this.setModel(this.getModel());
  this.menu=new JPopupMenu();
  this.initMenu();
  this.addMouseListener(new MouseAdapter(){
    private boolean hide=false;
    @Override public void mouseEntered(    MouseEvent e){
      if (menu.isVisible())       this.hide=true;
    }
    @Override public void mouseExited(    MouseEvent e){
      this.hide=false;
    }
    @Override public void mousePressed(    MouseEvent e){
      if (this.hide) {
        this.hide=false;
        return;
      }
      updateMenu();
      if (getText() == null)       menu.setPreferredSize(new Dimension(getWidth(),(int)menu.getPreferredSize().getHeight()));
      menu.show((Component)e.getSource(),0,getHeight() - 1);
      this.hide=true;
    }
  }
);
}",0.8881118881118881
4007,"public void addActions(List<Action> actions){
  if (actions == null)   return;
  this.isMenuUpdated=false;
  this.hasSize=false;
  this.actions.addAll(actions);
  this.updateSize();
}","public void addActions(List<Action> actions){
  if (actions == null)   return;
  this.isMenuUpdated=false;
  this.hasSize=false;
  this.actions.addAll(actions);
  if (this.selectedAction == null)   this.selectedAction=actions.get(0);
  this.updateSize();
}",0.8337129840546698
4008,"public void setSelectedAction(Action action){
  this.selectedAction=action;
  this.isMenuUpdated=false;
}","public void setSelectedAction(Action action){
  if (!this.actions.contains(action))   return;
  this.selectedAction=action;
  this.isMenuUpdated=false;
}",0.813953488372093
4009,"private void initMenu(){
  this.menu.setBorder(BorderFactory.createLineBorder(Color.BLACK,1));
  this.menu.setBackground(Color.WHITE);
  this.menu.setForeground(Color.BLACK);
  this.menu.setEnabled(false);
  this.menu.addMouseListener(new MouseListener(){
    @Override public void mouseClicked(    MouseEvent e){
    }
    @Override public void mouseEntered(    MouseEvent e){
    }
    @Override public void mouseExited(    MouseEvent e){
    }
    @Override public void mousePressed(    MouseEvent e){
    }
    @Override public void mouseReleased(    MouseEvent e){
    }
  }
);
}","private void initMenu(){
  this.menu.setBorder(BorderFactory.createLineBorder(Color.BLACK,1));
  this.menu.setBackground(Color.WHITE);
  this.menu.setForeground(Color.BLACK);
  this.menu.setVisible(false);
  this.menu.addMouseListener(new MouseListener(){
    @Override public void mouseClicked(    MouseEvent e){
    }
    @Override public void mouseEntered(    MouseEvent e){
    }
    @Override public void mouseExited(    MouseEvent e){
    }
    @Override public void mousePressed(    MouseEvent e){
    }
    @Override public void mouseReleased(    MouseEvent e){
    }
  }
);
}",0.9931506849315068
4010,"public DownloadSettingsPanel(){
  super(new BorderLayout());
  this.setPreferredSize(new Dimension(getPreferredSize().width,34));
  Painter painter=new SubpanelPainter();
  setBackgroundPainter(painter);
  pauseAllButton=new JButton(pauseAction);
  resumeAllButton=new JButton(resumeAction);
  clearFinishedButton=new JButton(clearAction);
  categorizeCheckBox=new CustomCheckBox(categorizeAction);
  titleLabel=new HeadingLabel(I18n.tr(""String_Node_Str""));
  FontUtils.changeSize(titleLabel,5);
  FontUtils.changeStyle(titleLabel,Font.PLAIN);
  categorizeCheckBox.setOpaque(false);
  categorizeCheckBox.setForeground(Color.WHITE);
  FontUtils.changeStyle(categorizeCheckBox,Font.PLAIN);
  searchBar=downloadMediator.getFilterTextField();
  searchBar.setPreferredSize(new Dimension(150,19));
  categorizeAction.setEnabled(true);
  GridBagConstraints gbc=new GridBagConstraints();
  JPanel buttonPanel=new JPanel(new FlowLayout());
  buttonPanel.setOpaque(false);
  buttonPanel.add(pauseAllButton);
  buttonPanel.add(resumeAllButton);
  Insets insets=new Insets(5,5,5,5);
  JXPanel titlePanel=new JXPanel(new GridBagLayout());
  titlePanel.setOpaque(false);
  gbc.gridx=0;
  gbc.gridy=0;
  gbc.weightx=.5;
  gbc.insets=insets;
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.LINE_START;
  titlePanel.add(titleLabel,gbc);
  JPanel restPanel=new JPanel();
  restPanel.setOpaque(false);
  gbc.gridx++;
  gbc.gridy=0;
  gbc.insets=insets;
  restPanel.add(categorizeCheckBox,gbc);
  gbc.gridx++;
  gbc.gridy=0;
  gbc.insets=insets;
  restPanel.add(clearFinishedButton,gbc);
  gbc.gridx++;
  gbc.gridy=0;
  gbc.insets=insets;
  gbc.anchor=GridBagConstraints.LINE_END;
  restPanel.add(searchBar,gbc);
  add(titlePanel,BorderLayout.WEST);
  add(restPanel,BorderLayout.EAST);
}","public DownloadSettingsPanel(){
  super(new BorderLayout());
  this.setPreferredSize(new Dimension(getPreferredSize().width,34));
  Painter painter=new SubpanelPainter();
  setBackgroundPainter(painter);
  pauseAllButton=new JButton(pauseAction);
  resumeAllButton=new JButton(resumeAction);
  clearFinishedButton=new JXButton(clearAction);
  categoriseCheckBox=new CustomCheckBox(categorizeAction);
  clearFinishedButton.setBackgroundPainter(new ButtonPainter());
  clearFinishedButton.setOpaque(false);
  clearFinishedButton.setForeground(Color.WHITE);
  clearFinishedButton.setFont(new Font(""String_Node_Str"",Font.PLAIN,10));
  clearFinishedButton.setBorderPainted(false);
  clearFinishedButton.setPreferredSize(new Dimension((int)clearFinishedButton.getPreferredSize().getWidth(),21));
  titleLabel=new HeadingLabel(I18n.tr(""String_Node_Str""));
  FontUtils.changeSize(titleLabel,5);
  FontUtils.changeStyle(titleLabel,Font.PLAIN);
  categoriseCheckBox.setOpaque(false);
  categoriseCheckBox.setForeground(Color.WHITE);
  FontUtils.changeStyle(categoriseCheckBox,Font.PLAIN);
  searchBar=downloadMediator.getFilterTextField();
  searchBar.setPreferredSize(new Dimension(150,19));
  categorizeAction.setEnabled(true);
  GridBagConstraints gbc=new GridBagConstraints();
  JPanel buttonPanel=new JPanel(new FlowLayout());
  buttonPanel.setOpaque(false);
  buttonPanel.add(pauseAllButton);
  buttonPanel.add(resumeAllButton);
  Insets insets=new Insets(5,5,5,5);
  JXPanel titlePanel=new JXPanel(new GridBagLayout());
  titlePanel.setOpaque(false);
  gbc.gridx=0;
  gbc.gridy=0;
  gbc.weightx=.5;
  gbc.insets=insets;
  gbc.fill=GridBagConstraints.VERTICAL;
  gbc.anchor=GridBagConstraints.LINE_START;
  titlePanel.add(titleLabel,gbc);
  JPanel restPanel=new JPanel();
  restPanel.setOpaque(false);
  gbc.anchor=GridBagConstraints.NORTH;
  gbc.gridx++;
  gbc.gridy=0;
  gbc.insets=insets;
  restPanel.add(categoriseCheckBox,gbc);
  gbc.anchor=GridBagConstraints.SOUTH;
  gbc.gridx++;
  gbc.gridy=0;
  gbc.insets=insets;
  restPanel.add(clearFinishedButton,gbc);
  gbc.gridx++;
  gbc.gridy=0;
  gbc.insets=insets;
  gbc.anchor=GridBagConstraints.LINE_END;
  restPanel.add(searchBar,gbc);
  add(titlePanel,BorderLayout.WEST);
  add(restPanel,BorderLayout.EAST);
}",0.7882382011366444
4011,"public boolean isCategorized(){
  return categorizeCheckBox.isSelected();
}","public boolean isCategorized(){
  return categoriseCheckBox.isSelected();
}",0.9866666666666668
4012,"/** 
 * @param category
 * @param friend the friend whose library is being viewed.  Null for MyLibrary.
 */
public LibraryHeaderPanel(Category category,Friend friend){
  super(new MigLayout());
  GuiUtils.assignResources(this);
  this.category=category;
  this.friend=friend;
  titleLabel=new HeadingLabel(getTitle());
  titleLabel.setForeground(fontColor);
  titleLabel.setFont(headerFont);
  filterField=new PromptTextField();
  filterField.setPromptText(I18n.tr(""String_Node_Str""));
  if (isShareButtonShown()) {
    shareAllButton=new JXButton(I18n.tr(""String_Node_Str""),shareIcon);
    shareAllButton.setForeground(fontColor);
    shareAllButton.setHorizontalTextPosition(SwingConstants.LEFT);
    shareAllButton.setBackgroundPainter(new ButtonPainter());
    shareAllButton.setFont(buttonFont);
    shareAllButton.setOpaque(false);
    shareAllButton.setFocusPainted(false);
    shareAllButton.setContentAreaFilled(false);
  }
  add(titleLabel);
  add(filterField,""String_Node_Str"");
  if (isShareButtonShown()) {
    add(shareAllButton);
  }
  setBackgroundPainter(new SubpanelPainter());
}","/** 
 * @param category
 * @param friend the friend whose library is being viewed.  Null for MyLibrary.
 */
public LibraryHeaderPanel(Category category,Friend friend){
  super(new MigLayout());
  GuiUtils.assignResources(this);
  this.category=category;
  this.friend=friend;
  titleLabel=new HeadingLabel(getTitle());
  titleLabel.setForeground(fontColor);
  titleLabel.setFont(headerFont);
  filterField=new PromptTextField();
  filterField.setPromptText(I18n.tr(""String_Node_Str""));
  if (isShareButtonShown()) {
    shareAllButton=new JXButton(I18n.tr(""String_Node_Str""),shareIcon);
    shareAllButton.setForeground(fontColor);
    shareAllButton.setHorizontalTextPosition(SwingConstants.LEFT);
    shareAllButton.setBackgroundPainter(new ButtonPainter());
    shareAllButton.setBorderPainted(false);
    shareAllButton.setFont(buttonFont);
    shareAllButton.setOpaque(false);
    shareAllButton.setFocusPainted(false);
    shareAllButton.setContentAreaFilled(false);
  }
  add(titleLabel);
  add(filterField,""String_Node_Str"");
  if (isShareButtonShown()) {
    add(shareAllButton);
  }
  setBackgroundPainter(new SubpanelPainter());
}",0.9803395889186772
4013,"private void createComponents(){
  titleLabel=new HeadingLabel(staticText);
  titleLabel.setForeground(fontColor);
  FontUtils.setSize(titleLabel,fontSize);
  FontUtils.changeStyle(titleLabel,Font.PLAIN);
  filterBox=new PromptTextField();
  libraryButton=new LibraryButton(new GoToLibraryAction(navigator,null));
  libraryButton.setPreferredSize(new Dimension(buttonWidth,buttonHeight));
  libraryButton.setForeground(fontColor);
  libraryButton.setBackgroundPainter(new ButtonPainter());
  shareButton=new JXButton(I18n.tr(""String_Node_Str""),downIcon);
  shareButton.setVisible(false);
  shareButton.setForeground(fontColor);
  shareButton.setHorizontalTextPosition(SwingConstants.LEFT);
  shareButton.setBackgroundPainter(new ButtonPainter());
  shareButton.addActionListener(new PopupActionListener());
}","private void createComponents(){
  titleLabel=new HeadingLabel(staticText);
  titleLabel.setForeground(fontColor);
  FontUtils.setSize(titleLabel,fontSize);
  FontUtils.changeStyle(titleLabel,Font.PLAIN);
  filterBox=new PromptTextField();
  libraryButton=new LibraryButton(new GoToLibraryAction(navigator,null));
  libraryButton.setPreferredSize(new Dimension(buttonWidth,buttonHeight));
  libraryButton.setForeground(fontColor);
  libraryButton.setBackgroundPainter(new ButtonPainter());
  libraryButton.setBorderPainted(false);
  shareButton=new JXButton(I18n.tr(""String_Node_Str""),downIcon);
  shareButton.setVisible(false);
  shareButton.setForeground(fontColor);
  shareButton.setHorizontalTextPosition(SwingConstants.LEFT);
  shareButton.setBackgroundPainter(new ButtonPainter());
  shareButton.addActionListener(new PopupActionListener());
}",0.9752564876282438
4014,"@Override public void componentResized(ComponentEvent e){
  if (table.getPreferredSize().height < scrollPane.getViewport().getSize().height) {
    layer.setPreferredSize(scrollPane.getViewport().getSize());
  }
 else {
    layer.setPreferredSize(table.getPreferredSize());
  }
}","@Override public void componentResized(ComponentEvent e){
  adjustSize();
}",0.4135977337110481
4015,"@AssistedInject public MyLibraryPanel(@Assisted Category category,@Assisted EventList<LocalFileItem> eventList,final LibrarySharePanel sharePanel,IconManager iconManager,LibraryTableFactory tableFactory){
  this.sharePanel=sharePanel;
  setLayout(new BorderLayout());
  header=new LibraryHeaderPanel(category,null);
  EventList<LocalFileItem> filterList=GlazedListsFactory.filterList(eventList,new TextComponentMatcherEditor<LocalFileItem>(header.getFilterTextField(),new LibraryTextFilterator<LocalFileItem>()));
  table=tableFactory.createTable(category,filterList,null);
  table.enableSharing(sharePanel);
  table.setDoubleClickHandler(new MyLibraryDoubleClickHandler(getTableModel()));
  final JXLayer<JTable> layer=new JXLayer<JTable>(table,new AbstractLayerUI<JTable>());
  final JScrollPane scrollPane=new JScrollPane(layer);
  scrollPane.setColumnHeaderView(table.getTableHeader());
  if (table.isColumnControlVisible()) {
    scrollPane.setCorner(JScrollPane.UPPER_TRAILING_CORNER,table.getColumnControl());
    scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
  }
  scrollPane.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      if (table.getPreferredSize().height < scrollPane.getViewport().getSize().height) {
        layer.setPreferredSize(scrollPane.getViewport().getSize());
      }
 else {
        layer.setPreferredSize(table.getPreferredSize());
      }
    }
  }
);
  layer.getGlassPane().setLayout(null);
  sharePanel.setBounds(0,0,sharePanel.getPreferredSize().width,sharePanel.getPreferredSize().height);
  layer.getGlassPane().add(sharePanel);
  sharePanel.setVisible(false);
  AWTEventListener eventListener=new AWTEventListener(){
    @Override public void eventDispatched(    AWTEvent event){
      if (sharePanel.isVisible() && (event.getID() == MouseEvent.MOUSE_PRESSED)) {
        MouseEvent e=(MouseEvent)event;
        if (sharePanel != e.getComponent() && !sharePanel.contains(e.getComponent()) && !scrollPane.getVerticalScrollBar().contains(e.getPoint())) {
          sharePanel.setVisible(false);
        }
      }
    }
  }
;
  Toolkit.getDefaultToolkit().addAWTEventListener(eventListener,AWTEvent.MOUSE_EVENT_MASK);
  add(scrollPane,BorderLayout.CENTER);
  add(header,BorderLayout.NORTH);
}","@AssistedInject public MyLibraryPanel(@Assisted Category category,@Assisted EventList<LocalFileItem> eventList,final LibrarySharePanel sharePanel,IconManager iconManager,LibraryTableFactory tableFactory){
  this.sharePanel=sharePanel;
  this.eventList=eventList;
  setLayout(new BorderLayout());
  header=new LibraryHeaderPanel(category,null);
  EventList<LocalFileItem> filterList=GlazedListsFactory.filterList(eventList,new TextComponentMatcherEditor<LocalFileItem>(header.getFilterTextField(),new LibraryTextFilterator<LocalFileItem>()));
  table=tableFactory.createTable(category,filterList,null);
  table.enableSharing(sharePanel);
  table.setDoubleClickHandler(new MyLibraryDoubleClickHandler(getTableModel()));
  layer=new JXLayer<JTable>(table,new AbstractLayerUI<JTable>());
  scrollPane=new JScrollPane(layer);
  scrollPane.setColumnHeaderView(table.getTableHeader());
  if (table.isColumnControlVisible()) {
    scrollPane.setCorner(JScrollPane.UPPER_TRAILING_CORNER,table.getColumnControl());
    scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
  }
  scrollPane.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      adjustSize();
    }
  }
);
  listListener=new ListEventListener<LocalFileItem>(){
    @Override public void listChanged(    ListEvent<LocalFileItem> listChanges){
      adjustSize();
    }
  }
;
  eventList.addListEventListener(listListener);
  layer.getGlassPane().setLayout(null);
  sharePanel.setBounds(0,0,sharePanel.getPreferredSize().width,sharePanel.getPreferredSize().height);
  layer.getGlassPane().add(sharePanel);
  sharePanel.setVisible(false);
  AWTEventListener eventListener=new AWTEventListener(){
    @Override public void eventDispatched(    AWTEvent event){
      if (sharePanel.isVisible() && (event.getID() == MouseEvent.MOUSE_PRESSED)) {
        MouseEvent e=(MouseEvent)event;
        if (sharePanel != e.getComponent() && !sharePanel.contains(e.getComponent()) && !scrollPane.getVerticalScrollBar().contains(e.getPoint())) {
          sharePanel.setVisible(false);
        }
      }
    }
  }
;
  Toolkit.getDefaultToolkit().addAWTEventListener(eventListener,AWTEvent.MOUSE_EVENT_MASK);
  add(scrollPane,BorderLayout.CENTER);
  add(header,BorderLayout.NORTH);
}",0.8890803359896619
4016,"public void dispose(){
  table.dispose();
  ((EventTableModel)table.getModel()).dispose();
  if (sharePanel != null) {
    sharePanel.dispose();
  }
}","public void dispose(){
  table.dispose();
  eventList.removeListEventListener(listListener);
  ((EventTableModel)table.getModel()).dispose();
  if (sharePanel != null) {
    sharePanel.dispose();
  }
}",0.8547008547008547
4017,"/** 
 * Forwards necessary events to the AutoCompleteList. 
 */
@Override public void keyPressed(KeyEvent evt){
  if (evt.getKeyCode() == KeyEvent.VK_UP || evt.getKeyCode() == KeyEvent.VK_DOWN)   evt.consume();
  if (dict != null) {
switch (evt.getKeyCode()) {
case KeyEvent.VK_UP:
      if (popup != null)       entryList.decrementSelection();
 else       showPopup(dict.iterator());
    break;
case KeyEvent.VK_DOWN:
  if (popup != null)   entryList.incrementSelection();
 else   showPopup(dict.iterator());
break;
}
}
}","/** 
 * Forwards necessary events to the AutoCompleteList. 
 */
@Override public void keyPressed(KeyEvent evt){
  if (evt.getKeyCode() == KeyEvent.VK_UP || evt.getKeyCode() == KeyEvent.VK_DOWN) {
    evt.consume();
  }
  if (dict != null) {
switch (evt.getKeyCode()) {
case KeyEvent.VK_UP:
      if (popup != null)       entryList.decrementSelection();
 else       showPopup(dict.iterator());
    break;
case KeyEvent.VK_DOWN:
  if (popup != null)   entryList.incrementSelection();
 else   showPopup(dict.iterator());
break;
}
}
}",0.9923954372623576
4018,"/** 
 * Displays the popup window with a list of auto-completable choices, if any exist.
 */
public void autoCompleteInput(){
  String input=textField.getText();
  if (input != null && input.length() > 0) {
    Iterator<String> it=dict.iterator(input);
    if (it.hasNext())     showPopup(it);
 else     hidePopup();
  }
 else {
    hidePopup();
  }
}","/** 
 * Displays the popup window with a list of auto-completable choices, if any exist.
 */
public void autoCompleteInput(){
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      String input=textField.getText();
      if (input != null && input.length() > 0) {
        Iterator<String> it=dict.iterator(input);
        if (it.hasNext())         showPopup(it);
 else         hidePopup();
      }
 else {
        hidePopup();
      }
    }
  }
);
}",0.841978287092883
4019,"public void listChanged(ListEvent<RemoteFileItem> listChanges){
  while (listChanges.next()) {
    if (listChanges.getType() == ListEvent.INSERT) {
      RemoteFileItem newFile=listChanges.getSourceList().get(listChanges.getIndex());
      LOG.debugf(""String_Node_Str"",newFile.getName());
      addToIndex(newFile,newFile.getName());
      StringTokenizer st=new StringTokenizer(newFile.getName());
      while (st.hasMoreElements()) {
        String word=st.nextToken();
        addToIndex(newFile,word);
      }
    }
  }
}","public void listChanged(ListEvent<RemoteFileItem> listChanges){
  while (listChanges.next()) {
    if (listChanges.getType() == ListEvent.INSERT) {
      RemoteFileItem newFile=listChanges.getSourceList().get(listChanges.getIndex());
      LOG.debugf(""String_Node_Str"",newFile.getName(),presenceId);
      addToIndex(newFile,newFile.getName());
      StringTokenizer st=new StringTokenizer(newFile.getName());
      if (st.countTokens() > 1) {
        while (st.hasMoreElements()) {
          String word=st.nextToken();
          addToIndex(newFile,word);
        }
      }
    }
  }
}",0.9450945094509452
4020,"LibraryListener(LockableStringTrie<ConcurrentLinkedQueue<RemoteFileItem>> library){
  this.library=library;
}","LibraryListener(String presenceId,LockableStringTrie<ConcurrentLinkedQueue<RemoteFileItem>> library){
  this.presenceId=presenceId;
  this.library=library;
}",0.8195488721804511
4021,"@Inject void register(RemoteLibraryManager remoteLibraryManager){
  remoteLibraryManager.getFriendLibraryList().addListEventListener(new ListEventListener<FriendLibrary>(){
    @Override public void listChanged(    ListEvent<FriendLibrary> listChanges){
      while (listChanges.next()) {
        int type=listChanges.getType();
        if (type == ListEvent.INSERT) {
          FriendLibrary friendLibrary=listChanges.getSourceList().get(listChanges.getIndex());
          new AbstractListEventListener<PresenceLibrary>(){
            @Override protected void itemAdded(            PresenceLibrary item){
              LockableStringTrie<ConcurrentLinkedQueue<RemoteFileItem>> trie=new LockableStringTrie<ConcurrentLinkedQueue<RemoteFileItem>>(true);
              if (libraries.putIfAbsent(item.getPresence().getPresenceId(),trie) == null) {
                LOG.debugf(""String_Node_Str"",item.getPresence().getPresenceId());
                item.getModel().addListEventListener(new LibraryListener(trie));
              }
            }
            @Override protected void itemRemoved(            PresenceLibrary item){
              LOG.debugf(""String_Node_Str"",item.getPresence());
              libraries.remove(item.getPresence().getPresenceId());
            }
            @Override protected void itemUpdated(            PresenceLibrary item){
            }
          }
.install(friendLibrary.getPresenceLibraryList());
        }
      }
    }
  }
);
}","@Inject void register(RemoteLibraryManager remoteLibraryManager){
  remoteLibraryManager.getFriendLibraryList().addListEventListener(new ListEventListener<FriendLibrary>(){
    @Override public void listChanged(    ListEvent<FriendLibrary> listChanges){
      while (listChanges.next()) {
        int type=listChanges.getType();
        if (type == ListEvent.INSERT) {
          FriendLibrary friendLibrary=listChanges.getSourceList().get(listChanges.getIndex());
          new AbstractListEventListener<PresenceLibrary>(){
            @Override protected void itemAdded(            PresenceLibrary item){
              LockableStringTrie<ConcurrentLinkedQueue<RemoteFileItem>> trie=new LockableStringTrie<ConcurrentLinkedQueue<RemoteFileItem>>(true);
              if (libraries.putIfAbsent(item.getPresence().getPresenceId(),trie) == null) {
                LOG.debugf(""String_Node_Str"",item.getPresence().getPresenceId());
                item.getModel().addListEventListener(new LibraryListener(item.getPresence().getPresenceId(),trie));
              }
            }
            @Override protected void itemRemoved(            PresenceLibrary item){
              LOG.debugf(""String_Node_Str"",item.getPresence());
              libraries.remove(item.getPresence().getPresenceId());
            }
            @Override protected void itemUpdated(            PresenceLibrary item){
            }
          }
.install(friendLibrary.getPresenceLibraryList());
        }
      }
    }
  }
);
}",0.988147646461226
4022,"@Override protected void itemAdded(PresenceLibrary item){
  LockableStringTrie<ConcurrentLinkedQueue<RemoteFileItem>> trie=new LockableStringTrie<ConcurrentLinkedQueue<RemoteFileItem>>(true);
  if (libraries.putIfAbsent(item.getPresence().getPresenceId(),trie) == null) {
    LOG.debugf(""String_Node_Str"",item.getPresence().getPresenceId());
    item.getModel().addListEventListener(new LibraryListener(trie));
  }
}","@Override protected void itemAdded(PresenceLibrary item){
  LockableStringTrie<ConcurrentLinkedQueue<RemoteFileItem>> trie=new LockableStringTrie<ConcurrentLinkedQueue<RemoteFileItem>>(true);
  if (libraries.putIfAbsent(item.getPresence().getPresenceId(),trie) == null) {
    LOG.debugf(""String_Node_Str"",item.getPresence().getPresenceId());
    item.getModel().addListEventListener(new LibraryListener(item.getPresence().getPresenceId(),trie));
  }
}",0.9596309111880046
4023,"/** 
 * Resolves a   {@link FirewalledAddress} to the {@link Connectable} of its {@link FirewalledAddress#getPrivateAddress() private address} if this peerand the peer the address belongs to are behind the same firewall. Otherwise resolves the address to a  {@link ResolvedFirewalledAddress} tomark it as resolved.
 */
@Override public void resolve(Address addr,int timeout,AddressResolutionObserver observer){
  FirewalledAddress address=(FirewalledAddress)addr;
  waitForLocalAddress();
  byte[] publicAddress=networkManager.getExternalAddress();
  if (!Arrays.equals(publicAddress,address.getPublicAddress().getInetAddress().getAddress())) {
    LOG.debugf(""String_Node_Str"",address.getPublicAddress());
    observer.resolved(new ResolvedFirewalledAddress(address.getPublicAddress(),address.getPrivateAddress(),address.getClientGuid(),address.getPushProxies(),address.getFwtVersion()));
    return;
  }
  byte[] privateAddress=networkManager.getAddress();
  if (NetworkUtils.areInSameSiteLocalNetwork(privateAddress,address.getPrivateAddress().getInetAddress().getAddress())) {
    LOG.debug(""String_Node_Str"");
    observer.resolved(address.getPrivateAddress());
  }
 else {
    LOG.debugf(""String_Node_Str"",address.getPrivateAddress());
    observer.resolved(new ResolvedFirewalledAddress(address.getPublicAddress(),address.getPrivateAddress(),address.getClientGuid(),address.getPushProxies(),address.getFwtVersion()));
  }
}","/** 
 * Resolves a   {@link FirewalledAddress} to the {@link Connectable} of its {@link FirewalledAddress#getPrivateAddress() private address} if this peerand the peer the address belongs to are behind the same firewall. Otherwise resolves the address to a  {@link ResolvedFirewalledAddress} tomark it as resolved.
 */
@Override public void resolve(Address addr,int timeout,AddressResolutionObserver observer){
  FirewalledAddress address=(FirewalledAddress)addr;
  waitForLocalAddress();
  byte[] publicAddress=networkManager.getExternalAddress();
  if (!Arrays.equals(publicAddress,address.getPublicAddress().getInetAddress().getAddress())) {
    LOG.debugf(""String_Node_Str"",toString(publicAddress),address.getPublicAddress());
    observer.resolved(new ResolvedFirewalledAddress(address.getPublicAddress(),address.getPrivateAddress(),address.getClientGuid(),address.getPushProxies(),address.getFwtVersion()));
    return;
  }
  byte[] privateAddress=networkManager.getNonForcedAddress();
  if (NetworkUtils.areInSameSiteLocalNetwork(privateAddress,address.getPrivateAddress().getInetAddress().getAddress())) {
    LOG.debug(""String_Node_Str"");
    observer.resolved(address.getPrivateAddress());
  }
 else {
    LOG.debugf(""String_Node_Str"",toString(privateAddress),address.getPrivateAddress());
    observer.resolved(new ResolvedFirewalledAddress(address.getPublicAddress(),address.getPrivateAddress(),address.getClientGuid(),address.getPushProxies(),address.getFwtVersion()));
  }
}",0.980123372172721
4024,"public byte[] getNonForcedAddress(){
  return null;
}","public byte[] getNonForcedAddress(){
  return getAddress();
}",0.8596491228070176
4025,"@Override public void mouseExited(MouseEvent e){
  if (!menu.isVisible()) {
    headerPanel.setBorder(noBorder);
  }
}","@Override public void mouseExited(MouseEvent e){
  hideTimer.start();
}",0.6772486772486772
4026,"private void updateMenus(){
  if (people.length == 0)   return;
  if (people.length == 1) {
    String person=people[0];
    menu.add(getChatAction(person));
    menu.add(getLibraryAction(person));
    menu.add(getSharingAction(person));
  }
 else {
    for (    String person : people) {
      JMenu submenu=new JMenu(person);
      submenu.add(getChatAction(person));
      submenu.add(getLibraryAction(person));
      menu.add(submenu);
    }
  }
}","private void updateMenus(){
  if (people.length == 0)   return;
  if (people.length == 1) {
    String person=people[0];
    menu.add(getChatAction(person));
    menu.add(getLibraryAction(person));
    menu.add(getSharingAction(person));
  }
 else {
    for (    String person : people) {
      JMenu submenu=new JMenu(person);
      submenu.addMouseListener(menuHider);
      JMenuItem chatItem=new JMenuItem(getChatAction(person));
      chatItem.addMouseListener(menuHider);
      submenu.add(chatItem);
      JMenuItem libraryItem=new JMenuItem(getLibraryAction(person));
      libraryItem.addMouseListener(menuHider);
      submenu.add(libraryItem);
      menu.add(submenu);
    }
  }
}",0.7705779334500875
4027,"public FromWidget(){
  menu=new JPopupMenu();
  menu.setBorder(border);
  configureHeader();
  layoutComponents();
  setOpaque(false);
}","public FromWidget(){
  menu=new JPopupMenu();
  menuHider=new MenuHider();
  menu.setBorder(border);
  configureHeader();
  layoutComponents();
  setOpaque(false);
}",0.903654485049834
4028,"@Override public void actionPerformed(ActionEvent e){
  fromActions.showFilesSharedBy(person);
}","@Override public void actionPerformed(ActionEvent e){
  if (menu.isVisible()) {
    menu.setVisible(false);
  }
  ((Timer)e.getSource()).stop();
}",0.628099173553719
4029,"@Override public void mouseEntered(MouseEvent e){
  headerPanel.setBorder(border);
}","@Override public void mouseEntered(MouseEvent e){
  hideTimer.stop();
}",0.8387096774193549
4030,"private void configureHeader(){
  headerPanel.add(headerLabel);
  headerPanel.setBorder(noBorder);
  headerPanel.setOpaque(false);
  menu.addMouseListener(new MouseAdapter(){
    @Override public void mouseExited(    MouseEvent e){
      if (menu.isVisible()) {
        menu.setVisible(false);
      }
    }
  }
);
  headerLabel.addMouseListener(new MouseAdapter(){
    @Override public void mouseEntered(    MouseEvent e){
      headerPanel.setBorder(border);
    }
    @Override public void mouseExited(    MouseEvent e){
      if (!menu.isVisible()) {
        headerPanel.setBorder(noBorder);
      }
    }
    @Override public void mousePressed(    MouseEvent e){
      if (people.length > 0) {
        menu.show((Component)e.getSource(),-R,-R);
      }
    }
  }
);
}","private void configureHeader(){
  headerPanel.add(headerLabel);
  headerPanel.setBorder(noBorder);
  headerPanel.setOpaque(false);
  menu.addMouseListener(menuHider);
  headerLabel.addMouseListener(new MouseAdapter(){
    @Override public void mouseEntered(    MouseEvent e){
      headerPanel.setBorder(border);
    }
    @Override public void mouseExited(    MouseEvent e){
      if (!menu.isVisible()) {
        headerPanel.setBorder(noBorder);
      }
    }
    @Override public void mousePressed(    MouseEvent e){
      if (people.length > 0) {
        menu.show((Component)e.getSource(),-R,-R);
      }
    }
  }
);
}",0.8810888252148997
4031,"public MultiLineLabel(String text,int lineWidth){
  super(text);
  setMaxLineSpan(lineWidth);
  setLineWrap(true);
  Object viewObj=getClientProperty(BasicHTML.propertyKey);
  if (viewObj instanceof View) {
    View view=(View)viewObj;
    int width=(int)view.getPreferredSpan(View.X_AXIS);
    int height=(int)view.getPreferredSpan(View.Y_AXIS);
    setPreferredSize(new Dimension(width,height));
  }
}","public MultiLineLabel(String text,int lineWidth){
  super(text);
  setMaxLineSpan(lineWidth);
  setLineWrap(true);
}",0.4470134874759152
4032,"public void resetAvailability(){
  if (hasChangedAvailability) {
    new SelfAvailabilityUpdateEvent(Mode.available).publish();
    hasChangedAvailability=false;
  }
}","public void resetAvailability(){
  Mode mode=currentMode.get();
  if (mode == null || !mode.equals(Mode.available)) {
    new SelfAvailabilityUpdateEvent(Mode.available).publish();
  }
}",0.6855524079320113
4033,"public IdleTimer(int delay,SelfAvailabilityAction listener){
  super(delay,listener);
  this.availabilityAction=listener;
}","public IdleTimer(int delay,AutomatedAvailabilityAction listener){
  super(delay,listener);
  this.availabilityAction=listener;
}",0.9561752988047808
4034,"@Override protected void configure(){
  binder().install(new LimeWireCommonModule());
  binder().install(new LimeWireNetModule(SettingsBackedProxySettings.class,SettingsBackedSocketBindingSettings.class));
  binder().install(new LimeWireDownloadModule());
  binder().install(new LimeWireHashTreeModule());
  binder().install(new LimeWireDHTModule());
  binder().install(new LimeWireHttpModule());
  binder().install(new LimeWireSearchModule());
  binder().install(new LimeWireStatisticsModule());
  binder().install(new LimeWireGnutellaStatisticsModule());
  binder().install(new LimeWireGnutellaRudpModule());
  binder().install(new LimeWireIOModule());
  binder().install(new LimeWireMojitoModule());
  binder().install(new LimeWireSecurityCertificateModule());
  binder().install(new LimeWireGeocodeGlueModule());
  binder().install(new LimeWirePromotionModule(PromotionBinderRequestorImpl.class,PromotionServicesImpl.class));
  binder().install(new LimeWireSimppModule());
  binder().install(new LimeWireBittorrentModule());
  bind(LimeWireCore.class);
  if (activityCallbackClass != null) {
    bind(ActivityCallback.class).to(activityCallbackClass);
  }
  bind(DownloadCallback.class).to(ActivityCallback.class);
  bind(NetworkManager.class).to(NetworkManagerImpl.class);
  bind(TLSManager.class).to(NetworkManagerImpl.class);
  bind(new TypeLiteral<ListenerSupport<AddressEvent>>(){
  }
).to(NetworkManagerImpl.class);
  bind(DHTManager.class).to(DHTManagerImpl.class);
  bind(DHTControllerFactory.class).to(DHTControllerFactoryImpl.class);
  bind(PingReplyFactory.class).to(PingReplyFactoryImpl.class);
  bind(PushProxiesValueFactory.class).to(PushProxiesValueFactoryImpl.class);
  bind(HandshakeResponderFactory.class).to(HandshakeResponderFactoryImpl.class);
  bind(HeadersFactory.class).to(HeadersFactoryImpl.class);
  bind(PushEndpointFactory.class).to(PushEndpointFactoryImpl.class);
  bind(ManagedTorrentFactory.class).to(ManagedTorrentFactoryImpl.class);
  bind(TrackerManagerFactory.class).to(TrackerManagerFactoryImpl.class);
  bind(TrackerFactory.class).to(TrackerFactoryImpl.class);
  bind(HeadPongFactory.class).to(HeadPongFactoryImpl.class);
  bind(UploadManager.class).to(HTTPUploadManager.class);
  bind(HTTPUploadSessionManager.class).to(HTTPUploadManager.class);
  bind(QueryHandlerFactory.class).to(QueryHandlerFactoryImpl.class);
  bind(QueryRequestFactory.class).to(QueryRequestFactoryImpl.class);
  bind(RoutedConnectionFactory.class).to(RoutedConnectionFactoryImpl.class);
  bind(AltLocValueFactory.class).to(AltLocValueFactoryImpl.class);
  bind(AlternateLocationFactory.class).to(AlternateLocationFactoryImpl.class);
  bind(LocalFileDetailsFactory.class).to(LocalFileDetailsFactoryImpl.class);
  bind(HttpExecutor.class).to(DefaultHttpExecutor.class);
  bind(HttpRequestHandlerFactory.class).to(HttpRequestHandlerFactoryImpl.class);
  bind(ResponseFactory.class).to(ResponseFactoryImpl.class);
  bind(QueryReplyFactory.class).to(QueryReplyFactoryImpl.class);
  bind(MessageDispatcherFactory.class).to(LimeMessageDispatcherFactoryImpl.class);
  bind(CapabilitiesVMFactory.class).to(CapabilitiesVMFactoryImpl.class);
  bind(BTContextFactory.class).to(BTContextFactoryImpl.class);
  bind(LifecycleManager.class).to(LifecycleManagerImpl.class);
  bind(LocalPongInfo.class).to(LocalPongInfoImpl.class);
  bind(ConnectionServices.class).to(ConnectionServicesImpl.class);
  bind(SearchServices.class).to(SearchServicesImpl.class);
  bind(DownloadServices.class).to(DownloadServicesImpl.class);
  bind(UploadServices.class).to(UploadServicesImpl.class);
  bind(ApplicationServices.class).to(ApplicationServicesImpl.class);
  bind(SpamServices.class).to(SpamServicesImpl.class);
  bind(SpamFilterFactory.class).to(SpamFilterFactoryImpl.class);
  bind(DHTControllerFacade.class).to(DHTControllerFacadeImpl.class);
  bind(ChokerFactory.class).to(ChokerFactoryImpl.class);
  bind(BTConnectionFetcherFactory.class).to(BTConnectionFetcherFactoryImpl.class);
  bind(ConnectionCheckerManager.class).to(ConnectionCheckerManagerImpl.class);
  bind(DHTBootstrapperFactory.class).to(DHTBootstrapperFactoryImpl.class);
  bind(DHTNodeFetcherFactory.class).to(DHTNodeFetcherFactoryImpl.class);
  bind(UDPReplyHandlerFactory.class).to(UDPReplyHandlerFactoryImpl.class);
  bind(UDPReplyHandlerCache.class).to(UDPReplyHandlerCacheImpl.class);
  bind(BTConnectionFactory.class).to(BTConnectionFactoryImpl.class);
  bind(SocketProcessor.class).to(Acceptor.class);
  bind(DownloadManager.class).to(DownloadManagerImpl.class).asEagerSingleton();
  bind(BrowseHostHandlerManagerImpl.class).asEagerSingleton();
  bind(ReplyNumberVendorMessageFactory.class).to(ReplyNumberVendorMessageFactoryImpl.class);
  bind(GuidMapManager.class).to(GuidMapManagerImpl.class);
  bind(BrowseHostHandlerManager.class).to(BrowseHostHandlerManagerImpl.class);
  bind(PushEndpointCache.class).to(PushEndpointCacheImpl.class);
  bind(PushEndpointService.class).annotatedWith(Names.named(""String_Node_Str"")).to(PushEndpointCacheImpl.class);
  bind(FileResponseEntityFactory.class).to(FileResponseEntityFactoryImpl.class);
  bind(MessageFactory.class).to(MessageFactoryImpl.class);
  bind(MessageReaderFactory.class).to(MessageReaderFactoryImpl.class);
  bind(MessageParserBinder.class).to(MessageParserBinderImpl.class);
  bind(VendorMessageFactory.class).to(VendorMessageFactoryImpl.class);
  bind(VendorMessageParserBinder.class).to(VendorMessageParserBinderImpl.class);
  bind(UDPCrawlerPongFactory.class).to(UDPCrawlerPongFactoryImpl.class);
  bind(UDPHostCacheFactory.class).to(UDPHostCacheFactoryImpl.class);
  bind(LimeXMLReplyCollectionFactory.class).to(LimeXMLReplyCollectionFactoryImpl.class);
  bind(LicenseFactory.class).to(LicenseFactoryImpl.class);
  bind(LimeXMLDocumentFactory.class).to(LimeXMLDocumentFactoryImpl.class);
  bind(MetaDataFactory.class).to(MetaDataFactoryImpl.class);
  bind(InstantMessengerFactory.class).to(InstantMessengerFactoryImpl.class);
  bind(SaveLocationManager.class).to(DownloadManager.class);
  bind(BTUploaderFactory.class).to(BTUploaderFactoryImpl.class);
  bind(PingRequestFactory.class).to(PingRequestFactoryImpl.class);
  bind(IpPortContentAuthorityFactory.class).to(IpPortContentAuthorityFactoryImpl.class);
  bind(UpdateCollectionFactory.class).to(UpdateCollectionFactoryImpl.class);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(UDPPinger.class).to(UDPPingerImpl.class);
  bind(UDPConnectionChecker.class).to(UDPConnectionCheckerImpl.class);
  bind(Inspector.class).to(InspectorImpl.class);
  bind(ConnectionCapabilities.class).to(ConnectionCapabilitiesImpl.class);
  bind(ConnectionBandwidthStatistics.class).to(ConnectionBandwidthStatisticsImpl.class);
  bind(LWSManager.class).to(LWSManagerImpl.class);
  bind(LWSIntegrationServicesDelegate.class).to(DownloadManager.class);
  bind(LocalSocketAddressProvider.class).to(LocalSocketAddressProviderImpl.class);
  bind(SettingsProvider.class).to(MacCalculatorSettingsProviderImpl.class);
  bind(ReplyHandler.class).annotatedWith(Names.named(""String_Node_Str"")).to(ForMeReplyHandler.class);
  bind(MessageRouter.class).to(StandardMessageRouter.class);
  bind(IPFilter.class).to(LocalIPFilter.class);
  bind(IPFilter.class).annotatedWith(Names.named(""String_Node_Str"")).to(HostileFilter.class);
  bind(UploadSlotManager.class).to(UploadSlotManagerImpl.class);
  bind(new TypeLiteral<EventDispatcher<TorrentEvent,TorrentEventListener>>(){
  }
).to(TorrentManager.class);
  bind(TorrentManager.class).to(TorrentManagerImpl.class);
  bind(BandwidthManager.class).to(BandwidthManagerImpl.class);
  bind(SecureMessageVerifier.class).toProvider(SecureMessageVerifierProvider.class);
  bind(SecureMessageVerifier.class).annotatedWith(Names.named(""String_Node_Str"")).toProvider(InspectionVerifierProvider.class);
  bind(PongCacher.class).to(PongCacherImpl.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(UploadManager.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(DownloadManager.class);
  bind(NIODispatcher.class).toProvider(NIODispatcherProvider.class);
  bind(ByteBufferCache.class).toProvider(ByteBufferCacheProvider.class);
  bind(ResponseVerifier.class).to(ResponseVerifierImpl.class);
  bind(HandshakeServices.class).to(HandshakeServicesImpl.class);
  bind(ConnectionManager.class).to(ConnectionManagerImpl.class);
  bind(MessageHandlerBinder.class).to(MessageHandlerBinderImpl.class);
  bind(QueryDispatcher.class).to(QueryDispatcherImpl.class);
  bind(DHTPeerPublisher.class).to(DHTPeerPublisherImpl.class);
  bind(DHTPeerLocator.class).to(DHTPeerLocatorImpl.class);
  bind(Acceptor.class).to(AcceptorImpl.class);
  bind(UpdateHandler.class).to(UpdateHandlerImpl.class);
  bind(SecurityToken.TokenProvider.class).to(SecurityToken.AddressSecurityTokenProvider.class);
  bind(UpdateMessageVerifier.class).to(UpdateMessageVerifierImpl.class);
  bind(InspectionResponseFactory.class).to(InspectionResponseFactoryImpl.class);
  bind(FECUtils.class).to(FECUtilsImpl.class);
  bind(NodeAssigner.class).to(NodeAssignerImpl.class);
  bind(BTMetaInfoFactory.class).to(BTMetaInfoFactoryImpl.class);
  bind(SharedFilesKeywordIndex.class).to(SharedFilesKeywordIndexImpl.class);
  bind(OutgoingQueryReplyFactory.class).to(OutgoingQueryReplyFactoryImpl.class);
  bind(UPnPManagerConfiguration.class).to(UPnPManagerConfigurationImpl.class);
  bindAll(Names.named(""String_Node_Str""),ExecutorService.class,UnlimitedExecutorProvider.class,Executor.class);
  bindAll(Names.named(""String_Node_Str""),ScheduledExecutorService.class,BackgroundTimerProvider.class,ExecutorService.class,Executor.class);
  bindAll(Names.named(""String_Node_Str""),ExecutorService.class,DHTExecutorProvider.class,Executor.class);
  bindAll(Names.named(""String_Node_Str""),ExecutorService.class,MessageExecutorProvider.class,Executor.class);
  bindAll(Names.named(""String_Node_Str""),ScheduledExecutorService.class,NIOScheduledExecutorServiceProvider.class,ExecutorService.class,Executor.class);
  bind(Statistics.class);
  bind(CoreRandomGlue.class);
  bind(ConnectionAcceptorGlue.class);
  bind(DownloadUpgradeTaskService.class);
  bind(LocalAcceptor.class);
  bind(Pinger.class);
  bind(ConnectionWatchdog.class);
  bind(SavedFileManager.class);
  bind(RatingTable.class);
  bind(OutOfBandThroughputMeasurer.class);
  bind(HostCatcher.class);
  bind(LimeCoreGlue.class);
  bind(QRPUpdater.class);
  bind(DaapManager.class);
  bind(FirewalledAddressSerializer.class);
  bind(SameNATAddressResolver.class);
  bind(FileManager.class).to(FileManagerImpl.class);
}","@Override protected void configure(){
  binder().install(new LimeWireCommonModule());
  binder().install(new LimeWireNetModule(SettingsBackedProxySettings.class,SettingsBackedSocketBindingSettings.class));
  binder().install(new LimeWireDownloadModule());
  binder().install(new LimeWireHashTreeModule());
  binder().install(new LimeWireDHTModule());
  binder().install(new LimeWireHttpModule());
  binder().install(new LimeWireSearchModule());
  binder().install(new LimeWireStatisticsModule());
  binder().install(new LimeWireGnutellaStatisticsModule());
  binder().install(new LimeWireGnutellaRudpModule());
  binder().install(new LimeWireIOModule());
  binder().install(new LimeWireMojitoModule());
  binder().install(new LimeWireSecurityCertificateModule());
  binder().install(new LimeWireGeocodeGlueModule());
  binder().install(new LimeWirePromotionModule(PromotionBinderRequestorImpl.class,PromotionServicesImpl.class));
  binder().install(new LimeWireSimppModule());
  binder().install(new LimeWireBittorrentModule());
  bind(LimeWireCore.class);
  if (activityCallbackClass != null) {
    bind(ActivityCallback.class).to(activityCallbackClass);
  }
  bind(DownloadCallback.class).to(ActivityCallback.class);
  bind(NetworkManager.class).to(NetworkManagerImpl.class);
  bind(TLSManager.class).to(NetworkManagerImpl.class);
  bind(new TypeLiteral<ListenerSupport<AddressEvent>>(){
  }
).to(NetworkManagerImpl.class);
  bind(DHTManager.class).to(DHTManagerImpl.class);
  bind(DHTControllerFactory.class).to(DHTControllerFactoryImpl.class);
  bind(PingReplyFactory.class).to(PingReplyFactoryImpl.class);
  bind(PushProxiesValueFactory.class).to(PushProxiesValueFactoryImpl.class);
  bind(HandshakeResponderFactory.class).to(HandshakeResponderFactoryImpl.class);
  bind(HeadersFactory.class).to(HeadersFactoryImpl.class);
  bind(PushEndpointFactory.class).to(PushEndpointFactoryImpl.class);
  bind(ManagedTorrentFactory.class).to(ManagedTorrentFactoryImpl.class);
  bind(TrackerManagerFactory.class).to(TrackerManagerFactoryImpl.class);
  bind(TrackerFactory.class).to(TrackerFactoryImpl.class);
  bind(HeadPongFactory.class).to(HeadPongFactoryImpl.class);
  bind(UploadManager.class).to(HTTPUploadManager.class);
  bind(HTTPUploadSessionManager.class).to(HTTPUploadManager.class);
  bind(QueryHandlerFactory.class).to(QueryHandlerFactoryImpl.class);
  bind(QueryRequestFactory.class).to(QueryRequestFactoryImpl.class);
  bind(RoutedConnectionFactory.class).to(RoutedConnectionFactoryImpl.class);
  bind(AltLocValueFactory.class).to(AltLocValueFactoryImpl.class);
  bind(AlternateLocationFactory.class).to(AlternateLocationFactoryImpl.class);
  bind(LocalFileDetailsFactory.class).to(LocalFileDetailsFactoryImpl.class);
  bind(HttpExecutor.class).to(DefaultHttpExecutor.class);
  bind(HttpRequestHandlerFactory.class).to(HttpRequestHandlerFactoryImpl.class);
  bind(ResponseFactory.class).to(ResponseFactoryImpl.class);
  bind(QueryReplyFactory.class).to(QueryReplyFactoryImpl.class);
  bind(MessageDispatcherFactory.class).to(LimeMessageDispatcherFactoryImpl.class);
  bind(CapabilitiesVMFactory.class).to(CapabilitiesVMFactoryImpl.class);
  bind(BTContextFactory.class).to(BTContextFactoryImpl.class);
  bind(LifecycleManager.class).to(LifecycleManagerImpl.class);
  bind(LocalPongInfo.class).to(LocalPongInfoImpl.class);
  bind(ConnectionServices.class).to(ConnectionServicesImpl.class);
  bind(SearchServices.class).to(SearchServicesImpl.class);
  bind(DownloadServices.class).to(DownloadServicesImpl.class);
  bind(UploadServices.class).to(UploadServicesImpl.class);
  bind(ApplicationServices.class).to(ApplicationServicesImpl.class);
  bind(SpamServices.class).to(SpamServicesImpl.class);
  bind(SpamFilterFactory.class).to(SpamFilterFactoryImpl.class);
  bind(DHTControllerFacade.class).to(DHTControllerFacadeImpl.class);
  bind(ChokerFactory.class).to(ChokerFactoryImpl.class);
  bind(BTConnectionFetcherFactory.class).to(BTConnectionFetcherFactoryImpl.class);
  bind(ConnectionCheckerManager.class).to(ConnectionCheckerManagerImpl.class);
  bind(DHTBootstrapperFactory.class).to(DHTBootstrapperFactoryImpl.class);
  bind(DHTNodeFetcherFactory.class).to(DHTNodeFetcherFactoryImpl.class);
  bind(UDPReplyHandlerFactory.class).to(UDPReplyHandlerFactoryImpl.class);
  bind(UDPReplyHandlerCache.class).to(UDPReplyHandlerCacheImpl.class);
  bind(BTConnectionFactory.class).to(BTConnectionFactoryImpl.class);
  bind(SocketProcessor.class).to(Acceptor.class);
  bind(DownloadManager.class).to(DownloadManagerImpl.class).asEagerSingleton();
  bind(BrowseHostHandlerManagerImpl.class).asEagerSingleton();
  bind(ReplyNumberVendorMessageFactory.class).to(ReplyNumberVendorMessageFactoryImpl.class);
  bind(GuidMapManager.class).to(GuidMapManagerImpl.class);
  bind(BrowseHostHandlerManager.class).to(BrowseHostHandlerManagerImpl.class);
  bind(PushEndpointCache.class).to(PushEndpointCacheImpl.class);
  bind(PushEndpointService.class).annotatedWith(Names.named(""String_Node_Str"")).to(PushEndpointCacheImpl.class);
  bind(FileResponseEntityFactory.class).to(FileResponseEntityFactoryImpl.class);
  bind(MessageFactory.class).to(MessageFactoryImpl.class);
  bind(MessageReaderFactory.class).to(MessageReaderFactoryImpl.class);
  bind(MessageParserBinder.class).to(MessageParserBinderImpl.class);
  bind(VendorMessageFactory.class).to(VendorMessageFactoryImpl.class);
  bind(VendorMessageParserBinder.class).to(VendorMessageParserBinderImpl.class);
  bind(UDPCrawlerPongFactory.class).to(UDPCrawlerPongFactoryImpl.class);
  bind(UDPHostCacheFactory.class).to(UDPHostCacheFactoryImpl.class);
  bind(LimeXMLReplyCollectionFactory.class).to(LimeXMLReplyCollectionFactoryImpl.class);
  bind(LicenseFactory.class).to(LicenseFactoryImpl.class);
  bind(LimeXMLDocumentFactory.class).to(LimeXMLDocumentFactoryImpl.class);
  bind(MetaDataFactory.class).to(MetaDataFactoryImpl.class);
  bind(InstantMessengerFactory.class).to(InstantMessengerFactoryImpl.class);
  bind(SaveLocationManager.class).to(DownloadManager.class);
  bind(BTUploaderFactory.class).to(BTUploaderFactoryImpl.class);
  bind(PingRequestFactory.class).to(PingRequestFactoryImpl.class);
  bind(IpPortContentAuthorityFactory.class).to(IpPortContentAuthorityFactoryImpl.class);
  bind(UpdateCollectionFactory.class).to(UpdateCollectionFactoryImpl.class);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(ConnectionDispatcher.class).annotatedWith(Names.named(""String_Node_Str"")).to(ConnectionDispatcherImpl.class).in(Scopes.SINGLETON);
  bind(UDPPinger.class).to(UDPPingerImpl.class);
  bind(UDPConnectionChecker.class).to(UDPConnectionCheckerImpl.class);
  bind(Inspector.class).to(InspectorImpl.class);
  bind(ConnectionCapabilities.class).to(ConnectionCapabilitiesImpl.class);
  bind(ConnectionBandwidthStatistics.class).to(ConnectionBandwidthStatisticsImpl.class);
  bind(LWSManager.class).to(LWSManagerImpl.class);
  bind(LWSIntegrationServicesDelegate.class).to(DownloadManager.class);
  bind(LocalSocketAddressProvider.class).to(LocalSocketAddressProviderImpl.class);
  bind(SettingsProvider.class).to(MacCalculatorSettingsProviderImpl.class);
  bind(ReplyHandler.class).annotatedWith(Names.named(""String_Node_Str"")).to(ForMeReplyHandler.class);
  bind(MessageRouter.class).to(StandardMessageRouter.class);
  bind(IPFilter.class).to(LocalIPFilter.class);
  bind(IPFilter.class).annotatedWith(Names.named(""String_Node_Str"")).to(HostileFilter.class);
  bind(UploadSlotManager.class).to(UploadSlotManagerImpl.class);
  bind(new TypeLiteral<EventDispatcher<TorrentEvent,TorrentEventListener>>(){
  }
).to(TorrentManager.class);
  bind(TorrentManager.class).to(TorrentManagerImpl.class);
  bind(BandwidthManager.class).to(BandwidthManagerImpl.class);
  bind(SecureMessageVerifier.class).toProvider(SecureMessageVerifierProvider.class);
  bind(SecureMessageVerifier.class).annotatedWith(Names.named(""String_Node_Str"")).toProvider(InspectionVerifierProvider.class);
  bind(PongCacher.class).to(PongCacherImpl.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(UploadManager.class);
  bind(BandwidthTracker.class).annotatedWith(Names.named(""String_Node_Str"")).to(DownloadManager.class);
  bind(NIODispatcher.class).toProvider(NIODispatcherProvider.class);
  bind(ByteBufferCache.class).toProvider(ByteBufferCacheProvider.class);
  bind(ResponseVerifier.class).to(ResponseVerifierImpl.class);
  bind(HandshakeServices.class).to(HandshakeServicesImpl.class);
  bind(ConnectionManager.class).to(ConnectionManagerImpl.class);
  bind(MessageHandlerBinder.class).to(MessageHandlerBinderImpl.class);
  bind(QueryDispatcher.class).to(QueryDispatcherImpl.class);
  bind(DHTPeerPublisher.class).to(DHTPeerPublisherImpl.class);
  bind(DHTPeerLocator.class).to(DHTPeerLocatorImpl.class);
  bind(Acceptor.class).to(AcceptorImpl.class);
  bind(UpdateHandler.class).to(UpdateHandlerImpl.class);
  bind(SecurityToken.TokenProvider.class).to(SecurityToken.AddressSecurityTokenProvider.class);
  bind(UpdateMessageVerifier.class).to(UpdateMessageVerifierImpl.class);
  bind(InspectionResponseFactory.class).to(InspectionResponseFactoryImpl.class);
  bind(FECUtils.class).to(FECUtilsImpl.class);
  bind(NodeAssigner.class).to(NodeAssignerImpl.class);
  bind(BTMetaInfoFactory.class).to(BTMetaInfoFactoryImpl.class);
  bind(SharedFilesKeywordIndex.class).to(SharedFilesKeywordIndexImpl.class);
  bind(OutgoingQueryReplyFactory.class).to(OutgoingQueryReplyFactoryImpl.class);
  bind(UPnPManagerConfiguration.class).to(UPnPManagerConfigurationImpl.class);
  bindAll(Names.named(""String_Node_Str""),ExecutorService.class,UnlimitedExecutorProvider.class,Executor.class);
  bindAll(Names.named(""String_Node_Str""),ScheduledExecutorService.class,BackgroundTimerProvider.class,ExecutorService.class,Executor.class);
  bindAll(Names.named(""String_Node_Str""),ExecutorService.class,DHTExecutorProvider.class,Executor.class);
  bindAll(Names.named(""String_Node_Str""),ExecutorService.class,MessageExecutorProvider.class,Executor.class);
  bindAll(Names.named(""String_Node_Str""),ScheduledExecutorService.class,NIOScheduledExecutorServiceProvider.class,ExecutorService.class,Executor.class);
  bind(Statistics.class);
  bind(CoreRandomGlue.class);
  bind(ConnectionAcceptorGlue.class);
  bind(DownloadUpgradeTaskService.class);
  bind(LocalAcceptor.class);
  bind(Pinger.class);
  bind(ConnectionWatchdog.class);
  bind(SavedFileManager.class);
  bind(RatingTable.class);
  bind(OutOfBandThroughputMeasurer.class);
  bind(HostCatcher.class);
  bind(LimeCoreGlue.class);
  bind(QRPUpdater.class);
  bind(DaapManager.class);
  bind(FirewalledAddressSerializer.class);
  bind(SameNATAddressResolver.class);
  bind(ConnectableConnector.class);
  bind(FileManager.class).to(FileManagerImpl.class);
}",0.998337950138504
4035,"@Override protected void configure(){
  bind(SocketsManager.class).to(SocketsManagerImpl.class);
  bind(ProxyManager.class).to(ProxyManagerImpl.class);
  bind(WhoIsRequestFactory.class).to(WhoIsRequestFactoryImpl.class);
  bind(FirewallService.class).to(FirewallServiceImpl.class);
  bind(AddressFactory.class).to(AddressFactoryImpl.class);
  bind(ConnectableSerializer.class);
  bind(ConnectableConnector.class);
  if (OSUtils.isSocketChallengedWindows())   bind(SocketController.class).to(LimitedSocketController.class);
 else   bind(SocketController.class).to(SimpleSocketController.class);
  if (proxySettings != null)   bind(ProxySettings.class).to(proxySettings);
  if (socketBindingSettings != null)   bind(SocketBindingSettings.class).to(socketBindingSettings);
}","@Override protected void configure(){
  bind(SocketsManager.class).to(SocketsManagerImpl.class);
  bind(ProxyManager.class).to(ProxyManagerImpl.class);
  bind(WhoIsRequestFactory.class).to(WhoIsRequestFactoryImpl.class);
  bind(FirewallService.class).to(FirewallServiceImpl.class);
  bind(AddressFactory.class).to(AddressFactoryImpl.class);
  bind(ConnectableSerializer.class);
  if (OSUtils.isSocketChallengedWindows())   bind(SocketController.class).to(LimitedSocketController.class);
 else   bind(SocketController.class).to(SimpleSocketController.class);
  if (proxySettings != null)   bind(ProxySettings.class).to(proxySettings);
  if (socketBindingSettings != null)   bind(SocketBindingSettings.class).to(socketBindingSettings);
}",0.9760956175298804
4036,"private static void appendIsTypingMessage(StringBuilder builder,String senderName,ChatState chatState,boolean friendSignedOff){
  String stateMessage=null;
  if (friendSignedOff) {
    stateMessage=I18n.tr(""String_Node_Str"",senderName);
  }
 else   if (chatState == ChatState.composing) {
    stateMessage=I18n.tr(""String_Node_Str"",senderName);
  }
 else   if (chatState == ChatState.paused) {
    stateMessage=I18n.tr(""String_Node_Str"",senderName);
  }
 else {
    return;
  }
  String cssClass=""String_Node_Str"";
  builder.append(""String_Node_Str"").append(cssClass).append(""String_Node_Str"").append(stateMessage).append(""String_Node_Str"").append(""String_Node_Str"");
}","private static void appendIsTypingMessage(StringBuilder builder,String senderName,ChatState chatState,boolean friendSignedOff){
  String stateMessage=null;
  if (friendSignedOff) {
    stateMessage=tr(""String_Node_Str"",senderName);
  }
 else   if (chatState == ChatState.composing) {
    stateMessage=tr(""String_Node_Str"",senderName);
  }
 else   if (chatState == ChatState.paused) {
    stateMessage=tr(""String_Node_Str"",senderName);
  }
 else {
    return;
  }
  String cssClass=""String_Node_Str"";
  builder.append(""String_Node_Str"").append(cssClass).append(""String_Node_Str"").append(stateMessage).append(""String_Node_Str"").append(""String_Node_Str"");
}",0.9886621315192744
4037,"@Override public void handleEvent(RosterEvent event){
  if (event.getType().equals(User.EventType.USER_ADDED)) {
    LocalFileList fileList=libraryManager.getOrCreateFriendShareList(event.getSource());
    eventList.add(new FriendItemImpl(event.getSource(),fileList.getModel()));
  }
 else   if (event.getType().equals(User.EventType.USER_REMOVED)) {
    libraryManager.removeFriendShareList(event.getSource());
  }
 else   if (event.getType().equals(User.EventType.USER_UPDATED)) {
  }
}","@Override public void handleEvent(RosterEvent event){
  if (event.getType().equals(User.EventType.USER_ADDED)) {
    LocalFileList fileList=libraryManager.getOrCreateFriendShareList(event.getSource());
    friendsList.add(new FriendItemImpl(event.getSource(),fileList.getModel()));
  }
 else   if (event.getType().equals(User.EventType.USER_REMOVED)) {
    libraryManager.removeFriendShareList(event.getSource());
  }
 else   if (event.getType().equals(User.EventType.USER_UPDATED)) {
  }
}",0.9877300613496932
4038,"@Inject public FriendSharePanel(LibraryManager libraryManager,SharingFriendEmptyPanel emptyPanel,Navigator navigator,IconManager iconManager,ThumbnailManager thumbnailManager){
  GuiUtils.assignResources(this);
  EventAnnotationProcessor.subscribe(this);
  this.libraryManager=libraryManager;
  this.iconManager=iconManager;
  this.thumbnailManager=thumbnailManager;
  viewCardLayout=new CardLayout();
  JPanel cardPanel=new JPanel();
  cardPanel.setLayout(viewCardLayout);
  cardPanel.add(emptyPanel,ViewSelectionPanel.DISABLED);
  eventList=new BasicEventList<FriendItem>();
  friendTable=new FriendNameTable(eventList,new FriendTableFormat(),libraryManager,navigator);
  headerPanel=createHeader(cardPanel);
  createCenterCards(headerPanel,cardPanel);
  viewCardLayout.show(cardPanel,ViewSelectionPanel.DISABLED);
  FriendSelectionListener friendSelectionListener=new FriendSelectionListener(friendTable,headerPanel,emptyPanel,cardPanel);
  friendTable.getSelectionModel().addListSelectionListener(friendSelectionListener);
  setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  add(headerPanel,""String_Node_Str"");
  add(new JScrollPane(friendTable),""String_Node_Str"");
  add(cardPanel,""String_Node_Str"");
}","@Inject public FriendSharePanel(LibraryManager libraryManager,SharingFriendEmptyPanel emptyPanel,Navigator navigator,IconManager iconManager,ThumbnailManager thumbnailManager){
  GuiUtils.assignResources(this);
  EventAnnotationProcessor.subscribe(this);
  this.libraryManager=libraryManager;
  this.iconManager=iconManager;
  this.thumbnailManager=thumbnailManager;
  viewCardLayout=new CardLayout();
  JPanel cardPanel=new JPanel();
  cardPanel.setLayout(viewCardLayout);
  cardPanel.add(emptyPanel,ViewSelectionPanel.DISABLED);
  friendsList=GlazedLists.threadSafeList(new BasicEventList<FriendItem>());
  friendTable=new FriendNameTable(friendsList,new FriendTableFormat(),libraryManager,navigator);
  headerPanel=createHeader(cardPanel);
  createCenterCards(headerPanel,cardPanel);
  viewCardLayout.show(cardPanel,ViewSelectionPanel.DISABLED);
  FriendSelectionListener friendSelectionListener=new FriendSelectionListener(friendTable,headerPanel,emptyPanel,cardPanel);
  friendTable.getSelectionModel().addListSelectionListener(friendSelectionListener);
  setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  add(headerPanel,""String_Node_Str"");
  add(new JScrollPane(friendTable),""String_Node_Str"");
  add(cardPanel,""String_Node_Str"");
}",0.9792993630573248
4039,"@EventSubscriber public void handleSignoff(SignoffEvent event){
  eventList.clear();
}","@EventSubscriber public void handleSignoff(SignoffEvent event){
  friendsList.clear();
}",0.9540229885057472
4040,"public ConfigurableTable(boolean showHeaders){
  this.showHeaders=showHeaders;
  setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
  if (showHeaders) {
    final JTableHeader header=getTableHeader();
    header.setToolTipText(""String_Node_Str"");
    header.addMouseListener(new MouseAdapter(){
      @Override public void mouseClicked(      MouseEvent e){
        if (e.getButton() == 1) {
          int col=columnAtPoint(e.getPoint());
          String headerName=tableFormat.getColumnName(col);
        }
 else         if (e.getButton() == 3) {
          if (headerPopup != null) {
            headerPopup.show(ConfigurableTable.this,e.getX(),e.getY() - header.getHeight());
          }
        }
      }
    }
);
  }
 else {
    setTableHeader(null);
  }
  TableColumnModel tcm=getColumnModel();
  for (int i=0; i < tcm.getColumnCount(); i++) {
    tcm.getColumn(i).setPreferredWidth(100);
  }
}","public ConfigurableTable(boolean showHeaders){
  this.showHeaders=showHeaders;
  setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
  if (showHeaders) {
    final JTableHeader header=getTableHeader();
    header.setToolTipText(""String_Node_Str"");
    header.addMouseListener(new MouseAdapter(){
      @Override public void mouseClicked(      MouseEvent e){
        if (e.getButton() == 1) {
          int col=columnAtPoint(e.getPoint());
          String headerName=tableFormat.getColumnName(col);
        }
 else         if (e.getButton() == 3) {
          if (headerPopup != null) {
            headerPopup.show(ConfigurableTable.this,e.getX(),e.getY() - header.getHeight());
          }
        }
      }
    }
);
  }
 else {
    setTableHeader(null);
  }
}",0.9153986609860012
4041,"private void configureList(EventList<VisualSearchResult> eventList){
  resultsList=new ConfigurableTable<VisualSearchResult>(false);
  resultsList.setEventList(eventList);
  resultsList.setTableFormat(new ListViewTableFormat());
  ListViewTableCellEditor renderer=new ListViewTableCellEditor(actionRenderer);
  resultsList.setDefaultRenderer(VisualSearchResult.class,renderer);
  ListViewTableCellEditor editor=new ListViewTableCellEditor(actionEditor);
  resultsList.setDefaultEditor(VisualSearchResult.class,editor);
  resultsList.setRowHeight(ListViewTableCellEditor.HEIGHT);
  resultsList.setColumnWidth(0,ListViewTableCellEditor.WIDTH);
  resultsList.setRowHeight(42);
}","private void configureList(final EventList<VisualSearchResult> eventList){
  resultsList=new ConfigurableTable<VisualSearchResult>(false);
  resultsList.setEventList(eventList);
  ListViewTableFormat tableFormat=new ListViewTableFormat();
  resultsList.setTableFormat(tableFormat);
  ListViewTableCellEditor renderer=new ListViewTableCellEditor(actionRenderer);
  resultsList.setDefaultRenderer(VisualSearchResult.class,renderer);
  ListViewTableCellEditor editor=new ListViewTableCellEditor(actionEditor);
  resultsList.setDefaultEditor(VisualSearchResult.class,editor);
  int columnIndex=0;
  resultsList.setColumnWidth(columnIndex,tableFormat.getInitialColumnWidth(columnIndex));
  resultsList.setRowHeight(ListViewTableCellEditor.HEIGHT);
  resultsList.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      if (e.getButton() == 3) {
        int row=resultsList.rowAtPoint(e.getPoint());
        VisualSearchResult vsr=eventList.get(row);
        JComponent component=(JComponent)e.getSource();
        Window window=(Window)component.getTopLevelAncestor();
        SearchResultMenu menu=new SearchResultMenu(window,vsr);
        menu.show(component,e.getX(),e.getY());
      }
    }
  }
);
}",0.6103286384976526
4042,"public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
  JPanel panel=(JPanel)getTableCellEditorComponent(table,value,isSelected,row,column);
  return panel;
}","public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
  return (JPanel)getTableCellEditorComponent(table,value,isSelected,row,column);
}",0.9192825112107624
4043,"private JPanel makePanel(){
  JPanel panel=new JPanel(new GridBagLayout()){
    @Override public void setBackground(    Color bg){
      super.setBackground(bg);
      if (actionComponent != null) {
        actionComponent.setBackground(bg);
      }
    }
  }
;
  panel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.anchor=GridBagConstraints.WEST;
  gbc.weightx=0;
  panel.add(makeLeftPanel(),gbc);
  gbc.anchor=GridBagConstraints.EAST;
  gbc.weightx=1;
  panel.add(makeCenterPanel(),gbc);
  gbc.weightx=0;
  actionPanel.setOpaque(false);
  panel.add(actionPanel,gbc);
  panel.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      if (e.getButton() == 3) {
        JComponent component=(JComponent)e.getSource();
        Window window=(Window)component.getTopLevelAncestor();
        SearchResultMenu menu=new SearchResultMenu(window,vsr);
        menu.show(component,e.getX(),e.getY());
      }
    }
  }
);
  return panel;
}","private JPanel makePanel(){
  final JPanel panel=new JPanel(new GridBagLayout()){
    @Override public void setBackground(    Color bg){
      super.setBackground(bg);
      if (actionComponent != null) {
        actionComponent.setBackground(bg);
      }
    }
  }
;
  panel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.anchor=GridBagConstraints.WEST;
  gbc.weightx=0;
  panel.add(makeLeftPanel(),gbc);
  gbc.anchor=GridBagConstraints.EAST;
  gbc.weightx=1;
  panel.add(makeCenterPanel(),gbc);
  gbc.weightx=0;
  actionPanel.setOpaque(false);
  panel.add(actionPanel,gbc);
  return panel;
}",0.7495538370017847
4044,"public Component getTableCellEditorComponent(JTable table,Object value,boolean isSelected,int row,int column){
  vsr=(VisualSearchResult)value;
  MediaType mediaType=MediaType.getMediaTypeForExtension(vsr.getFileExtension());
  schema=mediaType == null ? ""String_Node_Str"" : mediaType.toString();
  similarCount=vsr.getSimiliarResults().size();
  if (thePanel == null)   thePanel=makePanel();
  actionComponent=actionEditor.getTableCellEditorComponent(table,value,isSelected,row,column);
  actionPanel.removeAll();
  actionPanel.add(actionComponent);
  populatePanel((VisualSearchResult)value);
  setBackground(isSelected);
  return thePanel;
}","public Component getTableCellEditorComponent(JTable table,Object value,boolean isSelected,int row,int column){
  this.table=table;
  this.row=row;
  vsr=(VisualSearchResult)value;
  MediaType mediaType=MediaType.getMediaTypeForExtension(vsr.getFileExtension());
  schema=mediaType == null ? ""String_Node_Str"" : mediaType.toString();
  similarCount=vsr.getSimiliarResults().size();
  if (thePanel == null)   thePanel=makePanel();
  actionComponent=actionEditor.getTableCellEditorComponent(table,value,isSelected,row,column);
  actionPanel.removeAll();
  actionPanel.add(actionComponent);
  populatePanel((VisualSearchResult)value);
  setBackground(isSelected);
  return thePanel;
}",0.972809667673716
4045,"private void setBackground(boolean isSelected){
  if (thePanel == null)   return;
  Color color=isSelected ? new Color(220,220,255) : Color.WHITE;
  thePanel.setBackground(color);
  int childCount=thePanel.getComponentCount();
  for (int i=0; i < childCount; i++) {
    Component child=thePanel.getComponent(i);
    child.setBackground(color);
  }
}","private void setBackground(boolean isSelected){
  if (thePanel == null)   return;
  Color color=isSelected ? SELECTED_COLOR : Color.WHITE;
  thePanel.setBackground(color);
  int childCount=thePanel.getComponentCount();
  for (int i=0; i < childCount; i++) {
    Component child=thePanel.getComponent(i);
    child.setBackground(color);
  }
}",0.9478260869565216
4046,"@Override public int getInitialColumnWidth(int index){
  return 100;
}","@Override public int getInitialColumnWidth(int index){
  return ListViewTableCellEditor.WIDTH;
}",0.8072289156626506
4047,"private void changeState(TabState tabState){
  if (currentState != tabState) {
    this.currentState=tabState;
switch (tabState) {
case SELECTED:
      FontUtils.removeUnderline(mainButton);
    FontUtils.removeUnderline(additionalText);
  mainButton.setForeground(props.getSelectionColor());
additionalText.setForeground(props.getSelectionColor());
this.setBackgroundPainter(props.getSelectedPainter());
removeButton.setIcon(removeSelectedIcon);
break;
case BACKGROUND:
FontUtils.underline(mainButton);
FontUtils.underline(additionalText);
mainButton.setForeground(props.getNormalColor());
additionalText.setForeground(props.getNormalColor());
this.setBackgroundPainter(props.getNormalPainter());
removeButton.setIcon(removeBackgroundIcon);
break;
case ROLLOVER:
setBackgroundPainter(props.getHighlightPainter());
removeButton.setIcon(removeSelectedIcon);
break;
}
}
}","private void changeState(TabState tabState){
  if (currentState != tabState) {
    this.currentState=tabState;
switch (tabState) {
case SELECTED:
      FontUtils.removeUnderline(mainButton);
    FontUtils.removeUnderline(additionalText);
  mainButton.setForeground(props.getSelectionColor());
additionalText.setForeground(props.getSelectionColor());
this.setBackgroundPainter(props.getSelectedPainter());
removeButton.setIcon(removeSelectedIcon);
break;
case BACKGROUND:
underline();
mainButton.setForeground(props.getNormalColor());
additionalText.setForeground(props.getNormalColor());
this.setBackgroundPainter(props.getNormalPainter());
removeButton.setIcon(removeBackgroundIcon);
break;
case ROLLOVER:
setBackgroundPainter(props.getHighlightPainter());
removeButton.setIcon(removeSelectedIcon);
break;
}
}
}",0.9541939321832242
4048,"public void listChanged(ListEvent event){
  EventList list=event.getSourceList();
  VisualSearchResult vsr=(VisualSearchResult)list.get(list.size() - 1);
  String extension=vsr.getFileExtension();
  MediaType mediaType=MediaType.getMediaTypeForExtension(extension);
  String schema=mediaType == null ? ""String_Node_Str"" : mediaType.toString();
  String title=schemaToTitleMap.get(schema);
  if (!isAll) {
    if (title.endsWith(""String_Node_Str"")) {
      title=title.substring(0,title.length() - 1);
    }
    title+=""String_Node_Str"";
  }
  FancyTab tab=getTab(title);
  if (tab == null) {
    System.err.println(""String_Node_Str"" + title + '""');
  }
 else {
    tab.setVisible(true);
  }
}","public void listChanged(ListEvent event){
  EventList list=event.getSourceList();
  VisualSearchResult vsr=(VisualSearchResult)list.get(list.size() - 1);
  String extension=vsr.getFileExtension();
  MediaType mediaType=MediaType.getMediaTypeForExtension(extension);
  String schema=mediaType == null ? ""String_Node_Str"" : mediaType.toString();
  String title=schemaToTitleMap.get(schema);
  if (!isAll) {
    if (title.endsWith(""String_Node_Str"")) {
      title=title.substring(0,title.length() - 1);
    }
    title+=""String_Node_Str"";
  }
  FancyTab tab=getTab(title);
  if (tab == null) {
    System.err.println(""String_Node_Str"" + title + '""');
  }
 else {
    tab.underline();
    tab.setVisible(true);
  }
}",0.9850533807829182
4049,"private void configureList(final EventList<VisualSearchResult> eventList){
  resultsList=new ConfigurableTable<VisualSearchResult>(false);
  resultsList.setEventList(eventList);
  ListViewTableFormat tableFormat=new ListViewTableFormat();
  resultsList.setTableFormat(tableFormat);
  ListViewTableCellEditor renderer=new ListViewTableCellEditor(actionRenderer);
  resultsList.setDefaultRenderer(VisualSearchResult.class,renderer);
  ListViewTableCellEditor editor=new ListViewTableCellEditor(actionEditor);
  resultsList.setDefaultEditor(VisualSearchResult.class,editor);
  int columnIndex=0;
  resultsList.setColumnWidth(columnIndex,tableFormat.getInitialColumnWidth(columnIndex));
  resultsList.setRowHeight(ListViewTableCellEditor.HEIGHT);
  resultsList.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      if (e.getButton() == 3) {
        int row=resultsList.rowAtPoint(e.getPoint());
        VisualSearchResult vsr=eventList.get(row);
        JComponent component=(JComponent)e.getSource();
        Window window=(Window)component.getTopLevelAncestor();
        SearchResultMenu menu=new SearchResultMenu(window,vsr);
        menu.show(component,e.getX(),e.getY());
      }
    }
  }
);
}","private void configureList(final EventList<VisualSearchResult> eventList){
  resultsList=new ConfigurableTable<VisualSearchResult>(false){
  }
;
  resultsList.setEventList(eventList);
  ListViewTableFormat tableFormat=new ListViewTableFormat();
  resultsList.setTableFormat(tableFormat);
  ListViewTableCellEditor renderer=new ListViewTableCellEditor(actionRenderer);
  resultsList.setDefaultRenderer(VisualSearchResult.class,renderer);
  ListViewTableCellEditor editor=new ListViewTableCellEditor(actionEditor);
  resultsList.setDefaultEditor(VisualSearchResult.class,editor);
  int columnIndex=0;
  resultsList.setColumnWidth(columnIndex,tableFormat.getInitialColumnWidth(columnIndex));
  resultsList.setRowHeight(ListViewTableCellEditor.HEIGHT);
  resultsList.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      if (e.getButton() == 3) {
        int row=resultsList.rowAtPoint(e.getPoint());
        VisualSearchResult vsr=eventList.get(row);
        JComponent component=(JComponent)e.getSource();
        Window window=(Window)component.getTopLevelAncestor();
        SearchResultMenu menu=new SearchResultMenu(window,vsr);
        menu.show(component,e.getX(),e.getY());
      }
    }
  }
);
}",0.9975903614457832
4050,"@EventSubscriber public void handleAddConversation(ConversationStartedEvent event){
  Friend friend=event.getFriend();
  LOG.debugf(""String_Node_Str"",friend.getName());
  ConversationPane chatPane=chats.get(friend.getName());
  if (chatPane == null) {
    chatPane=conversationFactory.create(event.getWriter(),friend);
    chats.put(friend.getName(),chatPane);
  }
  if (conversationPanel.getComponent(0) != chatPane && event.isLocallyInitiated()) {
    setConversationPanel(chatPane);
  }
  chatPane.handleDisplay();
  event.unlock();
  LOG.debug(""String_Node_Str"");
}","@EventSubscriber public void handleAddConversation(ConversationStartedEvent event){
  Friend friend=event.getFriend();
  LOG.debugf(""String_Node_Str"",friend.getName());
  ConversationPane chatPane=chats.get(friend.getID());
  if (chatPane == null) {
    chatPane=conversationFactory.create(event.getWriter(),friend);
    chats.put(friend.getID(),chatPane);
  }
  if (conversationPanel.getComponent(0) != chatPane && event.isLocallyInitiated()) {
    setConversationPanel(chatPane);
  }
  chatPane.handleDisplay();
  event.unlock();
  LOG.debug(""String_Node_Str"");
}",0.9894179894179894
4051,"@EventSubscriber public void handleCloseChat(CloseChatEvent event){
  closeChat(event.getFriend().getName());
  setConversationPanel(new JPanel());
}","@EventSubscriber public void handleCloseChat(CloseChatEvent event){
  closeChat(event.getFriend().getID());
  setConversationPanel(new JPanel());
}",0.9797297297297296
4052,"@Override public void removeSelectedBuddy(){
  Friend selectedFriend=getSelectedFriend();
  if (selectedFriend != null) {
    new RemoveBuddyEvent(selectedFriend).publish();
  }
}","@Override public void removeSelectedBuddy(){
  removeBuddy(getSelectedFriend());
}",0.5670498084291188
4053,"@EventSubscriber public void handlePresenceUpdate(PresenceUpdateEvent event){
  LOG.debugf(""String_Node_Str"",event.getPresence().getJID(),event.getPresence().getType());
  final Presence presence=event.getPresence();
  FriendImpl friend=idToFriendMap.get(presence.getJID());
switch (presence.getType()) {
case available:
    if (friend == null) {
      final FriendImpl newFriend=new FriendImpl(event.getUser(),presence);
      presence.setIncomingChatListener(new IncomingChatListener(){
        public MessageReader incomingChat(        MessageWriter writer){
          LOG.debugf(""String_Node_Str"",presence.getJID());
          MessageWriter writerWrapper=new MessageWriterImpl(myID,newFriend,writer);
          ConversationStartedEvent event=new ConversationStartedEvent(newFriend,writerWrapper,false);
          event.publish();
          event.await();
          return new MessageReaderImpl(newFriend);
        }
      }
);
      friend=newFriend;
      friends.add(friend);
      idToFriendMap.put(presence.getJID(),friend);
    }
  friend.setStatus(presence.getStatus());
friend.setMode(presence.getMode());
break;
case unavailable:
if (friend != null) {
friends.remove(idToFriendMap.remove(presence.getJID()));
}
break;
}
friendsCountUpdater.setFriendsCount(friends.size());
}","@EventSubscriber public void handlePresenceUpdate(PresenceUpdateEvent event){
  LOG.debugf(""String_Node_Str"",event.getPresence().getJID(),event.getPresence().getType());
  final Presence presence=event.getPresence();
  final User user=event.getUser();
  FriendImpl friend=idToFriendMap.get(user.getId());
switch (presence.getType()) {
case available:
    if (friend == null) {
      final FriendImpl newFriend=new FriendImpl(user,presence);
      presence.setIncomingChatListener(new IncomingChatListener(){
        public MessageReader incomingChat(        MessageWriter writer){
          LOG.debugf(""String_Node_Str"",presence.getJID());
          MessageWriter writerWrapper=new MessageWriterImpl(myID,newFriend,writer);
          ConversationStartedEvent event=new ConversationStartedEvent(newFriend,writerWrapper,false);
          event.publish();
          event.await();
          return new MessageReaderImpl(newFriend);
        }
      }
);
      friend=newFriend;
      friends.add(friend);
      idToFriendMap.put(user.getId(),friend);
    }
  friend.setStatus(presence.getStatus());
friend.setMode(presence.getMode());
break;
case unavailable:
if (friend != null) {
friends.remove(idToFriendMap.remove(user.getId()));
}
break;
}
friendsCountUpdater.setFriendsCount(friends.size());
}",0.9523440526927548
4054,"@Inject public TopPanel(IconLibrary icons){
  this.icons=icons;
  setBackground(Color.BLACK);
  setForeground(Color.WHITE);
  setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  friendNameLabel=new JLabel();
  friendNameLabel.setForeground(getForeground());
  add(friendNameLabel);
  friendStatusLabel=new JLabel();
  friendStatusLabel.setForeground(getForeground());
  FontUtils.changeSize(friendStatusLabel,-1.8f);
  add(friendStatusLabel);
  JMenu options=new JMenu(tr(""String_Node_Str""));
  FontUtils.changeSize(options,-3.0f);
  options.setForeground(getForeground());
  options.setBackground(getBackground());
  options.setBorderPainted(false);
  options.add(new AddBuddyOption());
  options.add(new RemoveBuddyOption());
  options.add(new MoreChatOptionsOption());
  options.addSeparator();
  JCheckBoxMenuItem availableItem=new JCheckBoxMenuItem(new AvailableOption());
  JCheckBoxMenuItem awayItem=new JCheckBoxMenuItem(new AwayOption());
  ButtonGroup selectables=new ButtonGroup();
  selectables.add(availableItem);
  selectables.add(awayItem);
  selectables.setSelected(availableItem.getModel(),true);
  options.add(availableItem);
  options.add(awayItem);
  options.addSeparator();
  options.add(new SignoffAction());
  JMenuBar menuBar=new JMenuBar();
  menuBar.add(options);
  add(menuBar);
  JButton closeChat=new JButton(new CloseAction(icons.getCloseChat()));
  closeChat.setBorderPainted(false);
  closeChat.setForeground(getForeground());
  add(closeChat);
  EventAnnotationProcessor.subscribe(this);
}","@Inject public TopPanel(IconLibrary icons){
  this.icons=icons;
  setBackground(Color.BLACK);
  setForeground(Color.WHITE);
  setLayout(new MigLayout(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  friendNameLabel=new JLabel();
  friendNameLabel.setForeground(getForeground());
  add(friendNameLabel);
  friendStatusLabel=new JLabel();
  friendStatusLabel.setForeground(getForeground());
  FontUtils.changeSize(friendStatusLabel,-1.8f);
  add(friendStatusLabel);
  JMenu options=new JMenu(tr(""String_Node_Str""));
  FontUtils.changeSize(options,-3.0f);
  options.setForeground(getForeground());
  options.setBackground(getBackground());
  options.setBorderPainted(false);
  options.add(new AddBuddyOption());
  options.add(new RemoveBuddyOption());
  options.add(new MoreChatOptionsOption());
  options.addSeparator();
  JCheckBoxMenuItem availableItem=new JCheckBoxMenuItem(new AvailableOption());
  JCheckBoxMenuItem awayItem=new JCheckBoxMenuItem(new AwayOption());
  ButtonGroup selectables=new ButtonGroup();
  selectables.add(availableItem);
  selectables.add(awayItem);
  selectables.setSelected(availableItem.getModel(),true);
  options.add(availableItem);
  options.add(awayItem);
  options.addSeparator();
  options.add(new SignoffAction());
  JMenuBar menuBar=new JMenuBar();
  menuBar.setForeground(getForeground());
  menuBar.setBackground(getBackground());
  menuBar.setBorderPainted(false);
  menuBar.add(options);
  add(menuBar);
  JButton closeChat=new JButton(new CloseAction(icons.getCloseChat()));
  closeChat.setBorderPainted(false);
  closeChat.setForeground(getForeground());
  closeChat.setBackground(getBackground());
  add(closeChat);
  EventAnnotationProcessor.subscribe(this);
}",0.9476904252064852
4055,"/** 
 * This method splits the given Bucket into two new Buckets. There are a few conditions in which cases we do split and in which cases we don't.
 */
protected synchronized boolean split(Bucket bucket){
  boolean containsLocalNode=bucket.contains(getLocalNode().getNodeID());
  if (containsLocalNode || bucket.isInSmallestSubtree() || !bucket.isTooDeep()) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + bucket);
    }
    List<Bucket> buckets=bucket.split();
    assert(buckets.size() == 2);
    Bucket left=buckets.get(0);
    Bucket right=buckets.get(1);
    Bucket oldLeft=bucketTrie.put(left.getBucketID(),left);
    assert(oldLeft == bucket);
    Bucket oldRight=bucketTrie.put(right.getBucketID(),right);
    assert(oldRight == null);
    fireSplitBucket(bucket,left,right);
    return true;
  }
  return false;
}","/** 
 * This method splits the given Bucket into two new Buckets. There are a few conditions in which cases we do split and in which cases we don't.
 */
protected synchronized boolean split(Bucket bucket){
  if (canSplit(bucket)) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + bucket);
    }
    List<Bucket> buckets=bucket.split();
    assert(buckets.size() == 2);
    Bucket left=buckets.get(0);
    Bucket right=buckets.get(1);
    Bucket oldLeft=bucketTrie.put(left.getBucketID(),left);
    assert(oldLeft == bucket);
    Bucket oldRight=bucketTrie.put(right.getBucketID(),right);
    assert(oldRight == null);
    fireSplitBucket(bucket,left,right);
    return true;
  }
  return false;
}",0.8955797565663036
4056,"public synchronized void add(Contact node){
  if (localNode.equals(node)) {
    String msg=""String_Node_Str"" + node;
    if (LOG.isErrorEnabled()) {
      LOG.error(msg);
    }
    ErrorService.error(new IllegalArgumentException(msg));
    return;
  }
  if (node.isFirewalled()) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(node + ""String_Node_Str"");
    }
    return;
  }
  if (!ContactUtils.isSameAddressSpace(localNode,node)) {
    if (LOG.isErrorEnabled()) {
      LOG.error(node + ""String_Node_Str"" + localNode);
    }
    return;
  }
  consecutiveFailures=0;
  KUID nodeId=node.getNodeID();
  Bucket bucket=bucketTrie.select(nodeId);
  Contact existing=bucket.get(nodeId);
  if (existing != null) {
    updateContactInBucket(bucket,existing,node);
  }
 else   if (!bucket.isActiveFull()) {
    if (isOkayToAdd(bucket,node)) {
      addContactToBucket(bucket,node);
    }
 else {
      addContactToBucketCache(bucket,node);
    }
  }
 else   if (split(bucket)) {
    add(node);
  }
 else {
    replaceContactInBucket(bucket,node);
  }
}","public synchronized void add(Contact node){
  if (localNode.equals(node)) {
    String msg=""String_Node_Str"" + node;
    if (LOG.isErrorEnabled()) {
      LOG.error(msg);
    }
    ErrorService.error(new IllegalArgumentException(msg));
    return;
  }
  if (node.isFirewalled()) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(node + ""String_Node_Str"");
    }
    return;
  }
  if (!ContactUtils.isSameAddressSpace(localNode,node)) {
    if (LOG.isErrorEnabled()) {
      LOG.error(node + ""String_Node_Str"" + localNode);
    }
    return;
  }
  consecutiveFailures=0;
  KUID nodeId=node.getNodeID();
  Bucket bucket=bucketTrie.select(nodeId);
  Contact existing=bucket.get(nodeId);
  if (existing != null) {
    updateContactInBucket(bucket,existing,node);
  }
 else   if (!bucket.isActiveFull()) {
    if (isOkayToAdd(bucket,node)) {
      addContactToBucket(bucket,node);
    }
 else {
      if (!canSplit(bucket)) {
        addContactToBucketCache(bucket,node);
      }
    }
  }
 else   if (split(bucket)) {
    add(node);
  }
 else {
    replaceContactInBucket(bucket,node);
  }
}",0.9807782466010314
4057,"public void testNetworkClass(){
  final int k=KademliaSettings.REPLICATION_PARAMETER.getValue();
  RouteTableSettings.MAX_CACHE_SIZE.setValue(k);
  RouteTableSettings.MAX_CONTACTS_PER_NETWORK_CLASS_RATIO.setValue(1.0f);
  RouteTable routeTable1=new RouteTableImpl();
  for (int i=0; i < (k - 1); i++) {
    Contact node=ContactFactory.createUnknownContact(Vendor.UNKNOWN,Version.ZERO,KUID.createRandomID(),new InetSocketAddress(""String_Node_Str"" + i,1024 + i));
    routeTable1.add(node);
  }
  assertEquals(k,routeTable1.size());
  assertEquals(k,routeTable1.getActiveContacts().size());
  assertEquals(0,routeTable1.getCachedContacts().size());
  RouteTableSettings.MAX_CONTACTS_PER_NETWORK_CLASS_RATIO.setValue(0.0f);
  RouteTable routeTable2=new RouteTableImpl();
  for (int i=0; i < (k - 1); i++) {
    Contact node=ContactFactory.createUnknownContact(Vendor.UNKNOWN,Version.ZERO,KUID.createRandomID(),new InetSocketAddress(""String_Node_Str"" + i,1024 + i));
    routeTable2.add(node);
  }
  assertEquals(k,routeTable2.size());
  assertEquals(2,routeTable2.getActiveContacts().size());
  assertEquals(18,routeTable2.getCachedContacts().size());
  RouteTableSettings.MAX_CONTACTS_PER_NETWORK_CLASS_RATIO.setValue(0.5f);
  RouteTable routeTable3=new RouteTableImpl();
  for (int i=0; i < (k - 1); i++) {
    Contact node=ContactFactory.createUnknownContact(Vendor.UNKNOWN,Version.ZERO,KUID.createRandomID(),new InetSocketAddress(""String_Node_Str"" + i,1024 + i));
    routeTable3.add(node);
  }
  assertEquals(k,routeTable3.size());
  assertEquals(k / 2 + 1,routeTable3.getActiveContacts().size());
  assertEquals(k / 2 - 1,routeTable3.getCachedContacts().size());
  Contact node=ContactFactory.createLiveContact(new InetSocketAddress(""String_Node_Str"",2000),Vendor.UNKNOWN,Version.ZERO,KUID.createRandomID(),new InetSocketAddress(""String_Node_Str"",2000),0,Contact.DEFAULT_FLAG);
  routeTable3.add(node);
  assertEquals(k + 1,routeTable3.size());
  assertEquals(k / 2 + 2,routeTable3.getActiveContacts().size());
  assertEquals(k / 2 - 1,routeTable3.getCachedContacts().size());
  Bucket bucket=routeTable3.getBucket(node.getNodeID());
  assertNotNull(bucket);
  ClassfulNetworkCounter counter=bucket.getClassfulNetworkCounter();
  int count=counter.get(node);
  assertEquals(1,count);
  boolean removed=bucket.remove(node.getNodeID());
  assertTrue(removed);
  count=counter.get(node);
  assertEquals(0,count);
}","public void testNetworkClass(){
  final int k=KademliaSettings.REPLICATION_PARAMETER.getValue();
  RouteTableSettings.MAX_CACHE_SIZE.setValue(k);
  RouteTableSettings.MAX_CONTACTS_PER_NETWORK_CLASS_RATIO.setValue(1.0f);
  RouteTable routeTable1=new RouteTableImpl();
  for (int i=0; i < (k - 1); i++) {
    Contact node=ContactFactory.createUnknownContact(Vendor.UNKNOWN,Version.ZERO,KUID.createRandomID(),new InetSocketAddress(""String_Node_Str"" + i,1024 + i));
    routeTable1.add(node);
  }
  assertEquals(k,routeTable1.size());
  assertEquals(k,routeTable1.getActiveContacts().size());
  assertEquals(0,routeTable1.getCachedContacts().size());
  RouteTableSettings.MAX_CONTACTS_PER_NETWORK_CLASS_RATIO.setValue(0.0f);
  RouteTable routeTable2=new RouteTableImpl();
  for (int i=0; i < (k - 1); i++) {
    Contact node=ContactFactory.createUnknownContact(Vendor.UNKNOWN,Version.ZERO,KUID.createRandomID(),new InetSocketAddress(""String_Node_Str"" + i,1024 + i));
    routeTable2.add(node);
  }
  assertEquals(2,routeTable2.size());
  assertEquals(2,routeTable2.getActiveContacts().size());
  assertEquals(0,routeTable2.getCachedContacts().size());
  RouteTableSettings.MAX_CONTACTS_PER_NETWORK_CLASS_RATIO.setValue(0.5f);
  RouteTable routeTable3=new RouteTableImpl();
  for (int i=0; i < (k - 1); i++) {
    Contact node=ContactFactory.createUnknownContact(Vendor.UNKNOWN,Version.ZERO,KUID.createRandomID(),new InetSocketAddress(""String_Node_Str"" + i,1024 + i));
    routeTable3.add(node);
  }
  assertEquals(k / 2 + 1,routeTable3.size());
  assertEquals(k / 2 + 1,routeTable3.getActiveContacts().size());
  assertEquals(0,routeTable3.getCachedContacts().size());
  Contact node=ContactFactory.createLiveContact(new InetSocketAddress(""String_Node_Str"",2000),Vendor.UNKNOWN,Version.ZERO,KUID.createRandomID(),new InetSocketAddress(""String_Node_Str"",2000),0,Contact.DEFAULT_FLAG);
  routeTable3.add(node);
  assertEquals(k / 2 + 1 + 1,routeTable3.size());
  assertEquals(k / 2 + 1 + 1,routeTable3.getActiveContacts().size());
  assertEquals(0,routeTable3.getCachedContacts().size());
  Bucket bucket=routeTable3.getBucket(node.getNodeID());
  assertNotNull(bucket);
  ClassfulNetworkCounter counter=bucket.getClassfulNetworkCounter();
  int count=counter.get(node);
  assertEquals(1,count);
  boolean removed=bucket.remove(node.getNodeID());
  assertTrue(removed);
  count=counter.get(node);
  assertEquals(0,count);
}",0.9857172428068722
4058,"public void testUpdateUptimeHistory(){
  RefreshTimer refreshTimer=new RefreshTimer();
  StringArraySetting uptimeHistory=ApplicationSettings.LAST_N_UPTIMES;
  assertEquals(new String[0],uptimeHistory.getValue());
  for (int i=0; i < 5; i++) {
    refreshTimer.updateUptimeHistory(i,10,10);
    assertEquals(new String[0],uptimeHistory.getValue());
  }
  refreshTimer.updateUptimeHistory(10,10,2);
  assertEquals(new String[]{""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(20,10,2);
  assertEquals(new String[]{""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(10,10,2);
  assertEquals(new String[]{""String_Node_Str"",""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(10,10,2);
  assertEquals(new String[]{""String_Node_Str"",""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(30,10,2);
  assertEquals(new String[]{""String_Node_Str"",""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(10,10,1);
  assertEquals(new String[]{""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(20,10,1);
  assertEquals(new String[]{""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(30,10,2);
  assertEquals(new String[]{""String_Node_Str""},uptimeHistory.getValue());
}","public void testUpdateUptimeHistory(){
  RefreshTimer refreshTimer=new RefreshTimer();
  StringArraySetting uptimeHistory=ApplicationSettings.LAST_N_UPTIMES;
  assertEquals(new String[0],uptimeHistory.getValue());
  for (int i=0; i < 5; i++) {
    refreshTimer.updateUptimeHistory(i,10,10);
    assertEquals(new String[0],uptimeHistory.getValue());
  }
  refreshTimer.updateUptimeHistory(10,10,2);
  assertEquals(new String[]{""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(20,10,2);
  assertEquals(new String[]{""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer=new RefreshTimer();
  refreshTimer.updateUptimeHistory(10,10,2);
  assertEquals(new String[]{""String_Node_Str"",""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer=new RefreshTimer();
  refreshTimer.updateUptimeHistory(10,10,2);
  assertEquals(new String[]{""String_Node_Str"",""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(30,10,2);
  assertEquals(new String[]{""String_Node_Str"",""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer=new RefreshTimer();
  refreshTimer.updateUptimeHistory(10,10,1);
  assertEquals(new String[]{""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(20,10,1);
  assertEquals(new String[]{""String_Node_Str""},uptimeHistory.getValue());
  refreshTimer.updateUptimeHistory(30,10,2);
  assertEquals(new String[]{""String_Node_Str""},uptimeHistory.getValue());
}",0.9628318584070796
4059,"JLabel createAdditionalText(){
  final JLabel label=new JLabel();
  label.setVisible(false);
  if (tabActions.getMoreTextAction() != null) {
    label.setOpaque(false);
    label.setFont(props.getTextFont());
    String name=(String)tabActions.getMoreTextAction().getValue(Action.NAME);
    if (name != null) {
      label.setText(""String_Node_Str"" + name + ""String_Node_Str"");
      label.setVisible(true);
    }
    tabActions.getMoreTextAction().addPropertyChangeListener(new PropertyChangeListener(){
      @Override public void propertyChange(      PropertyChangeEvent evt){
        if (evt.getPropertyName().equals(Action.NAME)) {
          label.setText(""String_Node_Str"" + (String)evt.getNewValue() + ""String_Node_Str"");
          label.setVisible(true);
        }
      }
    }
);
  }
  return label;
}","JLabel createAdditionalText(){
  final JLabel label=new JLabel();
  label.setVisible(false);
  if (tabActions.getMoreTextAction() != null) {
    label.setOpaque(false);
    label.setFont(mainButton.getFont());
    String name=(String)tabActions.getMoreTextAction().getValue(Action.NAME);
    if (name != null) {
      label.setText(""String_Node_Str"" + name + ""String_Node_Str"");
      label.setVisible(true);
    }
    tabActions.getMoreTextAction().addPropertyChangeListener(new PropertyChangeListener(){
      @Override public void propertyChange(      PropertyChangeEvent evt){
        if (evt.getPropertyName().equals(Action.NAME)) {
          label.setText(""String_Node_Str"" + (String)evt.getNewValue() + ""String_Node_Str"");
          label.setVisible(true);
        }
      }
    }
);
  }
  return label;
}",0.984596426370918
4060,"SearchTabItems(SearchCategory category,SearchTabListener listener){
  this.listener=listener;
  this.searchTabs=new ArrayList<SearchTabAction>();
  searchTabs.add(new SearchTabAction(""String_Node_Str"",SearchCategory.ALL));
  searchTabs.add(new SearchTabAction(""String_Node_Str"",SearchCategory.AUDIO));
  searchTabs.add(new SearchTabAction(""String_Node_Str"",SearchCategory.VIDEO));
  searchTabs.add(new SearchTabAction(""String_Node_Str"",SearchCategory.IMAGES));
  searchTabs.add(new SearchTabAction(""String_Node_Str"",SearchCategory.DOCUMENTS));
  for (  SearchTabAction action : searchTabs) {
    if (category == action.getCategory()) {
      action.putValue(Action.SELECTED_KEY,true);
      listener.categorySelected(category);
    }
 else     if (category != SearchCategory.ALL) {
      action.setEnabled(false);
    }
  }
  setLayout(new GridBagLayout());
  setBackground(Color.LIGHT_GRAY);
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.gridwidth=GridBagConstraints.RELATIVE;
  FancyTabList ttp=new FancyTabList(TabActionMap.createMapForMainActions(searchTabs));
  ttp.setFlowedLayout(new Insets(0,2,0,5));
  ttp.setHighlightPainter(new RectanglePainter<JXButton>(2,2,0,2,5,5,true,Color.WHITE,0f,Color.WHITE));
  add(ttp,gbc);
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  gbc.weightx=1;
  add(Box.createGlue(),gbc);
}","SearchTabItems(SearchCategory category,SearchTabListener listener){
  this.listener=listener;
  this.searchTabs=new ArrayList<TabActionMap>();
  searchTabs.add(newTabActionMap(new SearchTabAction(""String_Node_Str"",SearchCategory.ALL)));
  searchTabs.add(newTabActionMap(new SearchTabAction(""String_Node_Str"",SearchCategory.AUDIO)));
  searchTabs.add(newTabActionMap(new SearchTabAction(""String_Node_Str"",SearchCategory.VIDEO)));
  searchTabs.add(newTabActionMap(new SearchTabAction(""String_Node_Str"",SearchCategory.IMAGES)));
  searchTabs.add(newTabActionMap(new SearchTabAction(""String_Node_Str"",SearchCategory.DOCUMENTS)));
  for (  TabActionMap map : searchTabs) {
    SearchTabAction action=(SearchTabAction)map.getMainAction();
    if (category == action.getCategory()) {
      action.putValue(Action.SELECTED_KEY,true);
      listener.categorySelected(category);
    }
 else     if (category != SearchCategory.ALL) {
      action.setEnabled(false);
    }
  }
  setLayout(new GridBagLayout());
  setBackground(Color.LIGHT_GRAY);
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.gridwidth=GridBagConstraints.RELATIVE;
  FancyTabList ttp=new FancyTabList(searchTabs);
  ttp.setFlowedLayout(new Insets(0,2,0,5));
  ttp.setHighlightPainter(new RectanglePainter<JXButton>(2,2,0,2,5,5,true,Color.WHITE,0f,Color.WHITE));
  add(ttp,gbc);
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  gbc.weightx=1;
  add(Box.createGlue(),gbc);
}",0.8494041170097508
4061,"private void updateStriping(){
  int length=0;
  for (  DownloadTable table : tables) {
    if (table.getRowCount() > 0 && table.isVisible()) {
      if (length % 2 == 0) {
        table.setHighlighters(evenTableHighlighter);
      }
 else {
        table.setHighlighters(oddTableHighlighter);
      }
      table.addMenuRowHighlighter();
      length+=table.getRowCount();
    }
  }
}","private void updateStriping(){
  int length=0;
  for (  DownloadTable table : tables) {
    if (table.getRowCount() > 0 && table.isVisible()) {
      if (length % 2 == 0) {
        table.setHighlighters(evenTableHighlighter);
      }
 else {
        table.setHighlighters(oddTableHighlighter);
      }
      length+=table.getRowCount();
    }
  }
}",0.9495225102319236
4062,"@Override public Component prepareEditor(TableCellEditor editor,int row,int column){
  Component comp=super.prepareEditor(editor,row,column);
  ComponentAdapter adapter=getComponentAdapter(row,column);
  if (compoundHighlighter != null) {
    comp=compoundHighlighter.highlight(comp,adapter);
  }
  return comp;
}","@Override public Component prepareEditor(TableCellEditor editor,int row,int column){
  Component comp=super.prepareEditor(editor,row,column);
  ComponentAdapter adapter=getComponentAdapter(row,column);
  if (compoundHighlighter != null) {
    comp=compoundHighlighter.highlight(comp,adapter);
  }
  adjustMenuShowingColor(comp,(DownloadItem)getValueAt(row,column));
  return comp;
}",0.9007194244604316
4063,"public DownloadTable(EventList<DownloadItem> downloadItems){
  super(new DownloadTableModel(downloadItems));
  GuiUtils.assignResources(this);
  setRolloverEnabled(false);
  setFocusable(false);
  setEditable(true);
  setShowGrid(false,false);
  setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  setHighlighters(new ColorHighlighter(HighlightPredicate.ODD,oddColor,oddForeground,oddColor,oddForeground),new ColorHighlighter(HighlightPredicate.EVEN,evenColor,evenForeground,evenColor,evenForeground));
  addMenuRowHighlighter();
  editor=new DownloadRendererEditor();
  editor.initializeEditor(downloadItems);
  DownloadRendererEditor renderer=new DownloadRendererEditor();
  setDefaultEditor(DownloadItem.class,editor);
  setDefaultRenderer(DownloadItem.class,renderer);
  setRowHeight(renderer.getPreferredSize().height);
  addMouseMotionListener(new MouseMotionAdapter(){
    @Override public void mouseMoved(    MouseEvent e){
      int col=columnAtPoint(e.getPoint());
      int row=rowAtPoint(e.getPoint());
      editCellAt(row,col);
    }
  }
);
  addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() == 2) {
        int col=columnAtPoint(e.getPoint());
        int row=rowAtPoint(e.getPoint());
        DownloadItem item=(DownloadItem)getValueAt(row,col);
        throw new RuntimeException(""String_Node_Str"" + item.getTitle() + ""String_Node_Str"");
      }
    }
    @Override public void mouseExited(    MouseEvent e){
      TableCellEditor editor=getCellEditor();
      Component component=e.getComponent();
      if (editor != null && component != editor) {
        if (component == null || component.getComponentAt(e.getPoint()) != editor) {
          editor.cancelCellEditing();
        }
      }
    }
    @Override public void mouseReleased(    MouseEvent e){
      maybeShowPopup(e);
    }
    @Override public void mousePressed(    MouseEvent e){
      maybeShowPopup(e);
    }
    private void maybeShowPopup(    MouseEvent e){
      if (e.isPopupTrigger()) {
        editor.showPopupMenu(e.getComponent(),e.getX(),e.getY());
        int col=columnAtPoint(e.getPoint());
        int row=rowAtPoint(e.getPoint());
        prepareEditor(editor,row,col);
        repaint();
      }
    }
  }
);
}","public DownloadTable(EventList<DownloadItem> downloadItems){
  super(new DownloadTableModel(downloadItems));
  GuiUtils.assignResources(this);
  setRolloverEnabled(false);
  setFocusable(false);
  setEditable(true);
  setShowGrid(false,false);
  setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  setHighlighters(new ColorHighlighter(HighlightPredicate.ODD,oddColor,oddForeground,oddColor,oddForeground),new ColorHighlighter(HighlightPredicate.EVEN,evenColor,evenForeground,evenColor,evenForeground));
  editor=new DownloadRendererEditor();
  editor.initializeEditor(downloadItems);
  DownloadRendererEditor renderer=new DownloadRendererEditor();
  setDefaultEditor(DownloadItem.class,editor);
  setDefaultRenderer(DownloadItem.class,renderer);
  setRowHeight(renderer.getPreferredSize().height);
  addMouseMotionListener(new MouseMotionAdapter(){
    @Override public void mouseMoved(    MouseEvent e){
      int col=columnAtPoint(e.getPoint());
      int row=rowAtPoint(e.getPoint());
      editCellAt(row,col);
    }
  }
);
  addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() == 2) {
        int col=columnAtPoint(e.getPoint());
        int row=rowAtPoint(e.getPoint());
        DownloadItem item=(DownloadItem)getValueAt(row,col);
        throw new RuntimeException(""String_Node_Str"" + item.getTitle() + ""String_Node_Str"");
      }
    }
    @Override public void mouseExited(    MouseEvent e){
      TableCellEditor editor=getCellEditor();
      Component component=e.getComponent();
      if (editor != null && component != editor) {
        if (component == null || component.getComponentAt(e.getPoint()) != editor) {
          editor.cancelCellEditing();
        }
      }
    }
    @Override public void mouseReleased(    MouseEvent e){
      maybeShowPopup(e);
    }
    @Override public void mousePressed(    MouseEvent e){
      maybeShowPopup(e);
    }
    private void maybeShowPopup(    MouseEvent e){
      if (e.isPopupTrigger()) {
        editor.showPopupMenu(e.getComponent(),e.getX(),e.getY());
        int col=columnAtPoint(e.getPoint());
        int row=rowAtPoint(e.getPoint());
        prepareEditor(editor,row,col);
        repaint();
      }
    }
  }
);
}",0.9940646295889206
4064,"private void update(){
  downloadItems.getReadWriteLock().readLock().lock();
  try {
    for (    DownloadItem item : downloadItems) {
      if (item instanceof CoreDownloadItem)       ((CoreDownloadItem)item).fireDataChanged();
    }
  }
  finally {
    downloadItems.getReadWriteLock().readLock().unlock();
  }
}","private void update(){
}",0.1420118343195266
4065,"@Override public void handleEvent(DownloadStatusEvent event){
  support.firePropertyChange(""String_Node_Str"",null,getState());
}","@Override public void handleEvent(DownloadStatusEvent event){
  fireDataChanged();
}",0.7547169811320755
4066,"public CoreDownloadItem(Downloader downloader,QueueTimeCalculator queueTimeCalculator){
  this.downloader=downloader;
  this.queueTimeCalculator=queueTimeCalculator;
  downloader.addListener(new EventListener<DownloadStatusEvent>(){
    @Override public void handleEvent(    DownloadStatusEvent event){
      support.firePropertyChange(""String_Node_Str"",null,getState());
    }
  }
);
}","public CoreDownloadItem(Downloader downloader,QueueTimeCalculator queueTimeCalculator){
  this.downloader=downloader;
  this.queueTimeCalculator=queueTimeCalculator;
  downloader.addListener(new EventListener<DownloadStatusEvent>(){
    @Override public void handleEvent(    DownloadStatusEvent event){
      fireDataChanged();
    }
  }
);
}",0.9230769230769232
4067,"private void update(){
  downloadItems.getReadWriteLock().writeLock().lock();
  try {
    if (downloadItems.size() > 0) {
      downloadItems.set(0,downloadItems.get(0));
    }
  }
  finally {
    downloadItems.getReadWriteLock().writeLock().unlock();
  }
}","private void update(){
  downloadItems.getReadWriteLock().readLock().lock();
  try {
    for (    DownloadItem item : downloadItems) {
      if (item instanceof CoreDownloadItem)       ((CoreDownloadItem)item).fireDataChanged();
    }
  }
  finally {
    downloadItems.getReadWriteLock().readLock().unlock();
  }
}",0.4588441330998248
4068,"public long getRemainingQueueTime(DownloadItem queueItem){
  if (queueItem.getState() != DownloadState.LOCAL_QUEUED) {
    return DownloadItem.UNKNOWN_TIME;
  }
  int priority=queueItem.getLocalQueuePriority();
  int index=priority - 1;
  downloadingList.getReadWriteLock().readLock().lock();
  try {
    if (index >= downloadingList.size()) {
      return DownloadItem.UNKNOWN_TIME;
    }
    return downloadingList.get(index).getRemainingDownloadTime();
  }
  finally {
    downloadingList.getReadWriteLock().readLock().unlock();
  }
}","public long getRemainingQueueTime(DownloadItem queueItem){
  if (queueItem.getState() != DownloadState.LOCAL_QUEUED) {
    return DownloadItem.UNKNOWN_TIME;
  }
  int priority=queueItem.getLocalQueuePriority();
  int index=priority - 1;
  downloadingList.getReadWriteLock().readLock().lock();
  try {
    if (index >= downloadingList.size()) {
      return DownloadItem.UNKNOWN_TIME;
    }
    System.out.println(downloadingList.get(index).getRemainingDownloadTime());
    return downloadingList.get(index).getRemainingDownloadTime();
  }
  finally {
    downloadingList.getReadWriteLock().readLock().unlock();
  }
}",0.8967909800520382
4069,"public void run(){
  while (isRunning() && getCurrentSize() < getTotalSize()) {
    setCurrentSize(getCurrentSize() + 5);
    try {
      sleep(500);
    }
 catch (    InterruptedException e) {
    }
  }
}","public void run(){
  while (isRunning() && getCurrentSize() < getTotalSize()) {
    setCurrentSize(getCurrentSize() + 5);
    setRemainingQueueTime(getRemainingQueueTime() - 1);
    try {
      sleep(500);
    }
 catch (    InterruptedException e) {
    }
  }
}",0.8798283261802575
4070,"@Override public long getRemainingQueueTime(){
  return 0;
}","@Override public long getRemainingQueueTime(){
  System.out.println(""String_Node_Str"" + remainingQueueTime);
  return remainingQueueTime;
}",0.592964824120603
4071,"public long getRemainingDownloadTime(){
  return 4123;
}","public long getRemainingDownloadTime(){
  return (long)((getTotalSize() - getCurrentSize()) / getDownloadSpeed());
}",0.6046511627906976
4072,"private synchronized void start(){
  new Thread(){
    public void run(){
      while (isRunning() && getCurrentSize() < getTotalSize()) {
        setCurrentSize(getCurrentSize() + 5);
        try {
          sleep(500);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
.start();
}","private synchronized void start(){
  new Thread(){
    public void run(){
      while (isRunning() && getCurrentSize() < getTotalSize()) {
        setCurrentSize(getCurrentSize() + 5);
        setRemainingQueueTime(getRemainingQueueTime() - 1);
        try {
          sleep(500);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
.start();
}",0.912280701754386
4073,"public void pauseAll(){
  commonBaseList.getReadWriteLock().writeLock().lock();
  try {
    for (    DownloadItem item : commonBaseList) {
      if (item.getState().isPausable()) {
        item.pause();
      }
    }
  }
  finally {
    commonBaseList.getReadWriteLock().writeLock().unlock();
  }
}","public void pauseAll(){
  commonBaseList.getReadWriteLock().readLock().lock();
  try {
    for (    DownloadItem item : commonBaseList) {
      if (item.getState().isPausable()) {
        item.pause();
      }
    }
  }
  finally {
    commonBaseList.getReadWriteLock().readLock().unlock();
  }
}",0.3333333333333333
4074,"public void resumeAll(){
  commonBaseList.getReadWriteLock().writeLock().lock();
  try {
    for (    DownloadItem item : commonBaseList) {
      if (item.getState().isResumable()) {
        item.resume();
      }
    }
  }
  finally {
    commonBaseList.getReadWriteLock().writeLock().unlock();
  }
}","public void resumeAll(){
  commonBaseList.getReadWriteLock().readLock().lock();
  try {
    for (    DownloadItem item : commonBaseList) {
      if (item.getState().isResumable()) {
        item.resume();
      }
    }
  }
  finally {
    commonBaseList.getReadWriteLock().readLock().unlock();
  }
}",0.34
4075,"/** 
 * Binds editor to downloadItems so that the editor automatically updates when downloadItems changes and popup menus work.  This is required for Editors
 */
public void initializeEditor(EventList<DownloadItem> downloadItems){
  this.downloadItems=downloadItems;
  downloadItems.addListEventListener(new ListEventListener<DownloadItem>(){
    @Override public void listChanged(    ListEvent<DownloadItem> listChanges){
      SwingUtils.invokeLater(new Runnable(){
        @Override public void run(){
          updateEditor();
        }
      }
);
    }
  }
);
}","/** 
 * Binds editor to downloadItems so that the editor automatically updates when downloadItems changes and popup menus work.  This is required for Editors
 */
public void initializeEditor(EventList<DownloadItem> downloadItems){
  this.downloadItems=downloadItems;
  downloadItems.addListEventListener(new ListEventListener<DownloadItem>(){
    @Override public void listChanged(    ListEvent<DownloadItem> listChanges){
      SwingUtils.invokeLater(new Runnable(){
        @Override public void run(){
          if (isVisible()) {
            updateEditor();
          }
        }
      }
);
    }
  }
);
}",0.963404255319149
4076,"@Override public void run(){
  updateEditor();
}","@Override public void run(){
  if (isVisible()) {
    updateEditor();
  }
}",0.7804878048780488
4077,"@Override public void listChanged(ListEvent<DownloadItem> listChanges){
  SwingUtils.invokeLater(new Runnable(){
    @Override public void run(){
      updateEditor();
    }
  }
);
}","@Override public void listChanged(ListEvent<DownloadItem> listChanges){
  SwingUtils.invokeLater(new Runnable(){
    @Override public void run(){
      if (isVisible()) {
        updateEditor();
      }
    }
  }
);
}",0.912280701754386
4078,"public Downloader getDownloader(){
  return downloader;
}","private Downloader getDownloader(){
  return downloader;
}",0.9217391304347826
4079,"@Override public void cancel(){
  downloader.stop();
}","@Override public void cancel(){
  cancelled=true;
  support.firePropertyChange(""String_Node_Str"",null,getState());
  downloader.stop();
}",0.5654450261780105
4080,"@Override public double getCurrentSize(){
  return downloader.getAmountRead();
}","@Override public double getCurrentSize(){
  if (getState() == DownloadState.DONE) {
    return getTotalSize();
  }
 else {
    return downloader.getAmountRead();
  }
}",0.6477732793522267
4081,"@Override public DownloadState getState(){
  return convertState(downloader.getState());
}","@Override public DownloadState getState(){
  if (cancelled) {
    return DownloadState.CANCELLED;
  }
  return convertState(downloader.getState());
}",0.7531380753138075
4082,"private static DownloadState convertState(DownloadStatus status){
switch (status) {
case SAVING:
case HASHING:
    return DownloadState.FINISHING;
case DOWNLOADING:
case FETCHING:
case IDENTIFY_CORRUPTION:
  return DownloadState.DOWNLOADING;
case CONNECTING:
case RESUMING:
case INITIALIZING:
case WAITING_FOR_GNET_RESULTS:
case QUERYING_DHT:
case BUSY:
case WAITING_FOR_CONNECTIONS:
case ITERATIVE_GUESSING:
return DownloadState.CONNECTING;
case COMPLETE:
return DownloadState.DONE;
case REMOTE_QUEUED:
return DownloadState.REMOTE_QUEUED;
case QUEUED:
return DownloadState.LOCAL_QUEUED;
case PAUSED:
return DownloadState.PAUSED;
case WAITING_FOR_USER:
case GAVE_UP:
return DownloadState.STALLED;
case ABORTED:
return DownloadState.CANCELLED;
case DISK_PROBLEM:
case CORRUPT_FILE:
case RECOVERY_FAILED:
case INVALID:
return DownloadState.ERROR;
default :
return DownloadState.DOWNLOADING;
}
}","private DownloadState convertState(DownloadStatus status){
switch (status) {
case SAVING:
case HASHING:
    if (getTotalSize() > finishingThreshold) {
      return DownloadState.FINISHING;
    }
 else {
      return DownloadState.DONE;
    }
case DOWNLOADING:
case FETCHING:
case IDENTIFY_CORRUPTION:
  return DownloadState.DOWNLOADING;
case CONNECTING:
case RESUMING:
case INITIALIZING:
case WAITING_FOR_GNET_RESULTS:
case QUERYING_DHT:
case BUSY:
case WAITING_FOR_CONNECTIONS:
case ITERATIVE_GUESSING:
return DownloadState.CONNECTING;
case COMPLETE:
return DownloadState.DONE;
case REMOTE_QUEUED:
return DownloadState.REMOTE_QUEUED;
case QUEUED:
return DownloadState.LOCAL_QUEUED;
case PAUSED:
return DownloadState.PAUSED;
case WAITING_FOR_USER:
case GAVE_UP:
return DownloadState.STALLED;
case ABORTED:
return DownloadState.CANCELLED;
case DISK_PROBLEM:
case CORRUPT_FILE:
case RECOVERY_FAILED:
case INVALID:
return DownloadState.ERROR;
default :
return DownloadState.DOWNLOADING;
}
}",0.9419904204364024
4083,"public CoreDownloadItem(Downloader downloader){
  this.downloader=downloader;
}","public CoreDownloadItem(Downloader downloader){
  this.downloader=downloader;
  downloader.addListener(new EventListener<DownloadStatusEvent>(){
    @Override public void handleEvent(    DownloadStatusEvent event){
      support.firePropertyChange(""String_Node_Str"",null,getState());
    }
  }
);
}",0.4190981432360742
4084,"@Override public EventList<DownloadItem> getDownloads(){
  return downloadItems;
}","@Override public EventList<DownloadItem> getDownloads(){
  System.out.println(this);
  return downloadItems;
}",0.8541666666666666
4085,"public DownloadMediator(DownloadListManager downloadManager){
  commonBaseList=downloadManager.getDownloads();
  searchBar=new JTextField();
  filteredList=new FilterList<DownloadItem>(commonBaseList,new TextComponentMatcherEditor<DownloadItem>(searchBar,new DownloadItemTextFilterator(),true));
}","public DownloadMediator(DownloadListManager downloadManager){
  commonBaseList=new FilterList<DownloadItem>(downloadManager.getDownloads(),new DownloadStateExcluder(DownloadState.CANCELLED));
  searchBar=new JTextField();
  filteredList=new FilterList<DownloadItem>(commonBaseList,new TextComponentMatcherEditor<DownloadItem>(searchBar,new DownloadItemTextFilterator(),true));
}",0.88
4086,"public void pauseAll(){
  for (  DownloadItem item : commonBaseList) {
    if (item.getState().isPausable()) {
      item.pause();
    }
  }
}","public void pauseAll(){
  commonBaseList.getReadWriteLock().readLock().lock();
  try {
    for (    DownloadItem item : commonBaseList) {
      if (item.getState().isPausable()) {
        item.pause();
      }
    }
  }
  finally {
    commonBaseList.getReadWriteLock().readLock().unlock();
  }
}",0.6164383561643836
4087,"public void resumeAll(){
  for (  DownloadItem item : commonBaseList) {
    if (item.getState().isResumable()) {
      item.resume();
    }
  }
}","public void resumeAll(){
  commonBaseList.getReadWriteLock().readLock().lock();
  try {
    for (    DownloadItem item : commonBaseList) {
      if (item.getState().isResumable()) {
        item.resume();
      }
    }
  }
  finally {
    commonBaseList.getReadWriteLock().readLock().unlock();
  }
}",0.6216216216216216
4088,"/** 
 * Create the panel
 */
public DownloadSummaryPanel(final EventList<DownloadItem> itemList){
  GuiUtils.assignResources(this);
  this.itemList=itemList;
  setLayout(new BorderLayout());
  titleLabel=new JLabel();
  titleLabel.setHorizontalTextPosition(SwingConstants.LEFT);
  FontUtils.changeStyle(titleLabel,Font.BOLD);
  add(titleLabel,BorderLayout.NORTH);
  table=new JTable(new DownloadTableModel(itemList));
  table.setShowHorizontalLines(false);
  table.setShowVerticalLines(false);
  warningList=new FilterList<DownloadItem>(itemList,new DownloadStateMatcher(DownloadState.ERROR,DownloadState.STALLED));
  itemList.addListEventListener(new ListEventListener<DownloadItem>(){
    @Override public void listChanged(    ListEvent<DownloadItem> listChanges){
      updateTitle();
      adjustVisibility();
    }
  }
);
  table.setDefaultRenderer(DownloadItem.class,new DownloadStatusPanelRenderer());
  add(table,BorderLayout.CENTER);
  updateTitle();
  adjustVisibility();
}","/** 
 * Create the panel
 */
public DownloadSummaryPanel(final EventList<DownloadItem> itemList){
  GuiUtils.assignResources(this);
  setLayout(new BorderLayout());
  this.allList=itemList;
  unfinishedList=new FilterList<DownloadItem>(itemList,new DownloadStateExcluder(DownloadState.DONE));
  warningList=new FilterList<DownloadItem>(itemList,new DownloadStateMatcher(DownloadState.ERROR,DownloadState.STALLED));
  titleLabel=new JLabel();
  titleLabel.setHorizontalTextPosition(SwingConstants.LEFT);
  FontUtils.changeStyle(titleLabel,Font.BOLD);
  add(titleLabel,BorderLayout.NORTH);
  table=new JTable(new DownloadTableModel(unfinishedList));
  table.setShowHorizontalLines(false);
  table.setShowVerticalLines(false);
  allList.addListEventListener(new ListEventListener<DownloadItem>(){
    @Override public void listChanged(    ListEvent<DownloadItem> listChanges){
      updateTitle();
      adjustVisibility();
    }
  }
);
  table.setDefaultRenderer(DownloadItem.class,new DownloadStatusPanelRenderer());
  add(table,BorderLayout.CENTER);
  updateTitle();
  adjustVisibility();
}",0.6280752532561505
4089,"private void adjustVisibility(){
  setVisible(itemList.size() > 0);
}","private void adjustVisibility(){
  setVisible(allList.size() > 0);
}",0.948905109489051
4090,"private void updateTitle(){
  titleLabel.setText(I18n.tr(""String_Node_Str"",itemList.size()));
  if (warningList.size() > 0) {
    titleLabel.setIcon(warningIcon);
  }
 else {
    titleLabel.setIcon(null);
  }
}","private void updateTitle(){
  titleLabel.setText(I18n.tr(""String_Node_Str"",unfinishedList.size()));
  if (warningList.size() > 0) {
    titleLabel.setIcon(warningIcon);
  }
 else {
    titleLabel.setIcon(null);
  }
}",0.9671361502347418
4091,"/** 
 * Creates a DownloadTable and adds it to a collapsible pane with the title 
 * @param model the model of the table
 * @param title the title of the panel displaying this table
 * @param state
 */
private void addTable(EventList<DownloadItem> list,String title,DownloadState... states){
  final JXCollapsiblePane collapsePane=new JXCollapsiblePane();
  collapsePane.setLayout(new BorderLayout());
  FilterList<DownloadItem> filterList=new FilterList<DownloadItem>(list,new DownloadStateMatcher(states));
  final JXTable table=new DownloadTable(filterList);
  tables.add(table);
  table.getSelectionModel().addListSelectionListener(new MultiTableSelectionListener());
  collapsePane.add(table,BorderLayout.CENTER);
  final JPanel titlePanel=new JPanel(new VerticalLayout());
  JLabel titleLabel=new JLabel(title);
  titleLabel.addMouseListener(getClickListener(collapsePane.getActionMap().get(JXCollapsiblePane.TOGGLE_ACTION)));
  titlePanel.add(titleLabel);
  titlePanel.add(new JSeparator());
  titles.add(titlePanel);
  tablePanel.add(titlePanel);
  tablePanel.add(collapsePane);
}","/** 
 * Creates a DownloadTable and adds it to a collapsible pane with the title 
 * @param model the model of the table
 * @param title the title of the panel displaying this table
 * @param state
 */
private void addTable(EventList<DownloadItem> list,String title,DownloadState... states){
  final JXCollapsiblePane collapsePane=new JXCollapsiblePane();
  collapsePane.setLayout(new BorderLayout());
  EventList<DownloadItem> filterList=new FilterList<DownloadItem>(list,new DownloadStateMatcher(states));
  final JXTable table=new DownloadTable(filterList);
  tables.add(table);
  table.getSelectionModel().addListSelectionListener(new MultiTableSelectionListener());
  collapsePane.add(table,BorderLayout.CENTER);
  final JPanel titlePanel=new JPanel(new VerticalLayout());
  JLabel titleLabel=new JLabel(title);
  titleLabel.addMouseListener(getClickListener(collapsePane.getActionMap().get(JXCollapsiblePane.TOGGLE_ACTION)));
  titlePanel.add(titleLabel);
  titlePanel.add(new JSeparator());
  titles.add(titlePanel);
  tablePanel.add(titlePanel);
  tablePanel.add(collapsePane);
}",0.9949425287356322
4092,"/** 
 * Create the panel
 */
public DownloadRendererEditor(){
  GuiUtils.assignResources(this);
  iconLabel=new JLabel();
  titleLabel=new JLabel();
  titleLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,18));
  titleLabel.setText(""String_Node_Str"");
  statusLabel=new JLabel();
  statusLabel.setFont(new Font(""String_Node_Str"",Font.PLAIN,9));
  statusLabel.setText(""String_Node_Str"");
  progressBar=new LimeProgressBar();
  Dimension size=new Dimension(350,25);
  progressBar.setMaximumSize(size);
  progressBar.setMinimumSize(size);
  progressBar.setPreferredSize(size);
  editorLister=new DownloadEditorListener();
  menuListener=new MenuListener();
  pauseButton=new JButton();
  pauseButton.addActionListener(editorLister);
  pauseButton.setOpaque(false);
  pauseButton.setText(""String_Node_Str"");
  pauseMenuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  pauseMenuItem.addActionListener(menuListener);
  cancelButton=new JButton();
  cancelButton.addActionListener(editorLister);
  cancelButton.setOpaque(false);
  cancelButton.setText(""String_Node_Str"");
  cancelMenuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  cancelMenuItem.addActionListener(menuListener);
  timeLabel=new JLabel();
  timeLabel.setFont(new Font(""String_Node_Str"",Font.PLAIN,9));
  timeLabel.setText(""String_Node_Str"");
  resumeButton=new JButton();
  resumeButton.addActionListener(editorLister);
  resumeButton.setVisible(false);
  resumeButton.setText(""String_Node_Str"");
  resumeMenuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  resumeMenuItem.addActionListener(menuListener);
  tryAgainButton=new JButton();
  tryAgainButton.addActionListener(editorLister);
  tryAgainButton.setToolTipText(I18n.tr(""String_Node_Str""));
  tryAgainButton.setText(""String_Node_Str"");
  tryAgainMenuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  tryAgainMenuItem.addActionListener(menuListener);
  buttonPanel=new JPanel(new FlowLayout(FlowLayout.LEFT));
  buttonPanel.setOpaque(false);
  buttonPanel.add(resumeButton);
  buttonPanel.add(pauseButton);
  buttonPanel.add(tryAgainButton);
  buttonPanel.add(cancelButton);
  setLayout(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.CENTER;
  gbc.weightx=0;
  gbc.weighty=1;
  gbc.gridheight=3;
  add(iconLabel,gbc);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.gridx=1;
  gbc.weightx=1;
  gbc.weighty=0;
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  gbc.gridheight=1;
  add(titleLabel,gbc);
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridx=1;
  gbc.gridy=1;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridwidth=2;
  add(progressBar,gbc);
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridx=1;
  gbc.gridy=2;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridwidth=1;
  add(statusLabel,gbc);
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.EAST;
  gbc.gridx=2;
  gbc.gridy=2;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridwidth=1;
  add(timeLabel,gbc);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.gridx=3;
  gbc.gridy=1;
  gbc.weightx=1;
  gbc.weighty=0;
  gbc.gridwidth=1;
  add(buttonPanel,gbc);
  popupMenu=new JPopupMenu();
  popupMenu.add(pauseMenuItem);
  popupMenu.add(resumeMenuItem);
  popupMenu.add(cancelMenuItem);
  popupMenu.add(tryAgainMenuItem);
  addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      maybeShowPopup(e);
    }
    @Override public void mousePressed(    MouseEvent e){
      maybeShowPopup(e);
    }
    private void maybeShowPopup(    MouseEvent e){
      if (e.isPopupTrigger()) {
        showPopup(e.getComponent(),e.getX(),e.getY());
      }
    }
  }
);
}","/** 
 * Create the panel
 */
public DownloadRendererEditor(){
  GuiUtils.assignResources(this);
  iconLabel=new JLabel();
  titleLabel=new JLabel();
  titleLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,18));
  titleLabel.setText(""String_Node_Str"");
  statusLabel=new JLabel();
  statusLabel.setFont(new Font(""String_Node_Str"",Font.PLAIN,9));
  statusLabel.setText(""String_Node_Str"");
  progressBar=new LimeProgressBar();
  Dimension size=new Dimension(350,25);
  progressBar.setMaximumSize(size);
  progressBar.setMinimumSize(size);
  progressBar.setPreferredSize(size);
  editorLister=new DownloadEditorListener();
  menuListener=new MenuListener();
  pauseButton=createButton(pauseIcon,pauseIconRollover,pauseIconPressed);
  pauseButton.addActionListener(editorLister);
  pauseButton.setToolTipText(I18n.tr(""String_Node_Str""));
  pauseMenuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  pauseMenuItem.addActionListener(menuListener);
  cancelButton=createButton(cancelIcon,cancelIconRollover,cancelIconPressed);
  cancelButton.addActionListener(editorLister);
  cancelButton.setToolTipText(I18n.tr(""String_Node_Str""));
  cancelMenuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  cancelMenuItem.addActionListener(menuListener);
  timeLabel=new JLabel();
  timeLabel.setFont(new Font(""String_Node_Str"",Font.PLAIN,9));
  timeLabel.setText(""String_Node_Str"");
  resumeButton=createButton(resumeIcon,resumeIconRollover,resumeIconPressed);
  resumeButton.addActionListener(editorLister);
  resumeButton.setVisible(false);
  resumeButton.setToolTipText(I18n.tr(""String_Node_Str""));
  resumeMenuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  resumeMenuItem.addActionListener(menuListener);
  tryAgainButton=createButton(tryAgainIcon,tryAgainIconRollover,tryAgainIconPressed);
  tryAgainButton.addActionListener(editorLister);
  tryAgainButton.setToolTipText(I18n.tr(""String_Node_Str""));
  tryAgainMenuItem=new JMenuItem(I18n.tr(""String_Node_Str""));
  tryAgainMenuItem.addActionListener(menuListener);
  buttonPanel=new JPanel(new FlowLayout(FlowLayout.LEFT));
  buttonPanel.setOpaque(false);
  buttonPanel.add(resumeButton);
  buttonPanel.add(pauseButton);
  buttonPanel.add(tryAgainButton);
  buttonPanel.add(cancelButton);
  setLayout(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.CENTER;
  gbc.weightx=0;
  gbc.weighty=1;
  gbc.gridheight=3;
  add(iconLabel,gbc);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.gridx=1;
  gbc.weightx=1;
  gbc.weighty=0;
  gbc.gridwidth=GridBagConstraints.REMAINDER;
  gbc.gridheight=1;
  add(titleLabel,gbc);
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridx=1;
  gbc.gridy=1;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridwidth=2;
  add(progressBar,gbc);
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.WEST;
  gbc.gridx=1;
  gbc.gridy=2;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridwidth=1;
  add(statusLabel,gbc);
  gbc.fill=GridBagConstraints.NONE;
  gbc.anchor=GridBagConstraints.EAST;
  gbc.gridx=2;
  gbc.gridy=2;
  gbc.weightx=0;
  gbc.weighty=0;
  gbc.gridwidth=1;
  add(timeLabel,gbc);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.anchor=GridBagConstraints.NORTHWEST;
  gbc.gridx=3;
  gbc.gridy=1;
  gbc.weightx=1;
  gbc.weighty=0;
  gbc.gridwidth=1;
  add(buttonPanel,gbc);
  popupMenu=new JPopupMenu();
  popupMenu.add(pauseMenuItem);
  popupMenu.add(resumeMenuItem);
  popupMenu.add(cancelMenuItem);
  popupMenu.add(tryAgainMenuItem);
}",0.8761288583367031
4093,"private void showPopup(Component c,int x,int y){
  menuEditItem=editItem;
  DownloadState state=menuEditItem.getState();
  pauseMenuItem.setVisible(state.isPausable());
  resumeMenuItem.setVisible(state.isResumable());
  cancelMenuItem.setVisible(state.isCancellable());
  tryAgainMenuItem.setVisible(state.isSearchAgainable());
  popupMenu.show(c,x,y);
}","public void showPopup(Component c,int x,int y){
  menuEditItem=editItem;
  DownloadState state=menuEditItem.getState();
  pauseMenuItem.setVisible(state.isPausable());
  resumeMenuItem.setVisible(state.isResumable());
  cancelMenuItem.setVisible(state.isCancellable());
  tryAgainMenuItem.setVisible(state.isSearchAgainable());
  popupMenu.show(c,x,y);
}",0.9844851904090268
4094,"public DownloadTable(EventList<DownloadItem> downloadItems){
  super(new DownloadTableModel(downloadItems));
  setRolloverEnabled(false);
  setFocusable(false);
  setEditable(true);
  setShowGrid(false,false);
  setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  setHighlighters(HighlighterFactory.createSimpleStriping());
  final DownloadRendererEditor editor=new DownloadRendererEditor();
  editor.initializeEditor(downloadItems);
  DownloadRendererEditor renderer=new DownloadRendererEditor();
  setDefaultEditor(DownloadItem.class,editor);
  setDefaultRenderer(DownloadItem.class,renderer);
  setRowHeight(renderer.getPreferredSize().height);
  addMouseMotionListener(new MouseMotionAdapter(){
    @Override public void mouseMoved(    MouseEvent e){
      Component component=getComponentAt(e.getPoint());
      if (component instanceof JTable) {
        JTable table=(JTable)component;
        int col=table.columnAtPoint(e.getPoint());
        int row=table.rowAtPoint(e.getPoint());
        table.editCellAt(row,col);
      }
    }
  }
);
  addMouseListener(new MouseAdapter(){
    @Override public void mouseExited(    MouseEvent e){
      TableCellEditor editor=getCellEditor();
      Component component=e.getComponent();
      if (editor != null && component != editor) {
        if (component == null || component.getComponentAt(e.getPoint()) != editor) {
          editor.cancelCellEditing();
        }
      }
    }
  }
);
}","public DownloadTable(EventList<DownloadItem> downloadItems){
  super(new DownloadTableModel(downloadItems));
  setRolloverEnabled(false);
  setFocusable(false);
  setEditable(true);
  setShowGrid(false,false);
  setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  setHighlighters(HighlighterFactory.createSimpleStriping());
  final DownloadRendererEditor editor=new DownloadRendererEditor();
  editor.initializeEditor(downloadItems);
  DownloadRendererEditor renderer=new DownloadRendererEditor();
  setDefaultEditor(DownloadItem.class,editor);
  setDefaultRenderer(DownloadItem.class,renderer);
  setRowHeight(renderer.getPreferredSize().height);
  addMouseMotionListener(new MouseMotionAdapter(){
    @Override public void mouseMoved(    MouseEvent e){
      Component component=getComponentAt(e.getPoint());
      if (component instanceof JTable) {
        JTable table=(JTable)component;
        int col=table.columnAtPoint(e.getPoint());
        int row=table.rowAtPoint(e.getPoint());
        table.editCellAt(row,col);
      }
    }
  }
);
  addMouseListener(new MouseAdapter(){
    @Override public void mouseExited(    MouseEvent e){
      TableCellEditor editor=getCellEditor();
      Component component=e.getComponent();
      if (editor != null && component != editor) {
        if (component == null || component.getComponentAt(e.getPoint()) != editor) {
          editor.cancelCellEditing();
        }
      }
    }
    @Override public void mouseReleased(    MouseEvent e){
      maybeShowPopup(e);
    }
    @Override public void mousePressed(    MouseEvent e){
      maybeShowPopup(e);
    }
    private void maybeShowPopup(    MouseEvent e){
      if (e.isPopupTrigger()) {
        editor.showPopup(e.getComponent(),e.getX(),e.getY());
      }
    }
  }
);
}",0.8933663980161191
4095,"/** 
 * Paints this component, including an icon and the default text when this component has focus and has no text value.
 */
@Override protected void paintComponent(Graphics g){
  Graphics2D g2d=(Graphics2D)g.create();
  if (icon == null) {
    g2d.drawLine(0,0,getWidth(),getHeight());
    g2d.drawLine(0,getHeight(),getWidth(),0);
  }
 else {
    Image image=((ImageIcon)icon).getImage();
    g2d.drawImage(image,0,0,Color.WHITE,null);
    g2d.translate(icon.getIconWidth(),0);
  }
  int iconWidth=icon.getIconWidth();
  g2d.translate(iconWidth,0);
  super.paintComponent(g2d);
  boolean valueEntered=getText().length() > 0;
  if (!hasFocus() && !valueEntered) {
    g2d.setColor(Color.LIGHT_GRAY);
    FontMetrics fm=g2d.getFontMetrics();
    int x=2;
    int y=fm.getAscent() + 2;
    g2d.drawString(defaultText,x,y);
  }
  g2d.dispose();
}","/** 
 * Paints this component, including an icon and the default text when this component has focus and has no text value.
 */
@Override protected void paintComponent(Graphics g){
  Graphics2D g2d=(Graphics2D)g.create();
  int iconWidth=icon == null ? getHeight() : icon.getIconWidth();
  if (icon == null) {
    g2d.drawLine(0,0,iconWidth,iconWidth);
    g2d.drawLine(0,iconWidth,iconWidth,0);
  }
 else {
    Image image=((ImageIcon)icon).getImage();
    g2d.drawImage(image,0,0,Color.WHITE,null);
  }
  g2d.translate(iconWidth,0);
  super.paintComponent(g2d);
  boolean valueEntered=getText().length() > 0;
  if (!hasFocus() && !valueEntered) {
    g2d.setColor(Color.LIGHT_GRAY);
    FontMetrics fm=g2d.getFontMetrics();
    int x=2;
    int y=fm.getAscent() + 2;
    g2d.drawString(defaultText,x,y);
  }
  g2d.dispose();
}",0.8762701733413031
4096,"private void layoutComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.insets=new Insets(2,2,2,10);
  add(filterBox,gbc);
  gbc.insets.right=5;
  add(sortLabel,gbc);
  add(sortBox,gbc);
  gbc.insets.left=gbc.insets.right=0;
  add(listViewToggleButton,gbc);
  add(tableViewToggleButton,gbc);
}","private void layoutComponents(){
  setLayout(new GridBagLayout());
  GridBagConstraints gbc=new GridBagConstraints();
  gbc.insets=new Insets(3,2,2,10);
  add(filterBox,gbc);
  gbc.insets.right=5;
  add(sortLabel,gbc);
  add(sortBox,gbc);
  gbc.insets.left=gbc.insets.right=0;
  add(listViewToggleButton,gbc);
  add(tableViewToggleButton,gbc);
}",0.9971014492753624
4097,"public boolean isAddressExternal(){
  if (!ConnectionSettings.LOCAL_IS_PRIVATE.getValue())   return true;
synchronized (AcceptorImpl.class) {
    return Arrays.equals(getAddress(true),_externalAddress);
  }
}","public boolean isAddressExternal(){
  if (!ConnectionSettings.LOCAL_IS_PRIVATE.getValue())   return true;
synchronized (ADDRESS_LOCK) {
    return Arrays.equals(getAddress(true),_externalAddress);
  }
}",0.8292682926829268
4098,"public void checkFirewall(InetAddress address){
  boolean changed=false;
  if (isOutsideConnection(address)) {
synchronized (AcceptorImpl.class) {
      changed=setIncoming(true);
      ConnectionSettings.EVER_ACCEPTED_INCOMING.setValue(true);
    }
  }
  if (changed)   networkManager.incomingStatusChanged();
}","public void checkFirewall(InetAddress address){
  boolean changed=false;
  if (isOutsideConnection(address)) {
synchronized (ADDRESS_LOCK) {
      changed=setIncoming(true);
      ConnectionSettings.EVER_ACCEPTED_INCOMING.setValue(true);
    }
  }
  if (changed)   networkManager.incomingStatusChanged();
}",0.9546925566343042
4099,"public void run(){
  boolean changed=false;
synchronized (AcceptorImpl.class) {
    changed=setIncoming(false);
  }
  if (changed)   networkManager.incomingStatusChanged();
}","public void run(){
  boolean changed=false;
synchronized (ADDRESS_LOCK) {
    changed=setIncoming(false);
  }
  if (changed)   networkManager.incomingStatusChanged();
}",0.9181286549707602
4100,"public byte[] getAddress(boolean checkForce){
  if (checkForce && ConnectionSettings.FORCE_IP_ADDRESS.getValue()) {
    String address=ConnectionSettings.FORCED_IP_ADDRESS_STRING.getValue();
    try {
      InetAddress ia=InetAddress.getByName(address);
      byte[] addr=ia.getAddress();
      if (addr != null)       return addr;
    }
 catch (    UnknownHostException err) {
    }
  }
synchronized (AcceptorImpl.class) {
    return _address;
  }
}","public byte[] getAddress(boolean checkForce){
  if (checkForce && ConnectionSettings.FORCE_IP_ADDRESS.getValue()) {
    String address=ConnectionSettings.FORCED_IP_ADDRESS_STRING.getValue();
    try {
      InetAddress ia=InetAddress.getByName(address);
      byte[] addr=ia.getAddress();
      if (addr != null)       return addr;
    }
 catch (    UnknownHostException err) {
    }
  }
synchronized (ADDRESS_LOCK) {
    return _address;
  }
}",0.9686800894854586
4101,"public void setAddress(InetAddress address){
  byte[] byteAddr=address.getAddress();
  if (!NetworkUtils.isValidAddress(byteAddr))   return;
  if (byteAddr[0] == 127 && ConnectionSettings.LOCAL_IS_PRIVATE.getValue()) {
    return;
  }
  boolean addrChanged=false;
synchronized (AcceptorImpl.class) {
    if (!Arrays.equals(_address,byteAddr)) {
      _address=byteAddr;
      addrChanged=true;
    }
  }
  if (addrChanged)   networkManager.addressChanged();
}","public void setAddress(InetAddress address){
  byte[] byteAddr=address.getAddress();
  if (!NetworkUtils.isValidAddress(byteAddr))   return;
  if (byteAddr[0] == 127 && ConnectionSettings.LOCAL_IS_PRIVATE.getValue()) {
    return;
  }
  boolean addrChanged=false;
synchronized (ADDRESS_LOCK) {
    if (!Arrays.equals(_address,byteAddr)) {
      _address=byteAddr;
      addrChanged=true;
    }
  }
  if (addrChanged)   networkManager.addressChanged();
}",0.9692982456140352
4102,"public byte[] getExternalAddress(){
synchronized (AcceptorImpl.class) {
    return _externalAddress;
  }
}","public byte[] getExternalAddress(){
synchronized (ADDRESS_LOCK) {
    return _externalAddress;
  }
}",0.8640776699029126
4103,"public void setExternalAddress(InetAddress address){
  byte[] byteAddr=address.getAddress();
  if (byteAddr[0] == 127 && ConnectionSettings.LOCAL_IS_PRIVATE.getValue()) {
    return;
  }
synchronized (AcceptorImpl.class) {
    _externalAddress=byteAddr;
  }
}","public void setExternalAddress(InetAddress address){
  byte[] byteAddr=address.getAddress();
  if (byteAddr[0] == 127 && ConnectionSettings.LOCAL_IS_PRIVATE.getValue()) {
    return;
  }
synchronized (ADDRESS_LOCK) {
    _externalAddress=byteAddr;
  }
}",0.9453125
4104,"/** 
 * Starts listening for UDP messages & allowing UDP messages to be written.
 */
public void start(){
  DatagramChannel channel;
synchronized (this) {
    _started=true;
    channel=_channel;
  }
  if (channel != null)   NIODispatcher.instance().registerReadWrite(channel,this);
}","/** 
 * Starts listening for UDP messages & allowing UDP messages to be written.
 */
public void start(){
  if (!_started)   scheduleServices();
  DatagramChannel channel;
synchronized (this) {
    _started=true;
    channel=_channel;
  }
  if (channel != null)   NIODispatcher.instance().registerReadWrite(channel,this);
}",0.9357495881383856
4105,"@Inject public UDPService(NetworkManager networkManager,Provider<MessageDispatcher> messageDispatcher,@Named(""String_Node_Str"") Provider<IPFilter> hostileFilter,Provider<ConnectionManager> connectionManager,Provider<MessageRouter> messageRouter,Provider<Acceptor> acceptor,Provider<QueryUnicaster> queryUnicaster,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,ConnectionServices connectionServices,MessageFactory messageFactory,PingRequestFactory pingRequestFactory,NetworkInstanceUtils networkInstanceUtils){
  this.networkManager=networkManager;
  this.messageDispatcher=messageDispatcher;
  this.hostileFilter=hostileFilter;
  this.connectionManager=connectionManager;
  this.messageRouter=messageRouter;
  this.acceptor=acceptor;
  this.queryUnicaster=queryUnicaster;
  this.backgroundExecutor=backgroundExecutor;
  this.connectionServices=connectionServices;
  this.messageFactory=messageFactory;
  this.pingRequestFactory=pingRequestFactory;
  this.networkInstanceUtils=networkInstanceUtils;
  OUTGOING_MSGS=new LinkedList<SendBundle>();
  byte[] backing=new byte[BUFFER_SIZE];
  BUFFER=ByteBuffer.wrap(backing);
  scheduleServices();
}","@Inject public UDPService(NetworkManager networkManager,Provider<MessageDispatcher> messageDispatcher,@Named(""String_Node_Str"") Provider<IPFilter> hostileFilter,Provider<ConnectionManager> connectionManager,Provider<MessageRouter> messageRouter,Provider<Acceptor> acceptor,Provider<QueryUnicaster> queryUnicaster,@Named(""String_Node_Str"") ScheduledExecutorService backgroundExecutor,ConnectionServices connectionServices,MessageFactory messageFactory,PingRequestFactory pingRequestFactory,NetworkInstanceUtils networkInstanceUtils){
  this.networkManager=networkManager;
  this.messageDispatcher=messageDispatcher;
  this.hostileFilter=hostileFilter;
  this.connectionManager=connectionManager;
  this.messageRouter=messageRouter;
  this.acceptor=acceptor;
  this.queryUnicaster=queryUnicaster;
  this.backgroundExecutor=backgroundExecutor;
  this.connectionServices=connectionServices;
  this.messageFactory=messageFactory;
  this.pingRequestFactory=pingRequestFactory;
  this.networkInstanceUtils=networkInstanceUtils;
  OUTGOING_MSGS=new LinkedList<SendBundle>();
  byte[] backing=new byte[BUFFER_SIZE];
  BUFFER=ByteBuffer.wrap(backing);
}",0.9904679376083187
4106,"/** 
 * Test to make sure that the query route tables are forwarded correctly between Ultrapeers.
 */
public void testIntraUltrapeerForwardQueryRouteTables() throws Exception {
  Injector injector=createInjectorAndInitialize(new AbstractModule(){
    @Override protected void configure(){
      bind(ConnectionManager.class).to(TestConnectionManager.class);
      bind(FileManager.class).to(TestFileManager.class);
    }
  }
);
  TestConnectionManager tcm=(TestConnectionManager)injector.getInstance(ConnectionManager.class);
  tcm.resetAndInitialize();
  messageRouterImpl.forwardQueryRouteTables();
  List connections=tcm.getInitializedConnections();
  Iterator iter=connections.iterator();
  while (iter.hasNext()) {
    TestConnection tc=(TestConnection)iter.next();
    QueryRouteTable qrt=tc.getQueryRouteTable();
    assertTrue(""String_Node_Str"",tcm.runQRPMatch(qrt));
  }
}","/** 
 * Test to make sure that the query route tables are forwarded correctly between Ultrapeers.
 */
public void testIntraUltrapeerForwardQueryRouteTables() throws Exception {
  Injector injector=createInjectorAndInitialize(new AbstractModule(){
    @Override protected void configure(){
      bind(ConnectionManager.class).to(TestConnectionManager.class);
      bind(QRPUpdater.class).to(TestQRPUpdater.class);
    }
  }
);
  TestConnectionManager tcm=(TestConnectionManager)injector.getInstance(ConnectionManager.class);
  tcm.resetAndInitialize();
  messageRouterImpl.forwardQueryRouteTables();
  List connections=tcm.getInitializedConnections();
  Iterator iter=connections.iterator();
  while (iter.hasNext()) {
    TestConnection tc=(TestConnection)iter.next();
    QueryRouteTable qrt=tc.getQueryRouteTable();
    assertTrue(""String_Node_Str"",tcm.runQRPMatch(qrt));
  }
}",0.9613636363636364
4107,"/** 
 * Tests the method for adding query routing entries to the QRP table for this node, adding the leaves' QRP tables if we're an Ultrapeer.
 */
public void testCreateRouteTable() throws Exception {
  Injector injector=createInjectorAndInitialize(new AbstractModule(){
    @Override protected void configure(){
      bind(ConnectionManager.class).to(TestConnectionManager.class);
      bind(FileManager.class).to(TestFileManager.class);
    }
  }
);
  TestConnectionManager tcm=(TestConnectionManager)injector.getInstance(ConnectionManager.class);
  tcm.resetAndInitialize();
  QueryRouteTable qrt=messageRouterImpl.createRouteTable();
  tcm.runQRPMatch(qrt);
}","/** 
 * Tests the method for adding query routing entries to the QRP table for this node, adding the leaves' QRP tables if we're an Ultrapeer.
 */
public void testCreateRouteTable() throws Exception {
  Injector injector=createInjectorAndInitialize(new AbstractModule(){
    @Override protected void configure(){
      bind(ConnectionManager.class).to(TestConnectionManager.class);
    }
  }
);
  TestConnectionManager tcm=(TestConnectionManager)injector.getInstance(ConnectionManager.class);
  tcm.resetAndInitialize();
  QueryRouteTable qrt=messageRouterImpl.createRouteTable();
  tcm.runQRPMatch(qrt);
}",0.9550827423167848
4108,"public BrowseHostHandler doAsynchronousBrowseHost(final Connectable host,GUID guid,GUID serventID,final Set<? extends IpPort> proxies,final boolean canDoFWTransfer){
  final BrowseHostHandler handler=browseHostHandlerManager.createBrowseHostHandler(guid,serventID);
  ThreadExecutor.startThread(new Runnable(){
    public void run(){
      handler.browseHost(host,proxies,canDoFWTransfer);
    }
  }
,""String_Node_Str"");
  return handler;
}","public BrowseHostHandler doAsynchronousBrowseHost(final Connectable host,GUID guid,GUID serventID,final Set<? extends IpPort> proxies,final boolean canDoFWTransfer){
  final BrowseHostHandler handler=browseHostHandlerManager.createBrowseHostHandler(guid,serventID);
  ThreadExecutor.startThread(new DebugRunnable(new Runnable(){
    public void run(){
      handler.browseHost(host,proxies,canDoFWTransfer);
    }
  }
),""String_Node_Str"");
  return handler;
}",0.978865406006674
4109,"/** 
 * Strips out results that don't seem to be valid due to territory, radius, or other restriction.
 */
private void removeInvalidResults(List<QueryResult> results){
  for (  QueryResult result : new ArrayList<QueryResult>(results)) {
    PromotionMessageContainer promo=result.getPromotionMessageContainer();
    List<GeoRestriction> restrictions=promo.getGeoRestrictions();
    if (restrictions.size() > 0) {
      if (userLatLon == null) {
        results.remove(result);
        continue;
      }
 else {
        boolean matchedAtLeastOneRestriction=false;
        for (        GeoRestriction restriction : restrictions) {
          if (restriction.contains(userLatLon)) {
            matchedAtLeastOneRestriction=true;
            break;
          }
        }
        if (!matchedAtLeastOneRestriction) {
          results.remove(result);
          continue;
        }
      }
    }
    Locale[] territories=promo.getTerritories();
    if (territories.length > 0) {
      if (userTerritory == null) {
        results.remove(result);
        continue;
      }
 else {
        boolean matchAtLeastOneTerritory=false;
        for (        Locale territory : territories) {
          if (userTerritory.equalsIgnoreCase(territory.getCountry())) {
            matchAtLeastOneTerritory=true;
            break;
          }
        }
        if (!matchAtLeastOneTerritory) {
          results.remove(result);
          continue;
        }
      }
    }
  }
}","/** 
 * Strips out results that don't seem to be valid due to territory, radius, or other restriction.
 */
private void removeInvalidResults(List<QueryResult> results,Date timeQueried){
  for (  QueryResult result : new ArrayList<QueryResult>(results)) {
    PromotionMessageContainer promo=result.getPromotionMessageContainer();
    List<GeoRestriction> restrictions=promo.getGeoRestrictions();
    if (restrictions.size() > 0) {
      if (userLatLon == null) {
        results.remove(result);
        continue;
      }
 else {
        boolean matchedAtLeastOneRestriction=false;
        for (        GeoRestriction restriction : restrictions) {
          if (restriction.contains(userLatLon)) {
            matchedAtLeastOneRestriction=true;
            break;
          }
        }
        if (!matchedAtLeastOneRestriction) {
          results.remove(result);
          continue;
        }
      }
    }
    Locale[] territories=promo.getTerritories();
    if (territories.length > 0) {
      if (userTerritory == null) {
        results.remove(result);
        continue;
      }
 else {
        boolean matchAtLeastOneTerritory=false;
        for (        Locale territory : territories) {
          if (userTerritory.equalsIgnoreCase(territory.getCountry())) {
            matchAtLeastOneTerritory=true;
            break;
          }
        }
        if (!matchAtLeastOneTerritory) {
          results.remove(result);
          continue;
        }
      }
    }
    if (!isMessageValid(result.getPromotionMessageContainer(),result.getBinderUniqueName(),timeQueried.getTime())) {
      results.remove(result);
      continue;
    }
  }
}",0.9400386847195358
4110,"public void run(){
  final Date timeQueried=new Date();
  PromotionBinder binder=null;
  List<QueryResult> results=null;
  binder=promotionBinderRepository.getBinderForBucket(keywordUtil.getHashValue(normalizedQuery));
  try {
    if (binder != null) {
      searcherDatabase.ingest(binder);
    }
    searcherDatabase.expungeExpired();
    results=searcherDatabase.query(normalizedQuery);
  }
 catch (  DatabaseExecutionException e) {
    promotionServices.shutDown();
  }
  if (results == null) {
    return;
  }
  removeInvalidResults(results);
  int shownResults=0;
  for (  QueryResult result : results) {
    final float probability=result.getPromotionMessageContainer().getProbability();
    if (Math.random() <= probability) {
      if (isMessageValid(result.getPromotionMessageContainer(),result.getBinderUniqueName(),timeQueried.getTime())) {
        if (!result.getPromotionMessageContainer().isImpressionOnly()) {
          shownResults++;
          callback.process(result.getPromotionMessageContainer());
        }
        impressionsCollector.recordImpression(query,timeQueried,new Date(),result.getPromotionMessageContainer(),result.getBinderUniqueName());
      }
    }
    if (shownResults >= maxNumberOfResults)     break;
  }
}","public void run(){
  final Date timeQueried=new Date();
  PromotionBinder binder=null;
  List<QueryResult> results=null;
  binder=promotionBinderRepository.getBinderForBucket(keywordUtil.getHashValue(normalizedQuery));
  try {
    if (binder != null) {
      searcherDatabase.ingest(binder);
    }
    searcherDatabase.expungeExpired();
    results=searcherDatabase.query(normalizedQuery);
  }
 catch (  DatabaseExecutionException e) {
    promotionServices.shutDown();
  }
  if (results == null) {
    return;
  }
  removeInvalidResults(results,timeQueried);
  List<QueryResult> visibleResults=new ArrayList<QueryResult>(results.size());
  for (  QueryResult result : results) {
    if (result.getPromotionMessageContainer().isImpressionOnly()) {
      impressionsCollector.recordImpression(query,timeQueried,new Date(),result.getPromotionMessageContainer(),result.getBinderUniqueName());
    }
 else {
      visibleResults.add(result);
    }
  }
  int shownResults=0;
  int idx=0;
  for (  QueryResult result : visibleResults) {
    final float probability=result.getPromotionMessageContainer().getProbability();
    int remainingToIterateThrough=visibleResults.size() - idx;
    int remainingMaxToShow=maxNumberOfResults - shownResults;
    if (remainingToIterateThrough <= remainingMaxToShow || Math.random() <= probability) {
      shownResults++;
      callback.process(result.getPromotionMessageContainer());
      impressionsCollector.recordImpression(query,timeQueried,new Date(),result.getPromotionMessageContainer(),result.getBinderUniqueName());
    }
    idx++;
    if (shownResults >= maxNumberOfResults)     break;
  }
}",0.5031228313671062
4111,"public void run(){
  try {
    ServerSocket ss=new ServerSocket(PORT);
    Socket s=ss.accept();
    InputStream in=s.getInputStream();
    BufferedReader BR=new BufferedReader(new InputStreamReader(in));
    String input=null;
    int length=0;
    while ((input=BR.readLine()).length() != 0) {
      if (input.toLowerCase().startsWith(""String_Node_Str"")) {
        length=Integer.parseInt(input.substring(input.indexOf(""String_Node_Str"") + 2));
      }
    }
    char[] content=new char[length];
    BR.read(content,0,length);
    String contentAsString=new String(content);
    userComments=contentAsString.substring(contentAsString.indexOf(""String_Node_Str"") + 4);
    OutputStream out=s.getOutputStream();
    String response;
    response=""String_Node_Str"";
    out.write(response.getBytes());
    out.flush();
    response=""String_Node_Str"";
    out.write(response.getBytes());
    out.flush();
    s.close();
  }
 catch (  IOException ex) {
    fail(ex);
  }
}","public void run(){
  try {
    ServerSocket ss=new ServerSocket(port);
    Socket s=ss.accept();
    InputStream in=s.getInputStream();
    BufferedReader BR=new BufferedReader(new InputStreamReader(in));
    String input=null;
    int length=0;
    while ((input=BR.readLine()).length() != 0) {
      if (input.toLowerCase().startsWith(""String_Node_Str"")) {
        length=Integer.parseInt(input.substring(input.indexOf(""String_Node_Str"") + 2));
      }
    }
    char[] content=new char[length];
    BR.read(content,0,length);
    contentAsString=new String(content);
    OutputStream out=s.getOutputStream();
    String response;
    response=""String_Node_Str"";
    out.write(response.getBytes());
    out.flush();
    response=""String_Node_Str"";
    out.write(response.getBytes());
    out.flush();
    s.close();
  }
 catch (  IOException ex) {
    fail(ex);
  }
}",0.9417528579205224
4112,"@Override protected void readTag(AudioFile audioFile,Tag tag){
  if (tag != null) {
    audioData.setTitle(tag.getFirstTitle());
    audioData.setArtist(tag.getFirstArtist());
    audioData.setAlbum(tag.getFirstAlbum());
    audioData.setYear(tag.getFirstYear());
    audioData.setComment(tag.getFirstComment());
    audioData.setGenre(tag.getFirstGenre());
    try {
      audioData.setTrack(tag.getFirstTrack());
    }
 catch (    UnsupportedOperationException e) {
    }
    if (!(tag instanceof ID3v1Tag)) {
      audioData.setLicense(tag.getFirst(ID3v24Frames.FRAME_ID_COPYRIGHTINFO));
      MP3File mp3File=((MP3File)audioFile);
      audioData.setGenre(parseGenre(tag.getFirstGenre()));
      AbstractID3v2Tag vTag=mp3File.getID3v2Tag();
      if (vTag != null) {
        List<TagField> license=vTag.get(PRIV_ID);
        List<TagField> priv=vTag.get(PRIV_ID);
        Iterator<TagField> iter=license.iterator();
        while (iter.hasNext()) {
          TagField t=iter.next();
          checkLWS(t.toString());
        }
        iter=priv.iterator();
        while (iter.hasNext()) {
          TagField t=iter.next();
          checkLWS(t.toString());
          try {
            isPRIVCheck(t.getRawContent());
          }
 catch (          UnsupportedEncodingException e) {
          }
        }
        AbstractID3v2Frame frame=vTag.getFirstField(ID3v24Frames.FRAME_ID_COPYRIGHTINFO);
        if (frame != null && !frame.isEmpty() && frame.getBody() instanceof AbstractFrameBodyTextInfo)         audioData.setLicense(((AbstractFrameBodyTextInfo)frame.getBody()).getText());
      }
    }
  }
}","@Override protected void readTag(AudioFile audioFile,Tag tag){
  MP3File mp3File=((MP3File)audioFile);
  mp3File.getID3v1Tag();
  AbstractID3v2Tag v2Tag=mp3File.getID3v2Tag();
  ID3v1Tag v1Tag=mp3File.getID3v1Tag();
  if (v2Tag != null)   readV2Tag(v2Tag);
  if (v1Tag != null)   readV1Tag(v1Tag);
}",0.1868766404199475
4113,"/** 
 * Some genres in ID3v2 tags are displaying (XXX) numbers along side the genre. If this exists it hides the number from the user
 * @param genre
 * @return
 */
private String parseGenre(String genre){
  if (genre == null || genre.length() <= 0)   return genre;
  String cleanGenre=genre;
  if (genre.charAt(0) == '(') {
    int startIndex=0;
    for (int i=0; i < genre.length(); i++) {
      if (genre.charAt(i) == ')') {
        startIndex=i + 1;
      }
    }
    cleanGenre=genre.substring(startIndex);
  }
  return cleanGenre;
}","/** 
 * Some genres in ID3v2 tags are displaying (XXX) numbers along side the genre. If this exists it hides the number from the user
 */
private String parseGenre(String genre){
  if (genre == null || genre.length() <= 0)   return genre;
  String cleanGenre=genre;
  if (genre.charAt(0) == '(') {
    int startIndex=0;
    for (int i=0; i < genre.length(); i++) {
      if (genre.charAt(i) == ')') {
        startIndex=i + 1;
      }
    }
    cleanGenre=genre.substring(startIndex);
  }
  return cleanGenre;
}",0.9742612011439468
4114,"/** 
 * Creates MetaData for the file, if possible. 
 */
public MetaReader parse(File f) throws IOException {
  try {
    if (LimeXMLUtils.isSupportedAudioFormat(f))     return parseAudioFile(f);
 else     if (LimeXMLUtils.isSupportedVideoFormat(f))     return parseVideoMetaData(f);
 else     if (LimeXMLUtils.isSupportedMultipleFormat(f))     return parseMultipleFormat(f);
  }
 catch (  OutOfMemoryError e) {
    LOG.warn(""String_Node_Str"",e);
  }
  return null;
}","/** 
 * Creates MetaData for the file, if possible. 
 */
public MetaReader parse(File f) throws IOException {
  try {
    if (LimeXMLUtils.isSupportedAudioFormat(f))     return parseAudioFile(f);
 else     if (LimeXMLUtils.isSupportedVideoFormat(f))     return parseVideoMetaData(f);
 else     if (LimeXMLUtils.isSupportedMultipleFormat(f))     return parseMultipleFormat(f);
  }
 catch (  OutOfMemoryError e) {
    LOG.warn(""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    return null;
  }
  return null;
}",0.9396378269617708
4115,"/** 
 * Reads the meta data for the audio file if LimeWire can parse it, otherwise return null if file type is not supported
 */
private MetaReader parseAudioFile(File f) throws IOException {
  if (LimeXMLUtils.isMP3File(f))   return new MP3MetaData(f);
  if (LimeXMLUtils.isOGGFile(f))   return new OGGMetaData(f);
  if (LimeXMLUtils.isFLACFile(f))   return new AudioDataReader(f);
  if (LimeXMLUtils.isM4AFile(f))   return new AudioDataReader(f);
  if (LimeXMLUtils.isWMAFile(f))   return new WMAMetaData(f);
  return null;
}","/** 
 * Reads the meta data for the audio file if LimeWire can parse it, otherwise return null if file type is not supported
 */
private MetaReader parseAudioFile(File f) throws IOException, IllegalArgumentException {
  if (LimeXMLUtils.isMP3File(f))   return new MP3MetaData(f);
  if (LimeXMLUtils.isOGGFile(f))   return new OGGMetaData(f);
  if (LimeXMLUtils.isFLACFile(f))   return new AudioDataReader(f);
  if (LimeXMLUtils.isM4AFile(f))   return new AudioDataReader(f);
  if (LimeXMLUtils.isWMAFile(f))   return new WMAMetaData(f);
  return null;
}",0.975925925925926
4116,"public AudioDataReader(File f) throws IOException {
  audioData=new AudioMetaData();
  parseFile(f);
}","public AudioDataReader(File f) throws IOException, IllegalArgumentException {
  audioData=new AudioMetaData();
  parseFile(f);
}",0.8869565217391304
4117,"/** 
 * Handles the reading and parsing of this file
 * @param file - file to read
 * @throws IOException - thrown if the file can't be read, is corrupted, etc..
 */
private void parseFile(File file) throws IOException {
  try {
    AudioFile audioFile=AudioFileIO.read(file);
    readHeader(audioFile.getAudioHeader());
    readTag(audioFile,audioFile.getTag());
  }
 catch (  CannotReadException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  TagException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  ReadOnlyFileException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InvalidAudioFrameException e) {
    throw (IOException)new IOException().initCause(e);
  }
}","/** 
 * Handles the reading and parsing of this file
 * @param file - file to read
 * @throws IOException - thrown if the file can't be read, is corrupted, etc..
 */
private void parseFile(File file) throws IOException, IllegalArgumentException {
  try {
    AudioFile audioFile=AudioFileIO.read(file);
    readHeader(audioFile.getAudioHeader());
    readTag(audioFile,audioFile.getTag());
  }
 catch (  CannotReadException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  TagException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  ReadOnlyFileException e) {
    throw (IOException)new IOException().initCause(e);
  }
catch (  InvalidAudioFrameException e) {
    throw (IOException)new IOException().initCause(e);
  }
}",0.9828269484808454
4118,"public MP3MetaData(File f) throws IOException {
  super(f);
}","public MP3MetaData(File f) throws IOException, IllegalArgumentException {
  super(f);
}",0.8243243243243243
4119,"public OGGMetaData(File f) throws IOException {
  super(f);
}","public OGGMetaData(File f) throws IOException, IllegalArgumentException {
  super(f);
}",0.8243243243243243
4120,"/** 
 * decodes an interval set encoded with: http://www.limewire.org/wiki/index.php?title=HashTreeRangeEncoding
 * @param maxSize the size of the file
 * @param id integers from the encoding
 */
public void decode(long maxSize,Integer... id){
  long numLeafs=getNumLeafs(maxSize);
  TreeStorage ts=new TreeStorage(null,new NodeGenerator.NullGenerator(),(int)numLeafs);
  for (  int i : id) {
    if (!ts.isValidId(i))     continue;
    int[] nodes=ts.nodeToFileId(i);
    Range r=Range.createRange(nodes[0] * 1024L,Math.min((nodes[1] + 1) * 1024L - 1,maxSize - 1));
    add(r);
  }
}","/** 
 * decodes an interval set encoded with: http://www.limewire.org/wiki/index.php?title=HashTreeRangeEncoding
 * @param maxSize the size of the file
 * @param id integers from the encoding
 */
public void decode(long maxSize,Integer... id){
  long numLeafs=getNumLeafs(maxSize);
  TreeStorage ts=new TreeStorage(null,new NodeGenerator.NullGenerator(),(int)numLeafs);
  for (  int i : id) {
    int[] nodes=ts.nodeToFileId(i);
    if (nodes == null)     continue;
    Range r=Range.createRange(nodes[0] * 1024L,Math.min((nodes[1] + 1) * 1024L - 1,maxSize - 1));
    add(r);
  }
}",0.9339055793991416
4121,"/** 
 * @param nodeId node from the tree
 * @return the start and end index of the chunks from the filethe node maps to
 */
public int[] nodeToFileId(int nodeId){
  if (!isValidId(nodeId))   throw new IllegalArgumentException(""String_Node_Str"" + nodeId + ""String_Node_Str""+ maxId);
  int power=Math.max(1,0x1 << (log2Ceil(maxId) - 1));
  if (nodeId == 1)   return new int[]{0,maxId - power};
  int[] ret=new int[2];
  int times=0;
  while (nodeId < power) {
    times++;
    nodeId<<=1;
  }
  ret[0]=nodeId - power;
  ret[1]=Math.min(maxId - power,ret[0] + (0x1 << times) - 1);
  return ret;
}","/** 
 * @param nodeId node from the tree
 * @return the start and end index of the chunks from the filethe node maps to or null if id is invalid.
 */
public int[] nodeToFileId(int nodeId){
  if (nodeId < 1 || nodeId > maxId)   return null;
  int power=Math.max(1,0x1 << (log2Ceil(maxId) - 1));
  if (nodeId == 1)   return new int[]{0,maxId - power};
  int[] ret=new int[2];
  int times=0;
  while (nodeId < power) {
    times++;
    nodeId<<=1;
  }
  if (nodeId > maxId)   return null;
  ret[0]=nodeId - power;
  ret[1]=Math.min(maxId - power,ret[0] + (0x1 << times) - 1);
  return ret;
}",0.8162574089754445
4122,"/** 
 * @return an IntervalSet contained in this GGEP.  Null if none.
 */
public static IntervalSet decode(long size,GGEP ggep) throws BadGGEPPropertyException {
  if (ggep.hasKey(GGEP.GGEP_HEADER_PARTIAL_RESULT_PREFIX + ""String_Node_Str""))   return new IntervalSet();
  IntervalSet ret=null;
  for (int i=1; i <= 4; i++) {
    String key=GGEP.GGEP_HEADER_PARTIAL_RESULT_PREFIX + i;
    if (ggep.hasKey(key)) {
      byte[] b=ggep.get(key);
      if (b == null)       continue;
      if (ret == null)       ret=new IntervalSet();
      if (b.length % i != 0)       return null;
      for (int j=0; j < b.length; j+=i) {
        int nodeId=0;
        for (int k=0; k < i; k++) {
          nodeId<<=8;
          nodeId|=(b[j + k] & 0xFF);
        }
        try {
          ret.decode(size,nodeId);
        }
 catch (        IllegalArgumentException bad) {
          if (!BugSettings.SEND_TREE_STORAGE_BUGS.getValue())           continue;
          StringBuilder report=new StringBuilder();
          report.append(""String_Node_Str"");
          report.append(""String_Node_Str"").append(size).append(""String_Node_Str"").append(nodeId);
          report.append(""String_Node_Str"").append(key).append(""String_Node_Str"").append(Base32.encode(b));
          report.append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(j);
          report.append(""String_Node_Str"").append(ret);
          throw new IllegalArgumentException(report.toString(),bad);
        }
      }
    }
  }
  return ret;
}","/** 
 * @return an IntervalSet contained in this GGEP.  Null if none.
 */
public static IntervalSet decode(long size,GGEP ggep) throws BadGGEPPropertyException {
  if (ggep.hasKey(GGEP.GGEP_HEADER_PARTIAL_RESULT_PREFIX + ""String_Node_Str""))   return new IntervalSet();
  IntervalSet ret=null;
  for (int i=1; i <= 4; i++) {
    String key=GGEP.GGEP_HEADER_PARTIAL_RESULT_PREFIX + i;
    if (ggep.hasKey(key)) {
      byte[] b=ggep.get(key);
      if (b == null)       continue;
      if (ret == null)       ret=new IntervalSet();
      if (b.length % i != 0)       return null;
      for (int j=0; j < b.length; j+=i) {
        int nodeId=0;
        for (int k=0; k < i; k++) {
          nodeId<<=8;
          nodeId|=(b[j + k] & 0xFF);
        }
        ret.decode(size,nodeId);
      }
    }
  }
  return ret;
}",0.6941074523396881
4123,"public void testInvalid() throws Exception {
  GGEP g=new GGEP();
  byte[] pr1=new byte[]{2,100};
  g.put(""String_Node_Str"",pr1);
  IntervalSet decoded=IntervalEncoder.decode(2048,g);
  assertEquals(1,decoded.getNumberOfIntervals());
  assertEquals(0,decoded.getFirst().getLow());
  assertEquals(1023,decoded.getFirst().getHigh());
}","public void testInvalid() throws Exception {
  GGEP g=new GGEP();
  byte[] pr1=new byte[]{2,100};
  g.put(""String_Node_Str"",pr1);
  IntervalSet decoded=IntervalEncoder.decode(2048,g);
  assertEquals(1,decoded.getNumberOfIntervals());
  assertEquals(0,decoded.getFirst().getLow());
  assertEquals(1023,decoded.getFirst().getHigh());
  String encoded=""String_Node_Str"";
  byte[] pr3=Base32.decode(encoded);
  g=new GGEP();
  g.put(""String_Node_Str"",pr3);
  IntervalEncoder.decode(734147846L,g);
}",0.8053204353083434
4124,"/** 
 * implements interface <tt>Token</tt>
 */
public double getImportance(){
  double importance=_importance;
  if (importance == Double.NaN) {
    importance=(_age * -100.0 * (0.1 + Math.pow(1.0 - getRating(),0.1)));
    _importance=importance;
  }
  return importance;
}","/** 
 * implements interface <tt>Token</tt>
 */
public double getImportance(){
  double importance=_importance;
  if (Double.isNaN(importance)) {
    importance=(_age * -100.0 * (0.1 + Math.pow(1.0 - getRating(),0.1)));
    _importance=importance;
  }
  return importance;
}",0.5766423357664233
4125,"public static void encode(long size,GGEP g,IntervalSet s){
  List<Integer> bytes=new ArrayList<Integer>();
  List<Integer> shorts=new ArrayList<Integer>();
  List<Integer> b24=new ArrayList<Integer>();
  List<Integer> ints=new ArrayList<Integer>();
  for (  int i : s.encode(size)) {
    long l=i & 0xFFFFFFFF;
    if (l > 0xFFFFFFL)     ints.add(i);
 else     if (l > 0xFFFF)     b24.add(i);
 else     if (l > 0xFF)     shorts.add(i);
 else     bytes.add(i);
  }
  byte[] bytesB=new byte[bytes.size()];
  for (int i=0; i < bytesB.length; i++)   bytesB[i]=(byte)bytes.get(i).intValue();
  byte[] shortsB=new byte[shorts.size() * 2];
  for (int i=0; i < shorts.size(); i++)   ByteOrder.short2beb(shorts.get(i).shortValue(),shortsB,i * 2);
  byte[] b24B=new byte[b24.size() * 3];
  for (int i=0; i < b24.size(); i++) {
    int value=b24.get(i);
    b24B[i]=(byte)((value & 0xFF0000) >> 16);
    b24B[i + 1]=(byte)((value & 0xFF00) >> 8);
    b24B[i + 2]=(byte)(value & 0xFF);
  }
  byte[] intsB=new byte[ints.size() * 4];
  for (int i=0; i < ints.size(); i++)   ByteOrder.int2beb(ints.get(i).intValue(),intsB,i * 4);
  int availableSpace=SharingSettings.MAX_PARTIAL_ENCODING_SIZE.getValue();
  availableSpace=addIfSpace(bytesB,g,1,availableSpace);
  availableSpace=addIfSpace(shortsB,g,2,availableSpace);
  availableSpace=addIfSpace(b24B,g,3,availableSpace);
  addIfSpace(intsB,g,4,availableSpace);
  if (bytes.size() + shorts.size() + b24.size()+ ints.size() == 0)   g.put(GGEP.GGEP_HEADER_PARTIAL_RESULT_PREFIX + ""String_Node_Str"");
}","public static void encode(long size,GGEP g,IntervalSet s){
  List<Integer> bytes=new ArrayList<Integer>();
  List<Integer> shorts=new ArrayList<Integer>();
  List<Integer> b24=new ArrayList<Integer>();
  List<Integer> ints=new ArrayList<Integer>();
  for (  int i : s.encode(size)) {
    long l=i & 0xFFFFFFFF;
    if (l > 0xFFFFFFL)     ints.add(i);
 else     if (l > 0xFFFF)     b24.add(i);
 else     if (l > 0xFF)     shorts.add(i);
 else     bytes.add(i);
  }
  byte[] bytesB=new byte[bytes.size()];
  for (int i=0; i < bytesB.length; i++)   bytesB[i]=(byte)bytes.get(i).intValue();
  byte[] shortsB=new byte[shorts.size() * 2];
  for (int i=0; i < shorts.size(); i++)   ByteOrder.short2beb(shorts.get(i).shortValue(),shortsB,i * 2);
  byte[] b24B=new byte[b24.size() * 3];
  for (int i=0; i < b24.size(); i++) {
    int value=b24.get(i);
    b24B[i * 3]=(byte)((value & 0xFF0000) >> 16);
    b24B[i * 3 + 1]=(byte)((value & 0xFF00) >> 8);
    b24B[i * 3 + 2]=(byte)(value & 0xFF);
  }
  byte[] intsB=new byte[ints.size() * 4];
  for (int i=0; i < ints.size(); i++)   ByteOrder.int2beb(ints.get(i).intValue(),intsB,i * 4);
  int availableSpace=SharingSettings.MAX_PARTIAL_ENCODING_SIZE.getValue();
  availableSpace=addIfSpace(bytesB,g,1,availableSpace);
  availableSpace=addIfSpace(shortsB,g,2,availableSpace);
  availableSpace=addIfSpace(b24B,g,3,availableSpace);
  addIfSpace(intsB,g,4,availableSpace);
  if (bytes.size() + shorts.size() + b24.size()+ ints.size() == 0)   g.put(GGEP.GGEP_HEADER_PARTIAL_RESULT_PREFIX + ""String_Node_Str"");
}",0.9961038961038962
4126,"/** 
 * Sets the new incoming status. Returns whether or not the status changed.
 */
boolean setIncoming(boolean canReceiveIncoming){
  if (_acceptedIncoming == canReceiveIncoming)   return false;
  if (canReceiveIncoming) {
    Future<?> resetter=resetterFuture;
    if (resetter != null)     resetter.cancel(false);
  }
  _acceptedIncoming=canReceiveIncoming;
  activityCallback.get().acceptedIncomingChanged(canReceiveIncoming);
  return true;
}","/** 
 * Sets the new incoming status. Returns whether or not the status changed.
 */
boolean setIncoming(boolean canReceiveIncoming){
  if (canReceiveIncoming) {
    Future<?> resetter=resetterFuture;
    if (resetter != null)     resetter.cancel(false);
  }
  if (_acceptedIncoming == canReceiveIncoming)   return false;
  _acceptedIncoming=canReceiveIncoming;
  activityCallback.get().acceptedIncomingChanged(canReceiveIncoming);
  return true;
}",0.859375
4127,"public int read(ByteBuffer dst) throws IOException {
  if (shutdown)   throw new ClosedChannelException();
  if (taskScheduled)   return 0;
  int transferred=0;
  if (readOutgoing != null && readOutgoing.position() > 0) {
    transferred+=BufferUtils.transfer(readOutgoing,dst);
    if (readOutgoing.hasRemaining()) {
      LOG.debug(""String_Node_Str"");
      return transferred;
    }
  }
  while (true) {
    if (firstReadDone.get() && !dst.hasRemaining() && engine.getHandshakeStatus() == HandshakeStatus.NOT_HANDSHAKING) {
      LOG.debug(""String_Node_Str"");
      return transferred;
    }
    int read=-1;
    while (readIncoming.hasRemaining() && (read=readSink.read(readIncoming)) > 0)     ;
    if (read == -1 && readIncoming.position() == 0) {
      LOG.debug(""String_Node_Str"");
      return -1;
    }
    if (readIncoming.position() == 0) {
      LOG.debug(""String_Node_Str"");
      return 0;
    }
    readIncoming.flip();
    SSLEngineResult result=engine.unwrap(readIncoming,dst);
    readProduced+=result.bytesProduced();
    readConsumed+=result.bytesConsumed();
    transferred+=result.bytesProduced();
    SSLEngineResult.Status status=result.getStatus();
    if (status == Status.BUFFER_OVERFLOW) {
      if (readOutgoing == null) {
synchronized (initLock) {
          if (!shutdown)           readOutgoing=byteBufferCache.getHeap(engine.getSession().getPacketBufferSize());
        }
      }
      result=engine.unwrap(readIncoming,readOutgoing);
      readProduced+=result.bytesProduced();
      readConsumed+=result.bytesConsumed();
      status=result.getStatus();
      if (status == Status.BUFFER_OVERFLOW)       throw new IllegalStateException(""String_Node_Str"" + readOutgoing + ""String_Node_Str""+ readIncoming);
      transferred+=BufferUtils.transfer(readOutgoing,dst);
    }
    firstReadDone.set(true);
    if (readIncoming.hasRemaining()) {
      readDataLeft=true;
      readIncoming.compact();
    }
 else {
      readDataLeft=false;
      readIncoming.clear();
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + result + ""String_Node_Str""+ transferred);
    if (status == Status.BUFFER_UNDERFLOW) {
      if (transferred == 0 && read == -1) {
        LOG.debug(""String_Node_Str"");
        return -1;
      }
 else {
        return transferred;
      }
    }
    if (status == Status.CLOSED) {
      if (transferred == 0)       return -1;
 else       return transferred;
    }
    if (!processHandshakeResult(true,false,result.getHandshakeStatus()))     return transferred;
  }
}","public int read(ByteBuffer dst) throws IOException {
  if (shutdown)   throw new ClosedChannelException();
  if (taskScheduled)   return 0;
  int transferred=0;
  if (readOutgoing != null && readOutgoing.position() > 0) {
    transferred+=BufferUtils.transfer(readOutgoing,dst);
    if (readOutgoing.hasRemaining()) {
      LOG.debug(""String_Node_Str"");
      return transferred;
    }
  }
  while (true) {
    if (firstReadDone.get() && !dst.hasRemaining() && engine.getHandshakeStatus() == HandshakeStatus.NOT_HANDSHAKING) {
      LOG.debug(""String_Node_Str"");
      return transferred;
    }
    int read=-1;
    while (readIncoming.hasRemaining() && (read=readSink.read(readIncoming)) > 0)     ;
    if (read == -1 && readIncoming.position() == 0) {
      LOG.debug(""String_Node_Str"");
      return -1;
    }
    if (readIncoming.position() == 0) {
      LOG.debug(""String_Node_Str"");
      return 0;
    }
    readIncoming.flip();
    SSLEngineResult result=engine.unwrap(readIncoming,dst);
    readProduced+=result.bytesProduced();
    readConsumed+=result.bytesConsumed();
    transferred+=result.bytesProduced();
    SSLEngineResult.Status status=result.getStatus();
    if (status == Status.BUFFER_OVERFLOW) {
      if (readOutgoing == null) {
synchronized (initLock) {
          if (!shutdown)           readOutgoing=byteBufferCache.getHeap(engine.getSession().getApplicationBufferSize());
        }
      }
      result=engine.unwrap(readIncoming,readOutgoing);
      readProduced+=result.bytesProduced();
      readConsumed+=result.bytesConsumed();
      status=result.getStatus();
      if (status == Status.BUFFER_OVERFLOW)       throw new IllegalStateException(""String_Node_Str"" + readOutgoing + ""String_Node_Str""+ readIncoming+ ""String_Node_Str""+ engine.getSession().getPacketBufferSize()+ ""String_Node_Str""+ engine.getSession().getApplicationBufferSize());
      transferred+=BufferUtils.transfer(readOutgoing,dst);
    }
    firstReadDone.set(true);
    if (readIncoming.hasRemaining()) {
      readDataLeft=true;
      readIncoming.compact();
    }
 else {
      readDataLeft=false;
      readIncoming.clear();
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + result + ""String_Node_Str""+ transferred);
    if (status == Status.BUFFER_UNDERFLOW) {
      if (transferred == 0 && read == -1) {
        LOG.debug(""String_Node_Str"");
        return -1;
      }
 else {
        return transferred;
      }
    }
    if (status == Status.CLOSED) {
      if (transferred == 0)       return -1;
 else       return transferred;
    }
    if (!processHandshakeResult(true,false,result.getHandshakeStatus()))     return transferred;
  }
}",0.9719122739515198
4128,"/** 
 * Initializes this TLSLayer, using the given address and enabling the given cipherSuites. If clientMode is disabled, client authentication can be turned on/off.
 * @param addr
 * @param cipherSuites
 */
void initialize(SocketAddress addr,String[] cipherSuites,boolean clientMode,boolean needClientAuth){
synchronized (initLock) {
    if (shutdown) {
      LOG.debug(""String_Node_Str"");
      return;
    }
    if (addr != null) {
      if (!(addr instanceof InetSocketAddress))       throw new IllegalArgumentException(""String_Node_Str"");
      InetSocketAddress iaddr=(InetSocketAddress)addr;
      String host=iaddr.getAddress().getHostAddress();
      int port=iaddr.getPort();
      engine=context.createSSLEngine(host,port);
    }
 else {
      engine=context.createSSLEngine();
    }
    engine.setEnabledCipherSuites(cipherSuites);
    engine.setUseClientMode(clientMode);
    if (!clientMode) {
      engine.setWantClientAuth(needClientAuth);
      engine.setNeedClientAuth(needClientAuth);
    }
    SSLSession session=engine.getSession();
    readIncoming=byteBufferCache.getHeap(session.getApplicationBufferSize());
    writeOutgoing=byteBufferCache.getHeap(session.getPacketBufferSize());
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + engine + ""String_Node_Str""+ session);
  }
}","/** 
 * Initializes this TLSLayer, using the given address and enabling the given cipherSuites. If clientMode is disabled, client authentication can be turned on/off.
 * @param addr
 * @param cipherSuites
 */
void initialize(SocketAddress addr,String[] cipherSuites,boolean clientMode,boolean needClientAuth){
synchronized (initLock) {
    if (shutdown) {
      LOG.debug(""String_Node_Str"");
      return;
    }
    if (addr != null) {
      if (!(addr instanceof InetSocketAddress))       throw new IllegalArgumentException(""String_Node_Str"");
      InetSocketAddress iaddr=(InetSocketAddress)addr;
      String host=iaddr.getAddress().getHostAddress();
      int port=iaddr.getPort();
      engine=context.createSSLEngine(host,port);
    }
 else {
      engine=context.createSSLEngine();
    }
    engine.setEnabledCipherSuites(cipherSuites);
    engine.setUseClientMode(clientMode);
    if (!clientMode) {
      engine.setWantClientAuth(needClientAuth);
      engine.setNeedClientAuth(needClientAuth);
    }
    SSLSession session=engine.getSession();
    readIncoming=byteBufferCache.getHeap(session.getPacketBufferSize());
    writeOutgoing=byteBufferCache.getHeap(session.getPacketBufferSize());
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + engine + ""String_Node_Str""+ session);
  }
}",0.993518871521159
4129,"/** 
 * Returns true if the folder is completely shared, false otherwise
 */
public boolean isFolderShared(File f){
  return _sharedDirectories.containsKey(f);
}","/** 
 * Returns true if the folder is completely shared, false otherwise
 */
public boolean isFolderShared(File f){
  if (SharingSettings.DIRECTORIES_TO_SHARE.contains(f))   return true;
  while (f != null && f.getParentFile() != null) {
    f=f.getParentFile();
    if (SharingSettings.DIRECTORIES_TO_SHARE.contains(f))     return true;
  }
  return false;
}",0.4769230769230769
4130,"/** 
 * Returns true if this folder is sharable. <p> Unsharable folders include: <ul> <li>A non-directory or unreadable folder</li> <li>The incomplete directory</li> <li>The 'application special share directory'</li> <li>Any root directory</li> <li>Any directory listed in 'directories not to share' (<i>Only if includeExcludedDirectories is true</i>)</li> </ul>
 * @param folder The folder to check for sharability
 * @param includeExcludedDirectories True if this should exclude the folderfrom sharability if it is listed in DIRECTORIES_NOT_TO_SHARE
 * @return true if the folder can be shared
 */
public boolean isFolderShareable(File folder,boolean includeExcludedDirectories){
  if (!folder.isDirectory() || !folder.canRead())   return false;
  if (folder.equals(SharingSettings.INCOMPLETE_DIRECTORY.getValue()))   return false;
  if (isApplicationSpecialShareDirectory(folder)) {
    return false;
  }
  if (includeExcludedDirectories && _data.DIRECTORIES_NOT_TO_SHARE.contains(folder))   return false;
  File[] faRoots=File.listRoots();
  if (faRoots != null && faRoots.length > 0) {
    for (int i=0; i < faRoots.length; i++) {
      if (folder.equals(faRoots[i]))       return false;
    }
  }
  return true;
}","/** 
 * Returns true if this folder is sharable. <p> Unsharable folders include: <ul> <li>A non-directory or unreadable folder</li> <li>The incomplete directory</li> <li>The 'application special share directory'</li> <li>Any root directory</li> <li>Any directory listed in 'directories not to share' (<i>Only if includeExcludedDirectories is true</i>)</li> </ul>
 * @param folder The folder to check for sharability
 * @param includeExcludedDirectories True if this should exclude the folderfrom sharability if it is listed in DIRECTORIES_NOT_TO_SHARE
 * @return true if the folder can be shared
 */
public boolean isFolderShareable(File folder,boolean includeExcludedDirectories){
  if (!folder.isDirectory() || !folder.canRead())   return false;
  if (folder.equals(SharingSettings.INCOMPLETE_DIRECTORY.getValue()))   return false;
  if (isApplicationSpecialShareDirectory(folder)) {
    return false;
  }
  if (includeExcludedDirectories && _data.DIRECTORIES_NOT_TO_SHARE.contains(folder))   return false;
  File[] faRoots=File.listRoots();
  if (faRoots != null && faRoots.length > 0) {
    for (int i=0; i < faRoots.length; i++) {
      if (folder.equals(faRoots[i]))       return false;
    }
  }
  String name=folder.getName().toLowerCase(Locale.US);
  if (name.equals(""String_Node_Str""))   return false;
 else   if (name.equals(""String_Node_Str"")) {
    String parent=folder.getParent();
    if (parent != null && parent.toLowerCase(Locale.US).equals(""String_Node_Str""))     return false;
  }
  return true;
}",0.8830409356725146
4131,"/** 
 * Returns true iff <tt>file</tt> is a sensitive directory.
 */
public static boolean isSensitiveDirectory(File folder){
  if (folder == null)   return false;
  String userHome=System.getProperty(""String_Node_Str"");
  if (folder.equals(new File(userHome)))   return true;
  String userHomeShortDir=userHome.substring(userHome.lastIndexOf(File.separator) + 1);
  String[] sensitive;
  if (OSUtils.isWindowsVista()) {
    sensitive=new String[]{""String_Node_Str"",userHomeShortDir + File.separator + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isWindows()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isMacOSX()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isPOSIX()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else {
    sensitive=new String[0];
  }
  String folderPath=folder.getPath();
  for (  String name : sensitive) {
    if (folderPath.endsWith(File.separator + name)) {
      return true;
    }
  }
  return false;
}","/** 
 * Returns true iff <tt>file</tt> is a sensitive directory.
 */
public static boolean isSensitiveDirectory(File folder){
  if (folder == null)   return false;
  String userHome=System.getProperty(""String_Node_Str"");
  if (folder.equals(new File(userHome)))   return true;
  String userHomeShortDir=userHome.substring(userHome.lastIndexOf(File.separator) + 1);
  String[] sensitive;
  if (OSUtils.isWindowsVista()) {
    sensitive=new String[]{""String_Node_Str"",userHomeShortDir + File.separator + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isWindows()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isMacOSX()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isPOSIX()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else {
    sensitive=new String[0];
  }
  String folderPath=folder.getPath();
  for (  String name : sensitive) {
    if (folderPath.endsWith(File.separator + name)) {
      return true;
    }
  }
  return false;
}",0.955719557195572
4132,"/** 
 * Recursively adds this directory and all subdirectories to the shared directories as well as queueing their files for sharing.  Does nothing if <tt>directory</tt> doesn't exist, isn't a directory, or has already been added.  This method is thread-safe.  It acquires locks on a per-directory basis.  If the current revision ever changes from the expected revision, this returns immediately.
 * @requires directory is part of DIRECTORIES_TO_SHARE or one of itschildren, and parent is directory's shared parent or null if directory's parent is not shared.
 * @modifies this
 */
private void updateSharedDirectories(File directory,File parent,int revision){
  try {
    directory=FileUtils.getCanonicalFile(directory);
  }
 catch (  IOException e) {
    return;
  }
  if (!directory.exists())   return;
  if (!isFolderShareable(directory,true))   return;
  if (isSensitiveDirectory(directory)) {
    if (_data.SENSITIVE_DIRECTORIES_NOT_TO_SHARE.contains(directory))     return;
    if (_data.SENSITIVE_DIRECTORIES_VALIDATED.contains(directory)) {
      if (!fileManagerController.warnAboutSharingSensitiveDirectory(directory))       return;
    }
  }
  if (_revision != revision)   return;
  boolean isForcedShare=isForcedShareDirectory(directory);
synchronized (this) {
    if (_completelySharedDirectories.contains(directory))     return;
    if (!_storeDirectories.contains(directory))     _completelySharedDirectories.add(directory);
    if (!isForcedShare) {
      dispatchFileEvent(new FileManagerEvent(this,Type.ADD_FOLDER,directory,parent));
    }
  }
  File[] file_list=directory.listFiles(SHAREABLE_FILE_FILTER);
  if (file_list == null)   return;
  for (int i=0; i < file_list.length && _revision == revision; i++)   addFileIfSharedOrStore(file_list[i],EMPTY_DOCUMENTS,true,_revision,null,AddType.ADD_SHARE);
  if (_revision != revision)   return;
  if (isForcedShare)   return;
  File[] dir_list=directory.listFiles(DIRECTORY_FILTER);
  if (dir_list != null) {
    for (int i=0; i < dir_list.length && _revision == revision; i++)     updateSharedDirectories(dir_list[i],directory,revision);
  }
}","/** 
 * Recursively adds this directory and all subdirectories to the shared directories as well as queueing their files for sharing.  Does nothing if <tt>directory</tt> doesn't exist, isn't a directory, or has already been added.  This method is thread-safe.  It acquires locks on a per-directory basis.  If the current revision ever changes from the expected revision, this returns immediately.
 * @requires directory is part of DIRECTORIES_TO_SHARE or one of itschildren, and parent is directory's shared parent or null if directory's parent is not shared.
 * @modifies this
 */
private void updateSharedDirectories(File directory,File parent,int revision){
  try {
    directory=FileUtils.getCanonicalFile(directory);
  }
 catch (  IOException e) {
    return;
  }
  if (!directory.exists())   return;
  if (!isFolderShareable(directory,true))   return;
  if (isSensitiveDirectory(directory)) {
    if (_data.SENSITIVE_DIRECTORIES_NOT_TO_SHARE.contains(directory)) {
      return;
    }
    if (!_data.SENSITIVE_DIRECTORIES_VALIDATED.contains(directory)) {
      if (!fileManagerController.warnAboutSharingSensitiveDirectory(directory))       return;
    }
  }
  if (_revision != revision)   return;
  boolean isForcedShare=isForcedShareDirectory(directory);
synchronized (this) {
    if (_completelySharedDirectories.contains(directory))     return;
    if (!_storeDirectories.contains(directory))     _completelySharedDirectories.add(directory);
    if (!isForcedShare) {
      dispatchFileEvent(new FileManagerEvent(this,Type.ADD_FOLDER,directory,parent));
    }
  }
  File[] file_list=directory.listFiles(SHAREABLE_FILE_FILTER);
  if (file_list == null)   return;
  for (int i=0; i < file_list.length && _revision == revision; i++)   addFileIfSharedOrStore(file_list[i],EMPTY_DOCUMENTS,true,_revision,null,AddType.ADD_SHARE);
  if (_revision != revision)   return;
  if (isForcedShare)   return;
  File[] dir_list=directory.listFiles(DIRECTORY_FILTER);
  if (dir_list != null) {
    for (int i=0; i < dir_list.length && _revision == revision; i++)     updateSharedDirectories(dir_list[i],directory,revision);
  }
}",0.9955114575950862
4133,"/** 
 * Creates a new <tt>URL</tt> based on the IP and port in the location The location MUST be a dotted IP address.
 */
private static IpPort createUrlFromMini(final String location,URN urn,boolean tlsCapable) throws IOException {
  int port=location.indexOf(':');
  final String loc=(port == -1 ? location : location.substring(0,port));
  try {
    new IP(loc);
  }
 catch (  IllegalArgumentException iae) {
    throw new IOException(""String_Node_Str"" + location);
  }
  if (loc.indexOf('/') != -1)   throw new IOException(""String_Node_Str"" + location);
  if (!NetworkUtils.isValidAddress(loc))   throw new IOException(""String_Node_Str"" + location);
  if (port == -1)   port=6346;
 else {
    if (location.length() < port + 1)     throw new IOException(""String_Node_Str"" + location);
    try {
      port=Short.parseShort(location.substring(port + 1));
    }
 catch (    NumberFormatException nfe) {
      throw new IOException(""String_Node_Str"" + location);
    }
  }
  if (!NetworkUtils.isValidPort(port))   throw new IOException(""String_Node_Str"" + port);
  return new ConnectableImpl(loc,port,tlsCapable);
}","/** 
 * Creates a new <tt>URL</tt> based on the IP and port in the location The location MUST be a dotted IP address.
 */
private static IpPort createUrlFromMini(final String location,URN urn,boolean tlsCapable) throws IOException {
  int port=location.indexOf(':');
  final String loc=(port == -1 ? location : location.substring(0,port));
  try {
    new IP(loc);
  }
 catch (  IllegalArgumentException iae) {
    throw new IOException(""String_Node_Str"" + location);
  }
  if (loc.indexOf('/') != -1)   throw new IOException(""String_Node_Str"" + location);
  if (!NetworkUtils.isValidAddress(loc))   throw new IOException(""String_Node_Str"" + location);
  if (port == -1)   port=6346;
 else {
    if (location.length() < port + 1)     throw new IOException(""String_Node_Str"" + location);
    try {
      port=Integer.parseInt(location.substring(port + 1));
    }
 catch (    NumberFormatException nfe) {
      throw new IOException(""String_Node_Str"" + location);
    }
  }
  if (!NetworkUtils.isValidPort(port))   throw new IOException(""String_Node_Str"" + port);
  return new ConnectableImpl(loc,port,tlsCapable);
}",0.9919210053859964
4134,"/** 
 * @return a list of XOR distances from a provided bigint
 */
private static List<BigInteger> getXorDistances(BigInteger local,List<BigInteger> others){
  List<BigInteger> distances=new ArrayList<BigInteger>(others.size());
  for (  BigInteger bi : others) {
    if (!local.equals(bi))     distances.add(local.xor(bi));
  }
  return distances;
}","/** 
 * @return a list of XOR distances from a provided node
 */
private static List<Double> getXorDistances(Double local,List<Double> others){
  List<Double> distances=new ArrayList<Double>(others.size());
  for (  Double l : others) {
    if (l != local)     distances.add((double)((local.longValue() ^ l.longValue())));
  }
  return distances;
}",0.4699140401146132
4135,"public Object getM2(){
  return m2.toByteArray();
}","public Object getM2(){
  return doubleToBytes(m2);
}",0.8155339805825242
4136,"public Object getQ3(){
  return q3.toByteArray();
}","public Object getQ3(){
  return doubleToBytes(q3);
}",0.8155339805825242
4137,"public Object getM4(){
  return m4.toByteArray();
}","public Object getM4(){
  return doubleToBytes(m4);
}",0.8155339805825242
4138,"public Object getM3(){
  return m3.toByteArray();
}","public Object getM3(){
  return doubleToBytes(m3);
}",0.8155339805825242
4139,"public Object getQ1(){
  return q1.toByteArray();
}","public Object getQ1(){
  return doubleToBytes(q1);
}",0.8155339805825242
4140,"public Object getMin(){
  return min.toByteArray();
}","public Object getMin(){
  return doubleToBytes(min);
}",0.8037383177570093
4141,"public Object getAvg(){
  return avg.toByteArray();
}","public Object getAvg(){
  return doubleToBytes(avg);
}",0.8037383177570093
4142,"public Object getMode(){
  return mode.toByteArray();
}","public Object getMode(){
  return doubleToBytes(mode);
}",0.8288288288288288
4143,"public Object getMed(){
  return med.toByteArray();
}","public Object getMed(){
  return doubleToBytes(med);
}",0.822429906542056
4144,"public Object getMax(){
  return max.toByteArray();
}","public Object getMax(){
  return doubleToBytes(max);
}",0.8037383177570093
4145,"/** 
 * Same as <code>getHistogram</code> but operates on <code>BigIntegers</code>.
 */
public static List<Integer> getHistogramBigInt(List<BigInteger> data,int breaks){
  if (data.isEmpty())   return Collections.emptyList();
  List<Integer> ret=new ArrayList<Integer>(breaks);
  for (int i=0; i < breaks; i++)   ret.add(0);
  BigInteger min=Collections.min(data);
  BigInteger max=Collections.max(data);
  BigInteger range=max.subtract(min).add(BigInteger.valueOf(1));
  BigInteger step=range.divide(BigInteger.valueOf(breaks));
  for (  BigInteger point : data) {
    int index=point.subtract(min).divide(step).intValue();
    index=Math.min(index,breaks - 1);
    ret.set(index,ret.get(index) + 1);
  }
  return ret;
}","/** 
 * Same as <code>getHistogram</code> but operates on <code>BigIntegers</code>.
 */
public static List<Integer> getHistogramBigInt(List<BigInteger> data,int breaks){
  if (data.isEmpty())   return Collections.emptyList();
  List<Integer> ret=new ArrayList<Integer>(breaks);
  for (int i=0; i < breaks; i++)   ret.add(0);
  BigInteger min=Collections.min(data);
  BigInteger max=Collections.max(data);
  BigInteger range=max.subtract(min).add(BigInteger.valueOf(1));
  BigInteger step=range.divide(BigInteger.valueOf(breaks));
  if (step.equals(BigInteger.ZERO))   return Collections.emptyList();
  for (  BigInteger point : data) {
    int index=point.subtract(min).divide(step).intValue();
    index=Math.min(index,breaks - 1);
    ret.set(index,ret.get(index) + 1);
  }
  return ret;
}",0.9537037037037036
4146,"public Object getST(){
  return st.toByteArray();
}","public Object getST(){
  return doubleToBytes(st);
}",0.8155339805825242
4147,"/** 
 * Sets the operating system variables.
 */
public static void setOperatingSystems(){
  _isWindows=false;
  _isWindowsNTor2000orXP=false;
  _isWindows2000orXP=false;
  _isWindowsNT=false;
  _isWindowsXP=false;
  _isWindows95=false;
  _isWindows98=false;
  _isWindowsMe=false;
  _isSolaris=false;
  _isLinux=false;
  _isOS2=false;
  _isMacOSX=false;
  String os=System.getProperty(""String_Node_Str"").toLowerCase(Locale.US);
  _isWindows=os.indexOf(""String_Node_Str"") != -1;
  if (os.indexOf(""String_Node_Str"") != -1 || os.indexOf(""String_Node_Str"") != -1 || os.indexOf(""String_Node_Str"") != -1)   _isWindowsNTor2000orXP=true;
  if (os.indexOf(""String_Node_Str"") != -1 || os.indexOf(""String_Node_Str"") != -1)   _isWindows2000orXP=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindowsNT=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindowsXP=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindowsVista=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindows95=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindows98=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindowsMe=true;
  _isSolaris=os.indexOf(""String_Node_Str"") != -1;
  _isLinux=os.indexOf(""String_Node_Str"") != -1;
  _isOS2=os.indexOf(""String_Node_Str"") != -1;
  if (_isWindows || _isLinux)   _supportsTray=true;
  if (os.startsWith(""String_Node_Str"")) {
    if (os.endsWith(""String_Node_Str"")) {
      _isMacOSX=true;
    }
  }
}","/** 
 * Sets the operating system variables.
 */
public static void setOperatingSystems(){
  _isWindows=false;
  _isWindowsVista=false;
  _isWindowsNT=false;
  _isWindowsXP=false;
  _isWindows95=false;
  _isWindows98=false;
  _isWindowsMe=false;
  _isSolaris=false;
  _isLinux=false;
  _isOS2=false;
  _isMacOSX=false;
  String os=System.getProperty(""String_Node_Str"").toLowerCase(Locale.US);
  _isWindows=os.indexOf(""String_Node_Str"") != -1;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindowsNT=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindowsXP=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindowsVista=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindows95=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindows98=true;
  if (os.indexOf(""String_Node_Str"") != -1)   _isWindowsMe=true;
  _isSolaris=os.indexOf(""String_Node_Str"") != -1;
  _isLinux=os.indexOf(""String_Node_Str"") != -1;
  _isOS2=os.indexOf(""String_Node_Str"") != -1;
  if (_isWindows || _isLinux)   _supportsTray=true;
  if (os.startsWith(""String_Node_Str"")) {
    if (os.endsWith(""String_Node_Str"")) {
      _isMacOSX=true;
    }
  }
}",0.3129357087529047
4148,"/** 
 * Returns true iff <tt>file</tt> is a sensitive directory.
 */
public static boolean isSensitiveDirectory(File folder){
  if (folder == null)   return false;
  String userHome=System.getProperty(""String_Node_Str"");
  if (folder.equals(new File(userHome)))   return true;
  String[] sensitive;
  if (OSUtils.isWindows()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isMacOSX()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isPOSIX()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else {
    sensitive=new String[0];
  }
  String folderName=folder.getName();
  for (  String name : sensitive) {
    if (folderName.equals(name))     return true;
  }
  return false;
}","/** 
 * Returns true iff <tt>file</tt> is a sensitive directory.
 */
public static boolean isSensitiveDirectory(File folder){
  if (folder == null)   return false;
  String userHome=System.getProperty(""String_Node_Str"");
  if (folder.equals(new File(userHome)))   return true;
  String userHomeShortDir=userHome.substring(userHome.lastIndexOf(File.separator) + 1);
  String[] sensitive;
  if (OSUtils.isWindowsVista()) {
    sensitive=new String[]{""String_Node_Str"",userHomeShortDir + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isWindows()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isMacOSX()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else   if (OSUtils.isPOSIX()) {
    sensitive=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  }
 else {
    sensitive=new String[0];
  }
  String folderPath=folder.getPath();
  for (  String name : sensitive) {
    if (folderPath.endsWith(File.separator + name)) {
      return true;
    }
  }
  return false;
}",0.7937203358890106
4149,"/** 
 * Tests whether the FileManager.isSensitiveDirectory(File) function is functioning properly. 
 */
public void testSensitiveDirectoryPredicate() throws Exception {
  File file=null;
  assertFalse(""String_Node_Str"",FileManager.isSensitiveDirectory(file));
  file=new File(""String_Node_Str"");
  assertFalse(""String_Node_Str"",FileManager.isSensitiveDirectory(file));
  String userHome=System.getProperty(""String_Node_Str"");
  assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(userHome)));
  String realOS=System.getProperty(""String_Node_Str"");
  try {
    setOSName(""String_Node_Str"");
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(userHome,""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(userHome,""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    setOSName(""String_Node_Str"");
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    setOSName(""String_Node_Str"");
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
  }
  finally {
    setOSName(realOS);
  }
}","/** 
 * Tests whether the FileManager.isSensitiveDirectory(File) function is functioning properly. 
 */
public void testSensitiveDirectoryPredicate() throws Exception {
  File file=null;
  assertFalse(""String_Node_Str"",FileManager.isSensitiveDirectory(file));
  file=new File(""String_Node_Str"");
  assertFalse(""String_Node_Str"",FileManager.isSensitiveDirectory(file));
  String userHome=System.getProperty(""String_Node_Str"");
  assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(userHome)));
  String realOS=System.getProperty(""String_Node_Str"");
  try {
    setOSName(""String_Node_Str"");
    assertTrue(OSUtils.isWindowsXP());
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    setOSName(""String_Node_Str"");
    assertTrue(OSUtils.isWindowsNT());
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertFalse(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertFalse(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    setOSName(""String_Node_Str"");
    assertTrue(OSUtils.isWindowsVista());
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(userHome + File.separator + ""String_Node_Str"")));
    assertFalse(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    setOSName(""String_Node_Str"");
    assertTrue(OSUtils.isWindows95());
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(userHome + File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(userHome + File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    setOSName(""String_Node_Str"");
    assertTrue(OSUtils.isWindows98());
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(userHome + File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    setOSName(""String_Node_Str"");
    assertTrue(OSUtils.isWindowsMe());
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(userHome + File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    setOSName(""String_Node_Str"");
    assertTrue(OSUtils.isMacOSX());
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    setOSName(""String_Node_Str"");
    assertTrue(OSUtils.isLinux());
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
    assertTrue(""String_Node_Str"",FileManager.isSensitiveDirectory(new File(File.separator + ""String_Node_Str"")));
  }
  finally {
    setOSName(realOS);
  }
}",0.5933321757249522
4150,"/** 
 * @return true if continuing is hopeless
 */
public boolean shouldStop(){
  return linkManager.getNumConnections() == 0 && _peers.size() == 0 && state.getLock() != TorrentState.SEEDING;
}","/** 
 * @return true if continuing is hopeless
 */
public boolean shouldStop(){
  return linkManager.getNumConnections() == 0 && _peers.size() == 0 && state.get() != TorrentState.SEEDING;
}",0.9895287958115184
4151,"public void startElement(String namespaceUri,String localName,String qualifiedName,Attributes attributes){
  if (_isFirstElement) {
    _isFirstElement=false;
    _result.canonicalKeyPrefix=qualifiedName;
    return;
  }
  if (_result.type == null) {
    _result.type=qualifiedName;
    _result.schemaURI=""String_Node_Str"" + _result.type + ""String_Node_Str"";
    _result.canonicalKeyPrefix+=""String_Node_Str"" + qualifiedName + ""String_Node_Str"";
  }
  int attributesLength=attributes.getLength();
  if (attributesLength > 0) {
    Map<String,String> attributeMap=new HashMap<String,String>(attributesLength);
    for (int i=0; i < attributesLength; i++) {
      attributeMap.put(_result.canonicalKeyPrefix + attributes.getQName(i) + ""String_Node_Str"",attributes.getValue(i).trim());
    }
    _result.add(attributeMap);
  }
 else {
    Map<String,String> empty=Collections.emptyMap();
    _result.add(empty);
  }
}","public void startElement(String namespaceUri,String localName,String qualifiedName,Attributes attributes){
  if (_isFirstElement) {
    _isFirstElement=false;
    _result.canonicalKeyPrefix=qualifiedName;
    return;
  }
  if (_result.type == null) {
    _result.type=qualifiedName;
    _result.schemaURI=""String_Node_Str"" + _result.type + ""String_Node_Str"";
    _result.canonicalKeyPrefix+=""String_Node_Str"" + qualifiedName + ""String_Node_Str"";
  }
  int attributesLength=attributes.getLength();
  _result.canonicalKeyPrefix=_result.canonicalKeyPrefix.toLowerCase(Locale.US);
  if (attributesLength > 0) {
    Map<String,String> attributeMap=new HashMap<String,String>(attributesLength);
    for (int i=0; i < attributesLength; i++) {
      attributeMap.put(_result.canonicalKeyPrefix + attributes.getQName(i) + ""String_Node_Str"",attributes.getValue(i).trim());
    }
    _result.add(attributeMap);
  }
 else {
    Map<String,String> empty=Collections.emptyMap();
    _result.add(empty);
  }
}",0.958071278825996
4152,"private void sendAndAssertResponse(Response resp,GUID guid,boolean expectedToBeFiltered) throws Exception {
  QueryReply reply=KeywordFilterTest.createReply(resp,guid,testUP[0].getPort(),testUP[0].getInetAddress().getAddress());
  callback.guid=reply.getClientGUID();
  callback.desc=null;
  testUP[0].send(reply);
  testUP[0].flush();
  RemoteFileDesc desc=callback.waitForRFD(1000);
  if (expectedToBeFiltered) {
    assertNull(desc);
  }
 else {
    assertNotNull(desc);
    assertEquals(resp.getName(),desc.getFileName());
  }
}","private void sendAndAssertResponse(Response resp,GUID guid,boolean expectedToBeFiltered) throws Exception {
  QueryReply reply=createReply(resp,guid,testUP[0].getPort(),testUP[0].getInetAddress().getAddress());
  callback.guid=reply.getClientGUID();
  callback.desc=null;
  testUP[0].send(reply);
  testUP[0].flush();
  RemoteFileDesc desc=callback.waitForRFD(1000);
  if (expectedToBeFiltered) {
    assertNull(desc);
  }
 else {
    assertNotNull(desc);
    assertEquals(resp.getName(),desc.getFileName());
  }
}",0.982791586998088
4153,"/** 
 * Overloaded constructor that allows the creation of Responses with meta-data and a <tt>Set</tt> of <tt>URN</tt> instances.  This  is the primary constructor that establishes all of the class's  invariants, does any necessary parameter validation, etc. If extensions is non-null, it is used as the extBytes instead of creating them from the urns and locations.
 * @param index the index of the file referenced in the response
 * @param size the size of the file (in bytes)
 * @param name the name of the file
 * @param urns the <tt>Set</tt> of <tt>URN</tt> instances associatedwith the file
 * @param doc the <tt>LimeXMLDocument</tt> instance associated withthe file
 * @param endpoints a collection of other locations on this networkthat will have this file
 * @param extensions The raw unparsed extension bytes.
 */
public Response(long index,long size,String name,Set<? extends URN> urns,LimeXMLDocument doc,Set<? extends IpPort> alternateLocations,long creationTime,byte[] extensions){
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IllegalArgumentException(""String_Node_Str"" + index);
  if (size < 0 || size > MAX_FILE_SIZE)   throw new IllegalArgumentException(""String_Node_Str"" + size);
  this.index=index;
  this.size=size;
  if (name == null)   this.name=""String_Node_Str"";
 else   this.name=name;
  isMetaFile=this.name.toLowerCase().endsWith(""String_Node_Str"");
  byte[] temp=null;
  try {
    temp=this.name.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException namex) {
    ErrorService.error(namex);
  }
  this.nameBytes=temp;
  if (urns == null)   this.urns=Collections.emptySet();
 else   this.urns=Collections.unmodifiableSet(urns);
  this.alternateLocations=alternateLocations;
  this.creationTime=creationTime;
  this.extBytes=extensions;
  this.document=doc;
}","/** 
 * Overloaded constructor that allows the creation of Responses with meta-data and a <tt>Set</tt> of <tt>URN</tt> instances.  This  is the primary constructor that establishes all of the class's  invariants, does any necessary parameter validation, etc. If extensions is non-null, it is used as the extBytes instead of creating them from the urns and locations.
 * @param index the index of the file referenced in the response
 * @param size the size of the file (in bytes)
 * @param name the name of the file
 * @param incomingNameByteArraySize TODO
 * @param urns the <tt>Set</tt> of <tt>URN</tt> instances associatedwith the file
 * @param doc the <tt>LimeXMLDocument</tt> instance associated withthe file
 * @param extensions The raw unparsed extension bytes.
 * @param endpoints a collection of other locations on this networkthat will have this file
 */
public Response(long index,long size,String name,int incomingNameByteArraySize,Set<? extends URN> urns,LimeXMLDocument doc,Set<? extends IpPort> alternateLocations,long creationTime,byte[] extensions){
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IllegalArgumentException(""String_Node_Str"" + index);
  if (size < 0 || size > MAX_FILE_SIZE)   throw new IllegalArgumentException(""String_Node_Str"" + size);
  this.index=index;
  this.size=size;
  if (name == null)   this.name=""String_Node_Str"";
 else   this.name=name;
  isMetaFile=this.name.toLowerCase().endsWith(""String_Node_Str"");
  byte[] temp=null;
  try {
    temp=this.name.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException namex) {
    ErrorService.error(namex);
  }
  this.nameBytes=temp;
  if (urns == null)   this.urns=Collections.emptySet();
 else   this.urns=Collections.unmodifiableSet(urns);
  this.alternateLocations=alternateLocations;
  this.creationTime=creationTime;
  this.extBytes=extensions;
  this.incomingNameByteArraySize=incomingNameByteArraySize;
  this.document=doc;
}",0.9022115640820676
4154,"/** 
 * Overloaded constructor that allows the creation of Responses with meta-data and a <tt>Set</tt> of <tt>URN</tt> instances. This is the primary constructor that establishes all of the class's invariants, does any necessary parameter validation, etc. If extensions is non-null, it is used as the extBytes instead of creating them from the urns and locations.
 * @param index the index of the file referenced in the response
 * @param size the size of the file (in bytes)
 * @param name the name of the file
 * @param urns the <tt>Set</tt> of <tt>URN</tt> instances associatedwith the file
 * @param doc the <tt>LimeXMLDocument</tt> instance associated with thefile
 * @param endpoints a collection of other locations on this network thatwill have this file
 * @param extensions The raw unparsed extension bytes.
 */
private Response createResponse(long index,long size,String name,Set<? extends URN> urns,LimeXMLDocument doc,GGEPContainer ggepData,byte[] extensions){
  if (ggepData == null) {
    if (size <= Integer.MAX_VALUE)     ggepData=GGEPContainer.EMPTY;
 else     ggepData=new GGEPContainer(null,-1L,size);
  }
  if (extensions == null)   extensions=createExtBytes(urns,ggepData);
  return new Response(index,size,name,urns,doc,ggepData.locations,ggepData.createTime,extensions);
}","/** 
 * Overloaded constructor that allows the creation of Responses with meta-data and a <tt>Set</tt> of <tt>URN</tt> instances. This is the primary constructor that establishes all of the class's invariants, does any necessary parameter validation, etc. If extensions is non-null, it is used as the extBytes instead of creating them from the urns and locations.
 * @param index the index of the file referenced in the response
 * @param size the size of the file (in bytes)
 * @param name the name of the file
 * @param incomingNameByteArraySize TODO
 * @param urns the <tt>Set</tt> of <tt>URN</tt> instances associatedwith the file
 * @param doc the <tt>LimeXMLDocument</tt> instance associated with thefile
 * @param extensions The raw unparsed extension bytes.
 * @param endpoints a collection of other locations on this network thatwill have this file
 */
private Response createResponse(long index,long size,String name,int incomingNameByteArraySize,Set<? extends URN> urns,LimeXMLDocument doc,GGEPContainer ggepData,byte[] extensions){
  if (ggepData == null) {
    if (size <= Integer.MAX_VALUE)     ggepData=GGEPContainer.EMPTY;
 else     ggepData=new GGEPContainer(null,-1L,size);
  }
  if (extensions == null)   extensions=createExtBytes(urns,ggepData);
  return new Response(index,size,name,incomingNameByteArraySize,urns,doc,ggepData.locations,ggepData.createTime,extensions);
}",0.8954224041682174
4155,"public Response createFromStream(InputStream is) throws IOException {
  long index=ByteOrder.uint2long(ByteOrder.leb2int(is));
  long size=ByteOrder.uint2long(ByteOrder.leb2int(is));
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IOException(""String_Node_Str"" + index);
  if (size < 0)   throw new IOException(""String_Node_Str"" + size);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int c;
  while ((c=is.read()) != 0) {
    if (c == -1)     throw new IOException(""String_Node_Str"");
    baos.write(c);
  }
  String name=new String(baos.toByteArray(),""String_Node_Str"");
  checkFilename(name);
  baos.reset();
  while ((c=is.read()) != 0) {
    if (c == -1)     throw new IOException(""String_Node_Str"");
    baos.write(c);
  }
  byte[] rawMeta=baos.toByteArray();
  if (rawMeta.length == 0) {
    if (is.available() < 16) {
      throw new IOException(""String_Node_Str"");
    }
    return createResponse(index,size,name);
  }
 else {
    HUGEExtension huge=new HUGEExtension(rawMeta);
    Set<URN> urns=huge.getURNS();
    LimeXMLDocument doc=null;
    for (    String next : huge.getMiscBlocks()) {
      doc=createXmlDocument(name,next);
      if (doc != null)       break;
    }
    GGEPContainer ggep=getGGEP(huge.getGGEP());
    if (ggep.size64 > MAX_FILE_SIZE)     throw new IOException(""String_Node_Str"" + ggep.size64);
    if (ggep.size64 > Integer.MAX_VALUE)     size=ggep.size64;
    return createResponse(index,size,name,urns,doc,ggep,rawMeta);
  }
}","public Response createFromStream(InputStream is) throws IOException {
  long index=ByteOrder.uint2long(ByteOrder.leb2int(is));
  long size=ByteOrder.uint2long(ByteOrder.leb2int(is));
  int incomingNameByteArraySize;
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IOException(""String_Node_Str"" + index);
  if (size < 0)   throw new IOException(""String_Node_Str"" + size);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int c;
  while ((c=is.read()) != 0) {
    if (c == -1)     throw new IOException(""String_Node_Str"");
    baos.write(c);
  }
  incomingNameByteArraySize=baos.size();
  String name=new String(baos.toByteArray(),""String_Node_Str"");
  checkFilename(name);
  baos.reset();
  while ((c=is.read()) != 0) {
    if (c == -1)     throw new IOException(""String_Node_Str"");
    baos.write(c);
  }
  byte[] rawMeta=baos.toByteArray();
  if (rawMeta.length == 0) {
    if (is.available() < 16) {
      throw new IOException(""String_Node_Str"");
    }
    return createResponse(index,size,name,incomingNameByteArraySize,null,null,null,null);
  }
 else {
    HUGEExtension huge=new HUGEExtension(rawMeta);
    Set<URN> urns=huge.getURNS();
    LimeXMLDocument doc=null;
    for (    String next : huge.getMiscBlocks()) {
      doc=createXmlDocument(name,next);
      if (doc != null)       break;
    }
    GGEPContainer ggep=getGGEP(huge.getGGEP());
    if (ggep.size64 > MAX_FILE_SIZE)     throw new IOException(""String_Node_Str"" + ggep.size64);
    if (ggep.size64 > Integer.MAX_VALUE)     size=ggep.size64;
    return createResponse(index,size,name,incomingNameByteArraySize,urns,doc,ggep,rawMeta);
  }
}",0.9459807073954984
4156,"protected void createResponseList(QueryReply qr,String response) throws BadPacketException {
  final QueryReply localqr=qr;
  final List<Response> responseList=new Vector<Response>();
  final Response qrResponse;
  long index=0;
  long size=0;
  LimeXMLDocument emptyDoc=null;
  Set<URN> emptyurns=null;
  Set<IpPort> alternateLocations=null;
  long creationTime=0;
  byte[] extensions=null;
  qrResponse=new Response(index,size,response,emptyurns,emptyDoc,alternateLocations,creationTime,extensions);
  responseList.add(qrResponse);
  context.checking(new Expectations(){
{
      one(localqr).getResultsAsList();
      will(returnValue(responseList));
    }
  }
);
}","protected void createResponseList(QueryReply qr,String response) throws BadPacketException {
  final QueryReply localqr=qr;
  final List<Response> responseList=new Vector<Response>();
  final Response qrResponse;
  long index=0;
  long size=0;
  LimeXMLDocument emptyDoc=null;
  Set<URN> emptyurns=null;
  Set<IpPort> alternateLocations=null;
  long creationTime=0;
  byte[] extensions=null;
  qrResponse=new Response(index,size,response,-1,emptyurns,emptyDoc,alternateLocations,creationTime,extensions);
  responseList.add(qrResponse);
  context.checking(new Expectations(){
{
      one(localqr).getResultsAsList();
      will(returnValue(responseList));
    }
  }
);
}",0.9977561705310396
4157,"/** 
 * Overloaded constructor that allows the creation of Responses with meta-data and a <tt>Set</tt> of <tt>URN</tt> instances.  This  is the primary constructor that establishes all of the class's  invariants, does any necessary parameter validation, etc. If extensions is non-null, it is used as the extBytes instead of creating them from the urns and locations.
 * @param index the index of the file referenced in the response
 * @param size the size of the file (in bytes)
 * @param name the name of the file
 * @param urns the <tt>Set</tt> of <tt>URN</tt> instances associatedwith the file
 * @param doc the <tt>LimeXMLDocument</tt> instance associated withthe file
 * @param endpoints a collection of other locations on this networkthat will have this file
 * @param extensions The raw unparsed extension bytes.
 */
Response(long index,long size,String name,Set<? extends URN> urns,LimeXMLDocument doc,Set<? extends IpPort> alternateLocations,long creationTime,byte[] extensions){
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IllegalArgumentException(""String_Node_Str"" + index);
  if (size < 0 || size > MAX_FILE_SIZE)   throw new IllegalArgumentException(""String_Node_Str"" + size);
  this.index=index;
  this.size=size;
  if (name == null)   this.name=""String_Node_Str"";
 else   this.name=name;
  isMetaFile=this.name.toLowerCase().endsWith(""String_Node_Str"");
  byte[] temp=null;
  try {
    temp=this.name.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException namex) {
    ErrorService.error(namex);
  }
  this.nameBytes=temp;
  if (urns == null)   this.urns=Collections.emptySet();
 else   this.urns=Collections.unmodifiableSet(urns);
  this.alternateLocations=alternateLocations;
  this.creationTime=creationTime;
  this.extBytes=extensions;
  this.document=doc;
}","/** 
 * Overloaded constructor that allows the creation of Responses with meta-data and a <tt>Set</tt> of <tt>URN</tt> instances.  This  is the primary constructor that establishes all of the class's  invariants, does any necessary parameter validation, etc. If extensions is non-null, it is used as the extBytes instead of creating them from the urns and locations.
 * @param index the index of the file referenced in the response
 * @param size the size of the file (in bytes)
 * @param name the name of the file
 * @param urns the <tt>Set</tt> of <tt>URN</tt> instances associatedwith the file
 * @param doc the <tt>LimeXMLDocument</tt> instance associated withthe file
 * @param endpoints a collection of other locations on this networkthat will have this file
 * @param extensions The raw unparsed extension bytes.
 */
public Response(long index,long size,String name,Set<? extends URN> urns,LimeXMLDocument doc,Set<? extends IpPort> alternateLocations,long creationTime,byte[] extensions){
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IllegalArgumentException(""String_Node_Str"" + index);
  if (size < 0 || size > MAX_FILE_SIZE)   throw new IllegalArgumentException(""String_Node_Str"" + size);
  this.index=index;
  this.size=size;
  if (name == null)   this.name=""String_Node_Str"";
 else   this.name=name;
  isMetaFile=this.name.toLowerCase().endsWith(""String_Node_Str"");
  byte[] temp=null;
  try {
    temp=this.name.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException namex) {
    ErrorService.error(namex);
  }
  this.nameBytes=temp;
  if (urns == null)   this.urns=Collections.emptySet();
 else   this.urns=Collections.unmodifiableSet(urns);
  this.alternateLocations=alternateLocations;
  this.creationTime=creationTime;
  this.extBytes=extensions;
  this.document=doc;
}",0.9980636237897648
4158,"public void run(){
  ByteBufferCache cache=NIODispatcher.instance().getBufferCache();
  if (readIncoming != null)   cache.release(readIncoming);
  if (readOutgoing != null)   cache.release(readOutgoing);
  if (writeOutgoing != null)   cache.release(writeOutgoing);
}","public void run(){
  if (readIncoming != null)   byteBufferCache.release(readIncoming);
  if (readOutgoing != null)   byteBufferCache.release(readOutgoing);
  if (writeOutgoing != null)   byteBufferCache.release(writeOutgoing);
}",0.7919191919191919
4159,"public SSLReadWriteChannel(SSLContext context,Executor executor){
  this.executor=executor;
  this.context=context;
}","public SSLReadWriteChannel(SSLContext context,Executor sslBlockingExecutor,ByteBufferCache byteBufferCache,Executor networkExecutor){
  this.sslBlockingExecutor=sslBlockingExecutor;
  this.context=context;
  this.byteBufferCache=byteBufferCache;
  this.networkExecutor=networkExecutor;
}",0.3712871287128713
4160,"public int read(ByteBuffer dst) throws IOException {
  if (shutdown)   throw new ClosedChannelException();
  if (taskScheduled)   return 0;
  int transferred=0;
  if (readOutgoing != null && readOutgoing.position() > 0) {
    transferred+=BufferUtils.transfer(readOutgoing,dst);
    if (readOutgoing.hasRemaining()) {
      LOG.debug(""String_Node_Str"");
      return transferred;
    }
  }
  while (true) {
    if (firstReadDone.get() && !dst.hasRemaining() && engine.getHandshakeStatus() == HandshakeStatus.NOT_HANDSHAKING) {
      LOG.debug(""String_Node_Str"");
      return transferred;
    }
    int read=-1;
    while (readIncoming.hasRemaining() && (read=readSink.read(readIncoming)) > 0)     ;
    if (read == -1 && readIncoming.position() == 0) {
      LOG.debug(""String_Node_Str"");
      return -1;
    }
    if (readIncoming.position() == 0) {
      LOG.debug(""String_Node_Str"");
      return 0;
    }
    readIncoming.flip();
    SSLEngineResult result=engine.unwrap(readIncoming,dst);
    readProduced+=result.bytesProduced();
    readConsumed+=result.bytesConsumed();
    transferred+=result.bytesProduced();
    SSLEngineResult.Status status=result.getStatus();
    if (status == Status.BUFFER_OVERFLOW) {
      if (readOutgoing == null) {
synchronized (initLock) {
          if (!shutdown)           readOutgoing=NIODispatcher.instance().getBufferCache().getHeap(engine.getSession().getPacketBufferSize());
        }
      }
      result=engine.unwrap(readIncoming,readOutgoing);
      readProduced+=result.bytesProduced();
      readConsumed+=result.bytesConsumed();
      status=result.getStatus();
      if (status == Status.BUFFER_OVERFLOW)       throw new IllegalStateException(""String_Node_Str"" + readOutgoing + ""String_Node_Str""+ readIncoming);
      transferred+=BufferUtils.transfer(readOutgoing,dst);
    }
    firstReadDone.set(true);
    if (readIncoming.hasRemaining()) {
      readDataLeft=true;
      readIncoming.compact();
    }
 else {
      readDataLeft=false;
      readIncoming.clear();
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + result);
    if (status == Status.BUFFER_UNDERFLOW)     return transferred;
    if (status == Status.CLOSED) {
      if (transferred == 0)       return -1;
 else       return transferred;
    }
    if (!processHandshakeResult(true,false,result.getHandshakeStatus()))     return transferred;
  }
}","public int read(ByteBuffer dst) throws IOException {
  if (shutdown)   throw new ClosedChannelException();
  if (taskScheduled)   return 0;
  int transferred=0;
  if (readOutgoing != null && readOutgoing.position() > 0) {
    transferred+=BufferUtils.transfer(readOutgoing,dst);
    if (readOutgoing.hasRemaining()) {
      LOG.debug(""String_Node_Str"");
      return transferred;
    }
  }
  while (true) {
    if (firstReadDone.get() && !dst.hasRemaining() && engine.getHandshakeStatus() == HandshakeStatus.NOT_HANDSHAKING) {
      LOG.debug(""String_Node_Str"");
      return transferred;
    }
    int read=-1;
    int oldPosition=readIncoming.position();
    while (readIncoming.hasRemaining() && (read=readSink.read(readIncoming)) > 0)     ;
    if (read == -1 && readIncoming.position() == oldPosition) {
      LOG.debug(""String_Node_Str"");
      return -1;
    }
    if (readIncoming.position() == 0) {
      LOG.debug(""String_Node_Str"");
      return 0;
    }
    readIncoming.flip();
    SSLEngineResult result=engine.unwrap(readIncoming,dst);
    readProduced+=result.bytesProduced();
    readConsumed+=result.bytesConsumed();
    transferred+=result.bytesProduced();
    SSLEngineResult.Status status=result.getStatus();
    if (status == Status.BUFFER_OVERFLOW) {
      if (readOutgoing == null) {
synchronized (initLock) {
          if (!shutdown)           readOutgoing=byteBufferCache.getHeap(engine.getSession().getPacketBufferSize());
        }
      }
      result=engine.unwrap(readIncoming,readOutgoing);
      readProduced+=result.bytesProduced();
      readConsumed+=result.bytesConsumed();
      status=result.getStatus();
      if (status == Status.BUFFER_OVERFLOW)       throw new IllegalStateException(""String_Node_Str"" + readOutgoing + ""String_Node_Str""+ readIncoming);
      transferred+=BufferUtils.transfer(readOutgoing,dst);
    }
    firstReadDone.set(true);
    if (readIncoming.hasRemaining()) {
      readDataLeft=true;
      readIncoming.compact();
    }
 else {
      readDataLeft=false;
      readIncoming.clear();
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + result + ""String_Node_Str""+ transferred);
    if (status == Status.BUFFER_UNDERFLOW) {
      return transferred;
    }
    if (status == Status.CLOSED) {
      if (transferred == 0)       return -1;
 else       return transferred;
    }
    if (!processHandshakeResult(true,false,result.getHandshakeStatus()))     return transferred;
  }
}",0.9595709570957096
4161,"/** 
 * The engine needs to run some tasks before proceeding... 
 */
private void needTask(){
synchronized (taskLock) {
    taskScheduled=true;
    readSink.interestRead(false);
    writeSink.interestWrite(null,false);
  }
  while (true) {
    final Runnable runner=engine.getDelegatedTask();
    if (runner == null) {
      executor.execute(new Runnable(){
        public void run(){
synchronized (taskLock) {
            taskScheduled=false;
          }
          HandshakeStatus status=engine.getHandshakeStatus();
          if (LOG.isDebugEnabled())           LOG.debug(""String_Node_Str"" + status);
          processHandshakeResult(false,false,status);
        }
      }
);
      break;
    }
 else {
      executor.execute(runner);
    }
  }
}","/** 
 * The engine needs to run some tasks before proceeding... 
 */
private void needTask(){
synchronized (taskLock) {
    taskScheduled=true;
    readSink.interestRead(false);
    writeSink.interestWrite(null,false);
  }
  while (true) {
    final Runnable runner=engine.getDelegatedTask();
    if (runner == null) {
      sslBlockingExecutor.execute(new Runnable(){
        public void run(){
synchronized (taskLock) {
            taskScheduled=false;
          }
          HandshakeStatus status=engine.getHandshakeStatus();
          if (LOG.isDebugEnabled())           LOG.debug(""String_Node_Str"" + status);
          processHandshakeResult(false,false,status);
        }
      }
);
      break;
    }
 else {
      sslBlockingExecutor.execute(runner);
    }
  }
}",0.9828722002635046
4162,"/** 
 * Processes a single handshake result. If a delegated task is needed, returns false & schedules the task(s). If writing is needed, returns false only if currently reading. If reading is needed, returns false only if currently writing. Otherwise, returns true.
 */
private boolean processHandshakeResult(boolean reading,boolean writing,HandshakeStatus hs){
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + engine + ""String_Node_Str""+ hs);
  needsHandshakeWrap=false;
  needsHandshakeUnwrap=false;
switch (hs) {
case NEED_TASK:
    needTask();
  return false;
case NEED_WRAP:
needsHandshakeWrap=true;
readSink.interestRead(false);
writeSink.interestWrite(this,true);
return writing;
case NEED_UNWRAP:
writeSink.interestWrite(null,false);
synchronized (readInterestLock) {
needsHandshakeUnwrap=true;
readSink.interestRead(true);
}
if (readDataLeft && !reading) NIODispatcher.instance().getScheduledExecutorService().execute(new Runnable(){
public void run(){
try {
read(BufferUtils.getEmptyBuffer());
}
 catch (IOException iox) {
FileUtils.close(SSLReadWriteChannel.this);
}
}
}
);
return reading;
case FINISHED:
synchronized (readInterestLock) {
readSink.interestRead(readInterest);
}
writeSink.interestWrite(this,true);
case NOT_HANDSHAKING:
default :
return true;
}
}","/** 
 * Processes a single handshake result. If a delegated task is needed, returns false & schedules the task(s). If writing is needed, returns false only if currently reading. If reading is needed, returns false only if currently writing. Otherwise, returns true.
 */
private boolean processHandshakeResult(boolean reading,boolean writing,HandshakeStatus hs){
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + engine + ""String_Node_Str""+ hs);
  needsHandshakeWrap=false;
  needsHandshakeUnwrap=false;
switch (hs) {
case NEED_TASK:
    needTask();
  return false;
case NEED_WRAP:
needsHandshakeWrap=true;
readSink.interestRead(false);
writeSink.interestWrite(this,true);
return writing;
case NEED_UNWRAP:
writeSink.interestWrite(null,false);
synchronized (readInterestLock) {
needsHandshakeUnwrap=true;
readSink.interestRead(true);
}
if (readDataLeft && !reading) networkExecutor.execute(new Runnable(){
public void run(){
try {
read(BufferUtils.getEmptyBuffer());
}
 catch (IOException iox) {
FileUtils.close(SSLReadWriteChannel.this);
}
}
}
);
return reading;
case FINISHED:
synchronized (readInterestLock) {
readSink.interestRead(readInterest);
}
writeSink.interestWrite(this,true);
case NOT_HANDSHAKING:
default :
return true;
}
}",0.9790431000395412
4163,"/** 
 * Initializes this TLSLayer, using the given address and enabling the given cipherSuites. If clientMode is disabled, client authentication can be turned on/off.
 * @param addr
 * @param cipherSuites
 */
void initialize(SocketAddress addr,String[] cipherSuites,boolean clientMode,boolean needClientAuth){
synchronized (initLock) {
    if (shutdown) {
      LOG.debug(""String_Node_Str"");
      return;
    }
    if (addr != null) {
      if (!(addr instanceof InetSocketAddress))       throw new IllegalArgumentException(""String_Node_Str"");
      InetSocketAddress iaddr=(InetSocketAddress)addr;
      String host=iaddr.getAddress().getHostAddress();
      int port=iaddr.getPort();
      engine=context.createSSLEngine(host,port);
    }
 else {
      engine=context.createSSLEngine();
    }
    engine.setEnabledCipherSuites(cipherSuites);
    engine.setUseClientMode(clientMode);
    if (!clientMode) {
      engine.setWantClientAuth(needClientAuth);
      engine.setNeedClientAuth(needClientAuth);
    }
    SSLSession session=engine.getSession();
    readIncoming=NIODispatcher.instance().getBufferCache().getHeap(session.getApplicationBufferSize());
    writeOutgoing=NIODispatcher.instance().getBufferCache().getHeap(session.getPacketBufferSize());
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + engine + ""String_Node_Str""+ session);
  }
}","/** 
 * Initializes this TLSLayer, using the given address and enabling the given cipherSuites. If clientMode is disabled, client authentication can be turned on/off.
 * @param addr
 * @param cipherSuites
 */
void initialize(SocketAddress addr,String[] cipherSuites,boolean clientMode,boolean needClientAuth){
synchronized (initLock) {
    if (shutdown) {
      LOG.debug(""String_Node_Str"");
      return;
    }
    if (addr != null) {
      if (!(addr instanceof InetSocketAddress))       throw new IllegalArgumentException(""String_Node_Str"");
      InetSocketAddress iaddr=(InetSocketAddress)addr;
      String host=iaddr.getAddress().getHostAddress();
      int port=iaddr.getPort();
      engine=context.createSSLEngine(host,port);
    }
 else {
      engine=context.createSSLEngine();
    }
    engine.setEnabledCipherSuites(cipherSuites);
    engine.setUseClientMode(clientMode);
    if (!clientMode) {
      engine.setWantClientAuth(needClientAuth);
      engine.setNeedClientAuth(needClientAuth);
    }
    SSLSession session=engine.getSession();
    readIncoming=byteBufferCache.getHeap(session.getApplicationBufferSize());
    writeOutgoing=byteBufferCache.getHeap(session.getPacketBufferSize());
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + engine + ""String_Node_Str""+ session);
  }
}",0.9746268656716418
4164,"/** 
 * Releases any resources that were acquired by the channel. If the underlying channels are still open, this method only propogates the shutdown call, instead of shutting down this channel, as it can still be used by other channels.
 */
public void shutdown(){
synchronized (initLock) {
    if (shutdown)     return;
    if (!isOpen()) {
      LOG.debug(""String_Node_Str"");
      shutdown=true;
    }
  }
  if (shutdown) {
    NIODispatcher.instance().getScheduledExecutorService().execute(new Runnable(){
      public void run(){
        ByteBufferCache cache=NIODispatcher.instance().getBufferCache();
        if (readIncoming != null)         cache.release(readIncoming);
        if (readOutgoing != null)         cache.release(readOutgoing);
        if (writeOutgoing != null)         cache.release(writeOutgoing);
      }
    }
);
  }
  Shutdownable observer=writeWanter;
  if (observer != null)   observer.shutdown();
}","/** 
 * Releases any resources that were acquired by the channel. If the underlying channels are still open, this method only propogates the shutdown call, instead of shutting down this channel, as it can still be used by other channels.
 */
public void shutdown(){
synchronized (initLock) {
    if (shutdown)     return;
    if (!isOpen()) {
      LOG.debug(""String_Node_Str"");
      shutdown=true;
    }
  }
  if (shutdown) {
    networkExecutor.execute(new Runnable(){
      public void run(){
        if (readIncoming != null)         byteBufferCache.release(readIncoming);
        if (readOutgoing != null)         byteBufferCache.release(readOutgoing);
        if (writeOutgoing != null)         byteBufferCache.release(writeOutgoing);
      }
    }
);
  }
  Shutdownable observer=writeWanter;
  if (observer != null)   observer.shutdown();
}",0.8582677165354331
4165,"@Override protected void initIncomingSocket(){
  super.initIncomingSocket();
  tlsLayer=new SSLReadWriteChannel(SSLUtils.getTLSContext(),SSLUtils.getExecutor());
  tlsLayer.initialize(getRemoteSocketAddress(),SSLUtils.getTLSCipherSuites(),false,false);
}","@Override protected void initIncomingSocket(){
  super.initIncomingSocket();
  tlsLayer=new SSLReadWriteChannel(SSLUtils.getTLSContext(),SSLUtils.getExecutor(),NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  tlsLayer.initialize(getRemoteSocketAddress(),SSLUtils.getTLSCipherSuites(),false,false);
}",0.8396694214876033
4166,"@Override protected void initOutgoingSocket() throws IOException {
  super.initOutgoingSocket();
  tlsLayer=new SSLReadWriteChannel(SSLUtils.getTLSContext(),SSLUtils.getExecutor());
}","@Override protected void initOutgoingSocket() throws IOException {
  super.initOutgoingSocket();
  tlsLayer=new SSLReadWriteChannel(SSLUtils.getTLSContext(),SSLUtils.getExecutor(),NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
}",0.7904967602591793
4167,"public void testClientTLSFails() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  SSLReadWriteChannel channel=new SSLReadWriteChannel(context,executor);
  channel.initialize(null,new String[]{""String_Node_Str""},true,false);
  ReadBufferChannel readSink=new ReadBufferChannel(""String_Node_Str"".getBytes());
  WriteBufferChannel writeSink=new WriteBufferChannel(300);
  channel.setReadChannel(readSink);
  channel.setWriteChannel(writeSink);
  new WriteBufferChannel(""String_Node_Str"".getBytes(),channel);
  channel.handleWrite();
  ByteBuffer readTo=ByteBuffer.allocate(200);
  try {
    channel.read(readTo);
    fail(""String_Node_Str"");
  }
 catch (  SSLException expected) {
  }
  writeSink.close();
  readSink.close();
  channel.shutdown();
}","public void testClientTLSFails() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  SSLReadWriteChannel channel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  channel.initialize(null,new String[]{""String_Node_Str""},true,false);
  ReadBufferChannel readSink=new ReadBufferChannel(""String_Node_Str"".getBytes());
  WriteBufferChannel writeSink=new WriteBufferChannel(300);
  channel.setReadChannel(readSink);
  channel.setWriteChannel(writeSink);
  new WriteBufferChannel(""String_Node_Str"".getBytes(),channel);
  channel.handleWrite();
  ByteBuffer readTo=ByteBuffer.allocate(200);
  try {
    channel.read(readTo);
    fail(""String_Node_Str"");
  }
 catch (  SSLException expected) {
  }
  writeSink.close();
  readSink.close();
  channel.shutdown();
}",0.9482114255205552
4168,"public void testHasBufferedOutput() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel clientChannel=new SSLReadWriteChannel(context,executor);
  final SSLReadWriteChannel serverChannel=new SSLReadWriteChannel(context,executor);
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
      clientChannel.initialize(null,new String[]{""String_Node_Str""},true,false);
      serverChannel.initialize(null,new String[]{""String_Node_Str""},false,false);
    }
  }
).get();
  Pipe clientToServer=Pipe.open();
  Pipe serverToClient=Pipe.open();
  serverToClient.source().configureBlocking(false);
  serverToClient.sink().configureBlocking(false);
  clientToServer.source().configureBlocking(false);
  clientToServer.sink().configureBlocking(false);
  IWWrapper clientWriteSink=new IWWrapper(clientToServer.sink());
  clientChannel.setReadChannel(new IRWrapper(serverToClient.source()));
  clientChannel.setWriteChannel(clientWriteSink);
  serverChannel.setReadChannel(new IRWrapper(clientToServer.source()));
  serverChannel.setWriteChannel(new IWWrapper(serverToClient.sink()));
  ByteBuffer buffer=ByteBuffer.wrap(""String_Node_Str"".getBytes());
  assertFalse(clientChannel.hasBufferedOutput());
  clientChannel.write(buffer);
  assertTrue(clientChannel.hasBufferedOutput());
  clientChannel.handleWrite();
  assertFalse(clientChannel.hasBufferedOutput());
  clientChannel.handleWrite();
  assertFalse(clientChannel.hasBufferedOutput());
  clientChannel.write(ByteBuffer.allocate(0));
  assertFalse(clientChannel.hasBufferedOutput());
  clientWriteSink.hasBufferedOutput=true;
  assertTrue(clientChannel.hasBufferedOutput());
  serverToClient.source().close();
  serverToClient.sink().close();
  clientToServer.source().close();
  clientToServer.sink().close();
  clientChannel.shutdown();
  serverChannel.shutdown();
}","public void testHasBufferedOutput() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel clientChannel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  final SSLReadWriteChannel serverChannel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
      clientChannel.initialize(null,new String[]{""String_Node_Str""},true,false);
      serverChannel.initialize(null,new String[]{""String_Node_Str""},false,false);
    }
  }
).get();
  Pipe clientToServer=Pipe.open();
  Pipe serverToClient=Pipe.open();
  serverToClient.source().configureBlocking(false);
  serverToClient.sink().configureBlocking(false);
  clientToServer.source().configureBlocking(false);
  clientToServer.sink().configureBlocking(false);
  IWWrapper clientWriteSink=new IWWrapper(clientToServer.sink());
  clientChannel.setReadChannel(new IRWrapper(serverToClient.source()));
  clientChannel.setWriteChannel(clientWriteSink);
  serverChannel.setReadChannel(new IRWrapper(clientToServer.source()));
  serverChannel.setWriteChannel(new IWWrapper(serverToClient.sink()));
  ByteBuffer buffer=ByteBuffer.wrap(""String_Node_Str"".getBytes());
  assertFalse(clientChannel.hasBufferedOutput());
  clientChannel.write(buffer);
  assertTrue(clientChannel.hasBufferedOutput());
  clientChannel.handleWrite();
  assertFalse(clientChannel.hasBufferedOutput());
  clientChannel.handleWrite();
  assertFalse(clientChannel.hasBufferedOutput());
  clientChannel.write(ByteBuffer.allocate(0));
  assertFalse(clientChannel.hasBufferedOutput());
  clientWriteSink.hasBufferedOutput=true;
  assertTrue(clientChannel.hasBufferedOutput());
  serverToClient.source().close();
  serverToClient.sink().close();
  clientToServer.source().close();
  clientToServer.sink().close();
  clientChannel.shutdown();
  serverChannel.shutdown();
}",0.9123881300047104
4169,"public void testShutdownCancelsInitialize() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel channel1=new SSLReadWriteChannel(context,executor);
  final SSLReadWriteChannel channel2=new SSLReadWriteChannel(context,executor);
  ByteBufferCache cache=NIODispatcher.instance().getBufferCache();
  cache.clearCache();
  channel1.shutdown();
  SSLSession session1=NIODispatcher.instance().getScheduledExecutorService().submit(new Callable<SSLSession>(){
    public SSLSession call(){
      channel1.initialize(null,new String[]{""String_Node_Str""},true,false);
      return channel1.getSession();
    }
  }
).get();
  assertNull(session1);
  assertEquals(0,cache.getHeapCacheSize());
  cache.clearCache();
  SSLSession session2=NIODispatcher.instance().getScheduledExecutorService().submit(new Callable<SSLSession>(){
    public SSLSession call(){
      channel2.initialize(null,new String[]{""String_Node_Str""},true,false);
      return channel2.getSession();
    }
  }
).get();
  assertNotNull(session2);
  assertEquals(0,cache.getHeapCacheSize());
  channel2.shutdown();
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
    }
  }
).get();
  assertNotEquals(0,cache.getHeapCacheSize());
  assertEquals(session2.getApplicationBufferSize() + session2.getPacketBufferSize(),cache.getHeapCacheSize());
}","public void testShutdownCancelsInitialize() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel channel1=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  final SSLReadWriteChannel channel2=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  ByteBufferCache cache=NIODispatcher.instance().getBufferCache();
  cache.clearCache();
  channel1.shutdown();
  SSLSession session1=NIODispatcher.instance().getScheduledExecutorService().submit(new Callable<SSLSession>(){
    public SSLSession call(){
      channel1.initialize(null,new String[]{""String_Node_Str""},true,false);
      return channel1.getSession();
    }
  }
).get();
  assertNull(session1);
  assertEquals(0,cache.getHeapCacheSize());
  cache.clearCache();
  SSLSession session2=NIODispatcher.instance().getScheduledExecutorService().submit(new Callable<SSLSession>(){
    public SSLSession call(){
      channel2.initialize(null,new String[]{""String_Node_Str""},true,false);
      return channel2.getSession();
    }
  }
).get();
  assertNotNull(session2);
  assertEquals(0,cache.getHeapCacheSize());
  channel2.shutdown();
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
    }
  }
).get();
  assertNotEquals(0,cache.getHeapCacheSize());
  assertEquals(session2.getApplicationBufferSize() + session2.getPacketBufferSize(),cache.getHeapCacheSize());
}",0.9399008674101612
4170,"public IRWrapper(ReadableByteChannel channel){
  this.channel=channel;
  this.in=null;
}","public IRWrapper(InputStream in,ReadableByteChannel channel,int totalAllowedToRead){
  this.channel=channel;
  this.in=in;
  this.totalAllowedToRead=totalAllowedToRead;
}",0.6744186046511628
4171,"public int read(ByteBuffer dst) throws IOException {
  if (in == null || in.available() > 0) {
    int read=channel.read(dst);
    totalRead+=read;
    return read;
  }
 else   return 0;
}","public int read(ByteBuffer dst) throws IOException {
  if (totalRead >= totalAllowedToRead)   return -1;
  if (in == null || in.available() > 0) {
    int oldLimit=dst.limit();
    if (dst.remaining() + totalRead > totalAllowedToRead)     dst.limit(totalAllowedToRead - totalRead + dst.position());
    int read=channel.read(dst);
    dst.limit(oldLimit);
    totalRead+=read;
    return read;
  }
 else   return 0;
}",0.6214876033057851
4172,"public void testServerTLSFails() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  SSLReadWriteChannel channel=new SSLReadWriteChannel(context,executor);
  channel.initialize(null,new String[]{""String_Node_Str""},false,false);
  ReadBufferChannel readSink=new ReadBufferChannel(""String_Node_Str"".getBytes());
  channel.setReadChannel(readSink);
  ByteBuffer readTo=ByteBuffer.allocate(200);
  try {
    channel.read(readTo);
    fail(""String_Node_Str"");
  }
 catch (  SSLException expected) {
  }
  readSink.close();
  channel.shutdown();
}","public void testServerTLSFails() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  SSLReadWriteChannel channel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  channel.initialize(null,new String[]{""String_Node_Str""},false,false);
  ReadBufferChannel readSink=new ReadBufferChannel(""String_Node_Str"".getBytes());
  channel.setReadChannel(readSink);
  ByteBuffer readTo=ByteBuffer.allocate(200);
  try {
    channel.read(readTo);
    fail(""String_Node_Str"");
  }
 catch (  SSLException expected) {
  }
  readSink.close();
  channel.shutdown();
}",0.9335161069225496
4173,"public void testNonBlockingTLSExchange() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel clientChannel=new SSLReadWriteChannel(context,executor);
  final SSLReadWriteChannel serverChannel=new SSLReadWriteChannel(context,executor);
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
      clientChannel.initialize(null,new String[]{""String_Node_Str""},true,false);
      serverChannel.initialize(null,new String[]{""String_Node_Str""},false,false);
    }
  }
).get();
  Pipe clientToServer=Pipe.open();
  Pipe serverToClient=Pipe.open();
  serverToClient.source().configureBlocking(false);
  serverToClient.sink().configureBlocking(false);
  clientToServer.source().configureBlocking(false);
  clientToServer.sink().configureBlocking(false);
  clientChannel.setReadChannel(new IRWrapper(serverToClient.source()));
  clientChannel.setWriteChannel(new IWWrapper(clientToServer.sink()));
  serverChannel.setReadChannel(new IRWrapper(clientToServer.source()));
  serverChannel.setWriteChannel(new IWWrapper(serverToClient.sink()));
  String serverOut=""String_Node_Str"";
  String clientOut=""String_Node_Str"";
  new WriteBufferChannel(serverOut.getBytes(),serverChannel);
  new WriteBufferChannel(clientOut.getBytes(),clientChannel);
  final ByteBuffer clientRead=ByteBuffer.allocate(100);
  final ByteBuffer serverRead=ByteBuffer.allocate(100);
  for (int i=0; i < 10; i++) {
    NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
      public void run(){
        try {
          clientChannel.read(clientRead);
          serverChannel.read(serverRead);
          clientChannel.handleWrite();
          serverChannel.handleWrite();
        }
 catch (        IOException iox) {
          throw new RuntimeException(iox);
        }
      }
    }
).get();
    Thread.sleep(100);
  }
  assertEquals(serverOut,new String(clientRead.array(),0,clientRead.position()));
  assertEquals(clientOut,new String(serverRead.array(),0,serverRead.position()));
  serverToClient.source().close();
  serverToClient.sink().close();
  clientToServer.source().close();
  clientToServer.sink().close();
  clientChannel.shutdown();
  serverChannel.shutdown();
}","public void testNonBlockingTLSExchange() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel clientChannel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  final SSLReadWriteChannel serverChannel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
      clientChannel.initialize(null,new String[]{""String_Node_Str""},true,false);
      serverChannel.initialize(null,new String[]{""String_Node_Str""},false,false);
    }
  }
).get();
  Pipe clientToServer=Pipe.open();
  Pipe serverToClient=Pipe.open();
  serverToClient.source().configureBlocking(false);
  serverToClient.sink().configureBlocking(false);
  clientToServer.source().configureBlocking(false);
  clientToServer.sink().configureBlocking(false);
  clientChannel.setReadChannel(new IRWrapper(serverToClient.source()));
  clientChannel.setWriteChannel(new IWWrapper(clientToServer.sink()));
  serverChannel.setReadChannel(new IRWrapper(clientToServer.source()));
  serverChannel.setWriteChannel(new IWWrapper(serverToClient.sink()));
  String serverOut=""String_Node_Str"";
  String clientOut=""String_Node_Str"";
  new WriteBufferChannel(serverOut.getBytes(),serverChannel);
  new WriteBufferChannel(clientOut.getBytes(),clientChannel);
  final ByteBuffer clientRead=ByteBuffer.allocate(100);
  final ByteBuffer serverRead=ByteBuffer.allocate(100);
  for (int i=0; i < 10; i++) {
    NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
      public void run(){
        try {
          clientChannel.read(clientRead);
          serverChannel.read(serverRead);
          clientChannel.handleWrite();
          serverChannel.handleWrite();
        }
 catch (        IOException iox) {
          throw new RuntimeException(iox);
        }
      }
    }
).get();
    Thread.sleep(100);
  }
  assertEquals(serverOut,new String(clientRead.array(),0,clientRead.position()));
  assertEquals(clientOut,new String(serverRead.array(),0,serverRead.position()));
  serverToClient.source().close();
  serverToClient.sink().close();
  clientToServer.source().close();
  clientToServer.sink().close();
  clientChannel.shutdown();
  serverChannel.shutdown();
}",0.9248181083265966
4174,"public SSLSession call(){
  channel2.initialize(null,new String[]{""String_Node_Str""},true,false);
  return channel2.getSession();
}","public Void call() throws IOException {
  lastClientReadAmount.set(clientChannel.read(clientRead));
  return null;
}",0.4129554655870445
4175,"private void doTLSTest(final boolean testServer) throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel channel=new SSLReadWriteChannel(context,executor);
  SSLSocketFactory sslFactory=context.getSocketFactory();
  final SSLSocket sslSocket=(SSLSocket)sslFactory.createSocket();
  sslSocket.setUseClientMode(!testServer);
  sslSocket.setWantClientAuth(false);
  sslSocket.setNeedClientAuth(false);
  sslSocket.setEnabledCipherSuites(new String[]{""String_Node_Str""});
  ServerSocket server=new ServerSocket();
  server.bind(null);
  sslSocket.connect(server.getLocalSocketAddress());
  final Socket accepted=server.accept();
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
      channel.initialize(accepted.getRemoteSocketAddress(),new String[]{""String_Node_Str""},testServer,false);
    }
  }
).get();
  IRWrapper irw=new IRWrapper(accepted.getInputStream());
  IWWrapper iww=new IWWrapper(accepted.getOutputStream());
  channel.setReadChannel(irw);
  channel.setWriteChannel(iww);
  final String INCOMING=""String_Node_Str"";
  final String OUTGOING=""String_Node_Str"";
  new WriteBufferChannel(OUTGOING.getBytes(),channel);
  final byte[] b=new byte[100];
  Thread t=new ManagedThread(new Runnable(){
    public void run(){
      try {
        sslSocket.getInputStream().read(b);
        sslSocket.getOutputStream().write(INCOMING.getBytes());
      }
 catch (      IOException iox) {
        throw new RuntimeException(iox);
      }
    }
  }
);
  t.start();
  final ByteBuffer channelRead=ByteBuffer.allocate(100);
  for (int i=0; i < 10; i++) {
    NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
      public void run(){
        try {
          channel.read(channelRead);
          channel.handleWrite();
        }
 catch (        IOException iox) {
          throw new RuntimeException(iox);
        }
      }
    }
).get();
    Thread.sleep(100);
  }
  t.join(10000);
  assertEquals(INCOMING,new String(channelRead.array(),0,channelRead.position()));
  assertEquals(OUTGOING,new String(b,0,OUTGOING.length()));
  assertEquals(irw.getTotalRead(),channel.getReadBytesConsumed());
  assertEquals(INCOMING.length(),channel.getReadBytesProduced());
  assertEquals(iww.getTotalWrote(),channel.getWrittenBytesProduced());
  assertEquals(OUTGOING.length(),channel.getWrittenBytesConsumed());
  assertGreaterThan(channel.getReadBytesProduced(),channel.getReadBytesConsumed());
  assertGreaterThan(channel.getWrittenBytesConsumed(),channel.getWrittenBytesProduced());
  sslSocket.close();
  server.close();
  accepted.close();
  channel.close();
  channel.shutdown();
}","private void doTLSTest(final boolean testServer) throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel channel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  SSLSocketFactory sslFactory=context.getSocketFactory();
  final SSLSocket sslSocket=(SSLSocket)sslFactory.createSocket();
  sslSocket.setUseClientMode(!testServer);
  sslSocket.setWantClientAuth(false);
  sslSocket.setNeedClientAuth(false);
  sslSocket.setEnabledCipherSuites(new String[]{""String_Node_Str""});
  ServerSocket server=new ServerSocket();
  server.bind(null);
  sslSocket.connect(server.getLocalSocketAddress());
  final Socket accepted=server.accept();
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
      channel.initialize(accepted.getRemoteSocketAddress(),new String[]{""String_Node_Str""},testServer,false);
    }
  }
).get();
  IRWrapper irw=new IRWrapper(accepted.getInputStream());
  IWWrapper iww=new IWWrapper(accepted.getOutputStream());
  channel.setReadChannel(irw);
  channel.setWriteChannel(iww);
  final String INCOMING=""String_Node_Str"";
  final String OUTGOING=""String_Node_Str"";
  new WriteBufferChannel(OUTGOING.getBytes(),channel);
  final byte[] b=new byte[100];
  Thread t=new ManagedThread(new Runnable(){
    public void run(){
      try {
        sslSocket.getInputStream().read(b);
        sslSocket.getOutputStream().write(INCOMING.getBytes());
      }
 catch (      IOException iox) {
        throw new RuntimeException(iox);
      }
    }
  }
);
  t.start();
  final ByteBuffer channelRead=ByteBuffer.allocate(100);
  for (int i=0; i < 10; i++) {
    NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
      public void run(){
        try {
          channel.read(channelRead);
          channel.handleWrite();
        }
 catch (        IOException iox) {
          throw new RuntimeException(iox);
        }
      }
    }
).get();
    Thread.sleep(100);
  }
  t.join(10000);
  assertEquals(INCOMING,new String(channelRead.array(),0,channelRead.position()));
  assertEquals(OUTGOING,new String(b,0,OUTGOING.length()));
  assertEquals(irw.getTotalRead(),channel.getReadBytesConsumed());
  assertEquals(INCOMING.length(),channel.getReadBytesProduced());
  assertEquals(iww.getTotalWrote(),channel.getWrittenBytesProduced());
  assertEquals(OUTGOING.length(),channel.getWrittenBytesConsumed());
  assertGreaterThan(channel.getReadBytesProduced(),channel.getReadBytesConsumed());
  assertGreaterThan(channel.getWrittenBytesConsumed(),channel.getWrittenBytesProduced());
  sslSocket.close();
  server.close();
  accepted.close();
  channel.close();
  channel.shutdown();
}",0.9830389928309144
4176,"public void testShutdown() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel clientChannel=new SSLReadWriteChannel(context,executor);
  final SSLReadWriteChannel serverChannel=new SSLReadWriteChannel(context,executor);
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
      clientChannel.initialize(null,new String[]{""String_Node_Str""},true,false);
      serverChannel.initialize(null,new String[]{""String_Node_Str""},false,false);
    }
  }
).get();
  Pipe clientToServer=Pipe.open();
  Pipe serverToClient=Pipe.open();
  serverToClient.source().configureBlocking(false);
  serverToClient.sink().configureBlocking(false);
  clientToServer.source().configureBlocking(false);
  clientToServer.sink().configureBlocking(false);
  clientChannel.setReadChannel(new IRWrapper(serverToClient.source()));
  clientChannel.setWriteChannel(new IWWrapper(clientToServer.sink()));
  serverChannel.setReadChannel(new IRWrapper(clientToServer.source()));
  serverChannel.setWriteChannel(new IWWrapper(serverToClient.sink()));
  String serverOut=""String_Node_Str"";
  String clientOut=""String_Node_Str"";
  new WriteBufferChannel(serverOut.getBytes(),serverChannel);
  new WriteBufferChannel(clientOut.getBytes(),clientChannel);
  final ByteBuffer clientRead=ByteBuffer.allocate(100);
  final ByteBuffer serverRead=ByteBuffer.allocate(100);
  for (int i=0; i < 10; i++) {
    NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
      public void run(){
        try {
          clientChannel.shutdown();
          serverChannel.shutdown();
          clientChannel.read(clientRead);
          serverChannel.read(serverRead);
          clientChannel.handleWrite();
          serverChannel.handleWrite();
        }
 catch (        IOException iox) {
          throw new RuntimeException(iox);
        }
      }
    }
).get();
    Thread.sleep(100);
  }
  assertEquals(serverOut,new String(clientRead.array(),0,clientRead.position()));
  assertEquals(clientOut,new String(serverRead.array(),0,serverRead.position()));
  serverToClient.source().close();
  serverToClient.sink().close();
  clientToServer.source().close();
  clientToServer.sink().close();
  clientChannel.shutdown();
  serverChannel.shutdown();
  try {
    clientChannel.read(BufferUtils.getEmptyBuffer());
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
  try {
    serverChannel.read(BufferUtils.getEmptyBuffer());
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
  try {
    clientChannel.write(BufferUtils.getEmptyBuffer());
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
  try {
    serverChannel.write(BufferUtils.getEmptyBuffer());
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
  try {
    clientChannel.handleWrite();
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
  try {
    serverChannel.handleWrite();
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
}","public void testShutdown() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel clientChannel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  final SSLReadWriteChannel serverChannel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
      clientChannel.initialize(null,new String[]{""String_Node_Str""},true,false);
      serverChannel.initialize(null,new String[]{""String_Node_Str""},false,false);
    }
  }
).get();
  Pipe clientToServer=Pipe.open();
  Pipe serverToClient=Pipe.open();
  serverToClient.source().configureBlocking(false);
  serverToClient.sink().configureBlocking(false);
  clientToServer.source().configureBlocking(false);
  clientToServer.sink().configureBlocking(false);
  clientChannel.setReadChannel(new IRWrapper(serverToClient.source()));
  clientChannel.setWriteChannel(new IWWrapper(clientToServer.sink()));
  serverChannel.setReadChannel(new IRWrapper(clientToServer.source()));
  serverChannel.setWriteChannel(new IWWrapper(serverToClient.sink()));
  String serverOut=""String_Node_Str"";
  String clientOut=""String_Node_Str"";
  new WriteBufferChannel(serverOut.getBytes(),serverChannel);
  new WriteBufferChannel(clientOut.getBytes(),clientChannel);
  final ByteBuffer clientRead=ByteBuffer.allocate(100);
  final ByteBuffer serverRead=ByteBuffer.allocate(100);
  for (int i=0; i < 10; i++) {
    NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
      public void run(){
        try {
          clientChannel.shutdown();
          serverChannel.shutdown();
          clientChannel.read(clientRead);
          serverChannel.read(serverRead);
          clientChannel.handleWrite();
          serverChannel.handleWrite();
        }
 catch (        IOException iox) {
          throw new RuntimeException(iox);
        }
      }
    }
).get();
    Thread.sleep(100);
  }
  assertEquals(serverOut,new String(clientRead.array(),0,clientRead.position()));
  assertEquals(clientOut,new String(serverRead.array(),0,serverRead.position()));
  serverToClient.source().close();
  serverToClient.sink().close();
  clientToServer.source().close();
  clientToServer.sink().close();
  clientChannel.shutdown();
  serverChannel.shutdown();
  try {
    clientChannel.read(BufferUtils.getEmptyBuffer());
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
  try {
    serverChannel.read(BufferUtils.getEmptyBuffer());
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
  try {
    clientChannel.write(BufferUtils.getEmptyBuffer());
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
  try {
    serverChannel.write(BufferUtils.getEmptyBuffer());
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
  try {
    clientChannel.handleWrite();
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
  try {
    serverChannel.handleWrite();
    fail(""String_Node_Str"");
  }
 catch (  ClosedChannelException expected) {
  }
}",0.9445768772348032
4177,"public void testParentInterestOffDoesntKillHandshake() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel clientChannel=new SSLReadWriteChannel(context,executor);
  final SSLReadWriteChannel serverChannel=new SSLReadWriteChannel(context,executor);
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
      clientChannel.initialize(null,new String[]{""String_Node_Str""},true,false);
      serverChannel.initialize(null,new String[]{""String_Node_Str""},false,false);
    }
  }
).get();
  Pipe clientToServer=Pipe.open();
  Pipe serverToClient=Pipe.open();
  serverToClient.source().configureBlocking(false);
  serverToClient.sink().configureBlocking(false);
  clientToServer.source().configureBlocking(false);
  clientToServer.sink().configureBlocking(false);
  final IRWrapper clientReadSink=new IRWrapper(serverToClient.source());
  final IWWrapper clientWriteSink=new IWWrapper(clientToServer.sink());
  final IRWrapper serverReadSink=new IRWrapper(clientToServer.source());
  final IWWrapper serverWriteSink=new IWWrapper(serverToClient.sink());
  clientChannel.setReadChannel(clientReadSink);
  clientChannel.setWriteChannel(clientWriteSink);
  serverChannel.setReadChannel(serverReadSink);
  serverChannel.setWriteChannel(serverWriteSink);
  String serverOut=""String_Node_Str"";
  String clientOut=""String_Node_Str"";
  final InterestWritableByteChannel serverSource=new WriteBufferChannel(serverOut.getBytes(),serverChannel);
  final InterestWritableByteChannel clientSource=new WriteBufferChannel(clientOut.getBytes(),clientChannel);
  final ByteBuffer clientRead=ByteBuffer.allocate(100);
  final ByteBuffer serverRead=ByteBuffer.allocate(100);
  for (int i=0; i < 10; i++) {
    NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
      public void run(){
        try {
          clientChannel.read(clientRead);
          if (clientReadSink.getLastReadInterest()) {
            clientChannel.interestRead(false);
            assertTrue(clientReadSink.getLastReadInterest());
          }
          serverChannel.read(serverRead);
          if (serverReadSink.getLastReadInterest()) {
            serverChannel.interestRead(false);
            assertTrue(serverReadSink.getLastReadInterest());
          }
          clientChannel.handleWrite();
          if (clientWriteSink.getLastWriteInterest()) {
            clientChannel.interestWrite(null,false);
            assertTrue(clientWriteSink.getLastWriteInterest());
            clientChannel.interestWrite(clientSource,true);
          }
          serverChannel.handleWrite();
          if (serverWriteSink.getLastWriteInterest()) {
            serverChannel.interestWrite(null,false);
            assertTrue(serverWriteSink.getLastWriteInterest());
            serverChannel.interestWrite(serverSource,true);
          }
        }
 catch (        IOException iox) {
          throw new RuntimeException(iox);
        }
      }
    }
).get();
    Thread.sleep(100);
  }
  assertEquals(serverOut,new String(clientRead.array(),0,clientRead.position()));
  assertEquals(clientOut,new String(serverRead.array(),0,serverRead.position()));
  serverToClient.source().close();
  serverToClient.sink().close();
  clientToServer.source().close();
  clientToServer.sink().close();
  clientChannel.shutdown();
  serverChannel.shutdown();
}","public void testParentInterestOffDoesntKillHandshake() throws Exception {
  Executor executor=ExecutorsHelper.newProcessingQueue(""String_Node_Str"");
  SSLContext context=SSLContext.getInstance(""String_Node_Str"");
  context.init(null,null,null);
  final SSLReadWriteChannel clientChannel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  final SSLReadWriteChannel serverChannel=new SSLReadWriteChannel(context,executor,NIODispatcher.instance().getBufferCache(),NIODispatcher.instance().getScheduledExecutorService());
  NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
    public void run(){
      clientChannel.initialize(null,new String[]{""String_Node_Str""},true,false);
      serverChannel.initialize(null,new String[]{""String_Node_Str""},false,false);
    }
  }
).get();
  Pipe clientToServer=Pipe.open();
  Pipe serverToClient=Pipe.open();
  serverToClient.source().configureBlocking(false);
  serverToClient.sink().configureBlocking(false);
  clientToServer.source().configureBlocking(false);
  clientToServer.sink().configureBlocking(false);
  final IRWrapper clientReadSink=new IRWrapper(serverToClient.source());
  final IWWrapper clientWriteSink=new IWWrapper(clientToServer.sink());
  final IRWrapper serverReadSink=new IRWrapper(clientToServer.source());
  final IWWrapper serverWriteSink=new IWWrapper(serverToClient.sink());
  clientChannel.setReadChannel(clientReadSink);
  clientChannel.setWriteChannel(clientWriteSink);
  serverChannel.setReadChannel(serverReadSink);
  serverChannel.setWriteChannel(serverWriteSink);
  String serverOut=""String_Node_Str"";
  String clientOut=""String_Node_Str"";
  final InterestWritableByteChannel serverSource=new WriteBufferChannel(serverOut.getBytes(),serverChannel);
  final InterestWritableByteChannel clientSource=new WriteBufferChannel(clientOut.getBytes(),clientChannel);
  final ByteBuffer clientRead=ByteBuffer.allocate(100);
  final ByteBuffer serverRead=ByteBuffer.allocate(100);
  for (int i=0; i < 10; i++) {
    NIODispatcher.instance().getScheduledExecutorService().submit(new Runnable(){
      public void run(){
        try {
          clientChannel.read(clientRead);
          if (clientReadSink.getLastReadInterest()) {
            clientChannel.interestRead(false);
            assertTrue(clientReadSink.getLastReadInterest());
          }
          serverChannel.read(serverRead);
          if (serverReadSink.getLastReadInterest()) {
            serverChannel.interestRead(false);
            assertTrue(serverReadSink.getLastReadInterest());
          }
          clientChannel.handleWrite();
          if (clientWriteSink.getLastWriteInterest()) {
            clientChannel.interestWrite(null,false);
            assertTrue(clientWriteSink.getLastWriteInterest());
            clientChannel.interestWrite(clientSource,true);
          }
          serverChannel.handleWrite();
          if (serverWriteSink.getLastWriteInterest()) {
            serverChannel.interestWrite(null,false);
            assertTrue(serverWriteSink.getLastWriteInterest());
            serverChannel.interestWrite(serverSource,true);
          }
        }
 catch (        IOException iox) {
          throw new RuntimeException(iox);
        }
      }
    }
).get();
    Thread.sleep(100);
  }
  assertEquals(serverOut,new String(clientRead.array(),0,clientRead.position()));
  assertEquals(clientOut,new String(serverRead.array(),0,serverRead.position()));
  serverToClient.source().close();
  serverToClient.sink().close();
  clientToServer.source().close();
  clientToServer.sink().close();
  clientChannel.shutdown();
  serverChannel.shutdown();
}",0.9486471562672556
4178,"private MutableGUIDFilter(){
  FILTER.disallowAdult();
}","MutableGUIDFilter(){
  this(new KeywordFilter());
  FILTER.disallowAdult();
}",0.7218045112781954
4179,"public static void globalSetUp(){
  try {
    URN sha1=URN.createSHA1Urn(""String_Node_Str"");
    urn=ProviderHacks.getQueryRequestFactory().createRequery(sha1);
    urnFile=ProviderHacks.getQueryRequestFactory().createQuery(sha1,""String_Node_Str"");
    noUrn=ProviderHacks.getQueryRequestFactory().createQuery(""String_Node_Str"");
  }
 catch (  IOException impossible) {
    ErrorService.error(impossible);
  }
  filter=new HashFilter();
}","public static void globalSetUp(){
  context=new Mockery();
  query=context.mock(QueryRequest.class);
  ping=context.mock(PingRequest.class);
  filter=new HashFilter();
}",0.3920922570016474
4180,"@Override protected void setUp() throws Exception {
  address=InetAddress.getLocalHost().getAddress();
  context=new Mockery();
  queryRequestMock=context.mock(QueryRequest.class);
  queryReplyMock=context.mock(QueryReply.class);
  pingRequestMock=context.mock(PingRequest.class);
}","@Override protected void setUp() throws Exception {
  context=new Mockery();
  queryRequestMock=context.mock(QueryRequest.class);
  queryReplyMock=context.mock(QueryReply.class);
  pingRequestMock=context.mock(PingRequest.class);
}",0.2456140350877192
4181,"/** 
 * Tests if more than one guid can be added by seeing if messages for it are filterted. Also test removal.
 */
public void testAddRemoveGUID(){
  MutableGUIDFilter filter=ProviderHacks.getMutableGUIDFilter();
  GUID guid=new GUID();
  filter.addGUID(guid.bytes());
  QueryReply qr=KeywordFilterTest.createReply(ProviderHacks.getResponseFactory().createResponse(1,2,""String_Node_Str""),guid,777,address);
  QueryReply unrelated=KeywordFilterTest.createReply(ProviderHacks.getResponseFactory().createResponse(1,2,""String_Node_Str""),new GUID(),777,address);
  assertFalse(filter.allow(qr));
  assertTrue(filter.allow(unrelated));
  GUID guid2=new GUID();
  filter.addGUID(guid2.bytes());
  QueryReply qr2=KeywordFilterTest.createReply(ProviderHacks.getResponseFactory().createResponse(1,2,""String_Node_Str""),guid2,777,address);
  assertFalse(filter.allow(qr2));
  assertFalse(filter.allow(qr));
  assertTrue(filter.allow(unrelated));
  filter.removeGUID(guid.bytes());
  assertFalse(filter.allow(qr2));
  assertTrue(filter.allow(qr));
  assertTrue(filter.allow(unrelated));
  filter.removeGUID(guid.bytes());
  assertFalse(filter.allow(qr2));
  assertTrue(filter.allow(qr));
  assertTrue(filter.allow(unrelated));
  filter.removeGUID(guid2.bytes());
  assertTrue(filter.allow(qr));
  assertTrue(filter.allow(qr2));
  assertTrue(filter.allow(unrelated));
}","public void testAddRemoveGUID(){
  final GUID guid=new GUID();
  final GUID guid2=new GUID();
  Message msg=null;
  assertTrue(filter.allow(msg));
  filter.addGUID(guid.bytes());
  context.checking(new Expectations(){
{
      exactly(1).of(queryReplyMock).getGUID();
      will(returnValue(guid.bytes()));
      exactly(1).of(queryReplyMock).getGUID();
      will(returnValue(guid2.bytes()));
    }
  }
);
  assertFalse(filter.allow(queryReplyMock));
  assertTrue(filter.allow(queryReplyMock));
  filter.removeGUID(guid.bytes());
  context.checking(new Expectations(){
{
      exactly(1).of(queryReplyMock).getGUID();
      will(returnValue(guid.bytes()));
      exactly(1).of(queryReplyMock).getGUID();
      will(returnValue(guid2.bytes()));
    }
  }
);
  assertTrue(filter.allow(queryReplyMock));
  assertTrue(filter.allow(queryReplyMock));
  context.assertIsSatisfied();
}",0.0716524854455888
4182,"@Override protected void setUp() throws Exception {
  address=InetAddress.getLocalHost().getAddress();
}","@Override protected void setUp() throws Exception {
  context=new Mockery();
  filter=new MutableGUIDFilter(filterKeyword);
  queryReplyMock=context.mock(QueryReply.class);
  queryRequestMock=context.mock(QueryRequest.class);
}",0.3685800604229607
4183,"public <T>List<Future<T>> invokeAll(Collection<Callable<T>> tasks,long timeout,TimeUnit unit) throws InterruptedException {
  return null;
}","public <T>List<Future<T>> invokeAll(Collection tasks,long timeout,TimeUnit unit) throws InterruptedException {
  return null;
}",0.951310861423221
4184,"public <T>T invokeAny(Collection<Callable<T>> tasks,long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  return null;
}","public <T>T invokeAny(Collection tasks,long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  return null;
}",0.9587301587301588
4185,"public void testReplies() throws Exception {
  assertTrue(allow(""String_Node_Str""));
  assertTrue(allow(""String_Node_Str""));
  assertTrue(allow(""String_Node_Str""));
  assertTrue(!allow(""String_Node_Str""));
  assertTrue(allow(""String_Node_Str""));
  assertTrue(allow(""String_Node_Str""));
}","public void testReplies() throws Exception {
  assertTrue(allow(""String_Node_Str""));
  assertTrue(allow(""String_Node_Str""));
  assertTrue(allow(""String_Node_Str""));
  assertTrue(!allow(""String_Node_Str""));
  assertTrue(allow(""String_Node_Str""));
  assertTrue(allow(""String_Node_Str""));
  context.assertIsSatisfied();
}",0.9487603305785124
4186,"private boolean allow(String vendorCode) throws Exception {
  byte[] vendorBytes=vendorCode.getBytes();
  assertEquals(4,vendorBytes.length);
  for (int i=0; i < vendorBytes.length; i++)   _replyBytes[_indexOfVendor + i]=vendorBytes[i];
  QueryReply qr=(QueryReply)ProviderHacks.getMessageFactory().read(new ByteArrayInputStream(_replyBytes));
  return _filter.allow(qr);
}","private boolean allow(final String vendorCode) throws Exception {
  context.checking(new Expectations(){
{
      exactly(1).of(queryReplyMock).getVendor();
      will(returnValue(vendorCode));
    }
  }
);
  return _filter.allow(queryReplyMock);
}",0.332258064516129
4187,"public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(FileRequestHandlerTest.suite());
  suite.addTest(PushProxyRequestHandlerTest.suite());
  suite.addTest(HTTPUploadManagerTest.suite());
  suite.addTest(HTTPUploaderTest.suite());
  suite.addTest(UploadSlotManagerTest.suite());
  suite.addTest(UrnHttpRequestTest.suite());
  suite.addTest(HTTPAcceptorTest.suite());
  suite.addTest(UploadQueueingTest.suite());
  suite.addTest(UploadTest.suite());
  suite.addTest(PushUploadTest.suite());
  suite.addTest(AltLocUploadTest.suite());
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(FileRequestHandlerTest.suite());
  suite.addTest(PushProxyRequestHandlerTest.suite());
  suite.addTest(HTTPUploaderTest.suite());
  suite.addTest(UploadSlotManagerTest.suite());
  suite.addTest(UrnHttpRequestTest.suite());
  suite.addTest(HTTPAcceptorTest.suite());
  suite.addTest(UploadQueueingTest.suite());
  suite.addTest(UploadTest.suite());
  suite.addTest(PushUploadTest.suite());
  suite.addTest(AltLocUploadTest.suite());
  return suite;
}",0.9565217391304348
4188,"public void runBare() throws Throwable {
  _currentTestName=getName();
  if (System.getProperty(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + _currentTestName);
    LogFactory.getLog(this.getClass()).info(""String_Node_Str"" + _currentTestName);
  }
  assertNotNull(_currentTestName);
  try {
    preSetUp();
    setUp();
    runTest();
  }
  finally {
    try {
      tearDown();
    }
  finally {
      postTearDown();
    }
  }
}","public void runBare() throws Throwable {
  _currentTestName=getName();
  if (System.getProperty(""String_Node_Str"",""String_Node_Str"").equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + _currentTestName);
  }
  assertNotNull(_currentTestName);
  try {
    preSetUp();
    setUp();
    runTest();
  }
  finally {
    try {
      tearDown();
    }
  finally {
      postTearDown();
    }
  }
}",0.5913621262458472
4189,"public void testDisallowAdult() throws Exception {
  KeywordFilter filter=new KeywordFilter();
  QueryReply qr=createReply(""String_Node_Str"");
  assertTrue(filter.allow(qr));
  qr=createReply(""String_Node_Str"");
  assertTrue(filter.allow(qr));
  filter.disallowAdult();
  assertFalse(filter.allow(qr));
  qr=createReply(""String_Node_Str"");
  assertFalse(filter.allow(qr));
  qr=createReply(""String_Node_Str"");
  assertTrue(filter.allow(qr));
}","public void testDisallowAdult() throws Exception {
  KeywordFilter filter=new KeywordFilter();
  createResponseList(queryReplyMock,""String_Node_Str"");
  assertTrue(filter.allow(queryReplyMock));
  createResponseList(queryReplyMock,""String_Node_Str"");
  assertTrue(filter.allow(queryReplyMock));
  filter.disallowAdult();
  createResponseList(queryReplyMock,""String_Node_Str"");
  assertFalse(filter.allow(queryReplyMock));
  createResponseList(queryReplyMock,""String_Node_Str"");
  assertFalse(filter.allow(queryReplyMock));
  createResponseList(queryReplyMock,""String_Node_Str"");
  assertTrue(filter.allow(queryReplyMock));
  context.assertIsSatisfied();
}",0.6338797814207651
4190,"@Override protected void setUp() throws Exception {
  address=InetAddress.getLocalHost().getAddress();
}","@Override protected void setUp() throws Exception {
  address=InetAddress.getLocalHost().getAddress();
  context=new Mockery();
  queryRequestMock=context.mock(QueryRequest.class);
  queryReplyMock=context.mock(QueryReply.class);
  pingRequestMock=context.mock(PingRequest.class);
}",0.538860103626943
4191,"/** 
 * Call this method with the verified simppSettings which are used to replace other settings if they exist in the system.
 */
public synchronized void updateSimppSettings(String simppSettings){
  byte[] settings=null;
  try {
    settings=simppSettings.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException uex) {
    ErrorService.error(uex);
    return;
  }
  ByteArrayInputStream bais=new ByteArrayInputStream(settings);
  _simppProps.clear();
  try {
    _simppProps.load(bais);
  }
 catch (  IOException iox) {
    LOG.error(""String_Node_Str"",iox);
    return;
  }
  activateSimppSettings();
}","/** 
 * Call this method with the verified simppSettings which are used to replace other settings if they exist in the system.
 */
public void updateSimppSettings(String simppSettings){
  if (_remoteController == null)   throw new IllegalStateException(""String_Node_Str"");
synchronized (_remoteController) {
    byte[] settings=null;
    try {
      settings=simppSettings.getBytes(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException uex) {
      ErrorService.error(uex);
      return;
    }
    ByteArrayInputStream bais=new ByteArrayInputStream(settings);
    _simppProps.clear();
    try {
      _simppProps.load(bais);
    }
 catch (    IOException iox) {
      LOG.error(""String_Node_Str"",iox);
      return;
    }
    activateSimppSettings();
  }
}",0.8034557235421166
4192,"/** 
 * Call this method if you want to activate the settings to the ones in this.simppProps
 */
public void activateSimppSettings(){
  LOG.debug(""String_Node_Str"");
synchronized (this) {
    if (_remoteController == null)     throw new IllegalStateException(""String_Node_Str"");
synchronized (_simppProps) {
      for (      Map.Entry<Object,Object> entry : _simppProps.entrySet()) {
        String key=(String)entry.getKey();
        String value=(String)entry.getValue();
        if (!_remoteController.updateSetting(key,value))         _remainderSimppSettings.put(key,value);
      }
    }
  }
}","/** 
 * Call this method if you want to activate the settings to the ones in this.simppProps
 */
public void activateSimppSettings(){
  LOG.debug(""String_Node_Str"");
  if (_remoteController == null)   throw new IllegalStateException(""String_Node_Str"");
synchronized (_remoteController) {
    for (    Map.Entry<Object,Object> entry : _simppProps.entrySet()) {
      String key=(String)entry.getKey();
      String value=(String)entry.getValue();
      if (!_remoteController.updateSetting(key,value))       _remainderSimppSettings.put(key,value);
    }
  }
}",0.9377162629757786
4193,"/** 
 * @return the simpp value for a simppkey from the map that remembers simppsettings which have not been loaded yet. Removes the entry from the mapping since it is no longer needed, now that the setting has been created.
 */
public synchronized String getUnloadedValueFor(String simppKey){
  return _remainderSimppSettings.remove(simppKey);
}","/** 
 * @return the simpp value for a simppkey from the map that remembers simppsettings which have not been loaded yet. Removes the entry from the mapping since it is no longer needed, now that the setting has been created.
 */
public String getUnloadedValueFor(String simppKey){
synchronized (_remoteController) {
    return _remainderSimppSettings.remove(simppKey);
  }
}",0.925
4194,"public synchronized void setRemoteSettingController(RemoteSettingController controller){
  _remoteController=controller;
}","public void setRemoteSettingController(RemoteSettingController controller){
  _remoteController=controller;
}",0.9437229437229436
4195,"/** 
 * Sets a new RemoteSettingManager to control remote settings. 
 */
public synchronized void setRemoteSettingManager(RemoteSettingManager manager){
  this.remoteManager=manager;
  manager.setRemoteSettingController(new RemoteSettingController(){
    public boolean updateSetting(    String remoteKey,    String value){
synchronized (SettingsFactory.this) {
        Setting setting=remoteKeyToSetting.get(remoteKey);
        if (setting != null) {
          setting.setValue(value);
          return true;
        }
 else {
          return false;
        }
      }
    }
  }
);
}","/** 
 * Sets a new RemoteSettingManager to control remote settings. 
 */
public synchronized void setRemoteSettingManager(RemoteSettingManager manager){
  this.remoteManager=manager;
  manager.setRemoteSettingController(this);
}",0.5541871921182266
4196,"/** 
 * Reloads the settings with the predefined settings file from disk.
 */
public synchronized void reload(){
  if (!SETTINGS_FILE.isFile()) {
    setExpireValue();
    return;
  }
  FileInputStream fis=null;
  try {
    fis=new FileInputStream(SETTINGS_FILE);
    try {
      PROPS.load(fis);
    }
 catch (    IllegalArgumentException ignored) {
    }
catch (    StringIndexOutOfBoundsException sioobe) {
    }
catch (    IOException iox) {
      String msg=iox.getMessage();
      if (msg != null) {
        msg=msg.toLowerCase();
        if (msg.indexOf(""String_Node_Str"") == -1)         throw iox;
      }
      SETTINGS_FILE.delete();
      MessageService.showError(I18n.marktr(""String_Node_Str""));
    }
  }
 catch (  IOException e) {
    ErrorService.error(e);
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
      }
    }
  }
  for (  Setting set : settings)   set.reload();
  setExpireValue();
}","/** 
 * Reloads the settings with the predefined settings file from disk.
 */
public synchronized void reload(){
  if (!SETTINGS_FILE.isFile()) {
    setExpireValue();
    return;
  }
  FileInputStream fis=null;
  try {
    fis=new FileInputStream(SETTINGS_FILE);
    try {
      PROPS.load(fis);
    }
 catch (    IllegalArgumentException ignored) {
    }
catch (    StringIndexOutOfBoundsException sioobe) {
    }
catch (    IOException iox) {
      String msg=iox.getMessage();
      if (msg != null) {
        msg=msg.toLowerCase();
        if (msg.indexOf(""String_Node_Str"") == -1)         throw iox;
      }
      SETTINGS_FILE.delete();
      MessageService.showError(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    ErrorService.error(e);
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
      }
    }
  }
  for (  Setting set : settings)   set.reload();
  setExpireValue();
}",0.9932537623248572
4197,"public boolean updateSetting(String remoteKey,String value){
synchronized (SettingsFactory.this) {
    Setting setting=remoteKeyToSetting.get(remoteKey);
    if (setting != null) {
      setting.setValue(value);
      return true;
    }
 else {
      return false;
    }
  }
}","public synchronized boolean updateSetting(String remoteKey,String value){
  Setting setting=remoteKeyToSetting.get(remoteKey);
  if (setting != null) {
    setting.setValue(value);
    return true;
  }
 else {
    return false;
  }
}",0.6444007858546169
4198,"public long extendSequenceNumber(long sequenceNumber){
  long extendedSeqNo;
  if (sequenceNumber >= HIGH_BASE_SWITCH_POINT && sequenceNumber < LOW_BASE_SWITCH_POINT && highSwitchPending) {
    highBase=lowBase;
    highSwitchPending=false;
    lowSwitchPending=true;
  }
  if (sequenceNumber > LOW_BASE_SWITCH_POINT && lowSwitchPending) {
    lowBase+=BASE_INCREMENT;
    highSwitchPending=true;
    lowSwitchPending=false;
  }
  if (sequenceNumber < HIGH_BASE_SWITCH_POINT) {
    extendedSeqNo=sequenceNumber + lowBase;
  }
 else {
    extendedSeqNo=sequenceNumber + highBase;
  }
  return extendedSeqNo;
}","public long extendSequenceNumber(long sequenceNumber){
  long extendedSeqNo;
  if (sequenceNumber >= HIGH_BASE_SWITCH_POINT && sequenceNumber < BASE_MIDPOINT && highSwitchPending) {
    highBase=lowBase;
    highSwitchPending=false;
    lowSwitchPending=true;
  }
  if (sequenceNumber > LOW_BASE_SWITCH_POINT && lowSwitchPending) {
    lowBase+=BASE_INCREMENT;
    highSwitchPending=true;
    lowSwitchPending=false;
  }
  if (sequenceNumber < HIGH_BASE_SWITCH_POINT) {
    extendedSeqNo=sequenceNumber + lowBase;
  }
 else {
    extendedSeqNo=sequenceNumber + highBase;
  }
  return extendedSeqNo;
}",0.98841059602649
4199,"public void testOutOfOrderNumber(){
  SequenceNumberExtender extender=new SequenceNumberExtender();
  assertEquals(0x3FFF,extender.extendSequenceNumber(0x3FFF));
  assertEquals(0x7FFF + 1,extender.extendSequenceNumber(0x7FFF + 1));
  assertEquals(0x7FFF - 3,extender.extendSequenceNumber(0x7FFF - 3));
}","public void testOutOfOrderNumber(){
  SequenceNumberExtender extender=new SequenceNumberExtender();
  for (long i=0; i < 0x3FFF; i++)   assertEquals(i,extender.extendSequenceNumber(i));
  assertEquals(0x3FFF,extender.extendSequenceNumber(0x3FFF));
  for (long i=0x3FFF + 1; i < 0x7FFF - 4; i++)   assertEquals(i,extender.extendSequenceNumber(i));
  assertEquals(0x7FFF + 1,extender.extendSequenceNumber(0x7FFF + 1));
  assertEquals(0x7FFF - 3,extender.extendSequenceNumber(0x7FFF - 3));
}",0.7029077117572693
4200,"public void testUDPHostCacheEndpoints() throws Exception {
  ExtendedEndpoint e=ExtendedEndpoint.read(""String_Node_Str"");
  assertTrue(e.isUDPHostCache());
  assertEquals(1,e.getUDPHostCacheFailures());
  e.recordUDPHostCacheFailure();
  assertEquals(2,e.getUDPHostCacheFailures());
  e.recordUDPHostCacheSuccess();
  assertEquals(0,e.getUDPHostCacheFailures());
  StringWriter writer=new StringWriter();
  e.write(writer);
  assertEquals(""String_Node_Str"",writer.toString());
  e.recordUDPHostCacheFailure();
  e.recordUDPHostCacheFailure();
  e.recordUDPHostCacheFailure();
  writer=new StringWriter();
  e.write(writer);
  assertEquals(""String_Node_Str"",writer.toString());
  e.setUDPHostCache(false);
  assertFalse(e.isUDPHostCache());
  try {
    e.recordUDPHostCacheFailure();
    fail(""String_Node_Str"");
  }
 catch (  AssertFailure expected) {
  }
  try {
    e.recordUDPHostCacheSuccess();
    fail(""String_Node_Str"");
  }
 catch (  AssertFailure expected) {
  }
  writer=new StringWriter();
  e.write(writer);
  assertEquals(""String_Node_Str"",writer.toString());
  e=ExtendedEndpoint.read(""String_Node_Str"");
  assertTrue(e.isUDPHostCache());
  assertEquals(0,e.getUDPHostCacheFailures());
}","public void testUDPHostCacheEndpoints() throws Exception {
  ExtendedEndpoint e=ExtendedEndpoint.read(""String_Node_Str"");
  assertTrue(e.isUDPHostCache());
  assertEquals(1,e.getUDPHostCacheFailures());
  e.recordUDPHostCacheFailure();
  assertEquals(2,e.getUDPHostCacheFailures());
  e.recordUDPHostCacheSuccess();
  assertEquals(0,e.getUDPHostCacheFailures());
  StringWriter writer=new StringWriter();
  e.write(writer);
  assertEquals(""String_Node_Str"",writer.toString());
  e.recordUDPHostCacheFailure();
  e.recordUDPHostCacheFailure();
  e.recordUDPHostCacheFailure();
  writer=new StringWriter();
  e.write(writer);
  assertEquals(""String_Node_Str"",writer.toString());
  e.setUDPHostCache(false);
  assertFalse(e.isUDPHostCache());
  try {
    e.recordUDPHostCacheFailure();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
  try {
    e.recordUDPHostCacheSuccess();
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
  writer=new StringWriter();
  e.write(writer);
  assertEquals(""String_Node_Str"",writer.toString());
  e=ExtendedEndpoint.read(""String_Node_Str"");
  assertTrue(e.isUDPHostCache());
  assertEquals(0,e.getUDPHostCacheFailures());
}",0.9875207986688852
4201,"/** 
 * Browses the files on the specified host and port.
 * @param host The IP of the host you want to browse.
 * @param port The port of the host you want to browse.
 * @param proxies the <tt>Set</tt> of push proxies to try
 * @param canDoFWTransfer Whether or not this guy can do a firewalltransfer.
 */
public void browseHost(Connectable host,Set<? extends IpPort> proxies,boolean canDoFWTransfer){
  if (host.getInetSocketAddress().isUnresolved()) {
    try {
      host=new ConnectableImpl(host.getAddress(),host.getPort(),host.isTLSCapable());
    }
 catch (    UnknownHostException uhe) {
      failed();
      return;
    }
  }
  if (!NetworkUtils.isValidIpPort(host)) {
    failed();
    return;
  }
  LOG.trace(""String_Node_Str"");
  setState(STARTED);
  if (canConnectDirectly(host) || isLocalBrowse(host)) {
    try {
      setState(DIRECTLY_CONNECTING);
      LOG.trace(""String_Node_Str"");
      ConnectType type=host.isTLSCapable() ? ConnectType.TLS : ConnectType.PLAIN;
      Socket socket=Sockets.connect(new InetSocketAddress(host.getAddress(),host.getPort()),DIRECT_CONNECT_TIME,type);
      LOG.trace(""String_Node_Str"");
      browseExchange(socket);
      return;
    }
 catch (    IOException ioe) {
      LOG.debug(""String_Node_Str"",ioe);
    }
  }
  LOG.debug(""String_Node_Str"");
  if (_serventID == null) {
    LOG.debug(""String_Node_Str"");
    failed();
  }
 else {
    RemoteFileDesc fakeRFD=new RemoteFileDesc(host.getAddress(),host.getPort(),SPECIAL_INDEX,""String_Node_Str"",0,_serventID.bytes(),0,false,0,false,null,null,false,true,""String_Node_Str"",proxies,-1,canDoFWTransfer ? UDPConnection.VERSION : 0,host.isTLSCapable());
synchronized (_pushedHosts) {
      _pushedHosts.put(_serventID,new PushRequestDetails(this));
    }
    LOG.trace(""String_Node_Str"");
    setState(PUSHING);
    RouterService.getDownloadManager().getPushManager().sendPush(fakeRFD);
  }
}","/** 
 * Browses the files on the specified host and port.
 * @param host The IP of the host you want to browse.
 * @param port The port of the host you want to browse.
 * @param proxies the <tt>Set</tt> of push proxies to try
 * @param canDoFWTransfer Whether or not this guy can do a firewalltransfer.
 */
public void browseHost(Connectable host,Set<? extends IpPort> proxies,boolean canDoFWTransfer){
  if (host.getInetSocketAddress().isUnresolved()) {
    try {
      host=new ConnectableImpl(host.getAddress(),host.getPort(),host.isTLSCapable());
    }
 catch (    UnknownHostException uhe) {
      failed();
      return;
    }
  }
  if (!NetworkUtils.isValidIpPort(host)) {
    failed();
    return;
  }
  LOG.trace(""String_Node_Str"");
  setState(STARTED);
  if (canConnectDirectly(host) || isLocalBrowse(host)) {
    try {
      setState(DIRECTLY_CONNECTING);
      ConnectType type=host.isTLSCapable() ? ConnectType.TLS : ConnectType.PLAIN;
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + type);
      Socket socket=Sockets.connect(new InetSocketAddress(host.getAddress(),host.getPort()),DIRECT_CONNECT_TIME,type);
      LOG.trace(""String_Node_Str"");
      browseExchange(socket);
      return;
    }
 catch (    IOException ioe) {
      LOG.debug(""String_Node_Str"",ioe);
    }
  }
  LOG.debug(""String_Node_Str"");
  if (_serventID == null) {
    LOG.debug(""String_Node_Str"");
    failed();
  }
 else {
    RemoteFileDesc fakeRFD=new RemoteFileDesc(host.getAddress(),host.getPort(),SPECIAL_INDEX,""String_Node_Str"",0,_serventID.bytes(),0,false,0,false,null,null,false,true,""String_Node_Str"",proxies,-1,canDoFWTransfer ? UDPConnection.VERSION : 0,host.isTLSCapable());
synchronized (_pushedHosts) {
      _pushedHosts.put(_serventID,new PushRequestDetails(this));
    }
    LOG.trace(""String_Node_Str"");
    setState(PUSHING);
    RouterService.getDownloadManager().getPushManager().sendPush(fakeRFD);
  }
}",0.9709803921568628
4202,"/** 
 * Validates a potential settings directory. This returns the validated directory, or throws an IOException if it can't be validated.
 */
public static File validateSettingsDirectory(File dir) throws IOException {
  dir=dir.getAbsoluteFile();
  if (!dir.isDirectory()) {
    dir.delete();
    if (!dir.mkdirs())     throw new IOException(""String_Node_Str"" + dir);
  }
  if (!dir.canWrite())   throw new IOException(""String_Node_Str"");
  if (!dir.canRead())   throw new IOException(""String_Node_Str"");
  return dir;
}","/** 
 * Validates a potential settings directory. This returns the validated directory, or throws an IOException if it can't be validated.
 */
public static File validateSettingsDirectory(File dir) throws IOException {
  dir=dir.getAbsoluteFile();
  if (!dir.isDirectory()) {
    dir.delete();
    if (!dir.mkdirs())     throw new IOException(""String_Node_Str"" + dir);
  }
  if (!dir.canWrite())   throw new IOException(""String_Node_Str"" + dir);
  if (!dir.canRead())   throw new IOException(""String_Node_Str"" + dir);
  return dir;
}",0.9886148007590132
4203,"/** 
 * Saves the data iff it was written exactly as we wanted.
 */
public static boolean verySafeSave(File dir,String name,byte[] data){
  File tmp;
  try {
    tmp=File.createTempFile(name,""String_Node_Str"",dir);
  }
 catch (  IOException hrorible) {
    return false;
  }
  File out=new File(dir,name);
  OutputStream os=null;
  try {
    os=new BufferedOutputStream(new FileOutputStream(tmp));
    os.write(data);
    os.flush();
  }
 catch (  IOException bad) {
    return false;
  }
 finally {
    close(os);
  }
  byte[] read=readFileFully(tmp);
  if (read == null || !Arrays.equals(read,data))   return false;
  return forceRename(tmp,out);
}","/** 
 * Saves the data iff it was written exactly as we wanted.
 */
public static boolean verySafeSave(File dir,String name,byte[] data){
  File tmp;
  try {
    tmp=FileUtils.createTempFile(name,""String_Node_Str"",dir);
  }
 catch (  IOException hrorible) {
    return false;
  }
  File out=new File(dir,name);
  OutputStream os=null;
  try {
    os=new BufferedOutputStream(new FileOutputStream(tmp));
    os.write(data);
    os.flush();
  }
 catch (  IOException bad) {
    return false;
  }
 finally {
    close(os);
  }
  byte[] read=readFileFully(tmp);
  if (read == null || !Arrays.equals(read,data))   return false;
  return forceRename(tmp,out);
}",0.9961685823754788
4204,"/** 
 * Wires initial pieces together that are required for nearly everything. 
 */
public static void preinstall(){
  if (!preinstalled.compareAndSet(false,true))   return;
  try {
    CommonUtils.setUserSettingsDir(LimeWireUtils.getRequestedUserSettingsLocation());
  }
 catch (  IOException iox) {
    try {
      File temporaryDir;
      try {
        temporaryDir=LimeWireUtils.getTemporarySettingsDirectory();
      }
 catch (      IOException tempFull) {
        tempFull.printStackTrace();
        tempFull.initCause(iox);
        LimeWireUtils.clearTemporarySettingsDirectories();
        try {
          temporaryDir=LimeWireUtils.getTemporarySettingsDirectory();
        }
 catch (        IOException stillBad) {
          stillBad.initCause(tempFull);
          throw stillBad;
        }
      }
      temporaryDir.deleteOnExit();
      try {
        CommonUtils.setUserSettingsDir(temporaryDir);
      }
 catch (      IOException cannotSet) {
        cannotSet.initCause(iox);
        throw cannotSet;
      }
      LimeWireUtils.setTemporaryDirectoryInUse(true);
    }
 catch (    IOException reallyBad) {
      throw new RuntimeException(reallyBad);
    }
  }
}","/** 
 * Wires initial pieces together that are required for nearly everything. 
 */
public static void preinstall() throws InstallFailedException {
  if (!preinstalled.compareAndSet(false,true))   return;
  try {
    CommonUtils.setUserSettingsDir(LimeWireUtils.getRequestedUserSettingsLocation());
  }
 catch (  IOException requestedFailed) {
    try {
      LimeWireUtils.clearTemporarySettingsDirectories();
      File temporaryDir;
      try {
        temporaryDir=LimeWireUtils.getTemporarySettingsDirectory();
      }
 catch (      IOException tempFailed) {
        tempFailed.initCause(requestedFailed);
        throw tempFailed;
      }
      temporaryDir.deleteOnExit();
      try {
        CommonUtils.setUserSettingsDir(temporaryDir);
      }
 catch (      IOException cannotSet) {
        cannotSet.initCause(requestedFailed);
        throw cannotSet;
      }
      LimeWireUtils.setTemporaryDirectoryInUse(true);
    }
 catch (    IOException totalFailure) {
      throw new InstallFailedException(""String_Node_Str"",totalFailure);
    }
  }
}",0.5791125056028686
4205,"private String getRawNameForSaving(){
  String tempFileName=getDisplayName();
  if (tempFileName != null && tempFileName.length() > 0) {
    return tempFileName;
  }
  tempFileName=getKeywordTopic();
  if (tempFileName != null && tempFileName.length() > 0) {
    return tempFileName;
  }
  URN urn=getSHA1Urn();
  if (urn != null) {
    tempFileName=urn.toString();
    return tempFileName;
  }
  String[] urls=getDefaultURLs();
  if (urls.length > 0) {
    try {
      URI uri=new URI(urls[0].toCharArray());
      tempFileName=extractFileName(uri);
      if (tempFileName != null && tempFileName.length() > 0) {
        return tempFileName;
      }
    }
 catch (    URIException e) {
    }
  }
  try {
    File file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    file.deleteOnExit();
    tempFileName=file.getName();
    return tempFileName;
  }
 catch (  IOException ie) {
  }
  tempFileName=DOWNLOAD_PREFIX;
  return tempFileName;
}","private String getRawNameForSaving(){
  String tempFileName=getDisplayName();
  if (tempFileName != null && tempFileName.length() > 0) {
    return tempFileName;
  }
  tempFileName=getKeywordTopic();
  if (tempFileName != null && tempFileName.length() > 0) {
    return tempFileName;
  }
  URN urn=getSHA1Urn();
  if (urn != null) {
    tempFileName=urn.toString();
    return tempFileName;
  }
  String[] urls=getDefaultURLs();
  if (urls.length > 0) {
    try {
      URI uri=new URI(urls[0].toCharArray());
      tempFileName=extractFileName(uri);
      if (tempFileName != null && tempFileName.length() > 0) {
        return tempFileName;
      }
    }
 catch (    URIException e) {
    }
  }
  try {
    File file=FileUtils.createTempFile(""String_Node_Str"",""String_Node_Str"");
    file.deleteOnExit();
    tempFileName=file.getName();
    return tempFileName;
  }
 catch (  IOException ie) {
  }
  tempFileName=DOWNLOAD_PREFIX;
  return tempFileName;
}",0.99738082765846
4206,"/** 
 * updates the given ogg file with the new Comment field
 * @param comment the <tt>com.jcraft.jorbis.Comment</tt> object to put in the file
 * @param file the .ogg file to be updated
 */
public void update(Comment comment,File file) throws IOException {
  InputStream in=null;
  OutputStream out=null;
  File tempFile=null;
  try {
    state=new State();
    in=new BufferedInputStream(new FileInputStream(file));
    read(in);
    state.vc=comment;
    tempFile=null;
    try {
      tempFile=File.createTempFile(file.getName(),""String_Node_Str"");
    }
 catch (    IOException e) {
      LOG.debug(""String_Node_Str"");
      tempFile=new File(file.getAbsolutePath(),file.getName() + ""String_Node_Str"");
    }
    out=new BufferedOutputStream(new FileOutputStream(tempFile));
    LOG.debug(""String_Node_Str"");
    write(out);
    out.flush();
  }
  finally {
    if (out != null)     try {
      out.close();
    }
 catch (    IOException ignored) {
    }
    if (in != null)     try {
      in.close();
    }
 catch (    IOException ignored) {
    }
  }
  if (tempFile.length() == 0)   throw new IOException(""String_Node_Str"");
  if (!FileUtils.forceRename(tempFile,file))   throw new IOException(""String_Node_Str"");
}","/** 
 * updates the given ogg file with the new Comment field
 * @param comment the <tt>com.jcraft.jorbis.Comment</tt> object to put in the file
 * @param file the .ogg file to be updated
 */
public void update(Comment comment,File file) throws IOException {
  InputStream in=null;
  OutputStream out=null;
  File tempFile=null;
  try {
    state=new State();
    in=new BufferedInputStream(new FileInputStream(file));
    read(in);
    state.vc=comment;
    tempFile=null;
    try {
      tempFile=FileUtils.createTempFile(file.getName(),""String_Node_Str"");
    }
 catch (    IOException e) {
      LOG.debug(""String_Node_Str"");
      tempFile=new File(file.getAbsolutePath(),file.getName() + ""String_Node_Str"");
    }
    out=new BufferedOutputStream(new FileOutputStream(tempFile));
    LOG.debug(""String_Node_Str"");
    write(out);
    out.flush();
  }
  finally {
    if (out != null)     try {
      out.close();
    }
 catch (    IOException ignored) {
    }
    if (in != null)     try {
      in.close();
    }
 catch (    IOException ignored) {
    }
  }
  if (tempFile.length() == 0)   throw new IOException(""String_Node_Str"");
  if (!FileUtils.forceRename(tempFile,file))   throw new IOException(""String_Node_Str"");
}",0.9979616795760292
4207,"/** 
 * Clears all potential temporary LW directories. 
 */
public static void clearTemporarySettingsDirectories(){
  File tempDir;
  try {
    tempDir=File.createTempFile(""String_Node_Str"",""String_Node_Str"").getAbsoluteFile();
  }
 catch (  IOException failure) {
    return;
  }
  File tempDirParent=tempDir.getParentFile();
  tempDir.delete();
  for (int i=0; i < 1000; i++) {
    File dir=new File(tempDirParent,""String_Node_Str"" + i);
    if (!dir.delete())     FileUtils.deleteRecursive(dir);
  }
}","/** 
 * Clears all potential temporary LW directories. 
 */
public static void clearTemporarySettingsDirectories(){
  File tempDir;
  try {
    tempDir=FileUtils.createTempFile(""String_Node_Str"",""String_Node_Str"").getAbsoluteFile();
  }
 catch (  IOException failure) {
    return;
  }
  File tempDirParent=tempDir.getParentFile();
  tempDir.delete();
  for (int i=0; i < 1000; i++) {
    File dir=new File(tempDirParent,""String_Node_Str"" + i);
    if (!dir.delete())     FileUtils.deleteRecursive(dir);
  }
}",0.9950641658440276
4208,"/** 
 * Returns a temporary directory that can be used for settings. 
 */
public static File getTemporarySettingsDirectory() throws IOException {
  File tempDir=File.createTempFile(""String_Node_Str"",""String_Node_Str"").getAbsoluteFile();
  File tempDirParent=tempDir.getParentFile();
  tempDir.delete();
  if (!tempDir.exists()) {
    if (tempDir.mkdir()) {
      if (tempDir.exists() && tempDir.isDirectory()) {
        return tempDir;
      }
    }
  }
  for (int i=0; i < 1000; i++) {
    tempDir=new File(tempDirParent,""String_Node_Str"" + i);
    if (!tempDir.exists()) {
      if (tempDir.mkdir()) {
        if (tempDir.exists() && tempDir.isDirectory()) {
          return tempDir;
        }
      }
    }
  }
  throw new IOException(""String_Node_Str"");
}","/** 
 * Returns a temporary directory that can be used for settings. 
 */
public static File getTemporarySettingsDirectory() throws IOException {
  File tempDir=FileUtils.createTempFile(""String_Node_Str"",""String_Node_Str"").getAbsoluteFile();
  File tempDirParent=tempDir.getParentFile();
  tempDir.delete();
  if (!tempDir.exists()) {
    if (tempDir.mkdir()) {
      if (tempDir.exists() && tempDir.isDirectory()) {
        return tempDir;
      }
    }
  }
  for (int i=0; i < 1000; i++) {
    tempDir=new File(tempDirParent,""String_Node_Str"" + i);
    if (!tempDir.exists()) {
      if (tempDir.mkdir()) {
        if (tempDir.exists() && tempDir.isDirectory()) {
          return tempDir;
        }
      }
    }
  }
  throw new IOException(""String_Node_Str"" + tempDirParent + ""String_Node_Str"");
}",0.9737347853939782
4209,"/** 
 * Sets the new ReadObserver. The deepest ChannelReader in the chain first has its source set to the prior reader (assuming it implemented ReadableByteChannel) and a read is notified, in order to read any buffered data. The source is then set to the Socket's channel and interest in reading is turned on.
 */
public final void setReadObserver(final ChannelReadObserver newReader){
  NIODispatcher.instance().getScheduledExecutorService().execute(new Runnable(){
    public void run(){
      ReadObserver oldReader=reader;
      try {
synchronized (LOCK) {
          if (shutdown) {
            newReader.shutdown();
            return;
          }
          reader=newReader;
        }
        ChannelReader lastChannel=newReader;
        while (lastChannel.getReadChannel() instanceof ChannelReader)         lastChannel=(ChannelReader)lastChannel.getReadChannel();
        if (lastChannel instanceof ThrottleListener)         ((ThrottleListener)lastChannel).setAttachment(AbstractNBSocket.this);
        if (oldReader instanceof InterestReadableByteChannel && oldReader != newReader) {
          lastChannel.setReadChannel((InterestReadableByteChannel)oldReader);
          reader.handleRead();
          oldReader.shutdown();
        }
        InterestReadableByteChannel source=getBaseReadChannel();
        lastChannel.setReadChannel(source);
        if (isConnected() && !NIODispatcher.instance().isReadReadyThisIteration(getChannel()))         ;
        reader.handleRead();
        source.interestRead(true);
      }
 catch (      IOException iox) {
        shutdown();
        oldReader.shutdown();
      }
    }
  }
);
}","/** 
 * Sets the new ReadObserver. The deepest ChannelReader in the chain first has its source set to the prior reader (assuming it implemented ReadableByteChannel) and a read is notified, in order to read any buffered data. The source is then set to the Socket's channel and interest in reading is turned on.
 */
public final void setReadObserver(final ChannelReadObserver newReader){
  NIODispatcher.instance().getScheduledExecutorService().execute(new Runnable(){
    public void run(){
      ReadObserver oldReader=reader;
      try {
synchronized (LOCK) {
          if (shutdown) {
            newReader.shutdown();
            return;
          }
          reader=newReader;
        }
        ChannelReader lastChannel=newReader;
        while (lastChannel.getReadChannel() instanceof ChannelReader)         lastChannel=(ChannelReader)lastChannel.getReadChannel();
        if (lastChannel instanceof ThrottleListener)         ((ThrottleListener)lastChannel).setAttachment(AbstractNBSocket.this);
        if (oldReader instanceof InterestReadableByteChannel && oldReader != newReader) {
          lastChannel.setReadChannel((InterestReadableByteChannel)oldReader);
          reader.handleRead();
          oldReader.shutdown();
        }
        InterestReadableByteChannel source=getBaseReadChannel();
        lastChannel.setReadChannel(source);
        if (isConnected() && !NIODispatcher.instance().isReadReadyThisIteration(getChannel()))         reader.handleRead();
        source.interestRead(true);
      }
 catch (      IOException iox) {
        shutdown();
        oldReader.shutdown();
      }
    }
  }
);
}",0.9969306322897484
4210,"/** 
 * @return the number, average, variance, min, median and max of alist of Integers
 */
public static DoubleStats quickStatsDouble(List<Double> l){
  DoubleStats ret=new DoubleStats();
  ret.number=l.size();
  if (ret.number < 2)   return ret;
  Collections.sort(l);
  ret.min=l.get(0);
  ret.max=l.get(l.size() - 1);
  ret.med=getQuartile(Quartile.MED,l);
  if (ret.number > 6) {
    ret.q1=getQuartile(Quartile.Q1,l);
    ret.q3=getQuartile(Quartile.Q3,l);
  }
  double mode=l.get(0);
  double current=l.get(0);
  int occurences=0;
  int currentOccurences=0;
  for (int i=1; i < l.size(); i++) {
    if (l.get(i) == current)     currentOccurences++;
    current=l.get(i);
    if (currentOccurences > occurences) {
      occurences=currentOccurences;
      mode=current;
    }
  }
  ret.mode=mode;
  double sum=0;
  for (  double i : l)   sum+=i;
  ret.avg=sum / l.size();
  sum=0;
  double sum3=0;
  double sum4=0;
  for (  double i : l) {
    if (i > ret.avg)     ret.st++;
    double dist=i - ret.avg;
    double dist2=dist * dist;
    double dist3=dist2 * dist;
    sum+=dist2;
    sum3+=dist3;
    sum4+=(dist2 * dist2);
  }
  int div=l.size() - 1;
  ret.m2=sum / div;
  ret.m3=sum3 / div;
  ret.m4=sum4 / div;
  double[] swilk=swilk(l);
  if (swilk != null) {
    ret.swilkW=swilk[0];
    ret.swilkPW=swilk[1];
  }
  return ret;
}","/** 
 * @return the number, average, variance, min, median and max of alist of Integers
 */
public static DoubleStats quickStatsDouble(List<Double> l){
  DoubleStats ret=new DoubleStats();
  ret.number=l.size();
  if (ret.number < 2)   return ret;
  Collections.sort(l);
  ret.min=l.get(0);
  ret.max=l.get(l.size() - 1);
  ret.med=getQuartile(Quartile.MED,l);
  if (ret.number > 6) {
    ret.q1=getQuartile(Quartile.Q1,l);
    ret.q3=getQuartile(Quartile.Q3,l);
  }
  double mode=l.get(0);
  double current=l.get(0);
  int occurences=0;
  int currentOccurences=0;
  for (int i=1; i < l.size(); i++) {
    if (l.get(i) == current)     currentOccurences++;
 else {
      current=l.get(i);
      currentOccurences=0;
    }
    if (currentOccurences > occurences) {
      occurences=currentOccurences;
      mode=current;
    }
  }
  ret.mode=mode;
  double sum=0;
  for (  double i : l)   sum+=i;
  ret.avg=sum / l.size();
  sum=0;
  double sum3=0;
  double sum4=0;
  for (  double i : l) {
    if (i > ret.avg)     ret.st++;
    double dist=i - ret.avg;
    double dist2=dist * dist;
    double dist3=dist2 * dist;
    sum+=dist2;
    sum3+=dist3;
    sum4+=(dist2 * dist2);
  }
  int div=l.size() - 1;
  ret.m2=sum / div;
  ret.m3=sum3 / div;
  ret.m4=sum4 / div;
  double[] swilk=swilk(l);
  if (swilk != null) {
    ret.swilkW=swilk[0];
    ret.swilkPW=swilk[1];
  }
  return ret;
}",0.9842201834862384
4211,"public void testQuickStats() throws Exception {
  List<Double> l=new ArrayList<Double>();
  for (int i=0; i < 100; i++)   l.add((double)i);
  DoubleStats s=StatsUtils.quickStatsDouble(l);
  assertEquals(100,s.getNumber());
  assertEquals(0.0,s.min);
  assertEquals(99.0,s.max);
  assertEquals(49.5,s.med);
  assertEquals(49.5,s.avg);
  assertEquals(24.25,s.q1);
  assertEquals(74.75,s.q3);
  assertEquals(841.6666666,s.m2,0.00001);
  assertEquals(0.0,s.mode);
  l.add((double)55);
  s=StatsUtils.quickStatsDouble(l);
  assertEquals(55.0,s.mode);
}","public void testQuickStats() throws Exception {
  List<Double> l=new ArrayList<Double>();
  for (int i=0; i < 100; i++)   l.add((double)i);
  DoubleStats s=StatsUtils.quickStatsDouble(l);
  assertEquals(100,s.getNumber());
  assertEquals(0.0,s.min);
  assertEquals(99.0,s.max);
  assertEquals(49.5,s.med);
  assertEquals(49.5,s.avg);
  assertEquals(24.25,s.q1);
  assertEquals(74.75,s.q3);
  assertEquals(841.6666666,s.m2,0.00001);
  assertEquals(0.0,s.mode);
  l.clear();
  l.add(2.0);
  l.add(2.0);
  l.add(1.0);
  l.add(1.0);
  l.add(0.5);
  l.add(0.5);
  l.add(0.5);
  s=StatsUtils.quickStatsDouble(l);
  assertEquals(0.5,s.mode);
}",0.8960270498732037
4212,"/** 
 * Gets copies of the current RouteTable, clears the current RouteTable and re-adds the Contacts from the copies.
 */
private void rebuild(boolean isTrueRebuild,long lastContactTime){
  Collection<Contact> activeNodes=getActiveContacts();
  activeNodes=ContactUtils.sortAliveToFailed(activeNodes);
  Collection<Contact> cachedNodes=null;
  if (isTrueRebuild) {
    cachedNodes=getCachedContacts();
    cachedNodes=ContactUtils.sort(cachedNodes);
  }
  clear();
  boolean removed=activeNodes.remove(localNode);
  assert(removed);
  long currentTime=System.currentTimeMillis();
  for (  Contact node : activeNodes) {
    if (lastContactTime >= 0L && (currentTime - node.getTimeStamp()) < lastContactTime) {
      continue;
    }
    if (isTrueRebuild) {
      node.unknown();
    }
    add(node);
  }
  if (isTrueRebuild) {
    for (    Contact node : cachedNodes) {
      if (lastContactTime >= 0L && (currentTime - node.getTimeStamp()) < lastContactTime) {
        continue;
      }
      node.unknown();
      add(node);
    }
  }
}","/** 
 * Gets copies of the current RouteTable, clears the current RouteTable and re-adds the Contacts from the copies.
 */
private void rebuild(boolean isTrueRebuild,long lastContactTime){
  Collection<Contact> activeNodes=getActiveContacts();
  activeNodes=ContactUtils.sortAliveToFailed(activeNodes);
  Collection<Contact> cachedNodes=null;
  if (isTrueRebuild) {
    cachedNodes=getCachedContacts();
    cachedNodes=ContactUtils.sort(cachedNodes);
  }
  clear();
  boolean removed=activeNodes.remove(localNode);
  assert(removed);
  long currentTime=System.currentTimeMillis();
  for (  Contact node : activeNodes) {
    if (lastContactTime >= 0L && (currentTime - node.getTimeStamp()) >= lastContactTime) {
      continue;
    }
    if (isTrueRebuild) {
      node.unknown();
    }
    add(node);
  }
  if (isTrueRebuild) {
    for (    Contact node : cachedNodes) {
      if (lastContactTime >= 0L && (currentTime - node.getTimeStamp()) >= lastContactTime) {
        continue;
      }
      node.unknown();
      add(node);
    }
  }
}",0.7988450433108758
4213,"/** 
 * Shuts down this NIOServerSocket 
 */
public void close() throws IOException {
  IOException exception=null;
  try {
    socket.close();
  }
 catch (  IOException iox) {
    exception=iox;
  }
  observer.shutdown();
  if (exception != null)   throw exception;
}","/** 
 * Shuts down this NIOServerSocket 
 */
public void close() throws IOException {
  IOException exception;
  if (VersionUtils.isJavaVersionOrAbove(""String_Node_Str"") || NIODispatcher.instance().isDispatchThread()) {
    exception=shutdownSocketAndChannels();
  }
 else {
    final AtomicReference<IOException> exRef=new AtomicReference<IOException>();
    try {
      NIODispatcher.instance().invokeAndWait(new Runnable(){
        public void run(){
          exRef.set(shutdownSocketAndChannels());
        }
      }
);
    }
 catch (    InterruptedException e) {
      throw new IllegalStateException(e);
    }
    exception=exRef.get();
  }
  observer.shutdown();
  if (exception != null)   throw exception;
}",0.4451219512195122
4214,"void writeDone(){
  doingWrite=false;
}","void writeDone(){
  doingWrite=false;
  _stateMachine.handleRead();
}",0.7222222222222222
4215,"public void writeScheduled(){
  LOG.debug(""String_Node_Str"");
  buffer.clear();
  downloader.writeDone();
  irc.interestRead(true);
}","public void writeScheduled(){
  LOG.debug(""String_Node_Str"");
  NIODispatcher.instance().invokeLater(this);
}",0.6859504132231405
4216,"public boolean get(int i){
  boolean ret=fields[0].get(i);
  for (int j=1; i < fields.length; j++)   ret^=fields[j].get(i);
  return ret;
}","public boolean get(int i){
  boolean ret=fields[0].get(i);
  for (int j=1; j < fields.length; j++) {
    ret^=fields[j].get(i);
  }
  return ret;
}",0.965034965034965
4217,"private ContactsScrubber(Context context,Contact sender,Collection<? extends Contact> nodes,float requiredRatio){
  assert(!nodes.isEmpty());
  assert(requiredRatio >= 0f && requiredRatio <= 1f);
  this.nodes=nodes;
  this.scrubbed=new LinkedHashMap<KUID,Contact>(nodes.size());
  this.collisions=new LinkedHashSet<Contact>(1);
  SameClassFilter filter=new SameClassFilter(sender);
  boolean containsLocal=false;
  for (  Contact node : nodes) {
    if (!ContactUtils.isValidSocketAddress(node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(sender + ""String_Node_Str"" + node);
      }
      continue;
    }
    if (ContactUtils.isPrivateAddress(node)) {
      if (LOG.isInfoEnabled()) {
        if (ContactUtils.isSameNodeID(sender,node)) {
          LOG.info(sender + ""String_Node_Str"");
        }
 else {
          LOG.info(sender + ""String_Node_Str"" + node);
        }
      }
      continue;
    }
    if (!ContactUtils.isSameNodeID(sender,node) && NetworkSettings.FILTER_CLASS_C.getValue() && filter.isSameNetwork(node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(sender + ""String_Node_Str"" + node);
      }
      continue;
    }
    if (!ContactUtils.isSameAddressSpace(context.getLocalNode(),node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(node + ""String_Node_Str"");
      }
      continue;
    }
    if (ContactUtils.isCollision(context,node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(node + ""String_Node_Str"" + context.getLocalNode());
      }
      collisions.add(node);
      continue;
    }
    if (ContactUtils.isLocalContact(context,node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(""String_Node_Str"");
      }
      containsLocal=true;
      continue;
    }
    scrubbed.put(node.getNodeID(),node);
  }
  if (requiredRatio > 0f) {
    int total=scrubbed.size() + collisions.size();
    if (containsLocal) {
      total++;
    }
    float ratio=(float)total / nodes.size();
    this.isValidResponse=(ratio >= requiredRatio);
  }
 else {
    this.isValidResponse=true;
  }
}","private ContactsScrubber(Context context,Contact sender,Collection<? extends Contact> nodes,float requiredRatio){
  assert(!nodes.isEmpty());
  assert(requiredRatio >= 0f && requiredRatio <= 1f);
  this.nodes=nodes;
  this.scrubbed=new LinkedHashMap<KUID,Contact>(nodes.size());
  this.collisions=new LinkedHashSet<Contact>(1);
  Contact localNode=context.getLocalNode();
  SameClassFilter filter=new SameClassFilter(sender);
  boolean containsLocal=false;
  for (  Contact node : nodes) {
    if (!ContactUtils.isValidSocketAddress(node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(sender + ""String_Node_Str"" + node);
      }
      continue;
    }
    if (ContactUtils.isPrivateAddress(node)) {
      if (LOG.isInfoEnabled()) {
        if (ContactUtils.isSameNodeID(sender,node)) {
          LOG.info(sender + ""String_Node_Str"");
        }
 else {
          LOG.info(sender + ""String_Node_Str"" + node);
        }
      }
      continue;
    }
    if (!ContactUtils.isSameAddressSpace(localNode,node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(node + ""String_Node_Str"");
      }
      continue;
    }
    if (NetworkSettings.DROP_PUBLIC_IPV4_COMPATIBLE_ADDRESSES.getValue() && ContactUtils.isIPv4CompatibleAddress(node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(node + ""String_Node_Str"");
      }
      continue;
    }
    if (NetworkSettings.DROP_PRIVATE_IPV4_COMPATIBLE_ADDRESSES.getValue() && ContactUtils.isPrivateIPv4CompatibleAddress(node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(node + ""String_Node_Str"");
      }
      continue;
    }
    if (NetworkSettings.FILTER_CLASS_C.getValue() && ContactUtils.isIPv4Address(node) && !ContactUtils.isSameNodeID(sender,node)&& filter.isSameNetwork(node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(sender + ""String_Node_Str"" + node);
      }
      continue;
    }
    if (ContactUtils.isCollision(context,node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(node + ""String_Node_Str"" + context.getLocalNode());
      }
      collisions.add(node);
      continue;
    }
    if (ContactUtils.isLocalContact(context,node)) {
      if (LOG.isInfoEnabled()) {
        LOG.info(""String_Node_Str"");
      }
      containsLocal=true;
      continue;
    }
    scrubbed.put(node.getNodeID(),node);
  }
  if (requiredRatio > 0f) {
    int total=scrubbed.size() + collisions.size();
    if (containsLocal) {
      total++;
    }
    float ratio=(float)total / nodes.size();
    this.isValidResponse=(ratio >= requiredRatio);
  }
 else {
    this.isValidResponse=true;
  }
}",0.8008695652173913
4218,"private boolean add(Contact node){
  InetAddress addr=((InetSocketAddress)node.getContactAddress()).getAddress();
  if (addr instanceof Inet6Address) {
    if (!((Inet6Address)addr).isIPv4CompatibleAddress() && !NetworkUtils.isIPv4MappedAddress(addr)) {
      return true;
    }
  }
  int key=NetworkUtils.getMaskedIP(addr,NetworkUtils.CLASS_C_NETMASK);
  return filter.put(key,node) == null;
}","private boolean add(Contact node){
  InetAddress addr=((InetSocketAddress)node.getContactAddress()).getAddress();
  int key=NetworkUtils.getMaskedIP(addr,NetworkUtils.CLASS_C_NETMASK);
  return filter.put(key,node) == null;
}",0.7269789983844911
4219,"/** 
 * Handles a node response message.  This type of message is handled in the same way regardless of the type of lookup.
 */
protected final boolean handleNodeResponse(FindNodeResponse response){
  Contact sender=response.getContact();
  Collection<? extends Contact> nodes=response.getNodes();
  if (!nodes.isEmpty()) {
    ContactFilter filter=new ContactFilter(context,sender);
    for (    Contact node : nodes) {
      if (!filter.isValidContact(node)) {
        if (LOG.isInfoEnabled()) {
          LOG.info(""String_Node_Str"" + node + ""String_Node_Str""+ sender);
        }
        continue;
      }
      if (!isQueried(node) && !isYetToBeQueried(node)) {
        if (LOG.isTraceEnabled()) {
          LOG.trace(""String_Node_Str"" + node + ""String_Node_Str"");
        }
        addYetToBeQueried(node,currentHop + 1);
        assert(node.isAlive() == false);
        context.getRouteTable().add(node);
      }
    }
    collisions.addAll(filter.getCollisions());
    addToResponsePath(response);
  }
  return true;
}","/** 
 * Handles a node response message.  This type of message is handled in the same way regardless of the type of lookup.
 */
protected final boolean handleNodeResponse(FindNodeResponse response){
  Contact sender=response.getContact();
  Collection<? extends Contact> nodes=response.getNodes();
  if (!nodes.isEmpty()) {
    ContactFilter filter=new ContactFilter(context,sender);
    for (    Contact node : nodes) {
      if (!filter.isValidContact(node)) {
        if (LOG.isInfoEnabled()) {
          LOG.info(""String_Node_Str"" + node + ""String_Node_Str""+ sender);
        }
        continue;
      }
      if (!isQueried(node) && !isYetToBeQueried(node)) {
        if (LOG.isTraceEnabled()) {
          LOG.trace(""String_Node_Str"" + node + ""String_Node_Str"");
        }
        addYetToBeQueried(node,currentHop + 1);
        assert(node.isAlive() == false);
        context.getRouteTable().add(node);
      }
    }
    collisions.addAll(filter.getCollisions());
  }
  addToResponsePath(response);
  return true;
}",0.9843597262952102
4220,"/** 
 * Tests that the progress is not 0% when resume button is hit while requerying.  This was caused by the call to cleanup() from tryAllDownloads3() and was reported by Sam Berlin.  Changed after requeries have been shut off (requery-expunge-branch).
 */
public void testRequeryProgress() throws Exception {
  LOG.info(""String_Node_Str"");
  TestUploader uploader=null;
  ManagedDownloader downloader=null;
  try {
    uploader=new TestUploader(""String_Node_Str"",PORT);
    uploader.stopAfter(500);
    uploader.setSendThexTreeHeader(false);
    uploader.setSendThexTree(false);
    downloader=new ManagedDownloader(new RemoteFileDesc[]{newRFD(""String_Node_Str"",FileDescStub.DEFAULT_URN.toString())},new IncompleteFileManager(),null);
    downloader.initialize(manager,fileman,callback);
    requestStart(downloader);
    Thread.sleep(140000);
    assertEquals(""String_Node_Str"",500,downloader.getAmountRead());
    assertEquals(""String_Node_Str"",Downloader.WAITING_FOR_USER,downloader.getState());
    downloader.resume();
    try {
      Thread.sleep(2000);
    }
 catch (    InterruptedException e) {
    }
    assertEquals(Downloader.WAITING_FOR_CONNECTIONS,downloader.getState());
    assertEquals(500,downloader.getAmountRead());
  }
  finally {
    if (uploader != null)     uploader.stopThread();
    if (downloader != null)     downloader.stop();
  }
}","/** 
 * Tests that the progress is not 0% when resume button is hit while requerying.  This was caused by the call to cleanup() from tryAllDownloads3() and was reported by Sam Berlin.  Changed after requeries have been shut off (requery-expunge-branch).
 */
public void testRequeryProgress() throws Exception {
  LOG.info(""String_Node_Str"");
  TestUploader uploader=null;
  ManagedDownloader downloader=null;
  try {
    uploader=new TestUploader(""String_Node_Str"",PORT);
    uploader.stopAfter(500);
    uploader.setSendThexTreeHeader(false);
    uploader.setSendThexTree(false);
    downloader=new ManagedDownloader(new RemoteFileDesc[]{newRFD(""String_Node_Str"",FileDescStub.DEFAULT_URN.toString())},new IncompleteFileManager(),null);
    downloader.initialize(manager,fileman,callback);
    requestStart(downloader);
    uploader.waitForUploaderToStop();
    try {
      Thread.sleep(5 * 1000);
    }
 catch (    InterruptedException ie) {
    }
    assertEquals(""String_Node_Str"",500,downloader.getAmountRead());
    try {
      Thread.sleep(60 * 1000);
    }
 catch (    InterruptedException ie) {
    }
    assertEquals(""String_Node_Str"",Downloader.WAITING_FOR_USER,downloader.getState());
    downloader.resume();
    try {
      Thread.sleep(2000);
    }
 catch (    InterruptedException e) {
    }
    assertEquals(Downloader.WAITING_FOR_CONNECTIONS,downloader.getState());
    assertEquals(500,downloader.getAmountRead());
  }
  finally {
    if (uploader != null)     uploader.stopThread();
    if (downloader != null)     downloader.stop();
  }
}",0.9195480999657653
4221,"/** 
 * Repeatedly accepts connections and handles them.
 */
private void loop(int port){
  Socket socket=null;
  while (true) {
    try {
      socket=server.accept();
      connects++;
      if (connects > maxConnects) {
        LOG.debug(""String_Node_Str"");
        socket.close();
        continue;
      }
      InetAddress address=socket.getInetAddress();
      if (isBannedIP(address.getHostAddress())) {
        LOG.debug(""String_Node_Str"");
        server.close();
        continue;
      }
      LOG.debug(""String_Node_Str"");
      final Socket mySocket=socket;
      Thread runner=new Thread(new SocketHandler(mySocket),name);
      runner.start();
    }
 catch (    IOException e) {
      LOG.debug(""String_Node_Str"",e);
      try {
        server.close();
      }
 catch (      IOException ignore) {
      }
      return;
    }
  }
}","/** 
 * Repeatedly accepts connections and handles them.
 */
private void loop(int port){
  Socket socket=null;
  while (true) {
    try {
      socket=server.accept();
      connects++;
      if (connects > maxConnects) {
        LOG.debug(""String_Node_Str"");
        socket.close();
        continue;
      }
      InetAddress address=socket.getInetAddress();
      if (isBannedIP(address.getHostAddress())) {
        LOG.debug(""String_Node_Str"");
        socket.close();
        continue;
      }
      LOG.debug(""String_Node_Str"");
      final Socket mySocket=socket;
      Thread runner=new Thread(new SocketHandler(mySocket),name);
      runner.start();
    }
 catch (    IOException e) {
      LOG.debug(""String_Node_Str"",e);
      try {
        server.close();
      }
 catch (      IOException ignore) {
      }
      return;
    }
  }
}",0.9940898345153664
4222,"private void send(OutputStream out,int start,int stop) throws IOException {
  LOG.debug(""String_Node_Str"" + start + ""String_Node_Str""+ stop);
  totalAmountToUpload+=stop - start;
  long t0=System.currentTimeMillis();
  if (minPollTime > 0)   Assert.that(t0 > minPollTime,""String_Node_Str"" + (minPollTime - t0) + ""String_Node_Str"");
  if (maxPollTime > 0)   Assert.that(t0 < maxPollTime,""String_Node_Str"" + (t0 - maxPollTime) + ""String_Node_Str"");
  String httpValue=respondWithHTTP11 ? ""String_Node_Str"" : ""String_Node_Str"";
  String str=httpValue + ""String_Node_Str"" + (busy || queue || partial == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
  out.write(str.getBytes());
  if (busy && retryAfter != -1) {
    str=""String_Node_Str"" + retryAfter + ""String_Node_Str"";
    out.write(str.getBytes());
  }
  if (queue) {
    LOG.debug(""String_Node_Str"");
    str=""String_Node_Str"" + queuePos + ""String_Node_Str""+ MIN_POLL / 1000 + ""String_Node_Str"" + MAX_POLL / 1000 + ""String_Node_Str"";
    out.write(str.getBytes());
    str=""String_Node_Str"";
    out.write(str.getBytes());
    out.flush();
    long t=System.currentTimeMillis();
    minPollTime=t + MIN_POLL;
    maxPollTime=t + MAX_POLL;
    return;
  }
  if (partial > 0) {
switch (partial) {
case 1:
      str=""String_Node_Str"";
    break;
case 2:
  str=""String_Node_Str"";
break;
default :
str=""String_Node_Str"";
}
out.write(str.getBytes());
out.flush();
partial++;
if (partial == 2) {
str=""String_Node_Str"";
out.write(str.getBytes());
out.flush();
return;
}
}
if (sendContentLength) {
str=""String_Node_Str"" + (stop - start) + ""String_Node_Str"";
out.write(str.getBytes());
}
if (start != 0 || (stop - start != TestFile.length())) {
str=""String_Node_Str"" + start + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str""+ TestFile.length()+ ""String_Node_Str"";
out.write(str.getBytes());
}
if (storedGoodLocs != null && storedGoodLocs.hasAlternateLocations()) {
LOG.debug(""String_Node_Str"" + storedGoodLocs + ""String_Node_Str"");
HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,storedGoodLocs,out);
}
 else {
LOG.debug(""String_Node_Str"" + storedGoodLocs + ""String_Node_Str"");
}
if (storedBadLocs != null && storedBadLocs.hasAlternateLocations()) {
LOG.debug(""String_Node_Str"" + storedBadLocs + ""String_Node_Str"");
HTTPUtils.writeHeader(HTTPHeaderName.NALTS,storedBadLocs,out);
}
 else {
LOG.debug(""String_Node_Str"" + storedBadLocs + ""String_Node_Str"");
}
if (creationTime != null) {
LOG.debug(""String_Node_Str"");
HTTPUtils.writeHeader(HTTPHeaderName.CREATION_TIME,""String_Node_Str"" + creationTime,out);
}
if (sendThexTreeHeader) {
HTTPUtils.writeHeader(HTTPHeaderName.THEX_URI,TestFile.tree(),out);
}
if (interestedInFalts) {
if (!isFirewalled) HTTPUtils.writeFeatures(out);
 else {
boolean previous=RouterService.acceptedIncomingConnection();
try {
PrivilegedAccessor.setValue(RouterService.getAcceptor(),""String_Node_Str"",new Boolean(false));
HTTPUtils.writeFeatures(out);
PrivilegedAccessor.setValue(RouterService.getAcceptor(),""String_Node_Str"",new Boolean(previous));
}
 catch (Exception bad) {
ErrorService.error(bad);
}
}
}
if (isFirewalled && _proxiesString != null) {
HTTPUtils.writeHeader(HTTPHeaderName.PROXIES,_proxiesString,out);
}
out.flush();
if (stallHeaders) {
LOG.debug(""String_Node_Str"");
try {
Thread.sleep(100000000);
}
 catch (InterruptedException end) {
return;
}
}
str=""String_Node_Str"";
out.write(str.getBytes());
out.flush();
if (busy) {
if (connects >= timesBusy) busy=false;
out.close();
return;
}
int length=stop - start;
int okLength=length - (int)(length * corruptPercentage);
amountThisRequest=0;
boolean sentCorrupt=false;
for (int i=start; i < stop; ) {
if (stopAfter > -1) {
Assert.that(fullRequestsUploaded + amountThisRequest <= stopAfter,""String_Node_Str"" + fullRequestsUploaded + ""String_Node_Str""+ amountThisRequest+ ""String_Node_Str""+ stopAfter);
if (fullRequestsUploaded + amountThisRequest == stopAfter) {
stopped=true;
out.flush();
LOG.debug(name + ""String_Node_Str"" + (fullRequestsUploaded + amountThisRequest));
throw new IOException();
}
}
throttle.request(1);
if (sendCorrupt && (i - start) >= okLength) {
sentCorrupt=true;
out.write(TestFile.getByte(i) + (byte)1);
}
 else out.write(TestFile.getByte(i));
amountThisRequest++;
i++;
}
if (sentCorrupt) LOG.debug(""String_Node_Str"");
out.flush();
fullRequestsUploaded+=amountThisRequest;
amountThisRequest=0;
}","private void send(OutputStream out,int start,int stop) throws IOException {
  LOG.debug(""String_Node_Str"" + start + ""String_Node_Str""+ stop);
  totalAmountToUpload+=stop - start;
  long t0=System.currentTimeMillis();
  if (minPollTime > 0)   Assert.that(t0 > minPollTime,""String_Node_Str"" + (minPollTime - t0) + ""String_Node_Str"");
  if (maxPollTime > 0)   Assert.that(t0 < maxPollTime,""String_Node_Str"" + (t0 - maxPollTime) + ""String_Node_Str"");
  String httpValue=respondWithHTTP11 ? ""String_Node_Str"" : ""String_Node_Str"";
  String str=httpValue + ""String_Node_Str"" + (busy || queue || partial == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
  out.write(str.getBytes());
  if (busy && retryAfter != -1) {
    str=""String_Node_Str"" + retryAfter + ""String_Node_Str"";
    out.write(str.getBytes());
  }
  if (queue) {
    LOG.debug(""String_Node_Str"");
    str=""String_Node_Str"" + queuePos + ""String_Node_Str""+ MIN_POLL / 1000 + ""String_Node_Str"" + MAX_POLL / 1000 + ""String_Node_Str"";
    out.write(str.getBytes());
    str=""String_Node_Str"";
    out.write(str.getBytes());
    out.flush();
    long t=System.currentTimeMillis();
    minPollTime=t + MIN_POLL;
    maxPollTime=t + MAX_POLL;
    return;
  }
  if (partial > 0) {
switch (partial) {
case 1:
      str=""String_Node_Str"";
    break;
case 2:
  str=""String_Node_Str"";
break;
default :
str=""String_Node_Str"";
}
out.write(str.getBytes());
out.flush();
partial++;
if (partial == 2) {
str=""String_Node_Str"";
out.write(str.getBytes());
out.flush();
return;
}
}
if (sendContentLength) {
str=""String_Node_Str"" + (stop - start) + ""String_Node_Str"";
out.write(str.getBytes());
}
if (start != 0 || (stop - start != TestFile.length())) {
str=""String_Node_Str"" + start + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str""+ TestFile.length()+ ""String_Node_Str"";
out.write(str.getBytes());
}
if (storedGoodLocs != null && storedGoodLocs.hasAlternateLocations()) {
LOG.debug(""String_Node_Str"" + storedGoodLocs + ""String_Node_Str"");
HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,storedGoodLocs,out);
}
 else {
LOG.debug(""String_Node_Str"" + storedGoodLocs + ""String_Node_Str"");
}
if (storedBadLocs != null && storedBadLocs.hasAlternateLocations()) {
LOG.debug(""String_Node_Str"" + storedBadLocs + ""String_Node_Str"");
HTTPUtils.writeHeader(HTTPHeaderName.NALTS,storedBadLocs,out);
}
 else {
LOG.debug(""String_Node_Str"" + storedBadLocs + ""String_Node_Str"");
}
if (creationTime != null) {
LOG.debug(""String_Node_Str"");
HTTPUtils.writeHeader(HTTPHeaderName.CREATION_TIME,""String_Node_Str"" + creationTime,out);
}
if (sendThexTreeHeader) {
HTTPUtils.writeHeader(HTTPHeaderName.THEX_URI,TestFile.tree(),out);
}
if (interestedInFalts) {
if (!isFirewalled) HTTPUtils.writeFeatures(out);
 else {
boolean previous=RouterService.acceptedIncomingConnection();
try {
PrivilegedAccessor.setValue(RouterService.getAcceptor(),""String_Node_Str"",new Boolean(false));
HTTPUtils.writeFeatures(out);
PrivilegedAccessor.setValue(RouterService.getAcceptor(),""String_Node_Str"",new Boolean(previous));
}
 catch (Exception bad) {
ErrorService.error(bad);
}
}
}
if (isFirewalled && _proxiesString != null) {
HTTPUtils.writeHeader(HTTPHeaderName.PROXIES,_proxiesString,out);
}
out.flush();
if (stallHeaders) {
LOG.debug(""String_Node_Str"");
try {
Thread.sleep(100000000);
}
 catch (InterruptedException end) {
return;
}
}
str=""String_Node_Str"";
out.write(str.getBytes());
out.flush();
if (busy) {
if (connects >= timesBusy) busy=false;
out.close();
return;
}
int length=stop - start;
int okLength=length - (int)(length * corruptPercentage);
amountThisRequest=0;
boolean sentCorrupt=false;
for (int i=start; i < stop; ) {
if (stopAfter > -1) {
Assert.that(fullRequestsUploaded + amountThisRequest <= stopAfter,""String_Node_Str"" + fullRequestsUploaded + ""String_Node_Str""+ amountThisRequest+ ""String_Node_Str""+ stopAfter);
if (fullRequestsUploaded + amountThisRequest == stopAfter) {
stopped=true;
synchronized (stoppedLock) {
stoppedLock.notifyAll();
}
out.flush();
LOG.debug(name + ""String_Node_Str"" + (fullRequestsUploaded + amountThisRequest));
throw new IOException();
}
}
throttle.request(1);
if (sendCorrupt && (i - start) >= okLength) {
sentCorrupt=true;
out.write(TestFile.getByte(i) + (byte)1);
}
 else out.write(TestFile.getByte(i));
amountThisRequest++;
i++;
}
if (sentCorrupt) LOG.debug(""String_Node_Str"");
out.flush();
fullRequestsUploaded+=amountThisRequest;
amountThisRequest=0;
}",0.9936029243774276
4223,"/** 
 * Notification that a read can happen on the SocketChannel.
 */
public void handleRead() throws IOException {
synchronized (bufferLock) {
    int read=0;
    while (buffer.hasRemaining() && (read=channel.read(buffer)) > 0)     ;
    if (read == -1)     source.finished();
    if (buffer.position() > 0 || read == -1)     bufferLock.notify();
    if (!buffer.hasRemaining() || read == -1)     channel.interestRead(false);
  }
}","/** 
 * Notification that a read can happen on the SocketChannel.
 */
public void handleRead() throws IOException {
  if (bufferLock == null) {
    channel.read(BufferUtils.getEmptyBuffer());
  }
 else {
synchronized (bufferLock) {
      int read=0;
      while (buffer.hasRemaining() && (read=channel.read(buffer)) > 0)       ;
      if (read == -1)       source.finished();
      if (buffer.position() > 0 || read == -1)       bufferLock.notify();
      if (!buffer.hasRemaining() || read == -1)       channel.interestRead(false);
    }
  }
}",0.8831967213114754
4224,"public int read(ByteBuffer dst) throws IOException {
  int transferred=0;
  if (readOutgoing != null && readOutgoing.position() > 0) {
    transferred+=BufferUtils.transfer(readOutgoing,dst);
  }
  while (true) {
    if (!dst.hasRemaining() && engine.getHandshakeStatus() == HandshakeStatus.NOT_HANDSHAKING) {
      LOG.debug(""String_Node_Str"");
      return transferred;
    }
    int read=-1;
    while (readIncoming.hasRemaining() && (read=readSink.read(readIncoming)) > 0)     ;
    if (read == -1 && readIncoming.position() == 0) {
      LOG.debug(""String_Node_Str"");
      return -1;
    }
    if (readIncoming.position() == 0)     return 0;
    readIncoming.flip();
    SSLEngineResult result=engine.unwrap(readIncoming,dst);
    transferred+=result.bytesProduced();
    SSLEngineResult.Status status=result.getStatus();
    if (status == Status.BUFFER_OVERFLOW) {
      if (readOutgoing == null)       readOutgoing=ByteBuffer.allocate(engine.getSession().getPacketBufferSize());
      result=engine.unwrap(readIncoming,readOutgoing);
      status=result.getStatus();
      if (status == Status.BUFFER_OVERFLOW)       throw new IllegalStateException(""String_Node_Str"");
      transferred+=BufferUtils.transfer(readOutgoing,dst);
    }
    if (readIncoming.hasRemaining()) {
      readDataLeft=true;
      readIncoming.compact();
    }
 else {
      readDataLeft=false;
      readIncoming.clear();
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + result);
    if (status == Status.BUFFER_UNDERFLOW)     return transferred;
    if (status == Status.CLOSED) {
      if (transferred == 0)       return -1;
 else       return transferred;
    }
    if (!processHandshakeResult(true,false,result.getHandshakeStatus()))     return transferred;
  }
}","public int read(ByteBuffer dst) throws IOException {
  int transferred=0;
  if (readOutgoing != null && readOutgoing.position() > 0) {
    transferred+=BufferUtils.transfer(readOutgoing,dst);
  }
  while (true) {
    if (!dst.hasRemaining() && engine.getHandshakeStatus() == HandshakeStatus.NOT_HANDSHAKING) {
      LOG.debug(""String_Node_Str"");
      return transferred;
    }
    int read=-1;
    while (readIncoming.hasRemaining() && (read=readSink.read(readIncoming)) > 0)     ;
    if (read == -1 && readIncoming.position() == 0) {
      LOG.debug(""String_Node_Str"");
      return -1;
    }
    if (readIncoming.position() == 0) {
      LOG.debug(""String_Node_Str"");
      return 0;
    }
    readIncoming.flip();
    SSLEngineResult result=engine.unwrap(readIncoming,dst);
    transferred+=result.bytesProduced();
    SSLEngineResult.Status status=result.getStatus();
    if (status == Status.BUFFER_OVERFLOW) {
      if (readOutgoing == null)       readOutgoing=ByteBuffer.allocate(engine.getSession().getPacketBufferSize());
      result=engine.unwrap(readIncoming,readOutgoing);
      status=result.getStatus();
      if (status == Status.BUFFER_OVERFLOW)       throw new IllegalStateException(""String_Node_Str"");
      transferred+=BufferUtils.transfer(readOutgoing,dst);
    }
    if (readIncoming.hasRemaining()) {
      readDataLeft=true;
      readIncoming.compact();
    }
 else {
      readDataLeft=false;
      readIncoming.clear();
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + result);
    if (status == Status.BUFFER_UNDERFLOW)     return transferred;
    if (status == Status.CLOSED) {
      if (transferred == 0)       return -1;
 else       return transferred;
    }
    if (!processHandshakeResult(true,false,result.getHandshakeStatus()))     return transferred;
  }
}",0.9871723368655884
4225,"/** 
 * Initializes this TLSLayer, using the given address and enabling the given cipherSuites. If clientMode is disabled, client authentication can be turned on/off.
 * @param addr
 * @param cipherSuites
 */
void initialize(SocketAddress addr,String[] cipherSuites,boolean clientMode,boolean needClientAuth){
  if (!(addr instanceof InetSocketAddress))   throw new IllegalArgumentException(""String_Node_Str"");
  InetSocketAddress iaddr=(InetSocketAddress)addr;
  String host=iaddr.getAddress().getHostAddress();
  int port=iaddr.getPort();
  engine=context.createSSLEngine(host,port);
  engine.setEnabledCipherSuites(cipherSuites);
  engine.setUseClientMode(clientMode);
  if (!clientMode) {
    engine.setWantClientAuth(needClientAuth);
    engine.setNeedClientAuth(needClientAuth);
  }
  SSLSession session=engine.getSession();
  readIncoming=ByteBuffer.allocate(session.getApplicationBufferSize());
  writeOutgoing=ByteBuffer.allocate(session.getPacketBufferSize());
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + engine + ""String_Node_Str""+ session);
}","/** 
 * Initializes this TLSLayer, using the given address and enabling the given cipherSuites. If clientMode is disabled, client authentication can be turned on/off.
 * @param addr
 * @param cipherSuites
 */
void initialize(SocketAddress addr,String[] cipherSuites,boolean clientMode,boolean needClientAuth){
  if (addr != null) {
    if (!(addr instanceof InetSocketAddress))     throw new IllegalArgumentException(""String_Node_Str"");
    InetSocketAddress iaddr=(InetSocketAddress)addr;
    String host=iaddr.getAddress().getHostAddress();
    int port=iaddr.getPort();
    engine=context.createSSLEngine(host,port);
  }
 else {
    engine=context.createSSLEngine();
  }
  engine.setEnabledCipherSuites(cipherSuites);
  engine.setUseClientMode(clientMode);
  if (!clientMode) {
    engine.setWantClientAuth(needClientAuth);
    engine.setNeedClientAuth(needClientAuth);
  }
  SSLSession session=engine.getSession();
  readIncoming=ByteBuffer.allocate(session.getApplicationBufferSize());
  writeOutgoing=ByteBuffer.allocate(session.getPacketBufferSize());
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + engine + ""String_Node_Str""+ session);
}",0.9605026929982048
4226,"private void proxyLoop(){
  try {
    while (true) {
      Socket incomingProxy=null;
      incomingProxy=_proxyServer.accept();
      if (!_proxyOn)       fail(""String_Node_Str"");
      InputStream is=incomingProxy.getInputStream();
      OutputStream os=incomingProxy.getOutputStream();
      if (_proxyVersion == ProxyTest.SOCKS4)       checkSOCKS4(is,os);
 else       if (_proxyVersion == ProxyTest.SOCKS5)       checkSOCKS5(is,os);
 else       if (_proxyVersion == ProxyTest.HTTP)       checkHTTP(is,os);
 else       assertTrue(""String_Node_Str"",_isHTTPRequest);
      int a=0;
      try {
        if (_isHTTPRequest) {
          consumeHttpHeaders(is);
          writeHTTPBack(os);
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException x) {
          }
        }
 else {
          while (a != -1)           a=is.read();
        }
      }
 catch (      SocketException se) {
        if (!_makeError) {
          throw se;
        }
      }
      if (!incomingProxy.isClosed())       incomingProxy.close();
    }
  }
 catch (  IOException iox) {
    ErrorService.error(iox);
  }
}","private void proxyLoop(){
  try {
    while (true) {
      Socket incomingProxy=null;
      incomingProxy=_proxyServer.accept();
      boolean savedMakeError=_makeError;
      if (!_proxyOn)       fail(""String_Node_Str"");
      InputStream is=incomingProxy.getInputStream();
      OutputStream os=incomingProxy.getOutputStream();
      if (_proxyVersion == ProxyTest.SOCKS4)       checkSOCKS4(is,os);
 else       if (_proxyVersion == ProxyTest.SOCKS5)       checkSOCKS5(is,os);
 else       if (_proxyVersion == ProxyTest.HTTP)       checkHTTP(is,os);
 else       assertTrue(""String_Node_Str"",_isHTTPRequest);
      int a=0;
      try {
        if (_isHTTPRequest) {
          consumeHttpHeaders(is);
          writeHTTPBack(os);
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException x) {
          }
        }
 else {
          while (a != -1)           a=is.read();
        }
      }
 catch (      SocketException se) {
        if (!savedMakeError) {
          throw se;
        }
      }
      if (!incomingProxy.isClosed())       incomingProxy.close();
    }
  }
 catch (  IOException iox) {
    ErrorService.error(iox);
  }
}",0.9787234042553192
4227,"/** 
 * Adds a certain IP to the IPList.
 * @param ipStr a String containing the IP, see IP.java for formatting
 */
public void add(String ipStr){
  IP ip;
  try {
    ip=new IP(ipStr);
  }
 catch (  IllegalArgumentException e) {
    return;
  }
  AddFilter filter=new AddFilter(ip);
  Map.Entry<IP,IP> entry=ips.select(ip,filter);
  if (entry != null) {
    if (!entry.getKey().contains(ip)) {
      for (      IP obsolete : filter.getContained()) {
        ips.remove(obsolete);
      }
      ips.put(ip,ip);
    }
  }
 else {
    ips.put(ip,ip);
  }
}","/** 
 * Adds a certain IP to the IPList.
 * @param ipStr a String containing the IP, see IP.java for formatting
 */
public void add(String ipStr){
  IP ip;
  try {
    ip=new IP(ipStr);
  }
 catch (  IllegalArgumentException e) {
    return;
  }
  if (ip.equals(NULL_IP)) {
    ips.clear();
    ips.put(ip,ip);
    return;
  }
  AddFilter filter=new AddFilter(ip);
  Map.Entry<IP,IP> entry=ips.select(ip,filter);
  if (entry != null) {
    if (!entry.getKey().contains(ip)) {
      for (      IP obsolete : filter.getContained()) {
        ips.remove(obsolete);
      }
      ips.put(ip,ip);
    }
  }
 else {
    ips.put(ip,ip);
  }
}",0.9318755256518082
4228,"public void testContains(){
  IPList list=new IPList();
  list.add(""String_Node_Str"");
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertFalse(list.contains(new IP(""String_Node_Str"")));
  list.add(""String_Node_Str"");
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertFalse(list.contains(new IP(""String_Node_Str"")));
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertFalse(list.contains(new IP(""String_Node_Str"")));
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertFalse(list.contains(new IP(""String_Node_Str"")));
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertFalse(list.contains(new IP(""String_Node_Str"")));
}","public void testContains(){
  IPList list=new IPList();
  list.add(""String_Node_Str"");
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertFalse(list.contains(new IP(""String_Node_Str"")));
  assertEquals(1,list.size());
  list.add(""String_Node_Str"");
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertFalse(list.contains(new IP(""String_Node_Str"")));
  assertEquals(2,list.size());
  list.add(""String_Node_Str"");
  assertEquals(2,list.size());
  list.add(""String_Node_Str"");
  assertEquals(2,list.size());
  list.add(""String_Node_Str"");
  assertEquals(3,list.size());
  list.add(""String_Node_Str"");
  assertEquals(4,list.size());
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertFalse(list.contains(new IP(""String_Node_Str"")));
  list.add(""String_Node_Str"");
  assertEquals(5,list.size());
  list.add(""String_Node_Str"");
  assertEquals(5,list.size());
  list.add(""String_Node_Str"");
  assertEquals(5,list.size());
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertFalse(list.contains(new IP(""String_Node_Str"")));
  list.add(""String_Node_Str"");
  assertEquals(6,list.size());
  list.add(""String_Node_Str"");
  assertEquals(7,list.size());
  list.add(""String_Node_Str"");
  assertEquals(6,list.size());
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertFalse(list.contains(new IP(""String_Node_Str"")));
  list.add(""String_Node_Str"");
  assertEquals(7,list.size());
  list.add(""String_Node_Str"");
  assertEquals(7,list.size());
  list.add(""String_Node_Str"");
  assertEquals(1,list.size());
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
  assertTrue(list.contains(new IP(""String_Node_Str"")));
}",0.5631789594053745
4229,"@Override public void setReadOnly(RandomAccessFile raf,String path) throws IOException {
  MappedByteBuffer buf;
synchronized (this) {
    buf=bufMap.remove(raf);
  }
  try {
    safeForce(buf);
  }
  finally {
    if (!clean(buf)) {
      buf=null;
      System.gc();
    }
  }
  super.setReadOnly(raf,path);
  buf=raf.getChannel().map(MapMode.READ_ONLY,0,raf.length());
synchronized (this) {
    bufMap.put(raf,buf);
  }
}","@Override public RandomAccessFile setReadOnly(RandomAccessFile raf,String path) throws IOException {
  MappedByteBuffer buf;
synchronized (this) {
    buf=bufMap.remove(raf);
  }
  try {
    safeForce(buf);
  }
  finally {
    if (!clean(buf)) {
      buf=null;
      System.gc();
    }
  }
  raf=super.setReadOnly(raf,path);
  buf=raf.getChannel().map(MapMode.READ_ONLY,0,raf.length());
synchronized (this) {
    bufMap.put(raf,buf);
  }
  return raf;
}",0.9544419134396356
4230,"protected void setReadOnly(RandomAccessFile f,String path) throws IOException {
  f.close();
  f=new RandomAccessFile(path,""String_Node_Str"");
}","protected RandomAccessFile setReadOnly(RandomAccessFile f,String path) throws IOException {
  f.close();
  return new RandomAccessFile(path,""String_Node_Str"");
}",0.918032786885246
4231,"/** 
 * Checks whether the given upload may proceed based on number of slots, position in upload queue, etc.  Updates the upload queue as necessary. Always accepts Browse Host requests, though.  Notifies callback of this.
 * @return ACCEPTED if the download may proceed, QUEUED if this is in theupload queue, REJECTED if this is flat-out disallowed (and hence not queued) and BANNED if the downloader is hammering us, and BYPASS_QUEUE if this is a File-View request that isn't hammering us. If REJECTED,  <tt>uploader</tt>'s state will be set to LIMIT_REACHED. If BANNED, the <tt>Uploader</tt>'s state will be set to BANNED_GREEDY.
 * @exception IOException the request came sooner than allowed by uploadqueueing rules.  (Throwing IOException forces the connection to be closed by the calling code.)  
 */
private synchronized int checkAndQueue(HTTPSession session) throws IOException {
  RequestCache rqc=(RequestCache)REQUESTS.get(session.getHost());
  if (rqc == null)   rqc=new RequestCache();
  REQUESTS.put(session.getHost(),rqc);
  rqc.countRequest();
  if (rqc.isHammering()) {
    if (LOG.isWarnEnabled())     LOG.warn(session.getUploader() + ""String_Node_Str"");
    return BANNED;
  }
  FileDesc fd=session.getUploader().getFileDesc();
  if (!fd.isVerified())   RouterService.getFileManager().validate(fd);
  URN sha1=fd.getSHA1Urn();
  if (rqc.isDupe(sha1))   return REJECTED;
  boolean greedy=rqc.isGreedy(sha1);
  if (slotManager.positionInQueue(session) == -1) {
    if (!greedy && hostLimitReached(session.getHost())) {
      LOG.debug(""String_Node_Str"");
      greedy=true;
      rqc.limitReached(sha1);
    }
 else     if (greedy && slotManager.getNumQueued() > 0) {
      if (LOG.isDebugEnabled())       LOG.debug(session.getUploader() + ""String_Node_Str"");
      return REJECTED;
    }
  }
  int queued=slotManager.pollForSlot(session,!greedy && session.getUploader().supportsQueueing());
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + queued);
  if (queued == -1) {
    if (!session.getUploader().supportsQueueing())     slotManager.cancelRequest(session);
    return REJECTED;
  }
  if (queued > 0 && session.poll()) {
    slotManager.cancelRequest(session);
    throw new IOException(""String_Node_Str"");
  }
  if (queued > 0)   return QUEUED;
 else {
    rqc.startedUpload(sha1);
    return ACCEPTED;
  }
}","/** 
 * Checks whether the given upload may proceed based on number of slots, position in upload queue, etc.  Updates the upload queue as necessary. Always accepts Browse Host requests, though.  Notifies callback of this.
 * @return ACCEPTED if the download may proceed, QUEUED if this is in theupload queue, REJECTED if this is flat-out disallowed (and hence not queued) and BANNED if the downloader is hammering us, and BYPASS_QUEUE if this is a File-View request that isn't hammering us. If REJECTED,  <tt>uploader</tt>'s state will be set to LIMIT_REACHED. If BANNED, the <tt>Uploader</tt>'s state will be set to BANNED_GREEDY.
 * @exception IOException the request came sooner than allowed by uploadqueueing rules.  (Throwing IOException forces the connection to be closed by the calling code.)  
 */
private synchronized int checkAndQueue(HTTPSession session) throws IOException {
  RequestCache rqc=(RequestCache)REQUESTS.get(session.getHost());
  if (rqc == null)   rqc=new RequestCache();
  REQUESTS.put(session.getHost(),rqc);
  rqc.countRequest();
  if (rqc.isHammering()) {
    if (LOG.isWarnEnabled())     LOG.warn(session.getUploader() + ""String_Node_Str"");
    return BANNED;
  }
  FileDesc fd=session.getUploader().getFileDesc();
  if (!fd.isVerified())   RouterService.getFileManager().validate(fd);
  URN sha1=fd.getSHA1Urn();
  if (rqc.isDupe(sha1))   return REJECTED;
  boolean greedy=rqc.isGreedy(sha1);
  if (slotManager.positionInQueue(session) == -1) {
    if (!greedy && hostLimitReached(session.getHost())) {
      LOG.debug(""String_Node_Str"");
      greedy=true;
      rqc.limitReached(sha1);
    }
    if (greedy) {
      if (LOG.isDebugEnabled())       LOG.debug(session.getUploader() + ""String_Node_Str"");
      UploadStat.LIMIT_REACHED_GREEDY.incrementStat();
      return REJECTED;
    }
  }
  int queued=slotManager.pollForSlot(session,session.getUploader().supportsQueueing());
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + queued);
  if (queued == -1) {
    if (!session.getUploader().supportsQueueing())     slotManager.cancelRequest(session);
    return REJECTED;
  }
  if (queued > 0 && session.poll()) {
    slotManager.cancelRequest(session);
    throw new IOException(""String_Node_Str"");
  }
  if (queued > 0)   return QUEUED;
 else {
    rqc.startedUpload(sha1);
    return ACCEPTED;
  }
}",0.9773794280836534
4232,"public void testGreedyLimitReached() throws Exception {
  UploadSettings.HARD_MAX_UPLOADS.setValue(2);
  UploadSettings.SOFT_MAX_UPLOADS.setValue(9999);
  UploadSettings.UPLOADS_PER_PERSON.setValue(2);
  UploadSettings.UPLOAD_QUEUE_SIZE.setValue(10);
  HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
  connectDloader(d1,true,rfd1,true);
  HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
  connectDloader(d2,true,rfd1,true);
  HTTPDownloader d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
  try {
    connectDloader(d3,true,rfd1,true);
    fail(""String_Node_Str"");
  }
 catch (  QueuedException qx) {
    fail(""String_Node_Str"",qx);
  }
catch (  TryAgainLaterException expectedException) {
  }
catch (  IOException ioe) {
  }
  HTTPDownloader d4=addUploader(upManager,rfd4,""String_Node_Str"",true);
  try {
    connectDloader(d4,true,rfd1,true);
    fail(""String_Node_Str"");
  }
 catch (  TryAgainLaterException tx) {
    fail(""String_Node_Str"",tx);
  }
catch (  QueuedException expectedException) {
  }
catch (  IOException ioe) {
    fail(""String_Node_Str"",ioe);
  }
  assertEquals(""String_Node_Str"",1,upManager.getNumQueuedUploads());
  assertEquals(""String_Node_Str"",2,upManager.uploadsInProgress());
  kill(d1);
  kill(d2);
  assertEquals(""String_Node_Str"",1,upManager.getNumQueuedUploads());
  assertEquals(""String_Node_Str"",0,upManager.uploadsInProgress());
  try {
    d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
    connectDloader(d3,true,rfd1,true);
    fail(""String_Node_Str"");
  }
 catch (  QueuedException qx) {
    fail(""String_Node_Str"",qx);
  }
catch (  TryAgainLaterException expectedException) {
  }
catch (  IOException ioe) {
  }
  assertEquals(""String_Node_Str"",1,upManager.getNumQueuedUploads());
  assertEquals(""String_Node_Str"",0,upManager.uploadsInProgress());
}","public void testGreedyLimitReached() throws Exception {
  UploadSettings.HARD_MAX_UPLOADS.setValue(2);
  UploadSettings.SOFT_MAX_UPLOADS.setValue(9999);
  UploadSettings.UPLOADS_PER_PERSON.setValue(1);
  UploadSettings.UPLOAD_QUEUE_SIZE.setValue(10);
  HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
  connectDloader(d1,true,rfd1,true);
  HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
  try {
    connectDloader(d2,true,rfd2,true);
    fail(""String_Node_Str"");
  }
 catch (  QueuedException qx) {
    fail(""String_Node_Str"",qx);
  }
catch (  TryAgainLaterException expectedException) {
  }
catch (  IOException ioe) {
  }
  HTTPDownloader d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
  connectDloader(d3,true,rfd3,true);
  HTTPDownloader d4=addUploader(upManager,rfd4,""String_Node_Str"",true);
  try {
    connectDloader(d4,true,rfd4,true);
    fail(""String_Node_Str"");
  }
 catch (  TryAgainLaterException expected) {
  }
catch (  QueuedException que) {
    fail(""String_Node_Str"",que);
  }
catch (  IOException ioe) {
    fail(""String_Node_Str"",ioe);
  }
  HTTPDownloader d5=addUploader(upManager,rfd5,""String_Node_Str"",true);
  try {
    connectDloader(d5,true,rfd5,true);
    fail(""String_Node_Str"");
  }
 catch (  QueuedException expected) {
  }
  assertEquals(""String_Node_Str"",1,upManager.getNumQueuedUploads());
  assertEquals(""String_Node_Str"",2,upManager.uploadsInProgress());
  kill(d1);
  kill(d3);
  assertEquals(""String_Node_Str"",1,upManager.getNumQueuedUploads());
  assertEquals(""String_Node_Str"",0,upManager.uploadsInProgress());
  try {
    d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd2,true);
    fail(""String_Node_Str"");
  }
 catch (  QueuedException qx) {
    fail(""String_Node_Str"",qx);
  }
catch (  TryAgainLaterException expectedException) {
  }
catch (  IOException ioe) {
  }
  assertEquals(""String_Node_Str"",1,upManager.getNumQueuedUploads());
  assertEquals(""String_Node_Str"",0,upManager.uploadsInProgress());
}",0.8087516087516088
4233,"public boolean add(Object o){
  throw new UnsupportedOperationException();
}","public boolean add(T o){
  throw new UnsupportedOperationException();
}",0.9523809523809524
4234,"/** 
 * Constructs a BTMetaInfo based on the BTData.
 */
private BTMetaInfo(BTData data) throws ValueException {
  try {
    URI trackerURI=new URI(data.getAnnounce());
    if (!""String_Node_Str"".equalsIgnoreCase(trackerURI.getScheme()))     throw new ValueException(""String_Node_Str"" + trackerURI.getScheme());
    _trackers=new URI[]{trackerURI};
  }
 catch (  URIException mue) {
    throw new ValueException(""String_Node_Str"" + data.getAnnounce());
  }
  _infoHash=data.getInfoHash();
  try {
    _infoHashURN=URN.createSHA1UrnFromBytes(_infoHash);
  }
 catch (  IOException impossible) {
    ErrorService.error(impossible);
  }
  _hashes=parsePieces(data.getPieces());
  data.clearPieces();
  _pieceLength=(int)data.getPieceLength().longValue();
  if (_pieceLength <= 0)   throw new ValueException(""String_Node_Str"" + data.getPieceLength());
  fileSystem=new TorrentFileSystem(data,_hashes.size(),_pieceLength,_infoHash);
  fullBitField=new BitFieldSet(fullSet,getNumBlocks());
  initializeDiskManager(null,false);
}","/** 
 * Constructs a BTMetaInfo based on the BTData.
 */
private BTMetaInfo(BTData data) throws IOException {
  try {
    URI trackerURI=new URI(data.getAnnounce());
    if (!""String_Node_Str"".equalsIgnoreCase(trackerURI.getScheme()))     throw new ValueException(""String_Node_Str"" + trackerURI.getScheme());
    _trackers=new URI[]{trackerURI};
  }
 catch (  URIException mue) {
    throw new ValueException(""String_Node_Str"" + data.getAnnounce());
  }
  _infoHash=data.getInfoHash();
  try {
    _infoHashURN=URN.createSHA1UrnFromBytes(_infoHash);
  }
 catch (  IOException impossible) {
    ErrorService.error(impossible);
  }
  _hashes=parsePieces(data.getPieces());
  data.clearPieces();
  _pieceLength=(int)data.getPieceLength().longValue();
  if (_pieceLength <= 0)   throw new ValueException(""String_Node_Str"" + data.getPieceLength());
  fileSystem=new TorrentFileSystem(data,_hashes.size(),_pieceLength,_infoHash);
  fullBitField=new BitFieldSet(fullSet,getNumBlocks());
  initializeDiskManager(null,false);
}",0.9965669445806769
4235,"void moveToCompleteFolder() throws IOException {
  saveFile(_incompleteFile,_completeFile);
  FileUtils.deleteRecursive(_incompleteFile.getParentFile());
}","void moveToCompleteFolder() throws IOException {
  boolean success=_incompleteFile.renameTo(_completeFile);
  if (!success) {
    success=CommonUtils.copy(_incompleteFile,_completeFile);
    if (success)     _incompleteFile.delete();
  }
}",0.4974619289340101
4236,"/** 
 * Constructs the file system using the given BTData & hash information. If any of the information is malformed, throws a ValueException.
 * @param data
 * @param numHashes
 * @param pieceLength
 * @param infoHash
 * @throws ValueException
 */
TorrentFileSystem(BTData data,int numHashes,long pieceLength,byte[] infoHash) throws ValueException {
  _name=CommonUtils.convertFileName(data.getName());
  if (_name.length() == 0)   throw new ValueException(""String_Node_Str"");
  File incompleteDir=SharingSettings.INCOMPLETE_DIRECTORY.getValue();
  try {
    incompleteDir=incompleteDir.getCanonicalFile();
  }
 catch (  IOException iox) {
  }
  _incompleteFile=new File(incompleteDir,Base32.encode(infoHash) + File.separator + _name);
  _completeFile=new File(SharingSettings.getSaveDirectory(),_name);
  if (data.getFiles() != null) {
    List<BTData.BTFileData> files=data.getFiles();
    List<TorrentFile> torrents=new ArrayList<TorrentFile>(files.size());
    for (    BTData.BTFileData file : files)     torrents.add(new TorrentFile(file.getLength(),new File(_completeFile,file.getPath()).getAbsolutePath()));
    if (files.size() == 0)     throw new ValueException(""String_Node_Str"");
    long position=0;
    for (    TorrentFile file : torrents) {
      file.setBegin((int)(position / pieceLength));
      position+=file.length();
      file.setEnd((int)(position / pieceLength));
    }
    _files=torrents;
    for (    String folderPath : data.getFolders())     _folders.add(new File(_completeFile,folderPath));
    _folders.add(_completeFile);
  }
 else {
    TorrentFile f=new TorrentFile(data.getLength(),_completeFile.getAbsolutePath());
    f.setBegin(0);
    f.setEnd(numHashes);
    _files=new ArrayList<TorrentFile>(1);
    _files.add(f);
  }
  _totalSize=calculateTotalSize(_files);
}","/** 
 * Constructs the file system using the given BTData & hash information. If any of the information is malformed, throws a ValueException.
 * @param data
 * @param numHashes
 * @param pieceLength
 * @param infoHash
 * @throws ValueException
 */
TorrentFileSystem(BTData data,int numHashes,long pieceLength,byte[] infoHash) throws IOException {
  _name=CommonUtils.convertFileName(data.getName());
  if (_name.length() == 0)   throw new ValueException(""String_Node_Str"");
  _incompleteFile=new File(SharingSettings.INCOMPLETE_DIRECTORY.getValue(),Base32.encode(infoHash) + File.separator + _name);
  _completeFile=new File(SharingSettings.getSaveDirectory(),_name);
  if (!FileUtils.isReallyParent(SharingSettings.getSaveDirectory(),_completeFile))   throw new SaveLocationException(SaveLocationException.SECURITY_VIOLATION,_completeFile);
  if (data.getFiles() != null) {
    List<BTData.BTFileData> files=data.getFiles();
    List<TorrentFile> torrents=new ArrayList<TorrentFile>(files.size());
    for (    BTData.BTFileData file : files) {
      TorrentFile f=new TorrentFile(file.getLength(),new File(_completeFile,file.getPath()).getAbsolutePath());
      if (!FileUtils.isReallyParent(_completeFile,f))       throw new SaveLocationException(SaveLocationException.SECURITY_VIOLATION,f);
      torrents.add(f);
    }
    if (files.size() == 0)     throw new ValueException(""String_Node_Str"");
    long position=0;
    for (    TorrentFile file : torrents) {
      file.setBegin((int)(position / pieceLength));
      position+=file.length();
      file.setEnd((int)(position / pieceLength));
    }
    _files=torrents;
    for (    String folderPath : data.getFolders())     _folders.add(new File(_completeFile,folderPath));
    _folders.add(_completeFile);
  }
 else {
    TorrentFile f=new TorrentFile(data.getLength(),_completeFile.getAbsolutePath());
    f.setBegin(0);
    f.setEnd(numHashes);
    _files=new ArrayList<TorrentFile>(1);
    _files.add(f);
  }
  _totalSize=calculateTotalSize(_files);
}",0.3174436877946568
4237,"void addToLibrary(){
  for (  File f : _folders)   RouterService.getFileManager().addSharedFolder(f);
  for (  File f : _files)   RouterService.getFileManager().addFileIfShared(f);
}","void addToLibrary(){
  if (_completeFile.isFile())   RouterService.getFileManager().addFileIfShared(_completeFile);
 else   if (_completeFile.isDirectory())   RouterService.getFileManager().addSharedFolder(_completeFile);
}",0.419753086419753
4238,"public String toString(){
  return ""String_Node_Str"" + query + ""String_Node_Str""+ hops+ ""String_Node_Str"";
}","public String toString(){
  return ""String_Node_Str"" + hops + ""String_Node_Str""+ metaMask+ ""String_Node_Str""+ URNs+ ""String_Node_Str""+ query+ ""String_Node_Str""+ xml+ ""String_Node_Str"";
}",0.6870748299319728
4239,"public void testQueryStringDuplicate() throws Exception {
  qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  assertTrue(filter.allow(qr));
  assertTrue(!filter.allow(qr));
  qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  assertTrue(filter.allow(qr));
synchronized (filter) {
    try {
      filter.wait(getLag(""String_Node_Str"") * 4);
    }
 catch (    InterruptedException e) {
    }
  }
  assertTrue(filter.allow(qr));
  assertTrue(!filter.allow(qr));
  qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  assertTrue(filter.allow(qr));
  qr.hop();
  assertTrue(filter.allow(qr));
}","public void testQueryStringDuplicate() throws Exception {
  qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  assertTrue(filter.allow(qr));
  qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  assertTrue(!filter.allow(qr));
  qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  assertTrue(filter.allow(qr));
synchronized (filter) {
    try {
      filter.wait(getLag(""String_Node_Str"") * 4);
    }
 catch (    InterruptedException e) {
    }
  }
  assertTrue(filter.allow(qr));
  qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  assertTrue(!filter.allow(qr));
  qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  assertTrue(filter.allow(qr));
  qr.hop();
  assertTrue(filter.allow(qr));
}",0.9130434782608696
4240,"/** 
 * Returns an entry strictly higher than the given key, or null if no such entry exists.
 */
protected TrieEntry<K,V> higherEntry(K key){
  int keyLength=length(key);
  if (keyLength == 0) {
    if (!root.isEmpty())     return firstEntry();
 else     if (size() > 1)     return nextEntry(firstEntry());
 else     return null;
  }
  TrieEntry<K,V> found=getNearestEntryForKey(key,keyLength);
  if (key.equals(found.key))   return nextEntry(found);
  int bitIndex=bitIndex(key,found.key);
  if (isValidBitIndex(bitIndex)) {
    TrieEntry<K,V> added=new TrieEntry<K,V>(key,null,bitIndex);
    addEntry(added,keyLength);
    incrementSize();
    TrieEntry<K,V> ceil=nextEntry(added);
    removeEntry(added);
    modCount-=2;
    return ceil;
  }
 else   if (isNullBitKey(bitIndex)) {
    if (!root.isEmpty())     return firstEntry();
 else     if (size() > 1)     return nextEntry(firstEntry());
 else     return null;
  }
 else   if (isEqualBitKey(bitIndex)) {
    return nextEntry(found);
  }
  throw new IllegalStateException(""String_Node_Str"" + key);
}","/** 
 * Returns an entry strictly higher than the given key, or null if no such entry exists.
 */
protected TrieEntry<K,V> higherEntry(K key){
  int keyLength=length(key);
  if (keyLength == 0) {
    if (!root.isEmpty()) {
      if (size() > 1) {
        return nextEntry(root);
      }
 else {
        return null;
      }
    }
 else {
      return firstEntry();
    }
  }
  TrieEntry<K,V> found=getNearestEntryForKey(key,keyLength);
  if (key.equals(found.key))   return nextEntry(found);
  int bitIndex=bitIndex(key,found.key);
  if (isValidBitIndex(bitIndex)) {
    TrieEntry<K,V> added=new TrieEntry<K,V>(key,null,bitIndex);
    addEntry(added,keyLength);
    incrementSize();
    TrieEntry<K,V> ceil=nextEntry(added);
    removeEntry(added);
    modCount-=2;
    return ceil;
  }
 else   if (isNullBitKey(bitIndex)) {
    if (!root.isEmpty())     return firstEntry();
 else     if (size() > 1)     return nextEntry(firstEntry());
 else     return null;
  }
 else   if (isEqualBitKey(bitIndex)) {
    return nextEntry(found);
  }
  throw new IllegalStateException(""String_Node_Str"" + key);
}",0.8997214484679665
4241,"/** 
 * Scans for the next node, starting at the specified point, and using 'previous' as a hint that the last node we returned was 'previous' (so we know not to return it again).  If 'tree' is non-null, this will limit the search to the given tree. The basic premise is that each iteration can follow the following steps: 1) Scan all the way to the left. a) If we already started from this node last time, proceed to Step 2. b) If a valid uplink is found, use it. c) If the result is an empty node (root not set), break the scan. d) If we already returned the left node, break the scan. 2) Check the right. a) If we already returned the right node, proceed to Step 3. b) If it is a valid uplink, use it. c) Do Step 1 from the right node. 3) Back up through the parents until we encounter find a parent that we're not the right child of. 4) If there's no right child of that parent, the iteration is finished. Otherwise continue to Step 5. 5) Check to see if the right child is a valid uplink. a) If we already returned that child, proceed to Step 6. Otherwise, use it. 6) If the right child of the parent is the parent itself, we've already found & returned the end of the Trie, so exit. 7) Do Step 1 on the parent's right child.
 */
private TrieEntry<K,V> nextEntryImpl(TrieEntry<K,V> start,TrieEntry<K,V> previous,TrieEntry<K,V> tree){
  TrieEntry<K,V> current=start;
  if (previous == null || start != previous.predecessor) {
    while (!current.left.isEmpty()) {
      if (previous == current.left) {
        break;
      }
      if (isValidUplink(current.left,current)) {
        return current.left;
      }
      current=current.left;
    }
  }
  if (current == null || current.isEmpty()) {
    return null;
  }
  if (previous != current.right) {
    if (isValidUplink(current.right,current)) {
      return current.right;
    }
    return nextEntryImpl(current.right,previous,tree);
  }
  while (current == current.parent.right) {
    if (current == tree)     return null;
    current=current.parent;
  }
  if (current == tree)   return null;
  if (current.parent.right == null) {
    return null;
  }
  if (previous != current.parent.right && isValidUplink(current.parent.right,current.parent)) {
    return current.parent.right;
  }
  if (current.parent.right == current.parent) {
    return null;
  }
  return nextEntryImpl(current.parent.right,previous,tree);
}","/** 
 * Scans for the next node, starting at the specified point, and using 'previous' as a hint that the last node we returned was 'previous' (so we know not to return it again).  If 'tree' is non-null, this will limit the search to the given tree. The basic premise is that each iteration can follow the following steps: 1) Scan all the way to the left. a) If we already started from this node last time, proceed to Step 2. b) If a valid uplink is found, use it. c) If the result is an empty node (root not set), break the scan. d) If we already returned the left node, break the scan. 2) Check the right. a) If we already returned the right node, proceed to Step 3. b) If it is a valid uplink, use it. c) Do Step 1 from the right node. 3) Back up through the parents until we encounter find a parent that we're not the right child of. 4) If there's no right child of that parent, the iteration is finished. Otherwise continue to Step 5. 5) Check to see if the right child is a valid uplink. a) If we already returned that child, proceed to Step 6. Otherwise, use it. 6) If the right child of the parent is the parent itself, we've already found & returned the end of the Trie, so exit. 7) Do Step 1 on the parent's right child.
 */
private TrieEntry<K,V> nextEntryImpl(TrieEntry<K,V> start,TrieEntry<K,V> previous,TrieEntry<K,V> tree){
  TrieEntry<K,V> current=start;
  if (previous == null || start != previous.predecessor) {
    while (!current.left.isEmpty()) {
      if (previous == current.left) {
        break;
      }
      if (isValidUplink(current.left,current)) {
        return current.left;
      }
      current=current.left;
    }
  }
  if (current.isEmpty()) {
    return null;
  }
  if (current.right == null)   return null;
  if (previous != current.right) {
    if (isValidUplink(current.right,current)) {
      return current.right;
    }
    return nextEntryImpl(current.right,previous,tree);
  }
  while (current == current.parent.right) {
    if (current == tree)     return null;
    current=current.parent;
  }
  if (current == tree)   return null;
  if (current.parent.right == null) {
    return null;
  }
  if (previous != current.parent.right && isValidUplink(current.parent.right,current.parent)) {
    return current.parent.right;
  }
  if (current.parent.right == current.parent) {
    return null;
  }
  return nextEntryImpl(current.parent.right,previous,tree);
}",0.9821914938194009
4242,"private TrieEntry(K key,V value,int bitIndex){
  this.key=key;
  this.value=value;
  this.bitIndex=bitIndex;
  this.parent=null;
  this.left=this;
  this.right=null;
}","private TrieEntry(K key,V value,int bitIndex){
  this.key=key;
  this.value=value;
  this.bitIndex=bitIndex;
  this.parent=null;
  this.left=this;
  this.right=null;
  this.predecessor=this;
}",0.9303621169916436
4243,"/** 
 * Finds the subtree that contains the prefix. This is very similar to getR but with the difference that we stop the lookup if h.bitIndex > keyLength.
 */
private TrieEntry<K,V> subtree(K prefix,int offset,int length){
  TrieEntry<K,V> current=root.left;
  TrieEntry<K,V> path=root;
  while (true) {
    if (current.bitIndex <= path.bitIndex || length < current.bitIndex)     break;
    path=current;
    if (!isBitSet(prefix,length + offset,current.bitIndex + offset)) {
      current=current.left;
    }
 else {
      current=current.right;
    }
  }
  TrieEntry<K,V> entry=current.isEmpty() ? path : current;
  if (entry.isEmpty())   return null;
  int offsetLength=offset + length;
  if (isBitSet(prefix,offsetLength,offsetLength) != isBitSet(entry.key,length(entry.key),length)) {
    return null;
  }
  int bitIndex=keyAnalyzer.bitIndex(prefix,offset,length,entry.key,0,length(entry.getKey()));
  if (bitIndex >= 0 && bitIndex < length)   return null;
  return entry;
}","/** 
 * Finds the subtree that contains the prefix. This is very similar to getR but with the difference that we stop the lookup if h.bitIndex > keyLength.
 */
private TrieEntry<K,V> subtree(K prefix,int offset,int length){
  TrieEntry<K,V> current=root.left;
  TrieEntry<K,V> path=root;
  while (true) {
    if (current.bitIndex <= path.bitIndex || length < current.bitIndex)     break;
    path=current;
    if (!isBitSet(prefix,length + offset,current.bitIndex + offset)) {
      current=current.left;
    }
 else {
      current=current.right;
    }
  }
  TrieEntry<K,V> entry=current.isEmpty() ? path : current;
  if (entry.isEmpty())   return null;
  int offsetLength=offset + length;
  if (entry == root && length(entry.getKey()) < offsetLength)   return null;
  if (isBitSet(prefix,offsetLength,offsetLength) != isBitSet(entry.key,length(entry.key),length)) {
    return null;
  }
  int bitIndex=keyAnalyzer.bitIndex(prefix,offset,length,entry.key,0,length(entry.getKey()));
  if (bitIndex >= 0 && bitIndex < length)   return null;
  return entry;
}",0.7383406971035837
4244,"public void testPrefixedBy(){
  PatriciaTrie<String,String> trie=new PatriciaTrie<String,String>(new CharSequenceKeyAnalyzer());
  final String[] keys=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String key : keys) {
    trie.put(key,key);
  }
  SortedMap<String,String> map;
  Iterator<String> iterator;
  Iterator<Map.Entry<String,String>> entryIterator;
  Map.Entry<String,String> entry;
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(8,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertNotNull(trie.get(""String_Node_Str""));
  assertNull(map.get(""String_Node_Str""));
  assertNull(trie.get(""String_Node_Str""));
  assertNull(map.get(""String_Node_Str""));
  iterator=map.values().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  assertEquals(4,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  assertNull(trie.get(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",trie.get(""String_Node_Str""));
  assertEquals(5,map.size());
  assertEquals(""String_Node_Str"",map.lastKey());
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  assertEquals(""String_Node_Str"",map.remove(""String_Node_Str""));
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(2,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  entryIterator=map.entrySet().iterator();
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  assertFalse(entryIterator.hasNext());
  trie.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(3,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  entryIterator=map.entrySet().iterator();
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  assertFalse(entryIterator.hasNext());
  assertEquals(""String_Node_Str"",trie.remove(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  assertEquals(2,map.size());
  entryIterator=map.entrySet().iterator();
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  assertFalse(entryIterator.hasNext());
  assertEquals(""String_Node_Str"",trie.remove(""String_Node_Str""));
  trie.put(""String_Node_Str"",""String_Node_Str"");
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(2,map.size());
  assertFalse(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  iterator=map.values().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertFalse(map.isEmpty());
  assertEquals(3,map.size());
  assertEquals(""String_Node_Str"",trie.remove(""String_Node_Str""));
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  iterator=map.keySet().iterator();
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(3,map.size());
  try {
    iterator.next();
    fail(""String_Node_Str"");
  }
 catch (  ConcurrentModificationException expected) {
  }
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(2,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  assertEquals(3,map.size());
  trie.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(3,map.size());
  assertEquals(""String_Node_Str"",map.remove(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  assertEquals(2,map.size());
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  assertEquals(""String_Node_Str"",trie.remove(""String_Node_Str""));
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertTrue(map.isEmpty());
  assertEquals(0,map.size());
  try {
    Object o=map.firstKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  try {
    Object o=map.lastKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  iterator=map.values().iterator();
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertTrue(map.isEmpty());
  assertEquals(0,map.size());
  try {
    Object o=map.firstKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  try {
    Object o=map.lastKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  iterator=map.values().iterator();
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertSame(trie,map);
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertTrue(map.isEmpty());
  assertEquals(0,map.size());
  try {
    Object o=map.firstKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  try {
    Object o=map.lastKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  iterator=map.values().iterator();
  assertFalse(iterator.hasNext());
}","public void testPrefixedBy(){
  PatriciaTrie<String,String> trie=new PatriciaTrie<String,String>(new CharSequenceKeyAnalyzer());
  final String[] keys=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (  String key : keys) {
    trie.put(key,key);
  }
  SortedMap<String,String> map;
  Iterator<String> iterator;
  Iterator<Map.Entry<String,String>> entryIterator;
  Map.Entry<String,String> entry;
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(8,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertNotNull(trie.get(""String_Node_Str""));
  assertNull(map.get(""String_Node_Str""));
  assertNull(trie.get(""String_Node_Str""));
  assertNull(map.get(""String_Node_Str""));
  iterator=map.values().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  assertEquals(4,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  assertNull(trie.get(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",trie.get(""String_Node_Str""));
  assertEquals(5,map.size());
  assertEquals(""String_Node_Str"",map.lastKey());
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  assertEquals(""String_Node_Str"",map.remove(""String_Node_Str""));
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(2,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  entryIterator=map.entrySet().iterator();
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  assertFalse(entryIterator.hasNext());
  trie.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(3,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  entryIterator=map.entrySet().iterator();
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  assertFalse(entryIterator.hasNext());
  assertEquals(""String_Node_Str"",trie.remove(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  assertEquals(2,map.size());
  entryIterator=map.entrySet().iterator();
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  entry=entryIterator.next();
  assertEquals(""String_Node_Str"",entry.getKey());
  assertEquals(""String_Node_Str"",entry.getValue());
  assertFalse(entryIterator.hasNext());
  assertEquals(""String_Node_Str"",trie.remove(""String_Node_Str""));
  trie.put(""String_Node_Str"",""String_Node_Str"");
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(2,map.size());
  assertFalse(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  iterator=map.values().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertFalse(map.isEmpty());
  assertEquals(3,map.size());
  assertEquals(""String_Node_Str"",trie.remove(""String_Node_Str""));
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  iterator=map.keySet().iterator();
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(3,map.size());
  try {
    iterator.next();
    fail(""String_Node_Str"");
  }
 catch (  ConcurrentModificationException expected) {
  }
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertTrue(map.isEmpty());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(2,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  assertEquals(3,map.size());
  trie.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(3,map.size());
  assertEquals(""String_Node_Str"",map.remove(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  assertEquals(2,map.size());
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  assertEquals(""String_Node_Str"",trie.remove(""String_Node_Str""));
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(""String_Node_Str"",map.firstKey());
  assertEquals(""String_Node_Str"",map.lastKey());
  iterator=map.keySet().iterator();
  assertEquals(""String_Node_Str"",iterator.next());
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertTrue(map.isEmpty());
  assertEquals(0,map.size());
  try {
    Object o=map.firstKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  try {
    Object o=map.lastKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  iterator=map.values().iterator();
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertTrue(map.isEmpty());
  assertEquals(0,map.size());
  try {
    Object o=map.firstKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  try {
    Object o=map.lastKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  iterator=map.values().iterator();
  assertFalse(iterator.hasNext());
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertSame(trie,map);
  map=trie.getPrefixedBy(""String_Node_Str"");
  assertTrue(map.isEmpty());
  assertEquals(0,map.size());
  try {
    Object o=map.firstKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  try {
    Object o=map.lastKey();
    fail(""String_Node_Str"" + o);
  }
 catch (  NoSuchElementException nsee) {
  }
  iterator=map.values().iterator();
  assertFalse(iterator.hasNext());
}",0.9946943483275664
4245,"/** 
 * build the  QRT table call to super.buildQRT and add XML specific Strings to QRT
 */
protected void buildQRT(){
  super.buildQRT();
  for (  String string : new MultiIterable<String>(getXMLKeyWords(),getXMLIndivisibleKeyWords()))   _queryRouteTable.add(string);
}","/** 
 * build the  QRT table call to super.buildQRT and add XML specific Strings to QRT
 */
protected void buildQRT(){
  super.buildQRT();
  for (  String string : getXMLKeyWords())   _queryRouteTable.add(string);
  for (  String string : getXMLIndivisibleKeyWords())   _queryRouteTable.addIndivisible(string);
}",0.8316151202749141
4246,"/** 
 * Browses the files on the specified host and port.
 * @param host The IP of the host you want to browse.
 * @param port The port of the host you want to browse.
 * @param proxies the <tt>Set</tt> of push proxies to try
 * @param canDoFWTransfer Whether or not this guy can do a firewalltransfer.
 */
public void browseHost(String host,int port,Set proxies,boolean canDoFWTransfer){
  if (!NetworkUtils.isValidPort(port) || !NetworkUtils.isValidAddress(host)) {
    failed();
    return;
  }
  LOG.trace(""String_Node_Str"");
  setState(STARTED);
  int shouldPush=needsPush(host);
  LOG.trace(""String_Node_Str"" + shouldPush);
  boolean shouldTryPush=false;
switch (shouldPush) {
case 0:
    try {
      setState(DIRECTLY_CONNECTING);
      LOG.trace(""String_Node_Str"");
      Socket socket=Sockets.connect(host,port,DIRECT_CONNECT_TIME);
      LOG.trace(""String_Node_Str"");
      browseExchange(socket);
    }
 catch (    IOException ioe) {
      LOG.debug(""String_Node_Str"",ioe);
      shouldTryPush=true;
    }
  if (!shouldTryPush)   break;
case 1:
LOG.debug(""String_Node_Str"");
if (_serventID == null) {
LOG.debug(""String_Node_Str"");
failed();
}
 else {
RemoteFileDesc fakeRFD=new RemoteFileDesc(host,port,SPECIAL_INDEX,""String_Node_Str"",0,_serventID.bytes(),0,false,0,false,null,null,false,true,""String_Node_Str"",0l,proxies,-1,canDoFWTransfer ? UDPConnection.VERSION : 0);
synchronized (_pushedHosts) {
  _pushedHosts.put(_serventID,new PushRequestDetails(this));
}
LOG.trace(""String_Node_Str"");
setState(PUSHING);
RouterService.getDownloadManager().sendPush(fakeRFD);
}
break;
}
}","/** 
 * Browses the files on the specified host and port.
 * @param host The IP of the host you want to browse.
 * @param port The port of the host you want to browse.
 * @param proxies the <tt>Set</tt> of push proxies to try
 * @param canDoFWTransfer Whether or not this guy can do a firewalltransfer.
 */
public void browseHost(String host,int port,Set proxies,boolean canDoFWTransfer){
  if (!NetworkUtils.isValidPort(port) || !NetworkUtils.isValidAddress(host)) {
    failed();
    return;
  }
  LOG.trace(""String_Node_Str"");
  setState(STARTED);
  int shouldPush=needsPush(host);
  LOG.trace(""String_Node_Str"" + shouldPush);
  boolean shouldTryPush=false;
switch (shouldPush) {
case 0:
    try {
      setState(DIRECTLY_CONNECTING);
      LOG.trace(""String_Node_Str"");
      Socket socket=Sockets.connect(host,port,DIRECT_CONNECT_TIME);
      LOG.trace(""String_Node_Str"");
      browseExchange(socket);
    }
 catch (    IOException ioe) {
      LOG.debug(""String_Node_Str"",ioe);
      shouldTryPush=true;
    }
  if (!shouldTryPush)   break;
case 1:
LOG.debug(""String_Node_Str"");
if (_serventID == null) {
LOG.debug(""String_Node_Str"");
failed();
}
 else {
RemoteFileDesc fakeRFD=new RemoteFileDesc(host,port,SPECIAL_INDEX,""String_Node_Str"",0,_serventID.bytes(),0,false,0,false,null,null,false,true,""String_Node_Str"",proxies,-1,canDoFWTransfer ? UDPConnection.VERSION : 0);
synchronized (_pushedHosts) {
  _pushedHosts.put(_serventID,new PushRequestDetails(this));
}
LOG.trace(""String_Node_Str"");
setState(PUSHING);
RouterService.getDownloadManager().sendPush(fakeRFD);
}
break;
}
}",0.9990557129367328
4247,"/** 
 * Reads the downloaders serialized in DOWNLOAD_SNAPSHOT_FILE and adds them to this, queued.  The queued downloads will restart immediately if slots are available.  Returns false iff the file could not be read for any reason.  THIS METHOD SHOULD BE CALLED BEFORE ANY GUI ACTION.  It is public for testing purposes only!  
 * @param file the downloads.dat snapshot file 
 */
public synchronized boolean readSnapshot(File file){
  List buf=null;
  try {
    ObjectInputStream in=new ConverterObjectInputStream(new BufferedInputStream(new FileInputStream(file)));
    buf=(List)in.readObject();
    incompleteFileManager=(IncompleteFileManager)in.readObject();
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"",t);
    return false;
  }
  buf=new LinkedList(new HashSet(buf));
  try {
    for (Iterator iter=buf.iterator(); iter.hasNext(); ) {
      ManagedDownloader downloader=(ManagedDownloader)iter.next();
      DownloadCallback dc=callback;
      if (downloader instanceof RequeryDownloader)       continue;
      waiting.add(downloader);
      downloader.initialize(this,this.fileManager,callback(downloader));
      callback(downloader).addDownload(downloader);
    }
    return true;
  }
 catch (  ClassCastException e) {
    return false;
  }
 finally {
    if (incompleteFileManager.initialPurge(getActiveDownloadFiles(buf)))     writeSnapshot();
  }
}","/** 
 * Reads the downloaders serialized in DOWNLOAD_SNAPSHOT_FILE and adds them to this, queued.  The queued downloads will restart immediately if slots are available.  Returns false iff the file could not be read for any reason.  THIS METHOD SHOULD BE CALLED BEFORE ANY GUI ACTION.  It is public for testing purposes only!  
 * @param file the downloads.dat snapshot file 
 */
public synchronized boolean readSnapshot(File file){
  List buf=null;
  try {
    ObjectInputStream in=new ConverterObjectInputStream(new BufferedInputStream(new FileInputStream(file)));
    buf=(List)in.readObject();
    incompleteFileManager=(IncompleteFileManager)in.readObject();
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"",t);
    return false;
  }
  buf=new LinkedList(new HashSet(buf));
  try {
    for (Iterator iter=buf.iterator(); iter.hasNext(); ) {
      ManagedDownloader downloader=(ManagedDownloader)iter.next();
      if (downloader instanceof RequeryDownloader)       continue;
      waiting.add(downloader);
      downloader.initialize(this,this.fileManager,callback(downloader));
      callback(downloader).addDownload(downloader);
    }
    return true;
  }
 catch (  ClassCastException e) {
    return false;
  }
 finally {
    if (incompleteFileManager.initialPurge(getActiveDownloadFiles(buf)))     writeSnapshot();
  }
}",0.9867452135493372
4248,"/** 
 * Handles core Gnutella request/reply protocol. If asynchronous messaging is supported, this immediately returns and messages are processed asynchronously via processMessage calls.  Otherwise, if reading blocks, this  will run until the connection is closed.
 * @requires this is initialized
 * @modifies the network underlying this, manager
 * @effects receives request and sends appropriate replies.
 * @throws IOException passed on from the receive call; failures to forwardor route messages are silently swallowed, allowing the message loop to continue.
 */
void loopForMessages() throws IOException {
  supernodeClientAtLooping=isSupernodeClientConnection();
  if (!isAsynchronous()) {
    Thread.currentThread().setName(""String_Node_Str"");
    while (true) {
      Message m=null;
      try {
        m=receive();
        if (m == null)         continue;
        handleMessageInternal(m);
      }
 catch (      BadPacketException ignored) {
      }
    }
  }
 else {
    _socket.setSoTimeout(0);
    MessageReader reader=new MessageReader(ManagedConnection.this);
    if (isReadDeflated())     reader.setReadChannel(new InflaterReader(_inflater));
    ((NIOMultiplexor)_socket).setReadObserver(reader);
  }
}","/** 
 * Handles core Gnutella request/reply protocol. If asynchronous messaging is supported, this immediately returns and messages are processed asynchronously via processMessage calls.  Otherwise, if reading blocks, this  will run until the connection is closed.
 * @requires this is initialized
 * @modifies the network underlying this, manager
 * @effects receives request and sends appropriate replies.
 * @throws IOException passed on from the receive call; failures to forwardor route messages are silently swallowed, allowing the message loop to continue.
 */
void loopForMessages() throws IOException {
  supernodeClientAtLooping=isSupernodeClientConnection();
  if (!isAsynchronous()) {
    LOG.debug(""String_Node_Str"");
    Thread.currentThread().setName(""String_Node_Str"");
    while (true) {
      Message m=null;
      try {
        m=receive();
        if (m == null)         continue;
        handleMessageInternal(m);
      }
 catch (      BadPacketException ignored) {
      }
    }
  }
 else {
    LOG.debug(""String_Node_Str"");
    _socket.setSoTimeout(0);
    MessageReader reader=new MessageReader(ManagedConnection.this);
    if (isReadDeflated())     reader.setReadChannel(new InflaterReader(_inflater));
    ((NIOMultiplexor)_socket).setReadObserver(reader);
  }
}",0.9497607655502392
4249,"/** 
 * removes all Unicast Endpoints, reset associated members
 */
private void resetUnicastEndpointsAndQueries(){
  LOG.debug(""String_Node_Str"");
synchronized (_queries) {
    _queries.clear();
    _queries.notifyAll();
  }
synchronized (_queryHosts) {
    _queryHosts.clear();
    _queryHosts.notifyAll();
  }
synchronized (_queryKeys) {
    _queryKeys.clear();
    _queryKeys.notifyAll();
  }
synchronized (_pingList) {
    _pingList.clear();
    _pingList.notifyAll();
  }
  _lastPingTime=0;
  _testUDPPingsSent=0;
}","/** 
 * removes all Unicast Endpoints, reset associated members
 */
@SuppressWarnings(""String_Node_Str"") private void resetUnicastEndpointsAndQueries(){
  LOG.debug(""String_Node_Str"");
synchronized (_queries) {
    _queries.clear();
    _queries.notifyAll();
  }
synchronized (_queryHosts) {
    _queryHosts.clear();
    _queryHosts.notifyAll();
  }
synchronized (_queryKeys) {
    _queryKeys.clear();
    _queryKeys.notifyAll();
  }
synchronized (_pingList) {
    _pingList.clear();
    _pingList.notifyAll();
  }
  _lastPingTime=0;
  _testUDPPingsSent=0;
}",0.9657089898053752
4250,"/** 
 * Actual constructor.  If the firewalled flag is set and a PE object is passed it is used, if  no PE object is passed a new one is created. 
 */
private RemoteFileDesc(String host,int port,long index,String filename,int size,byte[] clientGUID,int speed,boolean chat,int quality,boolean browseHost,LimeXMLDocument xmlDoc,Set urns,boolean replyToMulticast,boolean firewalled,String vendor,long timestamp,Set proxies,long createTime,int FWTVersion,PushEndpoint pe){
  if (!NetworkUtils.isValidPort(port)) {
    throw new IllegalArgumentException(""String_Node_Str"" + port);
  }
  if ((speed & 0xFFFFFFFF00000000L) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + speed);
  }
  if (filename == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (filename.equals(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if ((size & 0xFFFFFFFF00000000L) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + size);
  }
  if ((index & 0xFFFFFFFF00000000L) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + index);
  }
  if (host == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  _speed=speed;
  _host=host;
  _port=port;
  _index=index;
  _filename=filename;
  _size=size;
  _firewalled=firewalled;
  if (firewalled) {
    if (pe != null)     _pushAddr=pe;
 else {
      try {
        _pushAddr=new PushEndpoint(clientGUID,proxies,PushEndpoint.PLAIN,FWTVersion,new IpPortImpl(_host,_port));
      }
 catch (      UnknownHostException uhe) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
    _clientGUID=_pushAddr.getClientGUID();
  }
 else   _clientGUID=clientGUID;
  _chatEnabled=chat;
  _quality=quality;
  _browseHostEnabled=browseHost;
  _replyToMulticast=replyToMulticast;
  _vendor=vendor;
  _timestamp=timestamp;
  _creationTime=createTime;
  if (xmlDoc != null)   _xmlDocs=new LimeXMLDocument[]{xmlDoc};
 else   _xmlDocs=null;
  if (urns == null) {
    _urns=Collections.EMPTY_SET;
  }
 else {
    _urns=Collections.unmodifiableSet(urns);
  }
  _http11=(!_urns.isEmpty());
}","/** 
 * Actual constructor.  If the firewalled flag is set and a PE object is passed it is used, if  no PE object is passed a new one is created. 
 */
private RemoteFileDesc(String host,int port,long index,String filename,int size,byte[] clientGUID,int speed,boolean chat,int quality,boolean browseHost,LimeXMLDocument xmlDoc,Set urns,boolean replyToMulticast,boolean firewalled,String vendor,Set proxies,long createTime,int FWTVersion,PushEndpoint pe){
  if (!NetworkUtils.isValidPort(port)) {
    throw new IllegalArgumentException(""String_Node_Str"" + port);
  }
  if ((speed & 0xFFFFFFFF00000000L) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + speed);
  }
  if (filename == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (filename.equals(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if ((size & 0xFFFFFFFF00000000L) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + size);
  }
  if ((index & 0xFFFFFFFF00000000L) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + index);
  }
  if (host == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  _speed=speed;
  _host=host;
  _port=port;
  _index=index;
  _filename=filename;
  _size=size;
  _firewalled=firewalled;
  if (firewalled) {
    if (pe != null)     _pushAddr=pe;
 else {
      try {
        _pushAddr=new PushEndpoint(clientGUID,proxies,PushEndpoint.PLAIN,FWTVersion,new IpPortImpl(_host,_port));
      }
 catch (      UnknownHostException uhe) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
    _clientGUID=_pushAddr.getClientGUID();
  }
 else   _clientGUID=clientGUID;
  _chatEnabled=chat;
  _quality=quality;
  _browseHostEnabled=browseHost;
  _replyToMulticast=replyToMulticast;
  _vendor=vendor;
  _creationTime=createTime;
  if (xmlDoc != null)   _xmlDocs=new LimeXMLDocument[]{xmlDoc};
 else   _xmlDocs=null;
  if (urns == null) {
    _urns=Collections.EMPTY_SET;
  }
 else {
    _urns=Collections.unmodifiableSet(urns);
  }
  _http11=(!_urns.isEmpty());
}",0.9907692307692308
4251,"/** 
 * Returns this Response as a RemoteFileDesc.
 */
public RemoteFileDesc toRemoteFileDesc(HostData data){
  if (cachedRFD != null && cachedRFD.getPort() == data.getPort() && cachedRFD.getHost().equals(data.getIP()))   return cachedRFD;
 else {
    RemoteFileDesc rfd=new RemoteFileDesc(data.getIP(),data.getPort(),getIndex(),getName(),(int)getSize(),data.getClientGUID(),data.getSpeed(),data.isChatEnabled(),data.getQuality(),data.isBrowseHostEnabled(),getDocument(),getUrns(),data.isReplyToMulticastQuery(),data.isFirewalled(),data.getVendorCode(),System.currentTimeMillis(),data.getPushProxies(),getCreateTime(),data.getFWTVersionSupported());
    cachedRFD=rfd;
    return rfd;
  }
}","/** 
 * Returns this Response as a RemoteFileDesc.
 */
public RemoteFileDesc toRemoteFileDesc(HostData data){
  if (cachedRFD != null && cachedRFD.getPort() == data.getPort() && cachedRFD.getHost().equals(data.getIP()))   return cachedRFD;
 else {
    RemoteFileDesc rfd=new RemoteFileDesc(data.getIP(),data.getPort(),getIndex(),getName(),(int)getSize(),data.getClientGUID(),data.getSpeed(),data.isChatEnabled(),data.getQuality(),data.isBrowseHostEnabled(),getDocument(),getUrns(),data.isReplyToMulticastQuery(),data.isFirewalled(),data.getVendorCode(),data.getPushProxies(),getCreateTime(),data.getFWTVersionSupported());
    cachedRFD=rfd;
    return rfd;
  }
}",0.9800443458980044
4252,"/** 
 * Utility method for converting the non-firewalled elements of an AlternateLocationCollection to a smaller set of endpoints.
 */
private static Set getAsEndpoints(AlternateLocationCollection col){
  if (col == null || !col.hasAlternateLocations())   return Collections.EMPTY_SET;
  long now=System.currentTimeMillis();
synchronized (col) {
    Set endpoints=null;
    int i=0;
    for (Iterator iter=col.iterator(); iter.hasNext() && i < MAX_LOCATIONS; ) {
      Object o=iter.next();
      if (!(o instanceof DirectAltLoc))       continue;
      DirectAltLoc al=(DirectAltLoc)o;
      if (al.canBeSent(AlternateLocation.MESH_RESPONSE)) {
        IpPort host=al.getHost();
        if (!NetworkUtils.isMe(host)) {
          if (endpoints == null)           endpoints=new HashSet();
          if (!(host instanceof Endpoint))           host=new Endpoint(host.getAddress(),host.getPort());
          endpoints.add(host);
          i++;
          al.send(now,AlternateLocation.MESH_RESPONSE);
        }
      }
 else       if (!al.canBeSentAny())       iter.remove();
    }
    return endpoints == null ? Collections.EMPTY_SET : endpoints;
  }
}","/** 
 * Utility method for converting the non-firewalled elements of an AlternateLocationCollection to a smaller set of endpoints.
 */
private static Set getAsEndpoints(AlternateLocationCollection col){
  if (col == null || !col.hasAlternateLocations())   return Collections.EMPTY_SET;
  long now=System.currentTimeMillis();
synchronized (col) {
    Set endpoints=null;
    int i=0;
    for (Iterator iter=col.iterator(); iter.hasNext() && i < MAX_LOCATIONS; ) {
      Object o=iter.next();
      if (!(o instanceof DirectAltLoc)) {
        if (LOG.isDebugEnabled())         LOG.debug(""String_Node_Str"" + o);
        continue;
      }
      DirectAltLoc al=(DirectAltLoc)o;
      if (al.canBeSent(AlternateLocation.MESH_RESPONSE)) {
        IpPort host=al.getHost();
        if (!NetworkUtils.isMe(host)) {
          if (endpoints == null)           endpoints=new HashSet();
          if (!(host instanceof Endpoint))           host=new Endpoint(host.getAddress(),host.getPort());
          endpoints.add(host);
          i++;
          al.send(now,AlternateLocation.MESH_RESPONSE);
        }
      }
 else       if (!al.canBeSentAny())       iter.remove();
    }
    return endpoints == null ? Collections.EMPTY_SET : endpoints;
  }
}",0.9513014273719564
4253,"/** 
 * Browses the files on the specified host and port.
 * @param host The IP of the host you want to browse.
 * @param port The port of the host you want to browse.
 * @param proxies the <tt>Set</tt> of push proxies to try
 * @param canDoFWTransfer Whether or not this guy can do a firewalltransfer.
 */
public void browseHost(String host,int port,Set proxies,boolean canDoFWTransfer){
  if (!NetworkUtils.isValidPort(port) || !NetworkUtils.isValidAddress(host)) {
    failed();
    return;
  }
  LOG.trace(""String_Node_Str"");
  setState(STARTED);
  int shouldPush=needsPush(host);
  LOG.trace(""String_Node_Str"" + shouldPush);
  boolean shouldTryPush=false;
switch (shouldPush) {
case 0:
    try {
      setState(DIRECTLY_CONNECTING);
      LOG.trace(""String_Node_Str"");
      Socket socket=Sockets.connect(host,port,DIRECT_CONNECT_TIME);
      LOG.trace(""String_Node_Str"");
      browseExchange(socket);
    }
 catch (    IOException ioe) {
      LOG.debug(""String_Node_Str"",ioe);
      shouldTryPush=true;
    }
  if (!shouldTryPush)   break;
case 1:
LOG.debug(""String_Node_Str"");
if (_serventID == null) {
LOG.debug(""String_Node_Str"");
failed();
}
 else {
RemoteFileDesc fakeRFD=new RemoteFileDesc(host,port,SPECIAL_INDEX,""String_Node_Str"",0,_serventID.bytes(),0,false,0,false,null,null,false,true,""String_Node_Str"",proxies,-1,canDoFWTransfer ? UDPConnection.VERSION : 0);
synchronized (_pushedHosts) {
  _pushedHosts.put(_serventID,new PushRequestDetails(this));
}
LOG.trace(""String_Node_Str"");
setState(PUSHING);
RouterService.getDownloadManager().sendPush(fakeRFD);
}
break;
}
}","/** 
 * Browses the files on the specified host and port.
 * @param host The IP of the host you want to browse.
 * @param port The port of the host you want to browse.
 * @param proxies the <tt>Set</tt> of push proxies to try
 * @param canDoFWTransfer Whether or not this guy can do a firewalltransfer.
 */
public void browseHost(String host,int port,Set<? extends IpPort> proxies,boolean canDoFWTransfer){
  if (!NetworkUtils.isValidPort(port) || !NetworkUtils.isValidAddress(host)) {
    failed();
    return;
  }
  LOG.trace(""String_Node_Str"");
  setState(STARTED);
  int shouldPush=needsPush(host);
  LOG.trace(""String_Node_Str"" + shouldPush);
  boolean shouldTryPush=false;
switch (shouldPush) {
case 0:
    try {
      setState(DIRECTLY_CONNECTING);
      LOG.trace(""String_Node_Str"");
      Socket socket=Sockets.connect(host,port,DIRECT_CONNECT_TIME);
      LOG.trace(""String_Node_Str"");
      browseExchange(socket);
    }
 catch (    IOException ioe) {
      LOG.debug(""String_Node_Str"",ioe);
      shouldTryPush=true;
    }
  if (!shouldTryPush)   break;
case 1:
LOG.debug(""String_Node_Str"");
if (_serventID == null) {
LOG.debug(""String_Node_Str"");
failed();
}
 else {
RemoteFileDesc fakeRFD=new RemoteFileDesc(host,port,SPECIAL_INDEX,""String_Node_Str"",0,_serventID.bytes(),0,false,0,false,null,null,false,true,""String_Node_Str"",proxies,-1,canDoFWTransfer ? UDPConnection.VERSION : 0);
synchronized (_pushedHosts) {
  _pushedHosts.put(_serventID,new PushRequestDetails(this));
}
LOG.trace(""String_Node_Str"");
setState(PUSHING);
RouterService.getDownloadManager().sendPush(fakeRFD);
}
break;
}
}",0.9943609022556392
4254,"/** 
 * Loads values from cache file, if available
 */
private Map<URN,Long> createMap(){
  ObjectInputStream ois=null;
  try {
    ois=new ConverterObjectInputStream(new BufferedInputStream(new FileInputStream(CTIME_CACHE_FILE)));
    return GenericsUtils.scanForMap(ois.readObject(),URN.class,Long.class,true);
  }
 catch (  Throwable t) {
    dirty=true;
    LOG.error(""String_Node_Str"",t);
    return new HashMap<URN,Long>();
  }
 finally {
    IOUtils.close(ois);
  }
}","/** 
 * Loads values from cache file, if available
 */
private Map<URN,Long> createMap(){
  ObjectInputStream ois=null;
  try {
    ois=new ConverterObjectInputStream(new BufferedInputStream(new FileInputStream(CTIME_CACHE_FILE)));
    return GenericsUtils.scanForMap(ois.readObject(),URN.class,Long.class,GenericsUtils.ScanMode.REMOVE);
  }
 catch (  Throwable t) {
    dirty=true;
    LOG.error(""String_Node_Str"",t);
    return new HashMap<URN,Long>();
  }
 finally {
    IOUtils.close(ois);
  }
}",0.9660842754367934
4255,"/** 
 * Helper method to install a MessageHandler in the provided Map  for the provided Message Class. See setMessageHandler(), setUDPMessageHandler() and  setMulticastMessageHandler() for implementation details.
 */
private static Map setHandler(Map handlerMap,Class clazz,MessageHandler handler){
  if (clazz == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (handler == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  Map copy=new IdentityHashMap(handlerMap);
  Object o=copy.put(clazz,handler);
  if (o != null && LOG.isErrorEnabled()) {
    LOG.error(""String_Node_Str"" + o.getClass() + ""String_Node_Str""+ clazz);
  }
  return copy;
}","/** 
 * Helper method to install a MessageHandler in the provided Map  for the provided Message Class. See setMessageHandler(), setUDPMessageHandler() and  setMulticastMessageHandler() for implementation details.
 */
private static Map<Class<? extends Message>,MessageHandler> setHandler(Map<Class<? extends Message>,? extends MessageHandler> handlerMap,Class<? extends Message> clazz,MessageHandler handler){
  if (clazz == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (handler == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  Map<Class<? extends Message>,MessageHandler> copy=new IdentityHashMap<Class<? extends Message>,MessageHandler>(handlerMap);
  Object o=copy.put(clazz,handler);
  if (o != null && LOG.isErrorEnabled()) {
    LOG.error(""String_Node_Str"" + o.getClass() + ""String_Node_Str""+ clazz);
  }
  return copy;
}",0.8571428571428571
4256,"/** 
 * Forwards the UDPConnectBack to neighboring peers as a UDPConnectBackRedirect request.
 */
protected void handleUDPConnectBackRequest(UDPConnectBackVendorMessage udp,Connection source){
  GUID guidToUse=udp.getConnectBackGUID();
  int portToContact=udp.getConnectBackPort();
  InetAddress sourceAddr=source.getInetAddress();
  Message msg=new UDPConnectBackRedirect(guidToUse,sourceAddr,portToContact);
  int sentTo=0;
  List peers=new ArrayList(_manager.getInitializedConnections());
  Collections.shuffle(peers);
  for (Iterator i=peers.iterator(); i.hasNext() && sentTo < MAX_UDP_CONNECTBACK_FORWARDS; ) {
    ManagedConnection currMC=(ManagedConnection)i.next();
    if (currMC == source)     continue;
    if (currMC.remoteHostSupportsUDPRedirect() >= 0) {
      currMC.send(msg);
      sentTo++;
    }
  }
}","/** 
 * Forwards the UDPConnectBack to neighboring peers as a UDPConnectBackRedirect request.
 */
protected void handleUDPConnectBackRequest(UDPConnectBackVendorMessage udp,Connection source){
  GUID guidToUse=udp.getConnectBackGUID();
  int portToContact=udp.getConnectBackPort();
  InetAddress sourceAddr=source.getInetAddress();
  Message msg=new UDPConnectBackRedirect(guidToUse,sourceAddr,portToContact);
  int sentTo=0;
  List<ManagedConnection> peers=new ArrayList<ManagedConnection>(_manager.getInitializedConnections());
  Collections.shuffle(peers);
  for (  ManagedConnection currMC : peers) {
    if (sentTo >= MAX_UDP_CONNECTBACK_FORWARDS)     break;
    if (currMC == source)     continue;
    if (currMC.remoteHostSupportsUDPRedirect() >= 0) {
      currMC.send(msg);
      sentTo++;
    }
  }
}",0.8748466257668711
4257,"/** 
 * Helper method to get a MessageHandler from the provided Map for the provided Message Class
 */
private static MessageHandler getHandler(Map messageHandlers,Class clazz){
  return (MessageHandler)messageHandlers.get(clazz);
}","/** 
 * Helper method to get a MessageHandler from the provided Map for the provided Message Class
 */
private static MessageHandler getHandler(Map<Class<? extends Message>,? extends MessageHandler> messageHandlers,Class<? extends Message> clazz){
  return messageHandlers.get(clazz);
}",0.833976833976834
4258,"/** 
 * Installs a MessageHandler for Multicast Messages.
 * @link #handleMulticastMessage(Message, InetSocketAddress)
 * @param clazz The Class of the Message
 * @param handler The Handler of the Message
 */
public void setMulticastMessageHandler(Class clazz,MessageHandler handler){
synchronized (multicastMessageHandlers) {
    multicastMessageHandlers=setHandler(multicastMessageHandlers,clazz,handler);
  }
}","/** 
 * Installs a MessageHandler for Multicast Messages.
 * @link #handleMulticastMessage(Message, InetSocketAddress)
 * @param clazz The Class of the Message
 * @param handler The Handler of the Message
 */
public void setMulticastMessageHandler(Class<? extends Message> clazz,MessageHandler handler){
synchronized (multicastMessageHandlers) {
    multicastMessageHandlers=setHandler(multicastMessageHandlers,clazz,handler);
  }
}",0.9775147928994082
4259,"/** 
 * Abstract method for creating query hits.  Subclasses must specify how this list is created.
 * @return a <tt>List</tt> of <tt>QueryReply</tt> instances
 */
protected abstract List createQueryReply(byte[] guid,byte ttl,long speed,Response[] res,byte[] clientGUID,boolean busy,boolean uploaded,boolean measuredSpeed,boolean isFromMcast,boolean shouldMarkForFWTransfer);","/** 
 * Abstract method for creating query hits.  Subclasses must specify how this list is created.
 * @return a <tt>List</tt> of <tt>QueryReply</tt> instances
 */
protected abstract List<QueryReply> createQueryReply(byte[] guid,byte ttl,long speed,Response[] res,byte[] clientGUID,boolean busy,boolean uploaded,boolean measuredSpeed,boolean isFromMcast,boolean shouldMarkForFWTransfer);",0.984251968503937
4260,"/** 
 * The default handler for PingRequests received in ManagedConnection.loopForMessages().  This implementation uses the ping route table to route a ping reply.  If an appropriate route doesn't exist, records the error statistics.  On sucessful routing, the PingReply count is incremented.<p> In all cases, the ping reply is recorded into the host catcher.<p> Override as desired, but you probably want to call super.handlePingReply if you do.
 */
protected void handlePingReply(PingReply reply,ReplyHandler handler){
  boolean newAddress=RouterService.getHostCatcher().add(reply);
  if (newAddress && !reply.isUDPHostCache()) {
    PongCacher.instance().addPong(reply);
  }
  ReplyHandler replyHandler=_pingRouteTable.getReplyHandler(reply.getGUID());
  if (replyHandler != null) {
    replyHandler.handlePingReply(reply,handler);
  }
 else {
    RouteErrorStat.PING_REPLY_ROUTE_ERRORS.incrementStat();
    handler.countDroppedMessage();
  }
  boolean supportsUnicast=reply.supportsUnicast();
  if (newAddress && (reply.isUltrapeer() || supportsUnicast)) {
    List list=_manager.getInitializedClientConnections();
    for (int i=0; i < list.size(); i++) {
      ManagedConnection c=(ManagedConnection)list.get(i);
      Assert.that(c != null,""String_Node_Str"");
      if (c != handler && c != replyHandler && c.allowNewPongs()) {
        c.handlePingReply(reply,handler);
      }
    }
  }
}","/** 
 * The default handler for PingRequests received in ManagedConnection.loopForMessages().  This implementation uses the ping route table to route a ping reply.  If an appropriate route doesn't exist, records the error statistics.  On sucessful routing, the PingReply count is incremented.<p> In all cases, the ping reply is recorded into the host catcher.<p> Override as desired, but you probably want to call super.handlePingReply if you do.
 */
protected void handlePingReply(PingReply reply,ReplyHandler handler){
  boolean newAddress=RouterService.getHostCatcher().add(reply);
  if (newAddress && !reply.isUDPHostCache()) {
    PongCacher.instance().addPong(reply);
  }
  ReplyHandler replyHandler=_pingRouteTable.getReplyHandler(reply.getGUID());
  if (replyHandler != null) {
    replyHandler.handlePingReply(reply,handler);
  }
 else {
    RouteErrorStat.PING_REPLY_ROUTE_ERRORS.incrementStat();
    handler.countDroppedMessage();
  }
  boolean supportsUnicast=reply.supportsUnicast();
  if (newAddress && (reply.isUltrapeer() || supportsUnicast)) {
    List<ManagedConnection> list=_manager.getInitializedClientConnections();
    for (int i=0; i < list.size(); i++) {
      ManagedConnection c=list.get(i);
      Assert.that(c != null,""String_Node_Str"");
      if (c != handler && c != replyHandler && c.allowNewPongs()) {
        c.handlePingReply(reply,handler);
      }
    }
  }
}",0.9863896848137536
4261,"/** 
 * Converts the passed responses to QueryReplies. Each QueryReply can accomodate atmost 255 responses. Not all the responses may get included in QueryReplies in case the query request came from a far away host. <p> NOTE: This method doesnt have any side effect,  and does not modify the state of this object
 * @param responses The responses to be converted
 * @param queryRequest The query request corresponding to which we aregenerating query replies.
 * @param REPLY_LIMIT the maximum number of responses to have in each reply.
 * @return Iterator (on QueryReply) over the Query Replies
 */
private Iterator responsesToQueryReplies(Response[] responses,QueryRequest queryRequest,final int REPLY_LIMIT){
  List queryReplies=new LinkedList();
  byte[] guid=queryRequest.getGUID();
  byte ttl=(byte)(queryRequest.getHops() + 1);
  UploadManager um=RouterService.getUploadManager();
  long speed=um.measuredUploadSpeed();
  boolean measuredSpeed=true;
  if (speed == -1) {
    speed=ConnectionSettings.CONNECTION_SPEED.getValue();
    measuredSpeed=false;
  }
  int numResponses=responses.length;
  int index=0;
  int numHops=queryRequest.getHops();
  if (REPLY_LIMIT > 1 && numHops > 2 && numResponses > HIGH_HOPS_RESPONSE_LIMIT) {
    int j=(int)(Math.random() * numResponses) % (numResponses - HIGH_HOPS_RESPONSE_LIMIT);
    Response[] newResponses=new Response[HIGH_HOPS_RESPONSE_LIMIT];
    for (int i=0; i < 10; i++, j++) {
      newResponses[i]=responses[j];
    }
    responses=newResponses;
    numResponses=responses.length;
  }
  while (numResponses > 0) {
    int arraySize;
    if (numResponses < REPLY_LIMIT) {
      arraySize=numResponses;
    }
 else     arraySize=REPLY_LIMIT;
    Response[] res;
    if ((index == 0) && (arraySize < REPLY_LIMIT)) {
      res=responses;
    }
 else {
      res=new Response[arraySize];
      for (int i=0; i < arraySize; i++) {
        res[i]=responses[index];
        index++;
      }
    }
    numResponses-=arraySize;
    boolean busy=!um.isServiceable();
    boolean uploaded=um.hadSuccesfulUpload();
    boolean mcast=queryRequest.isMulticast() && (queryRequest.getTTL() + queryRequest.getHops()) == 1;
    final boolean fwTransfer=queryRequest.canDoFirewalledTransfer() && UDPService.instance().canDoFWT() && !RouterService.acceptedIncomingConnection();
    if (mcast) {
      ttl=1;
    }
    List replies=createQueryReply(guid,ttl,speed,res,_clientGUID,busy,uploaded,measuredSpeed,mcast,fwTransfer);
    queryReplies.addAll(replies);
  }
  return queryReplies.iterator();
}","/** 
 * Converts the passed responses to QueryReplies. Each QueryReply can accomodate atmost 255 responses. Not all the responses may get included in QueryReplies in case the query request came from a far away host. <p> NOTE: This method doesnt have any side effect,  and does not modify the state of this object
 * @param responses The responses to be converted
 * @param queryRequest The query request corresponding to which we aregenerating query replies.
 * @param REPLY_LIMIT the maximum number of responses to have in each reply.
 * @return Iterable of QueryReply
 */
private Iterable<QueryReply> responsesToQueryReplies(Response[] responses,QueryRequest queryRequest,final int REPLY_LIMIT){
  List<QueryReply> queryReplies=new LinkedList<QueryReply>();
  byte[] guid=queryRequest.getGUID();
  byte ttl=(byte)(queryRequest.getHops() + 1);
  UploadManager um=RouterService.getUploadManager();
  long speed=um.measuredUploadSpeed();
  boolean measuredSpeed=true;
  if (speed == -1) {
    speed=ConnectionSettings.CONNECTION_SPEED.getValue();
    measuredSpeed=false;
  }
  int numResponses=responses.length;
  int index=0;
  int numHops=queryRequest.getHops();
  if (REPLY_LIMIT > 1 && numHops > 2 && numResponses > HIGH_HOPS_RESPONSE_LIMIT) {
    int j=(int)(Math.random() * numResponses) % (numResponses - HIGH_HOPS_RESPONSE_LIMIT);
    Response[] newResponses=new Response[HIGH_HOPS_RESPONSE_LIMIT];
    for (int i=0; i < 10; i++, j++) {
      newResponses[i]=responses[j];
    }
    responses=newResponses;
    numResponses=responses.length;
  }
  while (numResponses > 0) {
    int arraySize;
    if (numResponses < REPLY_LIMIT) {
      arraySize=numResponses;
    }
 else     arraySize=REPLY_LIMIT;
    Response[] res;
    if ((index == 0) && (arraySize < REPLY_LIMIT)) {
      res=responses;
    }
 else {
      res=new Response[arraySize];
      for (int i=0; i < arraySize; i++) {
        res[i]=responses[index];
        index++;
      }
    }
    numResponses-=arraySize;
    boolean busy=!um.isServiceable();
    boolean uploaded=um.hadSuccesfulUpload();
    boolean mcast=queryRequest.isMulticast() && (queryRequest.getTTL() + queryRequest.getHops()) == 1;
    final boolean fwTransfer=queryRequest.canDoFirewalledTransfer() && UDPService.instance().canDoFWT() && !RouterService.acceptedIncomingConnection();
    if (mcast) {
      ttl=1;
    }
    List<QueryReply> replies=createQueryReply(guid,ttl,speed,res,_clientGUID,busy,uploaded,measuredSpeed,mcast,fwTransfer);
    queryReplies.addAll(replies);
  }
  return queryReplies;
}",0.9799370574350904
4262,"/** 
 * @param map the map that keeps track of recent redirects
 * @param key the key which we would (have) store(d) in the map
 * @return whether we should service the redirect request
 * @modifies the map
 */
private boolean shouldServiceRedirect(FixedsizeHashMap map,Object key){
synchronized (map) {
    Object placeHolder=map.get(key);
    if (placeHolder == null) {
      try {
        map.put(key,map);
        return true;
      }
 catch (      NoMoreStorageException nomo) {
        return false;
      }
    }
 else     return false;
  }
}","/** 
 * @param map the map that keeps track of recent redirects
 * @param key the key which we would (have) store(d) in the map
 * @return whether we should service the redirect request
 * @modifies the map
 */
private boolean shouldServiceRedirect(FixedsizeHashMap<String,String> map,String key){
synchronized (map) {
    String placeHolder=map.get(key);
    if (placeHolder == null) {
      try {
        map.put(key,key);
        return true;
      }
 catch (      NoMoreStorageException nomo) {
        return false;
      }
    }
 else     return false;
  }
}",0.9523809523809524
4263,"/** 
 * Installs a MessageHandler for UDP Messages.
 * @link #handleUDPMessage(Message, InetSocketAddress)
 * @param clazz The Class of the Message
 * @param handler The Handler of the Message
 */
public void setUDPMessageHandler(Class clazz,MessageHandler handler){
synchronized (udpMessageHandlers) {
    udpMessageHandlers=setHandler(udpMessageHandlers,clazz,handler);
  }
}","/** 
 * Installs a MessageHandler for UDP Messages.
 * @link #handleUDPMessage(Message, InetSocketAddress)
 * @param clazz The Class of the Message
 * @param handler The Handler of the Message
 */
public void setUDPMessageHandler(Class<? extends Message> clazz,MessageHandler handler){
synchronized (udpMessageHandlers) {
    udpMessageHandlers=setHandler(udpMessageHandlers,clazz,handler);
  }
}",0.9754204398447608
4264,"/** 
 * Notifies any message listeners of this message's guid about the message. This holds no locks.
 */
private final void notifyMessageListener(Message msg,ReplyHandler handler){
  List all=(List)_messageListeners.get(msg.getGUID());
  if (all != null) {
    for (Iterator i=all.iterator(); i.hasNext(); ) {
      MessageListener next=(MessageListener)i.next();
      next.processMessage(msg,handler);
    }
  }
}","/** 
 * Notifies any message listeners of this message's guid about the message. This holds no locks.
 */
private final void notifyMessageListener(Message msg,ReplyHandler handler){
  List<MessageListener> all=_messageListeners.get(msg.getGUID());
  if (all != null) {
    for (    MessageListener next : all) {
      next.processMessage(msg,handler);
    }
  }
}",0.7060333761232349
4265,"/** 
 * Sends updated query routing tables to all connections which haven't been updated in a while.  You can call this method as often as you want; it takes care of throttling.
 * @modifies connections
 */
private void forwardQueryRouteTables(){
  long time=System.currentTimeMillis();
  List list=_manager.getInitializedConnections();
  QueryRouteTable table=null;
  List patches=null;
  QueryRouteTable lastSent=null;
  for (int i=0; i < list.size(); i++) {
    ManagedConnection c=(ManagedConnection)list.get(i);
    if (RouterService.isSupernode()) {
      if (!c.isUltrapeerQueryRoutingConnection()) {
        continue;
      }
    }
 else     if (!(c.isClientSupernodeConnection() && c.isQueryRoutingEnabled())) {
      continue;
    }
    if (time < c.getNextQRPForwardTime())     continue;
    c.incrementNextQRPForwardTime(time);
    if (table == null) {
      table=createRouteTable();
      _lastQueryRouteTable=table;
    }
    if (lastSent == c.getQueryRouteTableSent()) {
      if (patches == null)       patches=table.encode(lastSent,true);
    }
 else {
      lastSent=c.getQueryRouteTableSent();
      patches=table.encode(lastSent,true);
    }
    if (!ConnectionSettings.SEND_QRP.getValue()) {
      return;
    }
    for (Iterator iter=patches.iterator(); iter.hasNext(); ) {
      c.send((RouteTableMessage)iter.next());
    }
    c.setQueryRouteTableSent(table);
  }
}","/** 
 * Sends updated query routing tables to all connections which haven't been updated in a while.  You can call this method as often as you want; it takes care of throttling.
 * @modifies connections
 */
private void forwardQueryRouteTables(){
  long time=System.currentTimeMillis();
  List<ManagedConnection> list=_manager.getInitializedConnections();
  QueryRouteTable table=null;
  List<RouteTableMessage> patches=null;
  QueryRouteTable lastSent=null;
  for (int i=0; i < list.size(); i++) {
    ManagedConnection c=list.get(i);
    if (RouterService.isSupernode()) {
      if (!c.isUltrapeerQueryRoutingConnection()) {
        continue;
      }
    }
 else     if (!(c.isClientSupernodeConnection() && c.isQueryRoutingEnabled())) {
      continue;
    }
    if (time < c.getNextQRPForwardTime())     continue;
    c.incrementNextQRPForwardTime(time);
    if (table == null) {
      table=createRouteTable();
      _lastQueryRouteTable=table;
    }
    if (lastSent == c.getQueryRouteTableSent()) {
      if (patches == null)       patches=table.encode(lastSent,true);
    }
 else {
      lastSent=c.getQueryRouteTableSent();
      patches=table.encode(lastSent,true);
    }
    if (!ConnectionSettings.SEND_QRP.getValue()) {
      return;
    }
    for (    RouteTableMessage next : patches)     c.send(next);
    c.setQueryRouteTableSent(table);
  }
}",0.9080334423845874
4266,"/** 
 * Returns a MessageHandler for the specified Message Class or null if no such MessageHandler exists.
 */
public MessageHandler getUDPMessageHandler(Class clazz){
  return getHandler(udpMessageHandlers,clazz);
}","/** 
 * Returns a MessageHandler for the specified Message Class or null if no such MessageHandler exists.
 */
public MessageHandler getUDPMessageHandler(Class<? extends Message> clazz){
  return getHandler(udpMessageHandlers,clazz);
}",0.9578713968957872
4267,"public int getNumOOBToRequest(ReplyNumberVendorMessage reply,ReplyHandler handler){
  GUID qGUID=new GUID(reply.getGUID());
  int numResults=RouterService.getSearchResultHandler().getNumResultsForQuery(qGUID);
  if (numResults < 0)   numResults=DYNAMIC_QUERIER.getLeafResultsForQuery(qGUID);
  if ((numResults < 0) || (numResults > QueryHandler.ULTRAPEER_RESULTS)) {
    OutOfBandThroughputStat.RESPONSES_BYPASSED.addData(reply.getNumResults());
    if (!reply.canReceiveUnsolicited())     return -1;
    DownloadManager dManager=RouterService.getDownloadManager();
    if (!_callback.isQueryAlive(qGUID) && !dManager.isGuidForQueryDownloading(qGUID))     return -1;
    GUESSEndpoint ep=new GUESSEndpoint(handler.getInetAddress(),handler.getPort());
synchronized (_bypassedResults) {
      Set eps=(Set)_bypassedResults.get(qGUID);
      if (eps == null) {
        eps=new HashSet();
        _bypassedResults.put(qGUID,eps);
      }
      if (_bypassedResults.size() <= MAX_BYPASSED_RESULTS)       eps.add(ep);
    }
    return -1;
  }
  return reply.getNumResults();
}","public int getNumOOBToRequest(ReplyNumberVendorMessage reply,ReplyHandler handler){
  GUID qGUID=new GUID(reply.getGUID());
  int numResults=RouterService.getSearchResultHandler().getNumResultsForQuery(qGUID);
  if (numResults < 0)   numResults=DYNAMIC_QUERIER.getLeafResultsForQuery(qGUID);
  if ((numResults < 0) || (numResults > QueryHandler.ULTRAPEER_RESULTS)) {
    OutOfBandThroughputStat.RESPONSES_BYPASSED.addData(reply.getNumResults());
    if (!reply.canReceiveUnsolicited())     return -1;
    DownloadManager dManager=RouterService.getDownloadManager();
    if (!_callback.isQueryAlive(qGUID) && !dManager.isGuidForQueryDownloading(qGUID))     return -1;
    GUESSEndpoint ep=new GUESSEndpoint(handler.getInetAddress(),handler.getPort());
synchronized (_bypassedResults) {
      Set<GUESSEndpoint> eps=_bypassedResults.get(qGUID);
      if (eps == null) {
        eps=new HashSet<GUESSEndpoint>();
        _bypassedResults.put(qGUID,eps);
      }
      if (_bypassedResults.size() <= MAX_BYPASSED_RESULTS)       eps.add(ep);
    }
    return -1;
  }
  return reply.getNumResults();
}",0.9838337182448036
4268,"/** 
 * Forwards the query request to any leaf connections.
 * @param request the query to forward
 * @param handler the <tt>ReplyHandler</tt> that responds to therequest appropriately
 * @param manager the <tt>ConnectionManager</tt> that providesaccess to any leaf connections that we should forward to
 */
public final void forwardQueryRequestToLeaves(QueryRequest query,ReplyHandler handler){
  if (!RouterService.isSupernode())   return;
  List list=_manager.getInitializedClientConnections();
  List hitConnections=new ArrayList();
  for (int i=0; i < list.size(); i++) {
    ManagedConnection mc=(ManagedConnection)list.get(i);
    if (mc == handler)     continue;
    if (mc.shouldForwardQuery(query)) {
      hitConnections.add(mc);
    }
  }
  if (list.size() > 8 && (double)hitConnections.size() / (double)list.size() > .8) {
    int startIndex=(int)Math.floor(Math.random() * hitConnections.size() * 0.75);
    hitConnections=hitConnections.subList(startIndex,startIndex + hitConnections.size() / 4);
  }
  int notSent=list.size() - hitConnections.size();
  RoutedQueryStat.LEAF_DROP.addData(notSent);
  for (int i=0; i < hitConnections.size(); i++) {
    ManagedConnection mc=(ManagedConnection)hitConnections.get(i);
    mc.send(query);
    RoutedQueryStat.LEAF_SEND.incrementStat();
  }
}","/** 
 * Forwards the query request to any leaf connections.
 * @param request the query to forward
 * @param handler the <tt>ReplyHandler</tt> that responds to therequest appropriately
 * @param manager the <tt>ConnectionManager</tt> that providesaccess to any leaf connections that we should forward to
 */
public final void forwardQueryRequestToLeaves(QueryRequest query,ReplyHandler handler){
  if (!RouterService.isSupernode())   return;
  List<ManagedConnection> list=_manager.getInitializedClientConnections();
  List<ManagedConnection> hitConnections=new ArrayList<ManagedConnection>();
  for (int i=0; i < list.size(); i++) {
    ManagedConnection mc=list.get(i);
    if (mc == handler)     continue;
    if (mc.shouldForwardQuery(query)) {
      hitConnections.add(mc);
    }
  }
  if (list.size() > 8 && (double)hitConnections.size() / (double)list.size() > .8) {
    int startIndex=(int)Math.floor(Math.random() * hitConnections.size() * 0.75);
    hitConnections=hitConnections.subList(startIndex,startIndex + hitConnections.size() / 4);
  }
  int notSent=list.size() - hitConnections.size();
  RoutedQueryStat.LEAF_DROP.addData(notSent);
  for (int i=0; i < hitConnections.size(); i++) {
    ManagedConnection mc=hitConnections.get(i);
    mc.send(query);
    RoutedQueryStat.LEAF_SEND.incrementStat();
  }
}",0.9637819290888296
4269,"/** 
 * Broadcasts the query request to all initialized connections that are not the receivingConnection, setting up the routing to the designated QueryReplyHandler.  This is called from teh default handleQueryRequest and the default broadcastQueryRequest(QueryRequest) If different (smarter) broadcasting functionality is desired, override as desired.  If you do, note that receivingConnection may be null (for requests originating here).
 */
private void forwardQueryToUltrapeers(QueryRequest query,ReplyHandler handler){
  List list=_manager.getInitializedConnections();
  int limit=list.size();
  for (int i=0; i < limit; i++) {
    ManagedConnection mc=(ManagedConnection)list.get(i);
    forwardQueryToUltrapeer(query,handler,mc);
  }
}","/** 
 * Broadcasts the query request to all initialized connections that are not the receivingConnection, setting up the routing to the designated QueryReplyHandler.  This is called from teh default handleQueryRequest and the default broadcastQueryRequest(QueryRequest) If different (smarter) broadcasting functionality is desired, override as desired.  If you do, note that receivingConnection may be null (for requests originating here).
 */
private void forwardQueryToUltrapeers(QueryRequest query,ReplyHandler handler){
  List<ManagedConnection> list=_manager.getInitializedConnections();
  int limit=list.size();
  for (int i=0; i < limit; i++) {
    ManagedConnection mc=list.get(i);
    forwardQueryToUltrapeer(query,handler,mc);
  }
}",0.9743935309973046
4270,"/** 
 * Unregisters this MessageListener from listening to the GUID. This works by replacing the necessary maps & lists so that notifying doesn't have to hold any locks.
 */
public void unregisterMessageListener(byte[] guid,MessageListener ml){
  boolean removed=false;
synchronized (MESSAGE_LISTENER_LOCK) {
    List all=(List)_messageListeners.get(guid);
    if (all != null) {
      all=new ArrayList(all);
      if (all.remove(ml)) {
        removed=true;
        Map listeners=new TreeMap(GUID.GUID_BYTE_COMPARATOR);
        listeners.putAll(_messageListeners);
        if (all.isEmpty())         listeners.remove(guid);
 else         listeners.put(guid,Collections.unmodifiableList(all));
        _messageListeners=Collections.unmodifiableMap(listeners);
      }
    }
  }
  if (removed)   ml.unregistered(guid);
}","/** 
 * Unregisters this MessageListener from listening to the GUID. This works by replacing the necessary maps & lists so that notifying doesn't have to hold any locks.
 */
public void unregisterMessageListener(byte[] guid,MessageListener ml){
  boolean removed=false;
synchronized (MESSAGE_LISTENER_LOCK) {
    List<MessageListener> all=_messageListeners.get(guid);
    if (all != null) {
      all=new ArrayList<MessageListener>(all);
      if (all.remove(ml)) {
        removed=true;
        Map<byte[],List<MessageListener>> listeners=new TreeMap<byte[],List<MessageListener>>(GUID.GUID_BYTE_COMPARATOR);
        listeners.putAll(_messageListeners);
        if (all.isEmpty())         listeners.remove(guid);
 else         listeners.put(guid,Collections.unmodifiableList(all));
        _messageListeners=Collections.unmodifiableMap(listeners);
      }
    }
  }
  if (removed)   ml.unregistered(guid);
}",0.9421296296296297
4271,"/** 
 * Adds the specified MessageListener for messages with this GUID. You must manually unregister the listener. This works by replacing the necessary maps & lists, so that  notifying doesn't have to hold any locks.
 */
public void registerMessageListener(byte[] guid,MessageListener ml){
  ml.registered(guid);
synchronized (MESSAGE_LISTENER_LOCK) {
    Map listeners=new TreeMap(GUID.GUID_BYTE_COMPARATOR);
    listeners.putAll(_messageListeners);
    List all=(List)listeners.get(guid);
    if (all == null) {
      all=new ArrayList(1);
      all.add(ml);
    }
 else {
      List temp=new ArrayList(all.size() + 1);
      temp.addAll(all);
      all=temp;
      all.add(ml);
    }
    listeners.put(guid,Collections.unmodifiableList(all));
    _messageListeners=Collections.unmodifiableMap(listeners);
  }
}","/** 
 * Adds the specified MessageListener for messages with this GUID. You must manually unregister the listener. This works by replacing the necessary maps & lists, so that  notifying doesn't have to hold any locks.
 */
public void registerMessageListener(byte[] guid,MessageListener ml){
  ml.registered(guid);
synchronized (MESSAGE_LISTENER_LOCK) {
    Map<byte[],List<MessageListener>> listeners=new TreeMap<byte[],List<MessageListener>>(GUID.GUID_BYTE_COMPARATOR);
    listeners.putAll(_messageListeners);
    List<MessageListener> all=listeners.get(guid);
    if (all == null) {
      all=new ArrayList<MessageListener>(1);
      all.add(ml);
    }
 else {
      List<MessageListener> temp=new ArrayList<MessageListener>(all.size() + 1);
      temp.addAll(all);
      all=temp;
      all.add(ml);
    }
    listeners.put(guid,Collections.unmodifiableList(all));
    _messageListeners=Collections.unmodifiableMap(listeners);
  }
}",0.9234285714285714
4272,"/** 
 * Returns a MessageHandler for the specified Message Class or null if no such MessageHandler exists.
 */
public MessageHandler getMulticastMessageHandler(Class clazz){
  return getHandler(multicastMessageHandlers,clazz);
}","/** 
 * Returns a MessageHandler for the specified Message Class or null if no such MessageHandler exists.
 */
public MessageHandler getMulticastMessageHandler(Class<? extends Message> clazz){
  return getHandler(multicastMessageHandlers,clazz);
}",0.96
4273,"public void run(){
  if (RouterService.isSupernode())   return;
  boolean isBusy=!RouterService.getUploadManager().isServiceable();
  final List connections=_manager.getInitializedConnections();
  final HopsFlowVendorMessage hops=new HopsFlowVendorMessage(isBusy ? BUSY_HOPS_FLOW : FREE_HOPS_FLOW);
  if (isBusy == _oldBusyState) {
    for (int i=0; i < connections.size(); i++) {
      ManagedConnection c=(ManagedConnection)connections.get(i);
      if (c != null && c.getConnectionTime() + 1.25 * HOPS_FLOW_INTERVAL > System.currentTimeMillis() && c.isClientSupernodeConnection())       c.send(hops);
    }
  }
 else {
    _oldBusyState=isBusy;
    for (int i=0; i < connections.size(); i++) {
      ManagedConnection c=(ManagedConnection)connections.get(i);
      if (c != null && c.isClientSupernodeConnection())       c.send(hops);
    }
  }
}","public void run(){
  if (RouterService.isSupernode())   return;
  boolean isBusy=!RouterService.getUploadManager().isServiceable();
  final List<ManagedConnection> connections=_manager.getInitializedConnections();
  final HopsFlowVendorMessage hops=new HopsFlowVendorMessage(isBusy ? BUSY_HOPS_FLOW : FREE_HOPS_FLOW);
  if (isBusy == _oldBusyState) {
    for (int i=0; i < connections.size(); i++) {
      ManagedConnection c=connections.get(i);
      if (c != null && c.getConnectionTime() + 1.25 * HOPS_FLOW_INTERVAL > System.currentTimeMillis() && c.isClientSupernodeConnection())       c.send(hops);
    }
  }
 else {
    _oldBusyState=isBusy;
    for (int i=0; i < connections.size(); i++) {
      ManagedConnection c=connections.get(i);
      if (c != null && c.isClientSupernodeConnection())       c.send(hops);
    }
  }
}",0.96605122096486
4274,"/** 
 * @returns a Set with GUESSEndpoints that had matches for theoriginal query guid.  may be empty.
 * @param guid the guid of the query you want endpoints for.
 */
public Set getGuessLocs(GUID guid){
  Set clone=new HashSet();
synchronized (_bypassedResults) {
    Set eps=(Set)_bypassedResults.get(guid);
    if (eps != null)     clone.addAll(eps);
  }
  return clone;
}","/** 
 * @returns a Set with GUESSEndpoints that had matches for theoriginal query guid.  may be empty.
 * @param guid the guid of the query you want endpoints for.
 */
public Set<GUESSEndpoint> getGuessLocs(GUID guid){
  Set<GUESSEndpoint> clone=new HashSet<GUESSEndpoint>();
synchronized (_bypassedResults) {
    Set<GUESSEndpoint> eps=_bypassedResults.get(guid);
    if (eps != null)     clone.addAll(eps);
  }
  return clone;
}",0.9192546583850932
4275,"/** 
 * Installs a MessageHandler for ""regular"" Messages.
 * @link #handleMessage(Message, ManagedConnection)
 * @param clazz The Class of the Message
 * @param handler The Handler of the Message
 */
public void setMessageHandler(Class clazz,MessageHandler handler){
synchronized (messageHandlers) {
    messageHandlers=setHandler(messageHandlers,clazz,handler);
  }
}","/** 
 * Installs a MessageHandler for ""regular"" Messages.
 * @link #handleMessage(Message, ManagedConnection)
 * @param clazz The Class of the Message
 * @param handler The Handler of the Message
 */
public void setMessageHandler(Class<? extends Message> clazz,MessageHandler handler){
synchronized (messageHandlers) {
    messageHandlers=setHandler(messageHandlers,clazz,handler);
  }
}",0.9748344370860929
4276,"/** 
 * Handles a ACK message - looks up the QueryReply and sends it out of band.
 */
protected void handleLimeACKMessage(LimeACKVendorMessage ack,InetSocketAddress addr){
  GUID.TimedGUID refGUID=new GUID.TimedGUID(new GUID(ack.getGUID()),TIMED_GUID_LIFETIME);
  QueryResponseBundle bundle=(QueryResponseBundle)_outOfBandReplies.remove(refGUID);
  if ((bundle != null) && (ack.getNumResults() > 0)) {
    InetAddress iaddr=addr.getAddress();
    int port=addr.getPort();
    Iterator iterator=null;
    if (ack.getNumResults() < bundle._responses.length) {
      Response[] desired=new Response[ack.getNumResults()];
      for (int i=0; i < desired.length; i++)       desired[i]=bundle._responses[i];
      iterator=responsesToQueryReplies(desired,bundle._query,1);
    }
 else     iterator=responsesToQueryReplies(bundle._responses,bundle._query,1);
    while (iterator.hasNext()) {
      QueryReply queryReply=(QueryReply)iterator.next();
      UDPService.instance().send(queryReply,iaddr,port);
    }
  }
}","/** 
 * Handles a ACK message - looks up the QueryReply and sends it out of band.
 */
protected void handleLimeACKMessage(LimeACKVendorMessage ack,InetSocketAddress addr){
  GUID.TimedGUID refGUID=new GUID.TimedGUID(new GUID(ack.getGUID()),TIMED_GUID_LIFETIME);
  QueryResponseBundle bundle=_outOfBandReplies.remove(refGUID);
  if ((bundle != null) && (ack.getNumResults() > 0)) {
    InetAddress iaddr=addr.getAddress();
    int port=addr.getPort();
    Iterable<QueryReply> iterable;
    if (ack.getNumResults() < bundle._responses.length) {
      Response[] desired=new Response[ack.getNumResults()];
      for (int i=0; i < desired.length; i++)       desired[i]=bundle._responses[i];
      iterable=responsesToQueryReplies(desired,bundle._query,1);
    }
 else {
      iterable=responsesToQueryReplies(bundle._responses,bundle._query,1);
    }
    for (    QueryReply queryReply : iterable)     UDPService.instance().send(queryReply,iaddr,port);
  }
}",0.9048346055979644
4277,"/** 
 * Forwards the request to neighboring Ultrapeers as a TCPConnectBackRedirect message.
 */
protected void handleTCPConnectBackRequest(TCPConnectBackVendorMessage tcp,Connection source){
  final int portToContact=tcp.getConnectBackPort();
  InetAddress sourceAddr=source.getInetAddress();
  Message msg=new TCPConnectBackRedirect(sourceAddr,portToContact);
  int sentTo=0;
  List peers=new ArrayList(_manager.getInitializedConnections());
  Collections.shuffle(peers);
  for (Iterator i=peers.iterator(); i.hasNext() && sentTo < MAX_TCP_CONNECTBACK_FORWARDS; ) {
    ManagedConnection currMC=(ManagedConnection)i.next();
    if (currMC == source)     continue;
    if (currMC.remoteHostSupportsTCPRedirect() >= 0) {
      currMC.send(msg);
      sentTo++;
    }
  }
}","/** 
 * Forwards the request to neighboring Ultrapeers as a TCPConnectBackRedirect message.
 */
protected void handleTCPConnectBackRequest(TCPConnectBackVendorMessage tcp,Connection source){
  final int portToContact=tcp.getConnectBackPort();
  InetAddress sourceAddr=source.getInetAddress();
  Message msg=new TCPConnectBackRedirect(sourceAddr,portToContact);
  int sentTo=0;
  List<ManagedConnection> peers=new ArrayList<ManagedConnection>(_manager.getInitializedConnections());
  Collections.shuffle(peers);
  for (  ManagedConnection currMC : peers) {
    if (sentTo >= MAX_TCP_CONNECTBACK_FORWARDS)     break;
    if (currMC == source)     continue;
    if (currMC.remoteHostSupportsTCPRedirect() >= 0) {
      currMC.send(msg);
      sentTo++;
    }
  }
}",0.8577023498694517
4278,"/** 
 * Adds all query routing tables of leaves to the query routing table for this node for propagation to other Ultrapeers at 1 hop. Added ""busy leaf"" support to prevent a busy leaf from having its QRT table added to the Ultrapeer's last-hop QRT table.  This should reduce BW costs for UPs with busy leaves.  
 * @param qrt the <tt>QueryRouteTable</tt> to add to
 */
private static void addQueryRoutingEntriesForLeaves(QueryRouteTable qrt){
  List leaves=_manager.getInitializedClientConnections();
  for (int i=0; i < leaves.size(); i++) {
    ManagedConnection mc=(ManagedConnection)leaves.get(i);
synchronized (mc.getQRPLock()) {
      if (!mc.isBusyLeaf()) {
        QueryRouteTable qrtr=mc.getQueryRouteTableReceived();
        if (qrtr != null) {
          qrt.addAll(qrtr);
        }
      }
    }
  }
}","/** 
 * Adds all query routing tables of leaves to the query routing table for this node for propagation to other Ultrapeers at 1 hop. Added ""busy leaf"" support to prevent a busy leaf from having its QRT table added to the Ultrapeer's last-hop QRT table.  This should reduce BW costs for UPs with busy leaves.  
 * @param qrt the <tt>QueryRouteTable</tt> to add to
 */
private static void addQueryRoutingEntriesForLeaves(QueryRouteTable qrt){
  List<ManagedConnection> leaves=_manager.getInitializedClientConnections();
  for (int i=0; i < leaves.size(); i++) {
    ManagedConnection mc=leaves.get(i);
synchronized (mc.getQRPLock()) {
      if (!mc.isBusyLeaf()) {
        QueryRouteTable qrtr=mc.getQueryRouteTableReceived();
        if (qrtr != null) {
          qrt.addAll(qrtr);
        }
      }
    }
  }
}",0.9766009852216748
4279,"/** 
 * Returns a MessageHandler for the specified Message Class or null if no such MessageHandler exists.
 */
public MessageHandler getMessageHandler(Class clazz){
  return getHandler(messageHandlers,clazz);
}","/** 
 * Returns a MessageHandler for the specified Message Class or null if no such MessageHandler exists.
 */
public MessageHandler getMessageHandler(Class<? extends Message> clazz){
  return getHandler(messageHandlers,clazz);
}",0.9567198177676538
4280,"/** 
 * Performs a limited broadcast of the specified query.  This is useful, for example, when receiving queries from old-style  connections that we don't want to forward to all connected Ultrapeers because we don't want to overly magnify the query.
 * @param query the <tt>QueryRequest</tt> instance to forward
 * @param handler the <tt>ReplyHandler</tt> from which we receivedthe query
 */
private void forwardLimitedQueryToUltrapeers(QueryRequest query,ReplyHandler handler){
  List list=_manager.getInitializedConnections();
  int limit=list.size();
  int connectionsNeededForOld=OLD_CONNECTIONS_TO_USE;
  for (int i=0; i < limit; i++) {
    if (connectionsNeededForOld == 0)     break;
    ManagedConnection mc=(ManagedConnection)list.get(i);
    if (mc.isGoodUltrapeer() && (limit - i) > connectionsNeededForOld) {
      continue;
    }
    forwardQueryToUltrapeer(query,handler,mc);
    connectionsNeededForOld--;
  }
}","/** 
 * Performs a limited broadcast of the specified query.  This is useful, for example, when receiving queries from old-style  connections that we don't want to forward to all connected Ultrapeers because we don't want to overly magnify the query.
 * @param query the <tt>QueryRequest</tt> instance to forward
 * @param handler the <tt>ReplyHandler</tt> from which we receivedthe query
 */
private void forwardLimitedQueryToUltrapeers(QueryRequest query,ReplyHandler handler){
  List<ManagedConnection> list=_manager.getInitializedConnections();
  int limit=list.size();
  int connectionsNeededForOld=OLD_CONNECTIONS_TO_USE;
  for (int i=0; i < limit; i++) {
    if (connectionsNeededForOld == 0)     break;
    ManagedConnection mc=list.get(i);
    if (mc.isGoodUltrapeer() && (limit - i) > connectionsNeededForOld) {
      continue;
    }
    forwardQueryToUltrapeer(query,handler,mc);
    connectionsNeededForOld--;
  }
}",0.9795037756202803
4281,"/** 
 * Originate a new query from this leaf node.
 * @param qr the <tt>QueryRequest</tt> to send
 */
private void originateLeafQuery(QueryRequest qr){
  List list=_manager.getInitializedConnections();
  final int max=qr.isWhatIsNewRequest() ? 2 : 3;
  int start=!qr.isWhatIsNewRequest() ? 0 : (int)(Math.floor(Math.random() * (list.size() - 1)));
  int limit=Math.min(max,list.size());
  final boolean wantsOOB=qr.desiresOutOfBandReplies();
  for (int i=start; i < start + limit; i++) {
    ManagedConnection mc=(ManagedConnection)list.get(i);
    QueryRequest qrToSend=qr;
    if (wantsOOB && (mc.remoteHostSupportsLeafGuidance() < 0))     qrToSend=QueryRequest.unmarkOOBQuery(qr);
    mc.send(qrToSend);
  }
}","/** 
 * Originate a new query from this leaf node.
 * @param qr the <tt>QueryRequest</tt> to send
 */
private void originateLeafQuery(QueryRequest qr){
  List<ManagedConnection> list=_manager.getInitializedConnections();
  final int max=qr.isWhatIsNewRequest() ? 2 : 3;
  int start=!qr.isWhatIsNewRequest() ? 0 : (int)(Math.floor(Math.random() * (list.size() - 1)));
  int limit=Math.min(max,list.size());
  final boolean wantsOOB=qr.desiresOutOfBandReplies();
  for (int i=start; i < start + limit; i++) {
    ManagedConnection mc=list.get(i);
    QueryRequest qrToSend=qr;
    if (wantsOOB && (mc.remoteHostSupportsLeafGuidance() < 0))     qrToSend=QueryRequest.unmarkOOBQuery(qr);
    mc.send(qrToSend);
  }
}",0.973314606741573
4282,"/** 
 * Broadcasts the ping request to all initialized connections that are not the receivingConnection, setting up the routing to the designated PingReplyHandler.  This is called from the default handlePingRequest and the default broadcastPingRequest(PingRequest) If different (smarter) broadcasting functionality is desired, override as desired.  If you do, note that receivingConnection may be null (for requests originating here).
 */
private void broadcastPingRequest(PingRequest request,ReplyHandler receivingConnection,ConnectionManager manager){
  List list=manager.getInitializedConnections();
  int size=list.size();
  boolean randomlyForward=false;
  if (size > 3)   randomlyForward=true;
  double percentToIgnore;
  for (int i=0; i < size; i++) {
    ManagedConnection mc=(ManagedConnection)list.get(i);
    if (!mc.isStable())     continue;
    if (receivingConnection == FOR_ME_REPLY_HANDLER || (mc != receivingConnection && !mc.isClientSupernodeConnection())) {
      if (mc.supportsPongCaching()) {
        percentToIgnore=0.70;
      }
 else {
        percentToIgnore=0.90;
      }
      if (randomlyForward && (Math.random() < percentToIgnore)) {
        continue;
      }
 else {
        mc.send(request);
      }
    }
  }
}","/** 
 * Broadcasts the ping request to all initialized connections that are not the receivingConnection, setting up the routing to the designated PingReplyHandler.  This is called from the default handlePingRequest and the default broadcastPingRequest(PingRequest) If different (smarter) broadcasting functionality is desired, override as desired.  If you do, note that receivingConnection may be null (for requests originating here).
 */
private void broadcastPingRequest(PingRequest request,ReplyHandler receivingConnection,ConnectionManager manager){
  List<ManagedConnection> list=manager.getInitializedConnections();
  int size=list.size();
  boolean randomlyForward=false;
  if (size > 3)   randomlyForward=true;
  double percentToIgnore;
  for (int i=0; i < size; i++) {
    ManagedConnection mc=list.get(i);
    if (!mc.isStable())     continue;
    if (receivingConnection == FOR_ME_REPLY_HANDLER || (mc != receivingConnection && !mc.isClientSupernodeConnection())) {
      if (mc.supportsPongCaching()) {
        percentToIgnore=0.70;
      }
 else {
        percentToIgnore=0.90;
      }
      if (randomlyForward && (Math.random() < percentToIgnore)) {
        continue;
      }
 else {
        mc.send(request);
      }
    }
  }
}",0.984726688102894
4283,"/** 
 * Accessor for the <tt>Set</tt> of cached pongs.  This <tt>List</tt> is unmodifiable and will throw <tt>IllegalOperationException</tt> if it is modified.
 * @return the <tt>List</tt> of cached pongs -- continually updated
 */
public List getBestPongs(String loc){
synchronized (PONGS) {
    List pongs=new LinkedList();
    long curTime=System.currentTimeMillis();
    List removeList=addBestPongs(loc,pongs,curTime,0);
    removePongs(loc,removeList);
    if (!ApplicationSettings.DEFAULT_LOCALE.getValue().equals(loc) && pongs.size() < NUM_HOPS) {
      removeList=addBestPongs(ApplicationSettings.DEFAULT_LOCALE.getValue(),pongs,curTime,pongs.size());
      removePongs(ApplicationSettings.DEFAULT_LOCALE.getValue(),removeList);
    }
    return pongs;
  }
}","/** 
 * Accessor for the <tt>Set</tt> of cached pongs.  This <tt>List</tt> is unmodifiable and will throw <tt>IllegalOperationException</tt> if it is modified.
 * @return the <tt>List</tt> of cached pongs -- continually updated
 */
public List<PingReply> getBestPongs(String loc){
synchronized (PONGS) {
    List<PingReply> pongs=new LinkedList<PingReply>();
    long curTime=System.currentTimeMillis();
    List<PingReply> removeList=addBestPongs(loc,pongs,curTime,0);
    removePongs(loc,removeList);
    if (!ApplicationSettings.DEFAULT_LOCALE.getValue().equals(loc) && pongs.size() < NUM_HOPS) {
      removeList=addBestPongs(ApplicationSettings.DEFAULT_LOCALE.getValue(),pongs,curTime,pongs.size());
      removePongs(ApplicationSettings.DEFAULT_LOCALE.getValue(),removeList);
    }
    return pongs;
  }
}",0.9721166032953104
4284,"/** 
 * Adds the specified <tt>PingReply</tt> instance to the cache of pongs.
 * @param pr the <tt>PingReply</tt> to add
 */
public void addPong(PingReply pr){
  if (!RouterService.isSupernode())   return;
  if (!pr.isUltrapeer())   return;
  if (pr.getHops() >= NUM_HOPS)   return;
synchronized (PONGS) {
    if (PONGS.containsKey(pr.getClientLocale())) {
      BucketQueue bq=(BucketQueue)PONGS.get(pr.getClientLocale());
      bq.insert(pr,pr.getHops());
    }
 else {
      BucketQueue bq=new BucketQueue(NUM_HOPS,NUM_PONGS_PER_HOP);
      bq.insert(pr,pr.getHops());
      PONGS.put(pr.getClientLocale(),bq);
    }
  }
}","/** 
 * Adds the specified <tt>PingReply</tt> instance to the cache of pongs.
 * @param pr the <tt>PingReply</tt> to add
 */
public void addPong(PingReply pr){
  if (!RouterService.isSupernode())   return;
  if (!pr.isUltrapeer())   return;
  if (pr.getHops() >= NUM_HOPS)   return;
synchronized (PONGS) {
    if (PONGS.containsKey(pr.getClientLocale())) {
      BucketQueue<PingReply> bq=PONGS.get(pr.getClientLocale());
      bq.insert(pr,pr.getHops());
    }
 else {
      BucketQueue<PingReply> bq=new BucketQueue<PingReply>(NUM_HOPS,NUM_PONGS_PER_HOP);
      bq.insert(pr,pr.getHops());
      PONGS.put(pr.getClientLocale(),bq);
    }
  }
}",0.9637795275590552
4285,"/** 
 * removes the pongs with the specified locale and those that are in the passed in list l
 */
private void removePongs(String loc,List l){
  if (l != null) {
    BucketQueue bq=(BucketQueue)PONGS.get(loc);
    Iterator iter=l.iterator();
    while (iter.hasNext()) {
      PingReply pr=(PingReply)iter.next();
      bq.removeAll(pr);
    }
  }
}","/** 
 * removes the pongs with the specified locale and those that are in the passed in list l
 */
private void removePongs(String loc,List<PingReply> l){
  if (l != null) {
    BucketQueue<PingReply> bq=PONGS.get(loc);
    for (    PingReply pr : l) {
      bq.removeAll(pr);
    }
  }
}",0.7554858934169278
4286,"/** 
 * adds good pongs to the passed in list ""pongs"" and return a list of pongs that should be removed.
 */
private List addBestPongs(String loc,List pongs,long curTime,int i){
  int exp_time=(ApplicationSettings.DEFAULT_LOCALE.getValue().equals(loc)) ? EXPIRE_TIME : EXPIRE_TIME_LOC;
  List remove=null;
  if (PONGS.containsKey(loc)) {
    BucketQueue bq=(BucketQueue)PONGS.get(loc);
    Iterator iter=bq.iterator();
    for (; iter.hasNext() && i < NUM_HOPS; i++) {
      PingReply pr=(PingReply)iter.next();
      if (curTime - pr.getCreationTime() > exp_time) {
        if (remove == null)         remove=new LinkedList();
        remove.add(pr);
      }
 else {
        pongs.add(pr);
      }
    }
  }
  return remove;
}","/** 
 * adds good pongs to the passed in list ""pongs"" and return a list of pongs that should be removed.
 */
private List<PingReply> addBestPongs(String loc,List<PingReply> pongs,long curTime,int i){
  int exp_time=(ApplicationSettings.DEFAULT_LOCALE.getValue().equals(loc)) ? EXPIRE_TIME : EXPIRE_TIME_LOC;
  List<PingReply> remove=null;
  if (PONGS.containsKey(loc)) {
    BucketQueue<PingReply> bq=PONGS.get(loc);
    Iterator<PingReply> iter=bq.iterator();
    for (; iter.hasNext() && i < NUM_HOPS; i++) {
      PingReply pr=iter.next();
      if (curTime - pr.getCreationTime() > exp_time) {
        if (remove == null)         remove=new LinkedList<PingReply>();
        remove.add(pr);
      }
 else {
        pongs.add(pr);
      }
    }
  }
  return remove;
}",0.9398395721925134
4287,"/** 
 * interrupts this downloader.
 */
void interrupt(){
  _interrupted=true;
synchronized (_currentState) {
    if (_currentState.getCurrentState() == DownloadState.QUEUED)     finishHttpLoop();
  }
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + _currentState + ""String_Node_Str""+ toString());
  if (_downloader != null) {
    _downloader.stop();
  }
 else {
    DirectConnector observer=_connectObserver;
    if (observer != null) {
      if (Sockets.removeConnectObserver(_connectObserver))       finishWorker();
 else       if (observer.getSocket() != null)       IOUtils.close(observer.getSocket());
    }
  }
}","/** 
 * interrupts this downloader.
 */
void interrupt(){
  _interrupted=true;
synchronized (_currentState) {
    if (_currentState.getCurrentState() == DownloadState.QUEUED)     finishHttpLoop();
  }
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + _currentState + ""String_Node_Str""+ toString());
  if (_downloader != null) {
    _downloader.stop();
  }
 else {
    DirectConnector observer=_connectObserver;
    if (observer != null) {
      Socket socket=observer.getSocket();
      if (socket != null)       IOUtils.close(socket);
    }
  }
}",0.8643639427127211
4288,"public synchronized void registered(byte[] guid){
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + (new GUID(guid)).toHexString(),new Exception());
  running=true;
}","public synchronized void registered(byte[] guid){
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + (new GUID(guid)).toHexString());
  running=true;
}",0.9523809523809524
4289,"public synchronized void unregistered(byte[] guid){
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + (new GUID(guid)).toHexString(),new Exception());
  running=false;
  newHosts.addAll(verifiedHosts);
  newHosts.addAll(testedLocations);
  verifiedHosts.clear();
  pingedHosts.clear();
  testedLocations.clear();
  lastPingTime=0;
}","public synchronized void unregistered(byte[] guid){
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + (new GUID(guid)).toHexString());
  running=false;
  newHosts.addAll(verifiedHosts);
  newHosts.addAll(testedLocations);
  verifiedHosts.clear();
  pingedHosts.clear();
  testedLocations.clear();
  lastPingTime=0;
}",0.9760479041916168
4290,"public void run(){
  reader=new NoOpReader();
  writer=new NoOpWriter();
  connecter=null;
}","public void run(){
  reader=new NoOpReader();
  writer=new NoOpWriter();
  connecter=null;
  shutdownObserver=null;
}",0.8803827751196173
4291,"/** 
 * Sets the new ReadObserver. The deepest ChannelReader in the chain first has its source set to the prior reader (assuming it implemented ReadableByteChannel) and a read is notified, in order to read any buffered data. The source is then set to the Socket's channel and interest in reading is turned on.
 */
public final void setReadObserver(final ChannelReadObserver newReader){
  NIODispatcher.instance().invokeLater(new Runnable(){
    public void run(){
      ReadObserver oldReader=reader;
      try {
        reader=newReader;
        ChannelReader lastChannel=newReader;
        while (lastChannel.getReadChannel() instanceof ChannelReader)         lastChannel=(ChannelReader)lastChannel.getReadChannel();
        if (oldReader instanceof InterestReadChannel && oldReader != newReader) {
          if (lastChannel instanceof ThrottleListener)           ((ThrottleListener)lastChannel).setAttachment(AbstractNBSocket.this);
          lastChannel.setReadChannel((InterestReadChannel)oldReader);
          reader.handleRead();
          oldReader.shutdown();
        }
        InterestReadChannel source=getBaseReadChannel();
        lastChannel.setReadChannel(source);
        NIODispatcher.instance().interestRead(getChannel(),true);
      }
 catch (      IOException iox) {
        shutdown();
        oldReader.shutdown();
      }
    }
  }
);
}","/** 
 * Sets the new ReadObserver. The deepest ChannelReader in the chain first has its source set to the prior reader (assuming it implemented ReadableByteChannel) and a read is notified, in order to read any buffered data. The source is then set to the Socket's channel and interest in reading is turned on.
 */
public final void setReadObserver(final ChannelReadObserver newReader){
  NIODispatcher.instance().invokeLater(new Runnable(){
    public void run(){
      ReadObserver oldReader=reader;
      try {
synchronized (LOCK) {
          if (shutdown) {
            newReader.shutdown();
            return;
          }
          reader=newReader;
        }
        ChannelReader lastChannel=newReader;
        while (lastChannel.getReadChannel() instanceof ChannelReader)         lastChannel=(ChannelReader)lastChannel.getReadChannel();
        if (oldReader instanceof InterestReadChannel && oldReader != newReader) {
          if (lastChannel instanceof ThrottleListener)           ((ThrottleListener)lastChannel).setAttachment(AbstractNBSocket.this);
          lastChannel.setReadChannel((InterestReadChannel)oldReader);
          reader.handleRead();
          oldReader.shutdown();
        }
        InterestReadChannel source=getBaseReadChannel();
        lastChannel.setReadChannel(source);
        NIODispatcher.instance().interestRead(getChannel(),true);
      }
 catch (      IOException iox) {
        shutdown();
        oldReader.shutdown();
      }
    }
  }
);
}",0.9556962025316456
4292,"/** 
 * Sets the new WriteObserver. If a ThrottleWriter is one of the ChannelWriters, the attachment of the ThrottleWriter is set to be this. The deepest ChannelWriter in the chain has its source set to be a new InterestWriteChannel, which will be used as the hub to receive and forward interest events from/to the channel. If this is called while the existing WriteObserver still has data left to write, then an IllegalStateException is thrown.
 */
public final void setWriteObserver(final ChannelWriter newWriter){
  NIODispatcher.instance().invokeLater(new Runnable(){
    public void run(){
      try {
        if (writer.handleWrite())         throw new IllegalStateException(""String_Node_Str"");
        writer.shutdown();
        ChannelWriter lastChannel=newWriter;
        while (lastChannel.getWriteChannel() instanceof ChannelWriter) {
          lastChannel=(ChannelWriter)lastChannel.getWriteChannel();
          if (lastChannel instanceof ThrottleListener)           ((ThrottleListener)lastChannel).setAttachment(AbstractNBSocket.this);
        }
        InterestWriteChannel source=getBaseWriteChannel();
        writer=source;
        lastChannel.setWriteChannel(source);
      }
 catch (      IOException iox) {
        shutdown();
        newWriter.shutdown();
      }
    }
  }
);
}","/** 
 * Sets the new WriteObserver. If a ThrottleWriter is one of the ChannelWriters, the attachment of the ThrottleWriter is set to be this. The deepest ChannelWriter in the chain has its source set to be a new InterestWriteChannel, which will be used as the hub to receive and forward interest events from/to the channel. If this is called while the existing WriteObserver still has data left to write, then an IllegalStateException is thrown.
 */
public final void setWriteObserver(final ChannelWriter newWriter){
  NIODispatcher.instance().invokeLater(new Runnable(){
    public void run(){
      try {
        if (writer.handleWrite())         throw new IllegalStateException(""String_Node_Str"");
        writer.shutdown();
        ChannelWriter lastChannel=newWriter;
        while (lastChannel.getWriteChannel() instanceof ChannelWriter) {
          lastChannel=(ChannelWriter)lastChannel.getWriteChannel();
          if (lastChannel instanceof ThrottleListener)           ((ThrottleListener)lastChannel).setAttachment(AbstractNBSocket.this);
        }
        InterestWriteChannel source=getBaseWriteChannel();
synchronized (LOCK) {
          lastChannel.setWriteChannel(source);
          if (shutdown) {
            source.shutdown();
            return;
          }
          writer=source;
        }
      }
 catch (      IOException iox) {
        shutdown();
        newWriter.shutdown();
      }
    }
  }
);
}",0.927653323540213
4293,"/** 
 * Connects to the specified address within the given timeout (in milliseconds). The given ConnectObserver will be notified of success or failure. In the event of success, observer.handleConnect is called.  In a failure, observer.shutdown is called.  observer.handleIOException is never called. Returns true if this was able to connect immediately.  The observer is still notified about the success even it it was immediate.
 */
public boolean connect(SocketAddress addr,int timeout,ConnectObserver observer){
  this.connecter=observer;
  try {
    InetSocketAddress iaddr=(InetSocketAddress)addr;
    if (iaddr.isUnresolved())     throw new IOException(""String_Node_Str"" + addr);
    if (getChannel().connect(addr)) {
      observer.handleConnect(this);
      return true;
    }
 else {
      NIODispatcher.instance().registerConnect(getChannel(),this,timeout);
      return false;
    }
  }
 catch (  IOException failed) {
    NIODispatcher.instance().invokeReallyLater(new Runnable(){
      public void run(){
        shutdown();
      }
    }
);
    return false;
  }
}","/** 
 * Connects to the specified address within the given timeout (in milliseconds). The given ConnectObserver will be notified of success or failure. In the event of success, observer.handleConnect is called.  In a failure, observer.shutdown is called.  observer.handleIOException is never called. Returns true if this was able to connect immediately.  The observer is still notified about the success even it it was immediate.
 */
public boolean connect(SocketAddress addr,int timeout,ConnectObserver observer){
synchronized (LOCK) {
    if (shutdown) {
      observer.shutdown();
      return false;
    }
    this.connecter=observer;
  }
  try {
    InetSocketAddress iaddr=(InetSocketAddress)addr;
    if (iaddr.isUnresolved())     throw new IOException(""String_Node_Str"" + addr);
    if (getChannel().connect(addr)) {
      observer.handleConnect(this);
      return true;
    }
 else {
      NIODispatcher.instance().registerConnect(getChannel(),this,timeout);
      return false;
    }
  }
 catch (  IOException failed) {
    NIODispatcher.instance().invokeReallyLater(new Runnable(){
      public void run(){
        shutdown();
      }
    }
);
    return false;
  }
}",0.9552503322995126
4294,"public String toString(){
  return ""String_Node_Str"" + channel.toString();
}","public String toString(){
  return ""String_Node_Str"" + connectedTo + ""String_Node_Str""+ channel.toString();
}",0.8216216216216217
4295,"/** 
 * Runs through any waiting Requestors and initiates a connection to them.
 */
private void runWaitingRequests(){
  List toBeProcessed=new ArrayList(Math.min(WAITING_REQUESTS.size(),Math.max(0,MAX_CONNECTING_SOCKETS - _socketsConnecting)));
synchronized (this) {
    while (_socketsConnecting < MAX_CONNECTING_SOCKETS && !WAITING_REQUESTS.isEmpty()) {
      toBeProcessed.add(WAITING_REQUESTS.remove(0));
      _socketsConnecting++;
    }
  }
  for (int i=0; i < toBeProcessed.size(); i++) {
    Requestor next=(Requestor)toBeProcessed.get(i);
    next.socket.connect(next.addr,next.timeout,new DelegateConnector(next.observer));
  }
}","/** 
 * Runs through any waiting Requestors and initiates a connection to them.
 */
private void runWaitingRequests(){
  List toBeProcessed=new ArrayList(Math.min(WAITING_REQUESTS.size(),Math.max(0,MAX_CONNECTING_SOCKETS - _socketsConnecting)));
synchronized (this) {
    while (_socketsConnecting < MAX_CONNECTING_SOCKETS && !WAITING_REQUESTS.isEmpty()) {
      Requestor next=(Requestor)WAITING_REQUESTS.remove(0);
      if (!next.socket.isClosed()) {
        toBeProcessed.add(next);
        _socketsConnecting++;
      }
    }
  }
  for (int i=0; i < toBeProcessed.size(); i++) {
    Requestor next=(Requestor)toBeProcessed.get(i);
    next.socket.setShutdownObserver(null);
    next.socket.connect(next.addr,next.timeout,new DelegateConnector(next.observer));
  }
}",0.8780141843971632
4296,"/** 
 * Determines if the given requestor can immediately connect. If not, adds it to a pool of future connection-wanters.
 */
private synchronized boolean addWaitingSocket(NBSocket socket,InetSocketAddress addr,int timeout,ConnectObserver observer){
  if (_socketsConnecting >= MAX_CONNECTING_SOCKETS) {
    WAITING_REQUESTS.add(new Requestor(socket,addr,timeout,observer));
    return false;
  }
 else {
    _socketsConnecting++;
    return true;
  }
}","/** 
 * Determines if the given requestor can immediately connect. If not, adds it to a pool of future connection-wanters.
 */
private synchronized boolean addWaitingSocket(NBSocket socket,InetSocketAddress addr,int timeout,ConnectObserver observer){
  if (_socketsConnecting >= MAX_CONNECTING_SOCKETS) {
    WAITING_REQUESTS.add(new Requestor(socket,addr,timeout,observer));
    socket.setShutdownObserver(new RemovalObserver(observer));
    return false;
  }
 else {
    _socketsConnecting++;
    return true;
  }
}",0.9351184346035016
4297,"public void testLegacy() throws Exception {
  BinaryHeap q=new BinaryHeap(4);
  MyInteger one=new MyInteger(1);
  MyInteger two=new MyInteger(2);
  MyInteger three=new MyInteger(3);
  MyInteger four=new MyInteger(4);
  MyInteger five=new MyInteger(5);
  assertTrue(q.isEmpty());
  assertEquals(4,q.capacity());
  assertEquals(0,q.size());
  q.insert(two);
  assertEquals(1,q.size());
  q.insert(three);
  q.insert(four);
  q.insert(one);
  assertTrue(q.isFull());
  assertEquals(4,q.size());
  assertEquals(four,q.getMax());
  assertEquals(four,q.extractMax());
  assertEquals(three,q.getMax());
  assertEquals(three,q.extractMax());
  q.insert(two);
  assertEquals(two,q.extractMax());
  assertEquals(two,q.extractMax());
  assertEquals(one,q.extractMax());
  try {
    q.extractMax();
    fail(""String_Node_Str"");
  }
 catch (  NoSuchElementException e) {
  }
  q=new BinaryHeap(2);
  assertTrue(!q.iterator().hasNext());
  q.insert(one);
  q.insert(two);
  Iterator iter=q.iterator();
  assertTrue(iter.hasNext());
  assertEquals(two,iter.next());
  assertTrue(iter.hasNext());
  assertEquals(one,iter.next());
  assertTrue(!iter.hasNext());
  try {
    iter.next();
    fail(""String_Node_Str"");
  }
 catch (  NoSuchElementException e) {
  }
  q=new BinaryHeap(4);
  assertNull(q.insert(one));
  assertNull(q.insert(four));
  assertNull(q.insert(three));
  assertTrue(!q.isFull());
  assertNull(q.insert(two));
  assertTrue(q.isFull());
  assertNotNull(q.insert(five));
  assertEquals(new MyInteger(2),q.insert(five));
  assertEquals(five,q.extractMax());
  assertEquals(five,q.extractMax());
  assertEquals(four,q.extractMax());
  assertEquals(three,q.extractMax());
  assertTrue(q.isEmpty());
}","public void testLegacy() throws Exception {
  BinaryHeap q=new BinaryHeap(4);
  Integer one=new Integer(1);
  Integer two=new Integer(2);
  Integer three=new Integer(3);
  Integer four=new Integer(4);
  Integer five=new Integer(5);
  assertTrue(q.isEmpty());
  assertEquals(4,q.capacity());
  assertEquals(0,q.size());
  q.insert(two);
  assertEquals(1,q.size());
  q.insert(three);
  q.insert(four);
  q.insert(one);
  assertTrue(q.isFull());
  assertEquals(4,q.size());
  assertEquals(four,q.getMax());
  assertEquals(four,q.extractMax());
  assertEquals(three,q.getMax());
  assertEquals(three,q.extractMax());
  q.insert(two);
  assertEquals(two,q.extractMax());
  assertEquals(two,q.extractMax());
  assertEquals(one,q.extractMax());
  try {
    q.extractMax();
    fail(""String_Node_Str"");
  }
 catch (  NoSuchElementException e) {
  }
  q=new BinaryHeap(2);
  assertTrue(!q.iterator().hasNext());
  q.insert(one);
  q.insert(two);
  Iterator iter=q.iterator();
  assertTrue(iter.hasNext());
  assertEquals(two,iter.next());
  assertTrue(iter.hasNext());
  assertEquals(one,iter.next());
  assertTrue(!iter.hasNext());
  try {
    iter.next();
    fail(""String_Node_Str"");
  }
 catch (  NoSuchElementException e) {
  }
  q=new BinaryHeap(4);
  assertNull(q.insert(one));
  assertNull(q.insert(four));
  assertNull(q.insert(three));
  assertTrue(!q.isFull());
  assertNull(q.insert(two));
  assertTrue(q.isFull());
  assertNotNull(q.insert(five));
  assertEquals(new Integer(2),q.insert(five));
  assertEquals(five,q.extractMax());
  assertEquals(five,q.extractMax());
  assertEquals(four,q.extractMax());
  assertEquals(three,q.extractMax());
  assertTrue(q.isEmpty());
}",0.9934834123222748
4298,"public int compareTo(Object other){
  int val2=((MyInteger)other).val;
  if (val < val2)   return -1;
 else   if (val > val2)   return 1;
 else   return 0;
}","public int compareTo(Object other){
  return new Integer(id).compareTo(new Integer(((Finalizable)other).id));
}",0.4552238805970149
4299,"public void testResize() throws Exception {
  MyInteger one=new MyInteger(1);
  MyInteger two=new MyInteger(2);
  MyInteger three=new MyInteger(3);
  MyInteger four=new MyInteger(4);
  MyInteger five=new MyInteger(5);
  BinaryHeap q=new BinaryHeap(2,true);
  assertNull(q.insert(one));
  assertTrue(!q.isFull());
  assertNull(q.insert(four));
  assertEquals(2,q.capacity());
  assertTrue(q.isFull());
  assertNull(q.insert(three));
  assertEquals(4,q.capacity());
  assertTrue(!q.isFull());
  assertEquals(3,q.size());
  assertEquals(5,getArray(q).length);
  assertNull(getArray(q)[0]);
  assertNull(q.insert(two));
  assertEquals(4,q.capacity());
  assertTrue(q.isFull());
  assertEquals(4,q.size());
  assertNull(q.insert(five));
  assertEquals(8,q.capacity());
  assertTrue(!q.isFull());
  assertEquals(5,q.size());
  assertEquals(five,q.extractMax());
  assertEquals(four,q.extractMax());
  assertEquals(three,q.extractMax());
  assertEquals(two,q.extractMax());
  assertEquals(one,q.extractMax());
  assertTrue(q.isEmpty());
  assertEquals(8,q.capacity());
}","public void testResize() throws Exception {
  Integer one=new Integer(1);
  Integer two=new Integer(2);
  Integer three=new Integer(3);
  Integer four=new Integer(4);
  Integer five=new Integer(5);
  BinaryHeap q=new BinaryHeap(2,true);
  assertNull(q.insert(one));
  assertTrue(!q.isFull());
  assertNull(q.insert(four));
  assertEquals(2,q.capacity());
  assertTrue(q.isFull());
  assertNull(q.insert(three));
  assertEquals(4,q.capacity());
  assertTrue(!q.isFull());
  assertEquals(3,q.size());
  assertEquals(5,getArray(q).length);
  assertNull(getArray(q)[0]);
  assertNull(q.insert(two));
  assertEquals(4,q.capacity());
  assertTrue(q.isFull());
  assertEquals(4,q.size());
  assertNull(q.insert(five));
  assertEquals(8,q.capacity());
  assertTrue(!q.isFull());
  assertEquals(5,q.size());
  assertEquals(five,q.extractMax());
  assertEquals(four,q.extractMax());
  assertEquals(three,q.extractMax());
  assertEquals(two,q.extractMax());
  assertEquals(one,q.extractMax());
  assertTrue(q.isEmpty());
  assertEquals(8,q.capacity());
}",0.9905033238366572
4300,"/** 
 * Accepts the given incoming socket, allowing only the given protocol. If allowedProtocol is null, all are allowed.
 */
public void accept(Socket client,String allowedProtocol){
  if (!_started) {
    IOUtils.close(client);
    return;
  }
  InetAddress address=client.getInetAddress();
  if (address == null) {
    IOUtils.close(client);
    LOG.warn(""String_Node_Str"");
  }
 else   if (isBannedIP(address.getAddress())) {
    if (LOG.isWarnEnabled())     LOG.warn(""String_Node_Str"" + address);
    HTTPStat.BANNED_REQUESTS.incrementStat();
    IOUtils.close(client);
  }
 else {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + address);
    if (!ConnectionSettings.UNSET_FIREWALLED_FROM_CONNECTBACK.getValue())     checkFirewall(client.getInetAddress());
    InetAddress localAddress=client.getLocalAddress();
    setAddress(localAddress);
    try {
      _socket.setSoTimeout(Constants.TIMEOUT);
    }
 catch (    SocketException se) {
      IOUtils.close(_socket);
      return;
    }
    if (client.getChannel() instanceof NIOMultiplexor)     ((NIOMultiplexor)client).setReadObserver(new AsyncConnectionDispatcher(client,allowedProtocol));
 else     ThreadFactory.startThread(new BlockingConnectionDispatcher(client,allowedProtocol),""String_Node_Str"");
  }
}","/** 
 * Accepts the given incoming socket, allowing only the given protocol. If allowedProtocol is null, all are allowed.
 */
public void accept(Socket client,String allowedProtocol){
  if (!_started) {
    IOUtils.close(client);
    return;
  }
  InetAddress address=client.getInetAddress();
  if (address == null) {
    IOUtils.close(client);
    LOG.warn(""String_Node_Str"");
  }
 else   if (isBannedIP(address.getAddress())) {
    if (LOG.isWarnEnabled())     LOG.warn(""String_Node_Str"" + address);
    HTTPStat.BANNED_REQUESTS.incrementStat();
    IOUtils.close(client);
  }
 else {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + address);
    if (!ConnectionSettings.UNSET_FIREWALLED_FROM_CONNECTBACK.getValue())     checkFirewall(client.getInetAddress());
    InetAddress localAddress=client.getLocalAddress();
    setAddress(localAddress);
    try {
      _socket.setSoTimeout(Constants.TIMEOUT);
    }
 catch (    SocketException se) {
      IOUtils.close(_socket);
      return;
    }
    if (client instanceof NIOMultiplexor)     ((NIOMultiplexor)client).setReadObserver(new AsyncConnectionDispatcher(client,allowedProtocol));
 else     ThreadFactory.startThread(new BlockingConnectionDispatcher(client,allowedProtocol),""String_Node_Str"");
  }
}",0.9949159170903402
4301,"private void browseExchange(Socket socket) throws IOException {
  try {
    browseExchangeInternal(socket);
  }
  finally {
    try {
      socket.close();
    }
 catch (    IOException ignored) {
    }
    setState(FINISHED);
  }
}","private void browseExchange(Socket socket) throws IOException {
  try {
    browseExchangeInternal(socket);
  }
  finally {
    IOUtils.close(socket);
    setState(FINISHED);
  }
}",0.8203883495145631
4302,"private void browseExchangeInternal(Socket socket) throws IOException {
  socket.setSoTimeout(5000);
  LOG.trace(""String_Node_Str"");
  setState(EXCHANGING);
  final String LF=""String_Node_Str"";
  String str=null;
  OutputStream oStream=socket.getOutputStream();
  LOG.trace(""String_Node_Str"");
  str=""String_Node_Str"" + LF;
  oStream.write(str.getBytes());
  str=""String_Node_Str"" + NetworkUtils.ip2string(RouterService.getAddress()) + ""String_Node_Str""+ RouterService.getPort()+ LF;
  oStream.write(str.getBytes());
  str=""String_Node_Str"" + CommonUtils.getVendor() + LF;
  oStream.write(str.getBytes());
  str=""String_Node_Str"" + Constants.QUERYREPLY_MIME_TYPE + LF;
  oStream.write(str.getBytes());
  str=""String_Node_Str"" + LF;
  oStream.write(str.getBytes());
  str=""String_Node_Str"" + LF;
  oStream.write(str.getBytes());
  str=LF;
  oStream.write(str.getBytes());
  oStream.flush();
  LOG.trace(""String_Node_Str"");
  InputStream in=socket.getInputStream();
  LOG.trace(""String_Node_Str"");
  ByteReader br=new ByteReader(in);
  LOG.trace(""String_Node_Str"");
  int code=parseHTTPCode(br.readLine());
  if ((code < 200) || (code >= 300))   throw new IOException();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + code);
  boolean readingHTTP=true;
  String currLine=null;
  while (readingHTTP) {
    currLine=br.readLine();
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + currLine);
    if ((currLine == null) || currLine.equals(""String_Node_Str"")) {
      readingHTTP=false;
    }
 else     if (indexOfIgnoreCase(currLine,""String_Node_Str"") > -1) {
      if (indexOfIgnoreCase(currLine,Constants.QUERYREPLY_MIME_TYPE) < 0)       throw new IOException();
    }
 else     if (indexOfIgnoreCase(currLine,""String_Node_Str"") > -1) {
      throw new IOException();
    }
 else     if (markContentLength(currLine))     ;
  }
  LOG.debug(""String_Node_Str"");
  in=new BufferedInputStream(in);
  Message m=null;
  while (true) {
    try {
      m=null;
      LOG.debug(""String_Node_Str"");
      m=MessageFactory.read(in);
      LOG.debug(""String_Node_Str"" + m);
    }
 catch (    BadPacketException bpe) {
      LOG.debug(bpe);
    }
catch (    IOException expected) {
    }
    if (m == null)     return;
 else {
      if (m instanceof QueryReply) {
        _currentLength+=m.getTotalLength();
        if (LOG.isTraceEnabled())         LOG.trace(""String_Node_Str"" + m);
        QueryReply reply=(QueryReply)m;
        reply.setGUID(_guid);
        reply.setBrowseHostReply(true);
        ForMeReplyHandler.instance().handleQueryReply(reply,null);
      }
    }
  }
}","private void browseExchangeInternal(Socket socket) throws IOException {
  socket.setSoTimeout(5000);
  LOG.trace(""String_Node_Str"");
  setState(EXCHANGING);
  final String LF=""String_Node_Str"";
  String str=null;
  OutputStream oStream=socket.getOutputStream();
  LOG.trace(""String_Node_Str"");
  str=""String_Node_Str"" + LF;
  oStream.write(str.getBytes());
  str=""String_Node_Str"" + NetworkUtils.ip2string(RouterService.getAddress()) + ""String_Node_Str""+ RouterService.getPort()+ LF;
  oStream.write(str.getBytes());
  str=""String_Node_Str"" + CommonUtils.getVendor() + LF;
  oStream.write(str.getBytes());
  str=""String_Node_Str"" + Constants.QUERYREPLY_MIME_TYPE + LF;
  oStream.write(str.getBytes());
  str=""String_Node_Str"" + LF;
  oStream.write(str.getBytes());
  str=""String_Node_Str"" + LF;
  oStream.write(str.getBytes());
  str=LF;
  oStream.write(str.getBytes());
  oStream.flush();
  LOG.trace(""String_Node_Str"");
  InputStream in=socket.getInputStream();
  LOG.trace(""String_Node_Str"" + in);
  ByteReader br=new ByteReader(in);
  LOG.trace(""String_Node_Str"");
  int code=parseHTTPCode(br.readLine());
  if ((code < 200) || (code >= 300)) {
    LOG.debug(""String_Node_Str"" + code);
    throw new IOException();
  }
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + code);
  boolean readingHTTP=true;
  String currLine=null;
  while (readingHTTP) {
    currLine=br.readLine();
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + currLine);
    if ((currLine == null) || currLine.equals(""String_Node_Str"")) {
      readingHTTP=false;
    }
 else     if (indexOfIgnoreCase(currLine,""String_Node_Str"") > -1) {
      if (indexOfIgnoreCase(currLine,Constants.QUERYREPLY_MIME_TYPE) < 0)       throw new IOException();
    }
 else     if (indexOfIgnoreCase(currLine,""String_Node_Str"") > -1) {
      throw new IOException();
    }
 else     if (markContentLength(currLine))     ;
  }
  LOG.debug(""String_Node_Str"");
  in=new BufferedInputStream(in);
  Message m=null;
  while (true) {
    try {
      m=null;
      LOG.debug(""String_Node_Str"");
      m=MessageFactory.read(in);
    }
 catch (    BadPacketException bpe) {
      LOG.debug(""String_Node_Str"",bpe);
    }
catch (    IOException expected) {
      LOG.debug(""String_Node_Str"",expected);
    }
    if (m == null) {
      LOG.debug(""String_Node_Str"");
      return;
    }
 else {
      if (m instanceof QueryReply) {
        _currentLength+=m.getTotalLength();
        if (LOG.isTraceEnabled())         LOG.trace(""String_Node_Str"" + m);
        QueryReply reply=(QueryReply)m;
        reply.setGUID(_guid);
        reply.setBrowseHostReply(true);
        ForMeReplyHandler.instance().handleQueryReply(reply,null);
      }
    }
  }
}",0.9473882707901188
4303,"/** 
 * @return true if the Push was handled by me.
 */
public static boolean handlePush(int index,GUID serventID,final Socket socket){
  boolean retVal=false;
  LOG.trace(""String_Node_Str"");
  PushRequestDetails prd=null;
synchronized (_pushedHosts) {
    prd=(PushRequestDetails)_pushedHosts.remove(serventID);
  }
  if (prd != null) {
    final PushRequestDetails finalPRD=prd;
    ThreadFactory.startThread(new Runnable(){
      public void run(){
        try {
          finalPRD.bhh.browseExchange(socket);
        }
 catch (        IOException ohWell) {
          finalPRD.bhh.failed();
        }
      }
    }
,""String_Node_Str"");
    retVal=true;
  }
 else   LOG.debug(""String_Node_Str"");
  LOG.trace(""String_Node_Str"");
  return retVal;
}","/** 
 * @return true if the Push was handled by me.
 */
public static boolean handlePush(int index,GUID serventID,final Socket socket){
  boolean retVal=false;
  LOG.trace(""String_Node_Str"");
  PushRequestDetails prd=null;
synchronized (_pushedHosts) {
    prd=(PushRequestDetails)_pushedHosts.remove(serventID);
  }
  if (prd != null) {
    final PushRequestDetails finalPRD=prd;
    ThreadFactory.startThread(new Runnable(){
      public void run(){
        try {
          finalPRD.bhh.browseExchange(socket);
        }
 catch (        IOException ohWell) {
          LOG.debug(""String_Node_Str"",ohWell);
          finalPRD.bhh.failed();
        }
      }
    }
,""String_Node_Str"");
    retVal=true;
  }
 else   LOG.debug(""String_Node_Str"");
  LOG.trace(""String_Node_Str"");
  return retVal;
}",0.8243681140635126
4304,"/** 
 * Returns the HTTP response code from the given string, throwing an exception if it couldn't be parsed.
 * @param str an HTTP response string, e.g., ""HTTP 200 OK \r\n""
 * @exception IOException a problem occurred
 */
private static int parseHTTPCode(String str) throws IOException {
  if (str == null)   return -1;
  StringTokenizer tokenizer=new StringTokenizer(str,""String_Node_Str"");
  String token;
  if (!tokenizer.hasMoreTokens())   throw new IOException();
  token=tokenizer.nextToken();
  if (token.toUpperCase().indexOf(""String_Node_Str"") < 0)   throw new IOException();
  if (!tokenizer.hasMoreTokens())   throw new IOException();
  token=tokenizer.nextToken();
  String num=token.trim();
  try {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + num);
    return java.lang.Integer.parseInt(num);
  }
 catch (  NumberFormatException e) {
    throw new IOException();
  }
}","/** 
 * Returns the HTTP response code from the given string, throwing an exception if it couldn't be parsed.
 * @param str an HTTP response string, e.g., ""HTTP 200 OK \r\n""
 * @exception IOException a problem occurred
 */
private static int parseHTTPCode(String str) throws IOException {
  if (str == null)   throw new IOException(""String_Node_Str"");
  StringTokenizer tokenizer=new StringTokenizer(str,""String_Node_Str"");
  String token;
  if (!tokenizer.hasMoreTokens())   throw new IOException(""String_Node_Str"" + str);
  token=tokenizer.nextToken();
  if (token.toUpperCase().indexOf(""String_Node_Str"") < 0)   throw new IOException(""String_Node_Str"" + token);
  if (!tokenizer.hasMoreTokens())   throw new IOException(""String_Node_Str"" + str);
  token=tokenizer.nextToken();
  String num=token.trim();
  try {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + num);
    return java.lang.Integer.parseInt(num);
  }
 catch (  NumberFormatException e) {
    throw new IOException(""String_Node_Str"" + num);
  }
}",0.6925868325557284
4305,"/** 
 * Browses the files on the specified host and port.
 * @param host The IP of the host you want to browse.
 * @param port The port of the host you want to browse.
 * @param proxies the <tt>Set</tt> of push proxies to try
 * @param canDoFWTransfer Whether or not this guy can do a firewalltransfer.
 */
public void browseHost(String host,int port,Set proxies,boolean canDoFWTransfer){
  if (!NetworkUtils.isValidPort(port) || !NetworkUtils.isValidAddress(host)) {
    failed();
    return;
  }
  LOG.trace(""String_Node_Str"");
  setState(STARTED);
  int shouldPush=needsPush(host);
  LOG.trace(""String_Node_Str"" + shouldPush);
  boolean shouldTryPush=false;
switch (shouldPush) {
case 0:
    try {
      setState(DIRECTLY_CONNECTING);
      Socket socket=Sockets.connect(host,port,DIRECT_CONNECT_TIME);
      LOG.trace(""String_Node_Str"");
      browseExchange(socket);
    }
 catch (    IOException ioe) {
      shouldTryPush=true;
    }
  if (!shouldTryPush)   break;
case 1:
if (_serventID == null) {
  failed();
}
 else {
  RemoteFileDesc fakeRFD=new RemoteFileDesc(host,port,SPECIAL_INDEX,""String_Node_Str"",0,_serventID.bytes(),0,false,0,false,null,null,false,true,""String_Node_Str"",0l,proxies,-1,canDoFWTransfer ? UDPConnection.VERSION : 0);
synchronized (_pushedHosts) {
    _pushedHosts.put(_serventID,new PushRequestDetails(this));
  }
  LOG.trace(""String_Node_Str"");
  setState(PUSHING);
  RouterService.getDownloadManager().sendPush(fakeRFD);
}
break;
}
}","/** 
 * Browses the files on the specified host and port.
 * @param host The IP of the host you want to browse.
 * @param port The port of the host you want to browse.
 * @param proxies the <tt>Set</tt> of push proxies to try
 * @param canDoFWTransfer Whether or not this guy can do a firewalltransfer.
 */
public void browseHost(String host,int port,Set proxies,boolean canDoFWTransfer){
  if (!NetworkUtils.isValidPort(port) || !NetworkUtils.isValidAddress(host)) {
    failed();
    return;
  }
  LOG.trace(""String_Node_Str"");
  setState(STARTED);
  int shouldPush=needsPush(host);
  LOG.trace(""String_Node_Str"" + shouldPush);
  boolean shouldTryPush=false;
switch (shouldPush) {
case 0:
    try {
      setState(DIRECTLY_CONNECTING);
      LOG.trace(""String_Node_Str"");
      Socket socket=Sockets.connect(host,port,DIRECT_CONNECT_TIME);
      LOG.trace(""String_Node_Str"");
      browseExchange(socket);
    }
 catch (    IOException ioe) {
      LOG.debug(""String_Node_Str"",ioe);
      shouldTryPush=true;
    }
  if (!shouldTryPush)   break;
case 1:
LOG.debug(""String_Node_Str"");
if (_serventID == null) {
LOG.debug(""String_Node_Str"");
failed();
}
 else {
RemoteFileDesc fakeRFD=new RemoteFileDesc(host,port,SPECIAL_INDEX,""String_Node_Str"",0,_serventID.bytes(),0,false,0,false,null,null,false,true,""String_Node_Str"",0l,proxies,-1,canDoFWTransfer ? UDPConnection.VERSION : 0);
synchronized (_pushedHosts) {
  _pushedHosts.put(_serventID,new PushRequestDetails(this));
}
LOG.trace(""String_Node_Str"");
setState(PUSHING);
RouterService.getDownloadManager().sendPush(fakeRFD);
}
break;
}
}",0.9509483322432962
4306,"public void handleRead() throws IOException {
  while (true) {
    int read=0;
    while (buffer.hasRemaining() && (read=source.read(buffer)) > 0)     ;
    if (buffer.position() == 0) {
      if (read == -1)       close();
      break;
    }
    buffer.flip();
    GIVLine giv=null;
    if (BufferUtils.readLine(buffer,sb))     giv=parseLine(sb.toString());
    buffer.compact();
    if (giv != null) {
      handleGIV(socket,giv);
      break;
    }
  }
}","public void handleRead() throws IOException {
  while (true) {
    int read=0;
    while (buffer.hasRemaining() && (read=source.read(buffer)) > 0)     ;
    if (buffer.position() == 0) {
      if (read == -1)       close();
      break;
    }
    buffer.flip();
    if (giv == null) {
      if (BufferUtils.readLine(buffer,givSB))       giv=parseLine(givSB.toString());
    }
    if (giv != null && !readBlank) {
      readBlank=BufferUtils.readLine(buffer,blankSB);
      if (blankSB.length() > 0)       throw new IOException(""String_Node_Str"");
    }
    buffer.compact();
    if (readBlank) {
      handleGIV(socket,giv);
      break;
    }
  }
}",0.5406871609403255
4307,"/** 
 * Sends a push through UDP. This always returns true, because a UDP push is always sent.
 */
private boolean sendPushUDP(RemoteFileDesc file,byte[] guid){
  PushRequest pr=new PushRequest(guid,(byte)2,file.getClientGUID(),file.getIndex(),RouterService.getAddress(),RouterService.getPort(),Message.N_UDP);
  if (LOG.isInfoEnabled())   LOG.info(""String_Node_Str"" + pr);
  UDPService udpService=UDPService.instance();
  try {
    InetAddress address=InetAddress.getByName(file.getHost());
    if (NetworkUtils.isValidAddress(address) && NetworkUtils.isValidPort(file.getPort()))     udpService.send(pr,address,file.getPort());
  }
 catch (  UnknownHostException notCritical) {
  }
 finally {
    IPFilter filter=IPFilter.instance();
    Set proxies=file.getPushProxies();
    for (Iterator iter=proxies.iterator(); iter.hasNext(); ) {
      IpPort ppi=(IpPort)iter.next();
      if (filter.allow(ppi.getAddress()))       udpService.send(pr,ppi.getInetAddress(),ppi.getPort());
    }
  }
  return true;
}","/** 
 * Sends a push through UDP. This always returns true, because a UDP push is always sent.
 */
private boolean sendPushUDP(RemoteFileDesc file,byte[] guid){
  PushRequest pr=new PushRequest(guid,(byte)2,file.getClientGUID(),file.getIndex(),RouterService.getAddress(),RouterService.getPort(),Message.N_UDP);
  if (LOG.isInfoEnabled())   LOG.info(""String_Node_Str"" + pr);
  UDPService udpService=UDPService.instance();
  try {
    InetAddress address=InetAddress.getByName(file.getHost());
    if (NetworkUtils.isValidAddress(address) && NetworkUtils.isValidPort(file.getPort())) {
      udpService.send(pr,address,file.getPort());
    }
  }
 catch (  UnknownHostException notCritical) {
  }
  IPFilter filter=IPFilter.instance();
  Set proxies=file.getPushProxies();
  for (Iterator iter=proxies.iterator(); iter.hasNext(); ) {
    IpPort ppi=(IpPort)iter.next();
    if (filter.allow(ppi.getAddress())) {
      udpService.send(pr,ppi.getInetAddress(),ppi.getPort());
    }
  }
  return true;
}",0.7578632051922117
4308,"/** 
 * like allowConnection, except more strict - if this is a leaf, only allow connections whom we have told we're leafs.
 * @return whether the connection should be allowed 
 */
private boolean allowInitializedConnection(Connection c){
  if ((isShieldedLeaf() || !isSupernode()) && !c.isClientSupernodeConnection())   return false;
  return allowConnection(c.headers());
}","/** 
 * Like allowConnection, but more more strict. In addition to allowConnection, this checks to see if the connection is a leaf, and if so only allows it if we said we're it's supernode. It also makes sure that we don't have any duplicate connections to this particular host.  (Duplicate connections are checked by IP address and 'listen port', if a listen port was specified.)
 * @return whether the connection should be allowed 
 */
private boolean allowInitializedConnection(ManagedConnection c){
  if ((isShieldedLeaf() || !isSupernode()) && !c.isClientSupernodeConnection())   return false;
  List connections=getConnections();
  int listenPort=c.getListeningPort();
  String addr=c.getAddress();
  for (int i=0; i < connections.size(); i++) {
    ManagedConnection mc=(ManagedConnection)connections.get(i);
    if (mc == c)     continue;
    if (addr.equals(mc.getAddress())) {
      int mcLP=mc.getListeningPort();
      if (listenPort == -1 || mcLP == -1 || mcLP == listenPort)       return false;
    }
  }
  return allowConnection(c.headers()).isAcceptable();
}",0.3961352657004831
4309,"/** 
 * Completes the process of initializing an externally generated connection.
 * @param c
 * @throws IOException
 */
private void completeInitializeExternallyGeneratedConnection(ManagedConnection c) throws IOException {
  processConnectionHeaders(c);
  if (!c.isOutgoing() && !allowConnection(c)) {
    throw new IOException(""String_Node_Str"");
  }
  if (!c.isOutgoing()) {
synchronized (this) {
      connectionInitializingIncoming(c);
      adjustConnectionFetchers();
    }
    RouterService.getCallback().connectionInitializing(c);
  }
  completeConnectionInitialization(c,false);
}","/** 
 * Completes the process of initializing an externally generated connection.
 * @param c
 * @throws IOException
 * @return true if the connection should continue, false if it was closed
 */
private boolean completeInitializeExternallyGeneratedConnection(ManagedConnection c) throws IOException {
  processConnectionHeaders(c);
  if (!c.isOutgoing() && !allowConnection(c).isAcceptable()) {
    throw new IOException(""String_Node_Str"");
  }
  if (!c.isOutgoing()) {
synchronized (this) {
      connectionInitializingIncoming(c);
      adjustConnectionFetchers();
    }
    RouterService.getCallback().connectionInitializing(c);
  }
  return completeConnectionInitialization(c,false);
}",0.9163408913213448
4310,"/** 
 * Performs the steps necessary to complete connection initialization.
 * @param mc the <tt>ManagedConnection</tt> to finish initializing
 * @param fetched Specifies whether or not this connection is was fetched by a connection fetcher. If so, thisremoves that connection from the list of fetched connections being initialized, keeping the connection fetcher data in sync
 */
private void completeConnectionInitialization(ManagedConnection mc,boolean fetched){
synchronized (this) {
    if (fetched) {
      _initializingFetchedConnections.remove(mc);
    }
    boolean connectionOpen=connectionInitialized(mc);
    if (connectionOpen) {
      RouterService.getCallback().connectionInitialized(mc);
      setPreferredConnections();
    }
  }
}","/** 
 * Performs the steps necessary to complete connection initialization.
 * @param mc the <tt>ManagedConnection</tt> to finish initializing
 * @param fetched Specifies whether or not this connection is was fetched by a connection fetcher. If so, thisremoves that connection from the list of fetched connections being initialized, keeping the connection fetcher data in sync
 * @return true if the connection should continue, false if it was closed
 */
private boolean completeConnectionInitialization(ManagedConnection mc,boolean fetched){
synchronized (this) {
    if (fetched) {
      _initializingFetchedConnections.remove(mc);
    }
    boolean connectionOpen=connectionInitialized(mc);
    if (connectionOpen) {
      RouterService.getCallback().connectionInitialized(mc);
      setPreferredConnections();
    }
    return connectionOpen;
  }
}",0.93
4311,"/** 
 * Callback that Sockets.connect worked. 
 */
public void handleConnect(){
  completeConnectionInitialization(connection,true);
  processConnectionHeaders(connection);
  _lastSuccessfulConnect=System.currentTimeMillis();
  _catcher.doneWithConnect(endpoint,true);
  if (_pref)   _needPref=false;
  try {
    startConnection(connection);
  }
 catch (  IOException ignored) {
  }
}","/** 
 * Callback that handshaking has succeeded and we're all connected and ready. 
 */
public void handleConnect(){
  boolean stillOpen=completeConnectionInitialization(connection,true);
  processConnectionHeaders(connection);
  _lastSuccessfulConnect=System.currentTimeMillis();
  _catcher.doneWithConnect(endpoint,true);
  if (_pref)   _needPref=false;
  try {
    if (stillOpen)     startConnection(connection);
  }
 catch (  IOException ignored) {
  }
}",0.8669833729216152
4312,"/** 
 * Checks if the connection received can be accepted, based upon the type of connection (e.g. client, ultrapeer, temporary etc).
 * @param c The connection we received, for which totest if we have incoming slot.
 * @return true, if we have incoming slot for the connection received,false otherwise
 */
public boolean allowConnectionAsLeaf(HandshakeResponse hr){
  return allowConnection(hr,true);
}","/** 
 * Checks if the connection received can be accepted, based upon the type of connection (e.g. client, ultrapeer, temporary etc).
 * @param c The connection we received, for which totest if we have incoming slot.
 * @return true, if we have incoming slot for the connection received,false otherwise
 */
public HandshakeStatus allowConnectionAsLeaf(HandshakeResponse hr){
  return allowConnection(hr,true);
}",0.972972972972973
4313,"/** 
 * Returns true if this has slots for an incoming connection, <b>without accounting for this' ultrapeer capabilities</b>.  More specifically: <ul> <li>if ultrapeerHeader==null, returns true if this has space for an unrouted old-style connection. <li>if ultrapeerHeader.equals(""true""), returns true if this has slots for a leaf connection. <li>if ultrapeerHeader.equals(""false""), returns true if this has slots for an ultrapeer connection. </ul> <tt>useragentHeader</tt> is used to prefer LimeWire and certain trusted vendors.  <tt>outgoing</tt> is currently unused, but may be used to prefer incoming or outgoing connections in the forward.
 * @param outgoing true if this is an outgoing connection; true if incoming
 * @param ultrapeerHeader the value of the X-Ultrapeer header, or nullif it was not written
 * @param useragentHeader the value of the User-Agent header, or null ifit was not written
 * @return true if a connection of the given type is allowed
 */
public boolean allowConnection(HandshakeResponse hr,boolean leaf){
  if (!ConnectionSettings.PREFERENCING_ACTIVE.getValue())   return true;
  if (!hr.isLeaf() && !hr.isUltrapeer())   return false;
  int limeAttempts=ConnectionSettings.LIME_ATTEMPTS.getValue();
  if (!ConnectionSettings.ALLOW_WHILE_DISCONNECTED.getValue() && _preferredConnections <= 0) {
    return false;
  }
 else   if (isShieldedLeaf() || !isSupernode()) {
    if (!hr.isUltrapeer()) {
      return false;
    }
    if (!hr.isGoodUltrapeer() || (_connectionAttempts < limeAttempts && !hr.isLimeWire())) {
      return false;
    }
 else     if (_shieldedConnections < _preferredConnections) {
      if (checkLocale(hr.getLocalePref()))       _needPref=false;
      if (isIdle()) {
        return hr.isLimeWire();
      }
      return true;
    }
 else {
      if (_needPref && checkLocale(hr.getLocalePref())) {
        return true;
      }
      return false;
    }
  }
 else   if (hr.isLeaf() || leaf) {
    if (isShieldedLeaf() || !isSupernode()) {
      return false;
    }
    if (!allowUltrapeer2LeafConnection(hr)) {
      return false;
    }
    int leaves=getNumInitializedClientConnections();
    int nonLimeWireLeaves=_nonLimeWireLeaves;
    if (!hr.isLimeWire()) {
      if (leaves < UltrapeerSettings.MAX_LEAVES.getValue() && nonLimeWireLeaves < RESERVED_NON_LIMEWIRE_LEAVES) {
        return true;
      }
    }
    if (!hr.isGoodLeaf()) {
      return false;
    }
    return (leaves + Math.max(0,RESERVED_NON_LIMEWIRE_LEAVES - nonLimeWireLeaves)) < UltrapeerSettings.MAX_LEAVES.getValue();
  }
 else   if (hr.isGoodUltrapeer()) {
    int peers=getNumInitializedConnections();
    int nonLimeWirePeers=_nonLimeWirePeers;
    int locale_num=0;
    if (!allowUltrapeer2UltrapeerConnection(hr)) {
      return false;
    }
    if (ConnectionSettings.USE_LOCALE_PREF.getValue()) {
      if (checkLocale(hr.getLocalePref()) && _localeMatchingPeers < ConnectionSettings.NUM_LOCALE_PREF.getValue()) {
        return true;
      }
      locale_num=getNumLimeWireLocalePrefSlots();
    }
    if (!hr.isLimeWire()) {
      double nonLimeRatio=((double)nonLimeWirePeers) / _preferredConnections;
      if (nonLimeRatio < ConnectionSettings.MIN_NON_LIME_PEERS.getValue())       return true;
      return (nonLimeRatio < ConnectionSettings.MAX_NON_LIME_PEERS.getValue());
    }
 else {
      int minNonLime=(int)(ConnectionSettings.MIN_NON_LIME_PEERS.getValue() * _preferredConnections);
      return (peers + Math.max(0,minNonLime - nonLimeWirePeers) + locale_num) < _preferredConnections;
    }
  }
  return false;
}","/** 
 * Returns true if this has slots for an incoming connection, <b>without accounting for this' ultrapeer capabilities</b>.  More specifically: <ul> <li>if ultrapeerHeader==null, returns true if this has space for an unrouted old-style connection. <li>if ultrapeerHeader.equals(""true""), returns true if this has slots for a leaf connection. <li>if ultrapeerHeader.equals(""false""), returns true if this has slots for an ultrapeer connection. </ul> <tt>useragentHeader</tt> is used to prefer LimeWire and certain trusted vendors.  <tt>outgoing</tt> is currently unused, but may be used to prefer incoming or outgoing connections in the forward.
 * @param outgoing true if this is an outgoing connection; true if incoming
 * @param ultrapeerHeader the value of the X-Ultrapeer header, or nullif it was not written
 * @param useragentHeader the value of the User-Agent header, or null ifit was not written
 * @return true if a connection of the given type is allowed
 */
public HandshakeStatus allowConnection(HandshakeResponse hr,boolean leaf){
  if (!ConnectionSettings.PREFERENCING_ACTIVE.getValue())   return HandshakeStatus.OK;
  if (!hr.isLeaf() && !hr.isUltrapeer())   return HandshakeStatus.NO_X_ULTRAPEER;
  int limeAttempts=ConnectionSettings.LIME_ATTEMPTS.getValue();
  if (!ConnectionSettings.ALLOW_WHILE_DISCONNECTED.getValue() && _preferredConnections <= 0) {
    return HandshakeStatus.DISCONNECTED;
  }
 else   if (isShieldedLeaf() || !isSupernode()) {
    if (!hr.isUltrapeer()) {
      return HandshakeStatus.WE_ARE_LEAVES;
    }
    if (!hr.isGoodUltrapeer()) {
      return HandshakeStatus.NOT_GOOD_UP;
    }
 else     if (_connectionAttempts < limeAttempts && !hr.isLimeWire()) {
      return HandshakeStatus.STARTING_LIMEWIRE;
    }
 else     if (_shieldedConnections < _preferredConnections) {
      if (checkLocale(hr.getLocalePref()))       _needPref=false;
      if (isIdle()) {
        if (hr.isLimeWire())         return HandshakeStatus.OK;
 else         return HandshakeStatus.IDLE_LIMEWIRE;
      }
      return HandshakeStatus.OK;
    }
 else {
      if (_needPref && checkLocale(hr.getLocalePref())) {
        _needPref=false;
        return HandshakeStatus.OK;
      }
      System.out.println(""String_Node_Str"" + _shieldedConnections + ""String_Node_Str""+ _preferredConnections);
      return HandshakeStatus.TOO_MANY_UPS;
    }
  }
 else   if (hr.isLeaf() || leaf) {
    if (isShieldedLeaf() || !isSupernode()) {
      return HandshakeStatus.WE_ARE_LEAVES;
    }
    if (!allowUltrapeer2LeafConnection(hr)) {
      return HandshakeStatus.NOT_ALLOWED_LEAF;
    }
    int leaves=getNumInitializedClientConnections();
    int nonLimeWireLeaves=_nonLimeWireLeaves;
    if (!hr.isLimeWire()) {
      if (leaves < UltrapeerSettings.MAX_LEAVES.getValue() && nonLimeWireLeaves < RESERVED_NON_LIMEWIRE_LEAVES) {
        return HandshakeStatus.OK;
      }
    }
    if (!hr.isGoodLeaf()) {
      return HandshakeStatus.NOT_GOOD_LEAF;
    }
    if ((leaves + Math.max(0,RESERVED_NON_LIMEWIRE_LEAVES - nonLimeWireLeaves)) < UltrapeerSettings.MAX_LEAVES.getValue()) {
      return HandshakeStatus.OK;
    }
 else {
      return HandshakeStatus.TOO_MANY_LEAF;
    }
  }
 else   if (hr.isUltrapeer()) {
    int peers=getNumInitializedConnections();
    int nonLimeWirePeers=_nonLimeWirePeers;
    int locale_num=0;
    if (!allowUltrapeer2UltrapeerConnection(hr)) {
      return HandshakeStatus.NOT_ALLOWED_UP;
    }
    if (ConnectionSettings.USE_LOCALE_PREF.getValue()) {
      if (checkLocale(hr.getLocalePref()) && _localeMatchingPeers < ConnectionSettings.NUM_LOCALE_PREF.getValue()) {
        return HandshakeStatus.OK;
      }
      locale_num=getNumLimeWireLocalePrefSlots();
    }
    if (!hr.isLimeWire()) {
      double nonLimeRatio=((double)nonLimeWirePeers) / _preferredConnections;
      if (nonLimeRatio < ConnectionSettings.MIN_NON_LIME_PEERS.getValue())       return HandshakeStatus.OK;
      if (!hr.isGoodUltrapeer()) {
        return HandshakeStatus.NOT_GOOD_UP;
      }
 else       if (nonLimeRatio < ConnectionSettings.MAX_NON_LIME_PEERS.getValue()) {
        return HandshakeStatus.OK;
      }
 else {
        return HandshakeStatus.NON_LIME_RATIO;
      }
    }
 else {
      int minNonLime=(int)(ConnectionSettings.MIN_NON_LIME_PEERS.getValue() * _preferredConnections);
      if (!hr.isGoodUltrapeer()) {
        return HandshakeStatus.NOT_GOOD_UP;
      }
 else       if ((peers + Math.max(0,minNonLime - nonLimeWirePeers) + locale_num) < _preferredConnections) {
        return HandshakeStatus.OK;
      }
 else {
        return HandshakeStatus.NO_LIME_SLOTS;
      }
    }
  }
  return HandshakeStatus.UNKNOWN;
}",0.7206812652068126
4314,"/** 
 * Creates a new <tt>HandshakeResponse</tt> instance that rejects an  outgoing leaf connection.  This occurs when we, as a leaf, reject a  connection on the third stage of the handshake.
 * @return a new <tt>HandshakeResponse</tt> instance rejecting the connection and with no extra headers
 */
static HandshakeResponse createLeafRejectOutgoingResponse(){
  return new HandshakeResponse(HandshakeResponse.SLOTS_FULL,HandshakeResponse.SHIELDED_MESSAGE);
}","/** 
 * Creates a new <tt>HandshakeResponse</tt> instance that rejects an  outgoing leaf connection.  This occurs when we, as a leaf, reject a  connection on the third stage of the handshake.
 * @return a new <tt>HandshakeResponse</tt> instance rejecting the connection and with no extra headers
 */
static HandshakeResponse createLeafRejectOutgoingResponse(HandshakeStatus status){
  return new HandshakeResponse(HandshakeResponse.SLOTS_FULL,status.getMessage());
}",0.9232432432432433
4315,"/** 
 * Creates a new <tt>HandshakeResponse</tt> instance that rejects the potential connection.  The returned <tt>HandshakeResponse</tt> DOES NOT include the X-Try-Ultrapeers header because this is an outgoing connection, and we should not send host data that the remote client does not request.
 * @param headers the <tt>Properties</tt> instance containing the headersto send to the node we're rejecting
 */
static HandshakeResponse createRejectOutgoingResponse(){
  return new HandshakeResponse(HandshakeResponse.SLOTS_FULL,HandshakeResponse.SLOTS_FULL_MESSAGE,new Properties());
}","/** 
 * Creates a new <tt>HandshakeResponse</tt> instance that rejects the potential connection.  The returned <tt>HandshakeResponse</tt> DOES NOT include the X-Try-Ultrapeers header because this is an outgoing connection, and we should not send host data that the remote client does not request.
 * @param headers the <tt>Properties</tt> instance containing the headersto send to the node we're rejecting
 */
static HandshakeResponse createRejectOutgoingResponse(HandshakeStatus status){
  return new HandshakeResponse(HandshakeResponse.SLOTS_FULL,status.getMessage(),new Properties());
}",0.9377664109121908
4316,"/** 
 * Creates a HandshakeResponse with the desired status code, status message,  and headers to respond with.
 * @param code the response code to use.
 * @param message the response message to use.
 * @param headers the headers to use in the response.
 */
HandshakeResponse(int code,String message,Properties headers){
  STATUS_CODE=code;
  STATUS_MESSAGE=message;
  HEADERS=headers;
  DEGREE=extractIntHeaderValue(HEADERS,HeaderNames.X_DEGREE,6);
  HIGH_DEGREE=getNumIntraUltrapeerConnections() >= 15;
  ULTRAPEER_QRP=isVersionOrHigher(HEADERS,HeaderNames.X_ULTRAPEER_QUERY_ROUTING,0.1F);
  MAX_TTL=extractByteHeaderValue(HEADERS,HeaderNames.X_MAX_TTL,(byte)4);
  DYNAMIC_QUERY=isVersionOrHigher(HEADERS,HeaderNames.X_DYNAMIC_QUERY,0.1F);
  PROBE_QUERIES=isVersionOrHigher(HEADERS,HeaderNames.X_PROBE_QUERIES,0.1F);
  NO_REQUERYING=isFalseValue(HEADERS,HeaderNames.X_REQUERIES);
  IS_LIMEWIRE=extractStringHeaderValue(headers,HeaderNames.USER_AGENT).toLowerCase().startsWith(""String_Node_Str"");
  GOOD_ULTRAPEER=isHighDegreeConnection() && isUltrapeerQueryRoutingConnection() && (getMaxTTL() < 5)&& isDynamicQueryConnection();
  GOOD_LEAF=GOOD_ULTRAPEER && (IS_LIMEWIRE || NO_REQUERYING);
  ULTRAPEER=isTrueValue(HEADERS,HeaderNames.X_ULTRAPEER);
  LEAF=isFalseValue(HEADERS,HeaderNames.X_ULTRAPEER);
  DEFLATE_ENCODED=isStringValue(HEADERS,HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  PONG_CACHING=isVersionOrHigher(headers,HeaderNames.X_PONG_CACHING,0.1F);
  GUESS_CAPABLE=isVersionOrHigher(headers,HeaderNames.X_GUESS,0.1F);
  IS_CRAWLER=isVersionOrHigher(headers,HeaderNames.CRAWLER,0.1F);
  IS_OLD_LIMEWIRE=IS_LIMEWIRE && oldVersion(extractStringHeaderValue(headers,HeaderNames.USER_AGENT));
  String loc=extractStringHeaderValue(headers,HeaderNames.X_LOCALE_PREF);
  LOCALE_PREF=(loc.equals(""String_Node_Str"")) ? ApplicationSettings.DEFAULT_LOCALE.getValue() : loc;
}","/** 
 * Creates a HandshakeResponse with the desired status code, status message,  and headers to respond with.
 * @param code the response code to use.
 * @param message the response message to use.
 * @param headers the headers to use in the response.
 */
HandshakeResponse(int code,String message,Properties headers){
  STATUS_CODE=code;
  STATUS_MESSAGE=message;
  HEADERS=headers;
  DEGREE=extractIntHeaderValue(HEADERS,HeaderNames.X_DEGREE,6);
  HIGH_DEGREE=getNumIntraUltrapeerConnections() >= 15;
  ULTRAPEER_QRP=isVersionOrHigher(HEADERS,HeaderNames.X_ULTRAPEER_QUERY_ROUTING,0.1F);
  MAX_TTL=extractByteHeaderValue(HEADERS,HeaderNames.X_MAX_TTL,(byte)4);
  DYNAMIC_QUERY=isVersionOrHigher(HEADERS,HeaderNames.X_DYNAMIC_QUERY,0.1F);
  PROBE_QUERIES=isVersionOrHigher(HEADERS,HeaderNames.X_PROBE_QUERIES,0.1F);
  NO_REQUERYING=isFalseValue(HEADERS,HeaderNames.X_REQUERIES);
  IS_LIMEWIRE=extractStringHeaderValue(headers,HeaderNames.USER_AGENT).toLowerCase().startsWith(""String_Node_Str"");
  GOOD_ULTRAPEER=isHighDegreeConnection() && isUltrapeerQueryRoutingConnection() && (getMaxTTL() < 5)&& isDynamicQueryConnection();
  GOOD_LEAF=GOOD_ULTRAPEER && (IS_LIMEWIRE || NO_REQUERYING);
  ULTRAPEER=isTrueValue(HEADERS,HeaderNames.X_ULTRAPEER);
  LEAF=isFalseValue(HEADERS,HeaderNames.X_ULTRAPEER);
  DEFLATE_ENCODED=isStringValue(HEADERS,HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  PONG_CACHING=isVersionOrHigher(headers,HeaderNames.X_PONG_CACHING,0.1F);
  GUESS_CAPABLE=isVersionOrHigher(headers,HeaderNames.X_GUESS,0.1F);
  IS_CRAWLER=isVersionOrHigher(headers,HeaderNames.CRAWLER,0.1F);
  IS_OLD_LIMEWIRE=IS_LIMEWIRE && oldVersion(extractStringHeaderValue(headers,HeaderNames.USER_AGENT));
  String loc=extractStringHeaderValue(headers,HeaderNames.X_LOCALE_PREF);
  LOCALE_PREF=(loc.equals(""String_Node_Str"")) ? ApplicationSettings.DEFAULT_LOCALE.getValue() : loc;
  LISTEN_PORT=extractIntHeaderValueAfter(headers,HeaderNames.LISTEN_IP,""String_Node_Str"",-1);
}",0.9757356737222508
4317,"/** 
 * Creates a new <tt>HandshakeResponse</tt> instance that rejects the potential connection to a leaf.  We add hosts that we know about with free connection slots to the X-Try-Ultrapeers header.
 * @param headers the <tt>Properties</tt> instance containing the headersto send to the node we're rejecting
 * @param hr the <tt>HandshakeResponse</tt> containing the headers of theremote host
 * @return a new <tt>HandshakeResponse</tt> instance rejecting the connection and with the specified connection headers
 */
static HandshakeResponse createLeafRejectIncomingResponse(HandshakeResponse hr){
  return new HandshakeResponse(HandshakeResponse.SLOTS_FULL,HandshakeResponse.SHIELDED_MESSAGE,addXTryHeader(hr,new Properties()));
}","/** 
 * Creates a new <tt>HandshakeResponse</tt> instance that rejects the potential connection to a leaf.  We add hosts that we know about with free connection slots to the X-Try-Ultrapeers header.
 * @param headers the <tt>Properties</tt> instance containing the headersto send to the node we're rejecting
 * @param hr the <tt>HandshakeResponse</tt> containing the headers of theremote host
 * @return a new <tt>HandshakeResponse</tt> instance rejecting the connection and with the specified connection headers
 */
static HandshakeResponse createLeafRejectIncomingResponse(HandshakeResponse hr,HandshakeStatus status){
  return new HandshakeResponse(HandshakeResponse.SLOTS_FULL,status.getMessage(),addXTryHeader(hr,new Properties()));
}",0.9510204081632652
4318,"/** 
 * Creates a new <tt>HandshakeResponse</tt> instance that rejects the potential connection.  This includes the X-Try-Ultrapeers header to tell the remote host about other nodes to connect to.  We return the hosts we most recently knew to have free leaf or ultrapeer connection slots.
 * @param hr the <tt>HandshakeResponse</tt> containing the connectionheaders of the connecting host
 * @return a <tt>HandshakeResponse</tt> with the appropriate response headers
 */
static HandshakeResponse createUltrapeerRejectIncomingResponse(HandshakeResponse hr){
  return new HandshakeResponse(HandshakeResponse.SLOTS_FULL,HandshakeResponse.SLOTS_FULL_MESSAGE,addXTryHeader(hr,new Properties()));
}","/** 
 * Creates a new <tt>HandshakeResponse</tt> instance that rejects the potential connection.  This includes the X-Try-Ultrapeers header to tell the remote host about other nodes to connect to.  We return the hosts we most recently knew to have free leaf or ultrapeer connection slots.
 * @param hr the <tt>HandshakeResponse</tt> containing the connectionheaders of the connecting host
 * @return a <tt>HandshakeResponse</tt> with the appropriate response headers
 */
static HandshakeResponse createUltrapeerRejectIncomingResponse(HandshakeResponse hr,HandshakeStatus status){
  return new HandshakeResponse(HandshakeResponse.SLOTS_FULL,status.getMessage(),addXTryHeader(hr,new Properties()));
}",0.9467625899280576
4319,"/** 
 * Responds to an incoming connection handshake.
 * @return the <tt>HandshakeResponse</tt> with the handshake headers to send in response to the connection attempt
 */
protected HandshakeResponse respondToIncoming(HandshakeResponse hr){
  if (hr.isCrawler()) {
    HandshakingStat.INCOMING_CRAWLER.incrementStat();
    return HandshakeResponse.createCrawlerResponse();
  }
  if (!hr.isUltrapeer()) {
    HandshakingStat.LEAF_INCOMING_REJECT.incrementStat();
    return HandshakeResponse.createLeafRejectOutgoingResponse();
  }
  Properties ret=new LeafHeaders(getRemoteIP());
  if (!_manager.allowConnection(hr)) {
    HandshakingStat.LEAF_INCOMING_REJECT.incrementStat();
    return HandshakeResponse.createLeafRejectIncomingResponse(hr);
  }
  if (hr.isDeflateAccepted()) {
    ret.put(HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  }
  HandshakingStat.LEAF_INCOMING_ACCEPT.incrementStat();
  return HandshakeResponse.createAcceptIncomingResponse(hr,ret);
}","/** 
 * Responds to an incoming connection handshake.
 * @return the <tt>HandshakeResponse</tt> with the handshake headers to send in response to the connection attempt
 */
protected HandshakeResponse respondToIncoming(HandshakeResponse hr){
  if (hr.isCrawler()) {
    HandshakingStat.INCOMING_CRAWLER.incrementStat();
    return HandshakeResponse.createCrawlerResponse();
  }
  if (!hr.isUltrapeer()) {
    HandshakingStat.LEAF_INCOMING_REJECT.incrementStat();
    return HandshakeResponse.createLeafRejectOutgoingResponse(HandshakeStatus.WE_ARE_LEAVES);
  }
  Properties ret=new LeafHeaders(getRemoteIP());
  HandshakeStatus status=_manager.allowConnection(hr);
  if (!status.isAcceptable()) {
    HandshakingStat.LEAF_INCOMING_REJECT.incrementStat();
    return HandshakeResponse.createLeafRejectIncomingResponse(hr,status);
  }
  if (hr.isDeflateAccepted()) {
    ret.put(HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  }
  HandshakingStat.LEAF_INCOMING_ACCEPT.incrementStat();
  return HandshakeResponse.createAcceptIncomingResponse(hr,ret);
}",0.9538310412573674
4320,"/** 
 * Responds to an outgoing connection handshake.
 * @return the <tt>HandshakeResponse</tt> with the handshake headers to send in response to the connection attempt
 */
protected HandshakeResponse respondToOutgoing(HandshakeResponse response){
  if (!response.isUltrapeer()) {
    HandshakingStat.LEAF_OUTGOING_REJECT_LEAF.incrementStat();
    return HandshakeResponse.createLeafRejectOutgoingResponse();
  }
  if (getLocalePreferencing()) {
    if (!ApplicationSettings.LANGUAGE.getValue().equals(response.getLocalePref())) {
      return HandshakeResponse.createLeafRejectLocaleOutgoingResponse();
    }
  }
  if (!_manager.allowConnection(response)) {
    HandshakingStat.LEAF_OUTGOING_REJECT_OLD_UP.incrementStat();
    return HandshakeResponse.createLeafRejectOutgoingResponse();
  }
  Properties ret=new Properties();
  if (response.isDeflateAccepted()) {
    ret.put(HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  }
  HandshakingStat.LEAF_OUTGOING_ACCEPT.incrementStat();
  return HandshakeResponse.createAcceptOutgoingResponse(ret);
}","/** 
 * Responds to an outgoing connection handshake.
 * @return the <tt>HandshakeResponse</tt> with the handshake headers to send in response to the connection attempt
 */
protected HandshakeResponse respondToOutgoing(HandshakeResponse response){
  if (!response.isUltrapeer()) {
    HandshakingStat.LEAF_OUTGOING_REJECT_LEAF.incrementStat();
    return HandshakeResponse.createLeafRejectOutgoingResponse(HandshakeStatus.WE_ARE_LEAVES);
  }
  if (getLocalePreferencing()) {
    if (!ApplicationSettings.LANGUAGE.getValue().equals(response.getLocalePref())) {
      return HandshakeResponse.createLeafRejectLocaleOutgoingResponse();
    }
  }
  HandshakeStatus status=_manager.allowConnection(response);
  if (!status.isAcceptable()) {
    HandshakingStat.LEAF_OUTGOING_REJECT_OLD_UP.incrementStat();
    return HandshakeResponse.createLeafRejectOutgoingResponse(status);
  }
  Properties ret=new Properties();
  if (response.isDeflateAccepted()) {
    ret.put(HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  }
  HandshakingStat.LEAF_OUTGOING_ACCEPT.incrementStat();
  return HandshakeResponse.createAcceptOutgoingResponse(ret);
}",0.9577080491132332
4321,"/** 
 * Returns true if this incoming connections should be rejected with a 503. 
 */
private boolean reject(HandshakeResponse response,Properties ret){
  boolean allowedAsLeaf=_manager.allowConnectionAsLeaf(response);
  if (response.isLeaf()) {
    if (!allowedAsLeaf)     HandshakingStat.UP_INCOMING_REJECT_LEAF.incrementStat();
 else     HandshakingStat.UP_INCOMING_ACCEPT_LEAF.incrementStat();
    return !allowedAsLeaf;
  }
  boolean supernodeNeeded=_manager.supernodeNeeded();
  if (allowedAsLeaf && !supernodeNeeded) {
    HandshakingStat.UP_INCOMING_GUIDED.incrementStat();
    ret.put(HeaderNames.X_ULTRAPEER_NEEDED,Boolean.FALSE.toString());
    return false;
  }
  boolean allowedAsUltrapeer=_manager.allowConnection(response);
  if (allowedAsUltrapeer) {
    HandshakingStat.UP_INCOMING_ACCEPT_UP.incrementStat();
    ret.put(HeaderNames.X_ULTRAPEER_NEEDED,Boolean.TRUE.toString());
    return false;
  }
  if (!allowedAsLeaf)   HandshakingStat.UP_INCOMING_REJECT_NO_ROOM_LEAF.incrementStat();
 else   HandshakingStat.UP_INCOMING_REJECT_NO_ROOM_UP.incrementStat();
  return true;
}","/** 
 * Returns a HandshakeStatus to be used for rejecting. 
 */
private HandshakeStatus reject(HandshakeResponse response,Properties ret){
  HandshakeStatus leafStatus=_manager.allowConnectionAsLeaf(response);
  boolean allowedAsLeaf=leafStatus.isAcceptable();
  if (response.isLeaf()) {
    if (!allowedAsLeaf)     HandshakingStat.UP_INCOMING_REJECT_LEAF.incrementStat();
 else     HandshakingStat.UP_INCOMING_ACCEPT_LEAF.incrementStat();
    return leafStatus;
  }
  boolean supernodeNeeded=_manager.supernodeNeeded();
  if (allowedAsLeaf && !supernodeNeeded) {
    HandshakingStat.UP_INCOMING_GUIDED.incrementStat();
    ret.put(HeaderNames.X_ULTRAPEER_NEEDED,Boolean.FALSE.toString());
    return HandshakeStatus.OK;
  }
  HandshakeStatus upStatus=_manager.allowConnection(response);
  boolean allowedAsUltrapeer=upStatus.isAcceptable();
  if (allowedAsUltrapeer) {
    HandshakingStat.UP_INCOMING_ACCEPT_UP.incrementStat();
    ret.put(HeaderNames.X_ULTRAPEER_NEEDED,Boolean.TRUE.toString());
    return upStatus;
  }
  if (!allowedAsLeaf) {
    HandshakingStat.UP_INCOMING_REJECT_NO_ROOM_LEAF.incrementStat();
    return leafStatus;
  }
 else {
    HandshakingStat.UP_INCOMING_REJECT_NO_ROOM_UP.incrementStat();
    return upStatus;
  }
}",0.7818648417450813
4322,"/** 
 * Respond to an incoming connection request.
 * @param response the headers read from the connection
 */
protected HandshakeResponse respondToIncoming(HandshakeResponse response){
  if (response.isCrawler()) {
    HandshakingStat.INCOMING_CRAWLER.incrementStat();
    return HandshakeResponse.createCrawlerResponse();
  }
  Properties ret=new UltrapeerHeaders(getRemoteIP());
  ret.put(HeaderNames.LISTEN_IP,NetworkUtils.ip2string(RouterService.getAddress()) + ""String_Node_Str"" + RouterService.getPort());
  if (reject(response,ret)) {
    return HandshakeResponse.createUltrapeerRejectIncomingResponse(response);
  }
  if (response.isDeflateAccepted()) {
    ret.put(HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  }
  return HandshakeResponse.createAcceptIncomingResponse(response,ret);
}","/** 
 * Respond to an incoming connection request.
 * @param response the headers read from the connection
 */
protected HandshakeResponse respondToIncoming(HandshakeResponse response){
  if (response.isCrawler()) {
    HandshakingStat.INCOMING_CRAWLER.incrementStat();
    return HandshakeResponse.createCrawlerResponse();
  }
  Properties ret=new UltrapeerHeaders(getRemoteIP());
  ret.put(HeaderNames.LISTEN_IP,NetworkUtils.ip2string(RouterService.getAddress()) + ""String_Node_Str"" + RouterService.getPort());
  HandshakeStatus status=reject(response,ret);
  if (!status.isAcceptable()) {
    return HandshakeResponse.createUltrapeerRejectIncomingResponse(response,status);
  }
  if (response.isDeflateAccepted()) {
    ret.put(HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  }
  return HandshakeResponse.createAcceptIncomingResponse(response,ret);
}",0.94377990430622
4323,"/** 
 * Respond to an outgoing connection request.
 * @param response the headers read from the connection
 */
protected HandshakeResponse respondToOutgoing(HandshakeResponse response){
  if (!_manager.allowConnection(response)) {
    HandshakingStat.UP_OUTGOING_REJECT_FULL.incrementStat();
    return HandshakeResponse.createRejectOutgoingResponse();
  }
  Properties ret=new Properties();
  if (response.hasLeafGuidance()) {
    if (_manager.allowLeafDemotion() && response.isGoodUltrapeer()) {
      HandshakingStat.UP_OUTGOING_GUIDANCE_FOLLOWED.incrementStat();
      ret.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
    }
 else {
      HandshakingStat.UP_OUTGOING_GUIDANCE_IGNORED.incrementStat();
    }
  }
 else   HandshakingStat.UP_OUTGOING_ACCEPT.incrementStat();
  if (response.isDeflateAccepted()) {
    ret.put(HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  }
  return HandshakeResponse.createAcceptOutgoingResponse(ret);
}","/** 
 * Respond to an outgoing connection request.
 * @param response the headers read from the connection
 */
protected HandshakeResponse respondToOutgoing(HandshakeResponse response){
  HandshakeStatus status=_manager.allowConnection(response);
  if (!status.isAcceptable()) {
    HandshakingStat.UP_OUTGOING_REJECT_FULL.incrementStat();
    return HandshakeResponse.createRejectOutgoingResponse(status);
  }
  Properties ret=new Properties();
  if (response.hasLeafGuidance()) {
    if (_manager.allowLeafDemotion() && response.isGoodUltrapeer()) {
      HandshakingStat.UP_OUTGOING_GUIDANCE_FOLLOWED.incrementStat();
      ret.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
    }
 else {
      HandshakingStat.UP_OUTGOING_GUIDANCE_IGNORED.incrementStat();
    }
  }
 else   HandshakingStat.UP_OUTGOING_ACCEPT.incrementStat();
  if (response.isDeflateAccepted()) {
    ret.put(HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  }
  return HandshakeResponse.createAcceptOutgoingResponse(ret);
}",0.967280163599182
4324,"/** 
 * Test to make sure that Ultrapeer headers are created correctly.
 */
public void testUltrapeerHeaders() throws Exception {
  ConnectionSettings.ACCEPT_DEFLATE.setValue(true);
  Properties headers=new Properties();
  headers.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
  HandshakeResponse client=HandshakeResponse.createResponse(headers);
  HandshakeResponse hr=HandshakeResponse.createUltrapeerRejectIncomingResponse(client);
  runRejectHeadersTest(hr);
  hr=HandshakeResponse.createAcceptIncomingResponse(HandshakeResponse.createEmptyResponse(),new UltrapeerHeaders(""String_Node_Str""));
  runUltrapeerHeadersTest(hr);
  headers=new Properties();
  headers.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
  client=HandshakeResponse.createResponse(headers);
  ConnectionSettings.ACCEPT_DEFLATE.setValue(false);
  hr=HandshakeResponse.createUltrapeerRejectIncomingResponse(client);
  runRejectHeadersTest(hr);
  hr=HandshakeResponse.createAcceptIncomingResponse(HandshakeResponse.createEmptyResponse(),new UltrapeerHeaders(""String_Node_Str""));
  runUltrapeerHeadersTest(hr);
}","/** 
 * Test to make sure that Ultrapeer headers are created correctly.
 */
public void testUltrapeerHeaders() throws Exception {
  ConnectionSettings.ACCEPT_DEFLATE.setValue(true);
  Properties headers=new Properties();
  headers.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
  HandshakeResponse client=HandshakeResponse.createResponse(headers);
  HandshakeResponse hr=HandshakeResponse.createUltrapeerRejectIncomingResponse(client,HandshakeStatus.DISCONNECTED);
  runRejectHeadersTest(hr);
  hr=HandshakeResponse.createAcceptIncomingResponse(HandshakeResponse.createEmptyResponse(),new UltrapeerHeaders(""String_Node_Str""));
  runUltrapeerHeadersTest(hr);
  headers=new Properties();
  headers.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
  client=HandshakeResponse.createResponse(headers);
  ConnectionSettings.ACCEPT_DEFLATE.setValue(false);
  hr=HandshakeResponse.createUltrapeerRejectIncomingResponse(client,HandshakeStatus.DISCONNECTED);
  runRejectHeadersTest(hr);
  hr=HandshakeResponse.createAcceptIncomingResponse(HandshakeResponse.createEmptyResponse(),new UltrapeerHeaders(""String_Node_Str""));
  runUltrapeerHeadersTest(hr);
}",0.973967684021544
4325,"/** 
 * Test to make sure that leaf headers are created correctly.
 */
public void testLeafHeaders() throws Exception {
  ConnectionSettings.ENCODE_DEFLATE.setValue(true);
  ConnectionSettings.ACCEPT_DEFLATE.setValue(true);
  Properties headers=new Properties();
  headers.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
  HandshakeResponse client=HandshakeResponse.createResponse(headers);
  HandshakeResponse hr=HandshakeResponse.createUltrapeerRejectIncomingResponse(client);
  runRejectHeadersTest(hr);
  hr=HandshakeResponse.createAcceptIncomingResponse(HandshakeResponse.createEmptyResponse(),new LeafHeaders(""String_Node_Str""));
  runLeafHeadersTest(hr);
  ConnectionSettings.ACCEPT_DEFLATE.setValue(false);
  hr=HandshakeResponse.createRejectOutgoingResponse();
  runRejectOutgoingLeafHeadersTest(hr);
  hr=HandshakeResponse.createAcceptOutgoingResponse(new LeafHeaders(""String_Node_Str""));
  runLeafHeadersTest(hr);
}","/** 
 * Test to make sure that leaf headers are created correctly.
 */
public void testLeafHeaders() throws Exception {
  ConnectionSettings.ENCODE_DEFLATE.setValue(true);
  ConnectionSettings.ACCEPT_DEFLATE.setValue(true);
  Properties headers=new Properties();
  headers.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
  HandshakeResponse client=HandshakeResponse.createResponse(headers);
  HandshakeResponse hr=HandshakeResponse.createUltrapeerRejectIncomingResponse(client,HandshakeStatus.DISCONNECTED);
  runRejectHeadersTest(hr);
  hr=HandshakeResponse.createAcceptIncomingResponse(HandshakeResponse.createEmptyResponse(),new LeafHeaders(""String_Node_Str""));
  runLeafHeadersTest(hr);
  ConnectionSettings.ACCEPT_DEFLATE.setValue(false);
  hr=HandshakeResponse.createRejectOutgoingResponse(HandshakeStatus.DISCONNECTED);
  runRejectOutgoingLeafHeadersTest(hr);
  hr=HandshakeResponse.createAcceptOutgoingResponse(new LeafHeaders(""String_Node_Str""));
  runLeafHeadersTest(hr);
}",0.9701414353064431
4326,"public void testLeafRejectIncoming() throws Exception {
  Properties props=new Properties();
  props.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
  HostCatcher hc=RouterService.getHostCatcher();
  hc.add(MessageTestUtils.createPongWithFreeLeafSlots());
  HandshakeResponse headers=HandshakeResponse.createResponse(props);
  HandshakeResponse hr=HandshakeResponse.createLeafRejectIncomingResponse(headers);
  assertTrue(hr.hasXTryUltrapeers());
}","public void testLeafRejectIncoming() throws Exception {
  Properties props=new Properties();
  props.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
  HostCatcher hc=RouterService.getHostCatcher();
  hc.add(MessageTestUtils.createPongWithFreeLeafSlots());
  HandshakeResponse headers=HandshakeResponse.createResponse(props);
  HandshakeResponse hr=HandshakeResponse.createLeafRejectIncomingResponse(headers,HandshakeStatus.NO_HEADERS);
  assertTrue(hr.hasXTryUltrapeers());
}",0.970747562296858
4327,"public void run(){
  _manager.unregisterPushObserver(mrfd,true);
}","public void run(){
  _manager.unregisterPushObserver(details,true);
}",0.9333333333333332
4328,"/** 
 * Attempts to asynchronously connect through TCP to the remote end. This will return immediately and the given observer will be notified of success or failure.
 */
private void connectDirectly(DirectConnector observer){
  if (!_interrupted) {
    LOG.trace(""String_Node_Str"" + _rfd);
    _connectObserver=observer;
    try {
      Socket socket=Sockets.connect(_rfd.getHost(),_rfd.getPort(),NORMAL_CONNECT_TIME,observer);
      if (!observer.isShutdown())       observer.setSocket(socket);
    }
 catch (    IOException iox) {
      observer.shutdown();
    }
  }
 else {
    _manager.workerFinished(this);
  }
}","/** 
 * Attempts to asynchronously connect through TCP to the remote end. This will return immediately and the given observer will be notified of success or failure.
 */
private void connectDirectly(DirectConnector observer){
  if (!_interrupted) {
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + _rfd);
    _connectObserver=observer;
    try {
      Socket socket=Sockets.connect(_rfd.getHost(),_rfd.getPort(),NORMAL_CONNECT_TIME,observer);
      if (!observer.isShutdown())       observer.setSocket(socket);
    }
 catch (    IOException iox) {
      observer.shutdown();
    }
  }
 else {
    _manager.workerFinished(this);
  }
}",0.976303317535545
4329,"/** 
 * Attempts to connect by using a push to the remote end. This method will return immediately and the given observer will be notified of success or failure.
 */
private void connectWithPush(HTTPConnectObserver observer){
  if (!_interrupted) {
    LOG.trace(""String_Node_Str"" + _rfd);
    _connectObserver=null;
    final MiniRemoteFileDesc mrfd=new MiniRemoteFileDesc(_rfd.getFileName(),_rfd.getIndex(),_rfd.getClientGUID());
    _manager.registerPushObserver(observer,mrfd);
    RouterService.getDownloadManager().sendPush(_rfd,observer);
    RouterService.schedule(new Runnable(){
      public void run(){
        _manager.unregisterPushObserver(mrfd,true);
      }
    }
,_rfd.isFromAlternateLocation() ? UDP_PUSH_CONNECT_TIME : PUSH_CONNECT_TIME,0);
  }
 else {
    _manager.workerFinished(this);
  }
}","/** 
 * Attempts to connect by using a push to the remote end. This method will return immediately and the given observer will be notified of success or failure.
 */
private void connectWithPush(PushConnector observer){
  if (!_interrupted) {
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + _rfd);
    _connectObserver=null;
    final PushDetails details=new PushDetails(_rfd.getClientGUID(),_rfd.getHost());
    observer.setPushDetails(details);
    _manager.registerPushObserver(observer,details);
    RouterService.getDownloadManager().sendPush(_rfd,observer);
    RouterService.schedule(new Runnable(){
      public void run(){
        _manager.unregisterPushObserver(details,true);
      }
    }
,_rfd.isFromAlternateLocation() ? UDP_PUSH_CONNECT_TIME : PUSH_CONNECT_TIME,0);
  }
 else {
    _manager.workerFinished(this);
  }
}",0.6935580975316075
4330,"/** 
 * Possibly tells the manager to forget this RFD, cleans up various things, and tells the manager to forget this worker.
 */
private void failed(){
  _manager.unregisterPushObserver(new MiniRemoteFileDesc(_rfd),false);
  if (!directConnectOnFailure) {
    if (forgetOnFailure) {
      _manager.forgetRFD(_rfd);
    }
    finishConnect();
    _manager.workerFinished(DownloadWorker.this);
  }
 else {
    connectDirectly(new DirectConnector(false));
  }
}","/** 
 * Possibly tells the manager to forget this RFD, cleans up various things, and tells the manager to forget this worker.
 */
private void failed(){
  _manager.unregisterPushObserver(pushDetails,false);
  if (!directConnectOnFailure) {
    if (forgetOnFailure) {
      _manager.forgetRFD(_rfd);
    }
    finishConnect();
    _manager.workerFinished(DownloadWorker.this);
  }
 else {
    connectDirectly(new DirectConnector(false));
  }
}",0.9567147613762488
4331,"/** 
 * Accepts a push download.  If this chooses to download the given file (with given index and clientGUID) from socket, returns true.  In this case, the caller may not make any modifications to the socket.  If this rejects the given file, returns false without modifying this or socket. Non-blocking.
 * @modifies this, socket
 * @requires GIV string (and nothing else) has been read from socket
 */
public boolean acceptDownload(String file,Socket socket,int index,byte[] clientGUID){
  if (stopped)   return false;
  MiniRemoteFileDesc mrfd=new MiniRemoteFileDesc(file,index,clientGUID);
  HTTPConnectObserver observer=(HTTPConnectObserver)pushObservers.remove(mrfd);
  if (observer == null)   return false;
  observer.handleConnect(socket);
  return true;
}","/** 
 * Accepts a push download.  If this chooses to download the given file (with given index and clientGUID) from socket, returns true.  In this case, the caller may not make any modifications to the socket.  If this rejects the given file, returns false without modifying this or socket. Non-blocking.
 * @modifies this, socket
 * @requires GIV string (and nothing else) has been read from socket
 */
public boolean acceptDownload(String file,Socket socket,int index,byte[] clientGUID){
  if (stopped)   return false;
  HTTPConnectObserver observer=pushes.getHostFor(clientGUID,socket.getInetAddress().getHostAddress());
  if (observer != null)   observer.handleConnect(socket);
  return observer != null;
}",0.7734056987788331
4332,"/** 
 * Kills all workers & shuts down all push waiters.
 */
private void killAllWorkers(){
  List workers=getAllWorkers();
  for (Iterator iter=workers.iterator(); iter.hasNext(); ) {
    DownloadWorker doomed=(DownloadWorker)iter.next();
    doomed.interrupt();
  }
  Map pushers;
synchronized (pushObservers) {
    pushers=new HashMap(pushObservers);
    pushObservers.clear();
  }
  for (Iterator i=pushers.values().iterator(); i.hasNext(); ) {
    HTTPConnectObserver next=(HTTPConnectObserver)i.next();
    next.shutdown();
  }
}","/** 
 * Kills all workers & shuts down all push waiters.
 */
private void killAllWorkers(){
  List workers=getAllWorkers();
  for (Iterator iter=workers.iterator(); iter.hasNext(); ) {
    DownloadWorker doomed=(DownloadWorker)iter.next();
    doomed.interrupt();
  }
  List pushObservers=pushes.getAllAndClear();
  for (Iterator i=pushObservers.iterator(); i.hasNext(); ) {
    HTTPConnectObserver next=(HTTPConnectObserver)i.next();
    next.shutdown();
  }
}",0.8273092369477911
4333,"/** 
 * Initializes a ManagedDownloader read from disk. Also used for internally initializing or resuming a normal download; there is no need to explicitly call this method in that case. After the call, this is in the queued state, at least for the moment.
 * @requires this is uninitialized or stopped, and allFiles, and incompleteFileManager are set
 * @modifies everything but the above fields 
 * @param deserialized True if this downloader is being initialized after being read from disk, false otherwise.
 */
public void initialize(DownloadManager manager,FileManager fileManager,DownloadCallback callback){
  this.manager=manager;
  this.fileManager=fileManager;
  this.callback=callback;
  currentRFDs=new HashSet();
  _activeWorkers=new LinkedList();
  _workers=new ArrayList();
  queuedWorkers=new HashMap();
  chatList=new DownloadChatList();
  browseList=new DownloadBrowseHostList();
  stealLock=new Object();
  stopped=false;
  paused=false;
  setState(QUEUED);
  pushObservers=Collections.synchronizedMap(new HashMap());
  corruptState=NOT_CORRUPT_STATE;
  corruptStateLock=new Object();
  altLock=new Object();
  numMeasures=0;
  averageBandwidth=0f;
  queuePosition=Integer.MAX_VALUE;
  queuedVendor=""String_Node_Str"";
  triedLocatingSources=false;
  ranker=getSourceRanker(null);
  ranker.setMeshHandler(this);
  if (downloadSHA1 == null)   downloadSHA1=(URN)propertiesMap.get(SHA1_URN);
synchronized (this) {
    for (Iterator iter=cachedRFDs.iterator(); iter.hasNext() && downloadSHA1 == null; ) {
      RemoteFileDesc rfd=(RemoteFileDesc)iter.next();
      downloadSHA1=rfd.getSHA1Urn();
    }
  }
  if (downloadSHA1 != null) {
    RouterService.getAltlocManager().addListener(downloadSHA1,this);
    propertiesMap.put(SHA1_URN,downloadSHA1);
  }
  verifyAllFiles();
synchronized (altLock) {
    validAlts=new HashSet();
    invalidAlts=new FixedSizeExpiringSet(1000,60 * 60 * 1000L);
    recentInvalidAlts=new FixedSizeExpiringSet(10,10 * 60 * 1000L);
  }
synchronized (this) {
    if (shouldInitAltLocs(deserializedFromDisk)) {
      initializeAlternateLocations();
    }
  }
  try {
    initializeIncompleteFile();
    initializeVerifyingFile();
  }
 catch (  IOException bad) {
    setState(DISK_PROBLEM);
    return;
  }
  setState(QUEUED);
}","/** 
 * Initializes a ManagedDownloader read from disk. Also used for internally initializing or resuming a normal download; there is no need to explicitly call this method in that case. After the call, this is in the queued state, at least for the moment.
 * @requires this is uninitialized or stopped, and allFiles, and incompleteFileManager are set
 * @modifies everything but the above fields 
 * @param deserialized True if this downloader is being initialized after being read from disk, false otherwise.
 */
public void initialize(DownloadManager manager,FileManager fileManager,DownloadCallback callback){
  this.manager=manager;
  this.fileManager=fileManager;
  this.callback=callback;
  currentRFDs=new HashSet();
  _activeWorkers=new LinkedList();
  _workers=new ArrayList();
  queuedWorkers=new HashMap();
  chatList=new DownloadChatList();
  browseList=new DownloadBrowseHostList();
  stealLock=new Object();
  stopped=false;
  paused=false;
  setState(QUEUED);
  pushes=new PushList();
  corruptState=NOT_CORRUPT_STATE;
  corruptStateLock=new Object();
  altLock=new Object();
  numMeasures=0;
  averageBandwidth=0f;
  queuePosition=Integer.MAX_VALUE;
  queuedVendor=""String_Node_Str"";
  triedLocatingSources=false;
  ranker=getSourceRanker(null);
  ranker.setMeshHandler(this);
  if (downloadSHA1 == null)   downloadSHA1=(URN)propertiesMap.get(SHA1_URN);
synchronized (this) {
    for (Iterator iter=cachedRFDs.iterator(); iter.hasNext() && downloadSHA1 == null; ) {
      RemoteFileDesc rfd=(RemoteFileDesc)iter.next();
      downloadSHA1=rfd.getSHA1Urn();
    }
  }
  if (downloadSHA1 != null) {
    RouterService.getAltlocManager().addListener(downloadSHA1,this);
    propertiesMap.put(SHA1_URN,downloadSHA1);
  }
  verifyAllFiles();
synchronized (altLock) {
    validAlts=new HashSet();
    invalidAlts=new FixedSizeExpiringSet(1000,60 * 60 * 1000L);
    recentInvalidAlts=new FixedSizeExpiringSet(10,10 * 60 * 1000L);
  }
synchronized (this) {
    if (shouldInitAltLocs(deserializedFromDisk)) {
      initializeAlternateLocations();
    }
  }
  try {
    initializeIncompleteFile();
    initializeVerifyingFile();
  }
 catch (  IOException bad) {
    setState(DISK_PROBLEM);
    return;
  }
  setState(QUEUED);
}",0.985114419017996
4334,"/** 
 * Unregisters a ConnectObserver that was waiting for the given MRFD.  If shutdown is true and the observer was still registered, calls shutdown on that observer.
 * @param mrfd
 * @param shutdown
 */
void unregisterPushObserver(MiniRemoteFileDesc mrfd,boolean shutdown){
  HTTPConnectObserver observer=(HTTPConnectObserver)pushObservers.remove(mrfd);
  if (observer != null && shutdown)   observer.shutdown();
}","/** 
 * Unregisters a ConnectObserver that was waiting for the given MRFD.  If shutdown is true and the observer was still registered, calls shutdown on that observer.
 * @param mrfd
 * @param shutdown
 */
void unregisterPushObserver(PushDetails details,boolean shutdown){
  HTTPConnectObserver observer=pushes.getExactHostFor(details);
  if (observer != null && shutdown)   observer.shutdown();
}",0.8624078624078624
4335,"/** 
 * Registers a new ConnectObserver that is waiting for a socket from the given MRFD.
 * @param observer
 * @param mrfd
 */
void registerPushObserver(HTTPConnectObserver observer,MiniRemoteFileDesc mrfd){
  pushObservers.put(mrfd,observer);
}","/** 
 * Registers a new ConnectObserver that is waiting for a socket from the given MRFD.
 * @param observer
 * @param mrfd
 */
void registerPushObserver(HTTPConnectObserver observer,PushDetails details){
  pushes.addPushHost(details,observer);
}",0.8577235772357723
4336,"private void addYetToBeQueried(ContactNode node,int hop){
  if (!queried.contains(node) && !node.equals(context.getLocalNode())) {
    toQuery.put(node.getNodeID(),node);
    hopMap.put(node.getNodeID(),new Integer(hop));
  }
}","private void addYetToBeQueried(ContactNode node,int hop){
  if (!queried.contains(node.getNodeID()) && !node.equals(context.getLocalNode())) {
    toQuery.put(node.getNodeID(),node);
    hopMap.put(node.getNodeID(),new Integer(hop));
  }
}",0.9742489270386266
4337,"public void refreshBuckets(boolean force,BootstrapListener l) throws IOException {
  ArrayList bucketsLookups=new ArrayList();
  long now=System.currentTimeMillis();
  for (Iterator iter=bucketsTrie.values().iterator(); iter.hasNext(); ) {
    BucketNode bucket=(BucketNode)iter.next();
    long lastTouch=bucket.getTimeStamp();
    int length=Math.max(0,bucket.getDepth() - 1);
    List liveNodes=nodesTrie.range(bucket.getNodeID(),length,SELECT_ALIVE_CONTACTS);
    if (l != null && liveNodes.contains(context.getLocalNodeID())) {
      continue;
    }
    if (force || ((now - lastTouch) > RouteTableSettings.BUCKET_REFRESH_TIME.getValue()) || (bucket.getNodeCount() < K)|| (liveNodes.size() != bucket.getNodeCount())) {
      KUID randomID=KUID.createPrefxNodeID(bucket.getNodeID().getBytes(),bucket.getDepth());
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + bucket + ""String_Node_Str""+ randomID);
      }
      bucketsLookups.add(randomID);
    }
  }
  if (bucketsLookups.isEmpty()) {
    if (l != null) {
      l.secondPhaseComplete(context.getLocalNodeID(),false,0L);
    }
  }
 else {
    BootstrapPhaseTwoManager listener=new BootstrapPhaseTwoManager(bucketsLookups,l);
    for (Iterator iter=bucketsLookups.iterator(); iter.hasNext(); ) {
      KUID lookupId=(KUID)iter.next();
      routingStats.BUCKET_REFRESH_COUNT.incrementStat();
      context.lookup(lookupId,listener);
    }
  }
}","public void refreshBuckets(boolean force,BootstrapListener l) throws IOException {
  ArrayList bucketsLookups=new ArrayList();
  long now=System.currentTimeMillis();
  for (Iterator iter=bucketsTrie.values().iterator(); iter.hasNext(); ) {
    BucketNode bucket=(BucketNode)iter.next();
    long lastTouch=bucket.getTimeStamp();
    int length=Math.max(0,bucket.getDepth() - 1);
    List liveNodes=nodesTrie.range(bucket.getNodeID(),length,SELECT_ALIVE_CONTACTS);
    if (l != null && liveNodes.contains(context.getLocalNode())) {
      continue;
    }
    if (force || ((now - lastTouch) > RouteTableSettings.BUCKET_REFRESH_TIME.getValue()) || (bucket.getNodeCount() < K)|| (liveNodes.size() != bucket.getNodeCount())) {
      KUID randomID=KUID.createPrefxNodeID(bucket.getNodeID().getBytes(),bucket.getDepth());
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + bucket + ""String_Node_Str""+ randomID);
      }
      bucketsLookups.add(randomID);
    }
  }
  if (bucketsLookups.isEmpty()) {
    if (l != null) {
      l.secondPhaseComplete(context.getLocalNodeID(),false,0L);
    }
  }
 else {
    BootstrapPhaseTwoManager listener=new BootstrapPhaseTwoManager(bucketsLookups,l);
    for (Iterator iter=bucketsLookups.iterator(); iter.hasNext(); ) {
      KUID lookupId=(KUID)iter.next();
      routingStats.BUCKET_REFRESH_COUNT.incrementStat();
      context.lookup(lookupId,listener);
    }
  }
}",0.99929676511955
4338,"public void foundNodes(KUID lookup,Collection nodes,Map queryKeys,long time){
  try {
    List keyValues=Arrays.asList(new KeyValue[]{keyValue});
    List targets=new ArrayList(nodes.size());
    for (Iterator it=nodes.iterator(); it.hasNext(); ) {
      ContactNode node=(ContactNode)it.next();
      QueryKey queryKey=(QueryKey)queryKeys.get(node);
      if (queryKey == null) {
        if (LOG.isErrorEnabled()) {
          LOG.error(""String_Node_Str"" + keyValues + ""String_Node_Str""+ node+ ""String_Node_Str"");
        }
        continue;
      }
      store(node,queryKey,keyValues);
      targets.add(node);
    }
    if (l != null) {
      l.store(keyValues,targets);
    }
  }
 catch (  IOException err) {
    LOG.error(err);
  }
}","public void foundNodes(KUID lookup,Collection nodes,Map queryKeys,long time){
  try {
    List keyValues=Arrays.asList(new KeyValue[]{keyValue});
    List targets=new ArrayList(nodes.size());
    for (Iterator it=nodes.iterator(); it.hasNext(); ) {
      ContactNode node=(ContactNode)it.next();
      QueryKey queryKey=(QueryKey)queryKeys.get(node);
      if (node.getNodeID().equals(getLocalNodeID()))       continue;
      if (queryKey == null) {
        if (LOG.isErrorEnabled()) {
          LOG.error(""String_Node_Str"" + keyValues + ""String_Node_Str""+ node+ ""String_Node_Str"");
        }
        continue;
      }
      store(node,queryKey,keyValues);
      targets.add(node);
    }
    if (l != null) {
      l.store(keyValues,targets);
    }
  }
 catch (  IOException err) {
    LOG.error(err);
  }
}",0.9553398058252428
4339,"public void lookup() throws IOException {
  MessageDispatcher messageDispatcher=context.getMessageDispatcher();
  if (LOG.isTraceEnabled()) {
    LOG.trace(""String_Node_Str"" + lookup);
  }
  int k=KademliaSettings.getReplicationParameter();
  List bucketList=context.getRouteTable().select(lookup,k,false,true);
  for (int i=bucketList.size() - 1; i >= 0; i--) {
    addYetToBeQueried((ContactNode)bucketList.get(i));
  }
  markAsQueried(context.getLocalNode());
  List alphaList=toQuery.select(lookup,KademliaSettings.getLookupParameter());
  for (int i=0; i < alphaList.size(); i++) {
    ContactNode node=(ContactNode)alphaList.get(i);
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + node + ""String_Node_Str""+ lookup);
    }
    markAsQueried(node);
    ++activeSearches;
    messageDispatcher.send(node,createMessage(lookup),this);
  }
}","public void lookup() throws IOException {
  MessageDispatcher messageDispatcher=context.getMessageDispatcher();
  if (LOG.isTraceEnabled()) {
    LOG.trace(""String_Node_Str"" + lookup);
  }
  int k=KademliaSettings.getReplicationParameter();
  List bucketList=context.getRouteTable().select(lookup,k,false,true);
  for (int i=bucketList.size() - 1; i >= 0; i--) {
    addYetToBeQueried((ContactNode)bucketList.get(i));
  }
  markAsQueried(context.getLocalNode());
  addResponse(context.getLocalNode());
  List alphaList=toQuery.select(lookup,KademliaSettings.getLookupParameter());
  for (int i=0; i < alphaList.size(); i++) {
    ContactNode node=(ContactNode)alphaList.get(i);
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + node + ""String_Node_Str""+ lookup);
    }
    markAsQueried(node);
    ++activeSearches;
    messageDispatcher.send(node,createMessage(lookup),this);
  }
}",0.9778534923339012
4340,"private void addResponse(ContactNode node){
  if (responses.size() == resultSize) {
    KUID furthest=lookup.invert();
    ContactNode worst=(ContactNode)responses.select(furthest);
    responses.remove(worst.getNodeID());
    queryKeys.remove(worst);
  }
  responses.put(node.getNodeID(),node);
}","private void addResponse(ContactNode node){
  responses.put(node.getNodeID(),node);
  if (responses.size() > resultSize) {
    KUID furthest=lookup.invert();
    ContactNode worst=(ContactNode)responses.select(furthest);
    responses.remove(worst.getNodeID());
    queryKeys.remove(worst);
  }
}",0.8600337268128162
4341,"private void lookupStep() throws IOException {
  if (toQuery.isEmpty() && activeSearches == 0) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + lookup + ""String_Node_Str"");
    }
    if (isValueLookup()) {
      finishValueLookup(lookup,null,time);
    }
 else {
      List nodes=responses.select(lookup,responses.size());
      finishNodeLookup(lookup,nodes,queryKeys,time);
    }
    finished=true;
    return;
  }
  if (responses.size() == resultSize) {
    KUID furthest=lookup.invert();
    ContactNode worstResponse=(ContactNode)responses.select(furthest);
    ContactNode bestToQuery=(ContactNode)toQuery.select(lookup);
    if (bestToQuery == null || worstResponse.getNodeID().isCloser(bestToQuery.getNodeID(),lookup)) {
      ContactNode bestResponse=(ContactNode)responses.select(lookup);
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + lookup + ""String_Node_Str""+ bestResponse+ ""String_Node_Str""+ queried.size()+ ""String_Node_Str"");
      }
      if (isValueLookup()) {
        finishValueLookup(lookup,null,time);
      }
 else {
        List nodes=responses.select(lookup,responses.size());
        finishNodeLookup(lookup,nodes,queryKeys,time);
      }
      finished=true;
      return;
    }
  }
  int numLookups=KademliaSettings.getLookupParameter() - activeSearches;
  if (numLookups > 0) {
    List bucketList=toQuery.select(lookup,numLookups);
    final int size=bucketList.size();
    MessageDispatcher messageDispatcher=context.getMessageDispatcher();
    for (int i=0; i < size; i++) {
      ContactNode node=(ContactNode)bucketList.get(i);
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + node + ""String_Node_Str""+ lookup);
      }
      markAsQueried(node);
      ++activeSearches;
      messageDispatcher.send(node,createMessage(lookup),this);
    }
  }
}","private void lookupStep() throws IOException {
  if (toQuery.isEmpty() && activeSearches == 0) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + lookup + ""String_Node_Str"");
    }
    if (isValueLookup()) {
      finishValueLookup(lookup,null,time);
    }
 else {
      List nodes=responses.select(lookup,responses.size());
      finishNodeLookup(lookup,nodes,queryKeys,time);
    }
    finished=true;
    return;
  }
  if ((responses.size() == resultSize) && (activeSearches == 0)) {
    KUID furthest=lookup.invert();
    ContactNode worstResponse=(ContactNode)responses.select(furthest);
    ContactNode bestToQuery=(ContactNode)toQuery.select(lookup);
    if (bestToQuery == null || worstResponse.getNodeID().isCloser(bestToQuery.getNodeID(),lookup)) {
      ContactNode bestResponse=(ContactNode)responses.select(lookup);
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + lookup + ""String_Node_Str""+ bestResponse+ ""String_Node_Str""+ queried.size()+ ""String_Node_Str"");
      }
      if (isValueLookup()) {
        finishValueLookup(lookup,null,time);
      }
 else {
        List nodes=responses.select(lookup,responses.size());
        finishNodeLookup(lookup,nodes,queryKeys,time);
      }
      finished=true;
      return;
    }
  }
  int numLookups=KademliaSettings.getLookupParameter() - activeSearches;
  if (numLookups > 0) {
    List bucketList=toQuery.select(lookup,numLookups);
    final int size=bucketList.size();
    MessageDispatcher messageDispatcher=context.getMessageDispatcher();
    for (int i=0; i < size; i++) {
      ContactNode node=(ContactNode)bucketList.get(i);
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + node + ""String_Node_Str""+ lookup);
      }
      markAsQueried(node);
      ++activeSearches;
      messageDispatcher.send(node,createMessage(lookup),this);
    }
  }
}",0.992751677852349
4342,"public static String toString(Collection c){
  StringBuffer buffer=new StringBuffer();
  for (Iterator it=c.iterator(); it.hasNext(); ) {
    buffer.append(it.next()).append(""String_Node_Str"");
  }
  buffer.setLength(buffer.length() - 1);
  return buffer.toString();
}","public static String toString(Collection c){
  StringBuffer buffer=new StringBuffer();
  for (Iterator it=c.iterator(); it.hasNext(); ) {
    buffer.append(it.next()).append(""String_Node_Str"");
  }
  if (buffer.length() > 1)   buffer.setLength(buffer.length() - 1);
  return buffer.toString();
}",0.9520426287744228
4343,"/** 
 * Computes the closest address to targetID between this KUID and nodeID
 * @param nodeID the KUID to compare to
 * @param targetID the target ID
 * @return true if this is closer to targetID, false otherwise
 */
public boolean isCloser(KUID nodeID,KUID targetID){
  for (int i=0; i < id.length; i++) {
    int d1=(id[i] ^ targetID.id[i]) & 0xFF;
    int d2=(nodeID.id[i] ^ targetID.id[i]) & 0xFF;
    int diff=d1 - d2;
    if (diff < 0) {
      return true;
    }
  }
  return false;
}","/** 
 * Computes the closest address to targetID between this KUID and nodeID
 * @param nodeID the KUID to compare to
 * @param targetID the target ID
 * @return true if this is closer to targetID, false otherwise
 */
public boolean isCloser(KUID nodeID,KUID targetID){
  for (int i=0; i < id.length; i++) {
    int dSelf=(id[i] ^ targetID.id[i]) & 0xFF;
    int dOther=(nodeID.id[i] ^ targetID.id[i]) & 0xFF;
    int diff=dOther - dSelf;
    if (diff > 0) {
      return true;
    }
 else     if (diff < 0) {
      return false;
    }
  }
  return false;
}",0.900763358778626
4344,"protected void addResponse(ContactNode node){
  if (responses.size() == resultSize) {
    KUID furthest=lookup.invert();
    responses.remove((KUID)responses.select(furthest));
  }
  responses.put(node.getNodeID(),node);
}","protected void addResponse(ContactNode node){
  if (responses.size() == resultSize) {
    KUID furthest=lookup.invert();
    responses.remove(((ContactNode)responses.select(furthest)).getNodeID());
  }
  responses.put(node.getNodeID(),node);
}",0.8344086021505376
4345,"public int compare(Object a,Object b){
  return ((Thread)a).getName().compareTo(((Thread)b).getName());
}","public int compare(Object a,Object b){
  Thread threadA=(Thread)((Map.Entry)a).getKey();
  Thread threadB=(Thread)((Map.Entry)b).getKey();
  return threadA.getName().compareTo(threadB.getName());
}",0.6291390728476821
4346,"/** 
 * Returns the stack traces of all current Threads or an empty String if LimeWire is running on Java 1.4 or if an error occured.
 */
public static String getAllStackTraces(){
  if (!CommonUtils.isJava15OrLater()) {
    return ""String_Node_Str"";
  }
  try {
    Method m=Thread.class.getDeclaredMethod(""String_Node_Str"",new Class[0]);
    Map map=(Map)m.invoke(null,new Object[0]);
    Map sorted=new TreeMap(new Comparator(){
      public int compare(      Object a,      Object b){
        return ((Thread)a).getName().compareTo(((Thread)b).getName());
      }
    }
);
    sorted.putAll(map);
    StringBuffer buffer=new StringBuffer();
    Iterator it=sorted.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry entry=(Map.Entry)it.next();
      Thread key=(Thread)entry.getKey();
      StackTraceElement[] value=(StackTraceElement[])entry.getValue();
      buffer.append(key.getName()).append(""String_Node_Str"");
      for (int i=0; i < value.length; i++) {
        buffer.append(""String_Node_Str"").append(value[i]).append(""String_Node_Str"");
      }
      buffer.append(""String_Node_Str"");
    }
    if (buffer.length() > 0) {
      buffer.setLength(buffer.length() - 1);
    }
    return buffer.toString();
  }
 catch (  Exception err) {
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    pw.println(""String_Node_Str"");
    err.printStackTrace(pw);
    pw.flush();
    return sw.toString();
  }
}","/** 
 * Returns the stack traces of all current Threads or an empty String if LimeWire is running on Java 1.4 or if an error occured.
 */
public static String getAllStackTraces(){
  if (!CommonUtils.isJava15OrLater()) {
    return ""String_Node_Str"";
  }
  try {
    Method m=Thread.class.getDeclaredMethod(""String_Node_Str"",new Class[0]);
    Map map=(Map)m.invoke(null,new Object[0]);
    List sorted=new ArrayList(map.entrySet());
    Collections.sort(sorted,new Comparator(){
      public int compare(      Object a,      Object b){
        Thread threadA=(Thread)((Map.Entry)a).getKey();
        Thread threadB=(Thread)((Map.Entry)b).getKey();
        return threadA.getName().compareTo(threadB.getName());
      }
    }
);
    StringBuffer buffer=new StringBuffer();
    Iterator it=sorted.iterator();
    while (it.hasNext()) {
      Map.Entry entry=(Map.Entry)it.next();
      Thread key=(Thread)entry.getKey();
      StackTraceElement[] value=(StackTraceElement[])entry.getValue();
      buffer.append(key.getName()).append(""String_Node_Str"");
      for (int i=0; i < value.length; i++) {
        buffer.append(""String_Node_Str"").append(value[i]).append(""String_Node_Str"");
      }
      buffer.append(""String_Node_Str"");
    }
    if (buffer.length() > 0) {
      buffer.setLength(buffer.length() - 1);
    }
    return buffer.toString();
  }
 catch (  Exception err) {
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    pw.println(""String_Node_Str"");
    err.printStackTrace(pw);
    pw.flush();
    return sw.toString();
  }
}",0.8620575587165068
4347,"private void put(KUID nodeId,ContactNode node){
  if (nodeId == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!nodeId.equals(node.getNodeID())) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  staleNodes.remove(nodeId);
  BucketNode bucket=(BucketNode)bucketsTrie.select(nodeId);
  if (bucket.getNodeCount() < K) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + node + ""String_Node_Str""+ bucket);
    }
    bucket.incrementNodeCount();
    bucket.removeReplacementNode(nodeId);
    nodesTrie.put(nodeId,node);
    return;
  }
 else {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + bucket + ""String_Node_Str"");
    }
    BucketNode localBucket=(BucketNode)bucketsTrie.select(context.getLocalNodeID());
    boolean containsLocal=localBucket.equals(bucket);
    BucketNode smallestSubtree=(BucketNode)bucketsTrie.selectNextClosest(localBucket.getNodeID());
    boolean partOfSmallest=bucket.equals(smallestSubtree);
    boolean tooDeep=bucket.getDepth() % B == 0;
    if (containsLocal || partOfSmallest || !tooDeep) {
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + bucket + ""String_Node_Str"");
      }
      List newBuckets=bucket.split();
      BucketNode leftSplitBucket=(BucketNode)newBuckets.get(0);
      BucketNode rightSplitBucket=(BucketNode)newBuckets.get(1);
      bucketsTrie.put(leftSplitBucket.getNodeID(),leftSplitBucket);
      bucketsTrie.put(rightSplitBucket.getNodeID(),rightSplitBucket);
      int countLeft=updateBucketNodeCount(leftSplitBucket);
      int countRight=updateBucketNodeCount(rightSplitBucket);
      BucketNode newBucket=(BucketNode)bucketsTrie.select(nodeId);
      if (countLeft + countRight != K) {
        if (LOG.isErrorEnabled()) {
          LOG.error(""String_Node_Str"");
        }
        return;
      }
      if (newBucket.equals(bucket)) {
        if (LOG.isErrorEnabled()) {
          LOG.error(""String_Node_Str"");
        }
        return;
      }
      if (newBucket.getNodeCount() < K) {
        if (LOG.isTraceEnabled()) {
          LOG.trace(""String_Node_Str"" + node + ""String_Node_Str""+ newBucket);
        }
        newBucket.incrementNodeCount();
        newBucket.removeReplacementNode(nodeId);
        nodesTrie.put(nodeId,node);
        return;
      }
 else {
        if (LOG.isTraceEnabled()) {
          LOG.trace(""String_Node_Str"" + newBucket + ""String_Node_Str""+ node+ ""String_Node_Str"");
        }
        bucket.addReplacementNode(node);
        return;
      }
    }
 else {
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + bucket + ""String_Node_Str""+ node+ ""String_Node_Str""+ bucket);
      }
      bucket.addReplacementNode(node);
    }
  }
}","private void put(KUID nodeId,ContactNode node){
  if (nodeId == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (node == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!nodeId.equals(node.getNodeID())) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  staleNodes.remove(nodeId);
  BucketNode bucket=(BucketNode)bucketsTrie.select(nodeId);
  if (bucket.getNodeCount() < K) {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + node + ""String_Node_Str""+ bucket);
    }
    bucket.incrementNodeCount();
    bucket.removeReplacementNode(nodeId);
    nodesTrie.put(nodeId,node);
    return;
  }
 else {
    if (LOG.isTraceEnabled()) {
      LOG.trace(""String_Node_Str"" + bucket + ""String_Node_Str"");
    }
    BucketNode localBucket=(BucketNode)bucketsTrie.select(context.getLocalNodeID());
    boolean containsLocal=localBucket.equals(bucket);
    BucketNode smallestSubtree=(BucketNode)bucketsTrie.selectNextClosest(localBucket.getNodeID());
    boolean partOfSmallest=bucket.equals(smallestSubtree);
    boolean tooDeep=bucket.getDepth() % B == 0;
    if (containsLocal || partOfSmallest || !tooDeep) {
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + bucket + ""String_Node_Str"");
      }
      List newBuckets=bucket.split();
      BucketNode leftSplitBucket=(BucketNode)newBuckets.get(0);
      BucketNode rightSplitBucket=(BucketNode)newBuckets.get(1);
      bucketsTrie.put(leftSplitBucket.getNodeID(),leftSplitBucket);
      bucketsTrie.put(rightSplitBucket.getNodeID(),rightSplitBucket);
      int countLeft=updateBucketNodeCount(leftSplitBucket);
      int countRight=updateBucketNodeCount(rightSplitBucket);
      BucketNode newBucket=(BucketNode)bucketsTrie.select(nodeId);
      if (countLeft + countRight != K) {
        if (LOG.isErrorEnabled()) {
          LOG.error(""String_Node_Str"");
        }
        return;
      }
      if (newBucket.equals(bucket)) {
        if (LOG.isErrorEnabled()) {
          LOG.error(""String_Node_Str"");
        }
        return;
      }
      if (newBucket.getNodeCount() < K) {
        if (LOG.isTraceEnabled()) {
          LOG.trace(""String_Node_Str"" + node + ""String_Node_Str""+ newBucket);
        }
        newBucket.incrementNodeCount();
        newBucket.removeReplacementNode(nodeId);
        nodesTrie.put(nodeId,node);
        return;
      }
 else {
        if (LOG.isTraceEnabled()) {
          LOG.trace(""String_Node_Str"" + newBucket + ""String_Node_Str""+ node+ ""String_Node_Str"");
        }
        newBucket.addReplacementNode(node);
        return;
      }
    }
 else {
      if (LOG.isTraceEnabled()) {
        LOG.trace(""String_Node_Str"" + bucket + ""String_Node_Str""+ node+ ""String_Node_Str""+ bucket);
      }
      bucket.addReplacementNode(node);
    }
  }
}",0.999117387466902
4348,"public void writeNodeStat(Writer writer,String stat) throws IOException {
  if (nodeID == null) {
    nodeID=context.getLocalNodeID().toHexString();
  }
 else {
    writer.write(nodeID + FILE_DELIMITER + stat);
  }
}","public void writeNodeStat(Writer writer,String stat) throws IOException {
  if (nodeID == null) {
    nodeID=context.getLocalNodeID().toHexString();
  }
  writer.write(nodeID + FILE_DELIMITER + stat);
}",0.7751196172248804
4349,"/** 
 * Attempts to asynchronously connect through TCP to the remote end. This will return immediately and the given observer will be notified of success or failure.
 */
private void connectDirectly(DirectConnector observer){
  if (!_interrupted) {
    LOG.trace(""String_Node_Str"");
    _connectObserver=observer;
    try {
      Socket socket=Sockets.connect(_rfd.getHost(),_rfd.getPort(),NORMAL_CONNECT_TIME,_connectObserver);
      _connectObserver.setSocket(socket);
    }
 catch (    IOException iox) {
      _connectObserver.shutdown();
    }
  }
}","/** 
 * Attempts to asynchronously connect through TCP to the remote end. This will return immediately and the given observer will be notified of success or failure.
 */
private void connectDirectly(DirectConnector observer){
  if (!_interrupted) {
    LOG.trace(""String_Node_Str"");
    _connectObserver=observer;
    try {
      Socket socket=Sockets.connect(_rfd.getHost(),_rfd.getPort(),NORMAL_CONNECT_TIME,observer);
      if (!observer.isShutdown())       observer.setSocket(socket);
    }
 catch (    IOException iox) {
      observer.shutdown();
    }
  }
}",0.9427549194991056
4350,"/** 
 * Upon unsuccesful connect, try using a push (if pushConnectOnFailure is true).
 */
public void shutdown(){
  this.connectingSocket=null;
  DownloadStat.CONNECT_DIRECT_FAILURES.incrementStat();
  if (pushConnectOnFailure) {
    connectWithPush(new PushConnector(false,false));
  }
 else {
    finishConnect();
    _manager.workerFinished(DownloadWorker.this);
  }
}","/** 
 * Upon unsuccesful connect, try using a push (if pushConnectOnFailure is true).
 */
public void shutdown(){
  this.shutdown=true;
  this.connectingSocket=null;
  DownloadStat.CONNECT_DIRECT_FAILURES.incrementStat();
  if (pushConnectOnFailure) {
    connectWithPush(new PushConnector(false,false));
  }
 else {
    finishConnect();
    _manager.workerFinished(DownloadWorker.this);
  }
}",0.9712041884816754
4351,"/** 
 * Returns the InputStream from the NIOInputStream. Internally, this is a blocking Pipe from the non-blocking SocketChannel.
 */
public InputStream getInputStream() throws IOException {
  if (isClosed())   throw new IOException(""String_Node_Str"");
  if (reader instanceof NIOInputStream)   return ((NIOInputStream)reader).getInputStream();
 else   throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Returns the InputStream from the NIOInputStream. Internally, this is a blocking Pipe from the non-blocking SocketChannel.
 */
public InputStream getInputStream() throws IOException {
  if (isClosed() || shutdown)   throw new IOException(""String_Node_Str"");
  if (reader instanceof NIOInputStream)   return ((NIOInputStream)reader).getInputStream();
 else   throw new IllegalStateException(""String_Node_Str"");
}",0.9854368932038836
4352,"/** 
 * Returns the OutputStream from the NIOOutputStream. Internally, this is a blcoking Pipe from the non-blocking SocketChannel.
 */
public OutputStream getOutputStream() throws IOException {
  if (isClosed())   throw new IOException(""String_Node_Str"");
  if (writer instanceof NIOOutputStream)   return ((NIOOutputStream)writer).getOutputStream();
 else   throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Returns the OutputStream from the NIOOutputStream. Internally, this is a blcoking Pipe from the non-blocking SocketChannel.
 */
public OutputStream getOutputStream() throws IOException {
  if (isClosed() || shutdown)   throw new IOException(""String_Node_Str"");
  if (writer instanceof NIOOutputStream)   return ((NIOOutputStream)writer).getOutputStream();
 else   throw new IllegalStateException(""String_Node_Str"");
}",0.9856801909307876
4353,"/** 
 * Tests that the verification RDF validates against a RELAX-NG Schema
 */
public void testVerifyRDFValidates() throws Exception {
  String rdfEmbeddedComment=PublishedCCLicense.getRDFRepresentation(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",CCConstants.ATTRIBUTION_SHARE_NON_COMMERCIAL);
  ParserGetter kit=new ParserGetter();
  HTMLEditorKit.Parser htmlParser=kit.getParser();
  HTMLEditorKit.ParserCallback callback=new CommentExtractor();
  StringReader reader=new StringReader(rdfEmbeddedComment);
  htmlParser.parse(reader,callback,true);
synchronized (rdfLock) {
    while (rdf == null) {
      try {
        System.err.println(""String_Node_Str"");
        rdfLock.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
  SAXParser parser=new SAXParser();
  parser.setFeature(""String_Node_Str"",true);
  parser.setFeature(""String_Node_Str"",true);
  parser.setProperty(""String_Node_Str"",""String_Node_Str"");
  parser.parse(new InputSource(new StringReader(rdf)));
}","/** 
 * Tests that the verification RDF validates against a RELAX-NG Schema
 */
public void testVerifyRDFValidates() throws Exception {
  String rdfEmbeddedComment=PublishedCCLicense.getRDFRepresentation(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",CCConstants.ATTRIBUTION_SHARE_NON_COMMERCIAL);
  StringReader reader=new StringReader(rdfEmbeddedComment);
  HTMLEditorKit.ParserCallback callback=new CommentExtractor();
  getHTMLEditorKitParser().parse(reader,callback,true);
synchronized (rdfLock) {
    while (rdf == null) {
      try {
        System.err.println(""String_Node_Str"");
        rdfLock.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
  SAXParser parser=new SAXParser();
  parser.setFeature(""String_Node_Str"",true);
  parser.setFeature(""String_Node_Str"",true);
  parser.setProperty(""String_Node_Str"",""String_Node_Str"");
  parser.parse(new InputSource(new StringReader(rdf)));
}",0.8641358641358642
4354,"/** 
 * If oldName isn't shared, returns false.  Otherwise removes ""oldName"", adds ""newName"", and returns true iff newName is actually shared.  The new file may or may not have the same index as the original. This assumes that oldName has been deleted & newName exists now.
 * @modifies this 
 */
public synchronized void renameFileIfShared(File oldName,final File newName,final FileEventListener callback){
  FileDesc toRemove=getFileDescForFile(oldName);
  if (toRemove == null) {
    FileManagerEvent evt=new FileManagerEvent(this,FileManagerEvent.FAILED,oldName);
    dispatchFileEvent(evt);
    if (callback != null)     callback.handleFileEvent(evt);
    return;
  }
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + oldName + ""String_Node_Str""+ newName);
  List xmlDocs=new LinkedList(toRemove.getLimeXMLDocuments());
  final FileDesc removed=removeFileIfShared(oldName,false);
  Assert.that(removed == toRemove,""String_Node_Str"");
  if (_data.SPECIAL_FILES_TO_SHARE.remove(oldName) && !isFileInCompletelySharedDirectory(newName))   _data.SPECIAL_FILES_TO_SHARE.add(newName);
  UrnCache.instance().addUrns(newName,removed.getUrns());
  addFileIfShared(newName,xmlDocs,false,_revision,new FileEventListener(){
    public void handleFileEvent(    FileManagerEvent evt){
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + evt);
      FileManagerEvent newEvt=null;
      if (evt.isAddEvent()) {
        FileDesc fd=evt.getFileDescs()[0];
        newEvt=new FileManagerEvent(FileManager.this,FileManagerEvent.RENAME,new FileDesc[]{removed,fd});
      }
 else {
        newEvt=new FileManagerEvent(FileManager.this,FileManagerEvent.REMOVE,removed);
      }
      dispatchFileEvent(evt);
      if (callback != null)       callback.handleFileEvent(newEvt);
    }
  }
);
}","/** 
 * If oldName isn't shared, returns false.  Otherwise removes ""oldName"", adds ""newName"", and returns true iff newName is actually shared.  The new file may or may not have the same index as the original. This assumes that oldName has been deleted & newName exists now.
 * @modifies this 
 */
public synchronized void renameFileIfShared(File oldName,final File newName,final FileEventListener callback){
  FileDesc toRemove=getFileDescForFile(oldName);
  if (toRemove == null) {
    FileManagerEvent evt=new FileManagerEvent(this,FileManagerEvent.FAILED,oldName);
    dispatchFileEvent(evt);
    if (callback != null)     callback.handleFileEvent(evt);
    return;
  }
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + oldName + ""String_Node_Str""+ newName);
  List xmlDocs=new LinkedList(toRemove.getLimeXMLDocuments());
  final FileDesc removed=removeFileIfShared(oldName,false);
  Assert.that(removed == toRemove,""String_Node_Str"");
  if (_data.SPECIAL_FILES_TO_SHARE.remove(oldName) && !isFileInCompletelySharedDirectory(newName))   _data.SPECIAL_FILES_TO_SHARE.add(newName);
  UrnCache.instance().addUrns(newName,removed.getUrns());
  addFileIfShared(newName,xmlDocs,false,_revision,new FileEventListener(){
    public void handleFileEvent(    FileManagerEvent evt){
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + evt);
      FileManagerEvent newEvt=null;
      if (evt.isAddEvent()) {
        FileDesc fd=evt.getFileDescs()[0];
        newEvt=new FileManagerEvent(FileManager.this,FileManagerEvent.RENAME,new FileDesc[]{removed,fd});
      }
 else {
        newEvt=new FileManagerEvent(FileManager.this,FileManagerEvent.REMOVE,removed);
      }
      dispatchFileEvent(newEvt);
      if (callback != null)       callback.handleFileEvent(newEvt);
    }
  }
);
}",0.9986099527383931
4355,"public void handleFileEvent(FileManagerEvent evt){
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + evt);
  FileManagerEvent newEvt=null;
  if (evt.isAddEvent()) {
    FileDesc fd=evt.getFileDescs()[0];
    newEvt=new FileManagerEvent(FileManager.this,FileManagerEvent.RENAME,new FileDesc[]{removed,fd});
  }
 else {
    newEvt=new FileManagerEvent(FileManager.this,FileManagerEvent.REMOVE,removed);
  }
  dispatchFileEvent(evt);
  if (callback != null)   callback.handleFileEvent(newEvt);
}","public void handleFileEvent(FileManagerEvent evt){
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + evt);
  FileManagerEvent newEvt=null;
  if (evt.isAddEvent()) {
    FileDesc fd=evt.getFileDescs()[0];
    newEvt=new FileManagerEvent(FileManager.this,FileManagerEvent.RENAME,new FileDesc[]{removed,fd});
  }
 else {
    newEvt=new FileManagerEvent(FileManager.this,FileManagerEvent.REMOVE,removed);
  }
  dispatchFileEvent(newEvt);
  if (callback != null)   callback.handleFileEvent(newEvt);
}",0.9950347567030784
4356,"/** 
 * Waits until we're allowed to do an active outgoing socket connection.
 * @return true if we had to wait before we could get a connection
 */
private static boolean waitForSocket(int timeout,long now) throws IOException {
  if (!CommonUtils.isWindowsXP())   return false;
  boolean ret=false;
synchronized (Sockets.class) {
    int currentSocketsConnecting=_socketsConnecting;
    while (currentSocketsConnecting >= MAX_CONNECTING_SOCKETS) {
      if (timeout <= 0)       throw new IOException(""String_Node_Str"");
      try {
        ret=true;
        Sockets.class.wait(timeout);
        timeout-=(System.currentTimeMillis() - now);
      }
 catch (      InterruptedException ignored) {
        throw new IOException(ignored.getMessage());
      }
    }
    _socketsConnecting++;
  }
  return ret;
}","/** 
 * Waits until we're allowed to do an active outgoing socket connection.
 * @return true if we had to wait before we could get a connection
 */
private static boolean waitForSocket(int timeout,long now) throws IOException {
  if (!CommonUtils.isWindowsXP())   return false;
  long timeoutTime=now + timeout;
  boolean ret=false;
synchronized (Sockets.class) {
    int currentSocketsConnecting=_socketsConnecting;
    while (currentSocketsConnecting >= MAX_CONNECTING_SOCKETS) {
      if (timeout <= 0)       throw new IOException(""String_Node_Str"");
      try {
        ret=true;
        Sockets.class.wait(timeout);
        timeout=(int)(timeoutTime - System.currentTimeMillis());
      }
 catch (      InterruptedException ignored) {
        throw new IOException(ignored.getMessage());
      }
    }
    _socketsConnecting++;
  }
  return ret;
}",0.9626506024096384
4357,"/** 
 * Iterates through all responses seeing if they can be matched up to any existing downloaders, adding them as possible sources if they do.
 */
private void addDownloadWithResponses(List responses,HostData data){
  if (responses == null)   throw new NullPointerException(""String_Node_Str"");
  if (data == null)   throw new NullPointerException(""String_Node_Str"");
  List downloaders=new ArrayList(active.size() + waiting.size());
synchronized (this) {
    downloaders.addAll(active);
    downloaders.addAll(waiting);
  }
  if (downloaders.isEmpty())   return;
  for (Iterator i=responses.iterator(); i.hasNext(); ) {
    Response r=(Response)i.next();
    RemoteFileDesc rfd=r.toRemoteFileDesc(data);
    for (Iterator j=downloaders.iterator(); j.hasNext(); ) {
      ManagedDownloader currD=(ManagedDownloader)j.next();
      if (currD.addDownload(rfd,true)) {
        Set alts=r.getLocations();
        for (Iterator k=alts.iterator(); k.hasNext(); ) {
          Endpoint ep=(Endpoint)k.next();
          currD.addDownload(new RemoteFileDesc(rfd,ep),false);
        }
        break;
      }
    }
  }
}","/** 
 * Iterates through all responses seeing if they can be matched up to any existing downloaders, adding them as possible sources if they do.
 */
private void addDownloadWithResponses(List responses,HostData data){
  if (responses == null)   throw new NullPointerException(""String_Node_Str"");
  if (data == null)   throw new NullPointerException(""String_Node_Str"");
  List downloaders=new ArrayList(active.size() + waiting.size());
synchronized (this) {
    downloaders.addAll(active);
    downloaders.addAll(waiting);
  }
  if (downloaders.isEmpty())   return;
  for (Iterator i=responses.iterator(); i.hasNext(); ) {
    Response r=(Response)i.next();
    RemoteFileDesc rfd=r.toRemoteFileDesc(data);
    for (Iterator j=downloaders.iterator(); j.hasNext(); ) {
      ManagedDownloader currD=(ManagedDownloader)j.next();
      if (rfd.getFileSize() == currD.getContentLength())       LOG.debug(""String_Node_Str"" + rfd + ""String_Node_Str""+ currD);
 else       LOG.debug(""String_Node_Str"" + rfd.getFileSize() + ""String_Node_Str""+ currD.getContentLength());
      if (currD.addDownload(rfd,true)) {
        Set alts=r.getLocations();
        for (Iterator k=alts.iterator(); k.hasNext(); ) {
          Endpoint ep=(Endpoint)k.next();
          currD.addDownload(new RemoteFileDesc(rfd,ep),false);
        }
        break;
      }
 else       LOG.debug(""String_Node_Str"");
    }
  }
}",0.8893344025661588
4358,"/** 
 * Returns an un-initialized (only established a TCP Connection,  no HTTP headers have been exchanged yet) connectable downloader  from the given list of locations. <p>  method tries to establish connection either by push or by normal ways. <p> If the connection fails for some reason, or needs a push the mesh needs  to be informed that this location failed.
 * @param rfd the RemoteFileDesc to connect to<p>  The following exceptions may be thrown within this method, but they are all dealt with internally. So this method does not throw any exception <p> NoSuchElementException thrown when (both normal and push) connections  to the given rfd fail. We discard the rfd by doing nothing and return  null.
 * @exception InterruptedException this thread was interrupted while waitingto connect. Remember this rfd by putting it back into files and return null 
 */
private void establishConnection(){
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + _rfd + ""String_Node_Str"");
  if (_rfd == null)   return;
  if (_manager.isCancelled() || _manager.isPaused()) {
    _manager.addRFD(_rfd);
    return;
  }
  boolean needsPush=_rfd.needsPush();
synchronized (_manager) {
    int state=_manager.getState();
    if (_manager.getNumDownloaders() == 0 && state != ManagedDownloader.COMPLETE && state != ManagedDownloader.ABORTED && state != ManagedDownloader.GAVE_UP && state != ManagedDownloader.DISK_PROBLEM && state != ManagedDownloader.CORRUPT_FILE && state != ManagedDownloader.HASHING && state != ManagedDownloader.SAVING) {
      if (_interrupted)       return;
      _manager.setState(ManagedDownloader.CONNECTING,needsPush ? PUSH_CONNECT_TIME : NORMAL_CONNECT_TIME);
    }
  }
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + _rfd.getHost() + ""String_Node_Str""+ _rfd.getPort());
  DownloadStat.CONNECTION_ATTEMPTS.incrementStat();
  if (_rfd.isReplyToMulticast()) {
    try {
      _downloader=connectWithPush();
    }
 catch (    IOException e) {
      try {
        _downloader=connectDirectly();
      }
 catch (      IOException e2) {
        return;
      }
    }
    return;
  }
  if (!needsPush) {
    try {
      _downloader=connectDirectly();
    }
 catch (    IOException e) {
    }
  }
  if (_downloader == null) {
    try {
      _downloader=connectWithPush();
    }
 catch (    IOException e) {
      _manager.forgetRFD(_rfd);
    }
  }
  if (_downloader == null)   _manager.informMesh(_rfd,false);
 else   if (_interrupted) {
    _downloader.stop();
    _downloader=null;
  }
}","/** 
 * Returns an un-initialized (only established a TCP Connection,  no HTTP headers have been exchanged yet) connectable downloader  from the given list of locations. <p>  method tries to establish connection either by push or by normal ways. <p> If the connection fails for some reason, or needs a push the mesh needs  to be informed that this location failed.
 * @param rfd the RemoteFileDesc to connect to<p>  The following exceptions may be thrown within this method, but they are all dealt with internally. So this method does not throw any exception <p> NoSuchElementException thrown when (both normal and push) connections  to the given rfd fail. We discard the rfd by doing nothing and return  null.
 * @exception InterruptedException this thread was interrupted while waitingto connect. Remember this rfd by putting it back into files and return null 
 */
private void establishConnection(){
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + _rfd + ""String_Node_Str"");
  if (_rfd == null)   return;
  if (_manager.isCancelled() || _manager.isPaused()) {
    _manager.addRFD(_rfd);
    return;
  }
  boolean needsPush=_rfd.needsPush();
synchronized (_manager) {
    int state=_manager.getState();
    if (_manager.getNumDownloaders() == 0 && state != ManagedDownloader.COMPLETE && state != ManagedDownloader.ABORTED && state != ManagedDownloader.GAVE_UP && state != ManagedDownloader.DISK_PROBLEM && state != ManagedDownloader.CORRUPT_FILE && state != ManagedDownloader.HASHING && state != ManagedDownloader.SAVING) {
      if (_interrupted)       return;
      _manager.setState(ManagedDownloader.CONNECTING,needsPush ? PUSH_CONNECT_TIME : NORMAL_CONNECT_TIME);
    }
  }
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + _rfd.getHost() + ""String_Node_Str""+ _rfd.getPort());
  DownloadStat.CONNECTION_ATTEMPTS.incrementStat();
  if (_rfd.isReplyToMulticast()) {
    try {
      _downloader=connectWithPush();
    }
 catch (    IOException e) {
      try {
        _downloader=connectDirectly();
      }
 catch (      IOException e2) {
        return;
      }
    }
    return;
  }
  if (!needsPush) {
    try {
      _downloader=connectDirectly();
    }
 catch (    IOException e) {
    }
  }
  if (_downloader == null) {
    try {
      _downloader=connectWithPush();
    }
 catch (    IOException e) {
      if (needsPush)       _manager.forgetRFD(_rfd);
    }
  }
  if (_downloader == null)   _manager.informMesh(_rfd,false);
 else   if (_interrupted) {
    _downloader.stop();
    _downloader=null;
  }
}",0.9958489820122554
4359,"/** 
 * Like tryDownloads2, but does not deal with the library, cleaning up corrupt files, etc.  Caller should look at corruptState to determine if the file is corrupted; a return value of COMPLETE does not mean no corruptions where encountered.
 * @return COMPLETE if a file was successfully downloadedWAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try. COULDNT_MOVE_TO_LIBRARY couldn't write the incomplete file
 * @exception InterruptedException if the someone stop()'ed this download.stop() was called either because the user killed the download or a corruption was detected and they chose to kill and discard the download.  Calls to resume() do not result in InterruptedException.
 */
private int fireDownloadWorkers() throws InterruptedException {
  LOG.trace(""String_Node_Str"");
  int size=-1;
  while (true) {
    if (stopped || paused) {
      LOG.warn(""String_Node_Str"");
      throw new InterruptedException();
    }
    LOG.debug(""String_Node_Str"");
    try {
      commonOutFile.waitForPendingIfNeeded();
    }
 catch (    DiskException dio) {
      if (stopped || paused) {
        LOG.warn(""String_Node_Str"");
        throw new InterruptedException();
      }
      stop();
      return DISK_PROBLEM;
    }
    LOG.debug(""String_Node_Str"");
    if (commonOutFile.isComplete()) {
      killAllWorkers();
      LOG.trace(""String_Node_Str"");
      return COMPLETE;
    }
synchronized (this) {
      if (_workers.size() == 0 && !ranker.hasNonBusy()) {
        receivedNewSources=false;
        if (ranker.calculateWaitTime() > 0) {
          LOG.trace(""String_Node_Str"");
          return BUSY;
        }
 else {
          LOG.trace(""String_Node_Str"");
          return GAVE_UP;
        }
      }
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + _activeWorkers.size() + ""String_Node_Str""+ _workers.size());
      if (shouldStartWorker()) {
        ranker=getSourceRanker(ranker);
        RemoteFileDesc rfd=ranker.getBest();
        if (rfd != null) {
          if (rfd.isBusy())           addRFD(rfd);
 else           startWorker(rfd);
        }
      }
 else       if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"");
      try {
        this.wait(DownloadSettings.WORKER_INTERVAL.getValue());
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
}","/** 
 * Like tryDownloads2, but does not deal with the library, cleaning up corrupt files, etc.  Caller should look at corruptState to determine if the file is corrupted; a return value of COMPLETE does not mean no corruptions where encountered.
 * @return COMPLETE if a file was successfully downloadedWAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try. COULDNT_MOVE_TO_LIBRARY couldn't write the incomplete file
 * @exception InterruptedException if the someone stop()'ed this download.stop() was called either because the user killed the download or a corruption was detected and they chose to kill and discard the download.  Calls to resume() do not result in InterruptedException.
 */
private int fireDownloadWorkers() throws InterruptedException {
  LOG.trace(""String_Node_Str"");
  while (true) {
    if (stopped || paused) {
      LOG.warn(""String_Node_Str"");
      throw new InterruptedException();
    }
    LOG.debug(""String_Node_Str"");
    try {
      commonOutFile.waitForPendingIfNeeded();
    }
 catch (    DiskException dio) {
      if (stopped || paused) {
        LOG.warn(""String_Node_Str"");
        throw new InterruptedException();
      }
      stop();
      return DISK_PROBLEM;
    }
    LOG.debug(""String_Node_Str"");
    if (commonOutFile.isComplete()) {
      killAllWorkers();
      LOG.trace(""String_Node_Str"");
      return COMPLETE;
    }
synchronized (this) {
      if (_workers.size() == 0 && !ranker.hasNonBusy()) {
        receivedNewSources=false;
        if (ranker.calculateWaitTime() > 0) {
          LOG.trace(""String_Node_Str"");
          return BUSY;
        }
 else {
          LOG.trace(""String_Node_Str"");
          return GAVE_UP;
        }
      }
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + _activeWorkers.size() + ""String_Node_Str""+ _workers.size());
      if (shouldStartWorker()) {
        ranker=getSourceRanker(ranker);
        RemoteFileDesc rfd=ranker.getBest();
        if (rfd != null) {
          if (rfd.isBusy())           addRFD(rfd);
 else           startWorker(rfd);
        }
      }
 else       if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"");
      try {
        this.wait(DownloadSettings.WORKER_INTERVAL.getValue());
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
}",0.9969909729187564
4360,"/** 
 * Initializes a ManagedDownloader read from disk. Also used for internally initializing or resuming a normal download; there is no need to explicitly call this method in that case. After the call, this is in the queued state, at least for the moment.
 * @requires this is uninitialized or stopped, and allFiles, and incompleteFileManager are set
 * @modifies everything but the above fields 
 * @param deserialized True if this downloader is being initialized after being read from disk, false otherwise.
 */
public void initialize(DownloadManager manager,FileManager fileManager,DownloadCallback callback){
  this.manager=manager;
  this.fileManager=fileManager;
  this.callback=callback;
  currentRFDs=new HashSet();
  _activeWorkers=new LinkedList();
  _workers=new ArrayList();
  queuedWorkers=new HashMap();
  chatList=new DownloadChatList();
  browseList=new DownloadBrowseHostList();
  stealLock=new Object();
  stopped=false;
  paused=false;
  setState(QUEUED);
  miniRFDToLock=Collections.synchronizedMap(new HashMap());
  corruptState=NOT_CORRUPT_STATE;
  corruptStateLock=new Object();
  altLock=new Object();
  numMeasures=0;
  averageBandwidth=0f;
  queuePosition=Integer.MAX_VALUE;
  queuedVendor=""String_Node_Str"";
  triedLocatingSources=false;
  ranker=getSourceRanker(null);
  ranker.setMeshHandler(this);
  if (cachedRFDs.size() > 0 && downloadSHA1 == null) {
    for (Iterator iter=cachedRFDs.iterator(); iter.hasNext() && downloadSHA1 == null; ) {
      RemoteFileDesc rfd=(RemoteFileDesc)iter.next();
      downloadSHA1=rfd.getSHA1Urn();
      RouterService.getAltlocManager().addListener(downloadSHA1,this);
    }
  }
  verifyAllFiles();
  validAlts=new HashSet();
  invalidAlts=new FixedSizeExpiringSet(1000,60 * 60 * 1000L);
  recentInvalidAlts=new FixedSizeExpiringSet(10,10 * 60 * 1000L);
synchronized (this) {
    if (shouldInitAltLocs(deserializedFromDisk)) {
      initializeAlternateLocations();
    }
  }
  try {
    initializeIncompleteFile();
    initializeVerifyingFile();
  }
 catch (  IOException bad) {
    setState(DISK_PROBLEM);
    return;
  }
  setState(QUEUED);
}","/** 
 * Initializes a ManagedDownloader read from disk. Also used for internally initializing or resuming a normal download; there is no need to explicitly call this method in that case. After the call, this is in the queued state, at least for the moment.
 * @requires this is uninitialized or stopped, and allFiles, and incompleteFileManager are set
 * @modifies everything but the above fields 
 * @param deserialized True if this downloader is being initialized after being read from disk, false otherwise.
 */
public void initialize(DownloadManager manager,FileManager fileManager,DownloadCallback callback){
  this.manager=manager;
  this.fileManager=fileManager;
  this.callback=callback;
  currentRFDs=new HashSet();
  _activeWorkers=new LinkedList();
  _workers=new ArrayList();
  queuedWorkers=new HashMap();
  chatList=new DownloadChatList();
  browseList=new DownloadBrowseHostList();
  stealLock=new Object();
  stopped=false;
  paused=false;
  setState(QUEUED);
  miniRFDToLock=Collections.synchronizedMap(new HashMap());
  corruptState=NOT_CORRUPT_STATE;
  corruptStateLock=new Object();
  altLock=new Object();
  numMeasures=0;
  averageBandwidth=0f;
  queuePosition=Integer.MAX_VALUE;
  queuedVendor=""String_Node_Str"";
  triedLocatingSources=false;
  ranker=getSourceRanker(null);
  ranker.setMeshHandler(this);
  if (downloadSHA1 == null)   downloadSHA1=(URN)propertiesMap.get(SHA1_URN);
  for (Iterator iter=cachedRFDs.iterator(); iter.hasNext() && downloadSHA1 == null; ) {
    RemoteFileDesc rfd=(RemoteFileDesc)iter.next();
    downloadSHA1=rfd.getSHA1Urn();
    RouterService.getAltlocManager().addListener(downloadSHA1,this);
  }
  if (downloadSHA1 != null)   propertiesMap.put(SHA1_URN,downloadSHA1);
  verifyAllFiles();
  validAlts=new HashSet();
  invalidAlts=new FixedSizeExpiringSet(1000,60 * 60 * 1000L);
  recentInvalidAlts=new FixedSizeExpiringSet(10,10 * 60 * 1000L);
synchronized (this) {
    if (shouldInitAltLocs(deserializedFromDisk)) {
      initializeAlternateLocations();
    }
  }
  try {
    initializeIncompleteFile();
    initializeVerifyingFile();
  }
 catch (  IOException bad) {
    setState(DISK_PROBLEM);
    return;
  }
  setState(QUEUED);
}",0.9125987912598792
4361,"/** 
 * Handles state changes when inactive.
 */
public synchronized void handleInactivity(){
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + getState() + ""String_Node_Str""+ hasNewSources()+ ""String_Node_Str""+ getRemainingStateTime());
switch (getState()) {
case BUSY:
case WAITING_FOR_CONNECTIONS:
case ITERATIVE_GUESSING:
    if (getRemainingStateTime() <= 0)     setState(QUEUED);
  break;
case WAITING_FOR_RESULTS:
if (hasNewSources()) setState(QUEUED);
 else if (getRemainingStateTime() <= 0) setState(GAVE_UP);
break;
case WAITING_FOR_USER:
case GAVE_UP:
case QUEUED:
case PAUSED:
break;
default :
Assert.that(false,""String_Node_Str"" + getState() + ""String_Node_Str""+ _workers.size()+ ""String_Node_Str""+ _activeWorkers.size());
}
}","/** 
 * Handles state changes when inactive.
 */
public synchronized void handleInactivity(){
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + getState() + ""String_Node_Str""+ hasNewSources()+ ""String_Node_Str""+ getRemainingStateTime());
switch (getState()) {
case BUSY:
case WAITING_FOR_CONNECTIONS:
case ITERATIVE_GUESSING:
    if (getRemainingStateTime() <= 0 || hasNewSources())     setState(QUEUED);
  break;
case WAITING_FOR_RESULTS:
if (hasNewSources()) setState(QUEUED);
 else if (getRemainingStateTime() <= 0) setState(GAVE_UP);
break;
case WAITING_FOR_USER:
case GAVE_UP:
if (hasNewSources()) setState(QUEUED);
case QUEUED:
case PAUSED:
break;
default :
Assert.that(false,""String_Node_Str"" + getState() + ""String_Node_Str""+ _workers.size()+ ""String_Node_Str""+ _activeWorkers.size());
}
}",0.9627249357326478
4362,"private boolean addInternal(RemoteFileDesc host){
  if (sha1 == null) {
    if (host.getSHA1Urn() != null)     sha1=host.getSHA1Urn();
 else     return testedLocations.add(host);
  }
  if (myGUID == null && meshHandler != null) {
    myGUID=new GUID(GUID.makeGuid());
    RouterService.getMessageRouter().registerMessageListener(myGUID.bytes(),this);
  }
  if (knowsAboutHost(host))   return false;
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + host + ""String_Node_Str""+ host.getPushAddr());
  if (host.isReplyToMulticast())   return verifiedHosts.add(host);
  return newHosts.add(host);
}","private boolean addInternal(RemoteFileDesc host){
  if (sha1 == null) {
    if (host.getSHA1Urn() != null)     sha1=host.getSHA1Urn();
 else     return testedLocations.add(host);
  }
  if (knowsAboutHost(host) && running)   return false;
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + host + ""String_Node_Str""+ host.getPushAddr());
  boolean ret=false;
  if (host.isReplyToMulticast())   ret=verifiedHosts.add(host);
 else   ret=newHosts.add(host);
  ret=ret | !running;
  if (myGUID == null && meshHandler != null) {
    myGUID=new GUID(GUID.makeGuid());
    RouterService.getMessageRouter().registerMessageListener(myGUID.bytes(),this);
  }
  return ret;
}",0.565149136577708
4363,"/** 
 * Completes the download process, possibly sending off requeries that may later restart it. This essentially pumps the state of the download to different areas, depending on what is required or what has already occurred.
 */
private void completeDownload(int status){
  boolean complete;
synchronized (this) {
switch (status) {
case COMPLETE:
case DISK_PROBLEM:
case CORRUPT_FILE:
      setState(status);
    break;
case BUSY:
case GAVE_UP:
  if (stopped)   setState(ABORTED);
 else   if (paused)   setState(PAUSED);
 else   setState(status);
break;
default :
Assert.that(false,""String_Node_Str"" + status);
}
complete=isCompleted();
ranker.stop();
}
long now=System.currentTimeMillis();
manager.remove(this,complete);
if (LOG.isTraceEnabled()) LOG.trace(""String_Node_Str"" + getSaveFile().getName() + ""String_Node_Str""+ getState()+ ""String_Node_Str""+ numQueries+ ""String_Node_Str""+ lastQuerySent);
if (complete) ;
 else if (getState() == PAUSED) ;
 else if (tryGUESSing()) ;
 else if (getState() == BUSY) setState(BUSY,ranker.calculateWaitTime());
 else if (now - lastQuerySent < TIME_BETWEEN_REQUERIES) setState(WAITING_FOR_RESULTS,TIME_BETWEEN_REQUERIES - (now - lastQuerySent));
 else if (numQueries >= REQUERY_ATTEMPTS) setState(GAVE_UP);
 else if (shouldSendRequeryImmediately(numQueries)) sendRequery();
 else setState(WAITING_FOR_USER);
if (LOG.isTraceEnabled()) LOG.trace(""String_Node_Str"" + getSaveFile().getName() + ""String_Node_Str""+ getState()+ ""String_Node_Str""+ numQueries);
}","/** 
 * Completes the download process, possibly sending off requeries that may later restart it. This essentially pumps the state of the download to different areas, depending on what is required or what has already occurred.
 */
private void completeDownload(int status){
  boolean complete;
  int waitTime=0;
synchronized (this) {
switch (status) {
case COMPLETE:
case DISK_PROBLEM:
case CORRUPT_FILE:
      setState(status);
    break;
case BUSY:
case GAVE_UP:
  if (stopped)   setState(ABORTED);
 else   if (paused)   setState(PAUSED);
 else   setState(status);
break;
default :
Assert.that(false,""String_Node_Str"" + status);
}
complete=isCompleted();
waitTime=ranker.calculateWaitTime();
ranker.stop();
}
long now=System.currentTimeMillis();
manager.remove(this,complete);
if (LOG.isTraceEnabled()) LOG.trace(""String_Node_Str"" + getSaveFile().getName() + ""String_Node_Str""+ getState()+ ""String_Node_Str""+ numQueries+ ""String_Node_Str""+ lastQuerySent);
if (complete) ;
 else if (getState() == PAUSED) ;
 else if (tryGUESSing()) ;
 else if (getState() == BUSY) setState(BUSY,waitTime);
 else if (now - lastQuerySent < TIME_BETWEEN_REQUERIES) setState(WAITING_FOR_RESULTS,TIME_BETWEEN_REQUERIES - (now - lastQuerySent));
 else if (numQueries >= REQUERY_ATTEMPTS) setState(GAVE_UP);
 else if (shouldSendRequeryImmediately(numQueries)) sendRequery();
 else setState(WAITING_FOR_USER);
if (LOG.isTraceEnabled()) LOG.trace(""String_Node_Str"" + getSaveFile().getName() + ""String_Node_Str""+ getState()+ ""String_Node_Str""+ numQueries);
}",0.9705979517674264
4364,"private static void setSettings() throws Exception {
  ConnectionSettings.PORT.setValue(6346);
  ConnectionSettings.CONNECT_ON_STARTUP.setValue(false);
  ConnectionSettings.LOCAL_IS_PRIVATE.setValue(false);
  ConnectionSettings.EVER_ACCEPTED_INCOMING.setValue(true);
  ConnectionSettings.USE_GWEBCACHE.setValue(false);
  UltrapeerSettings.FORCE_ULTRAPEER_MODE.setValue(true);
  UltrapeerSettings.EVER_ULTRAPEER_CAPABLE.setValue(true);
}","private static void setSettings() throws Exception {
  ConnectionSettings.PORT.setValue(6346);
  ConnectionSettings.CONNECT_ON_STARTUP.setValue(false);
  ConnectionSettings.LOCAL_IS_PRIVATE.setValue(false);
  ConnectionSettings.EVER_ACCEPTED_INCOMING.setValue(true);
  ConnectionSettings.USE_GWEBCACHE.setValue(false);
  UltrapeerSettings.FORCE_ULTRAPEER_MODE.setValue(true);
  UltrapeerSettings.EVER_ULTRAPEER_CAPABLE.setValue(true);
  ConnectionSettings.PREFERENCING_ACTIVE.setValue(false);
}",0.9376344086021504
4365,"String getInfo(){
synchronized (_downloader) {
    return this + ""String_Node_Str"" + hashCode()+ ""String_Node_Str""+ _shouldRelease+ ""String_Node_Str""+ _interrupted+ ""String_Node_Str""+ _downloader.isActive()+ ""String_Node_Str""+ _downloader.getInitialReadingPoint()+ ""String_Node_Str""+ _downloader.getInitialWritingPoint()+ ""String_Node_Str""+ _downloader.getAmountToRead()+ ""String_Node_Str""+ _downloader.getAmountRead();
  }
}","String getInfo(){
  if (_downloader != null) {
synchronized (_downloader) {
      return this + ""String_Node_Str"" + hashCode()+ ""String_Node_Str""+ _shouldRelease+ ""String_Node_Str""+ _interrupted+ ""String_Node_Str""+ _downloader.isActive()+ ""String_Node_Str""+ _downloader.getInitialReadingPoint()+ ""String_Node_Str""+ _downloader.getInitialWritingPoint()+ ""String_Node_Str""+ _downloader.getAmountToRead()+ ""String_Node_Str""+ _downloader.getAmountRead();
    }
  }
 else   return ""String_Node_Str"";
}",0.9229098805646035
4366,"/** 
 * The main work to be done. If there are queries, get a unicast enabled UP, and send each Query to it.  Then sleep and try some more later...
 */
private void queryLoop(){
  UDPService udpService=UDPService.instance();
  while (_shouldRun) {
    try {
      waitForQueries();
      GUESSEndpoint toQuery=getUnicastHost();
      if (!_queryKeys.containsKey(toQuery)) {
        PingRequest pr=PingRequest.createQueryKeyRequest();
        udpService.send(pr,toQuery.getAddress(),toQuery.getPort());
        SentMessageStatHandler.UDP_PING_REQUESTS.addMessage(pr);
        continue;
      }
      QueryKey queryKey=((QueryKeyBundle)_queryKeys.get(toQuery))._queryKey;
      purgeGuidsInternal();
      boolean currentHostUsed=false;
synchronized (_queries) {
        Iterator iter=_queries.values().iterator();
        while (iter.hasNext()) {
          QueryBundle currQB=(QueryBundle)iter.next();
          if ((currQB._numResults > QueryBundle.MAX_RESULTS) || (currQB._hostsQueried.size() > QueryBundle.MAX_QUERIES))           _qGuidsToRemove.add(new GUID(currQB._qr.getGUID()));
 else           if (currQB._hostsQueried.contains(toQuery))           ;
 else {
            InetAddress ip=toQuery.getAddress();
            QueryRequest qrToSend=QueryRequest.createQueryKeyQuery(currQB._qr,queryKey);
            udpService.send(qrToSend,ip,toQuery.getPort());
            currentHostUsed=true;
            SentMessageStatHandler.UDP_QUERY_REQUESTS.addMessage(qrToSend);
            currQB._hostsQueried.add(toQuery);
          }
        }
      }
      if (!currentHostUsed) {
        addUnicastEndpoint(toQuery);
      }
synchronized (_qGuidsToRemove) {
        purgeGuidsInternal();
        _qGuidsToRemove.clear();
      }
      Thread.sleep(ITERATION_TIME);
    }
 catch (    InterruptedException ignored) {
    }
  }
}","/** 
 * The main work to be done. If there are queries, get a unicast enabled UP, and send each Query to it.  Then sleep and try some more later...
 */
private void queryLoop(){
  UDPService udpService=UDPService.instance();
  while (_shouldRun) {
    try {
      waitForQueries();
      GUESSEndpoint toQuery=getUnicastHost();
      if (!_queryKeys.containsKey(toQuery)) {
        PingRequest pr=PingRequest.createQueryKeyRequest();
        udpService.send(pr,toQuery.getAddress(),toQuery.getPort());
        SentMessageStatHandler.UDP_PING_REQUESTS.addMessage(pr);
        continue;
      }
      QueryKey queryKey=((QueryKeyBundle)_queryKeys.get(toQuery))._queryKey;
      purgeGuidsInternal();
      boolean currentHostUsed=false;
synchronized (_queries) {
        Iterator iter=_queries.values().iterator();
        while (iter.hasNext()) {
          QueryBundle currQB=(QueryBundle)iter.next();
          if (currQB._hostsQueried.size() > QueryBundle.MAX_QUERIES)           _qGuidsToRemove.add(new GUID(currQB._qr.getGUID()));
 else           if (currQB._hostsQueried.contains(toQuery))           ;
 else {
            InetAddress ip=toQuery.getAddress();
            QueryRequest qrToSend=QueryRequest.createQueryKeyQuery(currQB._qr,queryKey);
            udpService.send(qrToSend,ip,toQuery.getPort());
            currentHostUsed=true;
            SentMessageStatHandler.UDP_QUERY_REQUESTS.addMessage(qrToSend);
            currQB._hostsQueried.add(toQuery);
          }
        }
      }
      if (!currentHostUsed) {
        addUnicastEndpoint(toQuery);
      }
synchronized (_qGuidsToRemove) {
        purgeGuidsInternal();
        _qGuidsToRemove.clear();
      }
      Thread.sleep(ITERATION_TIME);
    }
 catch (    InterruptedException ignored) {
    }
  }
}",0.9855555555555556
4367,"/** 
 * Add results to a query so we can invalidate it when enough results are received.
 */
private void addResults(GUID queryGUID,int numResultsToAdd){
synchronized (_queries) {
    QueryBundle qb=(QueryBundle)_queries.get(queryGUID);
    if (qb != null)     qb._numResults+=numResultsToAdd;
  }
}","/** 
 * Add results to a query so we can invalidate it when enough results are received.
 */
private void addResults(GUID queryGUID,int numResultsToAdd){
synchronized (_queries) {
    QueryBundle qb=(QueryBundle)_queries.get(queryGUID);
    if (qb != null) {
      qb._numResults+=numResultsToAdd;
      if (qb._numResults > QueryBundle.MAX_RESULTS) {
synchronized (_qGuidsToRemove) {
          _qGuidsToRemove.add(new GUID(qb._qr.getGUID()));
          purgeGuidsInternal();
          _qGuidsToRemove.clear();
        }
      }
    }
  }
}",0.7127532777115614
4368,"/** 
 * Busy loop that listens on a port for udp messages and then logs them.
 */
private void udpLoop(int port){
  DatagramSocket socket=null;
  try {
    socket=new DatagramSocket(port);
    socket.setSoTimeout(1000);
    debug(""String_Node_Str"" + port);
  }
 catch (  SocketException e) {
    debug(""String_Node_Str"" + port);
    return;
  }
catch (  RuntimeException e) {
    debug(""String_Node_Str"" + port);
    return;
  }
  byte[] datagramBytes=new byte[BUFFER_SIZE];
  DatagramPacket datagram=new DatagramPacket(datagramBytes,BUFFER_SIZE);
  QueryKey.SecretKey key=QueryKey.generateSecretKey();
  QueryKey.SecretPad pad=QueryKey.generateSecretPad();
  while (shouldRun()) {
    try {
      socket.receive(datagram);
      byte[] data=datagram.getData();
      int length=datagram.getLength();
      try {
        InputStream in=new ByteArrayInputStream(data);
        Message message=Message.read(in);
        if (message == null)         continue;
        if (message instanceof PingRequest) {
          PingRequest pr=(PingRequest)message;
          pr.hop();
          if (pr.isQueryKeyRequest()) {
            QueryKey qk=QueryKey.getQueryKey(datagram.getAddress(),datagram.getPort(),key,pad);
            PingReply pRep=PingReply.createQueryKeyReply(pr.getGUID(),(byte)1,port,localhost,2,2,true,qk);
            pRep.hop();
            debug(""String_Node_Str"");
            QueryUnicaster.instance().handleQueryKeyPong(pRep);
          }
        }
synchronized (_messages) {
          _messages.add(message);
          _messages.notify();
        }
      }
 catch (      BadPacketException e) {
        continue;
      }
    }
 catch (    InterruptedIOException e) {
      continue;
    }
catch (    IOException e) {
      continue;
    }
  }
  debug(""String_Node_Str"" + port);
  socket.close();
}","/** 
 * Busy loop that listens on a port for udp messages and then logs them.
 */
private void udpLoop(int port){
  DatagramSocket socket=null;
  try {
    socket=new DatagramSocket(port);
    socket.setSoTimeout(1000);
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + port);
  }
 catch (  SocketException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + port);
    return;
  }
catch (  RuntimeException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + port);
    return;
  }
  byte[] datagramBytes=new byte[BUFFER_SIZE];
  DatagramPacket datagram=new DatagramPacket(datagramBytes,BUFFER_SIZE);
  QueryKey.SecretKey key=QueryKey.generateSecretKey();
  QueryKey.SecretPad pad=QueryKey.generateSecretPad();
  while (shouldRun()) {
    try {
      socket.receive(datagram);
      byte[] data=datagram.getData();
      int length=datagram.getLength();
      try {
        InputStream in=new ByteArrayInputStream(data);
        Message message=Message.read(in);
        if (message == null)         continue;
        if (message instanceof PingRequest) {
          PingRequest pr=(PingRequest)message;
          pr.hop();
          if (pr.isQueryKeyRequest()) {
            QueryKey qk=QueryKey.getQueryKey(datagram.getAddress(),datagram.getPort(),key,pad);
            PingReply pRep=PingReply.createQueryKeyReply(pr.getGUID(),(byte)1,port,localhost,2,2,true,qk);
            pRep.hop();
            LOG.debug(""String_Node_Str"");
            QueryUnicaster.instance().handleQueryKeyPong(pRep);
          }
        }
synchronized (_messages) {
          if (LOG.isDebugEnabled())           LOG.debug(""String_Node_Str"" + (_messages.size() + 1) + ""String_Node_Str""+ message);
          _messages.add(message);
          _messages.notify();
        }
      }
 catch (      BadPacketException e) {
        continue;
      }
    }
 catch (    InterruptedIOException e) {
      continue;
    }
catch (    IOException e) {
      continue;
    }
  }
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + port);
  socket.close();
}",0.9310699588477366
4369,"public void run(){
  udpLoop(5500 + index);
}","public void run(){
  udpLoop(5000 + index);
}",0.9777777777777776
4370,"public void testResultMaxOut() throws Exception {
  _messages.clear();
  _shouldRun=true;
  Thread[] udpLoopers=new Thread[NUM_UDP_LOOPS];
  for (int i=0; i < NUM_UDP_LOOPS; i++) {
    final int index=i;
    udpLoopers[i]=new Thread(){
      public void run(){
        udpLoop(5500 + index);
      }
    }
;
    udpLoopers[i].start();
    Thread.yield();
  }
  QueryRequest qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  QueryUnicaster.instance().addQuery(qr,null);
  InetAddress addr=null;
  addr=InetAddress.getByName(""String_Node_Str"");
  for (int i=0; i < NUM_UDP_LOOPS; i++) {
    QueryUnicaster.instance().addUnicastEndpoint(addr,5000 + i);
    if (i % 5 == 0) {
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException ignored) {
      }
    }
    QueryReply qRep=generateFakeReply(qr.getGUID(),getNumberBetween(25,35));
    QueryUnicaster.instance().handleQueryReply(qRep);
  }
  try {
    Thread.sleep(30 * 1000);
    assertEquals(""String_Node_Str"",0,QueryUnicaster.instance().getQueryNumber());
  }
 catch (  InterruptedException ignored) {
  }
  int numMessages=0, numQRs=0, numPings=0;
  while (!_messages.isEmpty()) {
    Message currMessage=(Message)_messages.remove(0);
    numMessages++;
    if (currMessage instanceof QueryRequest) {
      QueryRequest currQR=(QueryRequest)currMessage;
      assertTrue(currQR.getQuery().equals(""String_Node_Str""));
      numQRs++;
    }
 else     if (currMessage instanceof PingRequest) {
      numPings++;
    }
 else     fail(""String_Node_Str"" + currMessage);
  }
  assertEquals(""String_Node_Str"",numMessages,numPings + numQRs);
  assertLessThan(""String_Node_Str"",11,numQRs);
  assertGreaterThan(""String_Node_Str"",0,QueryUnicaster.instance().getUnicastEndpoints().size());
  debug(""String_Node_Str"" + numMessages);
  debug(""String_Node_Str"" + numQRs);
  debug(""String_Node_Str"" + numPings);
  _shouldRun=false;
  for (int i=0; i < NUM_UDP_LOOPS; i++)   udpLoopers[i].interrupt();
  try {
    Thread.sleep(2 * 1000);
  }
 catch (  InterruptedException ignored) {
  }
}","public void testResultMaxOut() throws Exception {
  _messages.clear();
  _shouldRun=true;
  Thread[] udpLoopers=new Thread[NUM_UDP_LOOPS];
  for (int i=0; i < NUM_UDP_LOOPS; i++) {
    final int index=i;
    udpLoopers[i]=new Thread(){
      public void run(){
        udpLoop(5000 + index);
      }
    }
;
    udpLoopers[i].start();
    Thread.yield();
  }
  QueryRequest qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  QueryUnicaster.instance().addQuery(qr,null);
  InetAddress addr=null;
  addr=InetAddress.getByName(""String_Node_Str"");
  for (int i=0; i < NUM_UDP_LOOPS; i++) {
    QueryUnicaster.instance().addUnicastEndpoint(addr,5000 + i);
    if (i % 5 == 0) {
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException ignored) {
      }
    }
    int low=250 / NUM_UDP_LOOPS + 1;
    int hi=254 / NUM_UDP_LOOPS + 1;
    if (low < 25)     low=25;
    if (hi < 35)     hi=35;
    QueryReply qRep=generateFakeReply(qr.getGUID(),getNumberBetween(low,hi));
    QueryUnicaster.instance().handleQueryReply(qRep);
  }
  try {
    Thread.sleep(30 * 1000);
    assertEquals(""String_Node_Str"",0,QueryUnicaster.instance().getQueryNumber());
  }
 catch (  InterruptedException ignored) {
  }
  int numMessages=0, numQRs=0, numPings=0;
  while (!_messages.isEmpty()) {
    Message currMessage=(Message)_messages.remove(0);
    numMessages++;
    if (currMessage instanceof QueryRequest) {
      QueryRequest currQR=(QueryRequest)currMessage;
      assertTrue(currQR.getQuery().equals(""String_Node_Str""));
      numQRs++;
    }
 else     if (currMessage instanceof PingRequest) {
      numPings++;
    }
 else     fail(""String_Node_Str"" + currMessage);
  }
  assertEquals(""String_Node_Str"",numMessages,numPings + numQRs);
  assertLessThan(""String_Node_Str"",11,numQRs);
  if (NUM_UDP_LOOPS > 10)   assertGreaterThan(""String_Node_Str"",0,QueryUnicaster.instance().getUnicastEndpoints().size());
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + numMessages);
    LOG.debug(""String_Node_Str"" + numQRs);
    LOG.debug(""String_Node_Str"" + numPings);
  }
  _shouldRun=false;
  for (int i=0; i < NUM_UDP_LOOPS; i++)   udpLoopers[i].interrupt();
  try {
    Thread.sleep(2 * 1000);
  }
 catch (  InterruptedException ignored) {
  }
}",0.8325624421831638
4371,"public void testQueries() throws Exception {
  Thread[] udpLoopers=new Thread[NUM_UDP_LOOPS];
  for (int i=0; i < NUM_UDP_LOOPS; i++) {
    final int index=i;
    udpLoopers[i]=new Thread(){
      public void run(){
        udpLoop(5000 + index);
      }
    }
;
    udpLoopers[i].start();
    Thread.yield();
  }
  InetAddress addr=null;
  addr=InetAddress.getByName(""String_Node_Str"");
  for (int i=0; i < NUM_UDP_LOOPS; i++) {
    QueryUnicaster.instance().addUnicastEndpoint(addr,5000 + i);
    if (i % 5 == 0) {
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
  QueryRequest qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  assertEquals(""String_Node_Str"",0,QueryUnicaster.instance().getQueryNumber());
  QueryUnicaster.instance().addQuery(qr,null);
  assertEquals(""String_Node_Str"",1,QueryUnicaster.instance().getQueryNumber());
  try {
    Thread.sleep(30 * 1000);
  }
 catch (  InterruptedException ignored) {
  }
  int numMessages=0, numQRs=0, numPings=0, numQKReqs=0;
  while (!_messages.isEmpty()) {
    Message currMessage=(Message)_messages.remove(0);
    numMessages++;
    if (currMessage instanceof QueryRequest) {
      QueryRequest currQR=(QueryRequest)currMessage;
      assertEquals(""String_Node_Str"",""String_Node_Str"",currQR.getQuery());
      numQRs++;
    }
 else     if (currMessage instanceof PingRequest) {
      numPings++;
      if (((PingRequest)currMessage).isQueryKeyRequest())       numQKReqs++;
    }
 else     fail(""String_Node_Str"" + currMessage);
  }
  assertEquals(""String_Node_Str"",numMessages,numPings + numQRs);
  assertLessThanOrEquals(""String_Node_Str"",numPings,numQRs);
  assertGreaterThan(""String_Node_Str"",0,numQRs);
  assertLessThanOrEquals(""String_Node_Str"",numQKReqs,numQRs);
  debug(""String_Node_Str"" + numMessages);
  debug(""String_Node_Str"" + numQRs);
  debug(""String_Node_Str"" + numPings);
  _shouldRun=false;
  for (int i=0; i < NUM_UDP_LOOPS; i++)   udpLoopers[i].interrupt();
  try {
    Thread.sleep(2 * 1000);
  }
 catch (  InterruptedException ignored) {
  }
  QueryReply qRep=generateFakeReply(qr.getGUID(),251);
  QueryUnicaster.instance().handleQueryReply(qRep);
}","public void testQueries() throws Exception {
  _messages.clear();
  _shouldRun=true;
  Thread[] udpLoopers=new Thread[NUM_UDP_LOOPS];
  for (int i=0; i < NUM_UDP_LOOPS; i++) {
    final int index=i;
    udpLoopers[i]=new Thread(){
      public void run(){
        udpLoop(5000 + index);
      }
    }
;
    udpLoopers[i].start();
    Thread.yield();
  }
  InetAddress addr=null;
  addr=InetAddress.getByName(""String_Node_Str"");
  for (int i=0; i < NUM_UDP_LOOPS; i++) {
    QueryUnicaster.instance().addUnicastEndpoint(addr,5000 + i);
    if (i % 5 == 0) {
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
  QueryRequest qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  assertEquals(""String_Node_Str"",0,QueryUnicaster.instance().getQueryNumber());
  QueryUnicaster.instance().addQuery(qr,null);
  assertEquals(""String_Node_Str"",1,QueryUnicaster.instance().getQueryNumber());
  try {
    Thread.sleep(30 * 1000);
  }
 catch (  InterruptedException ignored) {
  }
  int numMessages=0, numQRs=0, numPings=0, numQKReqs=0;
  while (!_messages.isEmpty()) {
    Message currMessage=(Message)_messages.remove(0);
    numMessages++;
    if (currMessage instanceof QueryRequest) {
      QueryRequest currQR=(QueryRequest)currMessage;
      assertEquals(""String_Node_Str"",""String_Node_Str"",currQR.getQuery());
      numQRs++;
    }
 else     if (currMessage instanceof PingRequest) {
      numPings++;
      if (((PingRequest)currMessage).isQueryKeyRequest())       numQKReqs++;
    }
 else     fail(""String_Node_Str"" + currMessage);
  }
  assertEquals(""String_Node_Str"",numMessages,numPings + numQRs);
  assertLessThanOrEquals(""String_Node_Str"",numPings,numQRs);
  assertGreaterThan(""String_Node_Str"",0,numQRs);
  assertLessThanOrEquals(""String_Node_Str"",numQKReqs,numQRs);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + numMessages);
    LOG.debug(""String_Node_Str"" + numQRs);
    LOG.debug(""String_Node_Str"" + numPings);
  }
  _shouldRun=false;
  for (int i=0; i < NUM_UDP_LOOPS; i++)   udpLoopers[i].interrupt();
  try {
    Thread.sleep(2 * 1000);
  }
 catch (  InterruptedException ignored) {
  }
  QueryReply qRep=generateFakeReply(qr.getGUID(),251);
  QueryUnicaster.instance().handleQueryReply(qRep);
}",0.9790365744870652
4372,"public void setUp() throws Exception {
  _rs.start();
}","public void setUp() throws Exception {
  _rs.start();
  QueryUnicaster qu=QueryUnicaster.instance();
  PrivilegedAccessor.invokeMethod(qu,""String_Node_Str"",null);
  ConnectionSettings.DO_NOT_BOOTSTRAP.setValue(true);
  ConnectionSettings.CONNECT_ON_STARTUP.setValue(false);
}",0.3333333333333333
4373,"public void run(){
  try {
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + intvl);
synchronized (fos) {
      fos.seek(intvl.low);
      fos.write(buf,0,intvl.high - intvl.low + 1);
    }
synchronized (VerifyingFile.this) {
      pendingBlocks.delete(intvl);
      partialBlocks.add(intvl);
    }
    verifyChunks();
  }
 catch (  IOException diskIO) {
synchronized (VerifyingFile.this) {
      storedException=diskIO;
    }
  }
 finally {
synchronized (VerifyingFile.this) {
      VerifyingFile.this.notify();
    }
  }
}","public void run(){
  verifyChunks();
synchronized (VerifyingFile.this) {
    VerifyingFile.this.notify();
  }
}",0.3174114021571648
4374,"/** 
 * sets the HashTree the current download will use.  That affects whether we do overlap checking.
 */
public synchronized void setHashTree(HashTree tree){
  hashTree=tree;
}","/** 
 * sets the HashTree the current download will use.  That affects whether we do overlap checking.
 */
public synchronized void setHashTree(HashTree tree){
  HashTree previoius=hashTree;
  hashTree=tree;
  if (previoius == null && pendingBlocks.getSize() == 0 && partialBlocks.getSize() > 0)   QUEUE.add(new EmptyVerifier());
}",0.6601178781925344
4375,"private String getFileName(RemoteFileDesc[] rfds,String fileName){
  for (int i=0; i < rfds.length && fileName == null; i++) {
    fileName=rfds[0].getFileName();
  }
  return fileName;
}","private String getFileName(RemoteFileDesc[] rfds,String fileName){
  for (int i=0; i < rfds.length && fileName == null; i++) {
    fileName=rfds[i].getFileName();
  }
  return fileName;
}",0.9946524064171124
4376,"/** 
 * @param data data read from network
 * @param offset offset within that data
 */
public static PushEndpoint fromBytes(byte[] data,int offset) throws BadPacketException {
  byte[] tmp=new byte[6];
  byte[] guid=new byte[16];
  Set proxies=new IpPortSet();
  IpPort addr=null;
  boolean hasAddr=false;
  int number=data[offset] & SIZE_MASK;
  int features=data[offset] & FEATURES_MASK;
  int version=(data[offset] & FWT_VERSION_MASK) >> 3;
  if (data.length - offset < HEADER_SIZE + number * PROXY_SIZE)   throw new BadPacketException(""String_Node_Str"");
  if (data.length - offset >= HEADER_SIZE + (number + 1) * PROXY_SIZE && version > 0)   hasAddr=true;
  System.arraycopy(data,++offset,guid,0,16);
  offset+=16;
  if (hasAddr) {
    String address=NetworkUtils.ip2string(data,offset);
    offset+=4;
    int port=ByteOrder.ubytes2int(ByteOrder.leb2short(data,offset));
    offset+=2;
    try {
      addr=new IpPortImpl(address,port);
    }
 catch (    UnknownHostException hmm) {
      throw new BadPacketException(hmm.getMessage());
    }
  }
  for (int i=0; i < number; i++) {
    System.arraycopy(data,offset,tmp,0,6);
    offset+=6;
    proxies.add(QueryReply.IPPortCombo.getCombo(tmp));
  }
  PushEndpoint pe=new PushEndpoint(guid,proxies,features,version,addr);
  pe.updateProxies(true);
  return pe;
}","/** 
 * Constructs a PushEndpoint from binary representation
 */
public static PushEndpoint fromBytes(DataInputStream dais) throws BadPacketException, IOException {
  byte[] guid=new byte[16];
  Set proxies=new IpPortSet();
  IpPort addr=null;
  boolean hasAddr=false;
  int header=dais.read() & 0xFF;
  int number=header & SIZE_MASK;
  int features=header & FEATURES_MASK;
  int version=(header & FWT_VERSION_MASK) >> 3;
  dais.readFully(guid);
  if (version > 0) {
    byte[] host=new byte[6];
    dais.readFully(host);
    addr=QueryReply.IPPortCombo.getCombo(host);
  }
  byte[] tmp=new byte[6];
  for (int i=0; i < number; i++) {
    dais.readFully(tmp);
    proxies.add(QueryReply.IPPortCombo.getCombo(tmp));
  }
  PushEndpoint pe=new PushEndpoint(guid,proxies,features,version,addr);
  pe.updateProxies(true);
  return pe;
}",0.4457887389483481
4377,"private void toBytes(byte[] where,int offset,Set proxies,IpPort address){
  int neededSpace=getSizeBytes(proxies);
  int supportsFWT=supportsFWTVersion();
  if (address != null && supportsFWT > 0)   neededSpace+=6;
  if (where.length - offset < neededSpace)   throw new IllegalArgumentException(""String_Node_Str"");
  where[offset]=(byte)(Math.min(4,proxies.size()) | getFeatures() | supportsFWT << 3);
  System.arraycopy(_clientGUID,0,where,++offset,16);
  offset+=16;
  if (address != null && supportsFWT > 0) {
    byte[] addr=address.getInetAddress().getAddress();
    int port=address.getPort();
    System.arraycopy(addr,0,where,offset,4);
    offset+=4;
    ByteOrder.short2leb((short)port,where,offset);
    offset+=2;
  }
  int i=0;
  for (Iterator iter=proxies.iterator(); iter.hasNext() && i < 4; ) {
    IpPort ppi=(IpPort)iter.next();
    byte[] addr=ppi.getInetAddress().getAddress();
    short port=(short)ppi.getPort();
    System.arraycopy(addr,0,where,offset,4);
    offset+=4;
    ByteOrder.short2leb(port,where,offset);
    offset+=2;
    i++;
  }
}","private void toBytes(byte[] where,int offset,Set proxies,IpPort address,int FWTVersion){
  int neededSpace=getSizeBytes(proxies);
  if (address != null) {
    if (FWTVersion > 0)     neededSpace+=6;
  }
 else   FWTVersion=0;
  if (where.length - offset < neededSpace)   throw new IllegalArgumentException(""String_Node_Str"");
  where[offset]=(byte)(Math.min(4,proxies.size()) | getFeatures() | FWTVersion << 3);
  System.arraycopy(_clientGUID,0,where,++offset,16);
  offset+=16;
  if (address != null) {
    byte[] addr=address.getInetAddress().getAddress();
    int port=address.getPort();
    System.arraycopy(addr,0,where,offset,4);
    offset+=4;
    ByteOrder.short2leb((short)port,where,offset);
    offset+=2;
  }
  int i=0;
  for (Iterator iter=proxies.iterator(); iter.hasNext() && i < 4; ) {
    IpPort ppi=(IpPort)iter.next();
    byte[] addr=ppi.getInetAddress().getAddress();
    short port=(short)ppi.getPort();
    System.arraycopy(addr,0,where,offset,4);
    offset+=4;
    ByteOrder.short2leb(port,where,offset);
    offset+=2;
    i++;
  }
}",0.5907808090310442
4378,"/** 
 * reads firewalled alternate locations from an input stream
 */
private final Set readPushLocs(DataInputStream dais) throws IOException, BadPacketException {
  int size=dais.readUnsignedShort();
  byte[] altlocs=new byte[size];
  dais.readFully(altlocs);
  Set ret=new HashSet();
  ret.addAll(NetworkUtils.unpackPushEPs(altlocs));
  return ret;
}","/** 
 * reads firewalled alternate locations from an input stream
 */
private final Set readPushLocs(DataInputStream dais) throws IOException, BadPacketException {
  int size=dais.readUnsignedShort();
  byte[] altlocs=new byte[size];
  dais.readFully(altlocs);
  Set ret=new HashSet();
  ret.addAll(NetworkUtils.unpackPushEPs(new ByteArrayInputStream(altlocs)));
  return ret;
}",0.9452054794520548
4379,"/** 
 * @return a collection of <tt>PushEndpoint</tt> objects
 * @throws BadPacketException if parsing failed.
 */
public static List unpackPushEPs(byte[] data) throws BadPacketException {
  List ret=new LinkedList();
  int i=0;
  while (i < data.length) {
    PushEndpoint current=PushEndpoint.fromBytes(data,i);
    i+=PushEndpoint.getSizeBytes(current.getProxies());
    if (!current.getAddress().equals(RemoteFileDesc.BOGUS_IP))     i+=6;
    ret.add(current);
  }
  return Collections.unmodifiableList(ret);
}","public static List unpackPushEPs(InputStream is) throws BadPacketException, IOException {
  List ret=new LinkedList();
  DataInputStream dais=new DataInputStream(is);
  while (dais.available() > 0)   ret.add(PushEndpoint.fromBytes(dais));
  return Collections.unmodifiableList(ret);
}",0.075187969924812
4380,"/** 
 * Browses the files on the specified host and port.
 * @param host The IP of the host you want to browse.
 * @param port The port of the host you want to browse.
 * @param proxies the <tt>Set</tt> of push proxies to try
 * @param canDoFWTransfer Whether or not this guy can do a firewalltransfer.
 */
public void browseHost(String host,int port,Set proxies,boolean canDoFWTransfer){
  if (!NetworkUtils.isValidPort(port) || !NetworkUtils.isValidAddress(host)) {
    failed();
    return;
  }
  LOG.trace(""String_Node_Str"");
  setState(STARTED);
  int shouldPush=needsPush(host);
  LOG.trace(""String_Node_Str"" + shouldPush);
  boolean shouldTryPush=false;
switch (shouldPush) {
case 0:
    try {
      setState(DIRECTLY_CONNECTING);
      Socket socket=Sockets.connect(host,port,DIRECT_CONNECT_TIME);
      LOG.trace(""String_Node_Str"");
      browseExchange(socket);
    }
 catch (    IOException ioe) {
      shouldTryPush=true;
    }
  if (!shouldTryPush)   break;
case 1:
if (_serventID == null) {
  failed();
}
 else {
  RemoteFileDesc fakeRFD=new RemoteFileDesc(host,port,SPECIAL_INDEX,""String_Node_Str"",0,_serventID.bytes(),0,false,0,false,null,null,false,false,""String_Node_Str"",0l,proxies,-1,canDoFWTransfer ? UDPConnection.VERSION : 0);
synchronized (_pushedHosts) {
    _pushedHosts.put(_serventID,new PushRequestDetails(this));
  }
  LOG.trace(""String_Node_Str"");
  setState(PUSHING);
  RouterService.getDownloadManager().sendPush(fakeRFD);
}
break;
}
}","/** 
 * Browses the files on the specified host and port.
 * @param host The IP of the host you want to browse.
 * @param port The port of the host you want to browse.
 * @param proxies the <tt>Set</tt> of push proxies to try
 * @param canDoFWTransfer Whether or not this guy can do a firewalltransfer.
 */
public void browseHost(String host,int port,Set proxies,boolean canDoFWTransfer){
  if (!NetworkUtils.isValidPort(port) || !NetworkUtils.isValidAddress(host)) {
    failed();
    return;
  }
  LOG.trace(""String_Node_Str"");
  setState(STARTED);
  int shouldPush=needsPush(host);
  LOG.trace(""String_Node_Str"" + shouldPush);
  boolean shouldTryPush=false;
switch (shouldPush) {
case 0:
    try {
      setState(DIRECTLY_CONNECTING);
      Socket socket=Sockets.connect(host,port,DIRECT_CONNECT_TIME);
      LOG.trace(""String_Node_Str"");
      browseExchange(socket);
    }
 catch (    IOException ioe) {
      shouldTryPush=true;
    }
  if (!shouldTryPush)   break;
case 1:
if (_serventID == null) {
  failed();
}
 else {
  RemoteFileDesc fakeRFD=new RemoteFileDesc(host,port,SPECIAL_INDEX,""String_Node_Str"",0,_serventID.bytes(),0,false,0,false,null,null,false,true,""String_Node_Str"",0l,proxies,-1,canDoFWTransfer ? UDPConnection.VERSION : 0);
synchronized (_pushedHosts) {
    _pushedHosts.put(_serventID,new PushRequestDetails(this));
  }
  LOG.trace(""String_Node_Str"");
  setState(PUSHING);
  RouterService.getDownloadManager().sendPush(fakeRFD);
}
break;
}
}",0.9976166155941436
4381,"/** 
 * iterates through the pending blocks and checks if the recent write has created some (verifiable) full chunks.  Its not possible to verify more than two chunks per method call unless the downloader is being deserialized from disk
 */
private synchronized List findVerifyableBlocks(){
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + partialBlocks);
  List verifyable=new ArrayList(2);
  List partial=partialBlocks.getAllIntervalsAsList();
  int chunkSize=getChunkSize();
  int lastChunkOffset=completedSize - (completedSize % chunkSize);
  for (int i=0; i < partial.size(); i++) {
    Interval current=(Interval)partial.get(i);
    int lowChunkOffset=current.low - current.low % chunkSize;
    if (current.low % chunkSize != 0)     lowChunkOffset+=chunkSize;
    while (current.high >= lowChunkOffset + chunkSize - 1) {
      Interval complete=new Interval(lowChunkOffset,lowChunkOffset + chunkSize - 1);
      verifyable.add(complete);
      lowChunkOffset+=chunkSize;
    }
  }
  if (!partial.isEmpty()) {
    Interval last=(Interval)partial.get(partial.size() - 1);
    if (last.high == completedSize - 1 && last.low <= lastChunkOffset) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"");
      verifyable.add(new Interval(lastChunkOffset,last.high));
    }
  }
  return verifyable;
}","/** 
 * iterates through the pending blocks and checks if the recent write has created some (verifiable) full chunks.  Its not possible to verify more than two chunks per method call unless the downloader is being deserialized from disk
 */
private synchronized List findVerifyableBlocks(){
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + partialBlocks);
  List verifyable=new ArrayList(2);
  List partial=partialBlocks.getAllIntervalsAsList();
  int chunkSize=getChunkSize();
  for (int i=0; i < partial.size(); i++) {
    Interval current=(Interval)partial.get(i);
    int lowChunkOffset=current.low - current.low % chunkSize;
    if (current.low % chunkSize != 0)     lowChunkOffset+=chunkSize;
    while (current.high >= lowChunkOffset + chunkSize - 1) {
      Interval complete=new Interval(lowChunkOffset,lowChunkOffset + chunkSize - 1);
      verifyable.add(complete);
      lowChunkOffset+=chunkSize;
    }
  }
  if (!partial.isEmpty()) {
    int lastChunkOffset=completedSize - (completedSize % chunkSize);
    if (lastChunkOffset == completedSize)     lastChunkOffset-=chunkSize;
    Interval last=(Interval)partial.get(partial.size() - 1);
    if (last.high == completedSize - 1 && last.low <= lastChunkOffset) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"");
      verifyable.add(new Interval(lastChunkOffset,last.high));
    }
  }
  return verifyable;
}",0.922850844966936
4382,"public void testBasicOutOfBandRequest() throws Exception {
  DatagramPacket pack=null;
  UDP_ACCESS=new DatagramSocket();
{
    drainAll();
    PingReply pong=PingReply.create(GUID.makeGuid(),(byte)4,UDP_ACCESS.getLocalPort(),InetAddress.getLocalHost().getAddress(),10,10,true,900,true);
    ULTRAPEER[0].send(pong);
    ULTRAPEER[0].flush();
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    PingRequest ping=(PingRequest)Message.read(in);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pong=PingReply.create(ping.getGUID(),(byte)4,UDP_ACCESS.getLocalPort(),InetAddress.getLocalHost().getAddress(),10,10,true,900,true);
    pong.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,pack.getAddress(),pack.getPort());
    UDP_ACCESS.send(pack);
  }
{
    MessagesSupportedVendorMessage support=MessagesSupportedVendorMessage.instance();
    ULTRAPEER[0].send(support);
    ULTRAPEER[0].flush();
    byte[] cbGuid=null;
    int cbPort=-1;
    while (cbGuid == null) {
      try {
        Message m=ULTRAPEER[0].receive(TIMEOUT);
        if (m instanceof UDPConnectBackVendorMessage) {
          UDPConnectBackVendorMessage udp=(UDPConnectBackVendorMessage)m;
          cbGuid=udp.getConnectBackGUID().bytes();
          cbPort=udp.getConnectBackPort();
        }
      }
 catch (      Exception ie) {
        fail(""String_Node_Str"",ie);
      }
    }
    PingRequest pr=new PingRequest(cbGuid,(byte)1,(byte)0);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pr.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,ULTRAPEER[0].getInetAddress(),cbPort);
    UDP_ACCESS.send(pack);
  }
  drainAll();
  QueryRequest query=QueryRequest.createOutOfBandQuery(""String_Node_Str"",InetAddress.getLocalHost().getAddress(),UDP_ACCESS.getLocalPort());
  query.hop();
  ULTRAPEER[0].send(query);
  ULTRAPEER[0].flush();
  PrivilegedAccessor.setValue(RouterService.getUdpService(),""String_Node_Str"",new Boolean(true));
  PrivilegedAccessor.setValue(RouterService.getUdpService(),""String_Node_Str"",new Boolean(true));
  Message message=null;
  while (!(message instanceof ReplyNumberVendorMessage)) {
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    message=Message.read(in);
    assertTrue(!((message instanceof QueryReply) && (Arrays.equals(message.getGUID(),query.getGUID()))));
  }
  assertTrue(Arrays.equals(query.getGUID(),message.getGUID()));
  ReplyNumberVendorMessage reply=(ReplyNumberVendorMessage)message;
  assertEquals(2,reply.getNumResults());
  assertTrue(reply.canReceiveUnsolicited());
  query=QueryRequest.createOutOfBandQuery(""String_Node_Str"",InetAddress.getLocalHost().getAddress(),UDP_ACCESS.getLocalPort());
  query.hop();
  UDPService service=RouterService.getUdpService();
  PrivilegedAccessor.setValue(service,""String_Node_Str"",new Boolean(false));
  assertFalse(RouterService.getUdpService().canReceiveUnsolicited());
  assertTrue(query.desiresOutOfBandReplies());
  ULTRAPEER[1].send(query);
  ULTRAPEER[1].flush();
  message=null;
  while (!(message instanceof ReplyNumberVendorMessage)) {
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    message=Message.read(in);
    assertTrue(!((message instanceof QueryReply) && (Arrays.equals(message.getGUID(),query.getGUID()))));
  }
  assertTrue(Arrays.equals(query.getGUID(),message.getGUID()));
  reply=(ReplyNumberVendorMessage)message;
  assertEquals(2,reply.getNumResults());
  assertFalse(reply.canReceiveUnsolicited());
  query=QueryRequest.createOutOfBandQuery(""String_Node_Str"",InetAddress.getLocalHost().getAddress(),UDP_ACCESS.getLocalPort());
  query.hop();
  PrivilegedAccessor.setValue(service,""String_Node_Str"",new Boolean(true));
  ULTRAPEER[2].send(query);
  ULTRAPEER[2].flush();
  message=null;
  while (!(message instanceof ReplyNumberVendorMessage)) {
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    message=Message.read(in);
    assertTrue(!((message instanceof QueryReply) && (Arrays.equals(message.getGUID(),query.getGUID()))));
  }
  assertTrue(Arrays.equals(query.getGUID(),message.getGUID()));
  reply=(ReplyNumberVendorMessage)message;
  assertEquals(2,reply.getNumResults());
  assertTrue(reply.canReceiveUnsolicited());
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  LimeACKVendorMessage ack=new LimeACKVendorMessage(new GUID(message.getGUID()),reply.getNumResults());
  ack.write(baos);
  pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,pack.getAddress(),pack.getPort());
  UDP_ACCESS.send(pack);
  while (!(message instanceof QueryReply)) {
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    message=Message.read(in);
  }
  assertTrue(Arrays.equals(message.getGUID(),ack.getGUID()));
  assertEquals(1,((QueryReply)message).getResultCount());
  message=null;
  while (!(message instanceof QueryReply)) {
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    message=Message.read(in);
  }
  assertTrue(Arrays.equals(message.getGUID(),ack.getGUID()));
  assertEquals(1,((QueryReply)message).getResultCount());
  baos=new ByteArrayOutputStream();
  ack.write(baos);
  pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,pack.getAddress(),pack.getPort());
  UDP_ACCESS.send(pack);
  try {
    while (true) {
      UDP_ACCESS.setSoTimeout(500);
      pack=new DatagramPacket(new byte[1000],1000);
      UDP_ACCESS.receive(pack);
      InputStream in=new ByteArrayInputStream(pack.getData());
      message=Message.read(in);
      assertTrue(!((message instanceof QueryReply) && (Arrays.equals(message.getGUID(),ack.getGUID()))));
    }
  }
 catch (  IOException expected) {
  }
}","public void testBasicOutOfBandRequest() throws Exception {
  PrivilegedAccessor.setValue(RouterService.getUdpService(),""String_Node_Str"",new Boolean(true));
  PrivilegedAccessor.setValue(RouterService.getUdpService(),""String_Node_Str"",new Boolean(true));
  DatagramPacket pack=null;
  UDP_ACCESS=new DatagramSocket();
  drainAll();
  QueryRequest query=QueryRequest.createOutOfBandQuery(""String_Node_Str"",InetAddress.getLocalHost().getAddress(),UDP_ACCESS.getLocalPort());
  query.hop();
  ULTRAPEER[0].send(query);
  ULTRAPEER[0].flush();
  Message message=null;
  while (!(message instanceof ReplyNumberVendorMessage)) {
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    message=Message.read(in);
    assertTrue(!((message instanceof QueryReply) && (Arrays.equals(message.getGUID(),query.getGUID()))));
  }
  assertTrue(Arrays.equals(query.getGUID(),message.getGUID()));
  ReplyNumberVendorMessage reply=(ReplyNumberVendorMessage)message;
  assertEquals(2,reply.getNumResults());
  assertTrue(reply.canReceiveUnsolicited());
  query=QueryRequest.createOutOfBandQuery(""String_Node_Str"",InetAddress.getLocalHost().getAddress(),UDP_ACCESS.getLocalPort());
  query.hop();
  UDPService service=RouterService.getUdpService();
  PrivilegedAccessor.setValue(service,""String_Node_Str"",new Boolean(false));
  assertFalse(RouterService.getUdpService().canReceiveUnsolicited());
  assertTrue(query.desiresOutOfBandReplies());
  ULTRAPEER[1].send(query);
  ULTRAPEER[1].flush();
  message=null;
  while (!(message instanceof ReplyNumberVendorMessage)) {
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    message=Message.read(in);
    assertTrue(!((message instanceof QueryReply) && (Arrays.equals(message.getGUID(),query.getGUID()))));
  }
  assertTrue(Arrays.equals(query.getGUID(),message.getGUID()));
  reply=(ReplyNumberVendorMessage)message;
  assertEquals(2,reply.getNumResults());
  assertFalse(reply.canReceiveUnsolicited());
  query=QueryRequest.createOutOfBandQuery(""String_Node_Str"",InetAddress.getLocalHost().getAddress(),UDP_ACCESS.getLocalPort());
  query.hop();
  PrivilegedAccessor.setValue(service,""String_Node_Str"",new Boolean(true));
  ULTRAPEER[2].send(query);
  ULTRAPEER[2].flush();
  message=null;
  while (!(message instanceof ReplyNumberVendorMessage)) {
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    message=Message.read(in);
    assertTrue(!((message instanceof QueryReply) && (Arrays.equals(message.getGUID(),query.getGUID()))));
  }
  assertTrue(Arrays.equals(query.getGUID(),message.getGUID()));
  reply=(ReplyNumberVendorMessage)message;
  assertEquals(2,reply.getNumResults());
  assertTrue(reply.canReceiveUnsolicited());
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  LimeACKVendorMessage ack=new LimeACKVendorMessage(new GUID(message.getGUID()),reply.getNumResults());
  ack.write(baos);
  pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,pack.getAddress(),pack.getPort());
  UDP_ACCESS.send(pack);
  while (!(message instanceof QueryReply)) {
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    message=Message.read(in);
  }
  assertTrue(Arrays.equals(message.getGUID(),ack.getGUID()));
  assertEquals(1,((QueryReply)message).getResultCount());
  message=null;
  while (!(message instanceof QueryReply)) {
    UDP_ACCESS.setSoTimeout(500);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    message=Message.read(in);
  }
  assertTrue(Arrays.equals(message.getGUID(),ack.getGUID()));
  assertEquals(1,((QueryReply)message).getResultCount());
  baos=new ByteArrayOutputStream();
  ack.write(baos);
  pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,pack.getAddress(),pack.getPort());
  UDP_ACCESS.send(pack);
  try {
    while (true) {
      UDP_ACCESS.setSoTimeout(500);
      pack=new DatagramPacket(new byte[1000],1000);
      UDP_ACCESS.receive(pack);
      InputStream in=new ByteArrayInputStream(pack.getData());
      message=Message.read(in);
      assertTrue(!((message instanceof QueryReply) && (Arrays.equals(message.getGUID(),ack.getGUID()))));
    }
  }
 catch (  IOException expected) {
  }
}",0.5336426914153132
4383,"private boolean addInternal(RemoteFileDesc host){
  if (sha1 == null) {
    if (host.getSHA1Urn() != null)     sha1=host.getSHA1Urn();
 else     return false;
  }
  if (myGUID == null) {
    myGUID=new GUID(GUID.makeGuid());
    RouterService.getMessageRouter().registerMessageListener(myGUID.bytes(),this);
    running=true;
  }
  if (knowsAboutHost(host))   return false;
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + host + ""String_Node_Str""+ host.getPushAddr());
  if (host.isReplyToMulticast())   return verifiedHosts.add(host);
  return newHosts.add(host);
}","private boolean addInternal(RemoteFileDesc host){
  if (sha1 == null) {
    if (host.getSHA1Urn() != null)     sha1=host.getSHA1Urn();
 else     return testedLocations.add(host);
  }
  if (myGUID == null) {
    myGUID=new GUID(GUID.makeGuid());
    RouterService.getMessageRouter().registerMessageListener(myGUID.bytes(),this);
    running=true;
  }
  if (knowsAboutHost(host))   return false;
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + host + ""String_Node_Str""+ host.getPushAddr());
  if (host.isReplyToMulticast())   return verifiedHosts.add(host);
  return newHosts.add(host);
}",0.9744897959183674
4384,"public void testPushProxySetup() throws Exception {
  DatagramPacket pack=null;
  UDP_ACCESS=new DatagramSocket(9000);
  testUP[0].send(MessagesSupportedVendorMessage.instance());
  testUP[0].flush();
  Message m=null;
  do {
    m=testUP[0].receive(TIMEOUT);
  }
 while (!(m instanceof PushProxyRequest));
  PushProxyAcknowledgement ack=new PushProxyAcknowledgement(InetAddress.getLocalHost(),6355,new GUID(m.getGUID()));
  testUP[0].send(ack);
  testUP[0].flush();
{
    drainAll();
    PingReply pong=PingReply.create(GUID.makeGuid(),(byte)4,UDP_ACCESS.getLocalPort(),InetAddress.getLocalHost().getAddress(),10,10,true,900,true);
    testUP[0].send(pong);
    testUP[0].flush();
    UDP_ACCESS.setSoTimeout(2000);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    PingRequest ping=(PingRequest)Message.read(in);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pong=PingReply.create(ping.getGUID(),(byte)4,UDP_ACCESS.getLocalPort(),InetAddress.getLocalHost().getAddress(),10,10,true,900,true);
    pong.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,pack.getAddress(),pack.getPort());
    UDP_ACCESS.send(pack);
  }
  Thread.sleep(1000);
  assertTrue(UDPService.instance().canReceiveSolicited());
}","public void testPushProxySetup() throws Exception {
  DatagramPacket pack=null;
  testUP[0].send(MessagesSupportedVendorMessage.instance());
  testUP[0].flush();
  Message m=null;
  do {
    m=testUP[0].receive(TIMEOUT);
  }
 while (!(m instanceof PushProxyRequest));
  PushProxyAcknowledgement ack=new PushProxyAcknowledgement(InetAddress.getLocalHost(),6355,new GUID(m.getGUID()));
  testUP[0].send(ack);
  testUP[0].flush();
  Thread.sleep(1000);
  assertTrue(UDPService.instance().canReceiveSolicited());
}",0.4430769230769231
4385,"public void testStartsUDPTransfer() throws Exception {
  PrivilegedAccessor.setValue(RouterService.getAcceptor(),""String_Node_Str"",new byte[]{(byte)10,(byte)07,(byte)19,(byte)76});
  drain(testUP[0]);
  drainUDP();
  assertEquals(2,RouterService.getFileManager().getNumFiles());
  QueryRequest query=new QueryRequest(GUID.makeGuid(),(byte)2,0 | QueryRequest.SPECIAL_MINSPEED_MASK | QueryRequest.SPECIAL_FIREWALL_MASK| QueryRequest.SPECIAL_FWTRANS_MASK,""String_Node_Str"",""String_Node_Str"",null,null,null,false,Message.N_UNKNOWN,false,0,false,0);
  testUP[0].send(query);
  testUP[0].flush();
  Message m=null;
  do {
    m=testUP[0].receive(TIMEOUT);
  }
 while (!(m instanceof QueryReply));
  QueryReply reply=(QueryReply)m;
  assertEquals(reply.getIP(),""String_Node_Str"",reply.getIP());
  assertTrue(reply.getSupportsFWTransfer());
  assertEquals(UDPConnection.VERSION,reply.getFWTransferVersion());
  assertNotNull(reply.getPushProxies());
  Set proxies=reply.getPushProxies();
  assertEquals(1,proxies.size());
  Iterator iter=proxies.iterator();
  IpPort ppi=(IpPort)iter.next();
  assertEquals(ppi.getPort(),6355);
  assertTrue(ppi.getInetAddress().equals(InetAddress.getLocalHost()));
  ServerSocket ss=new ServerSocket(9000);
  ss.setReuseAddress(true);
  ss.setSoTimeout(TIMEOUT);
  PushRequest pr=new PushRequest(GUID.makeGuid(),(byte)1,RouterService.getMessageRouter()._clientGUID,PushRequest.FW_TRANS_INDEX,InetAddress.getLocalHost().getAddress(),9000);
  testUP[0].send(pr);
  testUP[0].flush();
  while (true) {
    DatagramPacket pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    Message syn=Message.read(in);
    if (syn instanceof SynMessage)     break;
  }
  try {
    Socket givSock=ss.accept();
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  ss.close();
}","public void testStartsUDPTransfer() throws Exception {
  PrivilegedAccessor.setValue(RouterService.getAcceptor(),""String_Node_Str"",new byte[]{(byte)10,(byte)07,(byte)19,(byte)76});
  drain(testUP[0]);
  drainUDP();
  assertEquals(2,RouterService.getFileManager().getNumFiles());
  QueryRequest query=new QueryRequest(GUID.makeGuid(),(byte)2,0 | QueryRequest.SPECIAL_MINSPEED_MASK | QueryRequest.SPECIAL_FIREWALL_MASK| QueryRequest.SPECIAL_FWTRANS_MASK,""String_Node_Str"",""String_Node_Str"",null,null,null,false,Message.N_UNKNOWN,false,0,false,0);
  testUP[0].send(query);
  testUP[0].flush();
  Message m=null;
  do {
    m=testUP[0].receive(TIMEOUT);
  }
 while (!(m instanceof QueryReply));
  QueryReply reply=(QueryReply)m;
  assertEquals(reply.getIP(),""String_Node_Str"",reply.getIP());
  assertTrue(reply.getSupportsFWTransfer());
  assertEquals(UDPConnection.VERSION,reply.getFWTransferVersion());
  assertNotNull(reply.getPushProxies());
  Set proxies=reply.getPushProxies();
  assertEquals(1,proxies.size());
  Iterator iter=proxies.iterator();
  IpPort ppi=(IpPort)iter.next();
  assertEquals(ppi.getPort(),6355);
  assertTrue(ppi.getInetAddress().equals(((Connection)rs.getConnectionManager().getConnections().get(0)).getInetAddress()));
  ServerSocket ss=new ServerSocket(9000);
  ss.setReuseAddress(true);
  ss.setSoTimeout(TIMEOUT);
  PushRequest pr=new PushRequest(GUID.makeGuid(),(byte)1,RouterService.getMessageRouter()._clientGUID,PushRequest.FW_TRANS_INDEX,InetAddress.getLocalHost().getAddress(),9000);
  testUP[0].send(pr);
  testUP[0].flush();
  while (true) {
    DatagramPacket pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    Message syn=Message.read(in);
    if (syn instanceof SynMessage)     break;
  }
  try {
    Socket givSock=ss.accept();
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  ss.close();
}",0.9801291604570294
4386,"/** 
 * Determines whether or not the specified message is valid for setting LimeWire as accepting UDP messages (solicited or unsolicited).
 */
private boolean isValidForIncoming(GUID match,GUID guidReceived,InetSocketAddress addr){
  if (!match.equals(guidReceived))   return false;
  String host=addr.getAddress().getHostAddress();
  return !ConnectionSettings.LOCAL_IS_PRIVATE.getValue() || !RouterService.getConnectionManager().isConnectedTo(host);
}","/** 
 * Determines whether or not the specified message is valid for setting LimeWire as accepting UDP messages (solicited or unsolicited).
 */
private boolean isValidForIncoming(GUID match,GUID guidReceived,InetSocketAddress addr){
  if (!match.equals(guidReceived))   return false;
  String host=addr.getAddress().getHostAddress();
  return !RouterService.getConnectionManager().isConnectedTo(host) && (!NetworkUtils.isPrivateAddress(addr.getAddress()) || !ConnectionSettings.LOCAL_IS_PRIVATE.getValue());
}",0.818276220145379
4387,"/** 
 * Updates internal state of the UDP Service. 
 */
private void updateState(Message message,InetSocketAddress addr){
  if (!isGUESSCapable()) {
    if (message instanceof PingRequest) {
      GUID guid=new GUID(message.getGUID());
      if (isValidForIncoming(CONNECT_BACK_GUID,guid,addr))       _acceptedUnsolicitedIncoming=true;
      _lastUnsolicitedIncomingTime=System.currentTimeMillis();
    }
 else     if (message instanceof PingReply) {
      GUID guid=new GUID(message.getGUID());
      if (!isValidForIncoming(SOLICITED_PING_GUID,guid,addr))       return;
      _acceptedSolicitedIncoming=true;
      PingReply r=(PingReply)message;
      if (r.getMyPort() != 0) {
synchronized (this) {
          _numReceivedIPPongs++;
          if (_numReceivedIPPongs == 1)           _lastReportedPort=r.getMyPort();
 else           if (_lastReportedPort != r.getMyPort()) {
            _portStable=false;
            _lastReportedPort=r.getMyPort();
          }
        }
      }
    }
  }
  if (message instanceof ReplyNumberVendorMessage)   _lastUnsolicitedIncomingTime=System.currentTimeMillis();
}","/** 
 * Updates internal state of the UDP Service. 
 */
private void updateState(Message message,InetSocketAddress addr){
  if (!isGUESSCapable()) {
    if (message instanceof PingRequest) {
      GUID guid=new GUID(message.getGUID());
      if (isValidForIncoming(CONNECT_BACK_GUID,guid,addr)) {
        _acceptedUnsolicitedIncoming=true;
      }
      _lastUnsolicitedIncomingTime=System.currentTimeMillis();
    }
 else     if (message instanceof PingReply) {
      GUID guid=new GUID(message.getGUID());
      if (!isValidForIncoming(SOLICITED_PING_GUID,guid,addr))       return;
      _acceptedSolicitedIncoming=true;
      PingReply r=(PingReply)message;
      if (r.getMyPort() != 0) {
synchronized (this) {
          _numReceivedIPPongs++;
          if (_numReceivedIPPongs == 1)           _lastReportedPort=r.getMyPort();
 else           if (_lastReportedPort != r.getMyPort()) {
            _portStable=false;
            _lastReportedPort=r.getMyPort();
          }
        }
      }
    }
  }
  if (message instanceof ReplyNumberVendorMessage)   _lastUnsolicitedIncomingTime=System.currentTimeMillis();
}",0.9945945945945946
4388,"/** 
 * Informs the receiver that the message is shutdown.
 */
public synchronized void shutdown(){
  if (shutdown)   return;
  shutdown=true;
  receiver.messagingClosed();
}","/** 
 * Informs the receiver that the message is shutdown.
 */
public void shutdown(){
synchronized (this) {
    if (shutdown)     return;
    shutdown=true;
  }
  receiver.messagingClosed();
}",0.8773841961852861
4389,"/** 
 * @return the first message of type <pre>type</pre>.  Read messages withinthe time out, so it's possible to wait upto almost 2 * timeout for this method to return
 */
public static Message getFirstInstanceOfMessage(Socket socket,Class type,int timeout) throws IOException, BadPacketException {
  int oldTimeout=socket.getSoTimeout();
  try {
    for (int i=0; i < 200; i++) {
      if (socket.isClosed())       return null;
      try {
        socket.setSoTimeout(timeout);
        Message m=Message.read(socket.getInputStream(),Message.N_TCP);
        if (type.isInstance(m))         return m;
 else         if (m instanceof PingRequest)         ;
 else         if (m == null)         return null;
        i=0;
      }
 catch (      InterruptedIOException iiox) {
        return null;
      }
    }
  }
  finally {
    socket.setSoTimeout(oldTimeout);
  }
  return null;
}","/** 
 * @return the first message of type <pre>type</pre>.  Read messages withinthe time out, so it's possible to wait upto almost 2 * timeout for this method to return
 */
public static Message getFirstInstanceOfMessage(Socket socket,Class type,int timeout) throws IOException, BadPacketException {
  int oldTimeout=socket.getSoTimeout();
  try {
    for (int i=0; i < 200; i++) {
      if (socket.isClosed())       return null;
      try {
        socket.setSoTimeout(timeout);
        Message m=Message.read(socket.getInputStream(),Message.N_TCP);
        if (type.isInstance(m))         return m;
 else         if (m == null)         return null;
        i=0;
      }
 catch (      InterruptedIOException iiox) {
        return null;
      }
    }
  }
  finally {
    socket.setSoTimeout(oldTimeout);
  }
  return null;
}",0.9683098591549296
4390,"public static Message getFirstInstanceOfMessageType(Connection c,Class type,int timeout) throws BadPacketException {
  for (int i=0; i < 200; i++) {
    if (!c.isOpen()) {
      return null;
    }
    try {
      Message m=c.receive(timeout);
      if (m instanceof RouteTableMessage)       ;
 else       if (m instanceof PingRequest)       ;
 else       if (type.isInstance(m))       return m;
      i=0;
    }
 catch (    InterruptedIOException ie) {
      return null;
    }
catch (    IOException iox) {
    }
  }
  throw new RuntimeException(""String_Node_Str"");
}","public static Message getFirstInstanceOfMessageType(Connection c,Class type,int timeout) throws BadPacketException {
  for (int i=0; i < 200; i++) {
    if (!c.isOpen()) {
      return null;
    }
    try {
      Message m=c.receive(timeout);
      if (type.isInstance(m))       return m;
      i=0;
    }
 catch (    InterruptedIOException ie) {
      return null;
    }
catch (    IOException iox) {
    }
  }
  throw new RuntimeException(""String_Node_Str"");
}",0.8970873786407767
4391,"/** 
 * Sends the message with the specified, pre-calculated priority.
 * @param m the <tt>Message</tt> to send
 * @param priority the priority to send the message with
 */
private void send(Message m,int priority){
  if (!supportsGGEP())   m=m.stripExtendedPayload();
  int smh=softMaxHops;
  if ((smh > -1) && (m instanceof QueryRequest) && (m.getHops() >= smh))   return;
  repOk();
  Assert.that(_outputQueue != null,""String_Node_Str"");
synchronized (_outputQueueLock) {
    _numMessagesSent++;
    _outputQueue[priority].add(m);
    int dropped=_outputQueue[priority].resetDropped();
    addSentDropped(dropped);
    _queued+=1 - dropped;
    _lastPriority=priority;
    _outputQueueLock.notify();
  }
  repOk();
}","/** 
 * Sends the message with the specified, pre-calculated priority.
 * @param m the <tt>Message</tt> to send
 * @param priority the priority to send the message with
 */
private void send(Message m,int priority){
  if (!supportsGGEP())   m=m.stripExtendedPayload();
  int smh=hopsFlowMax;
  if ((smh > -1) && (m instanceof QueryRequest) && (m.getHops() >= smh))   return;
  repOk();
  Assert.that(_outputQueue != null,""String_Node_Str"");
synchronized (_outputQueueLock) {
    _numMessagesSent++;
    _outputQueue[priority].add(m);
    int dropped=_outputQueue[priority].resetDropped();
    addSentDropped(dropped);
    _queued+=1 - dropped;
    _lastPriority=priority;
    _outputQueueLock.notify();
  }
  repOk();
}",0.9888734353268428
4392,"protected void handleVendorMessage(VendorMessage vm){
  super.handleVendorMessage(vm);
  if (vm instanceof HopsFlowVendorMessage) {
    HopsFlowVendorMessage hops=(HopsFlowVendorMessage)vm;
    if (isSupernodeClientConnection())     setBusy(hops.getHopValue() == 0);
    softMaxHops=hops.getHopValue();
  }
 else   if (vm instanceof PushProxyAcknowledgement) {
    PushProxyAcknowledgement ack=(PushProxyAcknowledgement)vm;
    if (Arrays.equals(ack.getGUID(),RouterService.getMessageRouter()._clientGUID)) {
      pushProxyPort=ack.getListeningPort();
      pushProxyAddr=ack.getListeningAddress();
    }
  }
 else   if (vm instanceof CapabilitiesVM) {
    CapabilitiesVM capVM=(CapabilitiesVM)vm;
    if (capVM.supportsSIMPP() > SimppManager.instance().getVersion()) {
      SimppRequestVM simppReq=new SimppRequestVM();
      send(simppReq);
    }
    if (capVM.supportsUpdate() > UpdateHandler.instance().getLatestId()) {
      send(new UpdateRequest());
    }
  }
 else   if (vm instanceof MessagesSupportedVendorMessage) {
    if (isClientSupernodeConnection() && (remoteHostSupportsLeafGuidance() >= 0)) {
      SearchResultHandler srh=RouterService.getSearchResultHandler();
      List queries=srh.getQueriesToReSend();
      for (Iterator i=queries.iterator(); i.hasNext(); )       send((Message)i.next());
    }
    if (remoteHostSupportsPushProxy() > -1) {
      GUID clientGUID=new GUID(RouterService.getMessageRouter()._clientGUID);
      PushProxyRequest req=new PushProxyRequest(clientGUID);
      send(req);
    }
    if (!UDPService.instance().canReceiveUnsolicited() && (_numUDPConnectBackRequests < MAX_UDP_CONNECT_BACK_ATTEMPTS) && (remoteHostSupportsUDPRedirect() > -1)) {
      GUID connectBackGUID=RouterService.getUDPConnectBackGUID();
      Message udp=new UDPConnectBackVendorMessage(RouterService.getPort(),connectBackGUID);
      send(udp);
      _numUDPConnectBackRequests++;
    }
    if (!RouterService.acceptedIncomingConnection() && (_numTCPConnectBackRequests < MAX_TCP_CONNECT_BACK_ATTEMPTS) && (remoteHostSupportsTCPRedirect() > -1)) {
      Message tcp=new TCPConnectBackVendorMessage(RouterService.getPort());
      send(tcp);
      _numTCPConnectBackRequests++;
    }
  }
}","protected void handleVendorMessage(VendorMessage vm){
  super.handleVendorMessage(vm);
  if (vm instanceof HopsFlowVendorMessage) {
    HopsFlowVendorMessage hops=(HopsFlowVendorMessage)vm;
    if (isSupernodeClientConnection())     setBusy(hops.getHopValue() == 0);
    hopsFlowMax=hops.getHopValue();
  }
 else   if (vm instanceof PushProxyAcknowledgement) {
    PushProxyAcknowledgement ack=(PushProxyAcknowledgement)vm;
    if (Arrays.equals(ack.getGUID(),RouterService.getMessageRouter()._clientGUID)) {
      pushProxyPort=ack.getListeningPort();
      pushProxyAddr=ack.getListeningAddress();
    }
  }
 else   if (vm instanceof CapabilitiesVM) {
    CapabilitiesVM capVM=(CapabilitiesVM)vm;
    if (capVM.supportsSIMPP() > SimppManager.instance().getVersion()) {
      SimppRequestVM simppReq=new SimppRequestVM();
      send(simppReq);
    }
    if (capVM.supportsUpdate() > UpdateHandler.instance().getLatestId()) {
      send(new UpdateRequest());
    }
  }
 else   if (vm instanceof MessagesSupportedVendorMessage) {
    if (isClientSupernodeConnection() && (remoteHostSupportsLeafGuidance() >= 0)) {
      SearchResultHandler srh=RouterService.getSearchResultHandler();
      List queries=srh.getQueriesToReSend();
      for (Iterator i=queries.iterator(); i.hasNext(); )       send((Message)i.next());
    }
    if (remoteHostSupportsPushProxy() > -1) {
      GUID clientGUID=new GUID(RouterService.getMessageRouter()._clientGUID);
      PushProxyRequest req=new PushProxyRequest(clientGUID);
      send(req);
    }
    if (!UDPService.instance().canReceiveUnsolicited() && (_numUDPConnectBackRequests < MAX_UDP_CONNECT_BACK_ATTEMPTS) && (remoteHostSupportsUDPRedirect() > -1)) {
      GUID connectBackGUID=RouterService.getUDPConnectBackGUID();
      Message udp=new UDPConnectBackVendorMessage(RouterService.getPort(),connectBackGUID);
      send(udp);
      _numUDPConnectBackRequests++;
    }
    if (!RouterService.acceptedIncomingConnection() && (_numTCPConnectBackRequests < MAX_TCP_CONNECT_BACK_ATTEMPTS) && (remoteHostSupportsTCPRedirect() > -1)) {
      Message tcp=new TCPConnectBackVendorMessage(RouterService.getPort());
      send(tcp);
      _numTCPConnectBackRequests++;
    }
  }
}",0.9963833634719712
4393,"/** 
 * Check to see how many leaves' tables would be included in the LastHop QRT
 * @return number of leaf tables which would be included in a LastHop QRT
 */
private int getTotalNumberOfLeavesQRTsIncluded(){
  int leaves=0;
  Iterator it=cm.getConnections().iterator();
  while (it.hasNext()) {
    if (((ManagedConnectionCountQRT)it.next())._qrtIncluded)     leaves++;
  }
  return leaves;
}","/** 
 * Check to see how many leaves' tables would be included in the LastHop QRT
 * @return number of leaf tables which would be included in a LastHop QRT
 */
private int getTotalNumberOfLeavesQRTsIncluded(){
  int leaves=0;
  Iterator it=cm.getInitializedClientConnections().iterator();
  while (it.hasNext()) {
    ManagedConnectionCountQRT mc=((ManagedConnectionCountQRT)it.next());
    if (mc._qrtIncluded)     leaves++;
  }
  return leaves;
}",0.9216152019002376
4394,"/** 
 * Sends a GET request using an already open socket, and reads all  headers.  The actual ranges downloaded MAY NOT be the same as the 'start' and 'stop' parameters, as HTTP allows the server to respond with any satisfiable subrange of the request. Users of this class should examine getInitialReadingPoint() and getAmountToRead() to determine what the effective start & stop ranges are, and update external datastructures appropriately. int newStart = dloader.getInitialReadingPoint(); int newStop = (dloader.getAmountToRead() - 1) + newStart; // INCLUSIVE or int newStop = dloader.getAmountToRead() + newStart; // EXCLUSIVE <p>
 * @param start The byte at which the HTTPDownloader should begin
 * @param stop the index just past the last byte to read;stop-1 is the last byte the HTTPDownloader should download <p>
 * @exception TryAgainLaterException the host is busy
 * @exception FileNotFoundException the host doesn't recognize the file
 * @exception NotSharingException the host isn't sharing files (BearShare)
 * @exception IOException miscellaneous  error 
 * @exception QueuedException uploader has queued us
 * @exception RangeNotAvailableException uploader has ranges other than requested
 * @exception ProblemReadingHeaderException could not parse headers
 * @exception UnknownCodeException unknown response code
 */
public void connectHTTP(int start,int stop,boolean supportQueueing) throws IOException, TryAgainLaterException, FileNotFoundException, NotSharingException, QueuedException, RangeNotAvailableException, ProblemReadingHeaderException, UnknownCodeException {
  if (start < 0)   throw new IllegalArgumentException(""String_Node_Str"" + start);
  if (stop <= start)   throw new IllegalArgumentException(""String_Node_Str"" + stop + ""String_Node_Str""+ start+ ""String_Node_Str"");
  _amountToRead=stop - start;
  _totalAmountRead+=_amountRead;
  _amountRead=0;
  _initialReadingPoint=start;
  _bodyConsumed=false;
  _contentLength=0;
  Set features=new HashSet();
  OutputStreamWriter osw=new OutputStreamWriter(_output);
  BufferedWriter out=new BufferedWriter(osw);
  String startRange=java.lang.String.valueOf(_initialReadingPoint);
  out.write(""String_Node_Str"" + _rfd.getUrl().getFile() + ""String_Node_Str"");
  out.write(""String_Node_Str"" + _host + ""String_Node_Str""+ _port+ ""String_Node_Str"");
  out.write(""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"");
  if (supportQueueing) {
    out.write(""String_Node_Str"");
    features.add(ConstantHTTPHeaderValue.QUEUE_FEATURE);
  }
  features.add(ConstantHTTPHeaderValue.PUSH_LOCS_FEATURE);
  if (!RouterService.acceptedIncomingConnection() && UDPService.instance().canDoFWT())   features.add(ConstantHTTPHeaderValue.FWT_PUSH_LOCS_FEATURE);
  if (isPartialFileValid() && (RouterService.acceptedIncomingConnection() || _wantsFalts)) {
    AlternateLocation me=AlternateLocation.create(_rfd.getSHA1Urn());
    if (me != null)     addSuccessfulAltLoc(me);
  }
  URN sha1=_rfd.getSHA1Urn();
  if (sha1 != null)   HTTPUtils.writeHeader(HTTPHeaderName.GNUTELLA_CONTENT_URN,sha1,out);
  Set writeClone=null;
synchronized (_goodLocs) {
    if (_goodLocs.size() > 0) {
      writeClone=new HashSet();
      Iterator iter=_goodLocs.iterator();
      while (iter.hasNext()) {
        Object next=iter.next();
        writeClone.add(next);
        _writtenGoodLocs.add(next);
      }
      _goodLocs.clear();
    }
  }
  if (writeClone != null)   HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,new HTTPHeaderValueCollection(writeClone),out);
  writeClone=null;
synchronized (_badLocs) {
    if (_badLocs.size() > 0) {
      writeClone=new HashSet();
      Iterator iter=_badLocs.iterator();
      while (iter.hasNext()) {
        Object next=iter.next();
        writeClone.add(next);
        _writtenBadLocs.add(next);
      }
      _badLocs.clear();
    }
  }
  if (writeClone != null)   HTTPUtils.writeHeader(HTTPHeaderName.NALTS,new HTTPHeaderValueCollection(writeClone),out);
  if (_wantsFalts) {
    writeClone=null;
synchronized (_goodPushLocs) {
      if (_goodPushLocs.size() > 0) {
        writeClone=new HashSet();
        Iterator iter=_goodPushLocs.iterator();
        while (iter.hasNext()) {
          PushAltLoc next=(PushAltLoc)iter.next();
          if (next.getPushAddress().getProxies().isEmpty()) {
            if (next.getPushAddress() instanceof PushEndpointForSelf)             continue;
 else             Assert.that(false,""String_Node_Str"");
          }
          writeClone.add(next);
          _writtenPushLocs.add(next);
        }
        _goodPushLocs.clear();
      }
    }
    if (writeClone != null)     HTTPUtils.writeHeader(HTTPHeaderName.FALT_LOCATION,new HTTPHeaderValueCollection(writeClone),out);
    writeClone=null;
synchronized (_badPushLocs) {
      if (_badPushLocs.size() > 0) {
        writeClone=new HashSet();
        Iterator iter=_badPushLocs.iterator();
        while (iter.hasNext()) {
          PushAltLoc next=(PushAltLoc)iter.next();
          Assert.that(!next.getPushAddress().getProxies().isEmpty());
          writeClone.add(next);
          _writtenBadPushLocs.add(next);
        }
        _badPushLocs.clear();
      }
    }
    if (writeClone != null)     HTTPUtils.writeHeader(HTTPHeaderName.BFALT_LOCATION,new HTTPHeaderValueCollection(writeClone),out);
  }
  out.write(""String_Node_Str"" + startRange + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str"");
  _requestedInterval=new Interval(_initialReadingPoint,stop - 1);
  if (ChatSettings.CHAT_ENABLED.getValue() && RouterService.acceptedIncomingConnection() && !NetworkUtils.isPrivateAddress(RouterService.getAddress())) {
    int port=RouterService.getPort();
    String host=NetworkUtils.ip2string(RouterService.getAddress());
    out.write(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str"");
    features.add(ConstantHTTPHeaderValue.BROWSE_FEATURE);
    if (ChatSettings.CHAT_ENABLED.getValue()) {
      out.write(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str"");
      features.add(ConstantHTTPHeaderValue.CHAT_FEATURE);
    }
  }
  if (features.size() > 0) {
    HTTPUtils.writeHeader(HTTPHeaderName.FEATURES,new HTTPHeaderValueCollection(features),out);
  }
  out.write(""String_Node_Str"");
  out.flush();
  readHeaders();
}","/** 
 * Sends a GET request using an already open socket, and reads all  headers.  The actual ranges downloaded MAY NOT be the same as the 'start' and 'stop' parameters, as HTTP allows the server to respond with any satisfiable subrange of the request. Users of this class should examine getInitialReadingPoint() and getAmountToRead() to determine what the effective start & stop ranges are, and update external datastructures appropriately. int newStart = dloader.getInitialReadingPoint(); int newStop = (dloader.getAmountToRead() - 1) + newStart; // INCLUSIVE or int newStop = dloader.getAmountToRead() + newStart; // EXCLUSIVE <p>
 * @param start The byte at which the HTTPDownloader should begin
 * @param stop the index just past the last byte to read;stop-1 is the last byte the HTTPDownloader should download <p>
 * @exception TryAgainLaterException the host is busy
 * @exception FileNotFoundException the host doesn't recognize the file
 * @exception NotSharingException the host isn't sharing files (BearShare)
 * @exception IOException miscellaneous  error 
 * @exception QueuedException uploader has queued us
 * @exception RangeNotAvailableException uploader has ranges other than requested
 * @exception ProblemReadingHeaderException could not parse headers
 * @exception UnknownCodeException unknown response code
 */
public void connectHTTP(int start,int stop,boolean supportQueueing) throws IOException, TryAgainLaterException, FileNotFoundException, NotSharingException, QueuedException, RangeNotAvailableException, ProblemReadingHeaderException, UnknownCodeException {
  if (start < 0)   throw new IllegalArgumentException(""String_Node_Str"" + start);
  if (stop <= start)   throw new IllegalArgumentException(""String_Node_Str"" + stop + ""String_Node_Str""+ start+ ""String_Node_Str"");
  _amountToRead=stop - start;
  _totalAmountRead+=_amountRead;
  _amountRead=0;
  _initialReadingPoint=start;
  _bodyConsumed=false;
  _contentLength=0;
  Set features=new HashSet();
  OutputStreamWriter osw=new OutputStreamWriter(_output);
  BufferedWriter out=new BufferedWriter(osw);
  String startRange=java.lang.String.valueOf(_initialReadingPoint);
  out.write(""String_Node_Str"" + _rfd.getUrl().getFile() + ""String_Node_Str"");
  out.write(""String_Node_Str"" + _host + ""String_Node_Str""+ _port+ ""String_Node_Str"");
  out.write(""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"");
  if (supportQueueing) {
    out.write(""String_Node_Str"");
    features.add(ConstantHTTPHeaderValue.QUEUE_FEATURE);
  }
  if (RouterService.acceptedIncomingConnection() || UDPService.instance().canDoFWT()) {
    features.add(ConstantHTTPHeaderValue.PUSH_LOCS_FEATURE);
    if (!RouterService.acceptedIncomingConnection())     features.add(ConstantHTTPHeaderValue.FWT_PUSH_LOCS_FEATURE);
  }
  if (isPartialFileValid() && (RouterService.acceptedIncomingConnection() || _wantsFalts)) {
    AlternateLocation me=AlternateLocation.create(_rfd.getSHA1Urn());
    if (me != null)     addSuccessfulAltLoc(me);
  }
  URN sha1=_rfd.getSHA1Urn();
  if (sha1 != null)   HTTPUtils.writeHeader(HTTPHeaderName.GNUTELLA_CONTENT_URN,sha1,out);
  Set writeClone=null;
synchronized (_goodLocs) {
    if (_goodLocs.size() > 0) {
      writeClone=new HashSet();
      Iterator iter=_goodLocs.iterator();
      while (iter.hasNext()) {
        Object next=iter.next();
        writeClone.add(next);
        _writtenGoodLocs.add(next);
      }
      _goodLocs.clear();
    }
  }
  if (writeClone != null)   HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,new HTTPHeaderValueCollection(writeClone),out);
  writeClone=null;
synchronized (_badLocs) {
    if (_badLocs.size() > 0) {
      writeClone=new HashSet();
      Iterator iter=_badLocs.iterator();
      while (iter.hasNext()) {
        Object next=iter.next();
        writeClone.add(next);
        _writtenBadLocs.add(next);
      }
      _badLocs.clear();
    }
  }
  if (writeClone != null)   HTTPUtils.writeHeader(HTTPHeaderName.NALTS,new HTTPHeaderValueCollection(writeClone),out);
  if (_wantsFalts) {
    writeClone=null;
synchronized (_goodPushLocs) {
      if (_goodPushLocs.size() > 0) {
        writeClone=new HashSet();
        Iterator iter=_goodPushLocs.iterator();
        while (iter.hasNext()) {
          PushAltLoc next=(PushAltLoc)iter.next();
          if (next.getPushAddress().getProxies().isEmpty()) {
            if (next.getPushAddress() instanceof PushEndpointForSelf)             continue;
 else             Assert.that(false,""String_Node_Str"");
          }
          writeClone.add(next);
          _writtenPushLocs.add(next);
        }
        _goodPushLocs.clear();
      }
    }
    if (writeClone != null)     HTTPUtils.writeHeader(HTTPHeaderName.FALT_LOCATION,new HTTPHeaderValueCollection(writeClone),out);
    writeClone=null;
synchronized (_badPushLocs) {
      if (_badPushLocs.size() > 0) {
        writeClone=new HashSet();
        Iterator iter=_badPushLocs.iterator();
        while (iter.hasNext()) {
          PushAltLoc next=(PushAltLoc)iter.next();
          Assert.that(!next.getPushAddress().getProxies().isEmpty());
          writeClone.add(next);
          _writtenBadPushLocs.add(next);
        }
        _badPushLocs.clear();
      }
    }
    if (writeClone != null)     HTTPUtils.writeHeader(HTTPHeaderName.BFALT_LOCATION,new HTTPHeaderValueCollection(writeClone),out);
  }
  out.write(""String_Node_Str"" + startRange + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str"");
  _requestedInterval=new Interval(_initialReadingPoint,stop - 1);
  if (RouterService.acceptedIncomingConnection() && !NetworkUtils.isPrivateAddress(RouterService.getAddress())) {
    int port=RouterService.getPort();
    String host=NetworkUtils.ip2string(RouterService.getAddress());
    out.write(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str"");
    features.add(ConstantHTTPHeaderValue.BROWSE_FEATURE);
    if (ChatSettings.CHAT_ENABLED.getValue()) {
      out.write(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str"");
      features.add(ConstantHTTPHeaderValue.CHAT_FEATURE);
    }
  }
  if (features.size() > 0) {
    HTTPUtils.writeHeader(HTTPHeaderName.FEATURES,new HTTPHeaderValueCollection(features),out);
  }
  out.write(""String_Node_Str"");
  out.flush();
  readHeaders();
}",0.9004460019114368
4395,"/** 
 * creates a PushEndpoint from a String passed in http header exchange.
 */
public PushEndpoint(String httpString) throws IOException {
  if (httpString.length() < 32 || httpString.indexOf(""String_Node_Str"") > 32)   throw new IOException(""String_Node_Str"");
  String guidS=httpString.substring(0,32);
  httpString=httpString.substring(32);
  _clientGUID=GUID.fromHexString(guidS);
  _guid=new GUID(_clientGUID);
  StringTokenizer tok=new StringTokenizer(httpString,""String_Node_Str"");
  Set proxies=new HashSet();
  int fwtVersion=0;
  IpPort addr=null;
  while (tok.hasMoreTokens() && proxies.size() < 4) {
    String current=tok.nextToken().trim();
    if (current.startsWith(HTTPConstants.FW_TRANSFER)) {
      fwtVersion=(int)HTTPUtils.parseFeatureToken(current);
      continue;
    }
    try {
      proxies.add(parseIpPort(current));
      continue;
    }
 catch (    IOException ohWell) {
    }
    if (addr == null) {
      try {
        addr=parsePortIp(current);
      }
 catch (      IOException notBad) {
      }
    }
  }
  _proxies=proxies;
  _externalAddr=addr;
  _fwtVersion=fwtVersion;
  _features=proxies.size() | (_fwtVersion << 3);
}","/** 
 * creates a PushEndpoint from a String passed in http header exchange.
 */
public PushEndpoint(String httpString) throws IOException {
  if (httpString.length() < 32 || httpString.indexOf(""String_Node_Str"") > 32)   throw new IOException(""String_Node_Str"");
  String guidS=httpString.substring(0,32);
  httpString=httpString.substring(32);
  try {
    _clientGUID=GUID.fromHexString(guidS);
  }
 catch (  IllegalArgumentException iae) {
    throw new IOException(iae.getMessage());
  }
  _guid=new GUID(_clientGUID);
  StringTokenizer tok=new StringTokenizer(httpString,""String_Node_Str"");
  Set proxies=new HashSet();
  int fwtVersion=0;
  IpPort addr=null;
  while (tok.hasMoreTokens() && proxies.size() < 4) {
    String current=tok.nextToken().trim();
    if (current.startsWith(HTTPConstants.FW_TRANSFER)) {
      fwtVersion=(int)HTTPUtils.parseFeatureToken(current);
      continue;
    }
    try {
      proxies.add(parseIpPort(current));
      continue;
    }
 catch (    IOException ohWell) {
    }
    if (addr == null) {
      try {
        addr=parsePortIp(current);
      }
 catch (      IOException notBad) {
      }
    }
  }
  _proxies=proxies;
  _externalAddr=addr;
  _fwtVersion=fwtVersion;
  _features=proxies.size() | (_fwtVersion << 3);
}",0.9566652909616178
4396,"public boolean sendResponses(Response[] responses,QueryRequest query,ReplyHandler handler){
  if ((responses == null) || ((responses.length < 1)))   return false;
  if (query.desiresOutOfBandReplies() && !isConnectedTo(query,handler) && RouterService.canReceiveSolicited()&& RouterService.getUploadManager().isServiceable()) {
    if (bufferResponsesForLaterDelivery(query,responses)) {
      InetAddress addr=null;
      try {
        addr=InetAddress.getByName(query.getReplyAddress());
      }
 catch (      UnknownHostException uhe) {
      }
      int port=query.getReplyPort();
      if (addr != null && NetworkUtils.isValidAddress(addr) && NetworkUtils.isValidPort(port)) {
        int resultCount=(responses.length > 255) ? 255 : responses.length;
        ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(query.getGUID()),resultCount);
        UDPService.instance().send(vm,addr,port);
        return true;
      }
    }
 else {
      return false;
    }
  }
  Iterator iterator=responsesToQueryReplies(responses,query);
  try {
    while (iterator.hasNext()) {
      QueryReply queryReply=(QueryReply)iterator.next();
      sendQueryReply(queryReply);
    }
  }
 catch (  IOException e) {
  }
  return true;
}","public boolean sendResponses(Response[] responses,QueryRequest query,ReplyHandler handler){
  if ((responses == null) || ((responses.length < 1)))   return false;
  if (query.desiresOutOfBandReplies() && !isConnectedTo(query,handler) && RouterService.canReceiveSolicited()&& RouterService.getUploadManager().isServiceable()&& NetworkUtils.isValidAddressAndPort(query.getReplyAddress(),query.getReplyPort())) {
    if (bufferResponsesForLaterDelivery(query,responses)) {
      InetAddress addr=null;
      try {
        addr=InetAddress.getByName(query.getReplyAddress());
      }
 catch (      UnknownHostException uhe) {
      }
      int port=query.getReplyPort();
      if (addr != null) {
        int resultCount=(responses.length > 255) ? 255 : responses.length;
        ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(query.getGUID()),resultCount);
        UDPService.instance().send(vm,addr,port);
        return true;
      }
    }
 else {
      return false;
    }
  }
  Iterator iterator=responsesToQueryReplies(responses,query);
  try {
    while (iterator.hasNext()) {
      QueryReply queryReply=(QueryReply)iterator.next();
      sendQueryReply(queryReply);
    }
  }
 catch (  IOException e) {
  }
  return true;
}",0.9379532634971796
4397,"/** 
 * Steals a grey area from the biggesr HTTPDownloader and gives it to the HTTPDownloader this method will return.  <p>  If there is less than MIN_SPLIT_SIZE left, we will assign the entire area to a new HTTPDownloader, if the current downloader is going too slow.
 */
private void assignGrey(HTTPDownloader dloader,boolean http11) throws NoSuchElementException, IOException, TryAgainLaterException, QueuedException, FileNotFoundException, NotSharingException, NoSuchRangeException {
  if (dloader.getRemoteFileDesc().isPartialSource())   throw new NoSuchRangeException();
  HTTPDownloader biggest=null;
synchronized (this) {
    if (!commonOutFile.isComplete())     Assert.silent(!dloaders.isEmpty());
    for (Iterator iter=dloaders.iterator(); iter.hasNext(); ) {
      HTTPDownloader h=(HTTPDownloader)iter.next();
      if (!h.isActive())       continue;
      if (biggest == null)       biggest=h;
 else {
        int hLeft=h.getAmountToRead() - h.getAmountRead();
        int bLeft=biggest.getAmountToRead() - biggest.getAmountRead();
        if (hLeft > 0 && hLeft > bLeft)         biggest=h;
      }
    }
  }
  if (biggest == null) {
    throw new NoSuchElementException();
  }
  int amountRead=biggest.getAmountRead();
  int left=biggest.getAmountToRead() - amountRead;
  if ((http11 && left < CHUNK_SIZE) || (!http11 && left < MIN_SPLIT_SIZE)) {
    float bandwidthVictim=-1;
    float bandwidthStealer=-1;
    try {
      bandwidthVictim=biggest.getAverageBandwidth();
      biggest.getMeasuredBandwidth();
    }
 catch (    InsufficientDataException ide) {
      LOG.debug(Thread.currentThread().hashCode() + ""String_Node_Str"",ide);
      bandwidthVictim=-1;
    }
    try {
      bandwidthStealer=dloader.getAverageBandwidth();
      dloader.getMeasuredBandwidth();
    }
 catch (    InsufficientDataException ide) {
      LOG.debug(Thread.currentThread().hashCode() + ""String_Node_Str"",ide);
      bandwidthStealer=-1;
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + Thread.currentThread().hashCode() + ""String_Node_Str""+ dloader+ ""String_Node_Str""+ biggest+ ""String_Node_Str""+ bandwidthStealer+ ""String_Node_Str""+ bandwidthVictim+ ""String_Node_Str"");
    if ((bandwidthVictim != -1 && bandwidthVictim < MIN_ACCEPTABLE_SPEED) || (bandwidthStealer > MIN_ACCEPTABLE_SPEED && bandwidthStealer > bandwidthVictim)) {
      int start=biggest.getInitialReadingPoint() + amountRead;
      int stop=biggest.getInitialReadingPoint() + biggest.getAmountToRead();
      if (stop <= start)       throw new NoSuchElementException();
      dloader.connectHTTP(getOverlapOffset(start),stop,false);
      int newLow=dloader.getInitialReadingPoint();
      int newHigh=dloader.getAmountToRead() + newLow;
      if (newLow > start || newHigh < stop) {
        if (LOG.isDebugEnabled())         LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + start + ""String_Node_Str""+ stop+ ""String_Node_Str""+ newLow+ ""String_Node_Str""+ newHigh);
        throw new IOException(""String_Node_Str"");
      }
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + Thread.currentThread().hashCode() + ""String_Node_Str""+ start+ ""String_Node_Str""+ stop+ ""String_Node_Str""+ biggest+ ""String_Node_Str""+ dloader);
      biggest.stopAt(start);
      biggest.stop();
    }
 else {
      throw new NoSuchElementException();
    }
  }
 else {
    int start;
    if (http11) {
      start=biggest.getInitialReadingPoint() + biggest.getAmountToRead() - CHUNK_SIZE + 1;
    }
 else {
      start=biggest.getInitialReadingPoint() + amountRead + left / 2;
    }
    int stop=biggest.getInitialReadingPoint() + biggest.getAmountToRead();
    if (stop <= start)     throw new NoSuchElementException();
    dloader.connectHTTP(getOverlapOffset(start),stop,true);
    int newLow=dloader.getInitialReadingPoint();
    int newHigh=dloader.getAmountToRead() + newLow;
    if (newHigh < stop) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + stop + ""String_Node_Str""+ newHigh);
      throw new IOException(""String_Node_Str"");
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + newLow + ""String_Node_Str""+ newHigh+ ""String_Node_Str""+ biggest+ ""String_Node_Str""+ dloader);
    if (newLow > start)     start=newLow;
    biggest.stopAt(start);
  }
}","/** 
 * Steals a grey area from the biggesr HTTPDownloader and gives it to the HTTPDownloader this method will return.  <p>  If there is less than MIN_SPLIT_SIZE left, we will assign the entire area to a new HTTPDownloader, if the current downloader is going too slow.
 */
private void assignGrey(HTTPDownloader dloader,boolean http11) throws NoSuchElementException, IOException, TryAgainLaterException, QueuedException, FileNotFoundException, NotSharingException, NoSuchRangeException {
  if (dloader.getRemoteFileDesc().isPartialSource())   throw new NoSuchRangeException();
  HTTPDownloader biggest=null;
synchronized (this) {
    for (Iterator iter=dloaders.iterator(); iter.hasNext(); ) {
      HTTPDownloader h=(HTTPDownloader)iter.next();
      if (!h.isActive())       continue;
      if (biggest == null)       biggest=h;
 else {
        int hLeft=h.getAmountToRead() - h.getAmountRead();
        int bLeft=biggest.getAmountToRead() - biggest.getAmountRead();
        if (hLeft > 0 && hLeft > bLeft)         biggest=h;
      }
    }
  }
  if (biggest == null) {
    throw new NoSuchElementException();
  }
  int amountRead=biggest.getAmountRead();
  int left=biggest.getAmountToRead() - amountRead;
  if ((http11 && left < CHUNK_SIZE) || (!http11 && left < MIN_SPLIT_SIZE)) {
    float bandwidthVictim=-1;
    float bandwidthStealer=-1;
    try {
      bandwidthVictim=biggest.getAverageBandwidth();
      biggest.getMeasuredBandwidth();
    }
 catch (    InsufficientDataException ide) {
      LOG.debug(Thread.currentThread().hashCode() + ""String_Node_Str"",ide);
      bandwidthVictim=-1;
    }
    try {
      bandwidthStealer=dloader.getAverageBandwidth();
      dloader.getMeasuredBandwidth();
    }
 catch (    InsufficientDataException ide) {
      LOG.debug(Thread.currentThread().hashCode() + ""String_Node_Str"",ide);
      bandwidthStealer=-1;
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + Thread.currentThread().hashCode() + ""String_Node_Str""+ dloader+ ""String_Node_Str""+ biggest+ ""String_Node_Str""+ bandwidthStealer+ ""String_Node_Str""+ bandwidthVictim+ ""String_Node_Str"");
    if ((bandwidthVictim != -1 && bandwidthVictim < MIN_ACCEPTABLE_SPEED) || (bandwidthStealer > MIN_ACCEPTABLE_SPEED && bandwidthStealer > bandwidthVictim)) {
      int start=biggest.getInitialReadingPoint() + amountRead;
      int stop=biggest.getInitialReadingPoint() + biggest.getAmountToRead();
      if (stop <= start)       throw new NoSuchElementException();
      dloader.connectHTTP(getOverlapOffset(start),stop,false);
      int newLow=dloader.getInitialReadingPoint();
      int newHigh=dloader.getAmountToRead() + newLow;
      if (newLow > start || newHigh < stop) {
        if (LOG.isDebugEnabled())         LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + start + ""String_Node_Str""+ stop+ ""String_Node_Str""+ newLow+ ""String_Node_Str""+ newHigh);
        throw new IOException(""String_Node_Str"");
      }
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + Thread.currentThread().hashCode() + ""String_Node_Str""+ start+ ""String_Node_Str""+ stop+ ""String_Node_Str""+ biggest+ ""String_Node_Str""+ dloader);
      biggest.stopAt(start);
      biggest.stop();
    }
 else {
      throw new NoSuchElementException();
    }
  }
 else {
    int start;
    if (http11) {
      start=biggest.getInitialReadingPoint() + biggest.getAmountToRead() - CHUNK_SIZE + 1;
    }
 else {
      start=biggest.getInitialReadingPoint() + amountRead + left / 2;
    }
    int stop=biggest.getInitialReadingPoint() + biggest.getAmountToRead();
    if (stop <= start)     throw new NoSuchElementException();
    dloader.connectHTTP(getOverlapOffset(start),stop,true);
    int newLow=dloader.getInitialReadingPoint();
    int newHigh=dloader.getAmountToRead() + newLow;
    if (newHigh < stop) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + stop + ""String_Node_Str""+ newHigh);
      throw new IOException(""String_Node_Str"");
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + newLow + ""String_Node_Str""+ newHigh+ ""String_Node_Str""+ biggest+ ""String_Node_Str""+ dloader);
    if (newLow > start)     start=newLow;
    biggest.stopAt(start);
  }
}",0.9909656224334156
4398,"/** 
 * Determines if the given addr or port is valid. Both must be valid for this to return true.
 */
public static boolean isValidAddressAndPort(byte[] addr,int port){
  return isValidAddress(addr) && isValidPort(port);
}","/** 
 * Determines if the given addr or port is valid. Both must be valid for this to return true.
 */
public static boolean isValidAddressAndPort(String addr,int port){
  return isValidAddress(addr) && isValidPort(port);
}",0.9730941704035876
4399,"/** 
 * Reloads the settings with the predefined settings file from disk.
 */
public synchronized void reload(){
  if (!SETTINGS_FILE.isFile()) {
    setExpireValue();
    return;
  }
  FileInputStream fis=null;
  try {
    fis=new FileInputStream(SETTINGS_FILE);
    try {
      PROPS.load(fis);
    }
 catch (    IllegalArgumentException ignored) {
    }
catch (    IOException iox) {
      String msg=iox.getMessage();
      if (StringUtils.indexOfIgnoreCase(msg,""String_Node_Str"") < 0)       throw iox;
      SETTINGS_FILE.delete();
      MessageService.showError(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    ErrorService.error(e);
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
      }
    }
  }
  Iterator ii=settings.iterator();
  while (ii.hasNext()) {
    Setting set=(Setting)ii.next();
    set.reload();
  }
  setExpireValue();
}","/** 
 * Reloads the settings with the predefined settings file from disk.
 */
public synchronized void reload(){
  if (!SETTINGS_FILE.isFile()) {
    setExpireValue();
    return;
  }
  FileInputStream fis=null;
  try {
    fis=new FileInputStream(SETTINGS_FILE);
    try {
      PROPS.load(fis);
    }
 catch (    IllegalArgumentException ignored) {
    }
catch (    StringIndexOutOfBoundsException sioobe) {
    }
catch (    IOException iox) {
      String msg=iox.getMessage();
      if (StringUtils.indexOfIgnoreCase(msg,""String_Node_Str"") < 0)       throw iox;
      SETTINGS_FILE.delete();
      MessageService.showError(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    ErrorService.error(e);
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
      }
    }
  }
  Iterator ii=settings.iterator();
  while (ii.hasNext()) {
    Setting set=(Setting)ii.next();
    set.reload();
  }
  setExpireValue();
}",0.9688982604111755
4400,"/** 
 * Determines whether or not the partial file is valid for us to add ourselves to the mesh. Checks the following: - RFD has a SHA1. - We are allowing partial sharing - The VerifyingFile is not corrupted - We've accepted an incoming connection this session - Our port and IP address are valid and not private.
 */
private boolean isPartialFileValid(){
  return _rfd.getSHA1Urn() != null && UploadSettings.ALLOW_PARTIAL_SHARING.getValue() && !_outIsCorrupted && RouterService.acceptedIncomingConnection() && _incompleteFile.length() > MIN_PARTIAL_FILE_BYTES && NetworkUtils.isValidPort(RouterService.getPort()) && NetworkUtils.isValidAddress(RouterService.getAddress()) && !NetworkUtils.isPrivateAddress(RouterService.getAddress());
}","/** 
 * Determines whether or not the partial file is valid for us to add ourselves to the mesh. Checks the following: - RFD has a SHA1. - We are allowing partial sharing - The VerifyingFile is not corrupted - Our port and IP address are valid 
 */
private boolean isPartialFileValid(){
  return _rfd.getSHA1Urn() != null && UploadSettings.ALLOW_PARTIAL_SHARING.getValue() && !_outIsCorrupted && _incompleteFile.length() > MIN_PARTIAL_FILE_BYTES && NetworkUtils.isValidPort(RouterService.getPort()) && NetworkUtils.isValidAddress(RouterService.getAddress());
}",0.812644564379337
4401,"public boolean sendResponses(Response[] responses,QueryRequest query,ReplyHandler handler){
  if ((responses == null) || ((responses.length < 1)))   return false;
  if (query.desiresOutOfBandReplies() && !isConnectedTo(query,handler) && RouterService.canReceiveSolicited()&& RouterService.getUploadManager().isServiceable()) {
    if (bufferResponsesForLaterDelivery(query,responses)) {
      InetAddress addr=null;
      try {
        addr=InetAddress.getByName(query.getReplyAddress());
      }
 catch (      UnknownHostException uhe) {
        return false;
      }
      int port=query.getReplyPort();
      int resultCount=(responses.length > 255) ? 255 : responses.length;
      ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(query.getGUID()),resultCount);
      UDPService.instance().send(vm,addr,port);
      return true;
    }
    return false;
  }
  Iterator iterator=responsesToQueryReplies(responses,query);
  try {
    while (iterator.hasNext()) {
      QueryReply queryReply=(QueryReply)iterator.next();
      sendQueryReply(queryReply);
    }
  }
 catch (  IOException e) {
  }
  return true;
}","public boolean sendResponses(Response[] responses,QueryRequest query,ReplyHandler handler){
  if ((responses == null) || ((responses.length < 1)))   return false;
  if (query.desiresOutOfBandReplies() && !isConnectedTo(query,handler) && RouterService.canReceiveSolicited()&& RouterService.getUploadManager().isServiceable()) {
    if (bufferResponsesForLaterDelivery(query,responses)) {
      InetAddress addr=null;
      try {
        addr=InetAddress.getByName(query.getReplyAddress());
      }
 catch (      UnknownHostException uhe) {
      }
      int port=query.getReplyPort();
      if (addr != null && NetworkUtils.isValidAddress(addr) && NetworkUtils.isValidPort(port)) {
        int resultCount=(responses.length > 255) ? 255 : responses.length;
        ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(query.getGUID()),resultCount);
        UDPService.instance().send(vm,addr,port);
        return true;
      }
    }
 else {
    }
    return false;
  }
  Iterator iterator=responsesToQueryReplies(responses,query);
  try {
    while (iterator.hasNext()) {
      QueryReply queryReply=(QueryReply)iterator.next();
      sendQueryReply(queryReply);
    }
  }
 catch (  IOException e) {
  }
  return true;
}",0.9368911478187208
4402,"/** 
 * Save setting information to property file We want to NOT save any properties which are the default value, as well as any older properties that are no longer in use. To avoid having to manually encode the file, we clone the existing properties and manually remove the ones which are default and aren't required to be saved. It is important to do it this way (as opposed to creating a new properties object and adding only those that should be saved or aren't default) because 'adding' properties may fail if certain settings classes haven't been statically loaded yet. (Note that we cannot use 'store' since it's only available in 1.2)
 */
public synchronized void save(){
  Properties toSave=(Properties)PROPS.clone();
  Iterator ii=settings.iterator();
  while (ii.hasNext()) {
    Setting set=(Setting)ii.next();
    if (!set.shouldAlwaysSave() && set.isDefault())     toSave.remove(set.getKey());
  }
  OutputStream out=null;
  try {
    if (SETTINGS_FILE.isDirectory())     SETTINGS_FILE.delete();
    File parent=FileUtils.getParentFile(SETTINGS_FILE);
    if (parent != null) {
      parent.mkdirs();
      FileUtils.setWriteable(parent);
    }
    FileUtils.setWriteable(SETTINGS_FILE);
    out=new BufferedOutputStream(new FileOutputStream(SETTINGS_FILE));
    toSave.store(out,HEADING);
  }
 catch (  FileNotFoundException e) {
    ErrorService.error(e);
  }
catch (  IOException e) {
    ErrorService.error(e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException ignored) {
      }
    }
  }
}","/** 
 * Save setting information to property file We want to NOT save any properties which are the default value, as well as any older properties that are no longer in use. To avoid having to manually encode the file, we clone the existing properties and manually remove the ones which are default and aren't required to be saved. It is important to do it this way (as opposed to creating a new properties object and adding only those that should be saved or aren't default) because 'adding' properties may fail if certain settings classes haven't been statically loaded yet. (Note that we cannot use 'store' since it's only available in 1.2)
 */
public synchronized void save(){
  Properties toSave=(Properties)PROPS.clone();
  Iterator ii=settings.iterator();
  while (ii.hasNext()) {
    Setting set=(Setting)ii.next();
    if (!set.shouldAlwaysSave() && set.isDefault())     toSave.remove(set.getKey());
  }
  OutputStream out=null;
  try {
    if (SETTINGS_FILE.isDirectory())     SETTINGS_FILE.delete();
    File parent=FileUtils.getParentFile(SETTINGS_FILE);
    if (parent != null) {
      parent.mkdirs();
      FileUtils.setWriteable(parent);
    }
    FileUtils.setWriteable(SETTINGS_FILE);
    try {
      out=new BufferedOutputStream(new FileOutputStream(SETTINGS_FILE));
    }
 catch (    IOException ioe) {
      SETTINGS_FILE.delete();
      out=new BufferedOutputStream(new FileOutputStream(SETTINGS_FILE));
    }
    toSave.store(out,HEADING);
  }
 catch (  IOException e) {
    ErrorService.error(e);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException ignored) {
      }
    }
  }
}",0.9301025163094128
4403,"public IntervalSet(){
  intervals=new TreeSet(new IntervalComparator());
}","public IntervalSet(){
  intervals=new TreeSet(IntervalComparator.INSTANCE);
}",0.9006622516556292
4404,"/** 
 * Determines whether or not the given IOException can can be ignored. Visit http://www.dte.net/winsock_error.htm for explanations of each code/message. Most of these have no meaning when applied to UDP, but it doesn't hurt to check for ones that aren't harmful. Depending on the version of Java or the OS, the error may either be ""Datagram send failed (code=<code>)"" or simply the text of the error.
 */
private boolean isIgnoreable(Throwable ex,final String message){
  if (""String_Node_Str"".equals(ex.getClass().getName()))   return true;
  if (message == null)   return false;
  final String msg=message.toLowerCase();
  if (scan(msg,1784,""String_Node_Str""))   return true;
  if (scan(msg,10004,""String_Node_Str""))   return true;
  if (scan(msg,10013,""String_Node_Str""))   return true;
  if (scan(msg,10022,""String_Node_Str""))   return true;
  if (scan(msg,10035,""String_Node_Str""))   return true;
  if (scan(msg,10038,""String_Node_Str""))   return true;
  if (scan(msg,10049,""String_Node_Str""))   return true;
  if (scan(msg,10050,""String_Node_Str""))   return true;
  if (scan(msg,10051,""String_Node_Str""))   return true;
  if (scan(msg,10052,""String_Node_Str""))   return true;
  if (scan(msg,10053,""String_Node_Str""))   return true;
  if (scan(msg,10054,""String_Node_Str""))   return true;
  if (scan(msg,10055,""String_Node_Str""))   return true;
  if (scan(msg,10060,""String_Node_Str""))   return true;
  if (scan(msg,10061,""String_Node_Str""))   return true;
  if (scan(msg,10064,""String_Node_Str""))   return true;
  if (scan(msg,10065,""String_Node_Str""))   return true;
  if (scan(msg,10091,""String_Node_Str""))   return true;
  if (scan(msg,10107,null))   return true;
  if (scan(msg,11001,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (msg.indexOf(""String_Node_Str"") > -1)   return true;
  return false;
}","/** 
 * Determines whether or not the given IOException can can be ignored. Visit http://www.dte.net/winsock_error.htm for explanations of each code/message. Most of these have no meaning when applied to UDP, but it doesn't hurt to check for ones that aren't harmful. Depending on the version of Java or the OS, the error may either be ""Datagram send failed (code=<code>)"" or simply the text of the error.
 */
private boolean isIgnoreable(Throwable ex,final String message){
  if (""String_Node_Str"".equals(ex.getClass().getName()))   return true;
  if (message == null)   return false;
  final String msg=message.toLowerCase();
  if (scan(msg,1784,""String_Node_Str""))   return true;
  if (scan(msg,10004,""String_Node_Str""))   return true;
  if (scan(msg,10013,""String_Node_Str""))   return true;
  if (scan(msg,10022,""String_Node_Str""))   return true;
  if (scan(msg,10035,""String_Node_Str""))   return true;
  if (scan(msg,10038,""String_Node_Str""))   return true;
  if (scan(msg,10049,""String_Node_Str""))   return true;
  if (scan(msg,10050,""String_Node_Str""))   return true;
  if (scan(msg,10051,""String_Node_Str""))   return true;
  if (scan(msg,10052,""String_Node_Str""))   return true;
  if (scan(msg,10053,""String_Node_Str""))   return true;
  if (scan(msg,10054,""String_Node_Str""))   return true;
  if (scan(msg,10055,""String_Node_Str""))   return true;
  if (scan(msg,10060,""String_Node_Str""))   return true;
  if (scan(msg,10061,""String_Node_Str""))   return true;
  if (scan(msg,10064,""String_Node_Str""))   return true;
  if (scan(msg,10065,""String_Node_Str""))   return true;
  if (scan(msg,10091,""String_Node_Str""))   return true;
  if (scan(msg,10107,null))   return true;
  if (scan(msg,11001,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (msg.indexOf(""String_Node_Str"") > -1)   return true;
  return false;
}",0.9876944508938936
4405,"/** 
 * Inflates (uncompresses) the data.
 */
public static byte[] inflate(byte[] data) throws IOException {
  InputStream in=null;
  try {
    in=new InflaterInputStream(new ByteArrayInputStream(data));
    ByteArrayOutputStream out=new ByteArrayOutputStream();
    byte[] buf=new byte[64];
    while (true) {
      int read=in.read(buf,0,buf.length);
      if (read == -1)       break;
      out.write(buf,0,read);
    }
    return out.toByteArray();
  }
  finally {
    IOUtils.close(in);
  }
}","/** 
 * Inflates (uncompresses) the data.
 */
public static byte[] inflate(byte[] data) throws IOException {
  InputStream in=null;
  try {
    in=new InflaterInputStream(new ByteArrayInputStream(data));
    ByteArrayOutputStream out=new ByteArrayOutputStream();
    byte[] buf=new byte[64];
    while (true) {
      int read=in.read(buf,0,buf.length);
      if (read == -1)       break;
      out.write(buf,0,read);
    }
    return out.toByteArray();
  }
 catch (  OutOfMemoryError oome) {
    throw new IOException(oome.getMessage());
  }
 finally {
    IOUtils.close(in);
  }
}",0.907235621521336
4406,"/** 
 * This method creates an IntervalSet that is the negative to this  IntervalSet
 * @return IntervalSet containing all ranges not contained in this
 */
public IntervalSet invert(int maxSize){
  IntervalSet ret=new IntervalSet();
  if (maxSize < 1)   return ret;
  if (intervals.size() == 0) {
    Interval block=new Interval(0,maxSize - 1);
    ret.add(block);
    return ret;
  }
  int low=-1;
  Interval interval=null;
  for (Iterator iter=intervals.iterator(); iter.hasNext(); ) {
    interval=(Interval)iter.next();
    if (interval.low != 0 && low < interval.low) {
      if (low + 1 > interval.low - 1)       throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + toString() + ""String_Node_Str""+ maxSize+ ""String_Node_Str""+ low+ ""String_Node_Str""+ interval.low);
      ret.add(new Interval(low + 1,interval.low - 1));
    }
    low=interval.high;
  }
  Assert.that(interval != null,""String_Node_Str"");
  if (interval.high < maxSize - 1)   ret.add(new Interval(interval.high + 1,maxSize - 1));
  return ret;
}","/** 
 * This method creates an IntervalSet that is the negative to this  IntervalSet
 * @return IntervalSet containing all ranges not contained in this
 */
public IntervalSet invert(int maxSize){
  IntervalSet ret=new IntervalSet();
  if (maxSize < 1)   return ret;
  if (intervals.size() == 0) {
    Interval block=new Interval(0,maxSize - 1);
    ret.add(block);
    return ret;
  }
  int low=-1;
  Interval interval=null;
  boolean fixed=false;
  for (Iterator iter=intervals.iterator(); iter.hasNext(); ) {
    interval=(Interval)iter.next();
    if (interval.low != 0 && low < interval.low) {
      if (low + 1 > interval.low - 1) {
        if (!fixed) {
          fixed=true;
          fix();
          iter=intervals.iterator();
          low=-1;
          interval=null;
          continue;
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + toString() + ""String_Node_Str""+ maxSize+ ""String_Node_Str""+ low+ ""String_Node_Str""+ interval.low);
        }
      }
      ret.add(new Interval(low + 1,interval.low - 1));
    }
    low=interval.high;
  }
  Assert.that(interval != null,""String_Node_Str"");
  if (interval.high < maxSize - 1)   ret.add(new Interval(interval.high + 1,maxSize - 1));
  return ret;
}",0.9018245004344048
4407,"/** 
 * Cancels this.  No more tasks can be scheduled or executed.
 */
public void cancel(){
  TIMER.cancel();
}","/** 
 * Cancels this.  No more tasks can be scheduled or executed.
 */
public void cancel(){
  cancelled=true;
  TIMER.cancel();
}",0.9256198347107438
4408,"/** 
 * Schedules the given task for fixed-delay execution after the given delay, repeating every period.
 * @param task the task to run repeatedly
 * @param delay the initial delay, in milliseconds
 * @param period the delay between executions, in millisecondsor zero if it should not be rescheduled
 * @exception IllegalStateException this is cancelled
 * @exception IllegalArgumentException delay or period negative
 * @see java.util.Timer#schedule(java.util.TimerTask,long,long)
 */
public void schedule(final Runnable task,long delay,long period) throws IllegalStateException {
  if (delay < 0)   throw new IllegalArgumentException(""String_Node_Str"" + delay);
  if (period < 0)   throw new IllegalArgumentException(""String_Node_Str"" + period);
  TimerTask tt=new TimerTask(){
    public void run(){
      try {
        task.run();
      }
 catch (      Throwable t) {
        ErrorService.error(t);
      }
    }
  }
;
  if (period == 0)   TIMER.schedule(tt,delay);
 else   TIMER.schedule(tt,delay,period);
}","/** 
 * Schedules the given task for fixed-delay execution after the given delay, repeating every period.
 * @param task the task to run repeatedly
 * @param delay the initial delay, in milliseconds
 * @param period the delay between executions, in millisecondsor zero if it should not be rescheduled
 * @exception IllegalStateException this is cancelled
 * @exception IllegalArgumentException delay or period negative
 * @see java.util.Timer#schedule(java.util.TimerTask,long,long)
 */
public void schedule(final Runnable task,long delay,long period) throws IllegalStateException {
  if (delay < 0)   throw new IllegalArgumentException(""String_Node_Str"" + delay);
  if (period < 0)   throw new IllegalArgumentException(""String_Node_Str"" + period);
  TimerTask tt=new TimerTask(){
    public void run(){
      try {
        task.run();
      }
 catch (      Throwable t) {
        ErrorService.error(t);
      }
    }
  }
;
  try {
    if (period == 0)     TIMER.schedule(tt,delay);
 else     TIMER.schedule(tt,delay,period);
  }
 catch (  IllegalStateException ise) {
    if (cancelled)     throw ise;
  }
}",0.9552098066949553
4409,"public int read(byte[] b,int off,int len) throws IOException {
  try {
    return super.read(b,off,len);
  }
 catch (  NullPointerException e) {
    throw new IOException(""String_Node_Str"");
  }
catch (  ArrayIndexOutOfBoundsException aioobe) {
    throw new IOException(aioobe.getMessage());
  }
}","public int read(byte[] b,int off,int len) throws IOException {
  try {
    return super.read(b,off,len);
  }
 catch (  NullPointerException e) {
    throw new IOException(""String_Node_Str"");
  }
catch (  ArrayIndexOutOfBoundsException aioobe) {
    throw new IOException(aioobe.getMessage());
  }
catch (  OutOfMemoryError oome) {
    throw new IOException(oome.getMessage());
  }
}",0.8735294117647059
4410,"/** 
 * Creates a <tt>List</tt> of <tt>QueryReply</tt> instances with compressed XML data, if requested.
 * @return a new <tt>List</tt> of <tt>QueryReply</tt> instances
 */
protected List createQueryReply(byte[] guid,byte ttl,long speed,Response[] res,byte[] clientGUID,boolean busy,boolean uploaded,boolean measuredSpeed,boolean isFromMcast,boolean canFWTransfer){
  List queryReplies=new ArrayList();
  QueryReply queryReply=null;
  int port=isFromMcast ? RouterService.getNonForcedPort() : RouterService.getPort();
  byte[] ip=isFromMcast ? RouterService.getNonForcedAddress() : (canFWTransfer ? RouterService.getExternalAddress() : RouterService.getAddress());
  String xmlCollectionString=LimeXMLDocumentHelper.getAggregateString(res);
  if (xmlCollectionString == null)   xmlCollectionString=""String_Node_Str"";
  byte[] xmlBytes=null;
  try {
    xmlBytes=xmlCollectionString.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException ueex) {
    ErrorService.error(ueex,""String_Node_Str"" + xmlCollectionString);
  }
  boolean notIncoming=!RouterService.acceptedIncomingConnection();
  Set proxies=(notIncoming ? _manager.getPushProxies() : null);
  if (xmlBytes.length > QueryReply.XML_MAX_SIZE) {
    List splitResps=new LinkedList();
    splitAndAddResponses(splitResps,res);
    while (!splitResps.isEmpty()) {
      Response[] currResps=(Response[])splitResps.remove(0);
      String currXML=LimeXMLDocumentHelper.getAggregateString(currResps);
      byte[] currXMLBytes=null;
      try {
        currXMLBytes=currXML.getBytes(""String_Node_Str"");
      }
 catch (      UnsupportedEncodingException ueex) {
        ErrorService.error(ueex,""String_Node_Str"" + currXML);
        currXMLBytes=""String_Node_Str"".getBytes();
      }
      if ((currXMLBytes.length > QueryReply.XML_MAX_SIZE) && (currResps.length > 1))       splitAndAddResponses(splitResps,currResps);
 else {
        byte[] xmlCompressed=null;
        if ((currXML != null) && (!currXML.equals(""String_Node_Str"")))         xmlCompressed=LimeXMLUtils.compress(currXMLBytes);
 else         xmlCompressed=DataUtils.EMPTY_BYTE_ARRAY;
        queryReply=new QueryReply(guid,ttl,port,ip,speed,currResps,_clientGUID,xmlCompressed,notIncoming,busy,uploaded,measuredSpeed,ChatSettings.CHAT_ENABLED.getValue(),isFromMcast,canFWTransfer,proxies);
        queryReplies.add(queryReply);
      }
    }
  }
 else {
    byte[] xmlCompressed=null;
    if (xmlCollectionString != null && !xmlCollectionString.equals(""String_Node_Str""))     xmlCompressed=LimeXMLUtils.compress(xmlBytes);
 else     xmlCompressed=DataUtils.EMPTY_BYTE_ARRAY;
    queryReply=new QueryReply(guid,ttl,port,ip,speed,res,_clientGUID,xmlCompressed,notIncoming,busy,uploaded,measuredSpeed,ChatSettings.CHAT_ENABLED.getValue(),isFromMcast,canFWTransfer,proxies);
    queryReplies.add(queryReply);
  }
  return queryReplies;
}","/** 
 * Creates a <tt>List</tt> of <tt>QueryReply</tt> instances with compressed XML data, if requested.
 * @return a new <tt>List</tt> of <tt>QueryReply</tt> instances
 */
protected List createQueryReply(byte[] guid,byte ttl,long speed,Response[] res,byte[] clientGUID,boolean busy,boolean uploaded,boolean measuredSpeed,boolean isFromMcast,boolean canFWTransfer){
  List queryReplies=new ArrayList();
  QueryReply queryReply=null;
  int port=-1;
  byte[] ip=null;
  if (isFromMcast) {
    ip=RouterService.getNonForcedAddress();
    port=RouterService.getNonForcedPort();
    if (!NetworkUtils.isValidPort(port) || !NetworkUtils.isValidAddress(ip))     isFromMcast=false;
  }
  if (!isFromMcast) {
    port=RouterService.getPort();
    if (!NetworkUtils.isValidPort(port))     return Collections.EMPTY_LIST;
    if (canFWTransfer) {
      ip=RouterService.getExternalAddress();
      if (!NetworkUtils.isValidAddress(ip))       canFWTransfer=false;
    }
    if (!canFWTransfer) {
      ip=RouterService.getAddress();
      if (!NetworkUtils.isValidAddress(ip))       return Collections.EMPTY_LIST;
    }
  }
  String xmlCollectionString=LimeXMLDocumentHelper.getAggregateString(res);
  if (xmlCollectionString == null)   xmlCollectionString=""String_Node_Str"";
  byte[] xmlBytes=null;
  try {
    xmlBytes=xmlCollectionString.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException ueex) {
    ErrorService.error(ueex,""String_Node_Str"" + xmlCollectionString);
  }
  boolean notIncoming=!RouterService.acceptedIncomingConnection();
  Set proxies=(notIncoming ? _manager.getPushProxies() : null);
  if (xmlBytes.length > QueryReply.XML_MAX_SIZE) {
    List splitResps=new LinkedList();
    splitAndAddResponses(splitResps,res);
    while (!splitResps.isEmpty()) {
      Response[] currResps=(Response[])splitResps.remove(0);
      String currXML=LimeXMLDocumentHelper.getAggregateString(currResps);
      byte[] currXMLBytes=null;
      try {
        currXMLBytes=currXML.getBytes(""String_Node_Str"");
      }
 catch (      UnsupportedEncodingException ueex) {
        ErrorService.error(ueex,""String_Node_Str"" + currXML);
        currXMLBytes=""String_Node_Str"".getBytes();
      }
      if ((currXMLBytes.length > QueryReply.XML_MAX_SIZE) && (currResps.length > 1))       splitAndAddResponses(splitResps,currResps);
 else {
        byte[] xmlCompressed=null;
        if ((currXML != null) && (!currXML.equals(""String_Node_Str"")))         xmlCompressed=LimeXMLUtils.compress(currXMLBytes);
 else         xmlCompressed=DataUtils.EMPTY_BYTE_ARRAY;
        queryReply=new QueryReply(guid,ttl,port,ip,speed,currResps,_clientGUID,xmlCompressed,notIncoming,busy,uploaded,measuredSpeed,ChatSettings.CHAT_ENABLED.getValue(),isFromMcast,canFWTransfer,proxies);
        queryReplies.add(queryReply);
      }
    }
  }
 else {
    byte[] xmlCompressed=null;
    if (xmlCollectionString != null && !xmlCollectionString.equals(""String_Node_Str""))     xmlCompressed=LimeXMLUtils.compress(xmlBytes);
 else     xmlCompressed=DataUtils.EMPTY_BYTE_ARRAY;
    queryReply=new QueryReply(guid,ttl,port,ip,speed,res,_clientGUID,xmlCompressed,notIncoming,busy,uploaded,measuredSpeed,ChatSettings.CHAT_ENABLED.getValue(),isFromMcast,canFWTransfer,proxies);
    queryReplies.add(queryReply);
  }
  return queryReplies;
}",0.9002267573696145
4411,"/** 
 * Creates a new <tt>URL</tt> based on the IP and port in the location The location MUST be a dotted IP address.
 */
private static IpPort createUrlFromMini(final String location,URN urn) throws IOException {
  int port=location.indexOf(':');
  final String loc=(port == -1 ? location : location.substring(0,port));
  try {
    new IP(loc);
  }
 catch (  IllegalArgumentException iae) {
    throw new IOException(""String_Node_Str"" + location);
  }
  if (loc.indexOf('/') != -1)   throw new IOException(""String_Node_Str"" + location);
  if (port == -1)   port=6346;
 else {
    if (location.length() < port + 1)     throw new IOException(""String_Node_Str"" + location);
    try {
      port=Short.parseShort(location.substring(port + 1));
    }
 catch (    NumberFormatException nfe) {
      throw new IOException(""String_Node_Str"" + location);
    }
  }
  return new Endpoint(loc,port);
}","/** 
 * Creates a new <tt>URL</tt> based on the IP and port in the location The location MUST be a dotted IP address.
 */
private static IpPort createUrlFromMini(final String location,URN urn) throws IOException {
  int port=location.indexOf(':');
  final String loc=(port == -1 ? location : location.substring(0,port));
  try {
    new IP(loc);
  }
 catch (  IllegalArgumentException iae) {
    throw new IOException(""String_Node_Str"" + location);
  }
  if (loc.indexOf('/') != -1)   throw new IOException(""String_Node_Str"" + location);
  if (!NetworkUtils.isValidAddress(loc))   throw new IOException(""String_Node_Str"" + location);
  if (port == -1)   port=6346;
 else {
    if (location.length() < port + 1)     throw new IOException(""String_Node_Str"" + location);
    try {
      port=Short.parseShort(location.substring(port + 1));
    }
 catch (    NumberFormatException nfe) {
      throw new IOException(""String_Node_Str"" + location);
    }
  }
  if (!NetworkUtils.isValidPort(port))   throw new IOException(""String_Node_Str"" + port);
  return new Endpoint(loc,port);
}",0.9054878048780488
4412,"/** 
 * Returns true if this has slots for an incoming connection, <b>without accounting for this' ultrapeer capabilities</b>.  More specifically: <ul> <li>if ultrapeerHeader==null, returns true if this has space for an unrouted old-style connection. <li>if ultrapeerHeader.equals(""true""), returns true if this has slots for a leaf connection. <li>if ultrapeerHeader.equals(""false""), returns true if this has slots for an ultrapeer connection. </ul> <tt>useragentHeader</tt> is used to prefer LimeWire and certain trusted vendors.  <tt>outgoing</tt> is currently unused, but may be used to prefer incoming or outgoing connections in the forward.
 * @param outgoing true if this is an outgoing connection; true if incoming
 * @param ultrapeerHeader the value of the X-Ultrapeer header, or nullif it was not written
 * @param useragentHeader the value of the User-Agent header, or null ifit was not written
 * @return true if a connection of the given type is allowed
 */
public boolean allowConnection(HandshakeResponse hr,boolean leaf){
  if (!ConnectionSettings.PREFERENCING_ACTIVE.getValue())   return true;
  int limeAttempts=ConnectionSettings.LIME_ATTEMPTS.getValue();
  if (!ConnectionSettings.ALLOW_WHILE_DISCONNECTED.getValue() && _preferredConnections <= 0) {
    return false;
  }
 else   if (RouterService.isShieldedLeaf()) {
    if (Sockets.getAttempts() < limeAttempts ? !hr.isLimeWire() : !hr.isGoodUltrapeer()) {
      return false;
    }
 else     if (_shieldedConnections < _preferredConnections) {
      if (checkLocale(hr.getLocalePref()))       _needPref=false;
      return true;
    }
 else {
      if (_needPref && checkLocale(hr.getLocalePref()))       return true;
      return false;
    }
  }
 else   if (hr.isLeaf() || leaf) {
    if (!allowUltrapeer2LeafConnection(hr)) {
      return false;
    }
    int leaves=getNumInitializedClientConnections();
    int nonLimeWireLeaves=_nonLimeWireLeaves;
    if (!hr.isLimeWire()) {
      if (leaves < UltrapeerSettings.MAX_LEAVES.getValue() && nonLimeWireLeaves < RESERVED_NON_LIMEWIRE_LEAVES) {
        return true;
      }
 else {
        return false;
      }
    }
    if (hr.isGoodLeaf()) {
      return (leaves + Math.max(0,RESERVED_NON_LIMEWIRE_LEAVES - nonLimeWireLeaves)) < UltrapeerSettings.MAX_LEAVES.getValue();
    }
    return leaves < (UltrapeerSettings.MAX_LEAVES.getValue() - RESERVED_GOOD_LEAF_CONNECTIONS);
  }
 else   if (hr.isUltrapeer()) {
    int peers=getNumInitializedConnections();
    int nonLimeWirePeers=_nonLimeWirePeers;
    int locale_num=0;
    if (peers == 0 && Sockets.getAttempts() < limeAttempts ? hr.isLimeWire() && hr.isGoodUltrapeer() : hr.isGoodUltrapeer()) {
      if (isIdle())       return hr.isLimeWire();
      if (!ConnectionSettings.USE_LOCALE_PREF.getValue() || _preferredConnections > ConnectionSettings.NUM_LOCALE_PREF.getValue())       return true;
    }
    if (!allowUltrapeer2UltrapeerConnection(hr)) {
      return false;
    }
    if (ConnectionSettings.USE_LOCALE_PREF.getValue()) {
      if (checkLocale(hr.getLocalePref()) && _localeMatchingPeers < ConnectionSettings.NUM_LOCALE_PREF.getValue()) {
        return true;
      }
      locale_num=getNumLimeWireLocalePrefSlots();
    }
    if (!hr.isLimeWire()) {
      if (peers < _preferredConnections && nonLimeWirePeers < RESERVED_NON_LIMEWIRE_PEERS) {
        return true;
      }
    }
    return (peers + Math.max(0,RESERVED_NON_LIMEWIRE_PEERS - nonLimeWirePeers) + locale_num) < _preferredConnections;
  }
  return false;
}","/** 
 * Returns true if this has slots for an incoming connection, <b>without accounting for this' ultrapeer capabilities</b>.  More specifically: <ul> <li>if ultrapeerHeader==null, returns true if this has space for an unrouted old-style connection. <li>if ultrapeerHeader.equals(""true""), returns true if this has slots for a leaf connection. <li>if ultrapeerHeader.equals(""false""), returns true if this has slots for an ultrapeer connection. </ul> <tt>useragentHeader</tt> is used to prefer LimeWire and certain trusted vendors.  <tt>outgoing</tt> is currently unused, but may be used to prefer incoming or outgoing connections in the forward.
 * @param outgoing true if this is an outgoing connection; true if incoming
 * @param ultrapeerHeader the value of the X-Ultrapeer header, or nullif it was not written
 * @param useragentHeader the value of the User-Agent header, or null ifit was not written
 * @return true if a connection of the given type is allowed
 */
public boolean allowConnection(HandshakeResponse hr,boolean leaf){
  if (!ConnectionSettings.PREFERENCING_ACTIVE.getValue())   return true;
  int limeAttempts=ConnectionSettings.LIME_ATTEMPTS.getValue();
  if (!ConnectionSettings.ALLOW_WHILE_DISCONNECTED.getValue() && _preferredConnections <= 0) {
    return false;
  }
 else   if (RouterService.isShieldedLeaf()) {
    if (Sockets.getAttempts() < limeAttempts ? !hr.isLimeWire() : !hr.isGoodUltrapeer()) {
      return false;
    }
 else     if (_shieldedConnections < _preferredConnections) {
      if (checkLocale(hr.getLocalePref()))       _needPref=false;
      return true;
    }
 else {
      if (_needPref && checkLocale(hr.getLocalePref()))       return true;
      return false;
    }
  }
 else   if (hr.isLeaf() || leaf) {
    if (!allowUltrapeer2LeafConnection(hr)) {
      return false;
    }
    int leaves=getNumInitializedClientConnections();
    int nonLimeWireLeaves=_nonLimeWireLeaves;
    if (!hr.isLimeWire()) {
      if (leaves < UltrapeerSettings.MAX_LEAVES.getValue() && nonLimeWireLeaves < RESERVED_NON_LIMEWIRE_LEAVES) {
        return true;
      }
 else {
        return false;
      }
    }
    if (hr.isGoodLeaf()) {
      return (leaves + Math.max(0,RESERVED_NON_LIMEWIRE_LEAVES - nonLimeWireLeaves)) < UltrapeerSettings.MAX_LEAVES.getValue();
    }
    return leaves < (UltrapeerSettings.MAX_LEAVES.getValue() - RESERVED_GOOD_LEAF_CONNECTIONS);
  }
 else   if (hr.isUltrapeer()) {
    int peers=getNumInitializedConnections();
    int nonLimeWirePeers=_nonLimeWirePeers;
    int locale_num=0;
    if (peers == 0 && (Sockets.getAttempts() < limeAttempts ? (hr.isLimeWire() && hr.isGoodUltrapeer()) : hr.isGoodUltrapeer())) {
      if (isIdle())       return hr.isLimeWire();
      if (!ConnectionSettings.USE_LOCALE_PREF.getValue() || _preferredConnections > ConnectionSettings.NUM_LOCALE_PREF.getValue())       return true;
    }
    if (!allowUltrapeer2UltrapeerConnection(hr)) {
      return false;
    }
    if (ConnectionSettings.USE_LOCALE_PREF.getValue()) {
      if (checkLocale(hr.getLocalePref()) && _localeMatchingPeers < ConnectionSettings.NUM_LOCALE_PREF.getValue()) {
        return true;
      }
      locale_num=getNumLimeWireLocalePrefSlots();
    }
    if (!hr.isLimeWire()) {
      if (peers < _preferredConnections && nonLimeWirePeers < RESERVED_NON_LIMEWIRE_PEERS) {
        return true;
      }
    }
    return (peers + Math.max(0,RESERVED_NON_LIMEWIRE_PEERS - nonLimeWirePeers) + locale_num) < _preferredConnections;
  }
  return false;
}",0.9994305239179956
4413,"/** 
 * Adds all supported capabilities to the given set.
 */
private static void addSupportedMessages(Set hashSet){
  SupportedMessageBlock smp=null;
  smp=new SupportedMessageBlock(FEATURE_SEARCH_BYTES,FeatureSearchData.FEATURE_SEARCH_MAX_SELECTOR);
  hashSet.add(smp);
  smp=new SupportedMessageBlock(SIMPP_CAPABILITY_BYTES,_simppVersion);
  hashSet.add(smp);
}","/** 
 * Adds all supported capabilities to the given set.
 */
private static void addSupportedMessages(Set hashSet){
  SupportedMessageBlock smp=null;
  smp=new SupportedMessageBlock(FEATURE_SEARCH_BYTES,FeatureSearchData.FEATURE_SEARCH_MAX_SELECTOR);
  hashSet.add(smp);
  smp=new SupportedMessageBlock(SIMPP_CAPABILITY_BYTES,SimppManager.instance().getVersion());
  hashSet.add(smp);
}",0.9533954727030626
4414,"public String toString(){
  return ""String_Node_Str"" + super.toString() + ""String_Node_Str"";
}","public String toString(){
  return ""String_Node_Str"" + super.toString() + ""String_Node_Str""+ _capabilitiesSupported+ ""String_Node_Str"";
}",0.8138528138528138
4415,"/** 
 * Internal constructor for creating the sole instance of our  CapabilitiesVM.
 */
private CapabilitiesVM(){
  super(F_NULL_VENDOR_ID,F_CAPABILITIES,VERSION,derivePayload());
  _simppVersion=SimppManager.instance().getVersion();
  addSupportedMessages(_capabilitiesSupported);
}","/** 
 * Internal constructor for creating the sole instance of our  CapabilitiesVM.
 */
private CapabilitiesVM(){
  super(F_NULL_VENDOR_ID,F_CAPABILITIES,VERSION,derivePayload());
  addSupportedMessages(_capabilitiesSupported);
}",0.7421875
4416,"/** 
 * Called when we receive a new SIMPPVendorMessage, 
 */
public void checkAndUpdate(final byte[] simppPayload){
  if (simppPayload == null)   return;
  final int myVersion=_latestVersion;
  Runnable simppHandler=new Runnable(){
    public void run(){
      SimppDataVerifier verifier=new SimppDataVerifier(simppPayload);
      boolean verified=false;
      verified=verifier.verifySource();
      if (!verified)       return;
      SimppParser parser=null;
      try {
        parser=new SimppParser(verifier.getVerifiedData());
      }
 catch (      SAXException sx) {
        return;
      }
catch (      IOException iox) {
        return;
      }
      int version=parser.getVersion();
      if (version <= myVersion)       return;
      SimppManager.this._latestVersion=version;
      SimppManager.this._simppBytes=simppPayload;
      SimppManager.this._propsStream=parser.getPropsData();
      String props=parser.getPropsData();
      SimppSettingsManager.instance().updateSimppSettings(props);
      CapabilitiesVM.updateSimppVersion(version);
      RouterService.getConnectionManager().sendUpdatedCapabilities();
    }
  }
;
  _processingQueue.add(simppHandler);
}","/** 
 * Called when we receive a new SIMPPVendorMessage, 
 */
public void checkAndUpdate(final byte[] simppPayload){
  if (simppPayload == null)   return;
  final int myVersion=_latestVersion;
  Runnable simppHandler=new Runnable(){
    public void run(){
      SimppDataVerifier verifier=new SimppDataVerifier(simppPayload);
      boolean verified=false;
      verified=verifier.verifySource();
      if (!verified)       return;
      SimppParser parser=null;
      try {
        parser=new SimppParser(verifier.getVerifiedData());
      }
 catch (      SAXException sx) {
        return;
      }
catch (      IOException iox) {
        return;
      }
      int version=parser.getVersion();
      if (version <= myVersion)       return;
      SimppManager.this._latestVersion=version;
      SimppManager.this._simppBytes=simppPayload;
      SimppManager.this._propsStream=parser.getPropsData();
      String props=parser.getPropsData();
      SimppSettingsManager.instance().updateSimppSettings(props);
      CapabilitiesVM.reconstructInstance();
      RouterService.getConnectionManager().sendUpdatedCapabilities();
    }
  }
;
  _processingQueue.add(simppHandler);
}",0.9804088586030664
4417,"public void run(){
  SimppDataVerifier verifier=new SimppDataVerifier(simppPayload);
  boolean verified=false;
  verified=verifier.verifySource();
  if (!verified)   return;
  SimppParser parser=null;
  try {
    parser=new SimppParser(verifier.getVerifiedData());
  }
 catch (  SAXException sx) {
    return;
  }
catch (  IOException iox) {
    return;
  }
  int version=parser.getVersion();
  if (version <= myVersion)   return;
  SimppManager.this._latestVersion=version;
  SimppManager.this._simppBytes=simppPayload;
  SimppManager.this._propsStream=parser.getPropsData();
  String props=parser.getPropsData();
  SimppSettingsManager.instance().updateSimppSettings(props);
  CapabilitiesVM.updateSimppVersion(version);
  RouterService.getConnectionManager().sendUpdatedCapabilities();
}","public void run(){
  SimppDataVerifier verifier=new SimppDataVerifier(simppPayload);
  boolean verified=false;
  verified=verifier.verifySource();
  if (!verified)   return;
  SimppParser parser=null;
  try {
    parser=new SimppParser(verifier.getVerifiedData());
  }
 catch (  SAXException sx) {
    return;
  }
catch (  IOException iox) {
    return;
  }
  int version=parser.getVersion();
  if (version <= myVersion)   return;
  SimppManager.this._latestVersion=version;
  SimppManager.this._simppBytes=simppPayload;
  SimppManager.this._propsStream=parser.getPropsData();
  String props=parser.getPropsData();
  SimppSettingsManager.instance().updateSimppSettings(props);
  CapabilitiesVM.reconstructInstance();
  RouterService.getConnectionManager().sendUpdatedCapabilities();
}",0.9707750952986024
4418,"/** 
 * Responds to a Gnutella ping with cached pongs.  This does special  handling for both ""heartbeat"" pings that were sent to ensure that the connection is still live as well as for pings from a crawler.
 * @param ping the <tt>PingRequest</tt> to respond to
 * @param handler the <tt>ReplyHandler</tt> to send any pongs to
 */
protected void respondToPingRequest(PingRequest ping,ReplyHandler handler){
  int hops=(int)ping.getHops();
  int ttl=(int)ping.getTTL();
  if ((hops + ttl > 2) && !_manager.allowAnyConnection())   return;
  if (NetworkUtils.isValidAddress(RouterService.getAddress()) && NetworkUtils.isValidPort(RouterService.getPort())) {
    if (hops == 1 && ttl == 1) {
      handleCrawlerPing(ping,handler);
      return;
    }
    if (ping.isHeartbeat()) {
      sendPingReply(PingReply.create(ping.getGUID(),(byte)1),handler);
      return;
    }
    int newTTL=hops + 1;
    if ((hops + ttl) <= 2)     newTTL=1;
    if (RouterService.getConnectionManager().hasFreeSlots() || Statistics.instance().calculateDailyUptime() > 60 * 30) {
      PingReply pr=PingReply.create(ping.getGUID(),(byte)newTTL);
      sendPingReply(pr,handler);
    }
  }
  List pongs=PongCacher.instance().getBestPongs(ping.getLocale());
  Iterator iter=pongs.iterator();
  byte[] guid=ping.getGUID();
  InetAddress pingerIP=handler.getInetAddress();
  while (iter.hasNext()) {
    PingReply pr=(PingReply)iter.next();
    if (pr.getInetAddress().equals(pingerIP)) {
      continue;
    }
    sendPingReply(pr.mutateGUID(guid),handler);
  }
}","/** 
 * Responds to a Gnutella ping with cached pongs.  This does special  handling for both ""heartbeat"" pings that were sent to ensure that the connection is still live as well as for pings from a crawler.
 * @param ping the <tt>PingRequest</tt> to respond to
 * @param handler the <tt>ReplyHandler</tt> to send any pongs to
 */
protected void respondToPingRequest(PingRequest ping,ReplyHandler handler){
  int hops=(int)ping.getHops();
  int ttl=(int)ping.getTTL();
  if ((hops + ttl > 2) && !_manager.allowAnyConnection())   return;
  if (NetworkUtils.isValidAddress(RouterService.getAddress()) && NetworkUtils.isValidPort(RouterService.getPort())) {
    if (hops == 1 && ttl == 1) {
      handleCrawlerPing(ping,handler);
      return;
    }
    if (ping.isHeartbeat()) {
      sendPingReply(PingReply.create(ping.getGUID(),(byte)1),handler);
      return;
    }
    int newTTL=hops + 1;
    if ((hops + ttl) <= 2)     newTTL=1;
    if (RouterService.getConnectionManager().hasFreeSlots() || Statistics.instance().calculateDailyUptime() > 60 * 30) {
      PingReply pr=PingReply.create(ping.getGUID(),(byte)newTTL);
      sendPingReply(pr,handler);
    }
  }
  List pongs=PongCacher.instance().getBestPongs(ping.getLocale());
  Iterator iter=pongs.iterator();
  byte[] guid=ping.getGUID();
  InetAddress pingerIP=handler.getInetAddress();
  while (iter.hasNext()) {
    PingReply pr=(PingReply)iter.next();
    if (pr.getInetAddress().equals(pingerIP))     continue;
    sendPingReply(pr.mutateGUID(guid),handler);
  }
}",0.9882275997383912
4419,"/** 
 * Creates a new <tt>PingReply</tt> instance from the network.
 * @param guid the Globally Unique Identifier (GUID) for this message
 * @param ttl the time to live for this message
 * @param hops the hops for this message
 * @param payload the message payload
 * @throws <tt>BadPacketException</tt> if the message is invalid forany reason
 */
public static PingReply createFromNetwork(byte[] guid,byte ttl,byte hops,byte[] payload) throws BadPacketException {
  if (guid == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (payload == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (payload.length < STANDARD_PAYLOAD_SIZE) {
    ReceivedErrorStat.PING_REPLY_INVALID_PAYLOAD.incrementStat();
    throw new BadPacketException(""String_Node_Str"");
  }
  int port=ByteOrder.ubytes2int(ByteOrder.leb2short(payload,0));
  if (!NetworkUtils.isValidPort(port)) {
    ReceivedErrorStat.PING_REPLY_INVALID_PORT.incrementStat();
    throw new BadPacketException(""String_Node_Str"" + port);
  }
  String ipString=NetworkUtils.ip2string(payload,2);
  if (!NetworkUtils.isValidAddress(ipString)) {
    ReceivedErrorStat.PING_REPLY_INVALID_ADDRESS.incrementStat();
    throw new BadPacketException(""String_Node_Str"" + ipString);
  }
  InetAddress ip;
  try {
    ip=InetAddress.getByName(NetworkUtils.ip2string(payload,2));
  }
 catch (  UnknownHostException e) {
    throw new BadPacketException(""String_Node_Str"" + ipString + ""String_Node_Str""+ e.getMessage());
  }
  GGEP ggep=parseGGEP(payload);
  if (ggep != null && ggep.hasKey(GGEP.GGEP_HEADER_VENDOR_INFO)) {
    byte[] vendorBytes=null;
    try {
      vendorBytes=ggep.getBytes(GGEP.GGEP_HEADER_VENDOR_INFO);
    }
 catch (    BadGGEPPropertyException e) {
      ReceivedErrorStat.PING_REPLY_INVALID_GGEP.incrementStat();
      throw new BadPacketException(""String_Node_Str"" + vendorBytes);
    }
    if (vendorBytes.length < 4) {
      ReceivedErrorStat.PING_REPLY_INVALID_VENDOR.incrementStat();
      throw new BadPacketException(""String_Node_Str"" + vendorBytes.length);
    }
    if (ggep.hasKey(GGEP.GGEP_HEADER_CLIENT_LOCALE)) {
      try {
        byte[] clocale=ggep.getBytes(GGEP.GGEP_HEADER_CLIENT_LOCALE);
      }
 catch (      BadGGEPPropertyException e) {
        ReceivedErrorStat.PING_REPLY_INVALID_GGEP.incrementStat();
        throw new BadPacketException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  return new PingReply(guid,ttl,hops,payload,ggep,ip);
}","/** 
 * Creates a new <tt>PingReply</tt> instance from the network.
 * @param guid the Globally Unique Identifier (GUID) for this message
 * @param ttl the time to live for this message
 * @param hops the hops for this message
 * @param payload the message payload
 * @throws <tt>BadPacketException</tt> if the message is invalid forany reason
 */
public static PingReply createFromNetwork(byte[] guid,byte ttl,byte hops,byte[] payload) throws BadPacketException {
  if (guid == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (payload == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (payload.length < STANDARD_PAYLOAD_SIZE) {
    ReceivedErrorStat.PING_REPLY_INVALID_PAYLOAD.incrementStat();
    throw new BadPacketException(""String_Node_Str"");
  }
  int port=ByteOrder.ubytes2int(ByteOrder.leb2short(payload,0));
  if (!NetworkUtils.isValidPort(port)) {
    ReceivedErrorStat.PING_REPLY_INVALID_PORT.incrementStat();
    throw new BadPacketException(""String_Node_Str"" + port);
  }
  String ipString=NetworkUtils.ip2string(payload,2);
  if (!NetworkUtils.isValidAddress(ipString)) {
    ReceivedErrorStat.PING_REPLY_INVALID_ADDRESS.incrementStat();
    throw new BadPacketException(""String_Node_Str"" + ipString);
  }
  InetAddress ip;
  try {
    ip=InetAddress.getByName(NetworkUtils.ip2string(payload,2));
  }
 catch (  UnknownHostException e) {
    throw new BadPacketException(""String_Node_Str"" + ipString + ""String_Node_Str""+ e.getMessage());
  }
  GGEP ggep=parseGGEP(payload);
  if (ggep != null) {
    if (ggep.hasKey(GGEP.GGEP_HEADER_VENDOR_INFO)) {
      byte[] vendorBytes=null;
      try {
        vendorBytes=ggep.getBytes(GGEP.GGEP_HEADER_VENDOR_INFO);
      }
 catch (      BadGGEPPropertyException e) {
        ReceivedErrorStat.PING_REPLY_INVALID_GGEP.incrementStat();
        throw new BadPacketException(""String_Node_Str"" + vendorBytes);
      }
      if (vendorBytes.length < 4) {
        ReceivedErrorStat.PING_REPLY_INVALID_VENDOR.incrementStat();
        throw new BadPacketException(""String_Node_Str"" + vendorBytes.length);
      }
    }
    if (ggep.hasKey(GGEP.GGEP_HEADER_CLIENT_LOCALE)) {
      try {
        byte[] clocale=ggep.getBytes(GGEP.GGEP_HEADER_CLIENT_LOCALE);
      }
 catch (      BadGGEPPropertyException e) {
        ReceivedErrorStat.PING_REPLY_INVALID_GGEP.incrementStat();
        throw new BadPacketException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  return new PingReply(guid,ttl,hops,payload,ggep,ip);
}",0.9908073541167066
4420,"/** 
 * Tests to make sure that pongs are received properly via pong caching when the locale is specified in the ping
 */
public void testPongsReceivedFromPingWithLocale() throws Exception {
  PingPongSettings.PINGS_ACTIVE.setValue(false);
  byte[] ip={(byte)1,(byte)2,(byte)3,(byte)3};
  for (int i=0; i < PongCacher.NUM_HOPS + 4; i++) {
    PingReply curPong=PingReply.create(new GUID().bytes(),(byte)3,13232,ip,0,0,true,-1,false);
    PrivilegedAccessor.setValue((Object)curPong,""String_Node_Str"",""String_Node_Str"");
    for (int j=0; j < i; j++) {
      if (j < PongCacher.NUM_HOPS) {
        curPong.hop();
      }
    }
    PongCacher.instance().addPong(curPong);
  }
  byte[] ip2={(byte)1,(byte)3,(byte)3,(byte)3};
  for (int i=0; i < PongCacher.NUM_HOPS + 4; i++) {
    PingReply curPong=PingReply.create(new GUID().bytes(),(byte)3,13232,ip2,0,0,true,-1,false);
    PrivilegedAccessor.setValue((Object)curPong,""String_Node_Str"",""String_Node_Str"");
    for (int j=0; j < i; j++) {
      if (j < PongCacher.NUM_HOPS) {
        curPong.hop();
      }
    }
    PongCacher.instance().addPong(curPong);
  }
  byte[] ip3={(byte)3,(byte)3,(byte)3,(byte)3};
  for (int i=0; i < 2; i++) {
    PingReply curPong=PingReply.create(new GUID().bytes(),(byte)3,13232,ip3,0,0,true,-1,false);
    PrivilegedAccessor.setValue((Object)curPong,""String_Node_Str"",""String_Node_Str"");
    for (int j=0; j < i; j++) {
      if (j < PongCacher.NUM_HOPS) {
        curPong.hop();
      }
    }
    PongCacher.instance().addPong(curPong);
  }
  List pongs=PongCacher.instance().getBestPongs(""String_Node_Str"");
  assertEquals(PongCacher.NUM_HOPS,pongs.size());
  pongs=PongCacher.instance().getBestPongs(""String_Node_Str"");
  assertEquals(PongCacher.NUM_HOPS,pongs.size());
  pongs=PongCacher.instance().getBestPongs(""String_Node_Str"");
  assertEquals(PongCacher.NUM_HOPS,pongs.size());
  ApplicationSettings.LANGUAGE.setValue(""String_Node_Str"");
  Message m=new PingRequest((byte)7);
  assertEquals(""String_Node_Str"",""String_Node_Str"",((PingRequest)m).getLocale());
  ApplicationSettings.LANGUAGE.setValue(""String_Node_Str"");
  Message m2=new PingRequest((byte)7);
  assertEquals(""String_Node_Str"",""String_Node_Str"",((PingRequest)m2).getLocale());
  ApplicationSettings.LANGUAGE.setValue(""String_Node_Str"");
  ULTRAPEER_3.send(m);
  ULTRAPEER_3.flush();
  Thread.sleep(100);
  ApplicationSettings.LANGUAGE.setValue(""String_Node_Str"");
  ULTRAPEER_4.send(m2);
  ULTRAPEER_4.flush();
  Message received;
  for (int i=0; i < PongCacher.NUM_HOPS; i++) {
    received=getFirstMessageOfType(ULTRAPEER_3,PingReply.class,10000);
    assertNotNull(""String_Node_Str"" + i,received);
    PingReply pr=(PingReply)received;
    assertEquals(""String_Node_Str"",""String_Node_Str"",pr.getClientLocale());
  }
  List returnedPongs=new ArrayList();
  for (int i=0; i < PongCacher.NUM_HOPS; i++) {
    received=getFirstMessageOfType(ULTRAPEER_4,PingReply.class,10000);
    assertNotNull(""String_Node_Str"" + i,received);
    PingReply pr=(PingReply)received;
    returnedPongs.add(pr);
  }
  int numSVPongs=0;
  Iterator iter=returnedPongs.iterator();
  while (iter.hasNext()) {
    PingReply pr=(PingReply)iter.next();
    if (pr.getClientLocale().equals(""String_Node_Str""))     numSVPongs++;
 else     assertEquals(""String_Node_Str"",""String_Node_Str"",pr.getClientLocale());
  }
  assertEquals(""String_Node_Str"",2,numSVPongs);
  PingPongSettings.PINGS_ACTIVE.setValue(true);
}","/** 
 * Tests to make sure that pongs are received properly via pong caching when the locale is specified in the ping
 */
public void testPongsReceivedFromPingWithLocale() throws Exception {
  PingPongSettings.PINGS_ACTIVE.setValue(false);
  byte[] ip={(byte)1,(byte)2,(byte)3,(byte)3};
  for (int i=0; i < PongCacher.NUM_HOPS + 4; i++) {
    PingReply curPong=PingReply.create(new GUID().bytes(),(byte)3,13232,ip,0,0,true,-1,false,""String_Node_Str"",1);
    for (int j=0; j < i; j++) {
      if (j < PongCacher.NUM_HOPS) {
        curPong.hop();
      }
    }
    PongCacher.instance().addPong(curPong);
  }
  byte[] ip2={(byte)1,(byte)3,(byte)3,(byte)3};
  for (int i=0; i < PongCacher.NUM_HOPS + 4; i++) {
    PingReply curPong=PingReply.create(new GUID().bytes(),(byte)3,13232,ip2,0,0,true,-1,false,""String_Node_Str"",1);
    for (int j=0; j < i; j++) {
      if (j < PongCacher.NUM_HOPS) {
        curPong.hop();
      }
    }
    PongCacher.instance().addPong(curPong);
  }
  List pongs=PongCacher.instance().getBestPongs(""String_Node_Str"");
  assertEquals(PongCacher.NUM_HOPS,pongs.size());
  pongs=PongCacher.instance().getBestPongs(""String_Node_Str"");
  assertEquals(PongCacher.NUM_HOPS,pongs.size());
  ApplicationSettings.LANGUAGE.setValue(""String_Node_Str"");
  Message m=new PingRequest((byte)7);
  assertEquals(""String_Node_Str"",""String_Node_Str"",((PingRequest)m).getLocale());
  ULTRAPEER_3.send(m);
  ULTRAPEER_3.flush();
  Thread.sleep(100);
  ApplicationSettings.LANGUAGE.setValue(""String_Node_Str"");
  Message received;
  for (int i=0; i < PongCacher.NUM_HOPS; i++) {
    received=getFirstMessageOfType(ULTRAPEER_3,PingReply.class,5000);
    assertNotNull(""String_Node_Str"" + i,received);
    PingReply pr=(PingReply)received;
    assertEquals(""String_Node_Str"",""String_Node_Str"",pr.getClientLocale());
  }
  byte[] ip3={(byte)3,(byte)3,(byte)3,(byte)3};
  for (int i=0; i < 2; i++) {
    PingReply curPong=PingReply.create(new GUID().bytes(),(byte)3,13232,ip3,0,0,true,-1,false,""String_Node_Str"",1);
    for (int j=0; j < i; j++) {
      if (j < PongCacher.NUM_HOPS) {
        curPong.hop();
      }
    }
    PongCacher.instance().addPong(curPong);
  }
  pongs=PongCacher.instance().getBestPongs(""String_Node_Str"");
  assertEquals(PongCacher.NUM_HOPS,pongs.size());
  ApplicationSettings.LANGUAGE.setValue(""String_Node_Str"");
  Message m2=new PingRequest((byte)7);
  assertEquals(""String_Node_Str"",""String_Node_Str"",((PingRequest)m2).getLocale());
  ULTRAPEER_4.send(m2);
  ULTRAPEER_4.flush();
  List returnedPongs=new ArrayList();
  for (int i=0; i < PongCacher.NUM_HOPS; i++) {
    received=getFirstMessageOfType(ULTRAPEER_4,PingReply.class,5000);
    assertNotNull(""String_Node_Str"" + i,received);
    PingReply pr=(PingReply)received;
    returnedPongs.add(pr);
  }
  int numSVPongs=0;
  Iterator iter=returnedPongs.iterator();
  while (iter.hasNext()) {
    PingReply pr=(PingReply)iter.next();
    if (pr.getClientLocale().equals(""String_Node_Str""))     numSVPongs++;
 else     assertEquals(""String_Node_Str"",""String_Node_Str"",pr.getClientLocale());
  }
  assertEquals(""String_Node_Str"",2,numSVPongs);
  PingPongSettings.PINGS_ACTIVE.setValue(true);
}",0.6445856019358742
4421,"/** 
 * @return A CapabilitiesVM with the set of messages this client supports.
 */
public static CapabilitiesVM instance(){
  if (_instance == null)   _instance=new CapabilitiesVM();
  return _instance;
}","/** 
 * @return A CapabilitiesVM with the set of messages this client supports.
 */
public synchronized static CapabilitiesVM instance(){
  if (_instance == null)   _instance=new CapabilitiesVM();
  return _instance;
}",0.9692671394799054
4422,"public static void updateSimppVersion(int newSimppVersion){
  Assert.that(newSimppVersion > _simppVersion,""String_Node_Str"" + newSimppVersion + ""String_Node_Str""+ _simppVersion);
  _simppVersion=newSimppVersion;
  _instance=null;
}","public static void updateSimppVersion(int newSimppVersion){
  Assert.that(newSimppVersion > _simppVersion,""String_Node_Str"" + newSimppVersion + ""String_Node_Str""+ _simppVersion);
  _simppVersion=newSimppVersion;
synchronized (CapabilitiesVM.class) {
    _instance=null;
  }
}",0.9130434782608696
4423,"public void run(){
  boolean proceed=false;
  byte[] key=_file.getClientGUID();
synchronized (UDP_FAILOVER) {
    Set files=(Set)UDP_FAILOVER.get(key);
    if (files != null && files.contains(_file.getFileName())) {
      proceed=true;
      files.remove(_file.getFileName());
      if (files.isEmpty())       UDP_FAILOVER.remove(key);
    }
  }
  if (proceed)   if (sendPushTCP(_file,_guid)) synchronized (_toNotify) {
    _toNotify.notify();
  }
}","public void run(){
  boolean proceed=false;
  byte[] key=_file.getClientGUID();
synchronized (UDP_FAILOVER) {
    Set files=(Set)UDP_FAILOVER.get(key);
    if (files != null && files.contains(_file.getFileName())) {
      proceed=true;
      files.remove(_file.getFileName());
      if (files.isEmpty())       UDP_FAILOVER.remove(key);
    }
  }
  if (proceed)   sendPushTCP(_file,_guid);
}",0.9249106078665076
4424,"public PushFailoverRequestor(RemoteFileDesc file,byte[] guid,Object toNotify){
  _file=file;
  _guid=guid;
  _toNotify=toNotify;
}","public PushFailoverRequestor(RemoteFileDesc file,byte[] guid){
  _file=file;
  _guid=guid;
}",0.8288288288288288
4425,"/** 
 * Sends a push request for the given file.  Returns false iff no push could be sent, i.e., because no routing entry exists. That generally means you shouldn't send any more pushes for this file.
 * @param file the <tt>RemoteFileDesc</tt> constructed from the query hit, containing data about the host we're pushing to
 * @return <tt>true</tt> if the push was successfully sent, otherwise<tt>false</tt>
 */
public void sendPush(final RemoteFileDesc file,final Object toNotify){
  byte[] addr=RouterService.getAddress();
  int port=RouterService.getPort();
  if (!NetworkUtils.isValidAddress(addr) || !NetworkUtils.isValidPort(port))   return;
  final byte[] guid=GUID.makeGuid();
  if (sendPushMulticast(file,guid))   return;
  byte[] key=file.getClientGUID();
synchronized (UDP_FAILOVER) {
    Set files=(Set)UDP_FAILOVER.get(key);
    if (files == null)     files=new HashSet();
    files.add(file.getFileName());
    UDP_FAILOVER.put(key,files);
  }
  RouterService.schedule(new Runnable(){
    public void run(){
      FAILOVERS.add(new PushFailoverRequestor(file,guid,toNotify));
    }
  }
,UDP_PUSH_FAILTIME,0);
  sendPushUDP(file,guid);
}","/** 
 * Sends a push request for the given file.  Returns false iff no push could be sent, i.e., because no routing entry exists. That generally means you shouldn't send any more pushes for this file.
 * @param file the <tt>RemoteFileDesc</tt> constructed from the query hit, containing data about the host we're pushing to
 * @return <tt>true</tt> if the push was successfully sent, otherwise<tt>false</tt>
 */
public void sendPush(final RemoteFileDesc file){
  byte[] addr=RouterService.getAddress();
  int port=RouterService.getPort();
  if (!NetworkUtils.isValidAddress(addr) || !NetworkUtils.isValidPort(port))   return;
  final byte[] guid=GUID.makeGuid();
  if (sendPushMulticast(file,guid))   return;
  byte[] key=file.getClientGUID();
synchronized (UDP_FAILOVER) {
    Set files=(Set)UDP_FAILOVER.get(key);
    if (files == null)     files=new HashSet();
    files.add(file.getFileName());
    UDP_FAILOVER.put(key,files);
  }
  RouterService.schedule(new Runnable(){
    public void run(){
      FAILOVERS.add(new PushFailoverRequestor(file,guid));
    }
  }
,UDP_PUSH_FAILTIME,0);
  sendPushUDP(file,guid);
}",0.986337593653592
4426,"/** 
 * Attempts to connect by using a push to the remote end. BLOCKING.
 */
private HTTPDownloader connectWithPush(RemoteFileDesc rfd,File incFile) throws IOException {
  LOG.trace(""String_Node_Str"");
  HTTPDownloader ret;
  Object threadLock=new Object();
  MiniRemoteFileDesc mrfd=new MiniRemoteFileDesc(rfd.getFileName(),rfd.getIndex(),rfd.getClientGUID());
  miniRFDToLock.put(mrfd,threadLock);
  boolean pushSent;
synchronized (threadLock) {
    manager.sendPush(rfd,threadLock);
    try {
      threadLock.wait(PUSH_CONNECT_TIME);
    }
 catch (    InterruptedException e) {
      if (RECORD_STATS)       DownloadStat.PUSH_FAILURE_INTERRUPTED.incrementStat();
      throw new IOException(""String_Node_Str"");
    }
  }
  Socket pushSocket=(Socket)threadLockToSocket.remove(threadLock);
  if (pushSocket == null) {
    DownloadStat.PUSH_FAILURE_NO_RESPONSE.incrementStat();
    throw new IOException(""String_Node_Str"");
  }
  miniRFDToLock.remove(mrfd);
  ret=new HTTPDownloader(pushSocket,rfd,incFile);
  try {
    ret.connectTCP(0);
    if (RECORD_STATS)     DownloadStat.CONNECT_PUSH_SUCCESS.incrementStat();
  }
 catch (  IOException iox) {
    if (RECORD_STATS)     DownloadStat.PUSH_FAILURE_LOST.incrementStat();
    throw iox;
  }
  return ret;
}","/** 
 * Attempts to connect by using a push to the remote end. BLOCKING.
 */
private HTTPDownloader connectWithPush(RemoteFileDesc rfd,File incFile) throws IOException {
  LOG.trace(""String_Node_Str"");
  HTTPDownloader ret;
  Object threadLock=new Object();
  MiniRemoteFileDesc mrfd=new MiniRemoteFileDesc(rfd.getFileName(),rfd.getIndex(),rfd.getClientGUID());
  miniRFDToLock.put(mrfd,threadLock);
  boolean pushSent;
synchronized (threadLock) {
    manager.sendPush(rfd);
    try {
      threadLock.wait(PUSH_CONNECT_TIME);
    }
 catch (    InterruptedException e) {
      if (RECORD_STATS)       DownloadStat.PUSH_FAILURE_INTERRUPTED.incrementStat();
      throw new IOException(""String_Node_Str"");
    }
  }
  Socket pushSocket=(Socket)threadLockToSocket.remove(threadLock);
  if (pushSocket == null) {
    DownloadStat.PUSH_FAILURE_NO_RESPONSE.incrementStat();
    throw new IOException(""String_Node_Str"");
  }
  miniRFDToLock.remove(mrfd);
  ret=new HTTPDownloader(pushSocket,rfd,incFile);
  try {
    ret.connectTCP(0);
    if (RECORD_STATS)     DownloadStat.CONNECT_PUSH_SUCCESS.incrementStat();
  }
 catch (  IOException iox) {
    if (RECORD_STATS)     DownloadStat.PUSH_FAILURE_LOST.incrementStat();
    throw iox;
  }
  return ret;
}",0.9956087824351296
4427,"public void testHTTPRequest() throws Exception {
  drain(testUP[0]);
  byte[] clientGUID=GUID.makeGuid();
  byte[] guid=GUID.makeGuid();
  RouterService.query(guid,""String_Node_Str"");
  Message m=null;
  do {
    m=testUP[0].receive(TIMEOUT);
  }
 while (!(m instanceof QueryRequest));
  ServerSocket ss=new ServerSocket(7000);
  ss.setReuseAddress(true);
  ss.setSoTimeout(15 * TIMEOUT);
  Set proxies=new HashSet();
  proxies.add(new QueryReply.PushProxyContainer(""String_Node_Str"",7000));
  Response[] res=new Response[1];
  res[0]=new Response(10,10,""String_Node_Str"");
  m=new QueryReply(m.getGUID(),(byte)1,6355,myIP(),0,res,clientGUID,new byte[0],false,false,true,true,false,false,proxies);
  testUP[0].send(m);
  testUP[0].flush();
  Thread.sleep(1000);
  assertTrue(((MyActivityCallback)getCallback()).getRFD() != null);
  RouterService.download((new RemoteFileDesc[]{((MyActivityCallback)getCallback()).getRFD()}),true,new GUID(m.getGUID()));
  Socket httpSock=ss.accept();
  assertNotNull(httpSock);
  String currLine=null;
  BufferedReader reader=new BufferedReader(new InputStreamReader(httpSock.getInputStream()));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str"") || currLine.startsWith(""String_Node_Str""));
  int beginIndex=currLine.indexOf(""String_Node_Str"") + 3;
  String guidString=currLine.substring(beginIndex,beginIndex + 26);
  GUID guidFromBackend=new GUID(clientGUID);
  GUID guidFromNetwork=new GUID(Base32.decode(guidString));
  assertEquals(guidFromNetwork,guidFromBackend);
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  StringTokenizer st=new StringTokenizer(currLine,""String_Node_Str"");
  assertEquals(st.nextToken(),""String_Node_Str"");
  InetAddress addr=InetAddress.getByName(st.nextToken().trim());
  Arrays.equals(addr.getAddress(),RouterService.getAddress());
  assertEquals(Integer.parseInt(st.nextToken()),PORT);
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(httpSock.getOutputStream()));
  writer.write(""String_Node_Str"");
  writer.flush();
  httpSock.close();
  try {
    do {
      m=testUP[0].receive(TIMEOUT);
      assertTrue(!(m instanceof PushRequest));
    }
 while (true);
  }
 catch (  InterruptedIOException expected) {
  }
  Socket push=new Socket(InetAddress.getLocalHost(),PORT);
  writer=new BufferedWriter(new OutputStreamWriter(push.getOutputStream()));
  writer.write(""String_Node_Str"" + new GUID(clientGUID).toHexString() + ""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.flush();
  reader=new BufferedReader(new InputStreamReader(push.getInputStream()));
  currLine=reader.readLine();
  assertEquals(""String_Node_Str"",currLine);
  push.close();
  ss.close();
}","public void testHTTPRequest() throws Exception {
  drain(testUP[0]);
  byte[] clientGUID=GUID.makeGuid();
  byte[] guid=GUID.makeGuid();
  RouterService.query(guid,""String_Node_Str"");
  Message m=null;
  do {
    m=testUP[0].receive(TIMEOUT);
  }
 while (!(m instanceof QueryRequest));
  ServerSocket ss=new ServerSocket(7000);
  ss.setReuseAddress(true);
  ss.setSoTimeout(25 * TIMEOUT);
  Set proxies=new HashSet();
  proxies.add(new QueryReply.PushProxyContainer(""String_Node_Str"",7000));
  Response[] res=new Response[1];
  res[0]=new Response(10,10,""String_Node_Str"");
  m=new QueryReply(m.getGUID(),(byte)1,6355,myIP(),0,res,clientGUID,new byte[0],false,false,true,true,false,false,proxies);
  testUP[0].send(m);
  testUP[0].flush();
  Thread.sleep(1000);
  assertTrue(((MyActivityCallback)getCallback()).getRFD() != null);
  RouterService.download((new RemoteFileDesc[]{((MyActivityCallback)getCallback()).getRFD()}),true,new GUID(m.getGUID()));
  Socket httpSock=ss.accept();
  assertNotNull(httpSock);
  String currLine=null;
  BufferedReader reader=new BufferedReader(new InputStreamReader(httpSock.getInputStream()));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str"") || currLine.startsWith(""String_Node_Str""));
  int beginIndex=currLine.indexOf(""String_Node_Str"") + 3;
  String guidString=currLine.substring(beginIndex,beginIndex + 26);
  GUID guidFromBackend=new GUID(clientGUID);
  GUID guidFromNetwork=new GUID(Base32.decode(guidString));
  assertEquals(guidFromNetwork,guidFromBackend);
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  StringTokenizer st=new StringTokenizer(currLine,""String_Node_Str"");
  assertEquals(st.nextToken(),""String_Node_Str"");
  InetAddress addr=InetAddress.getByName(st.nextToken().trim());
  Arrays.equals(addr.getAddress(),RouterService.getAddress());
  assertEquals(Integer.parseInt(st.nextToken()),PORT);
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(httpSock.getOutputStream()));
  writer.write(""String_Node_Str"");
  writer.flush();
  httpSock.close();
  try {
    do {
      m=testUP[0].receive(TIMEOUT);
      assertTrue(!(m instanceof PushRequest));
    }
 while (true);
  }
 catch (  InterruptedIOException expected) {
  }
  Socket push=new Socket(InetAddress.getLocalHost(),PORT);
  writer=new BufferedWriter(new OutputStreamWriter(push.getOutputStream()));
  writer.write(""String_Node_Str"" + new GUID(clientGUID).toHexString() + ""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.flush();
  reader=new BufferedReader(new InputStreamReader(push.getInputStream()));
  currLine=reader.readLine();
  assertEquals(""String_Node_Str"",currLine);
  push.close();
  ss.close();
}",0.9996331621423332
4428,"/** 
 * Resets the map to contain all the files in the saved directory. Does nothing if this is already loading, or if FileManager is still loading.
 */
private void load(){
  LOG.trace(""String_Node_Str"");
  Set urns=new HashSet();
  Set names=new TreeSet(Comparators.caseInsensitiveStringComparator());
  File saveDirectory=SharingSettings.getSaveDirectory();
  String[] saved=saveDirectory.list();
  if (saved == null)   saved=new String[0];
  for (int i=0; i < saved.length; i++) {
    String name=saved[i];
    File file=new File(saveDirectory,name);
    if (!file.isFile())     continue;
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + file);
    names.add(name);
    Set fileUrns;
    try {
      fileUrns=FileDesc.calculateAndCacheURN(file);
      for (Iterator j=fileUrns.iterator(); j.hasNext(); )       urns.add(j.next());
    }
 catch (    IOException ignored) {
    }
catch (    InterruptedException ignored) {
    }
  }
synchronized (this) {
    _names=names;
    _urns=urns;
  }
  LOG.trace(""String_Node_Str"");
}","/** 
 * Resets the map to contain all the files in the saved directory. Does nothing if this is already loading, or if FileManager is still loading.
 */
private void load(){
  LOG.trace(""String_Node_Str"");
  Set urns=new HashSet();
  Set names=new TreeSet(Comparators.caseInsensitiveStringComparator());
  File saveDirectory=SharingSettings.getSaveDirectory();
  String[] saved=saveDirectory.list();
  if (saved == null)   saved=new String[0];
  for (int i=0; i < saved.length; i++) {
    String name=saved[i];
    File file=new File(saveDirectory,name);
    if (!file.isFile() || !file.exists())     continue;
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + file);
    names.add(name);
    Set fileUrns;
    try {
      fileUrns=FileDesc.calculateAndCacheURN(file);
      for (Iterator j=fileUrns.iterator(); j.hasNext(); )       urns.add(j.next());
    }
 catch (    IOException ignored) {
    }
catch (    InterruptedException ignored) {
    }
  }
synchronized (this) {
    _names=names;
    _urns=urns;
  }
  LOG.trace(""String_Node_Str"");
}",0.9914367269267363
4429,"/** 
 * Determines whether or not the given IOException can can be ignored. Visit http://www.dte.net/winsock_error.htm for explanations of each code/message. Most of these have no meaning when applied to UDP, but it doesn't hurt to check for ones that aren't harmful. Depending on the version of Java or the OS, the error may either be ""Datagram send failed (code=<code>)"" or simply the text of the error.
 */
private boolean isIgnoreable(Throwable ex,final String message){
  if (""String_Node_Str"".equals(ex.getClass().getName()))   return true;
  if (message == null)   return false;
  final String msg=message.toLowerCase();
  if (scan(msg,10013,""String_Node_Str""))   return true;
  if (scan(msg,10049,""String_Node_Str""))   return true;
  if (scan(msg,10053,""String_Node_Str""))   return true;
  if (scan(msg,10054,""String_Node_Str""))   return true;
  if (scan(msg,10061,""String_Node_Str""))   return true;
  if (scan(msg,10064,""String_Node_Str""))   return true;
  if (scan(msg,10065,""String_Node_Str""))   return true;
  if (scan(msg,10004,""String_Node_Str""))   return true;
  if (scan(msg,10050,""String_Node_Str""))   return true;
  if (scan(msg,10052,""String_Node_Str""))   return true;
  if (scan(msg,10051,""String_Node_Str""))   return true;
  if (scan(msg,10055,""String_Node_Str""))   return true;
  if (scan(msg,10060,""String_Node_Str""))   return true;
  if (scan(msg,10035,""String_Node_Str""))   return true;
  if (scan(msg,11001,""String_Node_Str""))   return true;
  if (scan(msg,10091,""String_Node_Str""))   return true;
  if (scan(msg,10107,null))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (msg.indexOf(""String_Node_Str"") > -1)   return true;
  return false;
}","/** 
 * Determines whether or not the given IOException can can be ignored. Visit http://www.dte.net/winsock_error.htm for explanations of each code/message. Most of these have no meaning when applied to UDP, but it doesn't hurt to check for ones that aren't harmful. Depending on the version of Java or the OS, the error may either be ""Datagram send failed (code=<code>)"" or simply the text of the error.
 */
private boolean isIgnoreable(Throwable ex,final String message){
  if (""String_Node_Str"".equals(ex.getClass().getName()))   return true;
  if (message == null)   return false;
  final String msg=message.toLowerCase();
  if (scan(msg,1784,""String_Node_Str""))   return true;
  if (scan(msg,10004,""String_Node_Str""))   return true;
  if (scan(msg,10013,""String_Node_Str""))   return true;
  if (scan(msg,10022,""String_Node_Str""))   return true;
  if (scan(msg,10035,""String_Node_Str""))   return true;
  if (scan(msg,10038,""String_Node_Str""))   return true;
  if (scan(msg,10049,""String_Node_Str""))   return true;
  if (scan(msg,10050,""String_Node_Str""))   return true;
  if (scan(msg,10051,""String_Node_Str""))   return true;
  if (scan(msg,10052,""String_Node_Str""))   return true;
  if (scan(msg,10053,""String_Node_Str""))   return true;
  if (scan(msg,10054,""String_Node_Str""))   return true;
  if (scan(msg,10055,""String_Node_Str""))   return true;
  if (scan(msg,10060,""String_Node_Str""))   return true;
  if (scan(msg,10061,""String_Node_Str""))   return true;
  if (scan(msg,10064,""String_Node_Str""))   return true;
  if (scan(msg,10065,""String_Node_Str""))   return true;
  if (scan(msg,10091,""String_Node_Str""))   return true;
  if (scan(msg,10107,null))   return true;
  if (scan(msg,11001,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (scan(msg,-1,""String_Node_Str""))   return true;
  if (msg.indexOf(""String_Node_Str"") > -1)   return true;
  return false;
}",0.7063551871389098
4430,"/** 
 * Returns whether or not the http request corresponds with the standard  uri-res request
 * @param requestLine the <tt>String</tt> instance containing the http request
 * @return <tt>true</tt> if the http request includes the standard ""uri-res""(case-insensitive) request, <tt>false</tt> otherwise
 */
private static final boolean isValidUriRes(final String requestLine){
  int firstSlash=requestLine.indexOf(SLASH);
  if (firstSlash == -1) {
    return false;
  }
  int secondSlash=requestLine.indexOf(SLASH,firstSlash + 1);
  if (secondSlash == -1) {
    return false;
  }
  String uriStr=requestLine.substring(firstSlash + 1,secondSlash);
  if (!uriStr.equalsIgnoreCase(HTTPConstants.URI_RES)) {
    return false;
  }
  return true;
}","/** 
 * Returns whether or not the http request corresponds with the standard  uri-res request
 * @param requestLine the <tt>String</tt> instance containing the http request
 * @return <tt>true</tt> if the http request includes the standard ""uri-res""(case-insensitive) request, <tt>false</tt> otherwise
 */
private static final boolean isValidUriRes(final String requestLine){
  int firstSlash=requestLine.indexOf(SLASH);
  if (firstSlash == -1 || firstSlash == requestLine.length()) {
    return false;
  }
  int secondSlash=requestLine.indexOf(SLASH,firstSlash + 1);
  if (secondSlash == -1) {
    return false;
  }
  String uriStr=requestLine.substring(firstSlash + 1,secondSlash);
  if (!uriStr.equalsIgnoreCase(HTTPConstants.URI_RES)) {
    return false;
  }
  return true;
}",0.9750328515111696
4431,"/** 
 * Initializes the uploader's state. If the file is valid for uploading, this leaves the state as connecting.
 */
private void setInitialUploadingState(HTTPUploader uploader){
switch (uploader.getIndex()) {
case BROWSE_HOST_FILE_INDEX:
    uploader.setState(Uploader.BROWSE_HOST);
  return;
case FILE_VIEW_FILE_INDEX:
uploader.setState(Uploader.FILE_VIEW);
return;
case PUSH_PROXY_FILE_INDEX:
uploader.setState(Uploader.PUSH_PROXY);
return;
case UPDATE_FILE_INDEX:
uploader.setState(Uploader.UPDATE_FILE);
return;
case BAD_URN_QUERY_INDEX:
uploader.setState(Uploader.FILE_NOT_FOUND);
return;
case MALFORMED_REQUEST_INDEX:
uploader.setState(Uploader.MALFORMED_REQUEST);
return;
default :
FileManager fm=RouterService.getFileManager();
FileDesc fd=null;
int index=uploader.getIndex();
if (fm.isValidIndex(index)) {
fd=fm.get(index);
}
if (fd == null) {
if (LOG.isDebugEnabled()) LOG.debug(uploader + ""String_Node_Str"");
uploader.setState(Uploader.FILE_NOT_FOUND);
return;
}
if (!uploader.getFileName().equals(fd.getName())) {
if (LOG.isDebugEnabled()) LOG.debug(uploader + ""String_Node_Str"");
uploader.setState(Uploader.FILE_NOT_FOUND);
return;
}
try {
uploader.setFileDesc(fd);
}
 catch (IOException ioe) {
if (LOG.isDebugEnabled()) LOG.debug(uploader + ""String_Node_Str"");
uploader.setState(Uploader.FILE_NOT_FOUND);
return;
}
assertAsConnecting(uploader.getState());
}
}","/** 
 * Initializes the uploader's state. If the file is valid for uploading, this leaves the state as connecting.
 */
private void setInitialUploadingState(HTTPUploader uploader){
switch (uploader.getIndex()) {
case BROWSE_HOST_FILE_INDEX:
    uploader.setState(Uploader.BROWSE_HOST);
  return;
case FILE_VIEW_FILE_INDEX:
uploader.setState(Uploader.FILE_VIEW);
return;
case PUSH_PROXY_FILE_INDEX:
uploader.setState(Uploader.PUSH_PROXY);
return;
case UPDATE_FILE_INDEX:
uploader.setState(Uploader.UPDATE_FILE);
return;
case BAD_URN_QUERY_INDEX:
uploader.setState(Uploader.FILE_NOT_FOUND);
return;
case MALFORMED_REQUEST_INDEX:
uploader.setState(Uploader.MALFORMED_REQUEST);
return;
default :
FileManager fm=RouterService.getFileManager();
FileDesc fd=null;
int index=uploader.getIndex();
synchronized (fm) {
if (fm.isValidIndex(index)) {
fd=fm.get(index);
}
}
if (fd == null) {
if (LOG.isDebugEnabled()) LOG.debug(uploader + ""String_Node_Str"");
uploader.setState(Uploader.FILE_NOT_FOUND);
return;
}
if (!uploader.getFileName().equals(fd.getName())) {
if (LOG.isDebugEnabled()) LOG.debug(uploader + ""String_Node_Str"");
uploader.setState(Uploader.FILE_NOT_FOUND);
return;
}
try {
uploader.setFileDesc(fd);
}
 catch (IOException ioe) {
if (LOG.isDebugEnabled()) LOG.debug(uploader + ""String_Node_Str"");
uploader.setState(Uploader.FILE_NOT_FOUND);
return;
}
assertAsConnecting(uploader.getState());
}
}",0.9906272530641672
4432,"public boolean hasHashTree(){
  return (_thexUri != null && _root32 != null && !_rfd.hasTHEXFailed());
}","/** 
 * Returns TRUE if this downloader has a THEX tree that we have not yet retrieved.
 */
public boolean hasHashTree(){
  return _thexUri != null && _root32 != null && !_rfd.hasTHEXFailed() && !_thexSucceeded;
}",0.6435331230283912
4433,"/** 
 * Returns the ConnectionStatus from the request. Can be one of: Connected -- means to immediately assignAndRequest. Queued -- means to sleep while queued. ThexResponse -- means the thex tree was received.
 */
public ConnectionStatus requestHashTree(){
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + _thexUri + ""String_Node_Str""+ _host+ ""String_Node_Str""+ _port);
  try {
    String str;
    str=""String_Node_Str"" + _thexUri + ""String_Node_Str"";
    _output.write(str.getBytes());
    str=""String_Node_Str"" + _host + ""String_Node_Str""+ _port+ ""String_Node_Str"";
    _output.write(str.getBytes());
    str=""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"";
    _output.write(str.getBytes());
    str=""String_Node_Str"";
    _output.write(str.getBytes());
    _output.flush();
  }
 catch (  IOException ioe) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"");
    return ConnectionStatus.getConnected();
  }
  try {
    String line=_byteReader.readLine();
    if (line == null)     throw new IOException(""String_Node_Str"");
    int code=parseHTTPCode(line,_rfd);
    if (code < 200 || code >= 300) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + code);
      _rfd.setTHEXFailed();
      return consumeResponse(code);
    }
    int contentLength=consumeHeaders(null);
    InputStream in=_input;
    if (contentLength != -1)     in=new CountingInputStream(_input);
    try {
      HashTree hashTree=HashTree.createHashTree(in,_rfd.getSHA1Urn().toString(),_root32,(long)_rfd.getSize());
      return ConnectionStatus.getThexResponse(hashTree);
    }
 catch (    IOException ioe) {
      if (in instanceof CountingInputStream) {
        LOG.debug(""String_Node_Str"",ioe);
        _rfd.setTHEXFailed();
        int read=((CountingInputStream)in).getAmountRead();
        return consumeBody(contentLength - read);
      }
 else {
        throw ioe;
      }
    }
  }
 catch (  IOException ioe) {
    LOG.debug(""String_Node_Str"",ioe);
    _rfd.setTHEXFailed();
    return ConnectionStatus.getConnected();
  }
}","/** 
 * Returns the ConnectionStatus from the request. Can be one of: Connected -- means to immediately assignAndRequest. Queued -- means to sleep while queued. ThexResponse -- means the thex tree was received.
 */
public ConnectionStatus requestHashTree(){
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + _thexUri + ""String_Node_Str""+ _host+ ""String_Node_Str""+ _port);
  try {
    String str;
    str=""String_Node_Str"" + _thexUri + ""String_Node_Str"";
    _output.write(str.getBytes());
    str=""String_Node_Str"" + _host + ""String_Node_Str""+ _port+ ""String_Node_Str"";
    _output.write(str.getBytes());
    str=""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"";
    _output.write(str.getBytes());
    str=""String_Node_Str"";
    _output.write(str.getBytes());
    _output.flush();
  }
 catch (  IOException ioe) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"");
    return ConnectionStatus.getConnected();
  }
  try {
    String line=_byteReader.readLine();
    if (line == null)     throw new IOException(""String_Node_Str"");
    int code=parseHTTPCode(line,_rfd);
    if (code < 200 || code >= 300) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + code);
      _rfd.setTHEXFailed();
      return consumeResponse(code);
    }
    int contentLength=consumeHeaders(null);
    InputStream in=_input;
    if (contentLength != -1)     in=new CountingInputStream(_input);
    try {
      HashTree hashTree=HashTree.createHashTree(in,_rfd.getSHA1Urn().toString(),_root32,(long)_rfd.getSize());
      _thexSucceeded=true;
      return ConnectionStatus.getThexResponse(hashTree);
    }
 catch (    IOException ioe) {
      if (in instanceof CountingInputStream) {
        LOG.debug(""String_Node_Str"",ioe);
        _rfd.setTHEXFailed();
        int read=((CountingInputStream)in).getAmountRead();
        return consumeBody(contentLength - read);
      }
 else {
        throw ioe;
      }
    }
  }
 catch (  IOException ioe) {
    LOG.debug(""String_Node_Str"",ioe);
    _rfd.setTHEXFailed();
    return ConnectionStatus.getConnected();
  }
}",0.9935236267690094
4434,"/** 
 * Generates ID3Data from id3v2 data in the file.
 */
private void parseID3v2Data(File file){
  ID3v2 id3v2Parser=null;
  try {
    id3v2Parser=new ID3v2(file);
  }
 catch (  ID3v2Exception idvx) {
    return;
  }
catch (  IOException iox) {
    return;
  }
  Vector frames=null;
  try {
    frames=id3v2Parser.getFrames();
  }
 catch (  NoID3v2TagException ntx) {
    return;
  }
  for (Iterator iter=frames.iterator(); iter.hasNext(); ) {
    ID3v2Frame frame=(ID3v2Frame)iter.next();
    String frameID=frame.getID();
    byte[] contentBytes=frame.getContent();
    String frameContent=null;
    if (contentBytes.length > 0) {
      try {
        String enc=(frame.isISOLatin1()) ? ISO_LATIN_1 : UNICODE;
        frameContent=new String(contentBytes,enc).trim();
      }
 catch (      UnsupportedEncodingException err) {
      }
    }
    if (frameContent == null || frameContent.trim().equals(""String_Node_Str""))     continue;
    if (MP3DataEditor.TITLE_ID.equals(frameID))     setTitle(frameContent);
 else     if (MP3DataEditor.ARTIST_ID.equals(frameID))     setArtist(frameContent);
 else     if (MP3DataEditor.ALBUM_ID.equals(frameID))     setAlbum(frameContent);
 else     if (MP3DataEditor.YEAR_ID.equals(frameID))     setYear(frameContent);
 else     if (MP3DataEditor.COMMENT_ID.equals(frameID)) {
      byte[] bytes=frame.getContent();
      int startIndex=0;
      for (int i=bytes.length - 1; i >= 0; i--) {
        if (bytes[i] != (byte)0)         continue;
        startIndex=i;
        break;
      }
      frameContent=new String(bytes,startIndex,bytes.length - startIndex).trim();
      setComment(frameContent);
    }
 else     if (MP3DataEditor.TRACK_ID.equals(frameID)) {
      try {
        setTrack(Short.parseShort(frameContent));
      }
 catch (      NumberFormatException ignored) {
      }
    }
 else     if (MP3DataEditor.GENRE_ID.equals(frameID)) {
      int startIndex=frameContent.indexOf(""String_Node_Str"");
      int endIndex=frameContent.indexOf(""String_Node_Str"");
      int genreCode=-1;
      if (startIndex > -1 && endIndex > -1) {
        String genreByte=frameContent.substring(startIndex + 1,endIndex);
        try {
          genreCode=Integer.parseInt(genreByte);
        }
 catch (        NumberFormatException nfx) {
          genreCode=-1;
        }
      }
      if (genreCode >= 0 && genreCode <= 127)       setGenre(MP3MetaData.getGenreString((short)genreCode));
 else       setGenre(frameContent);
    }
  }
}","/** 
 * Generates ID3Data from id3v2 data in the file.
 */
private void parseID3v2Data(File file){
  ID3v2 id3v2Parser=null;
  try {
    id3v2Parser=new ID3v2(file);
  }
 catch (  ID3v2Exception idvx) {
    return;
  }
catch (  IOException iox) {
    return;
  }
  Vector frames=null;
  try {
    frames=id3v2Parser.getFrames();
  }
 catch (  NoID3v2TagException ntx) {
    return;
  }
  for (Iterator iter=frames.iterator(); iter.hasNext(); ) {
    ID3v2Frame frame=(ID3v2Frame)iter.next();
    String frameID=frame.getID();
    byte[] contentBytes=frame.getContent();
    String frameContent=null;
    if (contentBytes.length > 0) {
      try {
        String enc=(frame.isISOLatin1()) ? ISO_LATIN_1 : UNICODE;
        frameContent=new String(contentBytes,enc).trim();
      }
 catch (      UnsupportedEncodingException err) {
      }
    }
    if (frameContent == null || frameContent.trim().equals(""String_Node_Str""))     continue;
    if (MP3DataEditor.TITLE_ID.equals(frameID))     setTitle(frameContent);
 else     if (MP3DataEditor.ARTIST_ID.equals(frameID))     setArtist(frameContent);
 else     if (MP3DataEditor.ALBUM_ID.equals(frameID))     setAlbum(frameContent);
 else     if (MP3DataEditor.YEAR_ID.equals(frameID))     setYear(frameContent);
 else     if (MP3DataEditor.COMMENT_ID.equals(frameID)) {
      byte[] bytes=frame.getContent();
      int startIndex=0;
      for (int i=bytes.length - 1; i >= 0; i--) {
        if (bytes[i] != (byte)0)         continue;
        startIndex=i;
        break;
      }
      frameContent=new String(bytes,startIndex,bytes.length - startIndex).trim();
      setComment(frameContent);
    }
 else     if (MP3DataEditor.TRACK_ID.equals(frameID)) {
      try {
        setTrack(Short.parseShort(frameContent));
      }
 catch (      NumberFormatException ignored) {
      }
    }
 else     if (MP3DataEditor.GENRE_ID.equals(frameID)) {
      int startIndex=frameContent.indexOf(""String_Node_Str"");
      int endIndex=frameContent.indexOf(""String_Node_Str"");
      int genreCode=-1;
      if (startIndex > -1 && endIndex > -1 && startIndex < frameContent.length()) {
        String genreByte=frameContent.substring(startIndex + 1,endIndex);
        try {
          genreCode=Integer.parseInt(genreByte);
        }
 catch (        NumberFormatException nfx) {
          genreCode=-1;
        }
      }
      if (genreCode >= 0 && genreCode <= 127)       setGenre(MP3MetaData.getGenreString((short)genreCode));
 else       setGenre(frameContent);
    }
  }
}",0.992363344051447
4435,"/** 
 * Reloads the file from disk to read values from.
 */
public static void reload(){
  File themeFile=ThemeSettings.THEME_FILE.getValue();
  if (!ThemeSettings.isThemeFile(themeFile))   ThemeSettings.THEME_FILE.revertToDefault();
  themeFile=ThemeSettings.THEME_FILE.getValue();
  File themeDir=ThemeSettings.extractThemeDir(themeFile);
  if (!themeDir.isDirectory()) {
    if (!themeFile.exists()) {
      ThemeSettings.THEME_FILE.revertToDefault();
      themeFile=ThemeSettings.THEME_FILE.getValue();
      themeDir=ThemeSettings.extractThemeDir(themeFile);
    }
    ThemeSettings.expandTheme(themeFile,themeDir,false);
  }
  final File THEME_PROPS=new File(themeDir,""String_Node_Str"");
  handleFactory(THEME_PROPS);
  ThemeSettings.THEME_DIR.setValue(themeDir);
}","/** 
 * Reloads the file from disk to read values from.
 */
public static void reload(boolean force){
  File themeFile=ThemeSettings.THEME_FILE.getValue();
  if (!ThemeSettings.isThemeFile(themeFile))   ThemeSettings.THEME_FILE.revertToDefault();
  themeFile=ThemeSettings.THEME_FILE.getValue();
  File themeDir=ThemeSettings.extractThemeDir(themeFile);
  if (force || !themeDir.isDirectory()) {
    if (!themeFile.exists()) {
      ThemeSettings.THEME_FILE.revertToDefault();
      themeFile=ThemeSettings.THEME_FILE.getValue();
      themeDir=ThemeSettings.extractThemeDir(themeFile);
    }
    ThemeSettings.expandTheme(themeFile,themeDir,force || false);
  }
  final File THEME_PROPS=new File(themeDir,""String_Node_Str"");
  handleFactory(THEME_PROPS);
  ThemeSettings.THEME_DIR.setValue(themeDir);
}",0.9803174603174604
4436,"/** 
 * @return true if the DEPTH is ideal enough according to our standards.
 */
public boolean isDepthGoodEnough(){
  return DEPTH >= calculateDepth(FILE_SIZE);
}","/** 
 * @return true if the DEPTH is ideal enough according to our own standards
 */
public boolean isDepthGoodEnough(){
  return DEPTH >= calculateDepth(FILE_SIZE);
}",0.9848942598187312
4437,"/** 
 * This method returns the ranges of a file that do no match the expected TigerTree hashes
 * @param is an <tt>InputStream</tt>
 * @return List of <tt>Interval</tt>
 * @throws IOException if there was a problem reading the file
 */
public List getCorruptRanges(InputStream is) throws IOException {
  LOG.trace(""String_Node_Str"");
  List ret=new ArrayList();
  int n=log2Ceil((int)FILE_SIZE) - DEPTH;
  int nodeSize=1 << n;
  List fileHashes=createTTNodes(nodeSize,FILE_SIZE,is);
  for (int i=0; i < fileHashes.size(); i++) {
    byte[] aHash=(byte[])fileHashes.get(i);
    byte[] bHash=(byte[])NODES.get(i);
    for (int j=0; j < aHash.length; j++) {
      if (aHash[j] != bHash[j]) {
        Interval in=new Interval(i * nodeSize,(int)Math.min((i + 1) * nodeSize - 1,FILE_SIZE - 1));
        ret.add(in);
        if (LOG.isDebugEnabled())         LOG.debug(Base32.encode(ROOT_HASH) + ""String_Node_Str"" + in);
        break;
      }
    }
  }
  return ret;
}","/** 
 * This method returns the ranges of a file that do no match the expected TigerTree hashes
 * @param is an <tt>InputStream</tt>
 * @return List of <tt>Interval</tt>
 * @throws IOException if there was a problem reading the file
 */
public List getCorruptRanges(InputStream is) throws IOException {
  LOG.trace(""String_Node_Str"");
  List ret=new ArrayList();
  int n=log2Ceil((int)FILE_SIZE) - DEPTH;
  int nodeSize=1 << n;
  List fileHashes=createTTNodes(nodeSize,FILE_SIZE,is);
  int minSize=Math.min(fileHashes.size(),NODES.size());
  for (int i=0; i < minSize; i++) {
    byte[] aHash=(byte[])fileHashes.get(i);
    byte[] bHash=(byte[])NODES.get(i);
    for (int j=0; j < aHash.length; j++) {
      if (aHash[j] != bHash[j]) {
        Interval in=new Interval(i * nodeSize,(int)Math.min((i + 1) * nodeSize - 1,FILE_SIZE - 1));
        ret.add(in);
        if (LOG.isDebugEnabled())         LOG.debug(Base32.encode(ROOT_HASH) + ""String_Node_Str"" + in);
        break;
      }
    }
  }
  return ret;
}",0.962474645030426
4438,"public int read(byte[] b,int off,int len) throws IOException {
  int read=super.read(b,off,len);
  _count+=read;
  return read;
}","public int read(byte[] b,int off,int len) throws IOException {
  int read;
  try {
    read=super.read(b,off,len);
  }
 catch (  ArrayIndexOutOfBoundsException aioob) {
    throw new IOException();
  }
  _count+=read;
  return read;
}",0.7107438016528925
4439,"private void deserializeFromFile() throws IOException {
  FileInputStream istream=null;
  ObjectInputStream objStream=null;
  try {
    istream=new FileInputStream(_backingStoreFile);
    objStream=new ObjectInputStream(istream);
    _hashMap=(Map)objStream.readObject();
    if (LOG.isDebugEnabled()) {
      for (Iterator it=_hashMap.entrySet().iterator(); it.hasNext(); ) {
        Map.Entry ent=(Map.Entry)it.next();
        LOG.debug(""String_Node_Str"" + ent.getKey() + ""String_Node_Str""+ ent.getValue());
      }
    }
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException(""String_Node_Str"");
  }
catch (  ClassCastException cce) {
    throw new IOException(""String_Node_Str"");
  }
 finally {
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      IOException ignored) {
      }
    }
  }
}","private void deserializeFromFile() throws IOException {
  FileInputStream istream=null;
  ObjectInputStream objStream=null;
  try {
    istream=new FileInputStream(_backingStoreFile);
    objStream=new ObjectInputStream(istream);
    _hashMap=(Map)objStream.readObject();
    if (LOG.isDebugEnabled()) {
      for (Iterator it=_hashMap.entrySet().iterator(); it.hasNext(); ) {
        Map.Entry ent=(Map.Entry)it.next();
        LOG.debug(""String_Node_Str"" + ent.getKey() + ""String_Node_Str""+ ent.getValue());
      }
    }
  }
 catch (  ClassCastException e) {
    throw new IOException();
  }
catch (  ClassNotFoundException e) {
    throw new IOException();
  }
catch (  ArrayStoreException e) {
    throw new IOException();
  }
catch (  IndexOutOfBoundsException e) {
    throw new IOException();
  }
catch (  NegativeArraySizeException e) {
    throw new IOException();
  }
catch (  IllegalStateException e) {
    throw new IOException();
  }
catch (  SecurityException e) {
    throw new IOException();
  }
 finally {
    if (istream != null) {
      try {
        istream.close();
      }
 catch (      IOException ignored) {
      }
    }
  }
}",0.7117794486215538
4440,"/** 
 * Removes and returns the RemoteFileDesc with the highest quality in filesLeft.  If two or more entries have the same quality, returns the entry with the highest speed.  
 * @param filesLeft the list of file/locations to choose from, which MUSThave length of at least one.  Each entry MUST be an instance of RemoteFileDesc.  The assumption is that all are ""same"", though this isn't strictly needed.
 * @return the best file/endpoint location 
 */
private synchronized RemoteFileDesc removeBest(){
  Iterator iter=files.iterator();
  RemoteFileDesc ret=(RemoteFileDesc)iter.next();
  while (iter.hasNext()) {
    RemoteFileDesc rfd=(RemoteFileDesc)iter.next();
    if (ret.isBusy())     ret=rfd;
 else     if (rfd.getSHA1Urn() != null && ret.getSHA1Urn() == null)     ret=rfd;
 else     if ((rfd.getSHA1Urn() == null) == (ret.getSHA1Urn() == null)) {
      if (rfd.getQuality() > ret.getQuality())       ret=rfd;
 else       if (rfd.getQuality() == ret.getQuality()) {
        if (rfd.getSpeed() > ret.getSpeed())         ret=rfd;
      }
    }
  }
  files.remove(ret);
  return ret;
}","/** 
 * Removes and returns the RemoteFileDesc with the highest quality in filesLeft.  If two or more entries have the same quality, returns the entry with the highest speed.  
 * @param filesLeft the list of file/locations to choose from, which MUSThave length of at least one.  Each entry MUST be an instance of RemoteFileDesc.  The assumption is that all are ""same"", though this isn't strictly needed.
 * @return the best file/endpoint location 
 */
private synchronized RemoteFileDesc removeBest(){
  Iterator iter=files.iterator();
  RemoteFileDesc ret=(RemoteFileDesc)iter.next();
  while (iter.hasNext()) {
    RemoteFileDesc rfd=(RemoteFileDesc)iter.next();
    if (rfd.isBusy())     continue;
    if (ret.isBusy())     ret=rfd;
 else     if (rfd.getSHA1Urn() != null && ret.getSHA1Urn() == null)     ret=rfd;
 else     if ((rfd.getSHA1Urn() == null) == (ret.getSHA1Urn() == null)) {
      if (rfd.getQuality() > ret.getQuality())       ret=rfd;
 else       if (rfd.getQuality() == ret.getQuality()) {
        if (rfd.getSpeed() > ret.getSpeed())         ret=rfd;
      }
    }
  }
  files.remove(ret);
  return ret;
}",0.983754512635379
4441,"private void readHeaders() throws IOException {
  if (_byteReader == null)   throw new ReaderIsNullException();
  String str=_byteReader.readLine();
  if (str == null || str.equals(""String_Node_Str""))   throw new IOException();
  if (!CommonUtils.isJava118())   BandwidthStat.HTTP_HEADER_DOWNSTREAM_BANDWIDTH.addData(str.length());
  int code=parseHTTPCode(str,_rfd);
  int[] refQueueInfo={-1,-1,-1};
  while (true) {
    str=_byteReader.readLine();
    if (str == null || str.equals(""String_Node_Str""))     break;
    if (!CommonUtils.isJava118())     BandwidthStat.HTTP_HEADER_DOWNSTREAM_BANDWIDTH.addData(str.length());
    if (str.toUpperCase().startsWith(""String_Node_Str"")) {
      Interval responseRange=parseContentRange(str);
      int low=responseRange.low;
      int high=responseRange.high + 1;
      if (low < _initialReadingPoint || high > _initialReadingPoint + _amountToRead)       throw new ProblemReadingHeaderException(""String_Node_Str"" + _initialReadingPoint + ""String_Node_Str""+ (_initialReadingPoint + _amountToRead - 1)+ ""String_Node_Str""+ low+ ""String_Node_Str""+ high);
      _initialReadingPoint=low;
      _amountToRead=high - low;
    }
 else     if (HTTPHeaderName.CONTENT_LENGTH.matchesStartOfString(str))     _contentLength=readContentLength(str);
 else     if (HTTPHeaderName.CONTENT_URN.matchesStartOfString(str))     checkContentUrnHeader(str,_rfd.getSHA1Urn());
 else     if (HTTPHeaderName.GNUTELLA_CONTENT_URN.matchesStartOfString(str))     checkContentUrnHeader(str,_rfd.getSHA1Urn());
 else     if (HTTPHeaderName.ALT_LOCATION.matchesStartOfString(str))     readAlternateLocations(str);
 else     if (HTTPHeaderName.QUEUE.matchesStartOfString(str))     parseQueueHeaders(str,refQueueInfo);
 else     if (HTTPHeaderName.SERVER.matchesStartOfString(str))     _server=readServer(str);
 else     if (HTTPHeaderName.AVAILABLE_RANGES.matchesStartOfString(str))     parseAvailableRangesHeader(str,_rfd);
 else     if (HTTPHeaderName.RETRY_AFTER.matchesStartOfString(str))     parseRetryAfterHeader(str,_rfd);
 else     if (HTTPHeaderName.CREATION_TIME.matchesStartOfString(str))     parseCreationTimeHeader(str,_rfd);
 else     if (HTTPHeaderName.FEATURES.matchesStartOfString(str))     parseFeatureHeader(str);
 else     if (HTTPHeaderName.THEX_URI.matchesStartOfString(str))     parseTHEXHeader(str);
  }
  if ((code < 200) || (code >= 300)) {
    if (code == 404)     throw new com.limegroup.gnutella.downloader.FileNotFoundException();
 else     if (code == 410)     throw new NotSharingException();
 else     if (code == 416)     throw new RangeNotAvailableException();
 else     if (code == 503) {
      int min=refQueueInfo[0];
      int max=refQueueInfo[1];
      int pos=refQueueInfo[2];
      if (min != -1 && max != -1 && pos != -1)       throw new QueuedException(min,max,pos);
      if (_rfd.isPartialSource())       throw new RangeNotAvailableException();
      throw new TryAgainLaterException();
    }
 else     throw new UnknownCodeException(code);
  }
}","private void readHeaders() throws IOException {
  if (_byteReader == null)   throw new ReaderIsNullException();
  String str=_byteReader.readLine();
  if (str == null || str.equals(""String_Node_Str""))   throw new IOException();
  if (!CommonUtils.isJava118())   BandwidthStat.HTTP_HEADER_DOWNSTREAM_BANDWIDTH.addData(str.length());
  int code=parseHTTPCode(str,_rfd);
  int[] refQueueInfo={-1,-1,-1};
  while (true) {
    str=_byteReader.readLine();
    if (str == null || str.equals(""String_Node_Str""))     break;
    if (!CommonUtils.isJava118())     BandwidthStat.HTTP_HEADER_DOWNSTREAM_BANDWIDTH.addData(str.length());
    if (str.toUpperCase().startsWith(""String_Node_Str"")) {
      Interval responseRange=parseContentRange(str);
      int low=responseRange.low;
      int high=responseRange.high + 1;
      if (low < _initialReadingPoint || high > _initialReadingPoint + _amountToRead)       throw new ProblemReadingHeaderException(""String_Node_Str"" + _initialReadingPoint + ""String_Node_Str""+ (_initialReadingPoint + _amountToRead - 1)+ ""String_Node_Str""+ low+ ""String_Node_Str""+ high);
      _initialReadingPoint=low;
      _amountToRead=high - low;
    }
 else     if (HTTPHeaderName.CONTENT_LENGTH.matchesStartOfString(str))     _contentLength=readContentLength(str);
 else     if (HTTPHeaderName.CONTENT_URN.matchesStartOfString(str))     checkContentUrnHeader(str,_rfd.getSHA1Urn());
 else     if (HTTPHeaderName.GNUTELLA_CONTENT_URN.matchesStartOfString(str))     checkContentUrnHeader(str,_rfd.getSHA1Urn());
 else     if (HTTPHeaderName.ALT_LOCATION.matchesStartOfString(str))     readAlternateLocations(str);
 else     if (HTTPHeaderName.QUEUE.matchesStartOfString(str))     parseQueueHeaders(str,refQueueInfo);
 else     if (HTTPHeaderName.SERVER.matchesStartOfString(str))     _server=readServer(str);
 else     if (HTTPHeaderName.AVAILABLE_RANGES.matchesStartOfString(str))     parseAvailableRangesHeader(str,_rfd);
 else     if (HTTPHeaderName.RETRY_AFTER.matchesStartOfString(str))     parseRetryAfterHeader(str,_rfd);
 else     if (HTTPHeaderName.CREATION_TIME.matchesStartOfString(str))     parseCreationTimeHeader(str,_rfd);
 else     if (HTTPHeaderName.FEATURES.matchesStartOfString(str))     parseFeatureHeader(str);
 else     if (HTTPHeaderName.THEX_URI.matchesStartOfString(str))     parseTHEXHeader(str);
  }
  if ((code < 200) || (code >= 300)) {
    if (code == 404)     throw new com.limegroup.gnutella.downloader.FileNotFoundException();
 else     if (code == 410)     throw new NotSharingException();
 else     if (code == 416) {
      Iterator iter=_rfd.getAvailableRanges().getAllIntervals();
      while (iter.hasNext()) {
        Interval next=(Interval)iter.next();
        if (_requestedInterval.isSubrange(next))         throw new ProblemReadingHeaderException(""String_Node_Str"");
      }
      throw new RangeNotAvailableException();
    }
 else     if (code == 503) {
      int min=refQueueInfo[0];
      int max=refQueueInfo[1];
      int pos=refQueueInfo[2];
      if (min != -1 && max != -1 && pos != -1)       throw new QueuedException(min,max,pos);
      throw new TryAgainLaterException();
    }
 else     throw new UnknownCodeException(code);
  }
}",0.9348387096774192
4442,"/** 
 * Parses X-Available-Ranges header and stores the available ranges as a list.
 * @param line the X-Available-Ranges header line which should look like:""X-Available-Ranges: bytes A-B, C-D, E-F"" ""X-Available-Ranges:bytes A-B""
 * @param rfd the RemoteFileDesc2 for the location we are trying to downloadfrom. We need this to store the available Ranges. 
 * @exception ProblemReadingHeaderException when we could not parse the header line.
 */
private void parseAvailableRangesHeader(String line,RemoteFileDesc rfd) throws IOException {
  IntervalSet availableRanges=new IntervalSet();
  line=line.toLowerCase();
  int start=line.indexOf(""String_Node_Str"") + 6;
  while (start != -1 && start < line.length()) {
    int stop=line.indexOf('-',start);
    if (stop == -1)     break;
    Interval interval=null;
    try {
      int low=Integer.parseInt(line.substring(start,stop).trim());
      start=stop + 1;
      stop=line.indexOf(',',start);
      if (stop == -1)       stop=line.length();
      int high=Integer.parseInt(line.substring(start,stop).trim());
      if (high >= rfd.getSize())       high=rfd.getSize() - 1;
      if (low > high)       continue;
      interval=new Interval(low,high);
      start=stop + 1;
    }
 catch (    NumberFormatException e) {
      throw new ProblemReadingHeaderException(e);
    }
    availableRanges.add(interval);
  }
  Iterator iter=availableRanges.getAllIntervals();
  while (iter.hasNext()) {
    Interval next=(Interval)iter.next();
    if (_requestedInterval.isSubrange(next))     throw new ProblemReadingHeaderException(""String_Node_Str"");
  }
  rfd.setAvailableRanges(availableRanges);
}","/** 
 * Parses X-Available-Ranges header and stores the available ranges as a list.
 * @param line the X-Available-Ranges header line which should look like:""X-Available-Ranges: bytes A-B, C-D, E-F"" ""X-Available-Ranges:bytes A-B""
 * @param rfd the RemoteFileDesc2 for the location we are trying to downloadfrom. We need this to store the available Ranges. 
 * @exception ProblemReadingHeaderException when we could not parse the header line.
 */
private void parseAvailableRangesHeader(String line,RemoteFileDesc rfd) throws IOException {
  IntervalSet availableRanges=new IntervalSet();
  line=line.toLowerCase();
  int start=line.indexOf(""String_Node_Str"") + 6;
  while (start != -1 && start < line.length()) {
    int stop=line.indexOf('-',start);
    if (stop == -1)     break;
    Interval interval=null;
    try {
      int low=Integer.parseInt(line.substring(start,stop).trim());
      start=stop + 1;
      stop=line.indexOf(',',start);
      if (stop == -1)       stop=line.length();
      int high=Integer.parseInt(line.substring(start,stop).trim());
      if (high >= rfd.getSize())       high=rfd.getSize() - 1;
      if (low > high)       continue;
      interval=new Interval(low,high);
      start=stop + 1;
    }
 catch (    NumberFormatException e) {
      throw new ProblemReadingHeaderException(e);
    }
    availableRanges.add(interval);
  }
  rfd.setAvailableRanges(availableRanges);
}",0.906762967826658
4443,"/** 
 * Notifies all existing HTTPDownloaders about this RFD. If good is true, it notifies them of a succesful alternate location, otherwise it notifies them of a failed alternate location. The internal validAlts is also updated if good is true, and invalidAlts is updated if good is false. The IncompleteFileDesc is also notified of new locations for this file.
 */
private synchronized void informMesh(RemoteFileDesc rfd,boolean good){
  URN bucketHash=null;
  IncompleteFileDesc ifd=null;
  AlternateLocation loc=null;
  AlternateLocation forFD=null;
  if (!rfd.isAltLocCapable())   return;
  bucketHash=buckets.getURNForBucket(bucketNumber);
  Assert.that(bucketHash != null,""String_Node_Str"");
  Assert.that(bucketHash.equals(rfd.getSHA1Urn()),""String_Node_Str"");
  if (validAlts == null)   validAlts=AlternateLocationCollection.create(bucketHash);
  try {
    loc=AlternateLocation.create(rfd);
    forFD=AlternateLocation.create(rfd);
  }
 catch (  IOException iox) {
    return;
  }
  for (Iterator iter=dloaders.iterator(); iter.hasNext(); ) {
    HTTPDownloader httpDloader=(HTTPDownloader)iter.next();
    RemoteFileDesc r=httpDloader.getRemoteFileDesc();
    if (r.getHost() == rfd.getHost() && r.getPort() == rfd.getPort())     continue;
    if (good)     httpDloader.addSuccessfulAltLoc(loc);
 else     httpDloader.addFailedAltLoc(loc);
  }
  FileDesc fd=fileManager.getFileDescForFile(incompleteFile);
  if (fd != null && fd instanceof IncompleteFileDesc) {
    ifd=(IncompleteFileDesc)fd;
    if (!bucketHash.equals(ifd.getSHA1Urn())) {
      Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + incompleteFile + ""String_Node_Str""+ ifd.getFile()+ ""String_Node_Str""+ bucketHash+ ""String_Node_Str""+ DataUtils.listSet(ifd.getUrns())+ ""String_Node_Str""+ incompleteFileManager.dumpHashes());
      fileManager.removeFileIfShared(incompleteFile);
      ifd=null;
    }
  }
  if (good) {
synchronized (altLock) {
      if (!validAlts.contains(loc)) {
        if (RECORD_STATS && rfd.isFromAlternateLocation())         DownloadStat.ALTERNATE_WORKED.incrementStat();
        validAlts.add(loc);
        if (ifd != null)         ifd.addVerified(forFD);
      }
 else {
        if (RECORD_STATS && rfd.isFromAlternateLocation())         DownloadStat.ALTERNATE_NOT_ADDED.incrementStat();
        validAlts.remove(loc);
        if (ifd != null)         ifd.remove(forFD);
        invalidAlts.add(rfd.getRemoteHostData());
        recentInvalidAlts.add(loc);
      }
    }
  }
}","/** 
 * Notifies all existing HTTPDownloaders about this RFD. If good is true, it notifies them of a succesful alternate location, otherwise it notifies them of a failed alternate location. The internal validAlts is also updated if good is true, and invalidAlts is updated if good is false. The IncompleteFileDesc is also notified of new locations for this file.
 */
private synchronized void informMesh(RemoteFileDesc rfd,boolean good){
  URN bucketHash=null;
  IncompleteFileDesc ifd=null;
  AlternateLocation loc=null;
  AlternateLocation forFD=null;
  if (!rfd.isAltLocCapable())   return;
  bucketHash=buckets.getURNForBucket(bucketNumber);
  Assert.that(bucketHash != null,""String_Node_Str"");
  Assert.that(bucketHash.equals(rfd.getSHA1Urn()),""String_Node_Str"");
  if (validAlts == null)   validAlts=AlternateLocationCollection.create(bucketHash);
  try {
    loc=AlternateLocation.create(rfd);
    forFD=AlternateLocation.create(rfd);
  }
 catch (  IOException iox) {
    return;
  }
  for (Iterator iter=dloaders.iterator(); iter.hasNext(); ) {
    HTTPDownloader httpDloader=(HTTPDownloader)iter.next();
    RemoteFileDesc r=httpDloader.getRemoteFileDesc();
    if (r.getHost() == rfd.getHost() && r.getPort() == rfd.getPort())     continue;
    if (good)     httpDloader.addSuccessfulAltLoc(loc);
 else     httpDloader.addFailedAltLoc(loc);
  }
  FileDesc fd=fileManager.getFileDescForFile(incompleteFile);
  if (fd != null && fd instanceof IncompleteFileDesc) {
    ifd=(IncompleteFileDesc)fd;
    if (!bucketHash.equals(ifd.getSHA1Urn())) {
      Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + incompleteFile + ""String_Node_Str""+ ifd.getFile()+ ""String_Node_Str""+ bucketHash+ ""String_Node_Str""+ DataUtils.listSet(ifd.getUrns())+ ""String_Node_Str""+ incompleteFileManager.dumpHashes());
      fileManager.removeFileIfShared(incompleteFile);
      ifd=null;
    }
  }
synchronized (altLock) {
    if (good) {
      if (!validAlts.contains(loc)) {
        if (RECORD_STATS && rfd.isFromAlternateLocation())         DownloadStat.ALTERNATE_WORKED.incrementStat();
        validAlts.add(loc);
        if (ifd != null)         ifd.addVerified(forFD);
      }
    }
 else {
      if (RECORD_STATS && rfd.isFromAlternateLocation())       DownloadStat.ALTERNATE_NOT_ADDED.incrementStat();
      validAlts.remove(loc);
      if (ifd != null)       ifd.remove(forFD);
      invalidAlts.add(rfd.getRemoteHostData());
      recentInvalidAlts.add(loc);
    }
  }
}",0.9814516129032258
4444,"/** 
 * Returns an un-initialized (only established a TCP Connection,  no HTTP headers have been exchanged yet) connectable downloader  from the given list of locations. <p>  method tries to establish connection either by push or by normal ways. <p> If the connection fails for some reason, or needs a push the mesh needs  to be informed that this location failed.
 * @param rfd the RemoteFileDesc to connect to<p>  The following exceptions may be thrown within this method, but they are all dealt with internally. So this method does not throw any exception <p> NoSuchElementException thrown when (both normal and push) connections  to the given rfd fail. We discard the rfd by doing nothing and return  null.
 * @exception InterruptedException this thread was interrupted while waitingto connect. Remember this rfd by putting it back into files and return null 
 */
private HTTPDownloader establishConnection(RemoteFileDesc rfd){
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + rfd + ""String_Node_Str"");
  if (rfd == null)   return null;
  if (stopped) {
synchronized (this) {
      files.add(rfd);
    }
    return null;
  }
  File incFile=incompleteFile;
  HTTPDownloader ret;
  boolean needsPush=needsPush(rfd);
synchronized (this) {
    currentLocation=rfd.getHost();
    if (dloaders.size() == 0 && getState() != COMPLETE && getState() != ABORTED && getState() != GAVE_UP && getState() != COULDNT_MOVE_TO_LIBRARY && getState() != CORRUPT_FILE && getState() != HASHING && getState() != SAVING && queuedThreads.size() == 0)     setState(CONNECTING,needsPush ? PUSH_CONNECT_TIME : NORMAL_CONNECT_TIME);
  }
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + rfd.getHost() + ""String_Node_Str""+ rfd.getPort());
  if (RECORD_STATS)   DownloadStat.CONNECTION_ATTEMPTS.incrementStat();
  if (rfd.isReplyToMulticast()) {
    try {
      ret=connectWithPush(rfd,incFile);
    }
 catch (    IOException e) {
      try {
        ret=connectDirectly(rfd,incFile);
      }
 catch (      IOException e2) {
        return null;
      }
    }
    return ret;
  }
  if (!needsPush) {
    try {
      ret=connectDirectly(rfd,incFile);
      return ret;
    }
 catch (    IOException e) {
    }
  }
  informMesh(rfd,false);
  try {
    ret=connectWithPush(rfd,incFile);
    return ret;
  }
 catch (  IOException e) {
  }
  return null;
}","/** 
 * Returns an un-initialized (only established a TCP Connection,  no HTTP headers have been exchanged yet) connectable downloader  from the given list of locations. <p>  method tries to establish connection either by push or by normal ways. <p> If the connection fails for some reason, or needs a push the mesh needs  to be informed that this location failed.
 * @param rfd the RemoteFileDesc to connect to<p>  The following exceptions may be thrown within this method, but they are all dealt with internally. So this method does not throw any exception <p> NoSuchElementException thrown when (both normal and push) connections  to the given rfd fail. We discard the rfd by doing nothing and return  null.
 * @exception InterruptedException this thread was interrupted while waitingto connect. Remember this rfd by putting it back into files and return null 
 */
private HTTPDownloader establishConnection(RemoteFileDesc rfd){
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + rfd + ""String_Node_Str"");
  if (rfd == null)   return null;
  if (stopped) {
synchronized (this) {
      files.add(rfd);
    }
    return null;
  }
  File incFile=incompleteFile;
  HTTPDownloader ret;
  boolean needsPush=needsPush(rfd);
synchronized (this) {
    currentLocation=rfd.getHost();
    if (dloaders.size() == 0 && getState() != COMPLETE && getState() != ABORTED && getState() != GAVE_UP && getState() != COULDNT_MOVE_TO_LIBRARY && getState() != CORRUPT_FILE && getState() != HASHING && getState() != SAVING && queuedThreads.size() == 0)     setState(CONNECTING,needsPush ? PUSH_CONNECT_TIME : NORMAL_CONNECT_TIME);
  }
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + rfd.getHost() + ""String_Node_Str""+ rfd.getPort());
  if (RECORD_STATS)   DownloadStat.CONNECTION_ATTEMPTS.incrementStat();
  if (rfd.isReplyToMulticast()) {
    try {
      ret=connectWithPush(rfd,incFile);
    }
 catch (    IOException e) {
      try {
        ret=connectDirectly(rfd,incFile);
      }
 catch (      IOException e2) {
        return null;
      }
    }
    return ret;
  }
  if (!needsPush) {
    try {
      ret=connectDirectly(rfd,incFile);
      return ret;
    }
 catch (    IOException e) {
    }
  }
  informMesh(rfd,false);
  if (!rfd.isFromAlternateLocation()) {
    try {
      ret=connectWithPush(rfd,incFile);
      return ret;
    }
 catch (    IOException e) {
    }
  }
  return null;
}",0.9882005899705014
4445,"/** 
 * @return a <tt>Set</tt> of <tt>PushProxyContainer</tt> instances,which can be empty but is guaranteed not to be <tt>null</tt>, as  described by the GGEP blocks.
 * @param ggeps the array of GGEP extensions that may or may notcontain push proxy data
 */
public Set getPushProxies(GGEP[] ggeps){
  Set proxies=new HashSet();
  for (int i=0; (ggeps != null) && (i < ggeps.length); i++) {
    Set headers=ggeps[i].getHeaders();
    if (headers.contains(GGEP.GGEP_HEADER_PUSH_PROXY)) {
      byte[] proxyBytes=null;
      try {
        proxyBytes=ggeps[i].getBytes(GGEP.GGEP_HEADER_PUSH_PROXY);
      }
 catch (      BadGGEPPropertyException bad) {
        ErrorService.error(bad);
        continue;
      }
      ByteArrayInputStream bais=new ByteArrayInputStream(proxyBytes);
      while (bais.available() > 0) {
        byte[] combo=new byte[6];
        if (bais.read(combo,0,combo.length) == combo.length) {
          try {
            proxies.add(new PushProxyContainer(combo));
          }
 catch (          BadPacketException malformedPair) {
          }
        }
      }
    }
  }
  return proxies;
}","/** 
 * @return a <tt>Set</tt> of <tt>PushProxyContainer</tt> instances,which can be empty but is guaranteed not to be <tt>null</tt>, as  described by the GGEP blocks.
 * @param ggeps the array of GGEP extensions that may or may notcontain push proxy data
 */
public Set getPushProxies(GGEP[] ggeps){
  Set proxies=new HashSet();
  for (int i=0; (ggeps != null) && (i < ggeps.length); i++) {
    Set headers=ggeps[i].getHeaders();
    if (headers.contains(GGEP.GGEP_HEADER_PUSH_PROXY)) {
      byte[] proxyBytes=null;
      try {
        proxyBytes=ggeps[i].getBytes(GGEP.GGEP_HEADER_PUSH_PROXY);
      }
 catch (      BadGGEPPropertyException bad) {
        continue;
      }
      ByteArrayInputStream bais=new ByteArrayInputStream(proxyBytes);
      while (bais.available() > 0) {
        byte[] combo=new byte[6];
        if (bais.read(combo,0,combo.length) == combo.length) {
          try {
            proxies.add(new PushProxyContainer(combo));
          }
 catch (          BadPacketException malformedPair) {
          }
        }
      }
    }
  }
  return proxies;
}",0.984924623115578
4446,"public void testDownloadFinishes() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=TestFile.hash();
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
{
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(1,endpoints.size());
  }
  long currTime=System.currentTimeMillis();
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  Thread.sleep(500);
  assertEquals(Downloader.ITERATIVE_GUESSING,downloader.getState());
{
    boolean gotPing=false;
    while (!gotPing) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[0].setSoTimeout(10000);
        UDP_ACCESS[0].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        m.hop();
        if (m instanceof PingRequest)         gotPing=((PingRequest)m).isQueryKeyRequest();
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(false);
      }
    }
  }
  QueryKey qk=QueryKey.getQueryKey(InetAddress.getLocalHost(),SERVER_PORT);
{
    byte[] ip=new byte[]{(byte)127,(byte)0,(byte)0,(byte)1};
    PingReply pr=PingReply.createQueryKeyReply(GUID.makeGuid(),(byte)1,UDP_ACCESS[0].getLocalPort(),ip,10,10,false,qk);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pr.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(500);
{
    Map _queryKeys=(Map)PrivilegedAccessor.getValue(OnDemandUnicaster.class,""String_Node_Str"");
    assertNotNull(_queryKeys);
    assertEquals(1,_queryKeys.size());
  }
{
    boolean gotQuery=false;
    while (!gotQuery) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[0].setSoTimeout(10000);
        UDP_ACCESS[0].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        if (m instanceof QueryRequest) {
          QueryRequest qReq=(QueryRequest)m;
          Set queryURNs=qReq.getQueryUrns();
          gotQuery=queryURNs.contains(urn);
          if (gotQuery)           gotQuery=qk.equals(qReq.getQueryKey());
        }
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(false);
      }
    }
  }
  long timeoutVal=1000 - (System.currentTimeMillis() - currTime);
  Thread.sleep(timeoutVal > 0 ? timeoutVal : 0);
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  ((MyCallback)getCallback()).clearGUID();
  TestUploader uploader2=new TestUploader(""String_Node_Str"",UPLOADER_PORT + 1);
  uploader2.setRate(100);
{
    rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT + 1,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
    Response[] res=new Response[]{new Response(10,10,""String_Node_Str"")};
    m=new QueryReply(qr.getGUID(),(byte)1,UPLOADER_PORT + 1,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    m.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(10000);
  assertEquals(Downloader.COMPLETE,downloader.getState());
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}","public void testDownloadFinishes() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=TestFile.hash();
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
{
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(1,endpoints.size());
  }
  long currTime=System.currentTimeMillis();
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  final int MAX_TRIES=60;
  for (int i=0; i <= MAX_TRIES; i++) {
    Thread.sleep(500);
    if (downloader.getState() == Downloader.ITERATIVE_GUESSING)     break;
    if (i == MAX_TRIES)     fail(""String_Node_Str"");
  }
{
    boolean gotPing=false;
    while (!gotPing) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[0].setSoTimeout(10000);
        UDP_ACCESS[0].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        m.hop();
        if (m instanceof PingRequest)         gotPing=((PingRequest)m).isQueryKeyRequest();
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(false);
      }
    }
  }
  QueryKey qk=QueryKey.getQueryKey(InetAddress.getLocalHost(),SERVER_PORT);
{
    byte[] ip=new byte[]{(byte)127,(byte)0,(byte)0,(byte)1};
    PingReply pr=PingReply.createQueryKeyReply(GUID.makeGuid(),(byte)1,UDP_ACCESS[0].getLocalPort(),ip,10,10,false,qk);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pr.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(500);
{
    Map _queryKeys=(Map)PrivilegedAccessor.getValue(OnDemandUnicaster.class,""String_Node_Str"");
    assertNotNull(_queryKeys);
    assertEquals(1,_queryKeys.size());
  }
{
    boolean gotQuery=false;
    while (!gotQuery) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[0].setSoTimeout(10000);
        UDP_ACCESS[0].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        if (m instanceof QueryRequest) {
          QueryRequest qReq=(QueryRequest)m;
          Set queryURNs=qReq.getQueryUrns();
          gotQuery=queryURNs.contains(urn);
          if (gotQuery)           gotQuery=qk.equals(qReq.getQueryKey());
        }
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(false);
      }
    }
  }
  long timeoutVal=1000 - (System.currentTimeMillis() - currTime);
  Thread.sleep(timeoutVal > 0 ? timeoutVal : 0);
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  ((MyCallback)getCallback()).clearGUID();
  TestUploader uploader2=new TestUploader(""String_Node_Str"",UPLOADER_PORT + 1);
  uploader2.setRate(100);
{
    rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT + 1,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
    Response[] res=new Response[]{new Response(10,10,""String_Node_Str"")};
    m=new QueryReply(qr.getGUID(),(byte)1,UPLOADER_PORT + 1,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    m.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(10000);
  assertEquals(Downloader.COMPLETE,downloader.getState());
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}",0.9812568908489526
4447,"public void testBusyDownloadLocatesSources() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=URN.createSHA1Urn(""String_Node_Str"");
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
  for (int i=0; i < UDP_ACCESS.length; i++) {
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),i + 1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[i].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(UDP_ACCESS.length,endpoints.size());
  }
  long currTime=System.currentTimeMillis();
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  Thread.sleep(10000);
  assertEquals(Downloader.ITERATIVE_GUESSING,downloader.getState());
  for (int i=0; i < UDP_ACCESS.length; i++) {
    boolean gotPing=false;
    while (!gotPing) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[i].setSoTimeout(10000);
        UDP_ACCESS[i].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        m.hop();
        if (m instanceof PingRequest)         gotPing=((PingRequest)m).isQueryKeyRequest();
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(""String_Node_Str"" + i,false);
      }
    }
  }
  Thread.sleep(1000);
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  ((MyCallback)getCallback()).clearGUID();
  downloader.stop();
  Thread.sleep(1000);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}","public void testBusyDownloadLocatesSources() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=URN.createSHA1Urn(""String_Node_Str"");
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
  for (int i=0; i < UDP_ACCESS.length; i++) {
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),i + 1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[i].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(UDP_ACCESS.length,endpoints.size());
  }
  long currTime=System.currentTimeMillis();
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  final int MAX_TRIES=60;
  for (int i=0; i <= MAX_TRIES; i++) {
    Thread.sleep(1000);
    if (downloader.getState() == Downloader.ITERATIVE_GUESSING)     break;
    if (i == MAX_TRIES)     fail(""String_Node_Str"");
  }
  for (int i=0; i < UDP_ACCESS.length; i++) {
    boolean gotPing=false;
    while (!gotPing) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[i].setSoTimeout(10000);
        UDP_ACCESS[i].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        m.hop();
        if (m instanceof PingRequest)         gotPing=((PingRequest)m).isQueryKeyRequest();
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(""String_Node_Str"" + i,false);
      }
    }
  }
  Thread.sleep(1000);
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  ((MyCallback)getCallback()).clearGUID();
  downloader.stop();
  Thread.sleep(1000);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}",0.9681150823075784
4448,"public void testMultipleDownloadsNoPurge() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=URN.createSHA1Urn(""String_Node_Str"");
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  TestUploader uploader2=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader2.setBusy(true);
  urn=URN.createSHA1Urn(""String_Node_Str"");
  urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd2=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
{
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(1,endpoints.size());
  }
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  Downloader downloader2=RouterService.download(new RemoteFileDesc[]{rfd2},false,new GUID(guid));
  Thread.sleep(2000);
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader2.getState());
  ((MyCallback)getCallback()).clearGUID();
  downloader.stop();
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(1,endpoints.size());
  }
  downloader2.stop();
  Thread.sleep(1000);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}","public void testMultipleDownloadsNoPurge() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=URN.createSHA1Urn(""String_Node_Str"");
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  TestUploader uploader2=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader2.setBusy(true);
  urn=URN.createSHA1Urn(""String_Node_Str"");
  urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd2=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
{
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(1,endpoints.size());
  }
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  Downloader downloader2=RouterService.download(new RemoteFileDesc[]{rfd2},false,new GUID(guid));
  final int MAX_TRIES=60;
  boolean oneGood=false, twoGood=false;
  for (int i=0; i <= MAX_TRIES; i++) {
    Thread.sleep(500);
    if (downloader.getState() == Downloader.WAITING_FOR_RETRY)     oneGood=true;
    if (downloader2.getState() == Downloader.WAITING_FOR_RETRY)     twoGood=true;
    if (oneGood && twoGood)     break;
    if (i == MAX_TRIES)     fail(""String_Node_Str"");
  }
  ((MyCallback)getCallback()).clearGUID();
  downloader.stop();
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(1,endpoints.size());
  }
  downloader2.stop();
  Thread.sleep(1000);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}",0.9436100878435818
4449,"public void testUsesCachedQueryKeys() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=URN.createSHA1Urn(""String_Node_Str"");
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
  for (int i=0; i < UDP_ACCESS.length; i++) {
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),i + 1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[i].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(UDP_ACCESS.length,endpoints.size());
  }
  QueryKey qk=QueryKey.getQueryKey(InetAddress.getLocalHost(),SERVER_PORT);
  for (int i=0; i < UDP_ACCESS.length; i++) {
    byte[] ip=new byte[]{(byte)127,(byte)0,(byte)0,(byte)1};
    PingReply pr=PingReply.createQueryKeyReply(GUID.makeGuid(),(byte)1,UDP_ACCESS[i].getLocalPort(),ip,10,10,false,qk);
    pr.hop();
    OnDemandUnicaster.handleQueryKeyPong(pr);
  }
  long currTime=System.currentTimeMillis();
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  final int MAX_TRIES=60;
  for (int i=0; i <= MAX_TRIES; i++) {
    Thread.sleep(500);
    if (downloader.getState() == Downloader.ITERATIVE_GUESSING)     break;
    if (i == MAX_TRIES)     fail(""String_Node_Str"");
  }
  for (int i=0; i < UDP_ACCESS.length; i++) {
    boolean gotQuery=false;
    while (!gotQuery) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[i].setSoTimeout(10000);
        UDP_ACCESS[i].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        if (m instanceof QueryRequest) {
          QueryRequest qReq=(QueryRequest)m;
          Set queryURNs=qReq.getQueryUrns();
          gotQuery=queryURNs.contains(urn);
          if (gotQuery)           gotQuery=qk.equals(qReq.getQueryKey());
        }
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(""String_Node_Str"" + i,false);
      }
    }
  }
  Thread.sleep((UDP_ACCESS.length * 1000) - (System.currentTimeMillis() - currTime));
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  ((MyCallback)getCallback()).clearGUID();
  downloader.stop();
  Thread.sleep(1000);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}","public void testUsesCachedQueryKeys() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=URN.createSHA1Urn(""String_Node_Str"");
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
  for (int i=0; i < UDP_ACCESS.length; i++) {
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),i + 1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[i].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(UDP_ACCESS.length,endpoints.size());
  }
  QueryKey qk=QueryKey.getQueryKey(InetAddress.getLocalHost(),SERVER_PORT);
  for (int i=0; i < UDP_ACCESS.length; i++) {
    byte[] ip=new byte[]{(byte)127,(byte)0,(byte)0,(byte)1};
    PingReply pr=PingReply.createQueryKeyReply(GUID.makeGuid(),(byte)1,UDP_ACCESS[i].getLocalPort(),ip,10,10,false,qk);
    pr.hop();
    OnDemandUnicaster.handleQueryKeyPong(pr);
  }
  long currTime=System.currentTimeMillis();
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  final int MAX_TRIES=60;
  for (int i=0; i <= MAX_TRIES; i++) {
    Thread.sleep(500);
    if (downloader.getState() == Downloader.ITERATIVE_GUESSING)     break;
    if (i == MAX_TRIES)     fail(""String_Node_Str"");
  }
  for (int i=0; i < UDP_ACCESS.length; i++) {
    boolean gotQuery=false;
    while (!gotQuery) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[i].setSoTimeout(10000);
        UDP_ACCESS[i].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        if (m instanceof QueryRequest) {
          QueryRequest qReq=(QueryRequest)m;
          Set queryURNs=qReq.getQueryUrns();
          gotQuery=queryURNs.contains(urn);
          if (gotQuery)           gotQuery=qk.equals(qReq.getQueryKey());
        }
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(""String_Node_Str"" + i,false);
      }
    }
  }
  Thread.sleep((UDP_ACCESS.length * 1500) - (System.currentTimeMillis() - currTime));
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  ((MyCallback)getCallback()).clearGUID();
  downloader.stop();
  Thread.sleep(1000);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}",0.99975068561456
4450,"/** 
 * Returns true if this has slots for an incoming connection, <b>without accounting for this' ultrapeer capabilities</b>.  More specifically: <ul> <li>if ultrapeerHeader==null, returns true if this has space for an  unrouted old-style connection. <li>if ultrapeerHeader.equals(""true""), returns true if this has slots for a leaf connection. <li>if ultrapeerHeader.equals(""false""), returns true if this has slots  for an ultrapeer connection. </ul> <tt>useragentHeader</tt> is used to prefer LimeWire and certain trusted vendors.  <tt>outgoing</tt> is currently unused, but may be used to  prefer incoming or outgoing connections in the forward.
 * @param outgoing true if this is an outgoing connection; true if incoming
 * @param ultrapeerHeader the value of the X-Ultrapeer header, or nullif it was not written
 * @param useragentHeader the value of the User-Agent header, or null ifit was not written
 * @return true if a connection of the given type is allowed
 */
public boolean allowConnection(HandshakeResponse hr,boolean leaf){
  if (!ConnectionSettings.PREFERENCING_ACTIVE.getValue())   return true;
  if (!ConnectionSettings.IGNORE_KEEP_ALIVE.getValue() && _keepAlive <= 0) {
    return false;
  }
 else   if (RouterService.isShieldedLeaf()) {
    if (hr.isGoodUltrapeer() && _shieldedConnections < PREFERRED_CONNECTIONS_FOR_LEAF) {
      return true;
    }
 else {
      return false;
    }
  }
 else   if (hr.isLeaf() || leaf) {
    if (!allowUltrapeer2LeafConnection(hr)) {
      return false;
    }
    int leaves=getNumInitializedClientConnections();
    int nonLimeWireLeaves=_nonLimeWireLeaves;
    if (!hr.isLimeWire()) {
      if (leaves < UltrapeerSettings.MAX_LEAVES.getValue() && nonLimeWireLeaves < RESERVED_NON_LIMEWIRE_LEAVES) {
        return true;
      }
 else {
        return false;
      }
    }
    if (hr.isGoodLeaf()) {
      return (leaves + RESERVED_NON_LIMEWIRE_LEAVES - nonLimeWireLeaves) < UltrapeerSettings.MAX_LEAVES.getValue();
    }
    return leaves < (UltrapeerSettings.MAX_LEAVES.getValue() - RESERVED_GOOD_LEAF_CONNECTIONS);
  }
 else   if (hr.isUltrapeer()) {
    int peers=getNumInitializedConnections();
    int nonLimeWirePeers=_nonLimeWirePeers;
    int locale_num=0;
    if (!allowUltrapeer2UltrapeerConnection(hr)) {
      return false;
    }
    if (ConnectionSettings.USE_LOCALE_PREF.getValue()) {
      if (checkLocale(hr.getLocalePref()) && _localeMatchingPeers < ConnectionSettings.NUM_LOCALE_PREF.getValue()) {
        return true;
      }
      locale_num=getNumLimeWireLocalePrefSlots();
    }
    if (!hr.isLimeWire()) {
      if (peers < ULTRAPEER_CONNECTIONS && nonLimeWirePeers < RESERVED_NON_LIMEWIRE_PEERS) {
        return true;
      }
    }
    return (peers + RESERVED_NON_LIMEWIRE_PEERS - nonLimeWirePeers + locale_num) < ULTRAPEER_CONNECTIONS;
  }
  return false;
}","/** 
 * Returns true if this has slots for an incoming connection, <b>without accounting for this' ultrapeer capabilities</b>.  More specifically: <ul> <li>if ultrapeerHeader==null, returns true if this has space for an  unrouted old-style connection. <li>if ultrapeerHeader.equals(""true""), returns true if this has slots for a leaf connection. <li>if ultrapeerHeader.equals(""false""), returns true if this has slots  for an ultrapeer connection. </ul> <tt>useragentHeader</tt> is used to prefer LimeWire and certain trusted vendors.  <tt>outgoing</tt> is currently unused, but may be used to  prefer incoming or outgoing connections in the forward.
 * @param outgoing true if this is an outgoing connection; true if incoming
 * @param ultrapeerHeader the value of the X-Ultrapeer header, or nullif it was not written
 * @param useragentHeader the value of the User-Agent header, or null ifit was not written
 * @return true if a connection of the given type is allowed
 */
public boolean allowConnection(HandshakeResponse hr,boolean leaf){
  if (!ConnectionSettings.PREFERENCING_ACTIVE.getValue())   return true;
  if (!ConnectionSettings.IGNORE_KEEP_ALIVE.getValue() && _keepAlive <= 0) {
    return false;
  }
 else   if (RouterService.isShieldedLeaf()) {
    if (hr.isGoodUltrapeer() && _shieldedConnections < PREFERRED_CONNECTIONS_FOR_LEAF) {
      return true;
    }
 else {
      return false;
    }
  }
 else   if (hr.isLeaf() || leaf) {
    if (!allowUltrapeer2LeafConnection(hr)) {
      return false;
    }
    int leaves=getNumInitializedClientConnections();
    int nonLimeWireLeaves=_nonLimeWireLeaves;
    if (!hr.isLimeWire()) {
      if (leaves < UltrapeerSettings.MAX_LEAVES.getValue() && nonLimeWireLeaves < RESERVED_NON_LIMEWIRE_LEAVES) {
        return true;
      }
 else {
        return false;
      }
    }
    if (hr.isGoodLeaf()) {
      return (leaves + Math.max(0,RESERVED_NON_LIMEWIRE_LEAVES - nonLimeWireLeaves)) < UltrapeerSettings.MAX_LEAVES.getValue();
    }
    return leaves < (UltrapeerSettings.MAX_LEAVES.getValue() - RESERVED_GOOD_LEAF_CONNECTIONS);
  }
 else   if (hr.isUltrapeer()) {
    int peers=getNumInitializedConnections();
    int nonLimeWirePeers=_nonLimeWirePeers;
    int locale_num=0;
    if (!allowUltrapeer2UltrapeerConnection(hr)) {
      return false;
    }
    if (ConnectionSettings.USE_LOCALE_PREF.getValue()) {
      if (checkLocale(hr.getLocalePref()) && _localeMatchingPeers < ConnectionSettings.NUM_LOCALE_PREF.getValue()) {
        return true;
      }
      locale_num=getNumLimeWireLocalePrefSlots();
    }
    if (!hr.isLimeWire()) {
      if (peers < ULTRAPEER_CONNECTIONS && nonLimeWirePeers < RESERVED_NON_LIMEWIRE_PEERS) {
        return true;
      }
    }
    return (peers + Math.max(0,RESERVED_NON_LIMEWIRE_PEERS - nonLimeWirePeers) + locale_num) < ULTRAPEER_CONNECTIONS;
  }
  return false;
}",0.9957968476357268
4451,"/** 
 * Generates ID3Data from id3v2 data in the file.
 */
private static ID3Data parseID3v2Data(File file){
  ID3Data data=new ID3Data();
  ID3v2 id3v2Parser=null;
  try {
    id3v2Parser=new ID3v2(file);
  }
 catch (  ID3v2Exception idvx) {
    if (idvx instanceof ID3v2BadParsingException)     ErrorService.error(idvx);
    return data;
  }
catch (  IOException iox) {
    return data;
  }
  Vector frames=null;
  try {
    frames=id3v2Parser.getFrames();
  }
 catch (  NoID3v2TagException ntx) {
    return data;
  }
  for (Iterator iter=frames.iterator(); iter.hasNext(); ) {
    ID3v2Frame frame=(ID3v2Frame)iter.next();
    String frameID=frame.getID();
    byte[] contentBytes=frame.getContent();
    String frameContent=null;
    if (contentBytes.length > 0) {
      try {
        String enc=(frame.isISOLatin1()) ? ISO_LATIN_1 : UNICODE;
        frameContent=new String(contentBytes,enc).trim();
      }
 catch (      UnsupportedEncodingException err) {
      }
    }
    if (frameContent == null || frameContent.trim().equals(""String_Node_Str""))     continue;
    if (ID3Editor.TITLE_ID.equals(frameID))     data.setTitle(frameContent);
 else     if (ID3Editor.ARTIST_ID.equals(frameID))     data.setArtist(frameContent);
 else     if (ID3Editor.ALBUM_ID.equals(frameID))     data.setAlbum(frameContent);
 else     if (ID3Editor.YEAR_ID.equals(frameID))     data.setYear(frameContent);
 else     if (ID3Editor.COMMENT_ID.equals(frameID)) {
      byte[] bytes=frame.getContent();
      int startIndex=0;
      for (int i=bytes.length - 1; i >= 0; i--) {
        if (bytes[i] != (byte)0)         continue;
        startIndex=i;
        break;
      }
      frameContent=new String(bytes,startIndex,bytes.length - startIndex).trim();
      data.setComment(frameContent);
    }
 else     if (ID3Editor.TRACK_ID.equals(frameID)) {
      try {
        data.setTrack(Short.parseShort(frameContent));
      }
 catch (      NumberFormatException ignored) {
      }
    }
 else     if (ID3Editor.GENRE_ID.equals(frameID)) {
      int startIndex=frameContent.indexOf(""String_Node_Str"");
      int endIndex=frameContent.indexOf(""String_Node_Str"");
      int genreCode=-1;
      if (startIndex > -1 && endIndex > -1) {
        String genreByte=frameContent.substring(startIndex + 1,endIndex);
        try {
          genreCode=Integer.parseInt(genreByte);
        }
 catch (        NumberFormatException nfx) {
          genreCode=-1;
        }
      }
      if (genreCode >= 0 && genreCode <= 127)       data.setGenre(getGenreString((short)genreCode));
 else       data.setGenre(frameContent);
    }
  }
  return data;
}","/** 
 * Generates ID3Data from id3v2 data in the file.
 */
private static ID3Data parseID3v2Data(File file){
  ID3Data data=new ID3Data();
  if (frameIDs == null) {
    makeFrameIDs();
    ID3v2.setFramesToCheck(frameIDs);
  }
  ID3v2 id3v2Parser=null;
  try {
    id3v2Parser=new ID3v2(file);
  }
 catch (  ID3v2Exception idvx) {
    if (idvx instanceof ID3v2BadParsingException)     ErrorService.error(idvx);
    return data;
  }
catch (  IOException iox) {
    return data;
  }
  Vector frames=null;
  try {
    frames=id3v2Parser.getFrames();
  }
 catch (  NoID3v2TagException ntx) {
    return data;
  }
  for (Iterator iter=frames.iterator(); iter.hasNext(); ) {
    ID3v2Frame frame=(ID3v2Frame)iter.next();
    String frameID=frame.getID();
    byte[] contentBytes=frame.getContent();
    String frameContent=null;
    if (contentBytes.length > 0) {
      try {
        String enc=(frame.isISOLatin1()) ? ISO_LATIN_1 : UNICODE;
        frameContent=new String(contentBytes,enc).trim();
      }
 catch (      UnsupportedEncodingException err) {
      }
    }
    if (frameContent == null || frameContent.trim().equals(""String_Node_Str""))     continue;
    if (ID3Editor.TITLE_ID.equals(frameID))     data.setTitle(frameContent);
 else     if (ID3Editor.ARTIST_ID.equals(frameID))     data.setArtist(frameContent);
 else     if (ID3Editor.ALBUM_ID.equals(frameID))     data.setAlbum(frameContent);
 else     if (ID3Editor.YEAR_ID.equals(frameID))     data.setYear(frameContent);
 else     if (ID3Editor.COMMENT_ID.equals(frameID)) {
      byte[] bytes=frame.getContent();
      int startIndex=0;
      for (int i=bytes.length - 1; i >= 0; i--) {
        if (bytes[i] != (byte)0)         continue;
        startIndex=i;
        break;
      }
      frameContent=new String(bytes,startIndex,bytes.length - startIndex).trim();
      data.setComment(frameContent);
    }
 else     if (ID3Editor.TRACK_ID.equals(frameID)) {
      try {
        data.setTrack(Short.parseShort(frameContent));
      }
 catch (      NumberFormatException ignored) {
      }
    }
 else     if (ID3Editor.GENRE_ID.equals(frameID)) {
      int startIndex=frameContent.indexOf(""String_Node_Str"");
      int endIndex=frameContent.indexOf(""String_Node_Str"");
      int genreCode=-1;
      if (startIndex > -1 && endIndex > -1) {
        String genreByte=frameContent.substring(startIndex + 1,endIndex);
        try {
          genreCode=Integer.parseInt(genreByte);
        }
 catch (        NumberFormatException nfx) {
          genreCode=-1;
        }
      }
      if (genreCode >= 0 && genreCode <= 127)       data.setGenre(getGenreString((short)genreCode));
 else       data.setGenre(frameContent);
    }
  }
  return data;
}",0.9834772812617348
4452,"/** 
 * Notification that a file has changed. This implementation is different than FileManager's in that it maintains the XML. Important note: This method is called AFTER the file has changed.  It is possible that the metadata we wanted to write did not get written out completely.  We should NOT attempt to add the old metadata again, because we may end up recursing infinitely trying to write this metadata. However, it isn't very robust to blindly assume that the only metadata associated with this file was audio metadata. So, we make use of the fact that addFileIfShared will only add one type of metadata per file.  We read the ID3 tags off the file and insert it first into the list, ensuring that the existing metadata is the one that's added, short-circuiting any infinite loops.
 */
public FileDesc fileChanged(File f){
  FileDesc fd=getFileDescForFile(f);
  if (fd == null)   return null;
  CreationTimeCache ctCache=CreationTimeCache.instance();
  Long cTime=ctCache.getCreationTime(fd.getSHA1Urn());
  List xmlDocs=new LinkedList();
  if (LimeXMLUtils.isMP3File(f)) {
    try {
      xmlDocs.add(ID3Reader.readDocument(f));
    }
 catch (    IOException e) {
      return super.fileChanged(f);
    }
  }
  xmlDocs.addAll(fd.getLimeXMLDocuments());
  FileDesc removed=removeFileIfShared(f);
  Assert.that(fd == removed,""String_Node_Str"");
  _needRebuild=true;
  fd=addFileIfShared(f,xmlDocs);
  if ((fd != null) && (cTime != null)) {
synchronized (ctCache) {
      ctCache.removeTime(fd.getSHA1Urn());
      ctCache.addTime(fd.getSHA1Urn(),cTime.longValue());
      ctCache.commitTime(fd.getSHA1Urn());
    }
  }
  return fd;
}","/** 
 * Notification that a file has changed. This implementation is different than FileManager's in that it maintains the XML. Important note: This method is called AFTER the file has changed.  It is possible that the metadata we wanted to write did not get written out completely.  We should NOT attempt to add the old metadata again, because we may end up recursing infinitely trying to write this metadata. However, it isn't very robust to blindly assume that the only metadata associated with this file was audio metadata. So, we make use of the fact that addFileIfShared will only add one type of metadata per file.  We read the ID3 tags off the file and insert it first into the list, ensuring that the existing metadata is the one that's added, short-circuiting any infinite loops.
 */
public FileDesc fileChanged(File f){
  FileDesc fd=getFileDescForFile(f);
  if (fd == null)   return null;
  CreationTimeCache ctCache=CreationTimeCache.instance();
  Long cTime=ctCache.getCreationTime(fd.getSHA1Urn());
  List xmlDocs=new LinkedList();
  xmlDocs.addAll(fd.getLimeXMLDocuments());
  FileDesc removed=removeFileIfShared(f);
  Assert.that(fd == removed,""String_Node_Str"");
  _needRebuild=true;
  fd=addFileIfShared(f,xmlDocs);
  if ((fd != null) && (cTime != null)) {
synchronized (ctCache) {
      ctCache.removeTime(fd.getSHA1Urn());
      ctCache.addTime(fd.getSHA1Urn(),cTime.longValue());
      ctCache.commitTime(fd.getSHA1Urn());
    }
  }
  return fd;
}",0.9449983917658412
4453,"/** 
 * Notification that a file has changed. This implementation is different than FileManager's in that it maintains the XML. Important note: This method is called AFTER the file has changed.  It is possible that the metadata we wanted to write did not get written out completely.  We should NOT attempt to add the old metadata again, because we may end up recursing infinitely trying to write this metadata. However, it isn't very robust to blindly assume that the only metadata associated with this file was audio metadata. So, we make use of the fact that addFileIfShared will only add one type of metadata per file.  We read the ID3 tags off the file and insert it first into the list, ensuring that the existing metadata is the one that's added, short-circuiting any infinite loops.
 */
public FileDesc fileChanged(File f){
  FileDesc fd=getFileDescForFile(f);
  if (fd == null)   return null;
  CreationTimeCache ctCache=CreationTimeCache.instance();
  Long cTime=ctCache.getCreationTime(fd.getSHA1Urn());
  List xmlDocs=new LinkedList();
  xmlDocs.addAll(fd.getLimeXMLDocuments());
  FileDesc removed=removeFileIfShared(f);
  Assert.that(fd == removed,""String_Node_Str"");
  _needRebuild=true;
  fd=addFileIfShared(f,xmlDocs);
  if ((fd != null) && (cTime != null)) {
synchronized (ctCache) {
      ctCache.removeTime(fd.getSHA1Urn());
      ctCache.addTime(fd.getSHA1Urn(),cTime.longValue());
      ctCache.commitTime(fd.getSHA1Urn());
    }
  }
  return fd;
}","/** 
 * Notification that a file has changed. This implementation is different than FileManager's in that it maintains the XML. Important note: This method is called AFTER the file has changed.  It is possible that the metadata we wanted to write did not get written out completely.  We should NOT attempt to add the old metadata again, because we may end up recursing infinitely trying to write this metadata. However, it isn't very robust to blindly assume that the only metadata associated with this file was audio metadata. So, we make use of the fact that addFileIfShared will only add one type of metadata per file.  We read the ID3 tags off the file and insert it first into the list, ensuring that the existing metadata is the one that's added, short-circuiting any infinite loops.
 */
public FileDesc fileChanged(File f){
  FileDesc fd=getFileDescForFile(f);
  if (fd == null)   return null;
  CreationTimeCache ctCache=CreationTimeCache.instance();
  Long cTime=ctCache.getCreationTime(fd.getSHA1Urn());
  List xmlDocs=fd.getLimeXMLDocuments();
  if (LimeXMLUtils.isMP3File(f)) {
    try {
      LimeXMLDocument diskID3Doc=ID3Reader.readDocument(f);
      resolveAudioDocs(xmlDocs,diskID3Doc);
    }
 catch (    IOException e) {
      return super.fileChanged(f);
    }
  }
  FileDesc removed=removeFileIfShared(f);
  Assert.that(fd == removed,""String_Node_Str"");
  _needRebuild=true;
  fd=addFileIfShared(f,xmlDocs);
  if ((fd != null) && (cTime != null)) {
synchronized (ctCache) {
      ctCache.removeTime(fd.getSHA1Urn());
      ctCache.addTime(fd.getSHA1Urn(),cTime.longValue());
      ctCache.commitTime(fd.getSHA1Urn());
    }
  }
  return fd;
}",0.9153625039923348
4454,"/** 
 * Changes the DatagramSocket used for sending/receiving.  Typically called by Acceptor to commit to the new port.
 * @param datagramSocket the new listening socket, which must be be thereturn value of newListeningSocket(int).  A value of null disables  UDP sending and receiving.
 */
void setListeningSocket(DatagramSocket datagramSocket){
  if (_socket != null)   _socket.close();
synchronized (_receiveLock) {
synchronized (_sendLock) {
      if (_socket == null)       _socketSetOnce=true;
      _socket=(DatagramSocket)datagramSocket;
      _receiveLock.notify();
      _sendLock.notify();
    }
  }
}","/** 
 * Changes the DatagramSocket used for sending/receiving.  Typically called by Acceptor to commit to the new port.
 * @param datagramSocket the new listening socket, which must be be thereturn value of newListeningSocket(int).  A value of null disables  UDP sending and receiving.
 */
void setListeningSocket(DatagramSocket datagramSocket){
  if (_socket != null)   _socket.close();
synchronized (_receiveLock) {
synchronized (_sendLock) {
      if ((_socket == null) && (datagramSocket != null))       _socketSetOnce=true;
      if (_socketSetOnce && (datagramSocket == null))       _socketSetOnce=false;
      _socket=(DatagramSocket)datagramSocket;
      _receiveLock.notify();
      _sendLock.notify();
    }
  }
}",0.8935532233883059
4455,"private static byte[] derivePayload(UDPCrawlerPing request){
  byte format=(byte)(request.getFormat() & UDPCrawlerPing.FEATURE_MASK);
  List endpointsUP=new LinkedList();
  List endpointsLeaf=new LinkedList();
  Iterator iter=RouterService.getConnectionManager().getInitializedConnections().iterator();
  boolean newOnly=request.hasNewOnly();
  while (iter.hasNext()) {
    Connection c=(Connection)iter.next();
    if (newOnly && c.supportsVendorMessage(VendorMessage.F_LIME_VENDOR_ID,VendorMessage.F_ULTRAPEER_LIST) != -1)     endpointsUP.add(c);
 else     if (c.isGoodUltrapeer())     endpointsUP.add(c);
  }
  iter=RouterService.getConnectionManager().getInitializedClientConnections().iterator();
  while (iter.hasNext()) {
    Connection c=(Connection)iter.next();
    endpointsLeaf.add(c);
  }
  if (!request.hasLocaleInfo()) {
    if (request.getNumberUP() != request.ALL && request.getNumberUP() < endpointsUP.size()) {
      int index=(int)Math.floor(Math.random() * (endpointsUP.size() - request.getNumberUP()));
      endpointsUP=endpointsUP.subList(index,index + request.getNumberUP());
    }
    if (request.getNumberLeaves() != request.ALL && request.getNumberLeaves() < endpointsLeaf.size()) {
      int index=(int)Math.floor(Math.random() * (endpointsLeaf.size() - request.getNumberLeaves()));
      endpointsLeaf=endpointsLeaf.subList(index,index + request.getNumberLeaves());
    }
  }
 else {
    String myLocale=ApplicationSettings.LANGUAGE.getValue();
    List prefedcons=RouterService.getConnectionManager().getInitializedConnectionsMatchLocale(myLocale);
    endpointsUP.removeAll(prefedcons);
    prefedcons.addAll(endpointsUP);
    endpointsUP=prefedcons;
    prefedcons=RouterService.getConnectionManager().getInitializedClientConnectionsMatchLocale(myLocale);
    endpointsLeaf.removeAll(prefedcons);
    prefedcons.addAll(endpointsLeaf);
    endpointsLeaf=prefedcons;
    if (request.getNumberUP() != request.ALL && request.getNumberUP() < endpointsUP.size())     endpointsUP=endpointsUP.subList(0,request.getNumberUP());
    if (request.getNumberLeaves() != request.ALL && request.getNumberLeaves() < endpointsLeaf.size())     endpointsLeaf=endpointsLeaf.subList(0,request.getNumberLeaves());
  }
  int bytesPerResult=6;
  if (request.hasConnectionTime())   bytesPerResult+=2;
  if (request.hasLocaleInfo())   bytesPerResult+=2;
  byte[] result=new byte[(endpointsUP.size() + endpointsLeaf.size()) * bytesPerResult + 3];
  result[0]=(byte)endpointsUP.size();
  result[1]=(byte)endpointsLeaf.size();
  result[2]=format;
  endpointsUP.addAll(endpointsLeaf);
  long now=System.currentTimeMillis();
  int index=3;
  iter=endpointsUP.iterator();
  while (iter.hasNext()) {
    Connection c=(Connection)iter.next();
    System.arraycopy(packIPAddress(c.getInetAddress(),c.getPort()),0,result,index,6);
    index+=6;
    if (request.hasConnectionTime()) {
      long uptime=now - c.getConnectionTime();
      short packed=(short)(uptime / Constants.MINUTE);
      ByteOrder.short2leb(packed,result,index);
      index+=2;
    }
    if (request.hasLocaleInfo()) {
      System.arraycopy(c.getLocalePref().getBytes(),0,result,index,2);
      index+=2;
    }
  }
  return result;
}","private static byte[] derivePayload(UDPCrawlerPing request){
  byte format=(byte)(request.getFormat() & UDPCrawlerPing.FEATURE_MASK);
  List endpointsUP=new LinkedList();
  List endpointsLeaf=new LinkedList();
  Iterator iter=RouterService.getConnectionManager().getInitializedConnections().iterator();
  boolean newOnly=request.hasNewOnly();
  while (iter.hasNext()) {
    Connection c=(Connection)iter.next();
    if (newOnly) {
      if (c.remoteHostSupportsUDPCrawling() >= 1)       endpointsUP.add(c);
    }
 else     if (c.isGoodUltrapeer())     endpointsUP.add(c);
  }
  iter=RouterService.getConnectionManager().getInitializedClientConnections().iterator();
  while (iter.hasNext()) {
    Connection c=(Connection)iter.next();
    endpointsLeaf.add(c);
  }
  if (!request.hasLocaleInfo()) {
    if (request.getNumberUP() != request.ALL && request.getNumberUP() < endpointsUP.size()) {
      int index=(int)Math.floor(Math.random() * (endpointsUP.size() - request.getNumberUP()));
      endpointsUP=endpointsUP.subList(index,index + request.getNumberUP());
    }
    if (request.getNumberLeaves() != request.ALL && request.getNumberLeaves() < endpointsLeaf.size()) {
      int index=(int)Math.floor(Math.random() * (endpointsLeaf.size() - request.getNumberLeaves()));
      endpointsLeaf=endpointsLeaf.subList(index,index + request.getNumberLeaves());
    }
  }
 else {
    String myLocale=ApplicationSettings.LANGUAGE.getValue();
    List prefedcons=RouterService.getConnectionManager().getInitializedConnectionsMatchLocale(myLocale);
    endpointsUP.removeAll(prefedcons);
    prefedcons.addAll(endpointsUP);
    endpointsUP=prefedcons;
    prefedcons=RouterService.getConnectionManager().getInitializedClientConnectionsMatchLocale(myLocale);
    endpointsLeaf.removeAll(prefedcons);
    prefedcons.addAll(endpointsLeaf);
    endpointsLeaf=prefedcons;
    if (request.getNumberUP() != request.ALL && request.getNumberUP() < endpointsUP.size())     endpointsUP=endpointsUP.subList(0,request.getNumberUP());
    if (request.getNumberLeaves() != request.ALL && request.getNumberLeaves() < endpointsLeaf.size())     endpointsLeaf=endpointsLeaf.subList(0,request.getNumberLeaves());
  }
  int bytesPerResult=6;
  if (request.hasConnectionTime())   bytesPerResult+=2;
  if (request.hasLocaleInfo())   bytesPerResult+=2;
  byte[] result=new byte[(endpointsUP.size() + endpointsLeaf.size()) * bytesPerResult + 3];
  result[0]=(byte)endpointsUP.size();
  result[1]=(byte)endpointsLeaf.size();
  result[2]=format;
  endpointsUP.addAll(endpointsLeaf);
  long now=System.currentTimeMillis();
  int index=3;
  iter=endpointsUP.iterator();
  while (iter.hasNext()) {
    Connection c=(Connection)iter.next();
    System.arraycopy(packIPAddress(c.getInetAddress(),c.getPort()),0,result,index,6);
    index+=6;
    if (request.hasConnectionTime()) {
      long uptime=now - c.getConnectionTime();
      short packed=(short)(uptime / Constants.MINUTE);
      ByteOrder.short2leb(packed,result,index);
      index+=2;
    }
    if (request.hasLocaleInfo()) {
      System.arraycopy(c.getLocalePref().getBytes(),0,result,index,2);
      index+=2;
    }
  }
  return result;
}",0.9682689286836318
4456,"/** 
 * Returns the number of invalid alternate locations that this download is using.
 */
public int getNumberOfInvalidAlternateLocations(){
  if (invalidAlts == null)   return 0;
  return invalidAlts.size();
}","/** 
 * Returns the number of invalid alternate locations that this download is using.
 */
public synchronized int getNumberOfInvalidAlternateLocations(){
  if (invalidAlts == null)   return 0;
  return invalidAlts.size();
}",0.9701149425287356
4457,"private static List createTTNodes(int nodeSize,long fileSize,InputStream is) throws IOException {
  List ret=new ArrayList((int)Math.ceil((double)fileSize / nodeSize));
  MessageDigest tt=new TigerTree();
  byte[] block=new byte[BLOCK_SIZE * 128];
  long offset=0;
  int read=0;
  while (offset < fileSize) {
    int nodeOffset=0;
    long time=System.currentTimeMillis();
    tt.reset();
    while (nodeOffset < nodeSize && (read=is.read(block)) != -1) {
      tt.update(block,0,read);
      nodeOffset+=read;
      offset+=read;
      try {
        Thread.sleep((System.currentTimeMillis() - time) * 2);
      }
 catch (      InterruptedException ie) {
        throw new IOException(""String_Node_Str"");
      }
      time=System.currentTimeMillis();
    }
    ret.add(tt.digest());
    if (offset == fileSize) {
      if (read != -1 && is.read() != -1) {
        LOG.warn(""String_Node_Str"");
        throw new IOException(""String_Node_Str"");
      }
    }
 else     if (read == -1 && offset != fileSize) {
      if (LOG.isWarnEnabled()) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + read + ""String_Node_Str""+ offset+ ""String_Node_Str""+ fileSize);
      }
      throw new IOException(""String_Node_Str"");
    }
  }
  return ret;
}","private static List createTTNodes(int nodeSize,long fileSize,InputStream is) throws IOException {
  List ret=new ArrayList((int)Math.ceil((double)fileSize / nodeSize));
  MessageDigest tt=new TigerTree();
  byte[] block=new byte[BLOCK_SIZE * 128];
  long offset=0;
  int read=0;
  while (offset < fileSize) {
    int nodeOffset=0;
    long time=System.currentTimeMillis();
    tt.reset();
    while (nodeOffset < nodeSize && (read=is.read(block)) != -1) {
      tt.update(block,0,read);
      nodeOffset+=read;
      offset+=read;
      try {
        long sleep=(System.currentTimeMillis() - time) * 2;
        if (sleep > 0)         Thread.sleep(sleep);
      }
 catch (      InterruptedException ie) {
        throw new IOException(""String_Node_Str"");
      }
      time=System.currentTimeMillis();
    }
    ret.add(tt.digest());
    if (offset == fileSize) {
      if (read != -1 && is.read() != -1) {
        LOG.warn(""String_Node_Str"");
        throw new IOException(""String_Node_Str"");
      }
    }
 else     if (read == -1 && offset != fileSize) {
      if (LOG.isWarnEnabled()) {
        LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + read + ""String_Node_Str""+ offset+ ""String_Node_Str""+ fileSize);
      }
      throw new IOException(""String_Node_Str"");
    }
  }
  return ret;
}",0.9499013806706116
4458,"public void testLegacy() throws Exception {
  AutoDownloadDetails details=new AutoDownloadDetails(""String_Node_Str"",""String_Node_Str"",new byte[16],new MediaType(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new String[0]));
  IncompleteFileManager ifm=new IncompleteFileManager();
  VerifyingFile vf=new VerifyingFile(true,100);
  vf.addInterval(new Interval(10,20));
  ifm.addEntry(new File(""String_Node_Str""),vf);
  RequeryDownloader downloader=new RequeryDownloader(ifm,details,null);
  downloader.initialize(new DownloadManager(),new SimpleFileManager(),new ActivityCallbackStub(),false);
  File tmp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(tmp));
  out.writeObject(downloader);
  out.close();
  ObjectInputStream in=new ObjectInputStream(new FileInputStream(tmp));
  RequeryDownloader downloader2=(RequeryDownloader)in.readObject();
  in.close();
  assertEquals(downloader.hasFile(),downloader2.hasFile());
  tmp.delete();
}","public void testLegacy() throws Exception {
  AutoDownloadDetails details=new AutoDownloadDetails(""String_Node_Str"",""String_Node_Str"",new byte[16],new MediaType(""String_Node_Str"",""String_Node_Str"",new String[0]));
  IncompleteFileManager ifm=new IncompleteFileManager();
  VerifyingFile vf=new VerifyingFile(true,100);
  vf.addInterval(new Interval(10,20));
  ifm.addEntry(new File(""String_Node_Str""),vf);
  RequeryDownloader downloader=new RequeryDownloader(ifm,details,null);
  downloader.initialize(new DownloadManager(),new SimpleFileManager(),new ActivityCallbackStub(),false);
  File tmp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(tmp));
  out.writeObject(downloader);
  out.close();
  ObjectInputStream in=new ObjectInputStream(new FileInputStream(tmp));
  RequeryDownloader downloader2=(RequeryDownloader)in.readObject();
  in.close();
  assertEquals(downloader.hasFile(),downloader2.hasFile());
  tmp.delete();
}",0.9911242603550297
4459,"/** 
 * Writes this mp3 file to disk, using the XML in the doc.
 */
public int mp3ToDisk(String mp3FileName,LimeXMLDocument doc){
  boolean wrote=false;
  int mp3WriteState=-1;
  debug(""String_Node_Str"" + mp3FileName + ""String_Node_Str"");
  ID3Editor commitWith=ripMP3XML(mp3FileName,doc);
  if (commitWith != null)   mp3WriteState=commitID3Data(mp3FileName,commitWith);
  Assert.that(mp3WriteState != INCORRECT_FILETYPE,""String_Node_Str"");
  wrote=write();
  if (!wrote)   return RW_ERROR;
  return mp3WriteState;
}","/** 
 * Writes this mp3 file to disk, using the XML in the doc.
 */
public int mp3ToDisk(FileDesc fd,String mp3FileName,LimeXMLDocument doc,boolean checkBetter){
  boolean wrote=false;
  int mp3WriteState=-1;
  debug(""String_Node_Str"" + mp3FileName + ""String_Node_Str"");
  ID3Editor commitWith=ripMP3XML(mp3FileName,doc,checkBetter);
  if (commitWith != null) {
    if (commitWith.getCorrectDocument() == null)     mp3WriteState=commitID3Data(mp3FileName,commitWith);
 else {
      removeDoc(fd);
      addReply(fd,commitWith.getCorrectDocument());
      mp3WriteState=NORMAL;
    }
  }
  Assert.that(mp3WriteState != INCORRECT_FILETYPE,""String_Node_Str"");
  wrote=write();
  if (!wrote)   return RW_ERROR;
  return mp3WriteState;
}",0.8269230769230769
4460,"/** 
 * Determines whether or not this LimeXMLDocument can or should be commited to disk to replace the ID3 tags in the mp3File. If the ID3 tags in the file are the same as those in document, this returns null (indicating no changes required).
 * @return An ID3Editor to use when committing or null if nothing should be editted.
 */
private ID3Editor ripMP3XML(String mp3File,LimeXMLDocument doc){
  if (!LimeXMLUtils.isMP3File(mp3File))   return null;
  ID3Editor newValues=new ID3Editor();
  String newXML=null;
  try {
    newXML=doc.getXMLStringWithIdentifier();
  }
 catch (  SchemaNotFoundException snfe) {
    return null;
  }
  newValues.removeID3Tags(newXML);
  ID3Editor existing=new ID3Editor();
  LimeXMLDocument existingDoc=null;
  try {
    existingDoc=ID3Reader.readDocument(new File(mp3File));
  }
 catch (  IOException e) {
    return null;
  }
  String existingXML=null;
  try {
    existingXML=existingDoc.getXMLStringWithIdentifier();
  }
 catch (  SchemaNotFoundException snfe) {
    return null;
  }
  existing.removeID3Tags(existingXML);
  if (newValues.equals(existing)) {
    debug(""String_Node_Str"");
    return null;
  }
  return newValues;
}","/** 
 * Determines whether or not this LimeXMLDocument can or should be commited to disk to replace the ID3 tags in the mp3File. If the ID3 tags in the file are the same as those in document, this returns null (indicating no changes required).
 * @return An ID3Editor to use when committing or null if nothing should be editted.
 */
private ID3Editor ripMP3XML(String mp3File,LimeXMLDocument doc,boolean checkBetter){
  if (!LimeXMLUtils.isMP3File(mp3File))   return null;
  ID3Editor newValues=new ID3Editor();
  String newXML=null;
  try {
    newXML=doc.getXMLStringWithIdentifier();
  }
 catch (  SchemaNotFoundException snfe) {
    return null;
  }
  newValues.removeID3Tags(newXML);
  ID3Editor existing=new ID3Editor();
  LimeXMLDocument existingDoc=null;
  try {
    existingDoc=ID3Reader.readDocument(new File(mp3File));
  }
 catch (  IOException e) {
    return null;
  }
  String existingXML=null;
  try {
    existingXML=existingDoc.getXMLStringWithIdentifier();
  }
 catch (  SchemaNotFoundException snfe) {
    return null;
  }
  existing.removeID3Tags(existingXML);
  if (!checkBetter) {
    if (newValues.equals(existing))     return null;
 else     return newValues;
  }
  if (newValues.equals(existing)) {
    debug(""String_Node_Str"");
    return null;
  }
 else   if (existing.betterThan(newValues)) {
    existing.setCorrectDocument(existingDoc);
    return existing;
  }
 else   newValues.pickBetterFields(existing);
  return newValues;
}",0.8820395738203958
4461,"/** 
 * Creates a new LimeXMLReplyCollection.  The reply collection will retain only those XMLDocs that match the given schema URI.
 * @param fds The list of shared FileDescs.
 * @param URI This collection's schema URI
 * @param audio Whether this is a collection of audio files.
 */
public LimeXMLReplyCollection(FileDesc[] fds,String URI,boolean audio){
  this.schemaURI=URI;
  this.audio=audio;
  debug(""String_Node_Str"" + audio);
  mainMap=new HashMap();
  trieMap=new HashMap();
  MapSerializer ms=initializeMapSerializer(URI);
  Map hashToXML;
  if (ms == null)   hashToXML=new HashMap();
 else   hashToXML=ms.getMap();
  boolean requiresConversion=false;
{
    Iterator iter=hashToXML.keySet().iterator();
    if (iter.hasNext())     requiresConversion=(iter.next() instanceof String);
    debug(""String_Node_Str"" + requiresConversion);
  }
  for (int i=0; i < fds.length; i++) {
    FileDesc fd=fds[i];
    if (fd instanceof IncompleteFileDesc)     continue;
    File file=fd.getFile();
    URN hash=fd.getSHA1Urn();
    Object xml=null;
    LimeXMLDocument doc=null;
    if (requiresConversion) {
      String miniHash=null;
      try {
        miniHash=new String(LimeXMLUtils.hashFile(file));
      }
 catch (      IOException e) {
        continue;
      }
      xml=hashToXML.get(miniHash);
      if (xml != null && xml instanceof LimeXMLDocument) {
        doc=(LimeXMLDocument)xml;
      }
 else {
        doc=constructDocument((String)xml,file);
      }
    }
 else {
      xml=hashToXML.get(hash);
      if (xml == null) {
        doc=constructDocument(null,file);
      }
 else {
        doc=(LimeXMLDocument)xml;
      }
    }
    if (doc == null)     continue;
    if (!doc.isValid()) {
      doc=constructDocument(null,file);
      if (doc == null || !doc.isValid())       continue;
    }
    if (ID3Reader.isCorrupted(doc)) {
      doc=ID3Reader.fixCorruption(doc);
      addReplyWithCommit(file,fd,doc);
    }
 else {
      addReply(fd,doc);
    }
  }
  debug(""String_Node_Str"");
  write();
}","/** 
 * Creates a new LimeXMLReplyCollection.  The reply collection will retain only those XMLDocs that match the given schema URI.
 * @param fds The list of shared FileDescs.
 * @param URI This collection's schema URI
 * @param audio Whether this is a collection of audio files.
 */
public LimeXMLReplyCollection(FileDesc[] fds,String URI,boolean audio){
  this.schemaURI=URI;
  this.audio=audio;
  debug(""String_Node_Str"" + audio);
  mainMap=new HashMap();
  trieMap=new HashMap();
  MapSerializer ms=initializeMapSerializer(URI);
  Map hashToXML;
  if (ms == null)   hashToXML=new HashMap();
 else   hashToXML=ms.getMap();
  boolean requiresConversion=false;
{
    Iterator iter=hashToXML.keySet().iterator();
    if (iter.hasNext())     requiresConversion=(iter.next() instanceof String);
    debug(""String_Node_Str"" + requiresConversion);
  }
  for (int i=0; i < fds.length; i++) {
    FileDesc fd=fds[i];
    if (fd instanceof IncompleteFileDesc)     continue;
    File file=fd.getFile();
    URN hash=fd.getSHA1Urn();
    Object xml=null;
    LimeXMLDocument doc=null;
    if (requiresConversion) {
      String miniHash=null;
      try {
        miniHash=new String(LimeXMLUtils.hashFile(file));
      }
 catch (      IOException e) {
        continue;
      }
      xml=hashToXML.get(miniHash);
      if (xml != null && xml instanceof LimeXMLDocument) {
        doc=(LimeXMLDocument)xml;
      }
 else {
        doc=constructDocument((String)xml,file);
      }
    }
 else {
      xml=hashToXML.get(hash);
      if (xml == null) {
        doc=constructDocument(null,file);
      }
 else {
        doc=(LimeXMLDocument)xml;
      }
    }
    if (doc == null)     continue;
    if (!doc.isValid()) {
      doc=constructDocument(null,file);
      if (doc == null || !doc.isValid())       continue;
    }
    if (ID3Reader.isCorrupted(doc)) {
      doc=ID3Reader.fixCorruption(doc);
      addReplyWithCommit(file,fd,doc,false);
    }
 else {
      addReply(fd,doc);
    }
  }
  debug(""String_Node_Str"");
  write();
}",0.9985133795837464
4462,"/** 
 * Adds a reply into the mainMap of this collection, associating the FileDesc with the LimeXMLDocument. If this collection is an audio collection, this will write out the file to disk, possibly adding/changing ID3 tags on an MP3 file. If the file changed because of this operation, the FileManager is notified of the changed file, redoing its hashes. Regardless of whether or not this collection is for audio files, the map of (URN -> LimeXMLDocument) will always be serialized to disk.
 */
void addReplyWithCommit(File f,FileDesc fd,LimeXMLDocument replyDoc){
  addReply(fd,replyDoc);
  if (audio) {
    try {
      mp3ToDisk(f.getCanonicalPath(),replyDoc);
    }
 catch (    IOException ignored) {
    }
  }
 else   write();
}","/** 
 * Adds a reply into the mainMap of this collection, associating the FileDesc with the LimeXMLDocument. If this collection is an audio collection, this will write out the file to disk, possibly adding/changing ID3 tags on an MP3 file. If the file changed because of this operation, the FileManager is notified of the changed file, redoing its hashes. Regardless of whether or not this collection is for audio files, the map of (URN -> LimeXMLDocument) will always be serialized to disk.
 */
void addReplyWithCommit(File f,FileDesc fd,LimeXMLDocument replyDoc,boolean checkBetter){
  addReply(fd,replyDoc);
  if (audio) {
    try {
      mp3ToDisk(fd,f.getCanonicalPath(),replyDoc,checkBetter);
    }
 catch (    IOException ignored) {
    }
  }
 else   write();
}",0.9766822118587608
4463,"/** 
 * @modifies this
 * @effects calls addFileIfShared(file), then stores any metadata from thegiven XML documents.  metadata may be null if there is no data.  Returns the value from addFileIfShared.  Returns the value from addFileIfShared. <b>WARNING: this is a potential security hazard.</b> 
 * @return The FileDesc that was added, or null if nothing added.
 */
public FileDesc addFileIfShared(File file,List metadata){
  FileDesc fd=super.addFileIfShared(file);
  if (fd == null)   return null;
  if (metadata == null || metadata.size() == 0) {
    if (!LimeXMLUtils.isMP3File(file))     return fd;
    LimeXMLDocument doc;
    try {
      doc=ID3Reader.readDocument(file);
    }
 catch (    IOException ioe) {
      return fd;
    }
    metadata=new LinkedList();
    metadata.add(doc);
  }
  SchemaReplyCollectionMapper mapper=SchemaReplyCollectionMapper.instance();
  List schemasAddedTo=new LinkedList();
  for (Iterator iter=metadata.iterator(); iter.hasNext(); ) {
    LimeXMLDocument currDoc=(LimeXMLDocument)iter.next();
    String uri=currDoc.getSchemaURI();
    LimeXMLReplyCollection collection=mapper.getReplyCollection(uri);
    if (collection != null && !schemasAddedTo.contains(uri)) {
      schemasAddedTo.add(uri);
      if (ID3Reader.isCorrupted(currDoc))       currDoc=ID3Reader.fixCorruption(currDoc);
      collection.addReplyWithCommit(file,fd,currDoc);
    }
  }
  _needRebuild=true;
  return fd;
}","/** 
 * @modifies this
 * @effects calls addFileIfShared(file), then stores any metadata from thegiven XML documents.  metadata may be null if there is no data.  Returns the value from addFileIfShared.  Returns the value from addFileIfShared. <b>WARNING: this is a potential security hazard.</b> 
 * @return The FileDesc that was added, or null if nothing added.
 */
public FileDesc addFileIfShared(File file,List metadata){
  FileDesc fd=super.addFileIfShared(file);
  if (fd == null)   return null;
  if (metadata == null || metadata.size() == 0) {
    if (!LimeXMLUtils.isMP3File(file))     return fd;
    LimeXMLDocument doc;
    try {
      doc=ID3Reader.readDocument(file);
    }
 catch (    IOException ioe) {
      return fd;
    }
    metadata=new LinkedList();
    metadata.add(doc);
  }
  SchemaReplyCollectionMapper mapper=SchemaReplyCollectionMapper.instance();
  List schemasAddedTo=new LinkedList();
  for (Iterator iter=metadata.iterator(); iter.hasNext(); ) {
    LimeXMLDocument currDoc=(LimeXMLDocument)iter.next();
    String uri=currDoc.getSchemaURI();
    LimeXMLReplyCollection collection=mapper.getReplyCollection(uri);
    if (collection != null && !schemasAddedTo.contains(uri)) {
      schemasAddedTo.add(uri);
      if (ID3Reader.isCorrupted(currDoc))       currDoc=ID3Reader.fixCorruption(currDoc);
      collection.addReplyWithCommit(file,fd,currDoc,true);
    }
  }
  _needRebuild=true;
  return fd;
}",0.9982511367611052
4464,"public void testDownloadFinishes() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=TestFile.hash();
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
{
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(1,endpoints.size());
  }
  long currTime=System.currentTimeMillis();
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  Thread.sleep(5000);
  assertEquals(Downloader.ITERATIVE_GUESSING,downloader.getState());
{
    boolean gotPing=false;
    while (!gotPing) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[0].setSoTimeout(10000);
        UDP_ACCESS[0].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        m.hop();
        if (m instanceof PingRequest)         gotPing=((PingRequest)m).isQueryKeyRequest();
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(false);
      }
    }
  }
  QueryKey qk=QueryKey.getQueryKey(InetAddress.getLocalHost(),SERVER_PORT);
{
    byte[] ip=new byte[]{(byte)127,(byte)0,(byte)0,(byte)1};
    PingReply pr=PingReply.createQueryKeyReply(GUID.makeGuid(),(byte)1,UDP_ACCESS[0].getLocalPort(),ip,10,10,false,qk);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pr.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(500);
{
    Map _queryKeys=(Map)PrivilegedAccessor.getValue(OnDemandUnicaster.class,""String_Node_Str"");
    assertNotNull(_queryKeys);
    assertEquals(1,_queryKeys.size());
  }
{
    boolean gotQuery=false;
    while (!gotQuery) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[0].setSoTimeout(10000);
        UDP_ACCESS[0].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        if (m instanceof QueryRequest) {
          QueryRequest qReq=(QueryRequest)m;
          Set queryURNs=qReq.getQueryUrns();
          gotQuery=queryURNs.contains(urn);
          if (gotQuery)           gotQuery=qk.equals(qReq.getQueryKey());
        }
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(false);
      }
    }
  }
  long timeoutVal=1000 - (System.currentTimeMillis() - currTime);
  Thread.sleep(timeoutVal > 0 ? timeoutVal : 0);
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  ((MyCallback)getCallback()).clearGUID();
  TestUploader uploader2=new TestUploader(""String_Node_Str"",UPLOADER_PORT + 1);
  uploader2.setRate(100);
{
    rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT + 1,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
    Response[] res=new Response[]{new Response(10,10,""String_Node_Str"")};
    m=new QueryReply(qr.getGUID(),(byte)1,UPLOADER_PORT + 1,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    m.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(10000);
  assertEquals(Downloader.COMPLETE,downloader.getState());
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}","public void testDownloadFinishes() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=TestFile.hash();
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
{
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(1,endpoints.size());
  }
  long currTime=System.currentTimeMillis();
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  Thread.sleep(500);
  assertEquals(Downloader.ITERATIVE_GUESSING,downloader.getState());
{
    boolean gotPing=false;
    while (!gotPing) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[0].setSoTimeout(10000);
        UDP_ACCESS[0].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        m.hop();
        if (m instanceof PingRequest)         gotPing=((PingRequest)m).isQueryKeyRequest();
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(false);
      }
    }
  }
  QueryKey qk=QueryKey.getQueryKey(InetAddress.getLocalHost(),SERVER_PORT);
{
    byte[] ip=new byte[]{(byte)127,(byte)0,(byte)0,(byte)1};
    PingReply pr=PingReply.createQueryKeyReply(GUID.makeGuid(),(byte)1,UDP_ACCESS[0].getLocalPort(),ip,10,10,false,qk);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pr.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(500);
{
    Map _queryKeys=(Map)PrivilegedAccessor.getValue(OnDemandUnicaster.class,""String_Node_Str"");
    assertNotNull(_queryKeys);
    assertEquals(1,_queryKeys.size());
  }
{
    boolean gotQuery=false;
    while (!gotQuery) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[0].setSoTimeout(10000);
        UDP_ACCESS[0].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        if (m instanceof QueryRequest) {
          QueryRequest qReq=(QueryRequest)m;
          Set queryURNs=qReq.getQueryUrns();
          gotQuery=queryURNs.contains(urn);
          if (gotQuery)           gotQuery=qk.equals(qReq.getQueryKey());
        }
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(false);
      }
    }
  }
  long timeoutVal=1000 - (System.currentTimeMillis() - currTime);
  Thread.sleep(timeoutVal > 0 ? timeoutVal : 0);
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  ((MyCallback)getCallback()).clearGUID();
  TestUploader uploader2=new TestUploader(""String_Node_Str"",UPLOADER_PORT + 1);
  uploader2.setRate(100);
{
    rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT + 1,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
    Response[] res=new Response[]{new Response(10,10,""String_Node_Str"")};
    m=new QueryReply(qr.getGUID(),(byte)1,UPLOADER_PORT + 1,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    m.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[0].send(pack);
  }
  Thread.sleep(10000);
  assertEquals(Downloader.COMPLETE,downloader.getState());
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}",0.999907019990702
4465,"public void testBusyDownloadLocatesSources() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=URN.createSHA1Urn(""String_Node_Str"");
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
  for (int i=0; i < UDP_ACCESS.length; i++) {
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),i + 1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[i].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(UDP_ACCESS.length,endpoints.size());
  }
  long currTime=System.currentTimeMillis();
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  Thread.sleep(5000);
  assertEquals(Downloader.ITERATIVE_GUESSING,downloader.getState());
  for (int i=0; i < UDP_ACCESS.length; i++) {
    boolean gotPing=false;
    while (!gotPing) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[i].setSoTimeout(10000);
        UDP_ACCESS[i].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        m.hop();
        if (m instanceof PingRequest)         gotPing=((PingRequest)m).isQueryKeyRequest();
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(""String_Node_Str"" + i,false);
      }
    }
  }
  Thread.sleep(1000);
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  ((MyCallback)getCallback()).clearGUID();
  downloader.stop();
  Thread.sleep(1000);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}","public void testBusyDownloadLocatesSources() throws Exception {
  keepAllAlive(testUP);
  drainAll();
  DatagramPacket pack=null;
  Message m=null;
  byte[] guid=RouterService.newQueryGUID();
  RouterService.query(guid,""String_Node_Str"");
  ((MyCallback)getCallback()).setGUID(new GUID(guid));
  QueryRequest qr=(QueryRequest)getFirstInstanceOfMessageType(testUP[0],QueryRequest.class);
  assertNotNull(qr);
  assertTrue(qr.desiresOutOfBandReplies());
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[200];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10 + j + i,10 + j + i,""String_Node_Str"" + j + i);
    m=new QueryReply(qr.getGUID(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  final int UPLOADER_PORT=10000;
  TestUploader uploader=new TestUploader(""String_Node_Str"",UPLOADER_PORT);
  uploader.setBusy(true);
  URN urn=URN.createSHA1Urn(""String_Node_Str"");
  Set urns=new HashSet();
  urns.add(urn);
  RemoteFileDesc rfd=new RemoteFileDesc(""String_Node_Str"",UPLOADER_PORT,1,""String_Node_Str"",10,GUID.makeGuid(),1,false,3,false,null,urns,false,false,""String_Node_Str"",0,new HashSet());
  Thread.sleep(1500);
  for (int i=0; i < UDP_ACCESS.length; i++) {
    ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(qr.getGUID()),i + 1);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    vm.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),SERVER_PORT);
    UDP_ACCESS[i].send(pack);
  }
  Thread.sleep(500);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(1,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNotNull(endpoints);
    assertEquals(UDP_ACCESS.length,endpoints.size());
  }
  long currTime=System.currentTimeMillis();
  Downloader downloader=RouterService.download(new RemoteFileDesc[]{rfd},false,new GUID(guid));
  Thread.sleep(10000);
  assertEquals(Downloader.ITERATIVE_GUESSING,downloader.getState());
  for (int i=0; i < UDP_ACCESS.length; i++) {
    boolean gotPing=false;
    while (!gotPing) {
      try {
        byte[] datagramBytes=new byte[1000];
        pack=new DatagramPacket(datagramBytes,1000);
        UDP_ACCESS[i].setSoTimeout(10000);
        UDP_ACCESS[i].receive(pack);
        InputStream in=new ByteArrayInputStream(pack.getData());
        m=Message.read(in);
        m.hop();
        if (m instanceof PingRequest)         gotPing=((PingRequest)m).isQueryKeyRequest();
      }
 catch (      InterruptedIOException iioe) {
        assertTrue(""String_Node_Str"" + i,false);
      }
    }
  }
  Thread.sleep(1000);
  assertEquals(Downloader.WAITING_FOR_RETRY,downloader.getState());
  ((MyCallback)getCallback()).clearGUID();
  downloader.stop();
  Thread.sleep(1000);
{
    Map _bypassedResults=(Map)PrivilegedAccessor.getValue(RouterService.getMessageRouter(),""String_Node_Str"");
    assertNotNull(_bypassedResults);
    assertEquals(0,_bypassedResults.size());
    Set endpoints=(Set)_bypassedResults.get(new GUID(qr.getGUID()));
    assertNull(endpoints);
  }
}",0.9995463481022228
4466,"/** 
 * Generates ID3Data from id3v2 data in the file.
 */
private static ID3Data parseID3v2Data(File file){
  ID3Data data=new ID3Data();
  ID3v2 id3v2Parser=null;
  try {
    id3v3Parser=new ID3v2(file);
  }
 catch (  ID3v2Exception idvx) {
    return data;
  }
catch (  IOException iox) {
    return data;
  }
  Vector frames=null;
  try {
    frames=id3v2Parser.getFrames();
  }
 catch (  NoID3v2TagException ntx) {
    return data;
  }
  for (Iterator iter=frames.iterator(); iter.hasNext(); ) {
    ID2v3Frame frame=(ID3v2Frame)iter.next();
    String frameID=frame.getID();
    String frameContent=new String(frame.getContent());
    if (frameContent == null || frameContent.trim().equals(""String_Node_Str""))     continue;
    if (ID3Editor.TITLE_ID.equals(frameID))     data.setTitle(frameContent);
 else     if (ID3Editor.ARTIST_ID.equals(frameID))     data.setArtist(frameContent);
 else     if (ID3Editor.ALBUM_ID.equals(frameID))     data.setAlbum(frameContent);
 else     if (ID3Editor.YEAR_ID.equals(frameID))     data.setYear(frameContent);
 else     if (ID3Editor.COMMENT_ID.equals(frameID))     data.setComment(frameContent);
 else     if (ID3Editor.TRACK_ID.equals(frameID)) {
      try {
        data.setTrack(Short.parseShort(frameContent));
      }
 catch (      NumberFormatException ignored) {
      }
    }
 else     if (ID3Editor.GENRE_ID.equals(frameID)) {
      int index=frameContent.indexOf(""String_Node_Str"");
      if (index == -1 || !(index == 2 || index == 3 || index == 4))       data.setGenre(frameContent);
 else       data.setGenre(frameContent.substring(index + 1));
    }
  }
  return data;
}","/** 
 * Generates ID3Data from id3v2 data in the file.
 */
private static ID3Data parseID3v2Data(File file){
  ID3Data data=new ID3Data();
  ID3v2 id3v2Parser=null;
  try {
    id3v2Parser=new ID3v2(file);
  }
 catch (  ID3v2Exception idvx) {
    return data;
  }
catch (  IOException iox) {
    return data;
  }
  Vector frames=null;
  try {
    frames=id3v2Parser.getFrames();
  }
 catch (  NoID3v2TagException ntx) {
    return data;
  }
  for (Iterator iter=frames.iterator(); iter.hasNext(); ) {
    ID3v2Frame frame=(ID3v2Frame)iter.next();
    String frameID=frame.getID();
    String frameContent=new String(frame.getContent());
    if (frameContent == null || frameContent.trim().equals(""String_Node_Str""))     continue;
    if (ID3Editor.TITLE_ID.equals(frameID))     data.setTitle(frameContent);
 else     if (ID3Editor.ARTIST_ID.equals(frameID))     data.setArtist(frameContent);
 else     if (ID3Editor.ALBUM_ID.equals(frameID))     data.setAlbum(frameContent);
 else     if (ID3Editor.YEAR_ID.equals(frameID))     data.setYear(frameContent);
 else     if (ID3Editor.COMMENT_ID.equals(frameID))     data.setComment(frameContent);
 else     if (ID3Editor.TRACK_ID.equals(frameID)) {
      try {
        data.setTrack(Short.parseShort(frameContent));
      }
 catch (      NumberFormatException ignored) {
      }
    }
 else     if (ID3Editor.GENRE_ID.equals(frameID)) {
      int index=frameContent.indexOf(""String_Node_Str"");
      if (index == -1 || !(index == 2 || index == 3 || index == 4))       data.setGenre(frameContent);
 else       data.setGenre(frameContent.substring(index + 1));
    }
  }
  return data;
}",0.998160637645616
4467,"/** 
 * Creates a new <tt>ConnectionChecker</tt> instance that checks for a live internet connection.  If the checker determines that there is no active  connection, it will notify the <tt>ConnectionManager</tt> to take appropriate action.
 * @return a new <tt>ConnectionChecker</tt> instance
 */
public static ConnectionChecker checkForLiveConnection(){
  LOG.trace(""String_Node_Str"");
  ConnectionChecker checker=new ConnectionChecker();
  Thread connectionThread=new ManagedThread(checker,""String_Node_Str"");
  connectionThread.setDaemon(false);
  connectionThread.setDaemon(true);
  connectionThread.start();
  return checker;
}","/** 
 * Creates a new <tt>ConnectionChecker</tt> instance that checks for a live internet connection.  If the checker determines that there is no active  connection, it will notify the <tt>ConnectionManager</tt> to take appropriate action.
 * @return a new <tt>ConnectionChecker</tt> instance
 */
public static ConnectionChecker checkForLiveConnection(){
  LOG.trace(""String_Node_Str"");
  ConnectionChecker checker=new ConnectionChecker();
  Thread connectionThread=new ManagedThread(checker,""String_Node_Str"");
  connectionThread.setDaemon(true);
  connectionThread.start();
  return checker;
}",0.9698451507742462
4468,"/** 
 * @requires this' monitor held
 * @modifies this
 * @effects returns the highest priority endpoint in queue, regardlessof quick-connect settings, etc.  Throws NoSuchElementException if this is empty.
 */
private ExtendedEndpoint getAnEndpointInternal() throws NoSuchElementException {
  if (RouterService.isSupernode() && !FREE_ULTRAPEER_SLOTS_SET.isEmpty()) {
    Iterator iter=FREE_ULTRAPEER_SLOTS_SET.iterator();
    ExtendedEndpoint ee=(ExtendedEndpoint)iter.next();
    iter.remove();
    return ee;
  }
 else   if (RouterService.isShieldedLeaf() && !FREE_LEAF_SLOTS_SET.isEmpty()) {
    Iterator iter=FREE_LEAF_SLOTS_SET.iterator();
    ExtendedEndpoint ee=(ExtendedEndpoint)iter.next();
    iter.remove();
    return ee;
  }
 else   if (!FREE_ULTRAPEER_SLOTS_SET.isEmpty()) {
    Iterator iter=FREE_ULTRAPEER_SLOTS_SET.iterator();
    ExtendedEndpoint ee=(ExtendedEndpoint)iter.next();
    iter.remove();
    return ee;
  }
  if (!ENDPOINT_QUEUE.isEmpty()) {
    ExtendedEndpoint e=(ExtendedEndpoint)ENDPOINT_QUEUE.extractMax();
    boolean ok=ENDPOINT_SET.remove(e);
    Assert.that(ok,""String_Node_Str"");
    return e;
  }
 else   throw new NoSuchElementException();
}","/** 
 * @requires this' monitor held
 * @modifies this
 * @effects returns the highest priority endpoint in queue, regardlessof quick-connect settings, etc.  Throws NoSuchElementException if this is empty.
 */
private ExtendedEndpoint getAnEndpointInternal() throws NoSuchElementException {
  if (RouterService.isSupernode() && !FREE_ULTRAPEER_SLOTS_SET.isEmpty()) {
    Iterator iter=FREE_ULTRAPEER_SLOTS_SET.iterator();
    ExtendedEndpoint ee=(ExtendedEndpoint)iter.next();
    iter.remove();
    return ee;
  }
 else   if (RouterService.isShieldedLeaf() && !FREE_LEAF_SLOTS_SET.isEmpty()) {
    Iterator iter=FREE_LEAF_SLOTS_SET.iterator();
    ExtendedEndpoint ee=(ExtendedEndpoint)iter.next();
    iter.remove();
    return ee;
  }
 else   if (!FREE_ULTRAPEER_SLOTS_SET.isEmpty()) {
    Iterator iter=FREE_ULTRAPEER_SLOTS_SET.iterator();
    ExtendedEndpoint ee=(ExtendedEndpoint)iter.next();
    iter.remove();
    return ee;
  }
 else   if (!FREE_LEAF_SLOTS_SET.isEmpty()) {
    Iterator iter=FREE_LEAF_SLOTS_SET.iterator();
    ExtendedEndpoint ee=(ExtendedEndpoint)iter.next();
    iter.remove();
    return ee;
  }
  if (!ENDPOINT_QUEUE.isEmpty()) {
    ExtendedEndpoint e=(ExtendedEndpoint)ENDPOINT_QUEUE.extractMax();
    boolean ok=ENDPOINT_SET.remove(e);
    Assert.that(ok,""String_Node_Str"");
    return e;
  }
 else   throw new NoSuchElementException();
}",0.926027397260274
4469,"public void testSet() throws Exception {
  final int MAX_SIZE=8;
  final long EXPIRE_TIME=10 * 1000;
  FixedSizeExpiringSet set=new FixedSizeExpiringSet(MAX_SIZE,EXPIRE_TIME);
  String[] obj=new String[10];
  for (int i=0; i < 10; i++) {
    obj[i]=""String_Node_Str"" + i;
  }
  long[] timeExpiring=new long[10];
  for (int i=0; i < 10; i++) {
    timeExpiring[i]=System.currentTimeMillis() + EXPIRE_TIME;
    set.add(obj[i]);
    Thread.sleep(150L);
  }
  assertEquals(set.size(),MAX_SIZE);
  assertFalse(set.contains(obj[0]));
  assertFalse(set.contains(obj[1]));
  assertTrue(set.contains(obj[2]));
  set.remove(obj[2]);
  assertFalse(set.contains(obj[1]));
  set.add(obj[0]);
  assertTrue(set.contains(obj[8]));
  assertTrue(set.contains(obj[3]));
  set.remove(obj[3]);
  assertFalse(set.contains(obj[3]));
  set.add(obj[1]);
  assertTrue(set.contains(obj[1]));
  while (set.size() > 0) {
    for (int i=4; i < 10; i++) {
      if (set.contains(obj[i])) {
        assertGreaterThanOrEquals(System.currentTimeMillis(),timeExpiring[i]);
      }
 else {
        assertGreaterThan(timeExpiring[i],System.currentTimeMillis());
      }
    }
    Thread.sleep(100L);
  }
  Collection col=new ArrayList();
  for (int i=0; i < 10; i++)   col.add(obj[i]);
  set.addAll(col);
  assertEquals(set.size(),MAX_SIZE);
  assertFalse(set.contains(obj[8]));
  assertFalse(set.contains(obj[9]));
  assertTrue(set.contains(obj[0]));
  assertTrue(set.contains(obj[1]));
  col.clear();
  for (int i=6; i < 10; i++)   col.add(obj[i]);
  set.removeAll(col);
  for (int i=0; i < 6; i++)   assertTrue(set.contains(obj[i]));
  for (int i=6; i < 10; i++)   assertFalse(set.contains(obj[i]));
  set.clear();
  assertEquals(set.size(),0);
  for (int i=0; i < 10; i++)   set.add(obj[i]);
  set.retainAll(col);
  System.out.println(""String_Node_Str"" + set.size());
  for (int i=0; i < 6; i++)   assertFalse(set.contains(obj[i]));
  for (int i=6; i < 9; i++)   assertTrue(set.contains(obj[i]));
}","public void testSet() throws Exception {
  empty1.add(nullObj);
  assertTrue(empty1.isEmpty());
  try {
    empty1.addAll(nullColl);
    fail(""String_Node_Str"");
  }
 catch (  NullPointerException e) {
  }
  empty1.addAll(empty2);
  assertTrue(empty1.isEmpty());
  fastSet.add(empty1);
  Thread.sleep(60);
  assertFalse(fastSet.contains(empty1));
  String[] obj=new String[10];
  for (int i=0; i < 10; i++) {
    obj[i]=""String_Node_Str"" + i;
  }
  long[] timeExpiring=new long[10];
  for (int i=0; i < 10; i++) {
    timeExpiring[i]=System.currentTimeMillis() + EXPIRE_TIME;
    set.add(obj[i]);
    Thread.sleep(150L);
  }
  assertEquals(set.size(),MAX_SIZE);
  assertFalse(set.contains(obj[0]));
  assertFalse(set.contains(obj[1]));
  assertTrue(set.contains(obj[2]));
  set.remove(obj[2]);
  assertFalse(set.contains(obj[1]));
  set.add(obj[0]);
  assertTrue(set.contains(obj[8]));
  assertTrue(set.contains(obj[3]));
  set.remove(obj[3]);
  assertFalse(set.contains(obj[3]));
  set.add(obj[1]);
  assertTrue(set.contains(obj[1]));
  while (set.size() > 0) {
    for (int i=4; i < 10; i++) {
      if (set.contains(obj[i])) {
        assertGreaterThanOrEquals(System.currentTimeMillis(),timeExpiring[i]);
      }
 else {
        assertGreaterThan(timeExpiring[i],System.currentTimeMillis());
      }
    }
    Thread.sleep(100L);
  }
  Collection col=new ArrayList();
  for (int i=0; i < 10; i++)   col.add(obj[i]);
  set.addAll(col);
  assertEquals(set.size(),MAX_SIZE);
  assertFalse(set.contains(obj[8]));
  assertFalse(set.contains(obj[9]));
  assertTrue(set.contains(obj[0]));
  assertTrue(set.contains(obj[1]));
  col.clear();
  for (int i=6; i < 10; i++)   col.add(obj[i]);
  set.removeAll(col);
  for (int i=0; i < 6; i++)   assertTrue(set.contains(obj[i]));
  for (int i=6; i < 10; i++)   assertFalse(set.contains(obj[i]));
  set.clear();
  assertEquals(set.size(),0);
  for (int i=0; i < 10; i++) {
    set.add(obj[i]);
    Thread.sleep(20);
  }
  for (int i=2; i < 10; i++)   assertTrue(set.contains(obj[i]));
  set.retainAll(col);
  for (int i=0; i < 6; i++)   assertFalse(set.contains(obj[i]));
  for (int i=6; i < 9; i++)   assertTrue(set.contains(obj[i]));
  assertEquals(set.size(),col.size());
  assertTrue(set.containsAll(col));
  set.removeAll(empty1);
  assertEquals(set.size(),col.size());
  set.removeAll(col);
  assertTrue(set.isEmpty());
  Object[] array1=set.toArray();
  assertEquals(array1.length,set.size());
  Object[] array2=set.toArray(array1);
  assertEquals(array1.length,array2.length);
}",0.6942774437764417
4470,"/** 
 * Returns the URN for the bucket with the most entries.
 */
synchronized URN getBestURN(){
  int index=0;
  final int numBuckets=buckets.size();
  for (int i=0, maxNum=0; i < numBuckets; i++) {
    List currBucket=(List)buckets.get(i);
    if (currBucket.size() > maxNum) {
      maxNum=currBucket.size();
      index=i;
    }
  }
  return sha1s[index];
}","/** 
 * Returns the URN for the bucket with the most entries.  May return null.
 */
synchronized URN getBestURN(){
  if (sha1s.length < 1)   return null;
  int index=0;
  final int numBuckets=buckets.size();
  for (int i=0, maxNum=0; i < numBuckets; i++) {
    List currBucket=(List)buckets.get(i);
    if (currBucket.size() > maxNum) {
      maxNum=currBucket.size();
      index=i;
    }
  }
  if (index < sha1s.length)   return sha1s[index];
 else   return null;
}",0.857487922705314
4471,"/** 
 * Writes the common headers -- headers that all LimeWires should send, like Query-Routing and User-Agent.
 */
private static void addCommonHeaders(Properties props){
  props.put(HeaderNames.X_QUERY_ROUTING,QUERY_ROUTING_VERSION);
  props.put(HeaderNames.USER_AGENT,CommonUtils.getHttpServer());
  props.put(HeaderNames.GGEP,""String_Node_Str"");
  props.put(HeaderNames.X_GUESS,""String_Node_Str"");
  props.put(HeaderNames.X_VENDOR_MESSAGE,""String_Node_Str"");
  props.put(HeaderNames.X_DEGREE,Integer.toString(ConnectionManager.ULTRAPEER_CONNECTIONS));
  props.put(HeaderNames.X_ULTRAPEER_QUERY_ROUTING,QUERY_ROUTING_VERSION);
  props.put(HeaderNames.X_MAX_TTL,""String_Node_Str"");
  props.put(HeaderNames.X_DYNAMIC_QUERY,""String_Node_Str"");
  if (ConnectionSettings.ACCEPT_DEFLATE.getValue())   props.put(HeaderNames.ACCEPT_ENCODING,HeaderNames.DEFLATE_VALUE);
  props.put(HeaderNames.X_PONG_CACHING,""String_Node_Str"");
  UpdateManager updateManager=UpdateManager.instance();
  String latestVersion=updateManager.getVersion();
  if (updateManager.isValid() && !latestVersion.equals(""String_Node_Str""))   props.put(HeaderNames.X_VERSION,latestVersion);
}","/** 
 * Writes the common headers -- headers that all LimeWires should send, like Query-Routing and User-Agent.
 */
private static void addCommonHeaders(Properties props){
  props.put(HeaderNames.X_QUERY_ROUTING,QUERY_ROUTING_VERSION);
  props.put(HeaderNames.USER_AGENT,CommonUtils.getHttpServer());
  props.put(HeaderNames.GGEP,""String_Node_Str"");
  props.put(HeaderNames.X_GUESS,""String_Node_Str"");
  props.put(HeaderNames.X_VENDOR_MESSAGE,""String_Node_Str"");
  props.put(HeaderNames.X_DEGREE,Integer.toString(ConnectionManager.ULTRAPEER_CONNECTIONS));
  props.put(HeaderNames.X_ULTRAPEER_QUERY_ROUTING,QUERY_ROUTING_VERSION);
  props.put(HeaderNames.X_MAX_TTL,""String_Node_Str"");
  props.put(HeaderNames.X_DYNAMIC_QUERY,""String_Node_Str"");
  props.put(HeaderNames.X_LOCALE_PREF,ApplicationSettings.LANGUAGE.getValue());
  if (ConnectionSettings.ACCEPT_DEFLATE.getValue())   props.put(HeaderNames.ACCEPT_ENCODING,HeaderNames.DEFLATE_VALUE);
  props.put(HeaderNames.X_PONG_CACHING,""String_Node_Str"");
  UpdateManager updateManager=UpdateManager.instance();
  String latestVersion=updateManager.getVersion();
  if (updateManager.isValid() && !latestVersion.equals(""String_Node_Str""))   props.put(HeaderNames.X_VERSION,latestVersion);
}",0.9665551839464884
4472,"/** 
 * Adds the ultrapeer GGEP extension to the pong.  This has the version of the Ultrapeer protocol that we support as well as the number of free leaf and Ultrapeer slots available.
 * @param ggep the <tt>GGEP</tt> instance to add the extension to
 */
private static void addUltrapeerExtension(GGEP ggep){
  byte[] payload=new byte[3];
  payload[0]=convertToGUESSFormat(CommonUtils.getUPMajorVersionNumber(),CommonUtils.getUPMinorVersionNumber());
  payload[1]=(byte)RouterService.getNumFreeLeafSlots();
  payload[2]=(byte)RouterService.getNumFreeNonLeafSlots();
  ggep.put(GGEP.GGEP_HEADER_UP_SUPPORT,payload);
}","/** 
 * Adds the ultrapeer GGEP extension to the pong.  This has the version of the Ultrapeer protocol that we support as well as the number of free leaf and Ultrapeer slots available.
 * @param ggep the <tt>GGEP</tt> instance to add the extension to
 */
private static void addUltrapeerExtension(GGEP ggep){
  byte[] payload=new byte[3];
  payload[0]=convertToGUESSFormat(CommonUtils.getUPMajorVersionNumber(),CommonUtils.getUPMinorVersionNumber());
  payload[1]=(byte)RouterService.getNumFreeLimeWireLeafSlots();
  payload[2]=(byte)RouterService.getNumFreeLimeWireNonLeafSlots();
  ggep.put(GGEP.GGEP_HEADER_UP_SUPPORT,payload);
}",0.9871794871794872
4473,"private void populateValues(Document doc){
  Element docElement=doc.getDocumentElement();
  NodeList children=docElement.getChildNodes();
  int len=children.getLength();
  for (int i=0; i < len; i++) {
    Node node=children.item(i);
    String name=node.getNodeName().toLowerCase().trim();
    if (name.equals(""String_Node_Str""))     newVersion=LimeXMLUtils.getText(node.getChildNodes());
 else     if (name.equals(""String_Node_Str""))     updateMessage=getLocaleSpecificMessage(node);
  }
}","private void populateValues(Document doc) throws IOException {
  Element docElement=doc.getDocumentElement();
  NodeList children=docElement.getChildNodes();
  int len=children.getLength();
  for (int i=0; i < len; i++) {
    Node node=children.item(i);
    String name=node.getNodeName().toLowerCase().trim();
    if (name.equals(""String_Node_Str""))     newVersion=LimeXMLUtils.getText(node.getChildNodes());
 else     if (name.equals(""String_Node_Str""))     updateMessage=getLocaleSpecificMessage(node);
 else     if (name.equals(""String_Node_Str"")) {
      try {
        timestamp=Long.parseLong(LimeXMLUtils.getText(node.getChildNodes()));
      }
 catch (      NumberFormatException nfx) {
        throw new IOException();
      }
    }
  }
}",0.7932148626817448
4474,"public UpdateFileParser(String xml) throws SAXException, IOException {
  if (xml == null || xml.equals(""String_Node_Str""))   throw new SAXException(""String_Node_Str"");
  InputSource inputSource=new InputSource(new StringReader(xml));
  Document d=null;
synchronized (this.parser) {
    parser.parse(inputSource);
    d=parser.getDocument();
  }
  if (d == null)   throw new SAXException(""String_Node_Str"");
  populateValues(d);
}","public UpdateFileParser(String xml) throws SAXException, IOException {
  if (xml == null || xml.equals(""String_Node_Str""))   throw new SAXException(""String_Node_Str"");
  timestamp=-1l;
  InputSource inputSource=new InputSource(new StringReader(xml));
  Document d=null;
synchronized (this.parser) {
    parser.parse(inputSource);
    d=parser.getDocument();
  }
  if (d == null)   throw new SAXException(""String_Node_Str"");
  populateValues(d);
}",0.9805714285714284
4475,"public void checkAndUpdate(Connection connection){
  String nv=connection.getVersion();
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + latestVersion + ""String_Node_Str""+ nv);
  String myVersion=null;
  if (latestVersion.equals(SPECIAL_VERSION))   myVersion=CommonUtils.getLimeWireVersion();
 else   myVersion=latestVersion;
  if (!isGreaterVersion(nv,myVersion))   return;
  if (nv.equals(SPECIAL_VERSION))   return;
  final Connection c=connection;
  final String myversion=myVersion;
  Thread checker=new ManagedThread(""String_Node_Str""){
    public void managedRun(){
      LOG.trace(""String_Node_Str"");
      final String UPDATE=""String_Node_Str"";
      String ip=c.getAddress();
      int port=c.getPort();
      String connectTo=""String_Node_Str"" + ip + ""String_Node_Str""+ port+ UPDATE;
      HttpMethod get=new GetMethod(connectTo);
      get.addRequestHeader(""String_Node_Str"",""String_Node_Str"");
      get.addRequestHeader(""String_Node_Str"",CommonUtils.getHttpServer());
      get.addRequestHeader(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
      HttpClient client=HttpClientManager.getNewClient();
      try {
        client.executeMethod(get);
        byte[] data=get.getResponseBody();
        if (data == null)         return;
        UpdateMessageVerifier verifier=new UpdateMessageVerifier(data,false);
        if (!verifier.verifySource())         return;
        LOG.trace(""String_Node_Str"");
        String xml=new String(verifier.getMessageBytes(),""String_Node_Str"");
        UpdateFileParser parser=new UpdateFileParser(xml);
        if (LOG.isTraceEnabled())         LOG.trace(""String_Node_Str"" + parser.getVersion());
        String newVersion=parser.getVersion();
        if (newVersion == null)         return;
        if (isGreaterVersion(newVersion,myversion)) {
          LOG.trace(""String_Node_Str"");
synchronized (UpdateManager.this) {
            commitVersionFile(data);
            latestVersion=newVersion;
            if (LOG.isTraceEnabled())             LOG.trace(""String_Node_Str"" + latestVersion);
          }
          String runningVersion=CommonUtils.getLimeWireVersion();
          if (!isGreaterVersion(newVersion,runningVersion))           return;
          RouterService.getCallback().indicateNewVersion();
        }
      }
 catch (      IOException iox) {
        return;
      }
catch (      SAXException sx) {
        return;
      }
catch (      Throwable t) {
        ErrorService.error(t);
      }
 finally {
        if (get != null)         get.releaseConnection();
      }
    }
  }
;
  checker.start();
}","public void checkAndUpdate(Connection connection){
  String nv=connection.getVersion();
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + latestVersion + ""String_Node_Str""+ nv);
  String myVersion=null;
  if (latestVersion.equals(SPECIAL_VERSION))   myVersion=CommonUtils.getLimeWireVersion();
 else   myVersion=latestVersion;
  if (!isGreaterVersion(nv,myVersion))   return;
  if (nv.equals(SPECIAL_VERSION))   return;
  final Connection c=connection;
  final String myversion=myVersion;
  Thread checker=new ManagedThread(""String_Node_Str""){
    public void managedRun(){
      LOG.trace(""String_Node_Str"");
      final String UPDATE=""String_Node_Str"";
      String ip=c.getAddress();
      int port=c.getPort();
      String connectTo=""String_Node_Str"" + ip + ""String_Node_Str""+ port+ UPDATE;
      HttpMethod get=new GetMethod(connectTo);
      get.addRequestHeader(""String_Node_Str"",""String_Node_Str"");
      get.addRequestHeader(""String_Node_Str"",CommonUtils.getHttpServer());
      get.addRequestHeader(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
      HttpClient client=HttpClientManager.getNewClient();
      try {
        client.executeMethod(get);
        byte[] data=get.getResponseBody();
        if (data == null)         return;
        UpdateMessageVerifier verifier=new UpdateMessageVerifier(data,false);
        if (!verifier.verifySource())         return;
        LOG.trace(""String_Node_Str"");
        String xml=new String(verifier.getMessageBytes(),""String_Node_Str"");
        UpdateFileParser parser=new UpdateFileParser(xml);
        if (LOG.isTraceEnabled())         LOG.trace(""String_Node_Str"" + parser.getVersion());
        String newVersion=parser.getVersion();
        if (newVersion == null)         return;
        if (isGreaterVersion(newVersion,myversion)) {
          LOG.trace(""String_Node_Str"");
synchronized (UpdateManager.this) {
            commitVersionFile(data);
            latestVersion=newVersion;
            if (LOG.isTraceEnabled())             LOG.trace(""String_Node_Str"" + latestVersion);
          }
          String runningVersion=CommonUtils.getLimeWireVersion();
          if (!isGreaterVersion(newVersion,runningVersion))           return;
          long makeTime=parser.getTimestamp();
          if (makeTime == -1)           makeTime=System.currentTimeMillis();
          if (System.currentTimeMillis() < makeTime + SEVEN_HOURS) {
            Random rand=new Random();
            long sleep=rand.nextLong() % SEVEN_HOURS;
            if (sleep < 0)             sleep=-1 * sleep;
            try {
              Thread.sleep(sleep);
            }
 catch (            InterruptedException ignored) {
            }
          }
          RouterService.getCallback().indicateNewVersion();
        }
      }
 catch (      IOException iox) {
        return;
      }
catch (      SAXException sx) {
        return;
      }
catch (      Throwable t) {
        ErrorService.error(t);
      }
 finally {
        if (get != null)         get.releaseConnection();
      }
    }
  }
;
  checker.setDaemon(true);
  checker.start();
}",0.9098245614035088
4476,"public void managedRun(){
  LOG.trace(""String_Node_Str"");
  final String UPDATE=""String_Node_Str"";
  String ip=c.getAddress();
  int port=c.getPort();
  String connectTo=""String_Node_Str"" + ip + ""String_Node_Str""+ port+ UPDATE;
  HttpMethod get=new GetMethod(connectTo);
  get.addRequestHeader(""String_Node_Str"",""String_Node_Str"");
  get.addRequestHeader(""String_Node_Str"",CommonUtils.getHttpServer());
  get.addRequestHeader(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
  HttpClient client=HttpClientManager.getNewClient();
  try {
    client.executeMethod(get);
    byte[] data=get.getResponseBody();
    if (data == null)     return;
    UpdateMessageVerifier verifier=new UpdateMessageVerifier(data,false);
    if (!verifier.verifySource())     return;
    LOG.trace(""String_Node_Str"");
    String xml=new String(verifier.getMessageBytes(),""String_Node_Str"");
    UpdateFileParser parser=new UpdateFileParser(xml);
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + parser.getVersion());
    String newVersion=parser.getVersion();
    if (newVersion == null)     return;
    if (isGreaterVersion(newVersion,myversion)) {
      LOG.trace(""String_Node_Str"");
synchronized (UpdateManager.this) {
        commitVersionFile(data);
        latestVersion=newVersion;
        if (LOG.isTraceEnabled())         LOG.trace(""String_Node_Str"" + latestVersion);
      }
      String runningVersion=CommonUtils.getLimeWireVersion();
      if (!isGreaterVersion(newVersion,runningVersion))       return;
      RouterService.getCallback().indicateNewVersion();
    }
  }
 catch (  IOException iox) {
    return;
  }
catch (  SAXException sx) {
    return;
  }
catch (  Throwable t) {
    ErrorService.error(t);
  }
 finally {
    if (get != null)     get.releaseConnection();
  }
}","public void managedRun(){
  LOG.trace(""String_Node_Str"");
  final String UPDATE=""String_Node_Str"";
  String ip=c.getAddress();
  int port=c.getPort();
  String connectTo=""String_Node_Str"" + ip + ""String_Node_Str""+ port+ UPDATE;
  HttpMethod get=new GetMethod(connectTo);
  get.addRequestHeader(""String_Node_Str"",""String_Node_Str"");
  get.addRequestHeader(""String_Node_Str"",CommonUtils.getHttpServer());
  get.addRequestHeader(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
  HttpClient client=HttpClientManager.getNewClient();
  try {
    client.executeMethod(get);
    byte[] data=get.getResponseBody();
    if (data == null)     return;
    UpdateMessageVerifier verifier=new UpdateMessageVerifier(data,false);
    if (!verifier.verifySource())     return;
    LOG.trace(""String_Node_Str"");
    String xml=new String(verifier.getMessageBytes(),""String_Node_Str"");
    UpdateFileParser parser=new UpdateFileParser(xml);
    if (LOG.isTraceEnabled())     LOG.trace(""String_Node_Str"" + parser.getVersion());
    String newVersion=parser.getVersion();
    if (newVersion == null)     return;
    if (isGreaterVersion(newVersion,myversion)) {
      LOG.trace(""String_Node_Str"");
synchronized (UpdateManager.this) {
        commitVersionFile(data);
        latestVersion=newVersion;
        if (LOG.isTraceEnabled())         LOG.trace(""String_Node_Str"" + latestVersion);
      }
      String runningVersion=CommonUtils.getLimeWireVersion();
      if (!isGreaterVersion(newVersion,runningVersion))       return;
      long makeTime=parser.getTimestamp();
      if (makeTime == -1)       makeTime=System.currentTimeMillis();
      if (System.currentTimeMillis() < makeTime + SEVEN_HOURS) {
        Random rand=new Random();
        long sleep=rand.nextLong() % SEVEN_HOURS;
        if (sleep < 0)         sleep=-1 * sleep;
        try {
          Thread.sleep(sleep);
        }
 catch (        InterruptedException ignored) {
        }
      }
      RouterService.getCallback().indicateNewVersion();
    }
  }
 catch (  IOException iox) {
    return;
  }
catch (  SAXException sx) {
    return;
  }
catch (  Throwable t) {
    ErrorService.error(t);
  }
 finally {
    if (get != null)     get.releaseConnection();
  }
}",0.8930786405358472
4477,"/** 
 * Ensures that that integrity of the hashes HashMap is valid. This must be done to ensure that older version of LimeWire are started with a valid hashes map.  Previously, entries added to the map were not canonicalized, resulting in multiple downloads thinking they're going to seperate files, but actually going to the same file.
 */
private Map verifyHashes(){
  Map retMap=new HashMap();
  for (Iterator i=hashes.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry entry=(Map.Entry)i.next();
    if (entry.getKey() instanceof URN && entry.getValue() instanceof File) {
      URN urn=(URN)entry.getKey();
      File f=(File)entry.getValue();
      try {
        f=FileUtils.getCanonicalFile(f);
      }
 catch (      IOException ioe) {
      }
      if (!retMap.values().contains(f))       retMap.put(urn,f);
    }
  }
  return retMap;
}","/** 
 * Ensures that that integrity of the hashes HashMap is valid. This must be done to ensure that older version of LimeWire are started with a valid hashes map.  Previously, entries added to the map were not canonicalized, resulting in multiple downloads thinking they're going to seperate files, but actually going to the same file.
 */
private Map verifyHashes(){
  Map retMap=new HashMap();
  for (Iterator i=hashes.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry entry=(Map.Entry)i.next();
    if (entry.getKey() instanceof URN && entry.getValue() instanceof File) {
      URN urn=(URN)entry.getKey();
      File f=(File)entry.getValue();
      try {
        f=FileUtils.getCanonicalFile(f);
        if (!retMap.values().contains(f))         retMap.put(urn,f);
      }
 catch (      IOException ioe) {
      }
    }
  }
  return retMap;
}",0.8963486454652533
4478,"/** 
 * Returns the fully-qualified temporary download file for the given file/location pair.  The location of the file is determined by the INCOMPLETE_DIRECTORY property.  For example, getFile(""test.txt"", 1999) may return ""C:\Program Files\LimeWire\Incomplete\T-1999-Test.txt"".  The disk is not modified.<p> This method gives duplicate files the same temporary file, which is critical for resume and swarmed downloads.  That is, for all rfd_i and  rfd_j <pre> similar(rfd_i, rfd_j) <==> getFile(rfd_i).equals(getFile(rfd_j))<p>   </pre> It is imperative that the files are compared as in their canonical formats to preserve the integrity of the filesystem.  Otherwise, multiple downloads could be downloading to ""FILE A"", and ""file a"", although only ""file a"" exists on disk and is being written to by both.
 */
public synchronized File getFile(RemoteFileDesc rfd){
  File incDir=SharingSettings.INCOMPLETE_DIRECTORY.getValue();
  incDir.mkdirs();
  String convertedName=CommonUtils.convertFileName(rfd.getFileName());
  URN sha1=rfd.getSHA1Urn();
  if (sha1 != null) {
    File file=(File)hashes.get(sha1);
    if (file != null) {
      return file;
    }
 else {
      for (int i=1; ; i++) {
        file=new File(incDir,tempName(convertedName,rfd.getSize(),i));
        try {
          file=FileUtils.getCanonicalFile(file);
        }
 catch (        IOException ignored) {
        }
        if (!hashes.values().contains(file))         break;
      }
      hashes.put(sha1,file);
      return file;
    }
  }
 else {
    File f=new File(incDir,tempName(convertedName,rfd.getSize(),0));
    try {
      f=FileUtils.getCanonicalFile(f);
    }
 catch (    IOException ignored) {
    }
    return f;
  }
}","/** 
 * Returns the fully-qualified temporary download file for the given file/location pair.  The location of the file is determined by the INCOMPLETE_DIRECTORY property.  For example, getFile(""test.txt"", 1999) may return ""C:\Program Files\LimeWire\Incomplete\T-1999-Test.txt"".  The disk is not modified.<p> This method gives duplicate files the same temporary file, which is critical for resume and swarmed downloads.  That is, for all rfd_i and  rfd_j <pre> similar(rfd_i, rfd_j) <==> getFile(rfd_i).equals(getFile(rfd_j))<p>   </pre> It is imperative that the files are compared as in their canonical formats to preserve the integrity of the filesystem.  Otherwise, multiple downloads could be downloading to ""FILE A"", and ""file a"", although only ""file a"" exists on disk and is being written to by both.
 * @throws IOException if there was an IOError while determining thefile's name.
 */
public synchronized File getFile(RemoteFileDesc rfd) throws IOException {
  File incDir=SharingSettings.INCOMPLETE_DIRECTORY.getValue();
  incDir.mkdirs();
  String convertedName=CommonUtils.convertFileName(rfd.getFileName());
  URN sha1=rfd.getSHA1Urn();
  if (sha1 != null) {
    File file=(File)hashes.get(sha1);
    if (file != null) {
      return file;
    }
 else {
      for (int i=1; ; i++) {
        file=new File(incDir,tempName(convertedName,rfd.getSize(),i));
        file=FileUtils.getCanonicalFile(file);
        if (!hashes.values().contains(file))         break;
      }
      hashes.put(sha1,file);
      return file;
    }
  }
 else {
    File f=new File(incDir,tempName(convertedName,rfd.getSize(),0));
    f=FileUtils.getCanonicalFile(f);
    return f;
  }
}",0.923304708320995
4479,"/** 
 * Takes a map of File->List<Interval> and returns a new equivalent Map of File->VerifyingFile
 */
private Map transform(Object object){
  Map map=(Map)object;
  Map retMap=new TreeMap(new FileComparator());
  for (Iterator i=map.keySet().iterator(); i.hasNext(); ) {
    Object incompleteFile=i.next();
    Object o=map.get(incompleteFile);
    if (o == null)     continue;
 else {
      Iterator iter=((List)o).iterator();
      VerifyingFile vf=new VerifyingFile(true);
      while (iter.hasNext()) {
        Interval interval=(Interval)iter.next();
        interval.high=interval.high - 1;
        if (interval.high >= interval.low)         vf.addInterval(interval);
      }
      if (incompleteFile instanceof File) {
        File f=(File)incompleteFile;
        try {
          f=FileUtils.getCanonicalFile(f);
        }
 catch (        IOException ignored) {
        }
        retMap.put(f,vf);
      }
    }
  }
  return retMap;
}","/** 
 * Takes a map of File->List<Interval> and returns a new equivalent Map of File->VerifyingFile
 */
private Map transform(Object object){
  Map map=(Map)object;
  Map retMap=new TreeMap(new FileComparator());
  for (Iterator i=map.keySet().iterator(); i.hasNext(); ) {
    Object incompleteFile=i.next();
    Object o=map.get(incompleteFile);
    if (o == null)     continue;
 else {
      Iterator iter=((List)o).iterator();
      VerifyingFile vf=new VerifyingFile(true);
      while (iter.hasNext()) {
        Interval interval=(Interval)iter.next();
        interval.high=interval.high - 1;
        if (interval.high >= interval.low)         vf.addInterval(interval);
      }
      if (incompleteFile instanceof File) {
        File f=(File)incompleteFile;
        try {
          f=FileUtils.getCanonicalFile(f);
          retMap.put(f,vf);
        }
 catch (        IOException ignored) {
        }
      }
    }
  }
  return retMap;
}",0.948093220338983
4480,"/** 
 * Associates the incompleteFile with the VerifyingFile vf. Notifies FileManager about a new Incomplete File.
 */
public synchronized void addEntry(File incompleteFile,VerifyingFile vf){
  boolean ioproblem=false;
  try {
    incompleteFile=FileUtils.getCanonicalFile(incompleteFile);
  }
 catch (  IOException ignored) {
    ioproblem=true;
  }
  blocks.put(incompleteFile,vf);
  if (!ioproblem)   registerIncompleteFile(incompleteFile);
}","/** 
 * Associates the incompleteFile with the VerifyingFile vf. Notifies FileManager about a new Incomplete File.
 */
public synchronized void addEntry(File incompleteFile,VerifyingFile vf) throws IOException {
  incompleteFile=FileUtils.getCanonicalFile(incompleteFile);
  blocks.put(incompleteFile,vf);
  registerIncompleteFile(incompleteFile);
}",0.7103274559193955
4481,"/** 
 * Tries one round of downloading of the given files.  Downloads from all locations until all locations fail or some locations succeed.  Moves incomplete file to the library on success.
 * @return COMPLETE if a file was successfully downloaded.  This canhappen even if the file is corrupt, if the user explicitly approved. CORRUPT_FILE a bytes mismatched when checking overlapping regions of resume or swarm, and the user decided they' did not want the download fragment, which is now quarantined. COULDNT_MOVE_TO_LIBRARY the download completed but the temporary file couldn't be moved to the library OR the download couldn't be written to the incomplete file WAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try.
 * @exception InterruptedException if the user stop()'ed this download. (Calls to resume() do not result in InterruptedException.)
 */
private int tryAllDownloads2() throws InterruptedException {
synchronized (this) {
    if (files.size() == 0)     return GAVE_UP;
  }
  incompleteFile=incompleteFileManager.getFile((RemoteFileDesc)files.get(0));
  File saveDir;
  String fileName=getFileName();
  try {
    saveDir=SharingSettings.getSaveDirectory();
    completeFile=new File(saveDir,fileName);
    String savePath=saveDir.getCanonicalPath();
    String completeFileParentPath=new File(completeFile.getParent()).getCanonicalPath();
    if (!savePath.equals(completeFileParentPath))     throw new InvalidPathException();
  }
 catch (  IOException e) {
    return COULDNT_MOVE_TO_LIBRARY;
  }
  URN sha1=buckets.getURNForBucket(bucketNumber);
  if (sha1 != null)   validAlts=AlternateLocationCollection.create(sha1);
  int status=-1;
  try {
    status=tryAllDownloads3();
  }
 catch (  InterruptedException e) {
  }
  commonOutFile.close();
  if (corruptState != NOT_CORRUPT_STATE) {
synchronized (corruptStateLock) {
      try {
        while (corruptState == CORRUPT_WAITING_STATE) {
          corruptStateLock.wait();
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
 else     if (corruptState == CORRUPT_CONTINUE_STATE) {
      ;
    }
  }
  if (status == -1)   throw new InterruptedException();
  if (status != COMPLETE)   return status;
  URN bucketHash=buckets.getURNForBucket(bucketNumber);
  URN fileHash=null;
  try {
    setState(HASHING);
    fileHash=URN.createSHA1Urn(incompleteFile);
  }
 catch (  IOException ignored) {
  }
  if (bucketHash != null) {
synchronized (corruptStateLock) {
      if (!bucketHash.equals(fileHash)) {
        setState(CORRUPT_FILE);
        promptAboutCorruptDownload();
        if (LOG.isWarnEnabled())         LOG.warn(""String_Node_Str"" + fileHash + ""String_Node_Str""+ bucketHash);
      }
      try {
        while (corruptState == CORRUPT_WAITING_STATE)         corruptStateLock.wait();
      }
 catch (      InterruptedException ignored2) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
  }
  setState(SAVING);
  File completeFileDir=FileUtils.getParentFile(completeFile);
  FileUtils.setWriteable(completeFileDir);
  FileUtils.setWriteable(completeFile);
  completeFile.delete();
  boolean success=incompleteFile.renameTo(completeFile);
  if (!success) {
    FileDesc fd=RouterService.getFileManager().getFileDescForFile(incompleteFile);
    if (fd != null) {
      UploadManager upMan=RouterService.getUploadManager();
synchronized (upMan) {
        if (upMan.killUploadsForFileDesc(fd))         success=incompleteFile.renameTo(completeFile);
      }
    }
  }
  if (!success)   success=CommonUtils.copy(incompleteFile,completeFile);
  if (!success)   return COULDNT_MOVE_TO_LIBRARY;
  incompleteFileManager.removeEntry(incompleteFile);
  if (fileExists(completeFile))   fileManager.removeFileIfShared(completeFile);
  if (fileHash != null) {
    Set urns=new HashSet(1);
    urns.add(fileHash);
    File file=completeFile;
    try {
      file=FileUtils.getCanonicalFile(completeFile);
    }
 catch (    IOException ignored) {
    }
    if (fileManager.isFileInSharedDirectories(file))     UrnCache.instance().addUrns(file,urns);
  }
  FileDesc fileDesc=fileManager.addFileIfShared(completeFile,getXMLDocuments());
  if (validAlts != null && fileDesc != null && fileDesc.getSHA1Urn().equals(validAlts.getSHA1Urn())) {
    LOG.trace(""String_Node_Str"");
    addLocationsToFile(validAlts,fileDesc);
    callback.handleSharedFileUpdate(completeFile);
    HashSet set=null;
synchronized (this) {
      set=new HashSet(files);
    }
    if (fileDesc.getSize() < HTTPDownloader.MIN_PARTIAL_FILE_BYTES || !UploadSettings.ALLOW_PARTIAL_SHARING.getValue()) {
      LOG.trace(""String_Node_Str"");
      HeadRequester requester=new HeadRequester(set,fileHash,fileDesc,fileDesc.getAlternateLocationCollection());
      Thread headThread=new Thread(requester,""String_Node_Str"");
      headThread.setDaemon(true);
      headThread.start();
    }
  }
  return COMPLETE;
}","/** 
 * Tries one round of downloading of the given files.  Downloads from all locations until all locations fail or some locations succeed.  Moves incomplete file to the library on success.
 * @return COMPLETE if a file was successfully downloaded.  This canhappen even if the file is corrupt, if the user explicitly approved. CORRUPT_FILE a bytes mismatched when checking overlapping regions of resume or swarm, and the user decided they' did not want the download fragment, which is now quarantined. COULDNT_MOVE_TO_LIBRARY the download completed but the temporary file couldn't be moved to the library OR the download couldn't be written to the incomplete file WAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try.
 * @exception InterruptedException if the user stop()'ed this download. (Calls to resume() do not result in InterruptedException.)
 */
private int tryAllDownloads2() throws InterruptedException {
synchronized (this) {
    if (files.size() == 0)     return GAVE_UP;
  }
  File saveDir;
  String fileName=getFileName();
  try {
    incompleteFile=incompleteFileManager.getFile((RemoteFileDesc)files.get(0));
    saveDir=SharingSettings.getSaveDirectory();
    completeFile=new File(saveDir,fileName);
    String savePath=saveDir.getCanonicalPath();
    String completeFileParentPath=new File(completeFile.getParent()).getCanonicalPath();
    if (!savePath.equals(completeFileParentPath))     return COULDNT_MOVE_TO_LIBRARY;
  }
 catch (  IOException e) {
    ErrorService.error(e,""String_Node_Str"" + incompleteFile);
    return COULDNT_MOVE_TO_LIBRARY;
  }
  URN sha1=buckets.getURNForBucket(bucketNumber);
  if (sha1 != null)   validAlts=AlternateLocationCollection.create(sha1);
  int status=-1;
  try {
    status=tryAllDownloads3();
  }
 catch (  InterruptedException e) {
  }
  commonOutFile.close();
  if (corruptState != NOT_CORRUPT_STATE) {
synchronized (corruptStateLock) {
      try {
        while (corruptState == CORRUPT_WAITING_STATE) {
          corruptStateLock.wait();
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
 else     if (corruptState == CORRUPT_CONTINUE_STATE) {
      ;
    }
  }
  if (status == -1)   throw new InterruptedException();
  if (status != COMPLETE)   return status;
  URN bucketHash=buckets.getURNForBucket(bucketNumber);
  URN fileHash=null;
  try {
    setState(HASHING);
    fileHash=URN.createSHA1Urn(incompleteFile);
  }
 catch (  IOException ignored) {
  }
  if (bucketHash != null) {
synchronized (corruptStateLock) {
      if (!bucketHash.equals(fileHash)) {
        setState(CORRUPT_FILE);
        promptAboutCorruptDownload();
        if (LOG.isWarnEnabled())         LOG.warn(""String_Node_Str"" + fileHash + ""String_Node_Str""+ bucketHash);
      }
      try {
        while (corruptState == CORRUPT_WAITING_STATE)         corruptStateLock.wait();
      }
 catch (      InterruptedException ignored2) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
  }
  setState(SAVING);
  File completeFileDir=FileUtils.getParentFile(completeFile);
  FileUtils.setWriteable(completeFileDir);
  FileUtils.setWriteable(completeFile);
  completeFile.delete();
  boolean success=incompleteFile.renameTo(completeFile);
  if (!success) {
    FileDesc fd=RouterService.getFileManager().getFileDescForFile(incompleteFile);
    if (fd != null) {
      UploadManager upMan=RouterService.getUploadManager();
synchronized (upMan) {
        if (upMan.killUploadsForFileDesc(fd))         success=incompleteFile.renameTo(completeFile);
      }
    }
  }
  if (!success)   success=CommonUtils.copy(incompleteFile,completeFile);
  if (!success)   return COULDNT_MOVE_TO_LIBRARY;
  incompleteFileManager.removeEntry(incompleteFile);
  if (fileExists(completeFile))   fileManager.removeFileIfShared(completeFile);
  if (fileHash != null) {
    Set urns=new HashSet(1);
    urns.add(fileHash);
    File file=completeFile;
    try {
      file=FileUtils.getCanonicalFile(completeFile);
    }
 catch (    IOException ignored) {
    }
    if (fileManager.isFileInSharedDirectories(file))     UrnCache.instance().addUrns(file,urns);
  }
  FileDesc fileDesc=fileManager.addFileIfShared(completeFile,getXMLDocuments());
  if (validAlts != null && fileDesc != null && fileDesc.getSHA1Urn().equals(validAlts.getSHA1Urn())) {
    LOG.trace(""String_Node_Str"");
    addLocationsToFile(validAlts,fileDesc);
    callback.handleSharedFileUpdate(completeFile);
    HashSet set=null;
synchronized (this) {
      set=new HashSet(files);
    }
    if (fileDesc.getSize() < HTTPDownloader.MIN_PARTIAL_FILE_BYTES || !UploadSettings.ALLOW_PARTIAL_SHARING.getValue()) {
      LOG.trace(""String_Node_Str"");
      HeadRequester requester=new HeadRequester(set,fileHash,fileDesc,fileDesc.getAlternateLocationCollection());
      Thread headThread=new Thread(requester,""String_Node_Str"");
      headThread.setDaemon(true);
      headThread.start();
    }
  }
  return COMPLETE;
}",0.5466842006387376
4482,"/** 
 * Like tryDownloads2, but does not deal with the library, cleaning up corrupt files, etc.  Caller should look at corruptState to determine if the file is corrupted; a return value of COMPLETE does not mean no corruptions where encountered.
 * @return COMPLETE if a file was successfully downloadedWAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try. COULDNT_MOVE_TO_LIBRARY couldn't write the incomplete file
 * @exception InterruptedException if the someone stop()'ed this download.stop() was called either because the user killed the download or a corruption was detected and they chose to kill and discard the download.  Calls to resume() do not result in InterruptedException.
 */
private int tryAllDownloads3() throws InterruptedException {
  LOG.trace(""String_Node_Str"");
  int completedSize=-1;
synchronized (this) {
    needed=new IntervalSet();
{
      Assert.that(incompleteFile != null);
synchronized (incompleteFileManager) {
        if (commonOutFile != null)         commonOutFile.clearManagedDownloader();
        commonOutFile=incompleteFileManager.getEntry(incompleteFile);
      }
      if (commonOutFile == null) {
        LOG.trace(""String_Node_Str"");
        commonOutFile=new VerifyingFile(true);
        incompleteFileManager.addEntry(incompleteFile,commonOutFile);
{
          FileDesc fd=fileManager.getFileDescForFile(incompleteFile);
          URN bHash=buckets.getURNForBucket(bucketNumber);
          if (bHash != null && fd != null && !bHash.equals(fd.getSHA1Urn())) {
            File canon=null;
            Exception ioe=null;
            try {
              canon=FileUtils.getCanonicalFile(incompleteFile);
            }
 catch (            IOException e) {
              ioe=e;
            }
            Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + bHash + ""String_Node_Str""+ ""String_Node_Str""+ fd.getSHA1Urn()+ ""String_Node_Str""+ ""String_Node_Str""+ incompleteFile+ ""String_Node_Str""+ ""String_Node_Str""+ fd.getFile()+ ""String_Node_Str""+ ""String_Node_Str""+ canon+ ""String_Node_Str""+ ""String_Node_Str""+ (ioe == null ? ""String_Node_Str"" : ioe.getMessage())+ ""String_Node_Str""+ ""String_Node_Str""+ incompleteFileManager.dumpHashes());
            fileManager.removeFileIfShared(incompleteFile);
          }
        }
      }
      try {
        commonOutFile.open(incompleteFile,this);
      }
 catch (      IOException e) {
        if (StringUtils.contains(e.getMessage(),""String_Node_Str"",true)) {
          MessageService.showMessage(""String_Node_Str"");
        }
 else {
          ErrorService.error(e);
        }
        return COULDNT_MOVE_TO_LIBRARY;
      }
      completedSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
      Iterator iter=commonOutFile.getFreeBlocks(completedSize);
      while (iter.hasNext())       addToNeeded((Interval)iter.next());
    }
  }
  currentRFDs=new LinkedList();
  int size=-1;
  int connectTo=-1;
  int dloadsCount=-1;
  Assert.that(threads.size() == 0);
  while (true) {
synchronized (stealLock) {
synchronized (this) {
        if (stopped) {
          LOG.warn(""String_Node_Str"");
          throw new InterruptedException();
        }
        if (dloaders.size() == 0 && needed.isEmpty()) {
          int doneSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
          Assert.that(completedSize == doneSize,""String_Node_Str"");
          Iterator freeBlocks=commonOutFile.getFreeBlocks(doneSize);
          if (freeBlocks.hasNext()) {
            while (freeBlocks.hasNext())             addToNeeded((Interval)freeBlocks.next());
            Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + needed);
          }
 else {
            for (int i=threads.size(); i > 0; i--) {
              Thread t=(Thread)threads.get(i - 1);
              t.interrupt();
            }
            LOG.trace(""String_Node_Str"");
            return COMPLETE;
          }
        }
        if (threads.size() == 0) {
          if (files.size() > 0 && calculateWaitTime() > 0) {
            LOG.trace(""String_Node_Str"");
            return WAITING_FOR_RETRY;
          }
 else           if (files.size() == 0) {
            LOG.trace(""String_Node_Str"");
            return GAVE_UP;
          }
        }
        size=files.size();
        connectTo=getNumAllowedDownloads();
        dloadsCount=dloaders.size();
      }
    }
    for (int i=0; i < (connectTo + 1) && i < size && dloadsCount < getSwarmCapacity(); i++) {
      final RemoteFileDesc rfd;
synchronized (this) {
        rfd=removeBest(files);
        if (rfd.isBusy()) {
          files.add(rfd);
          break;
        }
        currentRFDs.add(rfd);
      }
      Thread connectCreator=new Thread(""String_Node_Str""){
        public void run(){
          boolean iterate=false;
          try {
            iterate=connectAndDownload(rfd);
          }
 catch (          Throwable e) {
            iterate=true;
            if (!(e instanceof InterruptedException)) {
              ErrorService.error(e);
            }
          }
 finally {
synchronized (ManagedDownloader.this) {
              currentRFDs.remove(rfd);
              threads.remove(this);
              if (iterate)               ManagedDownloader.this.notifyAll();
            }
          }
        }
      }
;
synchronized (this) {
        threads.add(connectCreator);
      }
      connectCreator.start();
    }
synchronized (this) {
      try {
        this.wait(4000);
      }
 catch (      InterruptedException ee) {
      }
    }
  }
}","/** 
 * Like tryDownloads2, but does not deal with the library, cleaning up corrupt files, etc.  Caller should look at corruptState to determine if the file is corrupted; a return value of COMPLETE does not mean no corruptions where encountered.
 * @return COMPLETE if a file was successfully downloadedWAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try. COULDNT_MOVE_TO_LIBRARY couldn't write the incomplete file
 * @exception InterruptedException if the someone stop()'ed this download.stop() was called either because the user killed the download or a corruption was detected and they chose to kill and discard the download.  Calls to resume() do not result in InterruptedException.
 */
private int tryAllDownloads3() throws InterruptedException {
  LOG.trace(""String_Node_Str"");
  int completedSize=-1;
synchronized (this) {
    needed=new IntervalSet();
{
      Assert.that(incompleteFile != null);
synchronized (incompleteFileManager) {
        if (commonOutFile != null)         commonOutFile.clearManagedDownloader();
        commonOutFile=incompleteFileManager.getEntry(incompleteFile);
      }
      if (commonOutFile == null) {
        LOG.trace(""String_Node_Str"");
        commonOutFile=new VerifyingFile(true);
        try {
          incompleteFileManager.addEntry(incompleteFile,commonOutFile);
        }
 catch (        IOException ioe) {
          ErrorService.error(ioe,""String_Node_Str"" + incompleteFile);
          return COULDNT_MOVE_TO_LIBRARY;
        }
{
          FileDesc fd=fileManager.getFileDescForFile(incompleteFile);
          URN bHash=buckets.getURNForBucket(bucketNumber);
          if (bHash != null && fd != null && !bHash.equals(fd.getSHA1Urn())) {
            File canon=null;
            Exception ioe=null;
            try {
              canon=FileUtils.getCanonicalFile(incompleteFile);
            }
 catch (            IOException e) {
              ioe=e;
            }
            Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + this.getClass().getName() + ""String_Node_Str""+ ""String_Node_Str""+ bHash+ ""String_Node_Str""+ ""String_Node_Str""+ fd.getSHA1Urn()+ ""String_Node_Str""+ ""String_Node_Str""+ incompleteFile+ ""String_Node_Str""+ ""String_Node_Str""+ fd.getFile()+ ""String_Node_Str""+ ""String_Node_Str""+ canon+ ""String_Node_Str""+ ""String_Node_Str""+ (ioe == null ? ""String_Node_Str"" : ioe.getMessage())+ ""String_Node_Str""+ ""String_Node_Str""+ incompleteFileManager.dumpHashes());
            fileManager.removeFileIfShared(incompleteFile);
          }
        }
      }
      try {
        commonOutFile.open(incompleteFile,this);
      }
 catch (      IOException e) {
        if (StringUtils.contains(e.getMessage(),""String_Node_Str"",true)) {
          MessageService.showMessage(""String_Node_Str"");
        }
 else {
          ErrorService.error(e);
        }
        return COULDNT_MOVE_TO_LIBRARY;
      }
      completedSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
      Iterator iter=commonOutFile.getFreeBlocks(completedSize);
      while (iter.hasNext())       addToNeeded((Interval)iter.next());
    }
  }
  currentRFDs=new LinkedList();
  int size=-1;
  int connectTo=-1;
  int dloadsCount=-1;
  Assert.that(threads.size() == 0);
  while (true) {
synchronized (stealLock) {
synchronized (this) {
        if (stopped) {
          LOG.warn(""String_Node_Str"");
          throw new InterruptedException();
        }
        if (dloaders.size() == 0 && needed.isEmpty()) {
          int doneSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
          Assert.that(completedSize == doneSize,""String_Node_Str"");
          Iterator freeBlocks=commonOutFile.getFreeBlocks(doneSize);
          if (freeBlocks.hasNext()) {
            while (freeBlocks.hasNext())             addToNeeded((Interval)freeBlocks.next());
            Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + needed);
          }
 else {
            for (int i=threads.size(); i > 0; i--) {
              Thread t=(Thread)threads.get(i - 1);
              t.interrupt();
            }
            LOG.trace(""String_Node_Str"");
            return COMPLETE;
          }
        }
        if (threads.size() == 0) {
          if (files.size() > 0 && calculateWaitTime() > 0) {
            LOG.trace(""String_Node_Str"");
            return WAITING_FOR_RETRY;
          }
 else           if (files.size() == 0) {
            LOG.trace(""String_Node_Str"");
            return GAVE_UP;
          }
        }
        size=files.size();
        connectTo=getNumAllowedDownloads();
        dloadsCount=dloaders.size();
      }
    }
    for (int i=0; i < (connectTo + 1) && i < size && dloadsCount < getSwarmCapacity(); i++) {
      final RemoteFileDesc rfd;
synchronized (this) {
        rfd=removeBest(files);
        if (rfd.isBusy()) {
          files.add(rfd);
          break;
        }
        currentRFDs.add(rfd);
      }
      Thread connectCreator=new Thread(""String_Node_Str""){
        public void run(){
          boolean iterate=false;
          try {
            iterate=connectAndDownload(rfd);
          }
 catch (          Throwable e) {
            iterate=true;
            if (!(e instanceof InterruptedException)) {
              ErrorService.error(e);
            }
          }
 finally {
synchronized (ManagedDownloader.this) {
              currentRFDs.remove(rfd);
              threads.remove(this);
              if (iterate)               ManagedDownloader.this.notifyAll();
            }
          }
        }
      }
;
synchronized (this) {
        threads.add(connectCreator);
      }
      connectCreator.start();
    }
synchronized (this) {
      try {
        this.wait(4000);
      }
 catch (      InterruptedException ee) {
      }
    }
  }
}",0.9784742552092304
4483,"/** 
 * Adds the given rfd to this, modifying an existing bucket or adding a new bucket as needed.
 * @param rfd the RemoteFileDesc to add to a specific bucket
 * @param checkExisting whether or not we should iterate over the elementsin the specific bucket and add if the RFD doesn't already exist.
 * @return 1 if added to an existing bucket, 0 if added to anew bucket, -1 if not added.
 * @see buckets 
 */
synchronized int add(RemoteFileDesc rfd,boolean checkExisting){
  repOk();
  File incompleteFile=incompleteFileManager.getFile(rfd);
  int n=buckets.size();
  Assert.that(incompletes.size() == n,""String_Node_Str"" + n + ""String_Node_Str""+ incompletes.size());
  for (int i=0; i < n; i++) {
    File otherIncompleteFile=(File)incompletes.get(i);
    if (otherIncompleteFile.equals(incompleteFile) && hashEquals(rfd.getSHA1Urn(),sha1s[i])) {
      if (sha1s[i] == null && rfd.getSHA1Urn() != null)       sha1s[i]=rfd.getSHA1Urn();
      List bucket=(List)buckets.get(i);
      if (checkExisting && bucket.contains(rfd))       return -1;
      if (bucket.size() > MAX_BUCKET_SIZE)       return -1;
      bucket.add(rfd);
      repOk();
      return 1;
    }
  }
  List bucket=new ArrayList();
  bucket.add(rfd);
  buckets.add(bucket);
  incompletes.add(incompleteFile);
  int p=incompletes.size();
  URN[] newArray=new URN[p];
  System.arraycopy(sha1s,0,newArray,0,sha1s.length);
  newArray[p - 1]=rfd.getSHA1Urn();
  sha1s=newArray;
  repOk();
  return 0;
}","/** 
 * Adds the given rfd to this, modifying an existing bucket or adding a new bucket as needed.
 * @param rfd the RemoteFileDesc to add to a specific bucket
 * @param checkExisting whether or not we should iterate over the elementsin the specific bucket and add if the RFD doesn't already exist.
 * @return 1 if added to an existing bucket, 0 if added to anew bucket, -1 if not added.
 * @see buckets 
 */
synchronized int add(RemoteFileDesc rfd,boolean checkExisting){
  repOk();
  File incompleteFile=null;
  try {
    incompleteFile=incompleteFileManager.getFile(rfd);
  }
 catch (  IOException ioe) {
    return -1;
  }
  int n=buckets.size();
  Assert.that(incompletes.size() == n,""String_Node_Str"" + n + ""String_Node_Str""+ incompletes.size());
  for (int i=0; i < n; i++) {
    File otherIncompleteFile=(File)incompletes.get(i);
    if (otherIncompleteFile.equals(incompleteFile) && hashEquals(rfd.getSHA1Urn(),sha1s[i])) {
      if (sha1s[i] == null && rfd.getSHA1Urn() != null)       sha1s[i]=rfd.getSHA1Urn();
      List bucket=(List)buckets.get(i);
      if (checkExisting && bucket.contains(rfd))       return -1;
      if (bucket.size() > MAX_BUCKET_SIZE)       return -1;
      bucket.add(rfd);
      repOk();
      return 1;
    }
  }
  List bucket=new ArrayList();
  bucket.add(rfd);
  buckets.add(bucket);
  incompletes.add(incompleteFile);
  int p=incompletes.size();
  URN[] newArray=new URN[p];
  System.arraycopy(sha1s,0,newArray,0,sha1s.length);
  newArray[p - 1]=rfd.getSHA1Urn();
  sha1s=newArray;
  repOk();
  return 0;
}",0.9717701760212554
4484,"/** 
 * Checks internal consistency.  Slow. 
 */
protected void repOk(){
  if (!DEBUG)   return;
  Assert.that(buckets.size() == incompletes.size());
  Assert.that(buckets.size() == sha1s.length);
  for (int i=0; i < buckets.size(); i++) {
    List bucket=(List)buckets.get(i);
    File tmp1=(File)incompletes.get(i);
    for (int j=0; j < bucket.size(); j++) {
      File tmp2=incompleteFileManager.getFile((RemoteFileDesc)bucket.get(j));
      Assert.that(tmp1.equals(tmp2));
    }
  }
  for (int i=0; i < buckets.size(); i++) {
    List bucket=(List)buckets.get(i);
    URN urn1=sha1s[i];
    for (int j=0; j < bucket.size(); j++) {
      URN urn2=((RemoteFileDesc)bucket.get(j)).getSHA1Urn();
      if (urn2 != null) {
        Assert.that(urn1 != null);
        Assert.that(urn1.equals(urn2));
      }
    }
  }
}","/** 
 * Checks internal consistency.  Slow. 
 */
protected void repOk(){
  if (!DEBUG)   return;
  Assert.that(buckets.size() == incompletes.size());
  Assert.that(buckets.size() == sha1s.length);
  for (int i=0; i < buckets.size(); i++) {
    List bucket=(List)buckets.get(i);
    File tmp1=(File)incompletes.get(i);
    for (int j=0; j < bucket.size(); j++) {
      try {
        File tmp2=incompleteFileManager.getFile((RemoteFileDesc)bucket.get(j));
        Assert.that(tmp1.equals(tmp2));
      }
 catch (      IOException ioe) {
        Assert.that(false,ioe.getMessage());
      }
    }
  }
  for (int i=0; i < buckets.size(); i++) {
    List bucket=(List)buckets.get(i);
    URN urn1=sha1s[i];
    for (int j=0; j < bucket.size(); j++) {
      URN urn2=((RemoteFileDesc)bucket.get(j)).getSHA1Urn();
      if (urn2 != null) {
        Assert.that(urn1 != null);
        Assert.that(urn1.equals(urn2));
      }
    }
  }
}",0.9369266055045872
4485,"/** 
 * Different name or size ==> different temp file 
 */
public void testGetFile_DifferentSize(){
  rfd1=newRFD(""String_Node_Str"",1839,null);
  rfd2=newRFD(""String_Node_Str"",1223,null);
  assertTrue(!IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertNotEquals(tmp2,tmp1);
}","/** 
 * Different name or size ==> different temp file 
 */
public void testGetFile_DifferentSize() throws Throwable {
  rfd1=newRFD(""String_Node_Str"",1839,null);
  rfd2=newRFD(""String_Node_Str"",1223,null);
  assertTrue(!IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertNotEquals(tmp2,tmp1);
}",0.9739130434782608
4486,"/** 
 * Risky resumes are allowed: no hashes 
 */
public void testGetFile_NoHash(){
  rfd1=newRFD(""String_Node_Str"",1839,null);
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  assertTrue(IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertEquals(tmp1,tmp2);
}","/** 
 * Risky resumes are allowed: no hashes 
 */
public void testGetFile_NoHash() throws Throwable {
  rfd1=newRFD(""String_Node_Str"",1839,null);
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  assertTrue(IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertEquals(tmp1,tmp2);
}",0.973293768545994
4487,"public void testCompletedSize(){
  File tmp1=new File(""String_Node_Str"");
  assertEquals(1839,ifm.getCompletedSize(tmp1));
}","public void testCompletedSize() throws Throwable {
  File tmp1=new File(""String_Node_Str"");
  assertEquals(1839,ifm.getCompletedSize(tmp1));
}",0.9323308270676692
4488,"public void testCompletedName_IllegalArgument(){
  try {
    ifm.getCompletedName(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
  try {
    ifm.getCompletedName(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
  try {
    ifm.getCompletedName(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
}","public void testCompletedName_IllegalArgument() throws Throwable {
  try {
    ifm.getCompletedName(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
  try {
    ifm.getCompletedName(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
  try {
    ifm.getCompletedName(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
}",0.9815573770491804
4489,"/** 
 * You should NOT be able to resume to file w/ same name but different hash.
 */
public void testGetFile_SameNameDifferentHash(){
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  assertTrue(!IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertNotEquals(tmp2,tmp1);
}","/** 
 * You should NOT be able to resume to file w/ same name but different hash.
 */
public void testGetFile_SameNameDifferentHash() throws Throwable {
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  assertTrue(!IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertNotEquals(tmp2,tmp1);
}",0.9777777777777776
4490,"/** 
 * Checks that removeEntry clears blocks AND hashes. 
 */
public void testRemoveEntry(){
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File tmp1=ifm.getFile(rfd1);
  VerifyingFile vf=new VerifyingFile(true);
  ifm.addEntry(tmp1,vf);
  ifm.removeEntry(tmp1);
  assertNull(ifm.getEntry(tmp1));
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File tmp2=ifm.getFile(rfd2);
  assertEquals(tmp1,tmp2);
  assertEquals(tmp2,ifm.getFile(newRFD(""String_Node_Str"",1839,null)));
}","/** 
 * Checks that removeEntry clears blocks AND hashes. 
 */
public void testRemoveEntry() throws Throwable {
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File tmp1=ifm.getFile(rfd1);
  VerifyingFile vf=new VerifyingFile(true);
  ifm.addEntry(tmp1,vf);
  ifm.removeEntry(tmp1);
  assertNull(ifm.getEntry(tmp1));
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File tmp2=ifm.getFile(rfd2);
  assertEquals(tmp1,tmp2);
  assertEquals(tmp2,ifm.getFile(newRFD(""String_Node_Str"",1839,null)));
}",0.982213438735178
4491,"public void testCompletedHash_NotFound(){
  File tmp2=new File(""String_Node_Str"");
  assertNull(ifm.getCompletedHash(tmp2));
}","public void testCompletedHash_NotFound() throws Throwable {
  File tmp2=new File(""String_Node_Str"");
  assertNull(ifm.getCompletedHash(tmp2));
}",0.9333333333333332
4492,"public void testCompletedSize_IllegalArgument(){
  try {
    ifm.getCompletedSize(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
  try {
    ifm.getCompletedSize(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
  try {
    ifm.getCompletedSize(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
  try {
    ifm.getCompletedSize(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
}","public void testCompletedSize_IllegalArgument() throws Throwable {
  try {
    ifm.getCompletedSize(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
  try {
    ifm.getCompletedSize(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
  try {
    ifm.getCompletedSize(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
  try {
    ifm.getCompletedSize(new File(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException pass) {
  }
}",0.9857369255150554
4493,"/** 
 * Tests that hash information is not purged when calling purge(false). 
 */
public void testPurgeHash_No(){
  RemoteFileDesc rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  RemoteFileDesc rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File file1=ifm.getFile(rfd1);
  File file2=ifm.getFile(rfd2);
  assertEquals(file1,file2);
  ifm.purge(false);
  File file2b=ifm.getFile(rfd2);
  assertEquals(file2,file2b);
}","/** 
 * Tests that hash information is not purged when calling purge(false). 
 */
public void testPurgeHash_No() throws Throwable {
  RemoteFileDesc rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  RemoteFileDesc rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File file1=ifm.getFile(rfd1);
  File file2=ifm.getFile(rfd2);
  assertEquals(file1,file2);
  ifm.purge(false);
  File file2b=ifm.getFile(rfd2);
  assertEquals(file2,file2b);
}",0.9797297297297296
4494,"public void testCompletedName(){
  File tmp1=new File(""String_Node_Str"");
  assertEquals(""String_Node_Str"",ifm.getCompletedName(tmp1));
}","public void testCompletedName() throws Throwable {
  File tmp1=new File(""String_Node_Str"");
  assertEquals(""String_Node_Str"",ifm.getCompletedName(tmp1));
}",0.9383561643835616
4495,"public void testCompletedHash_Found(){
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File tmp1=ifm.getFile(rfd1);
  try {
    URN urn=URN.createSHA1Urn(""String_Node_Str"");
    assertEquals(urn,ifm.getCompletedHash(tmp1));
  }
 catch (  IOException e) {
    fail(""String_Node_Str"",e);
  }
}","public void testCompletedHash_Found() throws Throwable {
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File tmp1=ifm.getFile(rfd1);
  try {
    URN urn=URN.createSHA1Urn(""String_Node_Str"");
    assertEquals(urn,ifm.getCompletedHash(tmp1));
  }
 catch (  IOException e) {
    fail(""String_Node_Str"",e);
  }
}",0.9710610932475884
4496,"/** 
 * You should be able to resume to a file with same hash but different name.
 */
public void testGetFile_DifferentNameSameHash(){
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  assertTrue(IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertEquals(tmp1,tmp2);
}","/** 
 * You should be able to resume to a file with same hash but different name.
 */
public void testGetFile_DifferentNameSameHash() throws Throwable {
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  assertTrue(IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertEquals(tmp1,tmp2);
}",0.9775561097256856
4497,"/** 
 * Tests that hash information is purged when calling purge(true). 
 */
public void testPurgeHash_Yes(){
  RemoteFileDesc rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  RemoteFileDesc rfd1b=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File file1=ifm.getFile(rfd1);
  File file1b=ifm.getFile(rfd1b);
  assertEquals(file1,file1b);
  RemoteFileDesc rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  RemoteFileDesc rfd2b=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File file2=ifm.getFile(rfd2);
  File file2b=ifm.getFile(rfd2b);
  assertEquals(file2,file2b);
  try {
    file2.createNewFile();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + file2,e);
  }
  ifm.purge(true);
  File file1c=ifm.getFile(rfd1b);
  assertNotEquals(file1b,file1c);
  File file2c=ifm.getFile(rfd2b);
  assertEquals(file2b,file2c);
  file2.delete();
}","/** 
 * Tests that hash information is purged when calling purge(true). 
 */
public void testPurgeHash_Yes() throws Throwable {
  RemoteFileDesc rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  RemoteFileDesc rfd1b=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File file1=ifm.getFile(rfd1);
  File file1b=ifm.getFile(rfd1b);
  assertEquals(file1,file1b);
  RemoteFileDesc rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  RemoteFileDesc rfd2b=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File file2=ifm.getFile(rfd2);
  File file2b=ifm.getFile(rfd2b);
  assertEquals(file2,file2b);
  try {
    file2.createNewFile();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + file2,e);
  }
  ifm.purge(true);
  File file1c=ifm.getFile(rfd1b);
  assertNotEquals(file1b,file1c);
  File file2c=ifm.getFile(rfd2b);
  assertEquals(file2b,file2c);
  file2.delete();
}",0.9897843359818388
4498,"public void testLegacy(){
  RemoteFileDescGrouper grouper=null;
  RemoteFileDesc[] allFiles=null;
  Iterator iter=null;
  List list=null;
  allFiles=new RemoteFileDesc[]{rf3,rf2,rf1,rf4};
  grouper=new RemoteFileDescGrouper(allFiles,ifm);
  iter=grouper.buckets();
  list=(List)iter.next();
  assertEquals(2,list.size());
  assertTrue(list.contains(rf1));
  assertTrue(list.contains(rf2));
  list=(List)iter.next();
  assertEquals(2,list.size());
  assertTrue(list.contains(rf3));
  assertTrue(list.contains(rf4));
  assertTrue(!iter.hasNext());
  allFiles=new RemoteFileDesc[]{rf3};
  grouper=new RemoteFileDescGrouper(allFiles,ifm);
  iter=grouper.buckets();
  assertEquals(1,grouper.add(rf4,false));
  list=(List)iter.next();
  assertEquals(2,list.size());
  assertTrue(list.contains(rf3));
  assertTrue(list.contains(rf4));
  allFiles=new RemoteFileDesc[]{rf3};
  grouper=new RemoteFileDescGrouper(allFiles,ifm);
  iter=grouper.buckets();
  list=(List)iter.next();
  assertEquals(1,list.size());
  assertTrue(list.contains(rf3));
  assertEquals(0,grouper.add(rf1,false));
  list=(List)iter.next();
  assertEquals(1,list.size());
  assertTrue(list.contains(rf1));
  VerifyingFile vf=new VerifyingFile(false);
  vf.addInterval(new Interval(0,1008));
  ifm.addEntry(ifm.getFile(rf3),vf);
  allFiles=new RemoteFileDesc[]{rf3,rf2,rf1,rf4};
  grouper=new RemoteFileDescGrouper(allFiles,ifm);
  iter=grouper.buckets();
  list=(List)iter.next();
  assertEquals(2,list.size());
  assertTrue(list.contains(rf3));
  assertTrue(list.contains(rf4));
  list=(List)iter.next();
  assertEquals(2,list.size());
  assertTrue(list.contains(rf1));
  assertTrue(list.contains(rf2));
  assertTrue(!iter.hasNext());
  allFiles=new RemoteFileDesc[]{rf3};
  grouper=new RemoteFileDescGrouper(allFiles,ifm);
  iter=grouper.buckets();
  list=(List)iter.next();
  assertEquals(1,list.size());
  assertTrue(list.contains(rf3));
  list.remove(rf3);
  assertEquals(0,list.size());
  assertEquals(1,grouper.add(rf4,false));
  assertEquals(1,list.size());
  assertTrue(list.contains(rf4));
}","public void testLegacy() throws Throwable {
  RemoteFileDescGrouper grouper=null;
  RemoteFileDesc[] allFiles=null;
  Iterator iter=null;
  List list=null;
  allFiles=new RemoteFileDesc[]{rf3,rf2,rf1,rf4};
  grouper=new RemoteFileDescGrouper(allFiles,ifm);
  iter=grouper.buckets();
  list=(List)iter.next();
  assertEquals(2,list.size());
  assertTrue(list.contains(rf1));
  assertTrue(list.contains(rf2));
  list=(List)iter.next();
  assertEquals(2,list.size());
  assertTrue(list.contains(rf3));
  assertTrue(list.contains(rf4));
  assertTrue(!iter.hasNext());
  allFiles=new RemoteFileDesc[]{rf3};
  grouper=new RemoteFileDescGrouper(allFiles,ifm);
  iter=grouper.buckets();
  assertEquals(1,grouper.add(rf4,false));
  list=(List)iter.next();
  assertEquals(2,list.size());
  assertTrue(list.contains(rf3));
  assertTrue(list.contains(rf4));
  allFiles=new RemoteFileDesc[]{rf3};
  grouper=new RemoteFileDescGrouper(allFiles,ifm);
  iter=grouper.buckets();
  list=(List)iter.next();
  assertEquals(1,list.size());
  assertTrue(list.contains(rf3));
  assertEquals(0,grouper.add(rf1,false));
  list=(List)iter.next();
  assertEquals(1,list.size());
  assertTrue(list.contains(rf1));
  VerifyingFile vf=new VerifyingFile(false);
  vf.addInterval(new Interval(0,1008));
  ifm.addEntry(ifm.getFile(rf3),vf);
  allFiles=new RemoteFileDesc[]{rf3,rf2,rf1,rf4};
  grouper=new RemoteFileDescGrouper(allFiles,ifm);
  iter=grouper.buckets();
  list=(List)iter.next();
  assertEquals(2,list.size());
  assertTrue(list.contains(rf3));
  assertTrue(list.contains(rf4));
  list=(List)iter.next();
  assertEquals(2,list.size());
  assertTrue(list.contains(rf1));
  assertTrue(list.contains(rf2));
  assertTrue(!iter.hasNext());
  allFiles=new RemoteFileDesc[]{rf3};
  grouper=new RemoteFileDescGrouper(allFiles,ifm);
  iter=grouper.buckets();
  list=(List)iter.next();
  assertEquals(1,list.size());
  assertTrue(list.contains(rf3));
  list.remove(rf3);
  assertEquals(0,list.size());
  assertEquals(1,grouper.add(rf4,false));
  assertEquals(1,list.size());
  assertTrue(list.contains(rf4));
}",0.9956542732979236
4499,"public static void globalSetUp() throws Exception {
  new RouterService(new ActivityCallbackStub());
  VerifyingFile vf=new VerifyingFile(false);
  vf.addInterval(new Interval(0,amountDownloaded - 1));
  ifm.addEntry(incompleteFile,vf);
  ManagedDownloader.NO_DELAY=true;
}","public static void globalSetUp() throws Exception {
  new RouterService(new ActivityCallbackStub());
  incompleteFile=ifm.getFile(rfd);
  VerifyingFile vf=new VerifyingFile(false);
  vf.addInterval(new Interval(0,amountDownloaded - 1));
  ifm.addEntry(incompleteFile,vf);
  ManagedDownloader.NO_DELAY=true;
}",0.9397590361445785
4500,"public boolean verifySource(){
  parse();
  if (CommonUtils.isMacClassic())   return true;
  PublicKey pubKey=null;
  FileInputStream fis=null;
  ObjectInputStream ois=null;
  try {
    File file=new File(CommonUtils.getUserSettingsDir(),""String_Node_Str"");
    fis=new FileInputStream(file);
    ois=new ObjectInputStream(fis);
    pubKey=(PublicKey)ois.readObject();
  }
 catch (  ClassNotFoundException cnfx) {
    return false;
  }
catch (  IOException iox) {
    return false;
  }
 finally {
    if (ois != null) {
      try {
        ois.close();
      }
 catch (      IOException e) {
      }
    }
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
      }
    }
  }
  try {
    Signature verifier=Signature.getInstance(""String_Node_Str"");
    verifier.initVerify(pubKey);
    verifier.update(xmlMessage,0,xmlMessage.length);
    return verifier.verify(signature);
  }
 catch (  NoSuchAlgorithmException nsax) {
    ErrorService.error(nsax);
    return false;
  }
catch (  InvalidKeyException ikx) {
    return false;
  }
catch (  SignatureException sx) {
    return false;
  }
}","public boolean verifySource(){
  parse();
  if (CommonUtils.isJava118())   return true;
  PublicKey pubKey=null;
  FileInputStream fis=null;
  ObjectInputStream ois=null;
  try {
    File file=new File(CommonUtils.getUserSettingsDir(),""String_Node_Str"");
    fis=new FileInputStream(file);
    ois=new ObjectInputStream(fis);
    pubKey=(PublicKey)ois.readObject();
  }
 catch (  ClassNotFoundException cnfx) {
    return false;
  }
catch (  IOException iox) {
    return false;
  }
 finally {
    if (ois != null) {
      try {
        ois.close();
      }
 catch (      IOException e) {
      }
    }
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
      }
    }
  }
  try {
    Signature verifier=Signature.getInstance(""String_Node_Str"");
    verifier.initVerify(pubKey);
    verifier.update(xmlMessage,0,xmlMessage.length);
    return verifier.verify(signature);
  }
 catch (  NoSuchAlgorithmException nsax) {
    ErrorService.error(nsax);
    return false;
  }
catch (  InvalidKeyException ikx) {
    return false;
  }
catch (  SignatureException sx) {
    return false;
  }
}",0.9924745462594068
4501,"/** 
 * Associates the incompleteFile with the VerifyingFile vf. Notifies FileManager about a new Incomplete File.
 */
public synchronized void addEntry(File incompleteFile,VerifyingFile vf){
  try {
    incompleteFile=FileUtils.getCanonicalFile(incompleteFile);
  }
 catch (  IOException ignored) {
  }
  blocks.put(incompleteFile,vf);
  registerIncompleteFile(incompleteFile);
}","/** 
 * Associates the incompleteFile with the VerifyingFile vf. Notifies FileManager about a new Incomplete File.
 */
public synchronized void addEntry(File incompleteFile,VerifyingFile vf){
  boolean ioproblem=false;
  try {
    incompleteFile=FileUtils.getCanonicalFile(incompleteFile);
  }
 catch (  IOException ignored) {
    ioproblem=true;
  }
  blocks.put(incompleteFile,vf);
  if (!ioproblem)   registerIncompleteFile(incompleteFile);
}",0.9212121212121211
4502,"/** 
 * Like tryDownloads2, but does not deal with the library, cleaning up corrupt files, etc.  Caller should look at corruptState to determine if the file is corrupted; a return value of COMPLETE does not mean no corruptions where encountered.
 * @return COMPLETE if a file was successfully downloadedWAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try. COULDNT_MOVE_TO_LIBRARY couldn't write the incomplete file
 * @exception InterruptedException if the someone stop()'ed this download.stop() was called either because the user killed the download or a corruption was detected and they chose to kill and discard the download.  Calls to resume() do not result in InterruptedException.
 */
private int tryAllDownloads3() throws InterruptedException {
  LOG.trace(""String_Node_Str"");
  int completedSize=-1;
synchronized (this) {
    needed=new IntervalSet();
{
      Assert.that(incompleteFile != null);
synchronized (incompleteFileManager) {
        if (commonOutFile != null)         commonOutFile.clearManagedDownloader();
        commonOutFile=incompleteFileManager.getEntry(incompleteFile);
      }
      if (commonOutFile == null) {
        LOG.trace(""String_Node_Str"");
        commonOutFile=new VerifyingFile(true);
        incompleteFileManager.addEntry(incompleteFile,commonOutFile);
{
          FileDesc fd=fileManager.getFileDescForFile(incompleteFile);
          URN bHash=buckets.getURNForBucket(bucketNumber);
          if (bHash != null && fd != null && !bHash.equals(fd.getSHA1Urn())) {
            Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + bHash + ""String_Node_Str""+ ""String_Node_Str""+ fd.getSHA1Urn()+ ""String_Node_Str""+ ""String_Node_Str""+ incompleteFile+ ""String_Node_Str""+ ""String_Node_Str""+ fd.getFile()+ ""String_Node_Str""+ ""String_Node_Str""+ incompleteFileManager.dumpHashes());
            fileManager.removeFileIfShared(incompleteFile);
          }
        }
      }
      try {
        commonOutFile.open(incompleteFile,this);
      }
 catch (      IOException e) {
        if (StringUtils.contains(e.getMessage(),""String_Node_Str"",true)) {
          MessageService.showMessage(""String_Node_Str"");
        }
 else {
          ErrorService.error(e);
        }
        return COULDNT_MOVE_TO_LIBRARY;
      }
      completedSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
      Iterator iter=commonOutFile.getFreeBlocks(completedSize);
      while (iter.hasNext())       addToNeeded((Interval)iter.next());
    }
  }
  currentRFDs=new LinkedList();
  int size=-1;
  int connectTo=-1;
  int dloadsCount=-1;
  Assert.that(threads.size() == 0);
  while (true) {
synchronized (stealLock) {
synchronized (this) {
        if (stopped) {
          LOG.warn(""String_Node_Str"");
          throw new InterruptedException();
        }
        if (dloaders.size() == 0 && needed.isEmpty()) {
          int doneSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
          Assert.that(completedSize == doneSize,""String_Node_Str"");
          Iterator freeBlocks=commonOutFile.getFreeBlocks(doneSize);
          if (freeBlocks.hasNext()) {
            while (freeBlocks.hasNext())             addToNeeded((Interval)freeBlocks.next());
            Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + needed);
          }
 else {
            for (int i=threads.size(); i > 0; i--) {
              Thread t=(Thread)threads.get(i - 1);
              t.interrupt();
            }
            LOG.trace(""String_Node_Str"");
            return COMPLETE;
          }
        }
        if (threads.size() == 0) {
          if (files.size() > 0 && calculateWaitTime() > 0) {
            LOG.trace(""String_Node_Str"");
            return WAITING_FOR_RETRY;
          }
 else           if (files.size() == 0) {
            LOG.trace(""String_Node_Str"");
            return GAVE_UP;
          }
        }
        size=files.size();
        connectTo=getNumAllowedDownloads();
        dloadsCount=dloaders.size();
      }
    }
    for (int i=0; i < (connectTo + 1) && i < size && dloadsCount < getSwarmCapacity(); i++) {
      final RemoteFileDesc rfd;
synchronized (this) {
        rfd=removeBest(files);
        if (rfd.isBusy()) {
          files.add(rfd);
          break;
        }
        currentRFDs.add(rfd);
      }
      Thread connectCreator=new Thread(""String_Node_Str""){
        public void run(){
          boolean iterate=false;
          try {
            iterate=connectAndDownload(rfd);
          }
 catch (          Throwable e) {
            iterate=true;
            if (!(e instanceof InterruptedException)) {
              ErrorService.error(e);
            }
          }
 finally {
synchronized (ManagedDownloader.this) {
              currentRFDs.remove(rfd);
              threads.remove(this);
              if (iterate)               ManagedDownloader.this.notifyAll();
            }
          }
        }
      }
;
synchronized (this) {
        threads.add(connectCreator);
      }
      connectCreator.start();
    }
synchronized (this) {
      try {
        this.wait(4000);
      }
 catch (      InterruptedException ee) {
      }
    }
  }
}","/** 
 * Like tryDownloads2, but does not deal with the library, cleaning up corrupt files, etc.  Caller should look at corruptState to determine if the file is corrupted; a return value of COMPLETE does not mean no corruptions where encountered.
 * @return COMPLETE if a file was successfully downloadedWAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try. COULDNT_MOVE_TO_LIBRARY couldn't write the incomplete file
 * @exception InterruptedException if the someone stop()'ed this download.stop() was called either because the user killed the download or a corruption was detected and they chose to kill and discard the download.  Calls to resume() do not result in InterruptedException.
 */
private int tryAllDownloads3() throws InterruptedException {
  LOG.trace(""String_Node_Str"");
  int completedSize=-1;
synchronized (this) {
    needed=new IntervalSet();
{
      Assert.that(incompleteFile != null);
synchronized (incompleteFileManager) {
        if (commonOutFile != null)         commonOutFile.clearManagedDownloader();
        commonOutFile=incompleteFileManager.getEntry(incompleteFile);
      }
      if (commonOutFile == null) {
        LOG.trace(""String_Node_Str"");
        commonOutFile=new VerifyingFile(true);
        incompleteFileManager.addEntry(incompleteFile,commonOutFile);
{
          FileDesc fd=fileManager.getFileDescForFile(incompleteFile);
          URN bHash=buckets.getURNForBucket(bucketNumber);
          if (bHash != null && fd != null && !bHash.equals(fd.getSHA1Urn())) {
            File canon=null;
            Exception ioe=null;
            try {
              canon=FileUtils.getCanonicalFile(incompleteFile);
            }
 catch (            IOException e) {
              ioe=e;
            }
            Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + bHash + ""String_Node_Str""+ ""String_Node_Str""+ fd.getSHA1Urn()+ ""String_Node_Str""+ ""String_Node_Str""+ incompleteFile+ ""String_Node_Str""+ ""String_Node_Str""+ fd.getFile()+ ""String_Node_Str""+ ""String_Node_Str""+ canon+ ""String_Node_Str""+ ""String_Node_Str""+ (ioe == null ? ""String_Node_Str"" : ioe.getMessage())+ ""String_Node_Str""+ incompleteFileManager.dumpHashes());
            fileManager.removeFileIfShared(incompleteFile);
          }
        }
      }
      try {
        commonOutFile.open(incompleteFile,this);
      }
 catch (      IOException e) {
        if (StringUtils.contains(e.getMessage(),""String_Node_Str"",true)) {
          MessageService.showMessage(""String_Node_Str"");
        }
 else {
          ErrorService.error(e);
        }
        return COULDNT_MOVE_TO_LIBRARY;
      }
      completedSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
      Iterator iter=commonOutFile.getFreeBlocks(completedSize);
      while (iter.hasNext())       addToNeeded((Interval)iter.next());
    }
  }
  currentRFDs=new LinkedList();
  int size=-1;
  int connectTo=-1;
  int dloadsCount=-1;
  Assert.that(threads.size() == 0);
  while (true) {
synchronized (stealLock) {
synchronized (this) {
        if (stopped) {
          LOG.warn(""String_Node_Str"");
          throw new InterruptedException();
        }
        if (dloaders.size() == 0 && needed.isEmpty()) {
          int doneSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
          Assert.that(completedSize == doneSize,""String_Node_Str"");
          Iterator freeBlocks=commonOutFile.getFreeBlocks(doneSize);
          if (freeBlocks.hasNext()) {
            while (freeBlocks.hasNext())             addToNeeded((Interval)freeBlocks.next());
            Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + needed);
          }
 else {
            for (int i=threads.size(); i > 0; i--) {
              Thread t=(Thread)threads.get(i - 1);
              t.interrupt();
            }
            LOG.trace(""String_Node_Str"");
            return COMPLETE;
          }
        }
        if (threads.size() == 0) {
          if (files.size() > 0 && calculateWaitTime() > 0) {
            LOG.trace(""String_Node_Str"");
            return WAITING_FOR_RETRY;
          }
 else           if (files.size() == 0) {
            LOG.trace(""String_Node_Str"");
            return GAVE_UP;
          }
        }
        size=files.size();
        connectTo=getNumAllowedDownloads();
        dloadsCount=dloaders.size();
      }
    }
    for (int i=0; i < (connectTo + 1) && i < size && dloadsCount < getSwarmCapacity(); i++) {
      final RemoteFileDesc rfd;
synchronized (this) {
        rfd=removeBest(files);
        if (rfd.isBusy()) {
          files.add(rfd);
          break;
        }
        currentRFDs.add(rfd);
      }
      Thread connectCreator=new Thread(""String_Node_Str""){
        public void run(){
          boolean iterate=false;
          try {
            iterate=connectAndDownload(rfd);
          }
 catch (          Throwable e) {
            iterate=true;
            if (!(e instanceof InterruptedException)) {
              ErrorService.error(e);
            }
          }
 finally {
synchronized (ManagedDownloader.this) {
              currentRFDs.remove(rfd);
              threads.remove(this);
              if (iterate)               ManagedDownloader.this.notifyAll();
            }
          }
        }
      }
;
synchronized (this) {
        threads.add(connectCreator);
      }
      connectCreator.start();
    }
synchronized (this) {
      try {
        this.wait(4000);
      }
 catch (      InterruptedException ee) {
      }
    }
  }
}",0.968399963573445
4503,"/** 
 * Assigns a white area or a grey area to a downloader. Sets the state, and checks if this downloader has been interrupted.
 * @param dloader The downloader to which this method assigns eithera grey area or white area.
 * @param refQueueInfo this parameter is used for pass by reference, thismethod puts the minPollTime as the 0th element of this array, and the remote queue postion of the downloader in the 1st element
 * @return 0 if (the server is not giving us the file)TryAgainLater, FileNotFound, NotSharing, Stopped, Misc IOE otherwise if queued return 1 otherwise if connected successfully return 2 otherwise if NoSuchElement( we have no areas to steal) return 3 otherwise if rfd was partial uploader and gave us ranges to try return 4 
 */
private int assignAndRequest(HTTPDownloader dloader,int[] refQueueInfo,boolean http11){
synchronized (stealLock) {
    RemoteFileDesc rfd=dloader.getRemoteFileDesc();
    boolean updateNeeded=true;
    try {
      if (!needed.isEmpty()) {
        assignWhite(dloader,http11);
      }
 else {
        updateNeeded=false;
        assignGrey(dloader,http11);
      }
      updateNeeded=false;
    }
 catch (    NoSuchElementException nsex) {
      if (RECORD_STATS)       DownloadStat.NSE_EXCEPTION.incrementStat();
      Assert.that(updateNeeded == false,""String_Node_Str"");
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,nsex);
synchronized (this) {
        files.add(rfd);
      }
      return 3;
    }
catch (    NoSuchRangeException nsrx) {
      if (RECORD_STATS)       DownloadStat.NSR_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,nsrx);
synchronized (this) {
        rfd.setAvailableRanges(null);
        if (!rfd.isBusy())         rfd.setRetryAfter(NO_RANGES_RETRY_AFTER);
        files.add(rfd);
      }
      rfd.resetFailedCount();
      return 0;
    }
catch (    TryAgainLaterException talx) {
      if (RECORD_STATS)       DownloadStat.TAL_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,talx);
      if (!rfd.isBusy()) {
        rfd.setRetryAfter(RETRY_AFTER_NONE_ACTIVE);
      }
synchronized (this) {
        if (dloaders.size() > 0 && rfd.getWaitTime() < RETRY_AFTER_SOME_ACTIVE)         rfd.setRetryAfter(RETRY_AFTER_SOME_ACTIVE);
        files.add(rfd);
      }
      rfd.resetFailedCount();
      return 0;
    }
catch (    RangeNotAvailableException rnae) {
      if (RECORD_STATS)       DownloadStat.RNA_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,rnae);
      rfd.resetFailedCount();
      informMesh(rfd,true);
      return 4;
    }
catch (    FileNotFoundException fnfx) {
      if (RECORD_STATS)       DownloadStat.FNF_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,fnfx);
      informMesh(rfd,false);
      return 0;
    }
catch (    NotSharingException nsx) {
      if (RECORD_STATS)       DownloadStat.NS_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,nsx);
      informMesh(rfd,false);
      return 0;
    }
catch (    QueuedException qx) {
      if (RECORD_STATS)       DownloadStat.Q_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,qx);
      refQueueInfo[0]=qx.getMinPollTime() * 1000 + 1000;
      refQueueInfo[1]=qx.getQueuePosition();
synchronized (this) {
        if (dloaders.size() == 0) {
          setState(REMOTE_QUEUED);
        }
        int oldPos=queuePosition.equals(""String_Node_Str"") ? Integer.MAX_VALUE : Integer.parseInt(queuePosition);
        int newPos=qx.getQueuePosition();
        if (newPos < oldPos) {
          queuePosition=""String_Node_Str"" + newPos;
          queuedVendor=dloader.getVendor();
        }
      }
      rfd.resetFailedCount();
      return 1;
    }
catch (    ProblemReadingHeaderException prhe) {
      if (RECORD_STATS)       DownloadStat.PRH_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,prhe);
      informMesh(rfd,false);
      return 0;
    }
catch (    UnknownCodeException uce) {
      if (RECORD_STATS)       DownloadStat.UNKNOWN_CODE_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + uce.getCode() + ""String_Node_Str""+ dloader,uce);
      informMesh(rfd,false);
      return 0;
    }
catch (    IOException iox) {
      if (RECORD_STATS)       DownloadStat.IO_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,iox);
      rfd.incrementFailedCount();
      if (rfd.getFailedCount() < 2) {
        rfd.setRetryAfter(FAILED_RETRY_AFTER);
synchronized (this) {
          files.add(rfd);
        }
      }
 else       informMesh(rfd,false);
      return 0;
    }
 finally {
      AlternateLocationCollection c=dloader.getAltLocsReceived();
      if (c != null) {
synchronized (c) {
          Iterator iter=c.iterator();
          while (iter.hasNext()) {
            AlternateLocation al=(AlternateLocation)iter.next();
            RemoteFileDesc rfd1=al.createRemoteFileDesc(rfd.getSize());
            addDownload(rfd1,false);
          }
        }
      }
      if (updateNeeded)       updateNeeded(dloader);
    }
    if (RECORD_STATS && rfd.getFailedCount() > 0)     DownloadStat.RETRIED_SUCCESS.incrementStat();
    rfd.resetFailedCount();
synchronized (this) {
      setState(DOWNLOADING);
    }
    if (stopped) {
      LOG.trace(""String_Node_Str"");
      updateNeeded(dloader);
synchronized (this) {
        files.add(rfd);
      }
      return 0;
    }
synchronized (this) {
      if (!dloaders.contains(dloader))       dloaders.add(dloader);
      chatList.addHost(dloader);
      browseList.addHost(dloader);
    }
    if (RECORD_STATS)     DownloadStat.RESPONSE_OK.incrementStat();
    return 2;
  }
}","/** 
 * Assigns a white area or a grey area to a downloader. Sets the state, and checks if this downloader has been interrupted.
 * @param dloader The downloader to which this method assigns eithera grey area or white area.
 * @param refQueueInfo this parameter is used for pass by reference, thismethod puts the minPollTime as the 0th element of this array, and the remote queue postion of the downloader in the 1st element
 * @return 0 if (the server is not giving us the file)TryAgainLater, FileNotFound, NotSharing, Stopped, Misc IOE otherwise if queued return 1 otherwise if connected successfully return 2 otherwise if NoSuchElement( we have no areas to steal) return 3 otherwise if rfd was partial uploader and gave us ranges to try return 4 
 */
private int assignAndRequest(HTTPDownloader dloader,int[] refQueueInfo,boolean http11){
synchronized (stealLock) {
    RemoteFileDesc rfd=dloader.getRemoteFileDesc();
    boolean updateNeeded=true;
    boolean shouldAssignWhite=false;
synchronized (this) {
      shouldAssignWhite=!needed.isEmpty();
    }
    try {
      if (shouldAssignWhite) {
        assignWhite(dloader,http11);
      }
 else {
        updateNeeded=false;
        assignGrey(dloader,http11);
      }
      updateNeeded=false;
    }
 catch (    NoSuchElementException nsex) {
      if (RECORD_STATS)       DownloadStat.NSE_EXCEPTION.incrementStat();
      Assert.that(updateNeeded == false,""String_Node_Str"");
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,nsex);
synchronized (this) {
        files.add(rfd);
      }
      return 3;
    }
catch (    NoSuchRangeException nsrx) {
      if (RECORD_STATS)       DownloadStat.NSR_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,nsrx);
synchronized (this) {
        rfd.setAvailableRanges(null);
        if (!rfd.isBusy())         rfd.setRetryAfter(NO_RANGES_RETRY_AFTER);
        files.add(rfd);
      }
      rfd.resetFailedCount();
      return 0;
    }
catch (    TryAgainLaterException talx) {
      if (RECORD_STATS)       DownloadStat.TAL_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,talx);
      if (!rfd.isBusy()) {
        rfd.setRetryAfter(RETRY_AFTER_NONE_ACTIVE);
      }
synchronized (this) {
        if (dloaders.size() > 0 && rfd.getWaitTime() < RETRY_AFTER_SOME_ACTIVE)         rfd.setRetryAfter(RETRY_AFTER_SOME_ACTIVE);
        files.add(rfd);
      }
      rfd.resetFailedCount();
      return 0;
    }
catch (    RangeNotAvailableException rnae) {
      if (RECORD_STATS)       DownloadStat.RNA_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,rnae);
      rfd.resetFailedCount();
      informMesh(rfd,true);
      return 4;
    }
catch (    FileNotFoundException fnfx) {
      if (RECORD_STATS)       DownloadStat.FNF_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,fnfx);
      informMesh(rfd,false);
      return 0;
    }
catch (    NotSharingException nsx) {
      if (RECORD_STATS)       DownloadStat.NS_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,nsx);
      informMesh(rfd,false);
      return 0;
    }
catch (    QueuedException qx) {
      if (RECORD_STATS)       DownloadStat.Q_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,qx);
      refQueueInfo[0]=qx.getMinPollTime() * 1000 + 1000;
      refQueueInfo[1]=qx.getQueuePosition();
synchronized (this) {
        if (dloaders.size() == 0) {
          setState(REMOTE_QUEUED);
        }
        int oldPos=queuePosition.equals(""String_Node_Str"") ? Integer.MAX_VALUE : Integer.parseInt(queuePosition);
        int newPos=qx.getQueuePosition();
        if (newPos < oldPos) {
          queuePosition=""String_Node_Str"" + newPos;
          queuedVendor=dloader.getVendor();
        }
      }
      rfd.resetFailedCount();
      return 1;
    }
catch (    ProblemReadingHeaderException prhe) {
      if (RECORD_STATS)       DownloadStat.PRH_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,prhe);
      informMesh(rfd,false);
      return 0;
    }
catch (    UnknownCodeException uce) {
      if (RECORD_STATS)       DownloadStat.UNKNOWN_CODE_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + uce.getCode() + ""String_Node_Str""+ dloader,uce);
      informMesh(rfd,false);
      return 0;
    }
catch (    IOException iox) {
      if (RECORD_STATS)       DownloadStat.IO_EXCEPTION.incrementStat();
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + dloader,iox);
      rfd.incrementFailedCount();
      if (rfd.getFailedCount() < 2) {
        rfd.setRetryAfter(FAILED_RETRY_AFTER);
synchronized (this) {
          files.add(rfd);
        }
      }
 else       informMesh(rfd,false);
      return 0;
    }
 finally {
      AlternateLocationCollection c=dloader.getAltLocsReceived();
      if (c != null) {
synchronized (c) {
          Iterator iter=c.iterator();
          while (iter.hasNext()) {
            AlternateLocation al=(AlternateLocation)iter.next();
            RemoteFileDesc rfd1=al.createRemoteFileDesc(rfd.getSize());
            addDownload(rfd1,false);
          }
        }
      }
      if (updateNeeded)       updateNeeded(dloader);
    }
    if (RECORD_STATS && rfd.getFailedCount() > 0)     DownloadStat.RETRIED_SUCCESS.incrementStat();
    rfd.resetFailedCount();
synchronized (this) {
      setState(DOWNLOADING);
    }
    if (stopped) {
      LOG.trace(""String_Node_Str"");
synchronized (this) {
        updateNeeded(dloader);
        files.add(rfd);
      }
      return 0;
    }
synchronized (this) {
      if (!dloaders.contains(dloader))       dloaders.add(dloader);
      chatList.addHost(dloader);
      browseList.addHost(dloader);
    }
    if (RECORD_STATS)     DownloadStat.RESPONSE_OK.incrementStat();
    return 2;
  }
}",0.9862309223623092
4504,"/** 
 * Changes the DatagramSocket used for sending/receiving.  Typically called by Acceptor to commit to the new port.
 * @param datagramSocket the new listening socket, which must be be thereturn value of newListeningSocket(int).  A value of null disables  UDP sending and receiving.
 */
void setListeningSocket(DatagramSocket datagramSocket){
  if (_socket != null)   _socket.close();
synchronized (_receiveLock) {
synchronized (_sendLock) {
      _socket=(DatagramSocket)datagramSocket;
      _receiveLock.notify();
      _sendLock.notify();
    }
  }
}","/** 
 * Changes the DatagramSocket used for sending/receiving.  Typically called by Acceptor to commit to the new port.
 * @param datagramSocket the new listening socket, which must be be thereturn value of newListeningSocket(int).  A value of null disables  UDP sending and receiving.
 */
void setListeningSocket(DatagramSocket datagramSocket){
  if (_socket != null)   _socket.close();
synchronized (_receiveLock) {
synchronized (_sendLock) {
      if (_socket == null)       _socketSetOnce=true;
      _socket=(DatagramSocket)datagramSocket;
      _receiveLock.notify();
      _sendLock.notify();
    }
  }
}",0.9537671232876712
4505,"public void run(){
  boolean hasReportedNullSocket=false;
  SendBundle currBundle=null;
  while (true) {
synchronized (PACKETS_TO_SEND) {
      while (PACKETS_TO_SEND.isEmpty()) {
        try {
          PACKETS_TO_SEND.wait();
        }
 catch (        InterruptedException ignored) {
        }
      }
      currBundle=(SendBundle)PACKETS_TO_SEND.remove(0);
    }
synchronized (_sendLock) {
      if (_socket == null) {
        if (!hasReportedNullSocket) {
          hasReportedNullSocket=true;
          Exception npe=new NullPointerException(""String_Node_Str"");
          ErrorService.error(npe);
        }
        continue;
      }
      try {
        _socket.send(currBundle._dp);
      }
 catch (      BindException be) {
      }
catch (      NoRouteToHostException nrthe) {
      }
catch (      IOException ioe) {
        if (isIgnoreable(ioe.getMessage()))         return;
        String errString=""String_Node_Str"" + currBundle._dp.getAddress() + ""String_Node_Str""+ currBundle._dp.getPort();
        currBundle._err.error(ioe,errString);
      }
    }
  }
}","public void run(){
  SendBundle currBundle=null;
  while (true) {
synchronized (PACKETS_TO_SEND) {
      while (PACKETS_TO_SEND.isEmpty()) {
        try {
          PACKETS_TO_SEND.wait();
        }
 catch (        InterruptedException ignored) {
        }
      }
      currBundle=(SendBundle)PACKETS_TO_SEND.remove(0);
    }
synchronized (_sendLock) {
      if (_socket == null) {
        if (_socketSetOnce) {
          Exception npe=new NullPointerException(""String_Node_Str"");
          ErrorService.error(npe);
        }
        continue;
      }
      try {
        _socket.send(currBundle._dp);
      }
 catch (      BindException be) {
      }
catch (      NoRouteToHostException nrthe) {
      }
catch (      IOException ioe) {
        if (isIgnoreable(ioe.getMessage()))         return;
        String errString=""String_Node_Str"" + currBundle._dp.getAddress() + ""String_Node_Str""+ currBundle._dp.getPort();
        currBundle._err.error(ioe,errString);
      }
    }
  }
}",0.946855192588981
4506,"public void testMixedProtocol() throws Exception {
  DatagramPacket pack=null;
  UDP_ACCESS=new DatagramSocket();
  for (int i=0; i < testUP.length; i++) {
    assertTrue(""String_Node_Str"",testUP[i].isOpen());
    assertTrue(""String_Node_Str"",testUP[i].isSupernodeClientConnection());
    drain(testUP[i],500);
    if ((i == 2)) {
      testUP[i].send(MessagesSupportedVendorMessage.instance());
      testUP[i].flush();
    }
  }
{
    drainAll();
    PingReply pong=PingReply.create(GUID.makeGuid(),(byte)4,UDP_ACCESS.getLocalPort(),InetAddress.getLocalHost().getAddress(),10,10,true,900,true);
    testUP[0].send(pong);
    testUP[0].flush();
    UDP_ACCESS.setSoTimeout(TIMEOUT * 2);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    PingRequest ping=(PingRequest)Message.read(in);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pong=PingReply.create(ping.getGUID(),(byte)4,UDP_ACCESS.getLocalPort(),InetAddress.getLocalHost().getAddress(),10,10,true,900,true);
    pong.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,pack.getAddress(),pack.getPort());
    UDP_ACCESS.send(pack);
  }
{
    testUP[0].send(MessagesSupportedVendorMessage.instance());
    testUP[0].flush();
    byte[] cbGuid=null;
    int cbPort=-1;
    while (cbGuid == null) {
      try {
        Message m=testUP[0].receive(TIMEOUT);
        if (m instanceof UDPConnectBackVendorMessage) {
          UDPConnectBackVendorMessage udp=(UDPConnectBackVendorMessage)m;
          cbGuid=udp.getConnectBackGUID().bytes();
          cbPort=udp.getConnectBackPort();
        }
      }
 catch (      Exception ie) {
        fail(""String_Node_Str"",ie);
      }
    }
    PingRequest pr=new PingRequest(cbGuid,(byte)1,(byte)0);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pr.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),cbPort);
    UDP_ACCESS.send(pack);
  }
{
    Socket sock=null;
    OutputStream os=null;
    try {
      sock=Sockets.connect(InetAddress.getLocalHost().getHostAddress(),SERVER_PORT,12);
      os=sock.getOutputStream();
      os.write(""String_Node_Str"".getBytes());
    }
 catch (    IOException ignored) {
    }
catch (    SecurityException ignored) {
    }
catch (    Throwable t) {
      ErrorService.error(t);
    }
 finally {
      if (sock != null)       try {
        sock.close();
      }
 catch (      IOException ignored) {
      }
      if (os != null)       try {
        os.close();
      }
 catch (      IOException ignored) {
      }
    }
  }
  Thread.sleep(250);
  assertTrue(rs.isGUESSCapable());
  assertTrue(rs.acceptedIncomingConnection());
  drainAll();
  GUID queryGuid=new GUID(rs.newQueryGUID());
  assertTrue(GUID.addressesMatch(queryGuid.bytes(),rs.getAddress(),rs.getPort()));
  rs.query(queryGuid.bytes(),""String_Node_Str"");
  Thread.sleep(250);
  for (int i=0; i < testUP.length; i++) {
    QueryRequest qr=getFirstQueryRequest(testUP[i],TIMEOUT);
    assertNotNull(""String_Node_Str"" + i + ""String_Node_Str"",qr);
    assertEquals(new GUID(qr.getGUID()),queryGuid);
    if ((i == 0) || (i == 2))     assertTrue(qr.desiresOutOfBandReplies());
 else     assertTrue(!qr.desiresOutOfBandReplies());
  }
  Message m=null;
  assertGreaterThan(SearchResultHandler.REPORT_INTERVAL,4 * testUP.length);
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[4];
    res[0]=new Response(10,10,""String_Node_Str"" + i);
    res[1]=new Response(10,10,""String_Node_Str"" + i);
    res[2]=new Response(10,10,""String_Node_Str"" + i);
    res[3]=new Response(10,10,""String_Node_Str"" + i);
    m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  for (int i=0; i < testUP.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUP[i]);
    if ((i == 0) || (i == 2)) {
      assertNotNull(stat);
      assertEquals(new GUID(stat.getGUID()),queryGuid);
      assertEquals(4,stat.getNumResults());
    }
 else     assertNull(stat);
  }
  rs.stopQuery(queryGuid);
  for (int i=0; i < testUP.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUP[i]);
    if ((i == 0) || (i == 2)) {
      assertNotNull(stat);
      assertEquals(new GUID(stat.getGUID()),queryGuid);
      assertEquals(65535,stat.getNumResults());
    }
 else     assertNull(stat);
  }
}","public void testMixedProtocol() throws Exception {
  DatagramPacket pack=null;
  UDP_ACCESS=new DatagramSocket();
  for (int i=0; i < testUP.length; i++) {
    assertTrue(""String_Node_Str"",testUP[i].isOpen());
    assertTrue(""String_Node_Str"",testUP[i].isSupernodeClientConnection());
    drain(testUP[i],500);
    if ((i == 2)) {
      testUP[i].send(MessagesSupportedVendorMessage.instance());
      testUP[i].flush();
    }
  }
{
    drainAll();
    PingReply pong=PingReply.create(GUID.makeGuid(),(byte)4,UDP_ACCESS.getLocalPort(),InetAddress.getLocalHost().getAddress(),10,10,true,900,true);
    testUP[0].send(pong);
    testUP[0].flush();
    UDP_ACCESS.setSoTimeout(TIMEOUT * 2);
    pack=new DatagramPacket(new byte[1000],1000);
    try {
      UDP_ACCESS.receive(pack);
    }
 catch (    IOException bad) {
      fail(""String_Node_Str"",bad);
    }
    InputStream in=new ByteArrayInputStream(pack.getData());
    PingRequest ping=(PingRequest)Message.read(in);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pong=PingReply.create(ping.getGUID(),(byte)4,UDP_ACCESS.getLocalPort(),InetAddress.getLocalHost().getAddress(),10,10,true,900,true);
    pong.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,pack.getAddress(),pack.getPort());
    UDP_ACCESS.send(pack);
  }
{
    testUP[0].send(MessagesSupportedVendorMessage.instance());
    testUP[0].flush();
    byte[] cbGuid=null;
    int cbPort=-1;
    while (cbGuid == null) {
      try {
        Message m=testUP[0].receive(TIMEOUT);
        if (m instanceof UDPConnectBackVendorMessage) {
          UDPConnectBackVendorMessage udp=(UDPConnectBackVendorMessage)m;
          cbGuid=udp.getConnectBackGUID().bytes();
          cbPort=udp.getConnectBackPort();
        }
      }
 catch (      Exception ie) {
        fail(""String_Node_Str"",ie);
      }
    }
    PingRequest pr=new PingRequest(cbGuid,(byte)1,(byte)0);
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    pr.write(baos);
    pack=new DatagramPacket(baos.toByteArray(),baos.toByteArray().length,testUP[0].getInetAddress(),cbPort);
    UDP_ACCESS.send(pack);
  }
{
    Socket sock=null;
    OutputStream os=null;
    try {
      sock=Sockets.connect(InetAddress.getLocalHost().getHostAddress(),SERVER_PORT,12);
      os=sock.getOutputStream();
      os.write(""String_Node_Str"".getBytes());
    }
 catch (    IOException ignored) {
    }
catch (    SecurityException ignored) {
    }
catch (    Throwable t) {
      ErrorService.error(t);
    }
 finally {
      if (sock != null)       try {
        sock.close();
      }
 catch (      IOException ignored) {
      }
      if (os != null)       try {
        os.close();
      }
 catch (      IOException ignored) {
      }
    }
  }
  Thread.sleep(250);
  assertTrue(RouterService.isGUESSCapable());
  assertTrue(RouterService.acceptedIncomingConnection());
  drainAll();
  GUID queryGuid=new GUID(RouterService.newQueryGUID());
  assertTrue(GUID.addressesMatch(queryGuid.bytes(),RouterService.getAddress(),RouterService.getPort()));
  RouterService.query(queryGuid.bytes(),""String_Node_Str"");
  Thread.sleep(250);
  for (int i=0; i < testUP.length; i++) {
    QueryRequest qr=getFirstQueryRequest(testUP[i],TIMEOUT);
    assertNotNull(""String_Node_Str"" + i + ""String_Node_Str"",qr);
    assertEquals(new GUID(qr.getGUID()),queryGuid);
    if ((i == 0) || (i == 2))     assertTrue(qr.desiresOutOfBandReplies());
 else     assertTrue(!qr.desiresOutOfBandReplies());
  }
  Message m=null;
  assertGreaterThan(SearchResultHandler.REPORT_INTERVAL,4 * testUP.length);
  for (int i=0; i < testUP.length; i++) {
    Response[] res=new Response[4];
    res[0]=new Response(10,10,""String_Node_Str"" + i);
    res[1]=new Response(10,10,""String_Node_Str"" + i);
    res[2]=new Response(10,10,""String_Node_Str"" + i);
    res[3]=new Response(10,10,""String_Node_Str"" + i);
    m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUP[i].send(m);
    testUP[i].flush();
  }
  for (int i=0; i < testUP.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUP[i]);
    if ((i == 0) || (i == 2)) {
      assertNotNull(stat);
      assertEquals(new GUID(stat.getGUID()),queryGuid);
      assertEquals(4,stat.getNumResults());
    }
 else     assertNull(stat);
  }
  RouterService.stopQuery(queryGuid);
  for (int i=0; i < testUP.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUP[i]);
    if ((i == 0) || (i == 2)) {
      assertNotNull(stat);
      assertEquals(new GUID(stat.getGUID()),queryGuid);
      assertEquals(65535,stat.getNumResults());
    }
 else     assertNull(stat);
  }
}",0.985364811451768
4507,"public void handleQueryResult(RemoteFileDesc rfd,HostData data,Set locs){
  this.rfd=rfd;
}","public void handleQueryResult(RemoteFileDesc returnedRfd,HostData data,Set locs){
  this.rfd=returnedRfd;
}",0.9191919191919192
4508,"public static void globalSetUp() throws Exception {
  RouterService rs=new RouterService(callback);
  dm=rs.getDownloadManager();
  dm.initialize();
  RouterService.getAcceptor().setAddress(InetAddress.getLocalHost());
  Runnable click=new Runnable(){
    public void run(){
      dm.measureBandwidth();
    }
  }
;
  RouterService.schedule(click,0,SupernodeAssigner.TIMER_DELAY);
}","public static void globalSetUp() throws Exception {
  DownloadSettings.MAX_DOWNLOAD_BYTES_PER_SEC.setValue(10);
  RouterService rs=new RouterService(callback);
  dm=rs.getDownloadManager();
  dm.initialize();
  RouterService.getAcceptor().setAddress(InetAddress.getLocalHost());
  Runnable click=new Runnable(){
    public void run(){
      dm.measureBandwidth();
    }
  }
;
  RouterService.schedule(click,0,SupernodeAssigner.TIMER_DELAY);
}",0.9271844660194176
4509,"public void setUp(){
  DOWNLOADER=null;
  ConnectionSettings.LOCAL_IS_PRIVATE.setValue(false);
  ManagedDownloader.NO_DELAY=true;
  uploader1=new TestUploader(""String_Node_Str"",PORT_1);
  uploader2=new TestUploader(""String_Node_Str"",PORT_2);
  uploader3=new TestUploader(""String_Node_Str"",PORT_3);
  uploader4=new TestUploader(""String_Node_Str"",PORT_4);
  uploader5=new TestUploader(""String_Node_Str"",PORT_5);
  deleteAllFiles();
  dataDir.mkdirs();
  saveDir.mkdirs();
  try {
    SharingSettings.setSaveDirectory(saveDir);
  }
 catch (  IOException e) {
    fail(""String_Node_Str"",e);
  }
  savedFile=new File(saveDir,savedFileName);
  savedFile.delete();
  ConnectionSettings.CONNECTION_SPEED.setValue(1000);
  callback.delCorrupt=false;
}","public void setUp(){
  DOWNLOAD_WAIT_TIME=1000 * 60 * 2;
  DOWNLOADER=null;
  ConnectionSettings.LOCAL_IS_PRIVATE.setValue(false);
  ManagedDownloader.NO_DELAY=true;
  uploader1=new TestUploader(""String_Node_Str"",PORT_1);
  uploader2=new TestUploader(""String_Node_Str"",PORT_2);
  uploader3=new TestUploader(""String_Node_Str"",PORT_3);
  uploader4=new TestUploader(""String_Node_Str"",PORT_4);
  uploader5=new TestUploader(""String_Node_Str"",PORT_5);
  deleteAllFiles();
  dataDir.mkdirs();
  saveDir.mkdirs();
  try {
    SharingSettings.setSaveDirectory(saveDir);
  }
 catch (  IOException e) {
    fail(""String_Node_Str"",e);
  }
  savedFile=new File(saveDir,savedFileName);
  savedFile.delete();
  ConnectionSettings.CONNECTION_SPEED.setValue(1000);
  callback.delCorrupt=false;
}",0.9763157894736842
4510,"private static void waitForComplete(boolean isCorrupt){
synchronized (COMPLETE_LOCK) {
    try {
      REMOVED=false;
      COMPLETE_LOCK.wait(TWO_MINUTES);
    }
 catch (    InterruptedException e) {
    }
  }
  if (!REMOVED) {
    dm.remove(DOWNLOADER,false);
    fail(""String_Node_Str"" + DOWNLOADER.getState());
  }
  if (isCorrupt)   assertEquals(""String_Node_Str"",Downloader.CORRUPT_FILE,DOWNLOADER.getState());
 else   assertEquals(""String_Node_Str"",Downloader.COMPLETE,DOWNLOADER.getState());
}","private static void waitForComplete(boolean isCorrupt){
synchronized (COMPLETE_LOCK) {
    try {
      REMOVED=false;
      COMPLETE_LOCK.wait(DOWNLOAD_WAIT_TIME);
    }
 catch (    InterruptedException e) {
    }
  }
  if (!REMOVED) {
    dm.remove(DOWNLOADER,false);
    fail(""String_Node_Str"" + DOWNLOADER.getState());
  }
  if (isCorrupt)   assertEquals(""String_Node_Str"",Downloader.CORRUPT_FILE,DOWNLOADER.getState());
 else   assertEquals(""String_Node_Str"",Downloader.COMPLETE,DOWNLOADER.getState());
}",0.975222993062438
4511,"public static Test suite(){
  return buildTestSuite(DownloadTest.class);
}","public static Test suite(){
  return buildTestSuite(DownloadTest.class,""String_Node_Str"");
}",0.891566265060241
4512,"public void run(){
  try {
    while (http11 && !stopped) {
      handleRequest(mySocket);
      if (queue) {
        mySocket.setSoTimeout(MAX_POLL);
        if (unqueue)         queue=false;
        handleRequest(mySocket);
      }
      mySocket.setSoTimeout(8000);
    }
  }
 catch (  IOException e) {
    if (totalUploaded < totalAmountToUpload)     killedByDownloader=true;
    LOG.debug(""String_Node_Str"",e);
  }
catch (  Throwable t) {
    ErrorService.error(t);
  }
 finally {
    try {
      mySocket.close();
    }
 catch (    IOException e) {
      return;
    }
  }
}","public void run(){
  try {
    while (http11 && !stopped) {
      handleRequest(mySocket);
      if (queue) {
        mySocket.setSoTimeout(MAX_POLL);
        if (unqueue)         queue=false;
        handleRequest(mySocket);
      }
      mySocket.setSoTimeout(8000);
    }
  }
 catch (  IOException e) {
    if (totalUploaded < totalAmountToUpload)     killedByDownloader=true;
    LOG.debug(""String_Node_Str"" + name + ""String_Node_Str"",e);
  }
catch (  Throwable t) {
    ErrorService.error(t);
  }
 finally {
    try {
      mySocket.close();
    }
 catch (    IOException e) {
      return;
    }
  }
}",0.9772535804549284
4513,"/** 
 * Repeatedly accepts connections and handles them.
 */
private void loop(int port){
  Socket socket=null;
  while (true) {
    try {
      socket=server.accept();
      connects++;
      InetAddress address=socket.getInetAddress();
      if (isBannedIP(address.getHostAddress())) {
        LOG.debug(""String_Node_Str"");
        server.close();
        continue;
      }
      LOG.debug(""String_Node_Str"");
      final Socket mySocket=socket;
      Thread runner=new Thread(){
        public void run(){
          try {
            while (http11 && !stopped) {
              handleRequest(mySocket);
              if (queue) {
                mySocket.setSoTimeout(MAX_POLL);
                if (unqueue)                 queue=false;
                handleRequest(mySocket);
              }
              mySocket.setSoTimeout(8000);
            }
          }
 catch (          IOException e) {
            if (totalUploaded < totalAmountToUpload)             killedByDownloader=true;
            LOG.debug(""String_Node_Str"",e);
          }
catch (          Throwable t) {
            ErrorService.error(t);
          }
 finally {
            try {
              mySocket.close();
            }
 catch (            IOException e) {
              return;
            }
          }
        }
      }
;
      runner.start();
    }
 catch (    IOException e) {
      LOG.debug(""String_Node_Str"",e);
      try {
        server.close();
      }
 catch (      IOException ignore) {
      }
      return;
    }
  }
}","/** 
 * Repeatedly accepts connections and handles them.
 */
private void loop(int port){
  Socket socket=null;
  while (true) {
    try {
      socket=server.accept();
      connects++;
      InetAddress address=socket.getInetAddress();
      if (isBannedIP(address.getHostAddress())) {
        LOG.debug(""String_Node_Str"");
        server.close();
        continue;
      }
      LOG.debug(""String_Node_Str"");
      final Socket mySocket=socket;
      Thread runner=new Thread(){
        public void run(){
          try {
            while (http11 && !stopped) {
              handleRequest(mySocket);
              if (queue) {
                mySocket.setSoTimeout(MAX_POLL);
                if (unqueue)                 queue=false;
                handleRequest(mySocket);
              }
              mySocket.setSoTimeout(8000);
            }
          }
 catch (          IOException e) {
            if (totalUploaded < totalAmountToUpload)             killedByDownloader=true;
            LOG.debug(""String_Node_Str"" + name + ""String_Node_Str"",e);
          }
catch (          Throwable t) {
            ErrorService.error(t);
          }
 finally {
            try {
              mySocket.close();
            }
 catch (            IOException e) {
              return;
            }
          }
        }
      }
;
      runner.start();
    }
 catch (    IOException e) {
      LOG.debug(""String_Node_Str"",e);
      try {
        server.close();
      }
 catch (      IOException ignore) {
      }
      return;
    }
  }
}",0.9911562397641664
4514,"/** 
 * Resets the rate, amount uploaded, stop byte, etc.
 */
public void reset(){
  storedAltLocs=null;
  incomingAltLocs=null;
  totalUploaded=0;
  stopAfter=-1;
  rate=10000;
  stopped=false;
  sendCorrupt=false;
  busy=false;
  retryAfter=-1;
  timesBusy=Integer.MAX_VALUE;
  queue=false;
  partial=0;
  minPollTime=-1;
  maxPollTime=-1;
  unqueue=true;
  queuePos=1;
  killedByDownloader=false;
  totalAmountToUpload=0;
  requestsReceived=0;
  connects=0;
  lowChunkOffset=0;
  highChunkOffset=0;
}","/** 
 * Resets the rate, amount uploaded, stop byte, etc.
 */
public void reset(){
  storedAltLocs=null;
  incomingAltLocs=null;
  totalUploaded=0;
  stopAfter=-1;
  rate=10000;
  stopped=false;
  sendCorrupt=false;
  busy=false;
  retryAfter=-1;
  timesBusy=Integer.MAX_VALUE;
  queue=false;
  partial=0;
  minPollTime=-1;
  maxPollTime=-1;
  unqueue=true;
  queuePos=1;
  killedByDownloader=false;
  totalAmountToUpload=0;
  requestsReceived=0;
  connects=0;
  lowChunkOffset=0;
  highChunkOffset=0;
  respondWithHTTP11=true;
}",0.9748062015503876
4515,"private void send(OutputStream out,int start,int stop) throws IOException {
  totalAmountToUpload+=stop - start;
  long t0=System.currentTimeMillis();
  if (minPollTime > 0)   Assert.that(t0 > minPollTime,""String_Node_Str"" + (minPollTime - t0) + ""String_Node_Str"");
  if (maxPollTime > 0)   Assert.that(t0 < maxPollTime,""String_Node_Str"" + (t0 - maxPollTime) + ""String_Node_Str"");
  String str=busy || queue || partial == 1 ? ""String_Node_Str"" : ""String_Node_Str"";
  out.write(str.getBytes());
  if (busy && retryAfter != -1) {
    str=""String_Node_Str"" + retryAfter + ""String_Node_Str"";
    out.write(str.getBytes());
  }
  if (queue) {
    LOG.debug(""String_Node_Str"");
    str=""String_Node_Str"" + queuePos + ""String_Node_Str""+ MIN_POLL / 1000 + ""String_Node_Str"" + MAX_POLL / 1000 + ""String_Node_Str"";
    out.write(str.getBytes());
    str=""String_Node_Str"";
    out.write(str.getBytes());
    out.flush();
    long t=System.currentTimeMillis();
    minPollTime=t + MIN_POLL;
    maxPollTime=t + MAX_POLL;
    return;
  }
  if (partial > 0) {
switch (partial) {
case 1:
      str=""String_Node_Str"";
    break;
case 2:
  str=""String_Node_Str"";
break;
default :
str=""String_Node_Str"";
}
out.write(str.getBytes());
out.flush();
partial++;
if (partial == 2) {
str=""String_Node_Str"";
out.write(str.getBytes());
out.flush();
return;
}
}
str=""String_Node_Str"" + (stop - start) + ""String_Node_Str"";
out.write(str.getBytes());
if (start != 0 || (stop - start != TestFile.length())) {
str=""String_Node_Str"" + start + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str""+ TestFile.length()+ ""String_Node_Str"";
out.write(str.getBytes());
}
if (storedAltLocs != null && storedAltLocs.hasAlternateLocations()) {
LOG.debug(""String_Node_Str"" + storedAltLocs + ""String_Node_Str"");
HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,storedAltLocs,out);
}
 else {
LOG.debug(""String_Node_Str"" + storedAltLocs + ""String_Node_Str"");
}
str=""String_Node_Str"";
out.write(str.getBytes());
out.flush();
if (busy) {
if (connects >= timesBusy) busy=false;
out.close();
return;
}
for (int i=start; i < stop; ) {
if (stopAfter > -1 && totalUploaded == stopAfter) {
stopped=true;
out.flush();
throw new IOException();
}
if (sendCorrupt) out.write(TestFile.getByte(i) + (byte)1);
 else out.write(TestFile.getByte(i));
totalUploaded++;
i++;
}
out.flush();
}","private void send(OutputStream out,int start,int stop) throws IOException {
  totalAmountToUpload+=stop - start;
  long t0=System.currentTimeMillis();
  if (minPollTime > 0)   Assert.that(t0 > minPollTime,""String_Node_Str"" + (minPollTime - t0) + ""String_Node_Str"");
  if (maxPollTime > 0)   Assert.that(t0 < maxPollTime,""String_Node_Str"" + (t0 - maxPollTime) + ""String_Node_Str"");
  String httpValue=respondWithHTTP11 ? ""String_Node_Str"" : ""String_Node_Str"";
  String str=httpValue + ""String_Node_Str"" + (busy || queue || partial == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
  out.write(str.getBytes());
  if (busy && retryAfter != -1) {
    str=""String_Node_Str"" + retryAfter + ""String_Node_Str"";
    out.write(str.getBytes());
  }
  if (queue) {
    LOG.debug(""String_Node_Str"");
    str=""String_Node_Str"" + queuePos + ""String_Node_Str""+ MIN_POLL / 1000 + ""String_Node_Str"" + MAX_POLL / 1000 + ""String_Node_Str"";
    out.write(str.getBytes());
    str=""String_Node_Str"";
    out.write(str.getBytes());
    out.flush();
    long t=System.currentTimeMillis();
    minPollTime=t + MIN_POLL;
    maxPollTime=t + MAX_POLL;
    return;
  }
  if (partial > 0) {
switch (partial) {
case 1:
      str=""String_Node_Str"";
    break;
case 2:
  str=""String_Node_Str"";
break;
default :
str=""String_Node_Str"";
}
out.write(str.getBytes());
out.flush();
partial++;
if (partial == 2) {
str=""String_Node_Str"";
out.write(str.getBytes());
out.flush();
return;
}
}
str=""String_Node_Str"" + (stop - start) + ""String_Node_Str"";
out.write(str.getBytes());
if (start != 0 || (stop - start != TestFile.length())) {
str=""String_Node_Str"" + start + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str""+ TestFile.length()+ ""String_Node_Str"";
out.write(str.getBytes());
}
if (storedAltLocs != null && storedAltLocs.hasAlternateLocations()) {
LOG.debug(""String_Node_Str"" + storedAltLocs + ""String_Node_Str"");
HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,storedAltLocs,out);
}
 else {
LOG.debug(""String_Node_Str"" + storedAltLocs + ""String_Node_Str"");
}
str=""String_Node_Str"";
out.write(str.getBytes());
out.flush();
if (busy) {
if (connects >= timesBusy) busy=false;
out.close();
return;
}
for (int i=start; i < stop; ) {
if (stopAfter > -1 && totalUploaded == stopAfter) {
stopped=true;
out.flush();
throw new IOException();
}
if (sendCorrupt) out.write(TestFile.getByte(i) + (byte)1);
 else out.write(TestFile.getByte(i));
totalUploaded++;
i++;
}
out.flush();
}",0.9747687132043734
4516,"/** 
 * Steals a grey area from the biggesr HHTPDownloader and gives it to the HTTPDownloader this method will return.  <p>  If there is less than MIN_SPLIT_SIZE left, we will assign the entire area to a new HTTPDownloader, if the current downloader is going too slow.
 */
private void assignGrey(HTTPDownloader dloader,boolean http11) throws NoSuchElementException, IOException, TryAgainLaterException, QueuedException, FileNotFoundException, NotSharingException, NoSuchRangeException {
  if (dloader.getRemoteFileDesc().isPartialSource())   throw new NoSuchRangeException();
  HTTPDownloader biggest=null;
synchronized (this) {
    for (Iterator iter=dloaders.iterator(); iter.hasNext(); ) {
      HTTPDownloader h=(HTTPDownloader)iter.next();
      if (h.isActive() && (biggest == null || h.getAmountToRead() > biggest.getAmountToRead()))       biggest=h;
    }
  }
  if (biggest == null) {
    throw new NoSuchElementException();
  }
  int amountRead=biggest.getAmountRead();
  int left=biggest.getAmountToRead() - amountRead;
  if ((http11 && left < CHUNK_SIZE) || (!http11 && left < MIN_SPLIT_SIZE)) {
    float bandwidthVictim=-1;
    float bandwidthStealer=-1;
    try {
      bandwidthVictim=biggest.getAverageBandwidth();
      biggest.getMeasuredBandwidth();
    }
 catch (    InsufficientDataException ide) {
      LOG.debug(""String_Node_Str"",ide);
      bandwidthVictim=-1;
    }
    try {
      bandwidthStealer=dloader.getAverageBandwidth();
      dloader.getMeasuredBandwidth();
    }
 catch (    InsufficientDataException ide) {
      LOG.debug(""String_Node_Str"",ide);
      bandwidthStealer=-1;
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + dloader + ""String_Node_Str""+ biggest+ ""String_Node_Str""+ bandwidthStealer+ ""String_Node_Str""+ bandwidthVictim+ ""String_Node_Str"");
    if ((bandwidthVictim != -1 && bandwidthVictim < MIN_ACCEPTABLE_SPEED) || (bandwidthStealer > MIN_ACCEPTABLE_SPEED && bandwidthStealer > bandwidthVictim)) {
      int start=biggest.getInitialReadingPoint() + amountRead;
      int stop=biggest.getInitialReadingPoint() + biggest.getAmountToRead();
      dloader.connectHTTP(getOverlapOffset(start),stop,false);
      int newLow=dloader.getInitialReadingPoint();
      int newHigh=dloader.getAmountToRead() + newLow;
      if (newLow > start || newHigh < stop) {
        if (LOG.isDebugEnabled())         LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + start + ""String_Node_Str""+ stop+ ""String_Node_Str""+ newLow+ ""String_Node_Str""+ newHigh);
        throw new IOException(""String_Node_Str"");
      }
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + start + ""String_Node_Str""+ stop+ ""String_Node_Str""+ biggest+ ""String_Node_Str""+ dloader);
      biggest.stopAt(start);
      biggest.stop();
    }
 else {
      throw new NoSuchElementException();
    }
  }
 else {
    int start;
    if (http11) {
      start=biggest.getInitialReadingPoint() + biggest.getAmountToRead() - CHUNK_SIZE + 1;
    }
 else {
      start=biggest.getInitialReadingPoint() + amountRead + left / 2;
    }
    int stop=biggest.getInitialReadingPoint() + biggest.getAmountToRead();
    dloader.connectHTTP(getOverlapOffset(start),stop,true);
    int newLow=dloader.getInitialReadingPoint();
    int newHigh=dloader.getAmountToRead() + newLow;
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + newLow + ""String_Node_Str""+ newHigh+ ""String_Node_Str""+ biggest+ ""String_Node_Str""+ dloader);
    if (newLow > start)     start=newLow;
    biggest.stopAt(start);
  }
}","/** 
 * Steals a grey area from the biggesr HHTPDownloader and gives it to the HTTPDownloader this method will return.  <p>  If there is less than MIN_SPLIT_SIZE left, we will assign the entire area to a new HTTPDownloader, if the current downloader is going too slow.
 */
private void assignGrey(HTTPDownloader dloader,boolean http11) throws NoSuchElementException, IOException, TryAgainLaterException, QueuedException, FileNotFoundException, NotSharingException, NoSuchRangeException {
  if (dloader.getRemoteFileDesc().isPartialSource())   throw new NoSuchRangeException();
  HTTPDownloader biggest=null;
synchronized (this) {
    for (Iterator iter=dloaders.iterator(); iter.hasNext(); ) {
      HTTPDownloader h=(HTTPDownloader)iter.next();
      if (h.isActive() && (biggest == null || h.getAmountToRead() > biggest.getAmountToRead()))       biggest=h;
    }
  }
  if (biggest == null) {
    throw new NoSuchElementException();
  }
  int amountRead=biggest.getAmountRead();
  int left=biggest.getAmountToRead() - amountRead;
  if ((http11 && left < CHUNK_SIZE) || (!http11 && left < MIN_SPLIT_SIZE)) {
    float bandwidthVictim=-1;
    float bandwidthStealer=-1;
    try {
      bandwidthVictim=biggest.getAverageBandwidth();
      biggest.getMeasuredBandwidth();
    }
 catch (    InsufficientDataException ide) {
      LOG.debug(""String_Node_Str"",ide);
      bandwidthVictim=-1;
    }
    try {
      bandwidthStealer=dloader.getAverageBandwidth();
      dloader.getMeasuredBandwidth();
    }
 catch (    InsufficientDataException ide) {
      LOG.debug(""String_Node_Str"",ide);
      bandwidthStealer=-1;
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + dloader + ""String_Node_Str""+ biggest+ ""String_Node_Str""+ bandwidthStealer+ ""String_Node_Str""+ bandwidthVictim+ ""String_Node_Str"");
    if ((bandwidthVictim != -1 && bandwidthVictim < MIN_ACCEPTABLE_SPEED) || (bandwidthStealer > MIN_ACCEPTABLE_SPEED && bandwidthStealer > bandwidthVictim)) {
      int start=biggest.getInitialReadingPoint() + amountRead;
      int stop=biggest.getInitialReadingPoint() + biggest.getAmountToRead();
      dloader.connectHTTP(getOverlapOffset(start),stop,false);
      int newLow=dloader.getInitialReadingPoint();
      int newHigh=dloader.getAmountToRead() + newLow;
      if (newLow > start || newHigh < stop) {
        if (LOG.isDebugEnabled())         LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + start + ""String_Node_Str""+ stop+ ""String_Node_Str""+ newLow+ ""String_Node_Str""+ newHigh);
        throw new IOException(""String_Node_Str"");
      }
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + start + ""String_Node_Str""+ stop+ ""String_Node_Str""+ biggest+ ""String_Node_Str""+ dloader);
      biggest.stopAt(start);
      biggest.stop();
    }
 else {
      throw new NoSuchElementException();
    }
  }
 else {
    int start;
    if (http11) {
      start=biggest.getInitialReadingPoint() + biggest.getAmountToRead() - CHUNK_SIZE + 1;
    }
 else {
      start=biggest.getInitialReadingPoint() + amountRead + left / 2;
    }
    int stop=biggest.getInitialReadingPoint() + biggest.getAmountToRead();
    dloader.connectHTTP(getOverlapOffset(start),stop,true);
    int newLow=dloader.getInitialReadingPoint();
    int newHigh=dloader.getAmountToRead() + newLow;
    if (newHigh < stop) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + stop + ""String_Node_Str""+ newHigh);
      throw new IOException(""String_Node_Str"");
    }
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + newLow + ""String_Node_Str""+ newHigh+ ""String_Node_Str""+ biggest+ ""String_Node_Str""+ dloader);
    if (newLow > start)     start=newLow;
    biggest.stopAt(start);
  }
}",0.9719317556411669
4517,"/** 
 * Actually does the download, finding duplicate files, trying all locations, resuming, waiting, and retrying as necessary. Also takes care of moving file from incomplete directory to save directory and adding file to the library.  Called from dloadManagerThread.  
 * @param deserialized True if this downloader was deserialized from disk,false if it was newly constructed.
 */
protected void tryAllDownloads(final boolean deserializedFromDisk){
  int numQueries=getQueryCount(deserializedFromDisk);
  long timeQuerySent=System.currentTimeMillis();
  long timeSpentWaiting=0;
  boolean triedLocatingSources=false;
  while (true) {
    try {
      setState(QUEUED);
      queuePosition=""String_Node_Str"";
      queuedVendor=""String_Node_Str"";
      manager.waitForSlot(this);
      boolean waitForRetry=false;
      bucketNumber=0;
      try {
        for (Iterator iter=buckets.buckets(); iter.hasNext(); bucketNumber++) {
          cleanup();
          files=(List)iter.next();
          if (checkHosts()) {
            setState(GAVE_UP);
            return;
          }
          if (files.size() <= 0)           continue;
          int status=tryAllDownloads2();
          if (status == COMPLETE) {
            setState(COMPLETE);
            manager.remove(this,true);
            return;
          }
 else           if (status == COULDNT_MOVE_TO_LIBRARY) {
            setState(COULDNT_MOVE_TO_LIBRARY);
            manager.remove(this,false);
            return;
          }
 else           if (status == CORRUPT_FILE) {
            setState(CORRUPT_FILE);
            manager.remove(this,false);
            return;
          }
 else           if (status == WAITING_FOR_RETRY) {
            waitForRetry=true;
          }
 else {
            Assert.that(status == GAVE_UP,""String_Node_Str"" + status);
          }
        }
      }
 catch (      InterruptedException e) {
        if (!stopped)         ErrorService.error(e);
      }
      manager.yieldSlot(this);
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
      Assert.that(getState() != GAVE_UP);
      Assert.that(getState() != COMPLETE);
      Assert.that(getState() != COULDNT_MOVE_TO_LIBRARY);
      Assert.that(getState() != CORRUPT_FILE);
      if ((this.originalQueryGUID != null) && !triedLocatingSources) {
        MessageRouter mr=RouterService.getMessageRouter();
        Set guessLocs=mr.getGuessLocs(this.originalQueryGUID);
        if ((guessLocs != null) && !guessLocs.isEmpty()) {
          setState(ITERATIVE_GUESSING);
          triedLocatingSources=true;
          boolean areThereNewResults=false;
          URN bestURN=getBestURN();
          for (Iterator i=guessLocs.iterator(); i.hasNext(); ) {
            GUESSEndpoint ep=(GUESSEndpoint)i.next();
            OnDemandUnicaster.query(ep,bestURN);
            if (!areThereNewResults)             areThereNewResults=reqLock.lock(750);
          }
          if (areThereNewResults)           continue;
        }
      }
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
      final long currTime=System.currentTimeMillis();
      if (waitForRetry) {
synchronized (this) {
          retriesWaiting=0;
          for (Iterator iter=buckets.buckets(); iter.hasNext(); ) {
            List bucket=(List)iter.next();
            retriesWaiting+=bucket.size();
          }
        }
        long time=calculateWaitTime();
        setState(WAITING_FOR_RETRY,time);
        reqLock.lock(time);
      }
 else {
        boolean areThereNewResults=false;
        final long timeToWait=TIME_BETWEEN_REQUERIES - (System.currentTimeMillis() - timeQuerySent);
        if ((numQueries > 0) && (timeToWait > 0)) {
          setState(WAITING_FOR_RESULTS,timeToWait);
          areThereNewResults=reqLock.lock(timeToWait);
        }
        if (!areThereNewResults) {
          if (pauseForRequery(numQueries,deserializedFromDisk))           continue;
          if (numQueries < REQUERY_ATTEMPTS) {
            waitForStableConnections();
            try {
              if (manager.sendQuery(this,newRequery(numQueries)))               numQueries++;
              timeQuerySent=System.currentTimeMillis();
            }
 catch (            CantResumeException ignore) {
            }
          }
 else {
            long[] instructions=getFailedState(deserializedFromDisk,timeSpentWaiting);
            if (instructions[1] > 0) {
              setState((int)instructions[0],instructions[1]);
              reqLock.lock(instructions[1]);
              timeSpentWaiting+=System.currentTimeMillis() - currTime;
            }
 else {
              setState(GAVE_UP);
              reqLock.lock(0);
            }
          }
        }
      }
    }
 catch (    InterruptedException e) {
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
    }
  }
}","/** 
 * Actually does the download, finding duplicate files, trying all locations, resuming, waiting, and retrying as necessary. Also takes care of moving file from incomplete directory to save directory and adding file to the library.  Called from dloadManagerThread.  
 * @param deserialized True if this downloader was deserialized from disk,false if it was newly constructed.
 */
protected void tryAllDownloads(final boolean deserializedFromDisk){
  int numQueries=getQueryCount(deserializedFromDisk);
  long timeQuerySent=System.currentTimeMillis();
  long timeSpentWaiting=0;
  boolean triedLocatingSources=false;
  while (true) {
    try {
      setState(QUEUED);
      queuePosition=""String_Node_Str"";
      queuedVendor=""String_Node_Str"";
      manager.waitForSlot(this);
      boolean waitForRetry=false;
      bucketNumber=0;
      try {
        for (Iterator iter=buckets.buckets(); iter.hasNext(); bucketNumber++) {
          cleanup();
          files=(List)iter.next();
          if (checkHosts()) {
            setState(GAVE_UP);
            return;
          }
          if (files.size() <= 0)           continue;
          int status=tryAllDownloads2();
          if (status == COMPLETE) {
            setState(COMPLETE);
            manager.remove(this,true);
            return;
          }
 else           if (status == COULDNT_MOVE_TO_LIBRARY) {
            setState(COULDNT_MOVE_TO_LIBRARY);
            manager.remove(this,false);
            return;
          }
 else           if (status == CORRUPT_FILE) {
            setState(CORRUPT_FILE);
            manager.remove(this,false);
            return;
          }
 else           if (status == WAITING_FOR_RETRY) {
            waitForRetry=true;
          }
 else {
            Assert.that(status == GAVE_UP,""String_Node_Str"" + status);
          }
        }
      }
 catch (      InterruptedException e) {
        if (!stopped)         ErrorService.error(e);
      }
      manager.yieldSlot(this);
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
      Assert.that(getState() != GAVE_UP);
      Assert.that(getState() != COMPLETE);
      Assert.that(getState() != COULDNT_MOVE_TO_LIBRARY);
      Assert.that(getState() != CORRUPT_FILE);
      if ((this.originalQueryGUID != null) && !triedLocatingSources) {
        MessageRouter mr=RouterService.getMessageRouter();
        Set guessLocs=mr.getGuessLocs(this.originalQueryGUID);
        if ((guessLocs != null) && !guessLocs.isEmpty()) {
          setState(ITERATIVE_GUESSING);
          triedLocatingSources=true;
          boolean areThereNewResults=false;
          final URN bestURN=getBestURN();
          for (Iterator i=guessLocs.iterator(); (bestURN != null) && i.hasNext(); ) {
            GUESSEndpoint ep=(GUESSEndpoint)i.next();
            OnDemandUnicaster.query(ep,bestURN);
            if (!areThereNewResults)             areThereNewResults=reqLock.lock(750);
          }
          if (areThereNewResults)           continue;
        }
      }
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
      final long currTime=System.currentTimeMillis();
      if (waitForRetry) {
synchronized (this) {
          retriesWaiting=0;
          for (Iterator iter=buckets.buckets(); iter.hasNext(); ) {
            List bucket=(List)iter.next();
            retriesWaiting+=bucket.size();
          }
        }
        long time=calculateWaitTime();
        setState(WAITING_FOR_RETRY,time);
        reqLock.lock(time);
      }
 else {
        boolean areThereNewResults=false;
        final long timeToWait=TIME_BETWEEN_REQUERIES - (System.currentTimeMillis() - timeQuerySent);
        if ((numQueries > 0) && (timeToWait > 0)) {
          setState(WAITING_FOR_RESULTS,timeToWait);
          areThereNewResults=reqLock.lock(timeToWait);
        }
        if (!areThereNewResults) {
          if (pauseForRequery(numQueries,deserializedFromDisk))           continue;
          if (numQueries < REQUERY_ATTEMPTS) {
            waitForStableConnections();
            try {
              if (manager.sendQuery(this,newRequery(numQueries)))               numQueries++;
              timeQuerySent=System.currentTimeMillis();
            }
 catch (            CantResumeException ignore) {
            }
          }
 else {
            long[] instructions=getFailedState(deserializedFromDisk,timeSpentWaiting);
            if (instructions[1] > 0) {
              setState((int)instructions[0],instructions[1]);
              reqLock.lock(instructions[1]);
              timeSpentWaiting+=System.currentTimeMillis() - currTime;
            }
 else {
              setState(GAVE_UP);
              reqLock.lock(0);
            }
          }
        }
      }
    }
 catch (    InterruptedException e) {
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
    }
  }
}",0.9972757542124912
4518,"/** 
 * Internal constructor.  Only creates QHD if includeQHD==true.  
 */
private QueryReply(byte[] guid,byte ttl,int port,byte[] ip,long speed,Response[] responses,byte[] clientGUID,byte[] xmlBytes,boolean includeQHD,boolean needsPush,boolean isBusy,boolean finishedUpload,boolean measuredSpeed,boolean supportsChat,boolean supportsBH,boolean isMulticastReply,Set proxies){
  super(guid,Message.F_QUERY_REPLY,ttl,(byte)0,0,16);
  if (xmlBytes.length > XML_MAX_SIZE)   return;
  final int n=responses.length;
  if (!NetworkUtils.isValidPort(port)) {
    throw new IllegalArgumentException(""String_Node_Str"" + port);
  }
 else   if (ip.length != 4) {
    throw new IllegalArgumentException(""String_Node_Str"" + ip.length);
  }
 else   if (!NetworkUtils.isValidAddress(ip)) {
    throw new IllegalArgumentException(""String_Node_Str"" + NetworkUtils.ip2string(ip));
  }
 else   if ((speed & 0xFFFFFFFF00000000l) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + speed);
  }
 else   if (n >= 256) {
    throw new IllegalArgumentException(""String_Node_Str"" + n);
  }
  _proxies=proxies;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    baos.write(n);
    ByteOrder.short2leb((short)port,baos);
    baos.write(ip,0,ip.length);
    ByteOrder.int2leb((int)speed,baos);
    for (int left=n; left > 0; left--) {
      Response r=responses[n - left];
      r.writeToStream(baos);
    }
    if (includeQHD) {
      baos.write(76);
      baos.write(73);
      baos.write(77);
      baos.write(69);
      baos.write(COMMON_PAYLOAD_LEN);
      int ggepLen=_ggepUtil.getQRGGEP(false,false,DataUtils.EMPTY_SET).length;
      byte flags=(byte)((needsPush && !isMulticastReply ? PUSH_MASK : 0) | BUSY_MASK | UPLOADED_MASK| SPEED_MASK| GGEP_MASK);
      byte controls=(byte)(PUSH_MASK | (isBusy && !isMulticastReply ? BUSY_MASK : 0) | (finishedUpload ? UPLOADED_MASK : 0)| (measuredSpeed || isMulticastReply ? SPEED_MASK : 0)| (supportsBH || isMulticastReply ? GGEP_MASK : (ggepLen > 0 ? GGEP_MASK : 0)));
      baos.write(flags);
      baos.write(controls);
      int xmlSize=xmlBytes.length + 1;
      if (xmlSize > XML_MAX_SIZE)       xmlSize=XML_MAX_SIZE;
      ByteOrder.short2leb(((short)xmlSize),baos);
      byte chatSupport=(byte)(supportsChat ? CHAT_MASK : 0);
      baos.write(chatSupport);
      byte[] ggepBytes=_ggepUtil.getQRGGEP(supportsBH,isMulticastReply,_proxies);
      baos.write(ggepBytes,0,ggepBytes.length);
      baos.write(xmlBytes,0,xmlBytes.length);
      baos.write(0);
    }
    baos.write(clientGUID,0,16);
    _payload=baos.toByteArray();
    updateLength(_payload.length);
  }
 catch (  IOException reallyBad) {
    ErrorService.error(reallyBad);
  }
  setAddress();
}","/** 
 * Internal constructor.  Only creates QHD if includeQHD==true.  
 */
private QueryReply(byte[] guid,byte ttl,int port,byte[] ip,long speed,Response[] responses,byte[] clientGUID,byte[] xmlBytes,boolean includeQHD,boolean needsPush,boolean isBusy,boolean finishedUpload,boolean measuredSpeed,boolean supportsChat,boolean supportsBH,boolean isMulticastReply,Set proxies){
  super(guid,Message.F_QUERY_REPLY,ttl,(byte)0,0,16);
  if (xmlBytes.length > XML_MAX_SIZE)   return;
  final int n=responses.length;
  if (!NetworkUtils.isValidPort(port)) {
    throw new IllegalArgumentException(""String_Node_Str"" + port);
  }
 else   if (ip.length != 4) {
    throw new IllegalArgumentException(""String_Node_Str"" + ip.length);
  }
 else   if (!NetworkUtils.isValidAddress(ip)) {
    throw new IllegalArgumentException(""String_Node_Str"" + NetworkUtils.ip2string(ip));
  }
 else   if ((speed & 0xFFFFFFFF00000000l) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + speed);
  }
 else   if (n >= 256) {
    throw new IllegalArgumentException(""String_Node_Str"" + n);
  }
  _proxies=proxies;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    baos.write(n);
    ByteOrder.short2leb((short)port,baos);
    baos.write(ip,0,ip.length);
    ByteOrder.int2leb((int)speed,baos);
    for (int left=n; left > 0; left--) {
      Response r=responses[n - left];
      r.writeToStream(baos);
    }
    if (includeQHD) {
      baos.write(76);
      baos.write(73);
      baos.write(77);
      baos.write(69);
      baos.write(COMMON_PAYLOAD_LEN);
      int ggepLen=_ggepUtil.getQRGGEP(false,false,DataUtils.EMPTY_SET).length;
      boolean hasProxies=(_proxies != null) && (_proxies.size() > 0);
      byte flags=(byte)((needsPush && !isMulticastReply ? PUSH_MASK : 0) | BUSY_MASK | UPLOADED_MASK| SPEED_MASK| GGEP_MASK);
      byte controls=(byte)(PUSH_MASK | (isBusy && !isMulticastReply ? BUSY_MASK : 0) | (finishedUpload ? UPLOADED_MASK : 0)| (measuredSpeed || isMulticastReply ? SPEED_MASK : 0)| (supportsBH || isMulticastReply || hasProxies ? GGEP_MASK : (ggepLen > 0 ? GGEP_MASK : 0)));
      baos.write(flags);
      baos.write(controls);
      int xmlSize=xmlBytes.length + 1;
      if (xmlSize > XML_MAX_SIZE)       xmlSize=XML_MAX_SIZE;
      ByteOrder.short2leb(((short)xmlSize),baos);
      byte chatSupport=(byte)(supportsChat ? CHAT_MASK : 0);
      baos.write(chatSupport);
      byte[] ggepBytes=_ggepUtil.getQRGGEP(supportsBH,isMulticastReply,_proxies);
      baos.write(ggepBytes,0,ggepBytes.length);
      baos.write(xmlBytes,0,xmlBytes.length);
      baos.write(0);
    }
    baos.write(clientGUID,0,16);
    _payload=baos.toByteArray();
    updateLength(_payload.length);
  }
 catch (  IOException reallyBad) {
    ErrorService.error(reallyBad);
  }
  setAddress();
}",0.9847826086956522
4519,"private void tStripsGGEP() throws Exception {
  ManagedConnection out=ManagedConnection.createTestConnection(""String_Node_Str"",Backend.PORT,new NoGGEPProperties(),new EmptyResponder());
  out.initialize();
  out.buildAndStartQueues();
  assertTrue(""String_Node_Str"",out.isOpen());
  drain(out);
  out.send(new PingRequest((byte)3));
  Message m=out.receive();
  assertInstanceof(""String_Node_Str"",PingReply.class,m);
  PingReply pr=(PingReply)m;
  assertTrue(""String_Node_Str"",!pr.hasGGEPExtension());
  assertTrue(""String_Node_Str"",!pr.supportsUnicast());
  assertEquals(""String_Node_Str"",-1,pr.getDailyUptime());
  out.close();
}","private void tStripsGGEP() throws Exception {
  ManagedConnection out=ManagedConnection.createTestConnection(""String_Node_Str"",Backend.BACKEND_PORT,new NoGGEPProperties(),new EmptyResponder());
  out.initialize();
  out.buildAndStartQueues();
  assertTrue(""String_Node_Str"",out.isOpen());
  drain(out);
  Thread.sleep(2000);
  drain(out);
  out.send(new PingRequest((byte)3));
  Message m=out.receive();
  assertInstanceof(""String_Node_Str"",PingReply.class,m);
  PingReply pr=(PingReply)m;
  assertTrue(""String_Node_Str"",!pr.hasGGEPExtension());
  assertTrue(""String_Node_Str"",!pr.supportsUnicast());
  assertEquals(""String_Node_Str"",-1,pr.getDailyUptime());
  out.close();
}",0.9663093415007658
4520,"/** 
 * Tests to make sure that connections are closed correctly from the server side.
 */
public void testServerSideClose() throws Exception {
  MiniAcceptor acceptor=new MiniAcceptor(PORT);
  ManagedConnection out=new ManagedConnection(""String_Node_Str"",PORT);
  out.initialize();
  out.buildAndStartQueues();
  Connection in=acceptor.accept();
  assertTrue(""String_Node_Str"",out.isOpen());
  assertTrue(""String_Node_Str"",!out.runnerDied());
  in.close();
  try {
    out.receive();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"",e);
  }
catch (  IOException e) {
  }
  sleep(100);
  assertTrue(""String_Node_Str"",!out.isOpen());
  assertTrue(""String_Node_Str"",out.runnerDied());
  acceptor=new com.limegroup.gnutella.MiniAcceptor(PORT);
  out=new ManagedConnection(""String_Node_Str"",PORT);
  out.initialize();
  out.buildAndStartQueues();
  in=acceptor.accept();
  assertTrue(""String_Node_Str"",out.isOpen());
  assertTrue(""String_Node_Str"",!out.runnerDied());
  in.close();
  Message m=new PingRequest((byte)3);
  m.hop();
  out.send(m);
  out.send(new PingRequest((byte)3));
  sleep(100);
  assertTrue(""String_Node_Str"",!out.isOpen());
  assertTrue(""String_Node_Str"",out.runnerDied());
  sleep(2000);
}","/** 
 * Tests to make sure that connections are closed correctly from the server side.
 */
public void testServerSideClose() throws Exception {
  MiniAcceptor acceptor=new MiniAcceptor(SERVER_PORT);
  ManagedConnection out=new ManagedConnection(""String_Node_Str"",SERVER_PORT);
  out.initialize();
  out.buildAndStartQueues();
  Connection in=acceptor.accept();
  assertTrue(""String_Node_Str"",out.isOpen());
  assertTrue(""String_Node_Str"",!out.runnerDied());
  in.close();
  try {
    out.receive();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"",e);
  }
catch (  IOException e) {
  }
  sleep(100);
  assertTrue(""String_Node_Str"",!out.isOpen());
  assertTrue(""String_Node_Str"",out.runnerDied());
  acceptor=new com.limegroup.gnutella.MiniAcceptor(SERVER_PORT);
  out=new ManagedConnection(""String_Node_Str"",SERVER_PORT);
  out.initialize();
  out.buildAndStartQueues();
  in=acceptor.accept();
  assertTrue(""String_Node_Str"",out.isOpen());
  assertTrue(""String_Node_Str"",!out.runnerDied());
  in.close();
  Message m=new PingRequest((byte)3);
  m.hop();
  out.send(m);
  out.send(new PingRequest((byte)3));
  sleep(100);
  assertTrue(""String_Node_Str"",!out.isOpen());
  assertTrue(""String_Node_Str"",out.runnerDied());
  sleep(2000);
}",0.9889415481832544
4521,"public void testHorizonStatistics(){
  HorizonCounter hc=HorizonCounter.instance();
  ManagedConnection mc=new ManagedConnection(""String_Node_Str"",1);
  hc.HORIZON_UPDATE_TIME=1 * 200;
  PingReply pr1=PingReply.create(GUID.makeGuid(),(byte)3,6346,new byte[]{(byte)127,(byte)0,(byte)0,(byte)1},1,10,false,0,false);
  PingReply pr2=PingReply.create(GUID.makeGuid(),(byte)3,6347,new byte[]{(byte)127,(byte)0,(byte)0,(byte)1},2,20,false,0,false);
  PingReply pr3=PingReply.create(GUID.makeGuid(),(byte)3,6346,new byte[]{(byte)127,(byte)0,(byte)0,(byte)2},3,30,false,0,false);
  assertEquals(""String_Node_Str"",0,hc.getNumFiles());
  assertEquals(""String_Node_Str"",0,hc.getNumHosts());
  assertEquals(""String_Node_Str"",0,hc.getTotalFileSize());
  mc.updateHorizonStats(pr1);
  mc.updateHorizonStats(pr1);
  assertEquals(""String_Node_Str"",1,hc.getNumFiles());
  assertEquals(""String_Node_Str"",1,hc.getNumHosts());
  assertEquals(""String_Node_Str"",10,hc.getTotalFileSize());
  try {
    Thread.sleep(HorizonCounter.HORIZON_UPDATE_TIME * 2);
  }
 catch (  InterruptedException e) {
  }
  hc.refresh();
  mc.updateHorizonStats(pr1);
  mc.updateHorizonStats(pr2);
  mc.updateHorizonStats(pr3);
  assertEquals(""String_Node_Str"",1,hc.getNumFiles());
  assertEquals(""String_Node_Str"",1,hc.getNumHosts());
  assertEquals(""String_Node_Str"",10,hc.getTotalFileSize());
  hc.refresh();
  assertEquals(""String_Node_Str"",1,hc.getNumFiles());
  assertEquals(""String_Node_Str"",1,hc.getNumHosts());
  assertEquals(""String_Node_Str"",10,hc.getTotalFileSize());
  try {
    Thread.sleep(HorizonCounter.HORIZON_UPDATE_TIME * 2);
  }
 catch (  InterruptedException e) {
  }
  hc.refresh();
  assertEquals(""String_Node_Str"",1 + 2 + 3,hc.getNumFiles());
  assertEquals(""String_Node_Str"",3,hc.getNumHosts());
  assertEquals(""String_Node_Str"",10 + 20 + 30,hc.getTotalFileSize());
  try {
    Thread.sleep(HorizonCounter.HORIZON_UPDATE_TIME * 2);
  }
 catch (  InterruptedException e) {
  }
  hc.refresh();
  assertEquals(""String_Node_Str"",0,hc.getNumFiles());
  assertEquals(""String_Node_Str"",0,hc.getNumHosts());
  assertEquals(""String_Node_Str"",0,hc.getTotalFileSize());
  mc.close();
}","public void testHorizonStatistics(){
  HorizonCounter hc=HorizonCounter.instance();
  ManagedConnection mc=new ManagedConnection(""String_Node_Str"",1);
  HorizonCounter.HORIZON_UPDATE_TIME=1 * 200;
  PingReply pr1=PingReply.create(GUID.makeGuid(),(byte)3,6346,new byte[]{(byte)127,(byte)0,(byte)0,(byte)1},1,10,false,0,false);
  PingReply pr2=PingReply.create(GUID.makeGuid(),(byte)3,6347,new byte[]{(byte)127,(byte)0,(byte)0,(byte)1},2,20,false,0,false);
  PingReply pr3=PingReply.create(GUID.makeGuid(),(byte)3,6346,new byte[]{(byte)127,(byte)0,(byte)0,(byte)2},3,30,false,0,false);
  assertEquals(""String_Node_Str"",0,hc.getNumFiles());
  assertEquals(""String_Node_Str"",0,hc.getNumHosts());
  assertEquals(""String_Node_Str"",0,hc.getTotalFileSize());
  mc.updateHorizonStats(pr1);
  mc.updateHorizonStats(pr1);
  assertEquals(""String_Node_Str"",1,hc.getNumFiles());
  assertEquals(""String_Node_Str"",1,hc.getNumHosts());
  assertEquals(""String_Node_Str"",10,hc.getTotalFileSize());
  try {
    Thread.sleep(HorizonCounter.HORIZON_UPDATE_TIME * 2);
  }
 catch (  InterruptedException e) {
  }
  hc.refresh();
  mc.updateHorizonStats(pr1);
  mc.updateHorizonStats(pr2);
  mc.updateHorizonStats(pr3);
  assertEquals(""String_Node_Str"",1,hc.getNumFiles());
  assertEquals(""String_Node_Str"",1,hc.getNumHosts());
  assertEquals(""String_Node_Str"",10,hc.getTotalFileSize());
  hc.refresh();
  assertEquals(""String_Node_Str"",1,hc.getNumFiles());
  assertEquals(""String_Node_Str"",1,hc.getNumHosts());
  assertEquals(""String_Node_Str"",10,hc.getTotalFileSize());
  try {
    Thread.sleep(HorizonCounter.HORIZON_UPDATE_TIME * 2);
  }
 catch (  InterruptedException e) {
  }
  hc.refresh();
  assertEquals(""String_Node_Str"",1 + 2 + 3,hc.getNumFiles());
  assertEquals(""String_Node_Str"",3,hc.getNumHosts());
  assertEquals(""String_Node_Str"",10 + 20 + 30,hc.getTotalFileSize());
  try {
    Thread.sleep(HorizonCounter.HORIZON_UPDATE_TIME * 2);
  }
 catch (  InterruptedException e) {
  }
  hc.refresh();
  assertEquals(""String_Node_Str"",0,hc.getNumFiles());
  assertEquals(""String_Node_Str"",0,hc.getNumHosts());
  assertEquals(""String_Node_Str"",0,hc.getTotalFileSize());
  mc.close();
}",0.996298010180472
4522,"public static void globalSetUp() throws Exception {
  launchBackend();
}","public static void globalSetUp() throws Exception {
  setStandardSettings();
  UltrapeerSettings.FORCE_ULTRAPEER_MODE.setValue(false);
  UltrapeerSettings.EVER_ULTRAPEER_CAPABLE.setValue(false);
  ConnectionSettings.EVER_ACCEPTED_INCOMING.setValue(false);
  ConnectionSettings.NUM_CONNECTIONS.setValue(1);
  ConnectionSettings.WATCHDOG_ACTIVE.setValue(false);
  ConnectionSettings.ACCEPT_DEFLATE.setValue(true);
  ConnectionSettings.ENCODE_DEFLATE.setValue(true);
  ConnectionSettings.SEND_QRP.setValue(false);
  launchBackend();
  sleep(4000);
  ROUTER_SERVICE.start();
  RouterService.clearHostCatcher();
  RouterService.connect();
}",0.2036775106082037
4523,"public void setUp() throws Exception {
  if (ROUTER_SERVICE.isStarted())   return;
  sleep(4000);
  setStandardSettings();
  UltrapeerSettings.FORCE_ULTRAPEER_MODE.setValue(false);
  UltrapeerSettings.EVER_ULTRAPEER_CAPABLE.setValue(false);
  ConnectionSettings.EVER_ACCEPTED_INCOMING.setValue(false);
  ConnectionSettings.NUM_CONNECTIONS.setValue(1);
  ConnectionSettings.WATCHDOG_ACTIVE.setValue(false);
  ConnectionSettings.ACCEPT_DEFLATE.setValue(true);
  ConnectionSettings.ENCODE_DEFLATE.setValue(true);
  ROUTER_SERVICE.start();
  RouterService.clearHostCatcher();
  ROUTER_SERVICE.connect();
}","public void setUp() throws Exception {
}",0.1248049921996879
4524,"/** 
 * Tests the method for checking whether or not a connection is stable.
 */
public void testIsStable() throws Exception {
  Connection conn=new ManagedConnection(""String_Node_Str"",Backend.PORT);
  conn.initialize();
  assertTrue(""String_Node_Str"",!conn.isStable());
  Thread.sleep(6000);
  assertTrue(""String_Node_Str"",conn.isStable());
  conn.close();
}","/** 
 * Tests the method for checking whether or not a connection is stable.
 */
public void testIsStable() throws Exception {
  Connection conn=new ManagedConnection(""String_Node_Str"",Backend.BACKEND_PORT);
  conn.initialize();
  assertTrue(""String_Node_Str"",!conn.isStable());
  Thread.sleep(6000);
  assertTrue(""String_Node_Str"",conn.isStable());
  conn.close();
}",0.9889807162534436
4525,"/** 
 * Tests to make sure that connections are closed correctly from the client side.
 */
public void testClientSideClose() throws Exception {
  ManagedConnection out=null;
  Connection in=null;
  ConnectionManager manager=new ConnectionManagerStub(true);
  out=new ManagedConnection(""String_Node_Str"",Backend.PORT);
  out.initialize();
  out.buildAndStartQueues();
  assertTrue(""String_Node_Str"",out.isOpen());
  assertTrue(""String_Node_Str"",!out.runnerDied());
  out.close();
  sleep(100);
  assertTrue(""String_Node_Str"",!out.isOpen());
  assertTrue(""String_Node_Str"",out.runnerDied());
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
  }
}","/** 
 * Tests to make sure that connections are closed correctly from the client side.
 */
public void testClientSideClose() throws Exception {
  ManagedConnection out=null;
  out=new ManagedConnection(""String_Node_Str"",Backend.BACKEND_PORT);
  out.initialize();
  out.buildAndStartQueues();
  assertTrue(""String_Node_Str"",out.isOpen());
  assertTrue(""String_Node_Str"",!out.runnerDied());
  out.close();
  sleep(100);
  assertTrue(""String_Node_Str"",!out.isOpen());
  assertTrue(""String_Node_Str"",out.runnerDied());
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
  }
}",0.9277204130262112
4526,"/** 
 * Tests the method for checking whether or not the connection is a high- degree connection that maintains high numbers of intra-Ultrapeer  connections.
 */
public void testIsHighDegreeConnection() throws IOException {
  ManagedConnection mc=new ManagedConnection(""String_Node_Str"",Backend.PORT);
  mc.initialize();
  assertTrue(""String_Node_Str"",mc.isHighDegreeConnection());
  mc.close();
}","/** 
 * Tests the method for checking whether or not the connection is a high- degree connection that maintains high numbers of intra-Ultrapeer  connections.
 */
public void testIsHighDegreeConnection() throws IOException {
  ManagedConnection mc=new ManagedConnection(""String_Node_Str"",Backend.BACKEND_PORT);
  mc.initialize();
  assertTrue(""String_Node_Str"",mc.isHighDegreeConnection());
  mc.close();
}",0.9900249376558604
4527,"private void tForwardsGGEP() throws Exception {
  ManagedConnection out=new ManagedConnection(""String_Node_Str"",Backend.PORT);
  out.initialize();
  out.buildAndStartQueues();
  assertTrue(""String_Node_Str"",out.isOpen());
  assertTrue(""String_Node_Str"",out.supportsGGEP());
  out.receive();
  out.receive();
  out.send(new PingRequest((byte)3));
  Message m=out.receive();
  assertInstanceof(""String_Node_Str"",PingReply.class,m);
  PingReply pr=(PingReply)m;
  assertTrue(""String_Node_Str"",pr.hasGGEPExtension());
  assertTrue(""String_Node_Str"",!pr.supportsUnicast());
  assertTrue(""String_Node_Str"",pr.getDailyUptime() > 0);
  assertEquals(""String_Node_Str"",""String_Node_Str"",pr.getVendor());
  assertTrue(""String_Node_Str"",pr.hasGGEPExtension());
  out.close();
}","private void tForwardsGGEP() throws Exception {
  ManagedConnection out=new ManagedConnection(""String_Node_Str"",Backend.BACKEND_PORT);
  out.initialize();
  out.buildAndStartQueues();
  assertTrue(""String_Node_Str"",out.isOpen());
  assertTrue(""String_Node_Str"",out.supportsGGEP());
  out.receive();
  out.receive();
  out.send(new PingRequest((byte)3));
  Message m=out.receive();
  assertInstanceof(""String_Node_Str"",PingReply.class,m);
  PingReply pr=(PingReply)m;
  assertTrue(""String_Node_Str"",pr.hasGGEPExtension());
  assertTrue(""String_Node_Str"",!pr.supportsUnicast());
  assertTrue(""String_Node_Str"",pr.getDailyUptime() > 0);
  assertEquals(""String_Node_Str"",""String_Node_Str"",pr.getVendor());
  assertTrue(""String_Node_Str"",pr.hasGGEPExtension());
  out.close();
}",0.9947984395318596
4528,"/** 
 * Accessor for the <tt>Collection</tt> of Ultrapeers that have advertised free leaf slots.  The returned <tt>Collection</tt> is a complete copy of the hosts with free slots and can therefore be modified in any way.
 * @return a copy of the <tt>Collection</tt> of hosts that have advertised that they have free leaf slots
 */
public synchronized Collection getUltrapeersWithFreeLeafSlots(){
  return new HashSet(FREE_LEAF_SLOTS);
}","/** 
 * Accessor for the <tt>Collection</tt> of Ultrapeers that have advertised free leaf slots.  The returned <tt>Collection</tt> is a complete copy of the hosts with free slots and can therefore be modified in any way.
 * @return a copy of the <tt>Collection</tt> of hosts that have advertised that they have free leaf slots
 */
public Collection getUltrapeersWithFreeLeafSlots(){
synchronized (FREE_LEAF_SLOTS) {
    return new HashSet(FREE_LEAF_SLOTS);
  }
}",0.8975501113585747
4529,"public void run(){
  if (_automaticConnectTime < _disconnectTime) {
    return;
  }
  ConnectionManager cm=RouterService.getConnectionManager();
  if (!cm.isConnected()) {
    cm.connect();
  }
}","public void run(){
  if (_automaticConnectTime < _disconnectTime) {
    return;
  }
  if (!RouterService.isConnected()) {
    recoverHosts();
    connect();
  }
}",0.7843137254901961
4530,"/** 
 * Initializes an outgoing connection created by a ConnectionFetcher Throws any of the exceptions listed in Connection.initialize on failure; no cleanup is necessary in this case.
 * @exception IOException we were unable to establish a TCP connectionto the host
 * @exception NoGnutellaOkException we were able to establish a messaging connection but were rejected
 * @exception BadHandshakeException some other problem establishing the connection, e.g., the server responded with HTTP, closed the the connection during handshaking, etc. 
 * @see com.limegroup.gnutella.Connection#initialize(int)
 */
private void initializeFetchedConnection(ManagedConnection mc,ConnectionFetcher fetcher) throws NoGnutellaOkException, BadHandshakeException, IOException {
synchronized (this) {
    if (fetcher.isInterrupted()) {
      throw new IOException(""String_Node_Str"");
    }
    _initializingFetchedConnections.add(mc);
    _fetchers.remove(fetcher);
    connectionInitializing(mc);
  }
  RouterService.getCallback().connectionInitializing(mc);
  try {
    _connectionAttempts++;
    mc.initialize();
  }
 catch (  IOException e) {
synchronized (ConnectionManager.this) {
      _initializingFetchedConnections.remove(mc);
      removeInternal(mc);
      adjustConnectionFetchers();
    }
    throw e;
  }
 finally {
    processConnectionHeaders(mc);
  }
  completeConnectionInitialization(mc,true);
}","/** 
 * Initializes an outgoing connection created by a ConnectionFetcher Throws any of the exceptions listed in Connection.initialize on failure; no cleanup is necessary in this case.
 * @exception IOException we were unable to establish a TCP connectionto the host
 * @exception NoGnutellaOkException we were able to establish a messaging connection but were rejected
 * @exception BadHandshakeException some other problem establishing the connection, e.g., the server responded with HTTP, closed the the connection during handshaking, etc. 
 * @see com.limegroup.gnutella.Connection#initialize(int)
 */
private void initializeFetchedConnection(ManagedConnection mc,ConnectionFetcher fetcher) throws NoGnutellaOkException, BadHandshakeException, IOException {
synchronized (this) {
    if (fetcher.isInterrupted()) {
      throw new IOException(""String_Node_Str"");
    }
    _initializingFetchedConnections.add(mc);
    _fetchers.remove(fetcher);
    connectionInitializing(mc);
  }
  RouterService.getCallback().connectionInitializing(mc);
  try {
    mc.initialize();
  }
 catch (  IOException e) {
synchronized (ConnectionManager.this) {
      _initializingFetchedConnections.remove(mc);
      removeInternal(mc);
      adjustConnectionFetchers();
    }
    throw e;
  }
 finally {
    processConnectionHeaders(mc);
  }
  completeConnectionInitialization(mc,true);
}",0.990249187432286
4531,"/** 
 * This method notifies the connection manager that the user does not have a live connection to the Internet to the best of our determination. In this case, we notify the user with a message and maintain any  Gnutella hosts we have already tried instead of discarding them.
 */
public void noInternetConnection(){
  if (_automaticallyConnecting) {
    if (_catcher != null && (_catcher.getNumHosts() < 50)) {
      _catcher.recoverHosts();
    }
    return;
  }
  if (SystemUtils.supportsIdleTime() && SystemUtils.getIdleTime() < 30 * 1000 && !QuestionsHandler.NO_INTERNET.getValue()) {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET);
  }
 else {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET_RETRYING);
    RouterService.schedule(new Runnable(){
      public void run(){
        if (_automaticConnectTime < _disconnectTime) {
          return;
        }
        ConnectionManager cm=RouterService.getConnectionManager();
        if (!cm.isConnected()) {
          cm.connect();
        }
      }
    }
,10 * 1000,60 * 1000);
    _automaticConnectTime=System.currentTimeMillis();
    _automaticallyConnecting=true;
  }
  _noInternetConnection=true;
  disconnect();
  if (_catcher != null) {
    _catcher.recoverHosts();
  }
}","/** 
 * This method notifies the connection manager that the user does not have a live connection to the Internet to the best of our determination. In this case, we notify the user with a message and maintain any  Gnutella hosts we have already tried instead of discarding them.
 */
public void noInternetConnection(){
  if (_automaticallyConnecting) {
    return;
  }
  if (SystemUtils.supportsIdleTime() && SystemUtils.getIdleTime() < 30 * 1000 && !QuestionsHandler.NO_INTERNET.getValue()) {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET);
  }
 else {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET_RETRYING);
    disconnect();
    RouterService.schedule(new Runnable(){
      public void run(){
        if (_automaticConnectTime < _disconnectTime) {
          return;
        }
        if (!RouterService.isConnected()) {
          recoverHosts();
          connect();
        }
      }
    }
,10 * 1000,60 * 1000);
    _automaticConnectTime=System.currentTimeMillis();
    _automaticallyConnecting=true;
  }
  recoverHosts();
}",0.8453781512605042
4532,"/** 
 * Connects to the network.  Ensures the number of messaging connections (keep-alive) is non-zero and recontacts the pong server as needed.  
 */
public synchronized void connect(){
  _disconnectTime=0;
  if (isConnected()) {
    return;
  }
  _connectionAttempts=0;
  _noInternetConnection=false;
  _lastConnectionCheck=0;
  _lastSuccessfulConnect=0;
  long fetched=ConnectionSettings.LAST_GWEBCACHE_FETCH_TIME.getValue();
  if (fetched + DataUtils.ONE_WEEK <= System.currentTimeMillis()) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + fetched);
    _catcher.expire();
  }
  int outgoing=ConnectionSettings.NUM_CONNECTIONS.getValue();
  if (outgoing < 1) {
    ConnectionSettings.NUM_CONNECTIONS.revertToDefault();
    outgoing=ConnectionSettings.NUM_CONNECTIONS.getValue();
  }
  setKeepAlive(outgoing);
}","/** 
 * Connects to the network.  Ensures the number of messaging connections (keep-alive) is non-zero and recontacts the pong server as needed.  
 */
public synchronized void connect(){
  _disconnectTime=0;
  if (isConnected()) {
    return;
  }
  recoverHosts();
  _connectionAttempts=0;
  _lastConnectionCheck=0;
  _lastSuccessfulConnect=0;
  long fetched=ConnectionSettings.LAST_GWEBCACHE_FETCH_TIME.getValue();
  if (fetched + DataUtils.ONE_WEEK <= System.currentTimeMillis()) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + fetched);
    _catcher.expire();
  }
  int outgoing=ConnectionSettings.NUM_CONNECTIONS.getValue();
  if (outgoing < 1) {
    ConnectionSettings.NUM_CONNECTIONS.revertToDefault();
    outgoing=ConnectionSettings.NUM_CONNECTIONS.getValue();
  }
  setKeepAlive(outgoing);
}",0.9709887507400828
4533,"public void testSendsPushRequest() throws Exception {
  drain(testUP);
  final byte[] clientGUID=GUID.makeGuid();
  byte[] guid=GUID.makeGuid();
  rs.query(guid,""String_Node_Str"");
  Message m=null;
  do {
    m=testUP.receive(TIMEOUT);
  }
 while (!(m instanceof QueryRequest));
  final Set proxies=new HashSet();
  proxies.add(new QueryReply.PushProxyContainer(""String_Node_Str"",7001));
  Response[] res=new Response[1];
  res[0]=new Response(10,10,""String_Node_Str"");
  m=new QueryReply(m.getGUID(),(byte)1,7000,InetAddress.getLocalHost().getAddress(),0,res,clientGUID,new byte[0],false,false,true,true,false,false,proxies);
  testUP.send(m);
  testUP.flush();
  Thread.sleep(1000);
  assertTrue(callback.getRFD() != null);
  rs.doAsynchronousBrowseHost(callback.getRFD().getHost(),callback.getRFD().getPort(),new GUID(GUID.makeGuid()),new GUID(clientGUID),proxies);
  do {
    m=testUP.receive(TIMEOUT * 5);
  }
 while (!(m instanceof PushRequest));
}","public void testSendsPushRequest() throws Exception {
  drain(testUP);
  final byte[] clientGUID=GUID.makeGuid();
  byte[] guid=GUID.makeGuid();
  RouterService.query(guid,""String_Node_Str"");
  Message m=null;
  do {
    m=testUP.receive(TIMEOUT);
  }
 while (!(m instanceof QueryRequest));
  final Set proxies=new HashSet();
  proxies.add(new QueryReply.PushProxyContainer(""String_Node_Str"",7001));
  Response[] res=new Response[1];
  res[0]=new Response(10,10,""String_Node_Str"");
  m=new QueryReply(m.getGUID(),(byte)1,7000,InetAddress.getLocalHost().getAddress(),0,res,clientGUID,new byte[0],false,false,true,true,false,false,proxies);
  testUP.send(m);
  testUP.flush();
  Thread.sleep(1000);
  assertTrue(callback.getRFD() != null);
  RouterService.doAsynchronousBrowseHost(callback.getRFD().getHost(),callback.getRFD().getPort(),new GUID(GUID.makeGuid()),new GUID(clientGUID),proxies);
  do {
    m=testUP.receive(TIMEOUT * 5);
  }
 while (!(m instanceof PushRequest));
}",0.984472049689441
4534,"public void testPushProxyRequest() throws Exception {
  drain(testUP);
  final byte[] clientGUID=GUID.makeGuid();
  byte[] guid=GUID.makeGuid();
  rs.query(guid,""String_Node_Str"");
  Message m=null;
  do {
    m=testUP.receive(TIMEOUT);
  }
 while (!(m instanceof QueryRequest));
  ServerSocket ss=new ServerSocket(7000);
  ss.setReuseAddress(true);
  ss.setSoTimeout(TIMEOUT * 4);
  final Set proxies=new HashSet();
  proxies.add(new QueryReply.PushProxyContainer(""String_Node_Str"",7000));
  Response[] res=new Response[1];
  res[0]=new Response(10,10,""String_Node_Str"");
  m=new QueryReply(m.getGUID(),(byte)1,6999,InetAddress.getLocalHost().getAddress(),0,res,clientGUID,new byte[0],false,false,true,true,false,false,proxies);
  testUP.send(m);
  testUP.flush();
  Thread.sleep(1000);
  assertTrue(callback.getRFD() != null);
  rs.doAsynchronousBrowseHost(callback.getRFD().getHost(),callback.getRFD().getPort(),new GUID(GUID.makeGuid()),new GUID(clientGUID),proxies);
  Socket httpSock=ss.accept();
  assertNotNull(httpSock);
  BufferedWriter sockWriter=new BufferedWriter(new OutputStreamWriter(httpSock.getOutputStream()));
  sockWriter.write(""String_Node_Str"");
  sockWriter.flush();
  String currLine=null;
  BufferedReader reader=new BufferedReader(new InputStreamReader(httpSock.getInputStream()));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str"") || currLine.startsWith(""String_Node_Str""));
  int beginIndex=currLine.indexOf(""String_Node_Str"") + 3;
  String guidString=currLine.substring(beginIndex,beginIndex + 26);
  GUID guidFromBackend=new GUID(clientGUID);
  GUID guidFromNetwork=new GUID(Base32.decode(guidString));
  assertEquals(guidFromNetwork,guidFromBackend);
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  StringTokenizer st=new StringTokenizer(currLine,""String_Node_Str"");
  assertEquals(st.nextToken(),""String_Node_Str"");
  InetAddress addr=InetAddress.getByName(st.nextToken().trim());
  Arrays.equals(addr.getAddress(),rs.getAddress());
  assertEquals(Integer.parseInt(st.nextToken()),PORT);
  Socket push=new Socket(InetAddress.getLocalHost(),PORT);
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(push.getOutputStream()));
  writer.write(""String_Node_Str"" + new GUID(clientGUID).toHexString() + ""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.flush();
  reader=new BufferedReader(new InputStreamReader(push.getInputStream()));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  st=new StringTokenizer(currLine,""String_Node_Str"");
  assertEquals(st.nextToken(),""String_Node_Str"");
  addr=InetAddress.getByName(st.nextToken().trim());
  Arrays.equals(addr.getAddress(),rs.getAddress());
  assertEquals(Integer.parseInt(st.nextToken()),PORT);
  Thread.sleep(500);
  writer=new BufferedWriter(new OutputStreamWriter(push.getOutputStream()));
  writer.write(""String_Node_Str"");
  writer.flush();
  writer.write(""String_Node_Str"");
  writer.flush();
  httpSock.close();
  try {
    do {
      m=testUP.receive(TIMEOUT);
      assertNotInstanceof(m.toString(),PushRequest.class,m);
    }
 while (true);
  }
 catch (  InterruptedIOException expected) {
  }
  ss.close();
}","public void testPushProxyRequest() throws Exception {
  drain(testUP);
  final byte[] clientGUID=GUID.makeGuid();
  byte[] guid=GUID.makeGuid();
  RouterService.query(guid,""String_Node_Str"");
  Message m=null;
  do {
    m=testUP.receive(TIMEOUT);
  }
 while (!(m instanceof QueryRequest));
  ServerSocket ss=new ServerSocket(7000);
  ss.setReuseAddress(true);
  ss.setSoTimeout(TIMEOUT * 4);
  final Set proxies=new HashSet();
  proxies.add(new QueryReply.PushProxyContainer(""String_Node_Str"",7000));
  Response[] res=new Response[1];
  res[0]=new Response(10,10,""String_Node_Str"");
  m=new QueryReply(m.getGUID(),(byte)1,6999,InetAddress.getLocalHost().getAddress(),0,res,clientGUID,new byte[0],false,false,true,true,false,false,proxies);
  testUP.send(m);
  testUP.flush();
  Thread.sleep(1000);
  assertTrue(callback.getRFD() != null);
  RouterService.doAsynchronousBrowseHost(callback.getRFD().getHost(),callback.getRFD().getPort(),new GUID(GUID.makeGuid()),new GUID(clientGUID),proxies);
  Socket httpSock=ss.accept();
  assertNotNull(httpSock);
  BufferedWriter sockWriter=new BufferedWriter(new OutputStreamWriter(httpSock.getOutputStream()));
  sockWriter.write(""String_Node_Str"");
  sockWriter.flush();
  String currLine=null;
  BufferedReader reader=new BufferedReader(new InputStreamReader(httpSock.getInputStream()));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str"") || currLine.startsWith(""String_Node_Str""));
  int beginIndex=currLine.indexOf(""String_Node_Str"") + 3;
  String guidString=currLine.substring(beginIndex,beginIndex + 26);
  GUID guidFromBackend=new GUID(clientGUID);
  GUID guidFromNetwork=new GUID(Base32.decode(guidString));
  assertEquals(guidFromNetwork,guidFromBackend);
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  StringTokenizer st=new StringTokenizer(currLine,""String_Node_Str"");
  assertEquals(st.nextToken(),""String_Node_Str"");
  InetAddress addr=InetAddress.getByName(st.nextToken().trim());
  Arrays.equals(addr.getAddress(),RouterService.getAddress());
  assertEquals(Integer.parseInt(st.nextToken()),SERVER_PORT);
  Socket push=new Socket(InetAddress.getLocalHost(),SERVER_PORT);
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(push.getOutputStream()));
  writer.write(""String_Node_Str"" + new GUID(clientGUID).toHexString() + ""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.flush();
  reader=new BufferedReader(new InputStreamReader(push.getInputStream()));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  st=new StringTokenizer(currLine,""String_Node_Str"");
  assertEquals(st.nextToken(),""String_Node_Str"");
  addr=InetAddress.getByName(st.nextToken().trim());
  Arrays.equals(addr.getAddress(),RouterService.getAddress());
  assertEquals(Integer.parseInt(st.nextToken()),SERVER_PORT);
  Thread.sleep(500);
  writer=new BufferedWriter(new OutputStreamWriter(push.getOutputStream()));
  writer.write(""String_Node_Str"");
  writer.flush();
  writer.write(""String_Node_Str"");
  writer.flush();
  httpSock.close();
  try {
    do {
      m=testUP.receive(TIMEOUT);
      assertNotInstanceof(m.toString(),PushRequest.class,m);
    }
 while (true);
  }
 catch (  InterruptedIOException expected) {
  }
  ss.close();
}",0.987912251902701
4535,"public static void globalSetUp() throws Exception {
  doSettings();
  callback=new MyActivityCallback();
  rs=new RouterService(callback);
  assertEquals(""String_Node_Str"",PORT,ConnectionSettings.PORT.getValue());
  rs.start();
  rs.clearHostCatcher();
  rs.connect();
  Thread.sleep(1000);
  assertEquals(""String_Node_Str"",PORT,ConnectionSettings.PORT.getValue());
  connect(rs);
  testUP=connect(rs,6355,true);
}","public static void globalSetUp() throws Exception {
  doSettings();
  callback=new MyActivityCallback();
  rs=new RouterService(callback);
  assertEquals(""String_Node_Str"",SERVER_PORT,ConnectionSettings.PORT.getValue());
  rs.start();
  RouterService.clearHostCatcher();
  RouterService.connect();
  Thread.sleep(1000);
  assertEquals(""String_Node_Str"",SERVER_PORT,ConnectionSettings.PORT.getValue());
  connect();
  testUP=connect(6355,true);
}",0.9429569266589056
4536,"private static void doSettings(){
  ConnectionSettings.PORT.setValue(PORT);
  ConnectionSettings.CONNECT_ON_STARTUP.setValue(false);
  UltrapeerSettings.EVER_ULTRAPEER_CAPABLE.setValue(false);
  UltrapeerSettings.DISABLE_ULTRAPEER_MODE.setValue(true);
  UltrapeerSettings.FORCE_ULTRAPEER_MODE.setValue(false);
  ConnectionSettings.NUM_CONNECTIONS.setValue(0);
  ConnectionSettings.LOCAL_IS_PRIVATE.setValue(false);
  SharingSettings.EXTENSIONS_TO_SHARE.setValue(""String_Node_Str"");
  ConnectionSettings.USE_GWEBCACHE.setValue(false);
  ConnectionSettings.WATCHDOG_ACTIVE.setValue(false);
  File berkeley=CommonUtils.getResourceFile(""String_Node_Str"");
  File susheel=CommonUtils.getResourceFile(""String_Node_Str"");
  CommonUtils.copy(berkeley,new File(_sharedDir,""String_Node_Str""));
  CommonUtils.copy(susheel,new File(_sharedDir,""String_Node_Str""));
  SearchSettings.MINIMUM_SEARCH_QUALITY.setValue(-2);
}","private static void doSettings(){
  ConnectionSettings.PORT.setValue(SERVER_PORT);
  ConnectionSettings.CONNECT_ON_STARTUP.setValue(false);
  UltrapeerSettings.EVER_ULTRAPEER_CAPABLE.setValue(false);
  UltrapeerSettings.DISABLE_ULTRAPEER_MODE.setValue(true);
  UltrapeerSettings.FORCE_ULTRAPEER_MODE.setValue(false);
  ConnectionSettings.NUM_CONNECTIONS.setValue(0);
  ConnectionSettings.LOCAL_IS_PRIVATE.setValue(false);
  SharingSettings.EXTENSIONS_TO_SHARE.setValue(""String_Node_Str"");
  ConnectionSettings.USE_GWEBCACHE.setValue(false);
  ConnectionSettings.WATCHDOG_ACTIVE.setValue(false);
  File berkeley=CommonUtils.getResourceFile(""String_Node_Str"");
  File susheel=CommonUtils.getResourceFile(""String_Node_Str"");
  CommonUtils.copy(berkeley,new File(_sharedDir,""String_Node_Str""));
  CommonUtils.copy(susheel,new File(_sharedDir,""String_Node_Str""));
  SearchSettings.MINIMUM_SEARCH_QUALITY.setValue(-2);
}",0.9961559582646896
4537,"public void testHTTPRequest() throws Exception {
  drain(testUP);
  final byte[] clientGUID=GUID.makeGuid();
  byte[] guid=GUID.makeGuid();
  rs.query(guid,""String_Node_Str"");
  Message m=null;
  do {
    m=testUP.receive(TIMEOUT);
  }
 while (!(m instanceof QueryRequest));
  ServerSocket ss=new ServerSocket(7000);
  ss.setReuseAddress(true);
  ss.setSoTimeout(TIMEOUT);
  PushProxyInterface[] proxies=new QueryReply.PushProxyContainer[1];
  proxies[0]=new QueryReply.PushProxyContainer(""String_Node_Str"",7000);
  Response[] res=new Response[1];
  res[0]=new Response(10,10,""String_Node_Str"");
  m=new QueryReply(m.getGUID(),(byte)1,7000,InetAddress.getLocalHost().getAddress(),0,res,clientGUID,new byte[0],false,false,true,true,false,false,null);
  testUP.send(m);
  testUP.flush();
  Thread.sleep(1000);
  assertNotNull(callback.getRFD());
  rs.doAsynchronousBrowseHost(callback.getRFD().getHost(),callback.getRFD().getPort(),new GUID(GUID.makeGuid()),new GUID(clientGUID),null);
  Socket httpSock=ss.accept();
  assertNotNull(httpSock);
  String currLine=null;
  BufferedReader reader=new BufferedReader(new InputStreamReader(httpSock.getInputStream()));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  StringTokenizer st=new StringTokenizer(currLine,""String_Node_Str"");
  assertEquals(st.nextToken(),""String_Node_Str"");
  InetAddress addr=InetAddress.getByName(st.nextToken().trim());
  Arrays.equals(addr.getAddress(),rs.getAddress());
  assertEquals(Integer.parseInt(st.nextToken()),PORT);
  Thread.sleep(500);
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(httpSock.getOutputStream()));
  writer.write(""String_Node_Str"");
  writer.flush();
  writer.write(""String_Node_Str"");
  writer.flush();
  httpSock.close();
  try {
    do {
      m=testUP.receive(TIMEOUT);
      assertTrue(!(m instanceof PushRequest));
    }
 while (true);
  }
 catch (  InterruptedIOException expected) {
  }
  ss.close();
}","public void testHTTPRequest() throws Exception {
  drain(testUP);
  final byte[] clientGUID=GUID.makeGuid();
  byte[] guid=GUID.makeGuid();
  RouterService.query(guid,""String_Node_Str"");
  Message m=null;
  do {
    m=testUP.receive(TIMEOUT);
  }
 while (!(m instanceof QueryRequest));
  ServerSocket ss=new ServerSocket(7000);
  ss.setReuseAddress(true);
  ss.setSoTimeout(TIMEOUT);
  PushProxyInterface[] proxies=new QueryReply.PushProxyContainer[1];
  proxies[0]=new QueryReply.PushProxyContainer(""String_Node_Str"",7000);
  Response[] res=new Response[1];
  res[0]=new Response(10,10,""String_Node_Str"");
  m=new QueryReply(m.getGUID(),(byte)1,7000,InetAddress.getLocalHost().getAddress(),0,res,clientGUID,new byte[0],false,false,true,true,false,false,null);
  testUP.send(m);
  testUP.flush();
  Thread.sleep(1000);
  assertNotNull(callback.getRFD());
  RouterService.doAsynchronousBrowseHost(callback.getRFD().getHost(),callback.getRFD().getPort(),new GUID(GUID.makeGuid()),new GUID(clientGUID),null);
  Socket httpSock=ss.accept();
  assertNotNull(httpSock);
  String currLine=null;
  BufferedReader reader=new BufferedReader(new InputStreamReader(httpSock.getInputStream()));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  currLine=reader.readLine();
  assertTrue(currLine.startsWith(""String_Node_Str""));
  StringTokenizer st=new StringTokenizer(currLine,""String_Node_Str"");
  assertEquals(st.nextToken(),""String_Node_Str"");
  InetAddress addr=InetAddress.getByName(st.nextToken().trim());
  Arrays.equals(addr.getAddress(),RouterService.getAddress());
  assertEquals(Integer.parseInt(st.nextToken()),SERVER_PORT);
  Thread.sleep(500);
  BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(httpSock.getOutputStream()));
  writer.write(""String_Node_Str"");
  writer.flush();
  writer.write(""String_Node_Str"");
  writer.flush();
  httpSock.close();
  try {
    do {
      m=testUP.receive(TIMEOUT);
      assertTrue(!(m instanceof PushRequest));
    }
 while (true);
  }
 catch (  InterruptedIOException expected) {
  }
  ss.close();
}",0.9874335427742872
4538,"private static Connection connect(RouterService rs,int port,boolean ultrapeer) throws IOException, BadPacketException, Exception {
  ServerSocket ss=new ServerSocket(port);
  rs.connectToHostAsynchronously(""String_Node_Str"",port);
  Socket socket=ss.accept();
  ss.close();
  socket.setSoTimeout(3000);
  InputStream in=socket.getInputStream();
  String word=readWord(in);
  if (!word.equals(""String_Node_Str""))   throw new IOException(""String_Node_Str"" + word);
  HandshakeResponder responder;
  if (ultrapeer) {
    responder=new UltrapeerResponder();
  }
 else {
    responder=new OldResponder();
  }
  Connection con=new Connection(socket,responder);
  con.initialize();
  replyToPing(con,ultrapeer);
  return con;
}","private static Connection connect(int port,boolean ultrapeer) throws IOException, BadPacketException, Exception {
  ServerSocket ss=new ServerSocket(port);
  RouterService.connectToHostAsynchronously(""String_Node_Str"",port);
  Socket socket=ss.accept();
  ss.close();
  socket.setSoTimeout(3000);
  InputStream in=socket.getInputStream();
  String word=readWord(in);
  if (!word.equals(""String_Node_Str""))   throw new IOException(""String_Node_Str"" + word);
  HandshakeResponder responder;
  if (ultrapeer) {
    responder=new UltrapeerResponder();
  }
 else {
    responder=new OldResponder();
  }
  Connection con=new Connection(socket,responder);
  con.initialize();
  replyToPing(con,ultrapeer);
  return con;
}",0.9776847977684798
4539,"public void testAdvancedGuidance1() throws Exception {
  for (int i=0; i < testUPs.length; i++)   drain(testUPs[i]);
  GUID queryGuid=new GUID(rs.newQueryGUID());
  rs.query(queryGuid.bytes(),""String_Node_Str"");
  for (int i=0; i < testUPs.length; i++) {
    QueryRequest qr=getFirstQueryRequest(testUPs[i]);
    assertNotNull(qr);
    assertEquals(new GUID(qr.getGUID()),queryGuid);
  }
  Message m=null;
  for (int i=0; i < testUPs.length; i++) {
    Response[] res=new Response[REPORT_INTERVAL * 3];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10,10,""String_Node_Str"" + i + j);
    m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUPs[i].send(m);
    testUPs[i].flush();
  }
  boolean maxResultsEncountered=false;
  for (int i=0; i < testUPs.length; i++) {
    for (int j=0; j < testUPs.length; j++) {
      QueryStatusResponse stat=getFirstQueryStatus(testUPs[j]);
      assertNotNull(stat);
      assertEquals(new GUID(stat.getGUID()),queryGuid);
      assertTrue((stat.getNumResults() == 11 * (i + 1)) || (stat.getNumResults() == MAX_RESULTS));
      if (stat.getNumResults() == MAX_RESULTS) {
        assertTrue(i == testUPs.length - 1);
        maxResultsEncountered=true;
      }
    }
  }
  assertTrue(maxResultsEncountered);
  Response[] res=new Response[REPORT_INTERVAL * 4];
  for (int j=0; j < res.length; j++)   res[j]=new Response(10,10,""String_Node_Str"" + j);
  m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
  testUPs[0].send(m);
  testUPs[0].flush();
  for (int i=0; i < testUPs.length; i++) {
    final int index=i;
    Thread newThread=new Thread(){
      public void run(){
        try {
          QueryStatusResponse stat=getFirstQueryStatus(testUPs[index]);
          assertNull(stat);
        }
 catch (        Exception e) {
          assertNull(e);
        }
      }
    }
;
    newThread.start();
  }
}","public void testAdvancedGuidance1() throws Exception {
  for (int i=0; i < testUPs.length; i++)   drain(testUPs[i]);
  GUID queryGuid=new GUID(RouterService.newQueryGUID());
  RouterService.query(queryGuid.bytes(),""String_Node_Str"");
  for (int i=0; i < testUPs.length; i++) {
    QueryRequest qr=getFirstQueryRequest(testUPs[i]);
    assertNotNull(qr);
    assertEquals(new GUID(qr.getGUID()),queryGuid);
  }
  Message m=null;
  for (int i=0; i < testUPs.length; i++) {
    Response[] res=new Response[REPORT_INTERVAL * 3];
    for (int j=0; j < res.length; j++)     res[j]=new Response(10,10,""String_Node_Str"" + i + j);
    m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUPs[i].send(m);
    testUPs[i].flush();
  }
  boolean maxResultsEncountered=false;
  for (int i=0; i < testUPs.length; i++) {
    for (int j=0; j < testUPs.length; j++) {
      QueryStatusResponse stat=getFirstQueryStatus(testUPs[j]);
      assertNotNull(stat);
      assertEquals(new GUID(stat.getGUID()),queryGuid);
      assertTrue((stat.getNumResults() == 11 * (i + 1)) || (stat.getNumResults() == MAX_RESULTS));
      if (stat.getNumResults() == MAX_RESULTS) {
        assertTrue(i == testUPs.length - 1);
        maxResultsEncountered=true;
      }
    }
  }
  assertTrue(maxResultsEncountered);
  Response[] res=new Response[REPORT_INTERVAL * 4];
  for (int j=0; j < res.length; j++)   res[j]=new Response(10,10,""String_Node_Str"" + j);
  m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
  testUPs[0].send(m);
  testUPs[0].flush();
  for (int i=0; i < testUPs.length; i++) {
    final int index=i;
    Thread newThread=new Thread(){
      public void run(){
        try {
          QueryStatusResponse stat=getFirstQueryStatus(testUPs[index]);
          assertNull(stat);
        }
 catch (        Exception e) {
          assertNull(e);
        }
      }
    }
;
    newThread.start();
  }
}",0.9926181102362204
4540,"public void testAdvancedGuidance2() throws Exception {
  Message m=null;
  for (int i=0; i < testUPs.length; i++)   drain(testUPs[i]);
  GUID queryGuid=new GUID(rs.newQueryGUID());
  rs.query(queryGuid.bytes(),""String_Node_Str"");
  for (int i=0; i < testUPs.length; i++) {
    QueryRequest qr=getFirstQueryRequest(testUPs[i]);
    assertNotNull(qr);
    assertEquals(new GUID(qr.getGUID()),queryGuid);
  }
  Response[] res=new Response[REPORT_INTERVAL * 4];
  for (int j=0; j < res.length; j++)   res[j]=new Response(10,10,""String_Node_Str"" + j);
  m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
  testUPs[0].send(m);
  testUPs[0].flush();
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNotNull(stat);
    assertEquals(new GUID(stat.getGUID()),queryGuid);
    assertEquals(REPORT_INTERVAL,stat.getNumResults());
  }
  res=new Response[REPORT_INTERVAL - 1];
  for (int j=0; j < res.length; j++)   res[j]=new Response(10,10,""String_Node_Str"" + j);
  m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
  testUPs[2].send(m);
  testUPs[2].flush();
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNull(stat);
  }
  res=new Response[2];
  for (int j=0; j < res.length; j++)   res[j]=new Response(10,10,""String_Node_Str"" + j);
  m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
  testUPs[1].send(m);
  testUPs[1].flush();
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNotNull(stat);
    assertEquals(new GUID(stat.getGUID()),queryGuid);
    assertEquals(REPORT_INTERVAL + ((REPORT_INTERVAL + 1) / 4),stat.getNumResults());
  }
  rs.stopQuery(queryGuid);
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNotNull(stat);
    assertEquals(new GUID(stat.getGUID()),queryGuid);
    assertEquals(65535,stat.getNumResults());
  }
  res=new Response[REPORT_INTERVAL * 2];
  for (int j=0; j < res.length; j++)   res[j]=new Response(10,10,""String_Node_Str"" + j);
  m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
  testUPs[0].send(m);
  testUPs[0].flush();
  for (int i=0; i < testUPs.length; i++) {
    final int index=i;
    Thread newThread=new Thread(){
      public void run(){
        try {
          QueryStatusResponse stat=getFirstQueryStatus(testUPs[index]);
          assertNull(stat);
        }
 catch (        Exception e) {
          assertNull(e);
        }
      }
    }
;
    newThread.start();
  }
}","public void testAdvancedGuidance2() throws Exception {
  Message m=null;
  for (int i=0; i < testUPs.length; i++)   drain(testUPs[i]);
  GUID queryGuid=new GUID(RouterService.newQueryGUID());
  RouterService.query(queryGuid.bytes(),""String_Node_Str"");
  for (int i=0; i < testUPs.length; i++) {
    QueryRequest qr=getFirstQueryRequest(testUPs[i]);
    assertNotNull(qr);
    assertEquals(new GUID(qr.getGUID()),queryGuid);
  }
  Response[] res=new Response[REPORT_INTERVAL * 4];
  for (int j=0; j < res.length; j++)   res[j]=new Response(10,10,""String_Node_Str"" + j);
  m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
  testUPs[0].send(m);
  testUPs[0].flush();
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNotNull(stat);
    assertEquals(new GUID(stat.getGUID()),queryGuid);
    assertEquals(REPORT_INTERVAL,stat.getNumResults());
  }
  res=new Response[REPORT_INTERVAL - 1];
  for (int j=0; j < res.length; j++)   res[j]=new Response(10,10,""String_Node_Str"" + j);
  m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
  testUPs[2].send(m);
  testUPs[2].flush();
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNull(stat);
  }
  res=new Response[2];
  for (int j=0; j < res.length; j++)   res[j]=new Response(10,10,""String_Node_Str"" + j);
  m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
  testUPs[1].send(m);
  testUPs[1].flush();
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNotNull(stat);
    assertEquals(new GUID(stat.getGUID()),queryGuid);
    assertEquals(REPORT_INTERVAL + ((REPORT_INTERVAL + 1) / 4),stat.getNumResults());
  }
  RouterService.stopQuery(queryGuid);
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNotNull(stat);
    assertEquals(new GUID(stat.getGUID()),queryGuid);
    assertEquals(65535,stat.getNumResults());
  }
  res=new Response[REPORT_INTERVAL * 2];
  for (int j=0; j < res.length; j++)   res[j]=new Response(10,10,""String_Node_Str"" + j);
  m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
  testUPs[0].send(m);
  testUPs[0].flush();
  for (int i=0; i < testUPs.length; i++) {
    final int index=i;
    Thread newThread=new Thread(){
      public void run(){
        try {
          QueryStatusResponse stat=getFirstQueryStatus(testUPs[index]);
          assertNull(stat);
        }
 catch (        Exception e) {
          assertNull(e);
        }
      }
    }
;
    newThread.start();
  }
}",0.9922667124935556
4541,"public static void globalSetUp() throws Exception {
  doSettings();
  callback=new MyActivityCallback();
  rs=new RouterService(callback);
  assertEquals(""String_Node_Str"",PORT,ConnectionSettings.PORT.getValue());
  rs.start();
  rs.clearHostCatcher();
  rs.connect();
  Thread.sleep(1000);
  assertEquals(""String_Node_Str"",PORT,ConnectionSettings.PORT.getValue());
  connect(rs);
}","public static void globalSetUp() throws Exception {
  doSettings();
  callback=new MyActivityCallback();
  rs=new RouterService(callback);
  assertEquals(""String_Node_Str"",TEST_PORT,ConnectionSettings.PORT.getValue());
  rs.start();
  RouterService.clearHostCatcher();
  RouterService.connect();
  Thread.sleep(1000);
  assertEquals(""String_Node_Str"",TEST_PORT,ConnectionSettings.PORT.getValue());
  connect();
}",0.947103274559194
4542,"public void testBasicGuidance() throws Exception {
  for (int i=0; i < testUPs.length; i++) {
    testUPs[i]=connect(rs,6355 + i,true);
    testUPs[i].send(MessagesSupportedVendorMessage.instance());
    testUPs[i].flush();
    drain(testUPs[i]);
  }
  GUID queryGuid=new GUID(rs.newQueryGUID());
  rs.query(queryGuid.bytes(),""String_Node_Str"");
  Thread.sleep(250);
  for (int i=0; i < testUPs.length; i++) {
    QueryRequest qr=getFirstQueryRequest(testUPs[i]);
    assertNotNull(qr);
    assertEquals(new GUID(qr.getGUID()),queryGuid);
  }
  Message m=null;
  assertGreaterThan(REPORT_INTERVAL,4 * testUPs.length);
  for (int i=0; i < testUPs.length; i++) {
    Response[] res=new Response[4];
    res[0]=new Response(10,10,""String_Node_Str"" + i);
    res[1]=new Response(10,10,""String_Node_Str"" + i);
    res[2]=new Response(10,10,""String_Node_Str"" + i);
    res[3]=new Response(10,10,""String_Node_Str"" + i);
    m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUPs[i].send(m);
    testUPs[i].flush();
  }
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNotNull(stat);
    assertEquals(new GUID(stat.getGUID()),queryGuid);
    assertEquals(4,stat.getNumResults());
  }
  rs.stopQuery(queryGuid);
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNotNull(stat);
    assertEquals(new GUID(stat.getGUID()),queryGuid);
    assertEquals(65535,stat.getNumResults());
  }
}","public void testBasicGuidance() throws Exception {
  for (int i=0; i < testUPs.length; i++) {
    testUPs[i]=connect(6355 + i,true);
    testUPs[i].send(MessagesSupportedVendorMessage.instance());
    testUPs[i].flush();
    drain(testUPs[i]);
  }
  GUID queryGuid=new GUID(RouterService.newQueryGUID());
  RouterService.query(queryGuid.bytes(),""String_Node_Str"");
  Thread.sleep(250);
  for (int i=0; i < testUPs.length; i++) {
    QueryRequest qr=getFirstQueryRequest(testUPs[i]);
    assertNotNull(qr);
    assertEquals(new GUID(qr.getGUID()),queryGuid);
  }
  Message m=null;
  assertGreaterThan(REPORT_INTERVAL,4 * testUPs.length);
  for (int i=0; i < testUPs.length; i++) {
    Response[] res=new Response[4];
    res[0]=new Response(10,10,""String_Node_Str"" + i);
    res[1]=new Response(10,10,""String_Node_Str"" + i);
    res[2]=new Response(10,10,""String_Node_Str"" + i);
    res[3]=new Response(10,10,""String_Node_Str"" + i);
    m=new QueryReply(queryGuid.bytes(),(byte)1,6355,myIP(),0,res,GUID.makeGuid(),new byte[0],false,false,true,true,false,false,null);
    testUPs[i].send(m);
    testUPs[i].flush();
  }
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNotNull(stat);
    assertEquals(new GUID(stat.getGUID()),queryGuid);
    assertEquals(4,stat.getNumResults());
  }
  RouterService.stopQuery(queryGuid);
  for (int i=0; i < testUPs.length; i++) {
    QueryStatusResponse stat=getFirstQueryStatus(testUPs[i]);
    assertNotNull(stat);
    assertEquals(new GUID(stat.getGUID()),queryGuid);
    assertEquals(65535,stat.getNumResults());
  }
}",0.9850560398505604
4543,"private static void doSettings(){
  ConnectionSettings.PORT.setValue(PORT);
  ConnectionSettings.CONNECT_ON_STARTUP.setValue(false);
  UltrapeerSettings.EVER_ULTRAPEER_CAPABLE.setValue(false);
  UltrapeerSettings.DISABLE_ULTRAPEER_MODE.setValue(true);
  UltrapeerSettings.FORCE_ULTRAPEER_MODE.setValue(false);
  ConnectionSettings.NUM_CONNECTIONS.setValue(0);
  ConnectionSettings.LOCAL_IS_PRIVATE.setValue(false);
  SharingSettings.EXTENSIONS_TO_SHARE.setValue(""String_Node_Str"");
  File berkeley=CommonUtils.getResourceFile(""String_Node_Str"");
  File susheel=CommonUtils.getResourceFile(""String_Node_Str"");
  CommonUtils.copy(berkeley,new File(_sharedDir,""String_Node_Str""));
  CommonUtils.copy(susheel,new File(_sharedDir,""String_Node_Str""));
  SearchSettings.MINIMUM_SEARCH_QUALITY.setValue(-2);
}","private static void doSettings(){
  ConnectionSettings.PORT.setValue(TEST_PORT);
  ConnectionSettings.CONNECT_ON_STARTUP.setValue(false);
  UltrapeerSettings.EVER_ULTRAPEER_CAPABLE.setValue(false);
  UltrapeerSettings.DISABLE_ULTRAPEER_MODE.setValue(true);
  UltrapeerSettings.FORCE_ULTRAPEER_MODE.setValue(false);
  ConnectionSettings.NUM_CONNECTIONS.setValue(0);
  ConnectionSettings.LOCAL_IS_PRIVATE.setValue(false);
  SharingSettings.EXTENSIONS_TO_SHARE.setValue(""String_Node_Str"");
  File berkeley=CommonUtils.getResourceFile(""String_Node_Str"");
  File susheel=CommonUtils.getResourceFile(""String_Node_Str"");
  CommonUtils.copy(berkeley,new File(_sharedDir,""String_Node_Str""));
  CommonUtils.copy(susheel,new File(_sharedDir,""String_Node_Str""));
  SearchSettings.MINIMUM_SEARCH_QUALITY.setValue(-2);
}",0.9968886123210952
4544,"public void handleQueryResult(RemoteFileDesc rfd,HostData data,Set locs){
  this.rfd=rfd;
}","public void handleQueryResult(RemoteFileDesc rfdParam,HostData data,Set locs){
  this.rfd=rfdParam;
}",0.9479166666666666
4545,"private static Connection connect(RouterService rs,int port,boolean ultrapeer) throws Exception {
  ServerSocket ss=new ServerSocket(port);
  rs.connectToHostAsynchronously(""String_Node_Str"",port);
  Socket socket=ss.accept();
  ss.close();
  socket.setSoTimeout(3000);
  InputStream in=socket.getInputStream();
  String word=readWord(in);
  if (!word.equals(""String_Node_Str""))   throw new IOException(""String_Node_Str"" + word);
  HandshakeResponder responder;
  if (ultrapeer) {
    responder=new UltrapeerResponder();
  }
 else {
    responder=new OldResponder();
  }
  Connection con=new Connection(socket,responder);
  con.initialize();
  replyToPing(con,ultrapeer);
  return con;
}","private static Connection connect(int port,boolean ultrapeer) throws Exception {
  ServerSocket ss=new ServerSocket(port);
  RouterService.connectToHostAsynchronously(""String_Node_Str"",port);
  Socket socket=ss.accept();
  ss.close();
  socket.setSoTimeout(3000);
  InputStream in=socket.getInputStream();
  String word=readWord(in);
  if (!word.equals(""String_Node_Str""))   throw new IOException(""String_Node_Str"" + word);
  HandshakeResponder responder;
  if (ultrapeer) {
    responder=new UltrapeerResponder();
  }
 else {
    responder=new OldResponder();
  }
  Connection con=new Connection(socket,responder);
  con.initialize();
  replyToPing(con,ultrapeer);
  return con;
}",0.9766081871345028
4546,"/** 
 * @return the number of initialized connections, which is less than or equalsto the number of connections.
 */
public int getNumInitializedConnections(){
  return _initializedConnections.size();
}","/** 
 * @return the number of initialized connections, which is less than or equals to the number of connections.
 */
public int getNumInitializedConnections(){
  return _initializedConnections.size();
}",0.9975308641975308
4547,"/** 
 * This method notifies the connection manager that the user does not have a live connection to the Internet to the best of our determination. In this case, we notify the user with a message and maintain any  Gnutella hosts we have already tried instead of discarding them.
 */
public void noInternetConnection(){
  if (_automaticallyConnecting) {
    return;
  }
  if (SystemUtils.supportsIdleTime() && SystemUtils.getIdleTime() < 30 * 1000 && !QuestionsHandler.NO_INTERNET.getValue()) {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET);
  }
 else {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET_RETRYING);
    disconnect();
    RouterService.schedule(new Runnable(){
      public void run(){
        if (_automaticConnectTime < _disconnectTime) {
          return;
        }
        if (!RouterService.isConnected()) {
          recoverHosts();
          connect();
        }
      }
    }
,10 * 1000,60 * 1000);
    _automaticConnectTime=System.currentTimeMillis();
    _automaticallyConnecting=true;
  }
  recoverHosts();
}","/** 
 * This method notifies the connection manager that the user does not have a live connection to the Internet to the best of our determination. In this case, we notify the user with a message and maintain any  Gnutella hosts we have already tried instead of discarding them.
 */
public void noInternetConnection(){
  if (_automaticallyConnecting) {
    return;
  }
  if (SystemUtils.supportsIdleTime() && SystemUtils.getIdleTime() < 30 * 1000 && !QuestionsHandler.NO_INTERNET.getValue()) {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET);
  }
 else {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET_RETRYING);
    disconnect();
    RouterService.schedule(new Runnable(){
      public void run(){
        if (_automaticConnectTime < _disconnectTime) {
          return;
        }
        if (!RouterService.isConnected()) {
          recoverHosts();
          connect();
        }
      }
    }
,10 * 1000,2 * 60 * 1000);
    _automaticConnectTime=System.currentTimeMillis();
    _automaticallyConnecting=true;
  }
  recoverHosts();
}",0.9981684981684982
4548,"public static void globalTearDown() throws Exception {
  drain(CONN_1);
  CONN_1.close();
  ROUTER_SERVICE.disconnect();
}","public static void globalTearDown() throws Exception {
  drain(CONN_1);
  CONN_1.close();
  RouterService.disconnect();
}",0.9053497942386832
4549,"public static void globalSetUp() throws Exception {
  doSettings();
  ROUTER_SERVICE=new RouterService(new ActivityCallbackStub());
  ROUTER_SERVICE.start();
  ROUTER_SERVICE.connect();
  connect();
}","public static void globalSetUp() throws Exception {
  doSettings();
  ROUTER_SERVICE=new RouterService(new ActivityCallbackStub());
  ROUTER_SERVICE.start();
  RouterService.connect();
  connect();
}",0.9423558897243108
4550,"/** 
 * tests that we get a query reply from a file with the normalized name and also that we receive the actual file name in the queryreply
 */
public void testSendReceive() throws Exception {
  QueryRequest qr;
  QueryReply rp;
  qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  CONN_1.send(qr);
  CONN_1.flush();
  rp=getFirstQueryReply(CONN_1);
  assertTrue(""String_Node_Str"",!drain(CONN_1));
  drain(CONN_1);
  List expectedReply=new ArrayList();
  expectedReply.add(FILE_0);
  sendCheckQuery(expectedReply,""String_Node_Str"");
  expectedReply.add(FILE_2);
  expectedReply.add(FILE_3);
  expectedReply.add(FILE_4);
  sendCheckQuery(expectedReply,""String_Node_Str"");
  expectedReply.add(FILE_3);
  sendCheckQuery(expectedReply,""String_Node_Str"");
  expectedReply.add(FILE_1);
  sendCheckQuery(expectedReply,""String_Node_Str"");
  expectedReply.add(FILE_4);
  sendCheckQuery(expectedReply,""String_Node_Str"");
}","/** 
 * tests that we get a query reply from a file with the normalized name and also that we receive the actual file name in the queryreply
 */
public void testSendReceive() throws Exception {
  QueryRequest qr=QueryRequest.createQuery(""String_Node_Str"",(byte)2);
  CONN_1.send(qr);
  CONN_1.flush();
  getFirstQueryReply(CONN_1);
  assertTrue(""String_Node_Str"",!drain(CONN_1));
  drain(CONN_1);
  List expectedReply=new ArrayList();
  expectedReply.add(FILE_0);
  sendCheckQuery(expectedReply,""String_Node_Str"");
  expectedReply.add(FILE_2);
  expectedReply.add(FILE_3);
  expectedReply.add(FILE_4);
  sendCheckQuery(expectedReply,""String_Node_Str"");
  expectedReply.add(FILE_3);
  sendCheckQuery(expectedReply,""String_Node_Str"");
  expectedReply.add(FILE_1);
  sendCheckQuery(expectedReply,""String_Node_Str"");
  expectedReply.add(FILE_4);
  sendCheckQuery(expectedReply,""String_Node_Str"");
}",0.9856670341786108
4551,"private static void doSettings() throws Exception {
  ConnectionSettings.PORT.setValue(PORT);
  ConnectionSettings.CONNECT_ON_STARTUP.setValue(false);
  UltrapeerSettings.EVER_ULTRAPEER_CAPABLE.setValue(false);
  UltrapeerSettings.DISABLE_ULTRAPEER_MODE.setValue(true);
  UltrapeerSettings.FORCE_ULTRAPEER_MODE.setValue(false);
  ConnectionSettings.NUM_CONNECTIONS.setValue(4);
  ConnectionSettings.LOCAL_IS_PRIVATE.setValue(false);
  ConnectionSettings.WATCHDOG_ACTIVE.setValue(false);
  PingPongSettings.PINGS_ACTIVE.setValue(false);
  setUpFiles();
  SearchSettings.MINIMUM_SEARCH_QUALITY.setValue(-2);
}","private static void doSettings() throws Exception {
  ConnectionSettings.PORT.setValue(TEST_PORT);
  ConnectionSettings.CONNECT_ON_STARTUP.setValue(false);
  UltrapeerSettings.EVER_ULTRAPEER_CAPABLE.setValue(false);
  UltrapeerSettings.DISABLE_ULTRAPEER_MODE.setValue(true);
  UltrapeerSettings.FORCE_ULTRAPEER_MODE.setValue(false);
  ConnectionSettings.NUM_CONNECTIONS.setValue(4);
  ConnectionSettings.LOCAL_IS_PRIVATE.setValue(false);
  ConnectionSettings.WATCHDOG_ACTIVE.setValue(false);
  PingPongSettings.PINGS_ACTIVE.setValue(false);
  setUpFiles();
  SearchSettings.MINIMUM_SEARCH_QUALITY.setValue(-2);
}",0.995898277276456
4552,"private static void connect() throws Exception {
  CONN_1=new Connection(""String_Node_Str"",PORT,new UltrapeerHeaders(""String_Node_Str""),new EmptyResponder());
  CONN_1.initialize();
  drain(CONN_1);
}","private static void connect() throws Exception {
  CONN_1=new Connection(""String_Node_Str"",TEST_PORT,new UltrapeerHeaders(""String_Node_Str""),new EmptyResponder());
  CONN_1.initialize();
  drain(CONN_1);
}",0.9876543209876544
4553,"/** 
 * Sends a push request for the given file.  Returns false iff no push could be sent, i.e., because no routing entry exists. That generally means you shouldn't send any more pushes for this file.
 * @param file the <tt>RemoteFileDesc</tt> constructed from the query hit, containing data about the host we're pushing to
 * @return <tt>true</tt> if the push was successfully sent, otherwise<tt>false</tt>
 */
public boolean sendPush(RemoteFileDesc file){
  LOG.trace(""String_Node_Str"");
  if (file.isReplyToMulticast()) {
    byte[] addr=RouterService.getNonForcedAddress();
    int port=RouterService.getNonForcedPort();
    if (NetworkUtils.isValidAddress(addr) && NetworkUtils.isValidPort(port)) {
      PushRequest pr=new PushRequest(GUID.makeGuid(),(byte)1,file.getClientGUID(),file.getIndex(),addr,port);
      router.sendMulticastPushRequest(pr);
      return true;
    }
  }
  byte[] addr=RouterService.getAddress();
  int port=RouterService.getPort();
  if (!NetworkUtils.isValidAddress(addr) || !NetworkUtils.isValidPort(port))   return false;
  Set proxies=file.getPushProxies();
  if (!proxies.isEmpty()) {
    LOG.info(""String_Node_Str"");
    boolean requestSuccessful=false;
    final String requestString=""String_Node_Str"" + Base32.encode(file.getClientGUID());
    final String nodeString=""String_Node_Str"";
    final String nodeValue=NetworkUtils.ip2string(addr) + ""String_Node_Str"" + port;
    Iterator iter=proxies.iterator();
    while (iter.hasNext() && !requestSuccessful) {
      PushProxyInterface ppi=(PushProxyInterface)iter.next();
      String ppIp=ppi.getPushProxyAddress().getHostName();
      int ppPort=ppi.getPushProxyPort();
      String connectTo=""String_Node_Str"" + ppIp + ""String_Node_Str""+ ppPort+ requestString;
      HeadMethod head=new HeadMethod(connectTo);
      head.addRequestHeader(nodeString,nodeValue);
      head.addRequestHeader(""String_Node_Str"",""String_Node_Str"");
      HttpClient client=HttpClientManager.getNewClient();
      if (LOG.isTraceEnabled())       LOG.trace(""String_Node_Str"" + connectTo);
      try {
        client.executeMethod(head);
        if (head.getStatusCode() == 202) {
          if (LOG.isInfoEnabled())           LOG.info(""String_Node_Str"" + connectTo);
          requestSuccessful=true;
        }
 else {
          if (LOG.isWarnEnabled())           LOG.warn(""String_Node_Str"" + connectTo + ""String_Node_Str""+ head.getStatusCode());
        }
      }
 catch (      IOException ioe) {
        LOG.warn(""String_Node_Str"",ioe);
      }
 finally {
        if (head != null)         head.releaseConnection();
      }
    }
    if (requestSuccessful)     return requestSuccessful;
  }
  PushRequest pr=new PushRequest(GUID.makeGuid(),ConnectionSettings.TTL.getValue(),file.getClientGUID(),file.getIndex(),addr,port);
  if (LOG.isInfoEnabled())   LOG.info(""String_Node_Str"" + pr);
  try {
    router.sendPushRequest(pr);
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}","/** 
 * Sends a push request for the given file.  Returns false iff no push could be sent, i.e., because no routing entry exists. That generally means you shouldn't send any more pushes for this file.
 * @param file the <tt>RemoteFileDesc</tt> constructed from the query hit, containing data about the host we're pushing to
 * @return <tt>true</tt> if the push was successfully sent, otherwise<tt>false</tt>
 */
public boolean sendPush(RemoteFileDesc file){
  LOG.trace(""String_Node_Str"");
  if (file.isReplyToMulticast()) {
    byte[] addr=RouterService.getNonForcedAddress();
    int port=RouterService.getNonForcedPort();
    if (NetworkUtils.isValidAddress(addr) && NetworkUtils.isValidPort(port)) {
      PushRequest pr=new PushRequest(GUID.makeGuid(),(byte)1,file.getClientGUID(),file.getIndex(),addr,port);
      router.sendMulticastPushRequest(pr);
      return true;
    }
  }
  byte[] addr=RouterService.getAddress();
  int port=RouterService.getPort();
  if (!NetworkUtils.isValidAddress(addr) || !NetworkUtils.isValidPort(port))   return false;
  Set proxies=file.getPushProxies();
  if (!proxies.isEmpty()) {
    LOG.info(""String_Node_Str"");
    boolean requestSuccessful=false;
    final String requestString=""String_Node_Str"" + Base32.encode(file.getClientGUID());
    final String nodeString=""String_Node_Str"";
    final String nodeValue=NetworkUtils.ip2string(addr) + ""String_Node_Str"" + port;
    Iterator iter=proxies.iterator();
    while (iter.hasNext() && !requestSuccessful) {
      PushProxyInterface ppi=(PushProxyInterface)iter.next();
      String ppIp=ppi.getPushProxyAddress().getHostAddress();
      int ppPort=ppi.getPushProxyPort();
      String connectTo=""String_Node_Str"" + ppIp + ""String_Node_Str""+ ppPort+ requestString;
      HeadMethod head=new HeadMethod(connectTo);
      head.addRequestHeader(nodeString,nodeValue);
      head.addRequestHeader(""String_Node_Str"",""String_Node_Str"");
      HttpClient client=HttpClientManager.getNewClient();
      if (LOG.isTraceEnabled())       LOG.trace(""String_Node_Str"" + connectTo);
      try {
        client.executeMethod(head);
        if (head.getStatusCode() == 202) {
          if (LOG.isInfoEnabled())           LOG.info(""String_Node_Str"" + connectTo);
          requestSuccessful=true;
        }
 else {
          if (LOG.isWarnEnabled())           LOG.warn(""String_Node_Str"" + connectTo + ""String_Node_Str""+ head.getStatusCode());
        }
      }
 catch (      IOException ioe) {
        LOG.warn(""String_Node_Str"",ioe);
      }
 finally {
        if (head != null)         head.releaseConnection();
      }
    }
    if (requestSuccessful)     return requestSuccessful;
  }
  PushRequest pr=new PushRequest(GUID.makeGuid(),ConnectionSettings.TTL.getValue(),file.getClientGUID(),file.getIndex(),addr,port);
  if (LOG.isInfoEnabled())   LOG.info(""String_Node_Str"" + pr);
  try {
    router.sendPushRequest(pr);
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}",0.9981459632563628
4554,"private static byte[] derivePayload(InetAddress addr,int port) throws BadPacketException {
  try {
    QueryReply.IPPortCombo combo=new QueryReply.IPPortCombo(addr.getHostName(),port);
    return combo.toBytes();
  }
 catch (  UnknownHostException uhe) {
    ErrorService.error(uhe);
    throw new BadPacketException(""String_Node_Str"");
  }
}","private static byte[] derivePayload(InetAddress addr,int port) throws BadPacketException {
  try {
    QueryReply.IPPortCombo combo=new QueryReply.IPPortCombo(addr.getHostAddress(),port);
    return combo.toBytes();
  }
 catch (  UnknownHostException uhe) {
    ErrorService.error(uhe);
    throw new BadPacketException(""String_Node_Str"");
  }
}",0.9839883551673944
4555,"/** 
 * Accessor for the <tt>Collection</tt> of Ultrapeers that have advertised free leaf slots.  The returned <tt>Collection</tt> will throw an exception if it is modified in any way.
 * @return a <tt>Collection</tt> of hosts that have advertised that theyhave free leaf slots
 */
public synchronized Collection getUltrapeersWithFreeLeafSlots(){
  return Collections.unmodifiableCollection(FREE_LEAF_SLOTS);
}","/** 
 * Accessor for the <tt>Collection</tt> of Ultrapeers that have advertised free leaf slots.  The returned <tt>Collection</tt> is a complete copy of the hosts with free slots and can therefore be modified in any way.
 * @return a copy of the <tt>Collection</tt> of hosts that have advertised that they have free leaf slots
 */
public synchronized Collection getUltrapeersWithFreeLeafSlots(){
  return new HashSet(FREE_LEAF_SLOTS);
}",0.7777777777777778
4556,"/** 
 * This method notifies the connection manager that the user does not have a live connection to the Internet to the best of our determination. In this case, we notify the user with a message and maintain any  Gnutella hosts we have already tried instead of discarding them.
 */
public void noInternetConnection(){
  if (_automaticallyConnecting) {
    if (_catcher != null && (_catcher.getNumHosts() < 50)) {
      _catcher.recoverHosts();
    }
    return;
  }
  if (SystemUtils.supportsIdleTime() && SystemUtils.getIdleTime() < 30 * 1000) {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET);
  }
 else {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET);
    RouterService.schedule(new Runnable(){
      public void run(){
        if (_automaticConnectTime < _disconnectTime) {
          return;
        }
        ConnectionManager cm=RouterService.getConnectionManager();
        if (!cm.isConnected()) {
          cm.connect();
        }
      }
    }
,10 * 1000,60 * 1000);
    _automaticConnectTime=System.currentTimeMillis();
    _automaticallyConnecting=true;
  }
  _noInternetConnection=true;
  disconnect();
  if (_catcher != null) {
    _catcher.recoverHosts();
  }
}","/** 
 * This method notifies the connection manager that the user does not have a live connection to the Internet to the best of our determination. In this case, we notify the user with a message and maintain any  Gnutella hosts we have already tried instead of discarding them.
 */
public void noInternetConnection(){
  if (_automaticallyConnecting) {
    if (_catcher != null && (_catcher.getNumHosts() < 50)) {
      _catcher.recoverHosts();
    }
    return;
  }
  if (SystemUtils.supportsIdleTime() && SystemUtils.getIdleTime() < 30 * 1000 && !QuestionsHandler.NO_INTERNET.getValue()) {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET);
  }
 else {
    MessageService.showError(""String_Node_Str"",QuestionsHandler.NO_INTERNET);
    RouterService.schedule(new Runnable(){
      public void run(){
        if (_automaticConnectTime < _disconnectTime) {
          return;
        }
        ConnectionManager cm=RouterService.getConnectionManager();
        if (!cm.isConnected()) {
          cm.connect();
        }
      }
    }
,10 * 1000,60 * 1000);
    _automaticConnectTime=System.currentTimeMillis();
    _automaticallyConnecting=true;
  }
  _noInternetConnection=true;
  disconnect();
  if (_catcher != null) {
    _catcher.recoverHosts();
  }
}",0.932486100079428
4557,"/** 
 * Connects to the network.  Ensures the number of messaging connections (keep-alive) is non-zero and recontacts the pong server as needed.  
 */
public synchronized void connect(){
  _catcher.expire();
  int outgoing=ConnectionSettings.NUM_CONNECTIONS.getValue();
  if (outgoing < 1) {
    ConnectionSettings.NUM_CONNECTIONS.revertToDefault();
    outgoing=ConnectionSettings.NUM_CONNECTIONS.getValue();
  }
  setKeepAlive(outgoing);
}","/** 
 * Connects to the network.  Ensures the number of messaging connections (keep-alive) is non-zero and recontacts the pong server as needed.  
 */
public synchronized void connect(){
  long fetched=ConnectionSettings.LAST_GWEBCACHE_FETCH_TIME.getValue();
  if (fetched + DataUtils.ONE_WEEK <= System.currentTimeMillis()) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + fetched);
    _catcher.expire();
  }
  int outgoing=ConnectionSettings.NUM_CONNECTIONS.getValue();
  if (outgoing < 1) {
    ConnectionSettings.NUM_CONNECTIONS.revertToDefault();
    outgoing=ConnectionSettings.NUM_CONNECTIONS.getValue();
  }
  setKeepAlive(outgoing);
}",0.786096256684492
4558,"/** 
 * Starts various threads and tasks once all core classes have been constructed.
 */
public void start(){
  if (isStarted())   return;
  _started=true;
  acceptor.start();
  RESULT_HANDLER.start();
  router.initialize();
  manager.initialize();
  downloader.initialize();
  SupernodeAssigner sa=new SupernodeAssigner(uploadManager,downloader,manager);
  sa.start();
  if (ConnectionSettings.CONNECT_ON_STARTUP.getValue()) {
    int outgoing=ConnectionSettings.NUM_CONNECTIONS.getValue();
    if (outgoing > 0)     connect();
  }
  catcher.initialize();
  fileManager.start();
  downloader.postGuiInit();
  UpdateManager.instance();
  QueryUnicaster.instance().start();
  new HTTPAcceptor().start();
  Pinger.instance().start();
  ConnectionWatchdog.instance().start();
}","/** 
 * Starts various threads and tasks once all core classes have been constructed.
 */
public void start(){
  if (isStarted())   return;
  _started=true;
  acceptor.start();
  RESULT_HANDLER.start();
  router.initialize();
  manager.initialize();
  downloader.initialize();
  SupernodeAssigner sa=new SupernodeAssigner(uploadManager,downloader,manager);
  sa.start();
  catcher.initialize();
  if (ConnectionSettings.CONNECT_ON_STARTUP.getValue()) {
    int outgoing=ConnectionSettings.NUM_CONNECTIONS.getValue();
    if (outgoing > 0)     connect();
  }
  fileManager.start();
  downloader.postGuiInit();
  UpdateManager.instance();
  QueryUnicaster.instance().start();
  new HTTPAcceptor().start();
  Pinger.instance().start();
  ConnectionWatchdog.instance().start();
}",0.969032258064516
4559,"private void requestFromOneHost(GWebCacheRequest request,BootstrapServer server){
  if (request == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (server == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  BufferedReader in=null;
  String connectTo=server.getURL().toString() + ""String_Node_Str"" + CommonUtils.QHD_VENDOR_NAME+ ""String_Node_Str""+ URLEncoder.encode(CommonUtils.getLimeWireVersion())+ ""String_Node_Str""+ request.parameters();
  HttpMethod get=new GetMethod(connectTo);
  get.addRequestHeader(""String_Node_Str"",""String_Node_Str"");
  get.addRequestHeader(""String_Node_Str"",CommonUtils.getHttpServer());
  get.addRequestHeader(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
  get.setFollowRedirects(true);
  HttpClient client=HttpClientManager.getNewClient();
  try {
    HttpClientManager.executeMethodRedirecting(client,get);
    in=new BufferedReader(new InputStreamReader(get.getResponseBodyAsStream()));
    if (get.getStatusCode() < 200 || get.getStatusCode() >= 300) {
      if (LOG.isWarnEnabled())       LOG.warn(""String_Node_Str"" + get.getStatusCode());
      throw new IOException(""String_Node_Str"");
    }
    boolean firstLine=true;
    boolean errors=false;
    while (true) {
      String line=in.readLine();
      if (line == null)       break;
      if (LOG.isTraceEnabled())       LOG.trace(""String_Node_Str"" + line);
      if (firstLine && StringUtils.startsWithIgnoreCase(line,""String_Node_Str"")) {
        request.handleError(server);
        errors=true;
      }
 else {
        request.handleResponseData(server,line);
      }
      firstLine=false;
    }
    if (!errors)     _lastConnectable=server;
  }
 catch (  IOException ioe) {
    LOG.warn(""String_Node_Str"",ioe);
    request.handleError(server);
  }
 finally {
    if (in != null)     try {
      in.close();
    }
 catch (    IOException e) {
    }
    if (get != null)     get.releaseConnection();
  }
}","private void requestFromOneHost(GWebCacheRequest request,BootstrapServer server){
  if (request == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (server == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (LOG.isTraceEnabled())   LOG.trace(""String_Node_Str"" + request + ""String_Node_Str""+ server);
  BufferedReader in=null;
  String connectTo=server.getURL().toString() + ""String_Node_Str"" + CommonUtils.QHD_VENDOR_NAME+ ""String_Node_Str""+ URLEncoder.encode(CommonUtils.getLimeWireVersion())+ ""String_Node_Str""+ request.parameters();
  HttpMethod get=new GetMethod(connectTo);
  get.addRequestHeader(""String_Node_Str"",""String_Node_Str"");
  get.addRequestHeader(""String_Node_Str"",CommonUtils.getHttpServer());
  get.addRequestHeader(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
  get.setFollowRedirects(true);
  HttpClient client=HttpClientManager.getNewClient();
  try {
    HttpClientManager.executeMethodRedirecting(client,get);
    in=new BufferedReader(new InputStreamReader(get.getResponseBodyAsStream()));
    if (get.getStatusCode() < 200 || get.getStatusCode() >= 300) {
      if (LOG.isWarnEnabled())       LOG.warn(""String_Node_Str"" + get.getStatusCode());
      throw new IOException(""String_Node_Str"");
    }
    boolean firstLine=true;
    boolean errors=false;
    while (true) {
      String line=in.readLine();
      if (line == null)       break;
      if (firstLine && StringUtils.startsWithIgnoreCase(line,""String_Node_Str"")) {
        request.handleError(server);
        errors=true;
      }
 else {
        request.handleResponseData(server,line);
      }
      firstLine=false;
    }
    if (!errors)     _lastConnectable=server;
  }
 catch (  IOException ioe) {
    LOG.warn(""String_Node_Str"",ioe);
    request.handleError(server);
  }
 finally {
    if (in != null)     try {
      in.close();
    }
 catch (    IOException e) {
    }
    if (get != null)     get.releaseConnection();
  }
}",0.9561247780877504
4560,"/** 
 * Called when if were unable to connect to the URL, got a non-standard HTTP response code, or got an ERROR method.  Default value: remove it from the list. 
 */
protected void handleError(BootstrapServer server){
synchronized (BootstrapServerManager.this) {
    SERVERS.remove(server);
    if (_lastConnectable == server)     _lastConnectable=null;
  }
}","/** 
 * Called when if were unable to connect to the URL, got a non-standard HTTP response code, or got an ERROR method.  Default value: remove it from the list. 
 */
protected void handleError(BootstrapServer server){
  if (LOG.isWarnEnabled())   LOG.warn(""String_Node_Str"" + server);
synchronized (BootstrapServerManager.this) {
    SERVERS.remove(server);
    if (_lastConnectable == server)     _lastConnectable=null;
  }
}",0.914866581956798
4561,"public void run(){
  SendBundle currBundle=null;
  while (true) {
synchronized (PACKETS_TO_SEND) {
      while (PACKETS_TO_SEND.isEmpty()) {
        try {
          PACKETS_TO_SEND.wait();
        }
 catch (        InterruptedException ignored) {
        }
      }
      currBundle=(SendBundle)PACKETS_TO_SEND.remove(0);
    }
synchronized (_sendLock) {
      if (_socket == null)       return;
      try {
        _socket.send(currBundle._dp);
      }
 catch (      BindException be) {
      }
catch (      NoRouteToHostException nrthe) {
      }
catch (      IOException ioe) {
        if (""String_Node_Str"".equals(ioe.getMessage()))         return;
        String errString=""String_Node_Str"" + currBundle._dp.getAddress() + ""String_Node_Str""+ currBundle._dp.getPort();
        currBundle._err.error(ioe,errString);
      }
    }
  }
}","public void run(){
  boolean hasReportedNullSocket=false;
  SendBundle currBundle=null;
  while (true) {
synchronized (PACKETS_TO_SEND) {
      while (PACKETS_TO_SEND.isEmpty()) {
        try {
          PACKETS_TO_SEND.wait();
        }
 catch (        InterruptedException ignored) {
        }
      }
      currBundle=(SendBundle)PACKETS_TO_SEND.remove(0);
    }
synchronized (_sendLock) {
      if (_socket == null) {
        if (!hasReportedNullSocket) {
          hasReportedNullSocket=true;
          Exception npe=new NullPointerException(""String_Node_Str"");
          ErrorService.error(npe);
        }
        continue;
      }
      try {
        _socket.send(currBundle._dp);
      }
 catch (      BindException be) {
      }
catch (      NoRouteToHostException nrthe) {
      }
catch (      IOException ioe) {
        if (""String_Node_Str"".equals(ioe.getMessage()))         return;
        String errString=""String_Node_Str"" + currBundle._dp.getAddress() + ""String_Node_Str""+ currBundle._dp.getPort();
        currBundle._err.error(ioe,errString);
      }
    }
  }
}",0.8596765779864372
4562,"public boolean conflicts(URN urn){
  File otherFile=incompleteFileManager.getFileForUrn(urn);
  return conflicts(otherFile);
}","public boolean conflicts(URN urn){
  Assert.that(urn != null,""String_Node_Str"");
  File otherFile=incompleteFileManager.getFileForUrn(urn);
  if (otherFile == null)   return false;
  return conflicts(otherFile);
}",0.7433628318584071
4563,"/** 
 * Factory method for instantiating individual responses from an <tt>InputStream</tt> instance.
 * @param is the <tt>InputStream</tt> to read from
 * @throws <tt>IOException</tt> if there are any problems reading fromor writing to the stream
 */
public static Response createFromStream(InputStream is) throws IOException {
  long index=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  long size=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IOException(""String_Node_Str"" + index);
  if (size > Integer.MAX_VALUE || size < 0)   throw new IOException(""String_Node_Str"" + size);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int c;
  while ((c=is.read()) != 0) {
    baos.write(c);
  }
  String name=new String(baos.toByteArray());
  if (name.length() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  baos.reset();
  while ((c=is.read()) != 0) {
    baos.write(c);
  }
  byte[] rawMeta=baos.toByteArray();
  String betweenNulls=new String(rawMeta);
  if (betweenNulls == null || betweenNulls.equals(""String_Node_Str"")) {
    if (is.available() < 16) {
      throw new IOException(""String_Node_Str"");
    }
    return new Response(index,size,name);
  }
 else {
    StringTokenizer stok=new StringTokenizer(betweenNulls,EXT_STRING);
    Set urns=null;
    Set endpoints=null;
    String metaString=null;
    while (stok.hasMoreTokens()) {
      final String ext=stok.nextToken();
      if (URN.isUrn(ext)) {
        try {
          URN urn=URN.createSHA1Urn(ext);
          if (urns == null)           urns=new HashSet(1);
          urns.add(urn);
          continue;
        }
 catch (        IOException e) {
        }
      }
      byte[] extBytes=ext.getBytes();
      if (extBytes != null && extBytes.length > 1 && extBytes[0] == GGEP.GGEP_PREFIX_MAGIC_NUMBER) {
        boolean readMore=false;
        if (stok.hasMoreTokens()) {
          readMore=true;
          StringBuffer sb=new StringBuffer(ext);
          while (stok.hasMoreTokens()) {
            sb.append(EXT_STRING);
            sb.append(stok.nextToken());
          }
          extBytes=sb.toString().getBytes();
        }
        GGEP[] ggepBlocks=null;
        try {
          if (!readMore)           ggepBlocks=GGEP.read(extBytes,0);
 else {
            int[] end=new int[1];
            ggepBlocks=GGEP.read(extBytes,0,end);
            if (end[0] != extBytes.length)             stok=recreateTokenizer(extBytes,end[0]);
          }
          endpoints=GGEPUtil.getLocations(ggepBlocks);
          continue;
        }
 catch (        BadGGEPBlockException be) {
        }
      }
      metaString=createXmlString(name,ext);
    }
    return new Response(index,size,name,metaString,urns,null,endpoints,rawMeta);
  }
}","/** 
 * Factory method for instantiating individual responses from an <tt>InputStream</tt> instance.
 * @param is the <tt>InputStream</tt> to read from
 * @throws <tt>IOException</tt> if there are any problems reading fromor writing to the stream
 */
public static Response createFromStream(InputStream is) throws IOException {
  long index=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  long size=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IOException(""String_Node_Str"" + index);
  if (size > Integer.MAX_VALUE || size < 0)   throw new IOException(""String_Node_Str"" + size);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int c;
  while ((c=is.read()) != 0) {
    if (c == -1)     throw new IOException(""String_Node_Str"");
    baos.write(c);
  }
  String name=new String(baos.toByteArray());
  if (name.length() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  baos.reset();
  while ((c=is.read()) != 0) {
    if (c == -1)     throw new IOException(""String_Node_Str"");
    baos.write(c);
  }
  byte[] rawMeta=baos.toByteArray();
  String betweenNulls=new String(rawMeta);
  if (betweenNulls == null || betweenNulls.equals(""String_Node_Str"")) {
    if (is.available() < 16) {
      throw new IOException(""String_Node_Str"");
    }
    return new Response(index,size,name);
  }
 else {
    StringTokenizer stok=new StringTokenizer(betweenNulls,EXT_STRING);
    Set urns=null;
    Set endpoints=null;
    String metaString=null;
    while (stok.hasMoreTokens()) {
      final String ext=stok.nextToken();
      if (URN.isUrn(ext)) {
        try {
          URN urn=URN.createSHA1Urn(ext);
          if (urns == null)           urns=new HashSet(1);
          urns.add(urn);
          continue;
        }
 catch (        IOException e) {
        }
      }
      byte[] extBytes=ext.getBytes();
      if (extBytes != null && extBytes.length > 1 && extBytes[0] == GGEP.GGEP_PREFIX_MAGIC_NUMBER) {
        boolean readMore=false;
        if (stok.hasMoreTokens()) {
          readMore=true;
          StringBuffer sb=new StringBuffer(ext);
          while (stok.hasMoreTokens()) {
            sb.append(EXT_STRING);
            sb.append(stok.nextToken());
          }
          extBytes=sb.toString().getBytes();
        }
        GGEP[] ggepBlocks=null;
        try {
          if (!readMore)           ggepBlocks=GGEP.read(extBytes,0);
 else {
            int[] end=new int[1];
            ggepBlocks=GGEP.read(extBytes,0,end);
            if (end[0] != extBytes.length)             stok=recreateTokenizer(extBytes,end[0]);
          }
          endpoints=GGEPUtil.getLocations(ggepBlocks);
          continue;
        }
 catch (        BadGGEPBlockException be) {
        }
      }
      metaString=createXmlString(name,ext);
    }
    return new Response(index,size,name,metaString,urns,null,endpoints,rawMeta);
  }
}",0.942110836569008
4564,"/** 
 * @return true if the version of limewire we are connected to is old
 */
private boolean oldVersion(String userAgent){
  StringTokenizer tok=new StringTokenizer(userAgent,""String_Node_Str"");
  int major=-1;
  int minor=-1;
  boolean ret=false;
  boolean error=false;
  try {
    String str=tok.nextToken();
    str=tok.nextToken();
    major=Integer.parseInt(str);
    str=tok.nextToken();
    minor=Integer.parseInt(str);
  }
 catch (  NoSuchElementException nssx) {
    error=true;
  }
catch (  NumberFormatException nfx) {
    error=true;
  }
  if (!error && (major < 3 || (major == 3 && minor < 4)))   ret=true;
  return ret;
}","/** 
 * @return true if the version of limewire we are connected to is old
 */
private boolean oldVersion(String userAgent){
  StringTokenizer tok=new StringTokenizer(userAgent,""String_Node_Str"");
  int major=-1;
  int minor=-1;
  boolean ret=false;
  boolean error=false;
  if (tok.countTokens() < 3)   return false;
  try {
    String str=tok.nextToken();
    str=tok.nextToken();
    major=Integer.parseInt(str);
    str=tok.nextToken();
    minor=Integer.parseInt(str);
  }
 catch (  NumberFormatException nfx) {
    error=true;
  }
  if (!error && (major < 3 || (major == 3 && minor < 4)))   ret=true;
  return ret;
}",0.9007148530579825
4565,"/** 
 * Adds an incomplete file to be used for partial file sharing.
 * @modifies this
 * @param incompleteFile the incomplete file.
 * @param urns the set of all known URNs for this incomplete file
 * @param name the completed name of this incomplete file
 * @param size the completed size of this incomplete file
 * @param vf the VerifyingFile containing the ranges for this inc. file
 */
public synchronized void addIncompleteFile(File incompleteFile,Set urns,String name,int size,VerifyingFile vf){
  try {
    incompleteFile=FileUtils.getCanonicalFile(incompleteFile);
  }
 catch (  IOException ioe) {
    ErrorService.error(ioe);
    return;
  }
  Iterator iter=urns.iterator();
  while (iter.hasNext()) {
    IntSet shared=(IntSet)_urnIndex.get(iter.next());
    if (shared == null)     continue;
    IntSet.IntSetIterator isIter=shared.iterator();
    for (; isIter.hasNext(); ) {
      int i=isIter.next();
      FileDesc desc=(FileDesc)_files.get(i);
      if (desc == null)       continue;
      String incPath=incompleteFile.getAbsolutePath();
      String path=desc.getFile().getAbsolutePath();
      if (incPath.equals(path))       return;
    }
  }
  int fileIndex=_files.size();
  _incompletesShared.add(fileIndex);
  IncompleteFileDesc ifd=new IncompleteFileDesc(incompleteFile,urns,fileIndex,name,size,vf);
  _files.add(ifd);
  _fileToFileDesc.put(incompleteFile,ifd);
  this.updateUrnIndex(ifd);
  _numIncompleteFiles++;
  File parent=FileUtils.getParentFile(incompleteFile);
  RouterService.getCallback().addSharedFile(ifd,parent);
}","/** 
 * Adds an incomplete file to be used for partial file sharing.
 * @modifies this
 * @param incompleteFile the incomplete file.
 * @param urns the set of all known URNs for this incomplete file
 * @param name the completed name of this incomplete file
 * @param size the completed size of this incomplete file
 * @param vf the VerifyingFile containing the ranges for this inc. file
 */
public synchronized void addIncompleteFile(File incompleteFile,Set urns,String name,int size,VerifyingFile vf){
  try {
    incompleteFile=FileUtils.getCanonicalFile(incompleteFile);
  }
 catch (  IOException ioe) {
    return;
  }
  Iterator iter=urns.iterator();
  while (iter.hasNext()) {
    IntSet shared=(IntSet)_urnIndex.get(iter.next());
    if (shared == null)     continue;
    IntSet.IntSetIterator isIter=shared.iterator();
    for (; isIter.hasNext(); ) {
      int i=isIter.next();
      FileDesc desc=(FileDesc)_files.get(i);
      if (desc == null)       continue;
      String incPath=incompleteFile.getAbsolutePath();
      String path=desc.getFile().getAbsolutePath();
      if (incPath.equals(path))       return;
    }
  }
  int fileIndex=_files.size();
  _incompletesShared.add(fileIndex);
  IncompleteFileDesc ifd=new IncompleteFileDesc(incompleteFile,urns,fileIndex,name,size,vf);
  _files.add(ifd);
  _fileToFileDesc.put(incompleteFile,ifd);
  this.updateUrnIndex(ifd);
  _numIncompleteFiles++;
  File parent=FileUtils.getParentFile(incompleteFile);
  RouterService.getCallback().addSharedFile(ifd,parent);
}",0.9905752356191097
4566,"public void run(){
  boolean iterate=false;
  try {
    iterate=connectAndDownload(rfd);
  }
 catch (  Throwable e) {
    iterate=true;
    if (!(e instanceof InterruptedException)) {
      ErrorService.error(e);
    }
  }
 finally {
synchronized (ManagedDownloader.this) {
      threads.remove(this);
      if (iterate)       ManagedDownloader.this.notifyAll();
    }
  }
}","public void run(){
  boolean iterate=false;
  try {
    iterate=connectAndDownload(rfd);
  }
 catch (  Throwable e) {
    iterate=true;
    if (!(e instanceof InterruptedException)) {
      ErrorService.error(e);
    }
  }
 finally {
synchronized (ManagedDownloader.this) {
      currentRFDs.remove(rfd);
      threads.remove(this);
      if (iterate)       ManagedDownloader.this.notifyAll();
    }
  }
}",0.9602053915275996
4567,"/** 
 * Like tryDownloads2, but does not deal with the library, cleaning up corrupt files, etc.  Caller should look at corruptState to determine if the file is corrupted; a return value of COMPLETE does not mean no corruptions where encountered.
 * @return COMPLETE if a file was successfully downloadedWAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try. COULDNT_MOVE_TO_LIBRARY couldn't write the incomplete file
 * @exception InterruptedException if the someone stop()'ed this download.stop() was called either because the user killed the download or a corruption was detected and they chose to kill and discard the download.  Calls to resume() do not result in InterruptedException.
 */
private int tryAllDownloads3() throws InterruptedException {
  int completedSize=-1;
synchronized (this) {
    needed=new IntervalSet();
{
      Assert.that(incompleteFile != null);
synchronized (incompleteFileManager) {
        if (commonOutFile != null)         commonOutFile.clearManagedDownloader();
        commonOutFile=incompleteFileManager.getEntry(incompleteFile);
      }
      if (commonOutFile == null) {
        debug(""String_Node_Str"");
        commonOutFile=new VerifyingFile(true);
        incompleteFileManager.addEntry(incompleteFile,commonOutFile);
{
          FileDesc f=fileManager.getFileDescForFile(incompleteFile);
          URN bucketHash=buckets.getURNForBucket(bucketNumber);
          if (bucketHash != null && f != null) {
            Assert.silent(bucketHash.equals(f.getSHA1Urn()),""String_Node_Str"");
            fileManager.removeFileIfShared(incompleteFile);
          }
        }
      }
      try {
        commonOutFile.open(incompleteFile,this);
      }
 catch (      IOException e) {
        ErrorService.error(e);
        return COULDNT_MOVE_TO_LIBRARY;
      }
      completedSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
      Iterator iter=commonOutFile.getFreeBlocks(completedSize);
      while (iter.hasNext())       addToNeeded((Interval)iter.next());
    }
  }
  busy=new LinkedList();
  int size=-1;
  int connectTo=-1;
  int dloadsCount=-1;
  Assert.that(threads.size() == 0);
  while (true) {
synchronized (stealLock) {
synchronized (this) {
        if (stopped) {
          debug(""String_Node_Str"");
          throw new InterruptedException();
        }
        if (dloaders.size() == 0 && needed.isEmpty()) {
          int doneSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
          Assert.that(completedSize == doneSize,""String_Node_Str"");
          Iterator freeBlocks=commonOutFile.getFreeBlocks(doneSize);
          if (freeBlocks.hasNext()) {
            while (freeBlocks.hasNext())             addToNeeded((Interval)freeBlocks.next());
            Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + needed);
          }
 else {
            for (int i=threads.size(); i > 0; i--) {
              Thread t=(Thread)threads.get(i - 1);
              t.interrupt();
            }
            debug(""String_Node_Str"");
            return COMPLETE;
          }
        }
        if (threads.size() == 0 && files.size() == 0) {
          if (busy.size() > 0) {
            debug(""String_Node_Str"");
            files.addAll(busy);
            return WAITING_FOR_RETRY;
          }
 else {
            debug(""String_Node_Str"");
            return GAVE_UP;
          }
        }
        size=files.size();
        connectTo=getNumAllowedDownloads();
        dloadsCount=dloaders.size();
      }
    }
    for (int i=0; i < (connectTo + 1) && i < size && dloadsCount < getSwarmCapacity(); i++) {
      final RemoteFileDesc rfd=removeBest(files);
      Thread connectCreator=new Thread(""String_Node_Str""){
        public void run(){
          boolean iterate=false;
          try {
            iterate=connectAndDownload(rfd);
          }
 catch (          Throwable e) {
            iterate=true;
            if (!(e instanceof InterruptedException)) {
              ErrorService.error(e);
            }
          }
 finally {
synchronized (ManagedDownloader.this) {
              threads.remove(this);
              if (iterate)               ManagedDownloader.this.notifyAll();
            }
          }
        }
      }
;
synchronized (this) {
        threads.add(connectCreator);
      }
      connectCreator.start();
    }
synchronized (this) {
      try {
        this.wait(4000);
      }
 catch (      InterruptedException ee) {
      }
    }
  }
}","/** 
 * Like tryDownloads2, but does not deal with the library, cleaning up corrupt files, etc.  Caller should look at corruptState to determine if the file is corrupted; a return value of COMPLETE does not mean no corruptions where encountered.
 * @return COMPLETE if a file was successfully downloadedWAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try. COULDNT_MOVE_TO_LIBRARY couldn't write the incomplete file
 * @exception InterruptedException if the someone stop()'ed this download.stop() was called either because the user killed the download or a corruption was detected and they chose to kill and discard the download.  Calls to resume() do not result in InterruptedException.
 */
private int tryAllDownloads3() throws InterruptedException {
  int completedSize=-1;
synchronized (this) {
    needed=new IntervalSet();
{
      Assert.that(incompleteFile != null);
synchronized (incompleteFileManager) {
        if (commonOutFile != null)         commonOutFile.clearManagedDownloader();
        commonOutFile=incompleteFileManager.getEntry(incompleteFile);
      }
      if (commonOutFile == null) {
        debug(""String_Node_Str"");
        commonOutFile=new VerifyingFile(true);
        incompleteFileManager.addEntry(incompleteFile,commonOutFile);
{
          FileDesc f=fileManager.getFileDescForFile(incompleteFile);
          URN bucketHash=buckets.getURNForBucket(bucketNumber);
          if (bucketHash != null && f != null && !bucketHash.equals(f.getSHA1Urn())) {
            Assert.silent(false,""String_Node_Str"");
            fileManager.removeFileIfShared(incompleteFile);
          }
        }
      }
      try {
        commonOutFile.open(incompleteFile,this);
      }
 catch (      IOException e) {
        ErrorService.error(e);
        return COULDNT_MOVE_TO_LIBRARY;
      }
      completedSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
      Iterator iter=commonOutFile.getFreeBlocks(completedSize);
      while (iter.hasNext())       addToNeeded((Interval)iter.next());
    }
  }
  busy=new LinkedList();
  currentRFDs=new LinkedList();
  int size=-1;
  int connectTo=-1;
  int dloadsCount=-1;
  Assert.that(threads.size() == 0);
  while (true) {
synchronized (stealLock) {
synchronized (this) {
        if (stopped) {
          debug(""String_Node_Str"");
          throw new InterruptedException();
        }
        if (dloaders.size() == 0 && needed.isEmpty()) {
          int doneSize=(int)IncompleteFileManager.getCompletedSize(incompleteFile);
          Assert.that(completedSize == doneSize,""String_Node_Str"");
          Iterator freeBlocks=commonOutFile.getFreeBlocks(doneSize);
          if (freeBlocks.hasNext()) {
            while (freeBlocks.hasNext())             addToNeeded((Interval)freeBlocks.next());
            Assert.silent(false,""String_Node_Str"" + ""String_Node_Str"" + needed);
          }
 else {
            for (int i=threads.size(); i > 0; i--) {
              Thread t=(Thread)threads.get(i - 1);
              t.interrupt();
            }
            debug(""String_Node_Str"");
            return COMPLETE;
          }
        }
        if (threads.size() == 0 && files.size() == 0) {
          if (busy.size() > 0) {
            debug(""String_Node_Str"");
            files.addAll(busy);
            return WAITING_FOR_RETRY;
          }
 else {
            debug(""String_Node_Str"");
            return GAVE_UP;
          }
        }
        size=files.size();
        connectTo=getNumAllowedDownloads();
        dloadsCount=dloaders.size();
      }
    }
    for (int i=0; i < (connectTo + 1) && i < size && dloadsCount < getSwarmCapacity(); i++) {
      final RemoteFileDesc rfd;
synchronized (this) {
        rfd=removeBest(files);
        currentRFDs.add(rfd);
      }
      Thread connectCreator=new Thread(""String_Node_Str""){
        public void run(){
          boolean iterate=false;
          try {
            iterate=connectAndDownload(rfd);
          }
 catch (          Throwable e) {
            iterate=true;
            if (!(e instanceof InterruptedException)) {
              ErrorService.error(e);
            }
          }
 finally {
synchronized (ManagedDownloader.this) {
              currentRFDs.remove(rfd);
              threads.remove(this);
              if (iterate)               ManagedDownloader.this.notifyAll();
            }
          }
        }
      }
;
synchronized (this) {
        threads.add(connectCreator);
      }
      connectCreator.start();
    }
synchronized (this) {
      try {
        this.wait(4000);
      }
 catch (      InterruptedException ee) {
      }
    }
  }
}",0.9772872001698152
4568,"/** 
 * Like addDownload, but doesn't call allowAddition(..). If cache is false, the RFD is not added to allFiles, but is added to the appropriate bucket. If the RFD matches one already in allFiles, the new one is NOT added to allFiles, but IS added the appropriate bucket if and only if a matching RFD is not currently in the bucket. If the file is ultimately added to buckets, either reqLock is released or this is notified. This ALWAYS returns true, because the download is either allowed or silently ignored (because we're already downloading or going to attempt to download from the host described in the RFD).
 */
protected final synchronized boolean addDownloadForced(RemoteFileDesc rfd,boolean cache){
  if (NetworkUtils.isMe(rfd.getHost(),rfd.getPort()))   return true;
  if (cache) {
    for (int i=0; i < allFiles.length; i++) {
      if (rfd.equals(allFiles[i])) {
        cache=false;
        break;
      }
    }
  }
  boolean added=false;
  if (buckets != null && (busy == null || (busy != null && !busy.contains(rfd)))) {
    added=(buckets.add(rfd,true) != -1);
  }
  if (cache) {
    RemoteFileDesc[] newAllFiles=new RemoteFileDesc[allFiles.length + 1];
    System.arraycopy(allFiles,0,newAllFiles,0,allFiles.length);
    newAllFiles[newAllFiles.length - 1]=rfd;
    allFiles=newAllFiles;
  }
  if (added) {
    if ((state == Downloader.WAITING_FOR_RETRY) || (state == Downloader.WAITING_FOR_RESULTS) || (state == Downloader.GAVE_UP)|| (state == Downloader.WAITING_FOR_USER))     reqLock.releaseDueToNewResults();
 else     this.notify();
  }
  return true;
}","/** 
 * Like addDownload, but doesn't call allowAddition(..). If cache is false, the RFD is not added to allFiles, but is added to the appropriate bucket. If the RFD matches one already in allFiles, the new one is NOT added to allFiles, but IS added the appropriate bucket if and only if a matching RFD is not currently in the bucket. If the file is ultimately added to buckets, either reqLock is released or this is notified. This ALWAYS returns true, because the download is either allowed or silently ignored (because we're already downloading or going to attempt to download from the host described in the RFD).
 */
protected final synchronized boolean addDownloadForced(RemoteFileDesc rfd,boolean cache){
  if (NetworkUtils.isMe(rfd.getHost(),rfd.getPort()))   return true;
  if (cache) {
    for (int i=0; i < allFiles.length; i++) {
      if (rfd.equals(allFiles[i])) {
        cache=false;
        break;
      }
    }
  }
  boolean added=false;
  if (shouldAllowRFD(rfd)) {
    added=(buckets.add(rfd,true) != -1);
  }
  if (cache) {
    RemoteFileDesc[] newAllFiles=new RemoteFileDesc[allFiles.length + 1];
    System.arraycopy(allFiles,0,newAllFiles,0,allFiles.length);
    newAllFiles[newAllFiles.length - 1]=rfd;
    allFiles=newAllFiles;
  }
  if (added) {
    if ((state == Downloader.WAITING_FOR_RETRY) || (state == Downloader.WAITING_FOR_RESULTS) || (state == Downloader.GAVE_UP)|| (state == Downloader.WAITING_FOR_USER))     reqLock.releaseDueToNewResults();
 else     this.notify();
  }
  return true;
}",0.9706356889319137
4569,"/** 
 * Initialize the connection by doing the handshake.  Throws IOException if we were unable to establish a normal messaging connection for any reason.  Do not call send or receive if this happens.
 * @param timeout for outgoing connections, the timeout in millisecondsto use in establishing the socket, or 0 for no timeout.  If the  platform does not support native timeouts, it will be emulated with threads.
 * @exception IOException we were unable to connect to the host
 * @exception NoGnutellaOkException one of the participants respondedwith an error code other than 200 OK (possibly after several rounds of 401's)
 * @exception BadHandshakeException some other problem establishing the connection, e.g., the server responded with HTTP, closed the the connection during handshaking, etc.
 */
public void initialize(int timeout) throws IOException, NoGnutellaOkException, BadHandshakeException {
  if (isOutgoing())   _socket=Sockets.connect(_host,_port,timeout);
  if (_closed) {
    _socket.close();
    throw CONNECTION_CLOSED;
  }
  InetAddress localAddress=_socket.getLocalAddress();
  if (ConnectionSettings.LOCAL_IS_PRIVATE.getValue() && _socket.getInetAddress().equals(localAddress) && _port == ConnectionSettings.PORT.getValue()) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    RouterService.getAcceptor().setAddress(localAddress);
    _in=getInputStream();
    _out=getOutputStream();
    if (_in == null)     throw new IOException(""String_Node_Str"");
 else     if (_out == null)     throw new IOException(""String_Node_Str"");
  }
 catch (  Exception e) {
    close();
    throw new IOException(""String_Node_Str"");
  }
  try {
    if (isOutgoing())     initializeOutgoing();
 else     initializeIncoming();
    _headers=HandshakeResponse.createResponse(HEADERS_READ);
    _headersWritten=HandshakeResponse.createResponse(HEADERS_WRITTEN);
    _connectionTime=System.currentTimeMillis();
    _softMax=ConnectionSettings.SOFT_MAX.getValue();
    if (isGoodUltrapeer() || isGoodLeaf()) {
      _softMax++;
    }
    if (isWriteDeflated()) {
      _deflater=new Deflater();
      _out=new CompressingOutputStream(_out,_deflater);
    }
    if (isReadDeflated()) {
      _inflater=new Inflater();
      _in=new UncompressingInputStream(_in,_inflater);
    }
    RESPONSE_HEADERS=null;
  }
 catch (  NoGnutellaOkException e) {
    close();
    throw e;
  }
catch (  IOException e) {
    close();
    throw new BadHandshakeException(e);
  }
}","/** 
 * Initialize the connection by doing the handshake.  Throws IOException if we were unable to establish a normal messaging connection for any reason.  Do not call send or receive if this happens.
 * @param timeout for outgoing connections, the timeout in millisecondsto use in establishing the socket, or 0 for no timeout.  If the  platform does not support native timeouts, it will be emulated with threads.
 * @exception IOException we were unable to connect to the host
 * @exception NoGnutellaOkException one of the participants respondedwith an error code other than 200 OK (possibly after several rounds of 401's)
 * @exception BadHandshakeException some other problem establishing the connection, e.g., the server responded with HTTP, closed the the connection during handshaking, etc.
 */
public void initialize(int timeout) throws IOException, NoGnutellaOkException, BadHandshakeException {
  if (isOutgoing())   _socket=Sockets.connect(_host,_port,timeout);
  if (_closed) {
    _socket.close();
    throw CONNECTION_CLOSED;
  }
  InetAddress localAddress=_socket.getLocalAddress();
  if (ConnectionSettings.LOCAL_IS_PRIVATE.getValue() && _socket.getInetAddress().equals(localAddress) && _port == ConnectionSettings.PORT.getValue()) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    _in=getInputStream();
    _out=getOutputStream();
    if (_in == null)     throw new IOException(""String_Node_Str"");
 else     if (_out == null)     throw new IOException(""String_Node_Str"");
  }
 catch (  Exception e) {
    close();
    throw new IOException(""String_Node_Str"");
  }
  try {
    if (isOutgoing())     initializeOutgoing();
 else     initializeIncoming();
    _headers=HandshakeResponse.createResponse(HEADERS_READ);
    _headersWritten=HandshakeResponse.createResponse(HEADERS_WRITTEN);
    _connectionTime=System.currentTimeMillis();
    _softMax=ConnectionSettings.SOFT_MAX.getValue();
    if (isGoodUltrapeer() || isGoodLeaf()) {
      _softMax++;
    }
    if (isWriteDeflated()) {
      _deflater=new Deflater();
      _out=new CompressingOutputStream(_out,_deflater);
    }
    if (isReadDeflated()) {
      _inflater=new Inflater();
      _in=new UncompressingInputStream(_in,_inflater);
    }
    RESPONSE_HEADERS=null;
  }
 catch (  NoGnutellaOkException e) {
    close();
    throw e;
  }
catch (  IOException e) {
    close();
    throw new BadHandshakeException(e);
  }
}",0.9881147540983608
4570,"/** 
 * Sends a push request for the given file.  Returns false iff no push could be sent, i.e., because no routing entry exists. That generally means you shouldn't send any more pushes for this file.
 * @param file the <tt>RemoteFileDesc</tt> constructed from the query hit, containing data about the host we're pushing to
 * @return <tt>true</tt> if the push was successfully sent, otherwise<tt>false</tt>
 */
public boolean sendPush(RemoteFileDesc file){
  debug(""String_Node_Str"");
  if (file.isReplyToMulticast()) {
    PushRequest pr=new PushRequest(GUID.makeGuid(),(byte)1,file.getClientGUID(),file.getIndex(),RouterService.getNonForcedAddress(),RouterService.getNonForcedPort());
    router.sendMulticastPushRequest(pr);
    return true;
  }
  Set proxies=file.getPushProxies();
  if (!proxies.isEmpty()) {
    debug(""String_Node_Str"");
    boolean requestSuccessful=false;
    final String requestString=""String_Node_Str"" + Base32.encode(file.getClientGUID());
    final String nodeString=""String_Node_Str"";
    final String nodeValue=NetworkUtils.ip2string(RouterService.getAddress()) + ""String_Node_Str"" + RouterService.getPort();
    Iterator iter=proxies.iterator();
    while (iter.hasNext() && !requestSuccessful) {
      PushProxyInterface ppi=(PushProxyInterface)iter.next();
      try {
        String ip=ppi.getPushProxyAddress().getHostName();
        int port=ppi.getPushProxyPort();
        URL url=new URL(""String_Node_Str"",ip,port,requestString);
        HttpURLConnection connection=(HttpURLConnection)url.openConnection();
        connection.setUseCaches(false);
        connection.setRequestProperty(nodeString,nodeValue);
        requestSuccessful=(connection.getResponseCode() == 202);
        connection.disconnect();
      }
 catch (      MalformedURLException url) {
        ErrorService.error(url);
      }
catch (      IOException ioe) {
      }
    }
    if (requestSuccessful)     return requestSuccessful;
  }
  PushRequest pr=new PushRequest(GUID.makeGuid(),ConnectionSettings.TTL.getValue(),file.getClientGUID(),file.getIndex(),RouterService.getAddress(),RouterService.getPort());
  try {
    router.sendPushRequest(pr);
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}","/** 
 * Sends a push request for the given file.  Returns false iff no push could be sent, i.e., because no routing entry exists. That generally means you shouldn't send any more pushes for this file.
 * @param file the <tt>RemoteFileDesc</tt> constructed from the query hit, containing data about the host we're pushing to
 * @return <tt>true</tt> if the push was successfully sent, otherwise<tt>false</tt>
 */
public boolean sendPush(RemoteFileDesc file){
  debug(""String_Node_Str"");
  if (file.isReplyToMulticast()) {
    byte[] addr=RouterService.getNonForcedAddress();
    int port=RouterService.getNonForcedPort();
    if (NetworkUtils.isValidAddress(addr) && NetworkUtils.isValidPort(port)) {
      PushRequest pr=new PushRequest(GUID.makeGuid(),(byte)1,file.getClientGUID(),file.getIndex(),addr,port);
      router.sendMulticastPushRequest(pr);
      return true;
    }
  }
  byte[] addr=RouterService.getAddress();
  int port=RouterService.getPort();
  if (!NetworkUtils.isValidAddress(addr) || !NetworkUtils.isValidPort(port))   return false;
  Set proxies=file.getPushProxies();
  if (!proxies.isEmpty()) {
    debug(""String_Node_Str"");
    boolean requestSuccessful=false;
    final String requestString=""String_Node_Str"" + Base32.encode(file.getClientGUID());
    final String nodeString=""String_Node_Str"";
    final String nodeValue=NetworkUtils.ip2string(addr) + ""String_Node_Str"" + port;
    Iterator iter=proxies.iterator();
    while (iter.hasNext() && !requestSuccessful) {
      PushProxyInterface ppi=(PushProxyInterface)iter.next();
      try {
        String ppIp=ppi.getPushProxyAddress().getHostName();
        int ppPort=ppi.getPushProxyPort();
        URL url=new URL(""String_Node_Str"",ppIp,ppPort,requestString);
        HttpURLConnection connection=(HttpURLConnection)url.openConnection();
        connection.setUseCaches(false);
        connection.setRequestProperty(nodeString,nodeValue);
        requestSuccessful=(connection.getResponseCode() == 202);
        connection.disconnect();
      }
 catch (      MalformedURLException url) {
        ErrorService.error(url);
      }
catch (      IOException ioe) {
      }
    }
    if (requestSuccessful)     return requestSuccessful;
  }
  PushRequest pr=new PushRequest(GUID.makeGuid(),ConnectionSettings.TTL.getValue(),file.getClientGUID(),file.getIndex(),addr,port);
  try {
    router.sendPushRequest(pr);
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}",0.8666524429272455
4571,"/** 
 * Adds an incomplete file to be used for partial file sharing.
 * @modifies this
 * @param incompleteFile the incomplete file.
 * @param urns the set of all known URNs for this incomplete file
 * @param name the completed name of this incomplete file
 * @param size the completed size of this incomplete file
 * @param vf the VerifyingFile containing the ranges for this inc. file
 */
public synchronized void addIncompleteFile(File incompleteFile,Set urns,String name,int size,VerifyingFile vf){
  try {
    incompleteFile=FileUtils.getCanonicalFile(incompleteFile);
  }
 catch (  IOException ioe) {
  }
  Iterator iter=urns.iterator();
  while (iter.hasNext()) {
    IntSet shared=(IntSet)_urnIndex.get(iter.next());
    if (shared == null)     continue;
    IntSet.IntSetIterator isIter=shared.iterator();
    for (; isIter.hasNext(); ) {
      int i=isIter.next();
      FileDesc desc=(FileDesc)_files.get(i);
      if (desc == null)       continue;
      String incPath=incompleteFile.getAbsolutePath();
      String path=desc.getFile().getAbsolutePath();
      if (incPath.equals(path))       return;
    }
  }
  int fileIndex=_files.size();
  _incompletesShared.add(fileIndex);
  IncompleteFileDesc ifd=new IncompleteFileDesc(incompleteFile,urns,fileIndex,name,size,vf);
  _files.add(ifd);
  _fileToFileDesc.put(incompleteFile,ifd);
  this.updateUrnIndex(ifd);
  _numIncompleteFiles++;
  File parent=FileUtils.getParentFile(incompleteFile);
  RouterService.getCallback().addSharedFile(ifd,parent);
}","/** 
 * Adds an incomplete file to be used for partial file sharing.
 * @modifies this
 * @param incompleteFile the incomplete file.
 * @param urns the set of all known URNs for this incomplete file
 * @param name the completed name of this incomplete file
 * @param size the completed size of this incomplete file
 * @param vf the VerifyingFile containing the ranges for this inc. file
 */
public synchronized void addIncompleteFile(File incompleteFile,Set urns,String name,int size,VerifyingFile vf){
  try {
    incompleteFile=FileUtils.getCanonicalFile(incompleteFile);
  }
 catch (  IOException ioe) {
    ErrorService.error(ioe);
    return;
  }
  Iterator iter=urns.iterator();
  while (iter.hasNext()) {
    IntSet shared=(IntSet)_urnIndex.get(iter.next());
    if (shared == null)     continue;
    IntSet.IntSetIterator isIter=shared.iterator();
    for (; isIter.hasNext(); ) {
      int i=isIter.next();
      FileDesc desc=(FileDesc)_files.get(i);
      if (desc == null)       continue;
      String incPath=incompleteFile.getAbsolutePath();
      String path=desc.getFile().getAbsolutePath();
      if (incPath.equals(path))       return;
    }
  }
  int fileIndex=_files.size();
  _incompletesShared.add(fileIndex);
  IncompleteFileDesc ifd=new IncompleteFileDesc(incompleteFile,urns,fileIndex,name,size,vf);
  _files.add(ifd);
  _fileToFileDesc.put(incompleteFile,ifd);
  this.updateUrnIndex(ifd);
  _numIncompleteFiles++;
  File parent=FileUtils.getParentFile(incompleteFile);
  RouterService.getCallback().addSharedFile(ifd,parent);
}",0.9866231647634583
4572,"public void run(){
  try {
    if (RouterService.acceptedIncomingConnection() && RouterService.isSupernode()) {
      Endpoint e=new Endpoint(RouterService.getAddress(),RouterService.getPort());
      if (!e.isPrivateAddress()) {
        gWebCache.sendUpdatesAsync(e);
      }
    }
  }
 catch (  Throwable t) {
    ErrorService.error(t);
  }
}","public void run(){
  try {
    if (RouterService.acceptedIncomingConnection() && RouterService.isSupernode()) {
      byte[] addr=RouterService.getAddress();
      int port=RouterService.getPort();
      if (NetworkUtils.isValidAddress(addr) && NetworkUtils.isValidPort(port) && !NetworkUtils.isPrivateAddress(addr)) {
        Endpoint e=new Endpoint(addr,port);
        gWebCache.sendUpdatesAsync(e);
      }
    }
  }
 catch (  Throwable t) {
    ErrorService.error(t);
  }
}",0.633373934226553
4573,"/** 
 * Links the HostCatcher up with the other back end pieces, and, if quick connect is not specified in the SettingsManager, loads the hosts in the host list into the maybe set.  (The likelys set is empty.)  If filename does not exist, then no error message is printed and this is initially empty.  The file is expected to contain a sequence of lines in the format ""<host>:port\n"".  Lines not in this format are silently ignored.
 */
public void initialize(){
  try {
    read(HOST_FILE);
  }
 catch (  FileNotFoundException e) {
  }
catch (  IOException e) {
  }
  Runnable updater=new Runnable(){
    public void run(){
      try {
        if (RouterService.acceptedIncomingConnection() && RouterService.isSupernode()) {
          Endpoint e=new Endpoint(RouterService.getAddress(),RouterService.getPort());
          if (!e.isPrivateAddress()) {
            gWebCache.sendUpdatesAsync(e);
          }
        }
      }
 catch (      Throwable t) {
        ErrorService.error(t);
      }
    }
  }
;
  RouterService.schedule(updater,BootstrapServerManager.UPDATE_DELAY_MSEC,BootstrapServerManager.UPDATE_DELAY_MSEC);
}","/** 
 * Links the HostCatcher up with the other back end pieces, and, if quick connect is not specified in the SettingsManager, loads the hosts in the host list into the maybe set.  (The likelys set is empty.)  If filename does not exist, then no error message is printed and this is initially empty.  The file is expected to contain a sequence of lines in the format ""<host>:port\n"".  Lines not in this format are silently ignored.
 */
public void initialize(){
  try {
    read(HOST_FILE);
  }
 catch (  FileNotFoundException e) {
  }
catch (  IOException e) {
  }
  Runnable updater=new Runnable(){
    public void run(){
      try {
        if (RouterService.acceptedIncomingConnection() && RouterService.isSupernode()) {
          byte[] addr=RouterService.getAddress();
          int port=RouterService.getPort();
          if (NetworkUtils.isValidAddress(addr) && NetworkUtils.isValidPort(port) && !NetworkUtils.isPrivateAddress(addr)) {
            Endpoint e=new Endpoint(addr,port);
            gWebCache.sendUpdatesAsync(e);
          }
        }
      }
 catch (      Throwable t) {
        ErrorService.error(t);
      }
    }
  }
;
  RouterService.schedule(updater,BootstrapServerManager.UPDATE_DELAY_MSEC,BootstrapServerManager.UPDATE_DELAY_MSEC);
}",0.867197318810222
4574,"/** 
 * Creates a new <tt>PingReply</tt> from the set of cached GUESS endpoints, or a <tt>PingReply</tt> for localhost if no GUESS endpoints are available.
 */
private PingReply createPingReply(byte[] guid){
  GUESSEndpoint endpoint=UNICASTER.getUnicastEndpoint();
  if (endpoint == null) {
    return PingReply.create(guid,(byte)1);
  }
 else {
    return PingReply.createGUESSReply(guid,(byte)1,endpoint.getPort(),endpoint.getAddress().getAddress());
  }
}","/** 
 * Creates a new <tt>PingReply</tt> from the set of cached GUESS endpoints, or a <tt>PingReply</tt> for localhost if no GUESS endpoints are available.
 */
private PingReply createPingReply(byte[] guid){
  GUESSEndpoint endpoint=UNICASTER.getUnicastEndpoint();
  if (endpoint == null) {
    if (NetworkUtils.isValidPort(RouterService.getPort()) && NetworkUtils.isValidAddress(RouterService.getAddress()))     return PingReply.create(guid,(byte)1);
 else     return null;
  }
 else {
    return PingReply.createGUESSReply(guid,(byte)1,endpoint.getPort(),endpoint.getAddress().getAddress());
  }
}",0.8666035950804163
4575,"/** 
 * Sends an ack back to the GUESS client node.  
 */
protected void sendAcknowledgement(DatagramPacket datagram,byte[] guid){
  ConnectionManager manager=RouterService.getConnectionManager();
  Endpoint host=manager.getConnectedGUESSUltrapeer();
  PingReply reply;
  if (host != null) {
    try {
      reply=PingReply.createGUESSReply(guid,(byte)1,host);
    }
 catch (    UnknownHostException e) {
      reply=createPingReply(guid);
    }
  }
 else {
    reply=createPingReply(guid);
  }
  try {
    UDPService.instance().send(reply,datagram.getAddress(),datagram.getPort());
  }
 catch (  IOException ioe) {
    ErrorService.error(ioe,""String_Node_Str"" + datagram.getAddress() + ""String_Node_Str""+ datagram.getPort());
  }
  if (RECORD_STATS)   SentMessageStatHandler.UDP_PING_REPLIES.addMessage(reply);
}","/** 
 * Sends an ack back to the GUESS client node.  
 */
protected void sendAcknowledgement(DatagramPacket datagram,byte[] guid){
  ConnectionManager manager=RouterService.getConnectionManager();
  Endpoint host=manager.getConnectedGUESSUltrapeer();
  PingReply reply;
  if (host != null) {
    try {
      reply=PingReply.createGUESSReply(guid,(byte)1,host);
    }
 catch (    UnknownHostException e) {
      reply=createPingReply(guid);
    }
  }
 else {
    reply=createPingReply(guid);
  }
  if (reply == null)   return;
  try {
    UDPService.instance().send(reply,datagram.getAddress(),datagram.getPort());
  }
 catch (  IOException ioe) {
    ErrorService.error(ioe,""String_Node_Str"" + datagram.getAddress() + ""String_Node_Str""+ datagram.getPort());
  }
  if (RECORD_STATS)   SentMessageStatHandler.UDP_PING_REPLIES.addMessage(reply);
}",0.9812914906457452
4576,"/** 
 * The handler for all message types.  Processes a message based on the  message type.
 * @param msg the <tt>Message</tt> received
 * @param datagram the <tt>DatagramPacket</tt> containing the IP and port of the client node
 */
public void handleUDPMessage(Message msg,DatagramPacket datagram){
  msg.hop();
  InetAddress address=datagram.getAddress();
  int port=datagram.getPort();
  ReplyHandler handler=new UDPReplyHandler(address,port);
  if (msg instanceof QueryRequest) {
    if (hasValidQueryKey(address,port,(QueryRequest)msg)) {
      sendAcknowledgement(datagram,msg.getGUID());
      if (!handleUDPQueryRequestPossibleDuplicate((QueryRequest)msg,handler)) {
        ReceivedMessageStatHandler.UDP_DUPLICATE_QUERIES.addMessage(msg);
      }
    }
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_QUERY_REQUESTS.addMessage(msg);
  }
 else   if (msg instanceof QueryReply) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_QUERY_REPLIES.addMessage(msg);
    handleQueryReply((QueryReply)msg,handler);
  }
 else   if (msg instanceof PingRequest) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_PING_REQUESTS.addMessage(msg);
    handleUDPPingRequestPossibleDuplicate((PingRequest)msg,handler,datagram);
  }
 else   if (msg instanceof PingReply) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_PING_REPLIES.addMessage(msg);
    handleUDPPingReply((PingReply)msg,handler,address,port);
  }
 else   if (msg instanceof PushRequest) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_PUSH_REQUESTS.addMessage(msg);
    handlePushRequest((PushRequest)msg,handler);
  }
 else   if (msg instanceof LimeACKVendorMessage) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_LIME_ACK.addMessage(msg);
    handleLimeACKMessage((LimeACKVendorMessage)msg,datagram);
  }
}","/** 
 * The handler for all message types.  Processes a message based on the  message type.
 * @param msg the <tt>Message</tt> received
 * @param datagram the <tt>DatagramPacket</tt> containing the IP and port of the client node
 */
public void handleUDPMessage(Message msg,DatagramPacket datagram){
  msg.hop();
  InetAddress address=datagram.getAddress();
  int port=datagram.getPort();
  if (!NetworkUtils.isValidAddress(address) || !NetworkUtils.isValidPort(port))   return;
  ReplyHandler handler=new UDPReplyHandler(address,port);
  if (msg instanceof QueryRequest) {
    if (hasValidQueryKey(address,port,(QueryRequest)msg)) {
      sendAcknowledgement(datagram,msg.getGUID());
      if (!handleUDPQueryRequestPossibleDuplicate((QueryRequest)msg,handler)) {
        ReceivedMessageStatHandler.UDP_DUPLICATE_QUERIES.addMessage(msg);
      }
    }
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_QUERY_REQUESTS.addMessage(msg);
  }
 else   if (msg instanceof QueryReply) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_QUERY_REPLIES.addMessage(msg);
    handleQueryReply((QueryReply)msg,handler);
  }
 else   if (msg instanceof PingRequest) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_PING_REQUESTS.addMessage(msg);
    handleUDPPingRequestPossibleDuplicate((PingRequest)msg,handler,datagram);
  }
 else   if (msg instanceof PingReply) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_PING_REPLIES.addMessage(msg);
    handleUDPPingReply((PingReply)msg,handler,address,port);
  }
 else   if (msg instanceof PushRequest) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_PUSH_REQUESTS.addMessage(msg);
    handlePushRequest((PushRequest)msg,handler);
  }
 else   if (msg instanceof LimeACKVendorMessage) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.UDP_LIME_ACK.addMessage(msg);
    handleLimeACKMessage((LimeACKVendorMessage)msg,datagram);
  }
}",0.9759229534510432
4577,"/** 
 * Uses the push route table to send a push request to the appropriate connection.  Since this is used for PushRequests orginating here, no stats are updated.
 * @throws IOException if no appropriate route exists.
 */
public void sendPushRequest(PushRequest push) throws IOException {
  if (push == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  ReplyHandler replyHandler=_pushRouteTable.getReplyHandler(push.getClientGUID());
  if (replyHandler != null)   replyHandler.handlePushRequest(push,null);
 else   throw new IOException(""String_Node_Str"");
}","/** 
 * Uses the push route table to send a push request to the appropriate connection.  Since this is used for PushRequests orginating here, no stats are updated.
 * @throws IOException if no appropriate route exists.
 */
public void sendPushRequest(PushRequest push) throws IOException {
  if (push == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  ReplyHandler replyHandler=_pushRouteTable.getReplyHandler(push.getClientGUID());
  if (replyHandler != null)   replyHandler.handlePushRequest(push,FOR_ME_REPLY_HANDLER);
 else   throw new IOException(""String_Node_Str"");
}",0.9795221843003412
4578,"/** 
 * Notifies components that this' IP address has changed.
 */
public static boolean addressChanged(){
  if (!NetworkUtils.isValidAddress(getAddress()))   return false;
  if (!NetworkUtils.isValidPort(getPort()))   return false;
  FileDesc[] fds=fileManager.getAllSharedFileDescriptors();
  for (int i=0; i < fds.length; i++)   fds[i].addUrnsForSelf();
  return true;
}","/** 
 * Notifies components that this' IP address has changed.
 */
public static boolean addressChanged(){
  byte addr[]=getAddress();
  if (!NetworkUtils.isValidAddress(addr))   return false;
  if (NetworkUtils.isPrivateAddress(addr))   return false;
  if (!NetworkUtils.isValidPort(getPort()))   return false;
  FileDesc[] fds=fileManager.getAllSharedFileDescriptors();
  for (int i=0; i < fds.length; i++)   fds[i].addUrnsForSelf();
  return true;
}",0.8945454545454545
4579,"protected boolean respondToQueryRequest(QueryRequest queryRequest,byte[] clientGUID){
  Response[] responses=RouterService.getFileManager().query(queryRequest);
  if (RouterService.isShieldedLeaf() && queryRequest.isTCP()) {
    if (RECORD_STATS) {
      if (responses != null && responses.length > 0)       RoutedQueryStat.LEAF_HIT.incrementStat();
 else       RoutedQueryStat.LEAF_FALSE_POSITIVE.incrementStat();
    }
  }
  return sendResponses(responses,queryRequest);
}","protected boolean respondToQueryRequest(QueryRequest queryRequest,byte[] clientGUID){
  if (!NetworkUtils.isValidPort(RouterService.getPort()) || !NetworkUtils.isValidAddress(RouterService.getAddress()))   return false;
  Response[] responses=RouterService.getFileManager().query(queryRequest);
  if (RouterService.isShieldedLeaf() && queryRequest.isTCP()) {
    if (RECORD_STATS) {
      if (responses != null && responses.length > 0)       RoutedQueryStat.LEAF_HIT.incrementStat();
 else       RoutedQueryStat.LEAF_FALSE_POSITIVE.incrementStat();
    }
  }
  return sendResponses(responses,queryRequest);
}",0.8761552680221811
4580,"/** 
 * Constructor that sets the ip and port to reply to.
 * @param ip the <tt>InetAddress</tt> to reply to
 * @param port the port to reply to
 */
public UDPReplyHandler(InetAddress ip,int port){
  IP=ip;
  PORT=port;
}","/** 
 * Constructor that sets the ip and port to reply to.
 * @param ip the <tt>InetAddress</tt> to reply to
 * @param port the port to reply to
 */
public UDPReplyHandler(InetAddress ip,int port){
  if (!NetworkUtils.isValidPort(port))   throw new IllegalArgumentException(""String_Node_Str"" + port);
  if (!NetworkUtils.isValidAddress(ip))   throw new IllegalArgumentException(""String_Node_Str"" + ip);
  IP=ip;
  PORT=port;
}",0.6831530139103554
4581,"/** 
 * Sends the <tt>Message</tt> via UDP to the port and IP address specified. This method should not be called if the client is not GUESS enabled.
 * @param msg  the <tt>Message</tt> to send
 * @param ip   the <tt>InetAddress</tt> to send to
 * @param port the port to send to
 */
public synchronized void send(Message msg,InetAddress ip,int port) throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    msg.write(baos);
  }
 catch (  IOException e) {
    ErrorService.error(e);
    return;
  }
  byte[] data=baos.toByteArray();
  DatagramPacket dg=new DatagramPacket(data,data.length,ip,port);
synchronized (_sendLock) {
    if (_socket == null)     return;
    try {
      _socket.send(dg);
    }
 catch (    BindException be) {
      return;
    }
catch (    IOException ioe) {
      if (""String_Node_Str"".equals(ioe.getMessage()))       return;
      throw ioe;
    }
  }
}","/** 
 * Sends the <tt>Message</tt> via UDP to the port and IP address specified. This method should not be called if the client is not GUESS enabled. If sending fails for reasons such as a BindException, NoRouteToHostException or specific IOExceptions such as ""No buffer space available"", this message is silently dropped.
 * @param msg  the <tt>Message</tt> to send
 * @param ip   the <tt>InetAddress</tt> to send to
 * @param port the port to send to
 */
public synchronized void send(Message msg,InetAddress ip,int port) throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    msg.write(baos);
  }
 catch (  IOException e) {
    ErrorService.error(e);
    return;
  }
  byte[] data=baos.toByteArray();
  DatagramPacket dg=new DatagramPacket(data,data.length,ip,port);
synchronized (_sendLock) {
    if (_socket == null)     return;
    try {
      _socket.send(dg);
    }
 catch (    BindException be) {
      return;
    }
catch (    NoRouteToHostException nrthe) {
      return;
    }
catch (    IOException ioe) {
      if (""String_Node_Str"".equals(ioe.getMessage()))       return;
      throw ioe;
    }
  }
}",0.3233301064859632
4582,"/** 
 * Notifies all existing HTTPDownloaders about this RFD. If good is true, it notifies them of a succesful alternate location, otherwise it notifies them of a failed alternate location. The internal validAlts is also updated if good is true, and invalidAlts is updated if good is false. The IncompleteFileDesc is also notified of new locations for this file.
 */
private synchronized void informMesh(RemoteFileDesc rfd,boolean good){
  if (!rfd.isAltLocCapable())   return;
  URN bucketHash=buckets.getURNForBucket(bucketNumber);
  Assert.that(bucketHash != null,""String_Node_Str"");
  Assert.that(bucketHash.equals(rfd.getSHA1Urn()),""String_Node_Str"");
  if (validAlts == null)   validAlts=AlternateLocationCollection.create(bucketHash);
  AlternateLocation loc=null;
  AlternateLocation forFD=null;
  try {
    loc=AlternateLocation.create(rfd);
    forFD=AlternateLocation.create(rfd);
  }
 catch (  IOException iox) {
    return;
  }
  for (Iterator iter=dloaders.iterator(); iter.hasNext(); ) {
    HTTPDownloader httpDloader=(HTTPDownloader)iter.next();
    RemoteFileDesc r=httpDloader.getRemoteFileDesc();
    if (r.getHost() == rfd.getHost() && r.getPort() == rfd.getPort())     continue;
    if (good)     httpDloader.addSuccessfulAltLoc(loc);
 else     httpDloader.addFailedAltLoc(loc);
  }
  FileDesc fd=fileManager.getFileDescForFile(incompleteFile);
  IncompleteFileDesc ifd=null;
  if (fd != null && fd instanceof IncompleteFileDesc) {
    ifd=(IncompleteFileDesc)fd;
    if (!bucketHash.equals(ifd.getSHA1Urn())) {
      Assert.silent(false,""String_Node_Str"");
      fileManager.removeFileIfShared(incompleteFile);
    }
  }
  if (good) {
    if (!validAlts.contains(loc)) {
      if (RECORD_STATS && rfd.isFromAlternateLocation())       DownloadStat.ALTERNATE_WORKED.incrementStat();
      validAlts.add(loc);
      if (ifd != null)       ifd.addVerified(forFD);
    }
  }
 else {
    if (RECORD_STATS && rfd.isFromAlternateLocation())     DownloadStat.ALTERNATE_NOT_ADDED.incrementStat();
    validAlts.remove(loc);
    if (ifd != null)     ifd.remove(forFD);
    invalidAlts.put(rfd,rfd);
  }
}","/** 
 * Notifies all existing HTTPDownloaders about this RFD. If good is true, it notifies them of a succesful alternate location, otherwise it notifies them of a failed alternate location. The internal validAlts is also updated if good is true, and invalidAlts is updated if good is false. The IncompleteFileDesc is also notified of new locations for this file.
 */
private synchronized void informMesh(RemoteFileDesc rfd,boolean good){
  if (!rfd.isAltLocCapable())   return;
  URN bucketHash=buckets.getURNForBucket(bucketNumber);
  Assert.that(bucketHash != null,""String_Node_Str"");
  Assert.that(bucketHash.equals(rfd.getSHA1Urn()),""String_Node_Str"");
  if (validAlts == null)   validAlts=AlternateLocationCollection.create(bucketHash);
  AlternateLocation loc=null;
  AlternateLocation forFD=null;
  try {
    loc=AlternateLocation.create(rfd);
    forFD=AlternateLocation.create(rfd);
  }
 catch (  IOException iox) {
    return;
  }
  for (Iterator iter=dloaders.iterator(); iter.hasNext(); ) {
    HTTPDownloader httpDloader=(HTTPDownloader)iter.next();
    RemoteFileDesc r=httpDloader.getRemoteFileDesc();
    if (r.getHost() == rfd.getHost() && r.getPort() == rfd.getPort())     continue;
    if (good)     httpDloader.addSuccessfulAltLoc(loc);
 else     httpDloader.addFailedAltLoc(loc);
  }
  FileDesc fd=fileManager.getFileDescForFile(incompleteFile);
  IncompleteFileDesc ifd=null;
  if (fd != null && fd instanceof IncompleteFileDesc) {
    ifd=(IncompleteFileDesc)fd;
    if (!bucketHash.equals(ifd.getSHA1Urn())) {
      Assert.silent(false,""String_Node_Str"");
      fileManager.removeFileIfShared(incompleteFile);
      ifd=null;
    }
  }
  if (good) {
    if (!validAlts.contains(loc)) {
      if (RECORD_STATS && rfd.isFromAlternateLocation())       DownloadStat.ALTERNATE_WORKED.incrementStat();
      validAlts.add(loc);
      if (ifd != null)       ifd.addVerified(forFD);
    }
  }
 else {
    if (RECORD_STATS && rfd.isFromAlternateLocation())     DownloadStat.ALTERNATE_NOT_ADDED.incrementStat();
    validAlts.remove(loc);
    if (ifd != null)     ifd.remove(forFD);
    invalidAlts.put(rfd,rfd);
  }
}",0.9962335216572504
4583,"/** 
 * @param network the network this was received from.
 * @requires buf.length==23
 * @effects exactly like Message.read(in), but buf is used as scratch forreading the header.  This is an optimization that lets you avoid repeatedly allocating 23-byte arrays.  buf may be used when this returns, but the contents are not guaranteed to contain any useful data.  
 */
public static Message read(InputStream in,byte[] buf,int network,byte softMax) throws BadPacketException, IOException {
  for (int i=0; i < 23; ) {
    int got;
    try {
      got=in.read(buf,i,23 - i);
    }
 catch (    InterruptedIOException e) {
      if (i == 0)       return null;
 else       throw e;
    }
    if (got == -1) {
      if (RECORD_STATS)       ReceivedErrorStat.CONNECTION_CLOSED.incrementStat();
      throw new IOException(""String_Node_Str"");
    }
    i+=got;
  }
  byte func=buf[16];
  byte ttl=buf[17];
  byte hops=buf[18];
  int length=ByteOrder.leb2int(buf,19);
  if (length < 0 || length > MessageSettings.MAX_LENGTH.getValue()) {
    if (RECORD_STATS)     ReceivedErrorStat.INVALID_LENGTH.incrementStat();
    throw new IOException(""String_Node_Str"" + length);
  }
  byte[] payload=null;
  if (length != 0) {
    payload=new byte[length];
    for (int i=0; i < length; ) {
      int got=in.read(payload,i,length - i);
      if (got == -1) {
        if (RECORD_STATS)         ReceivedErrorStat.CONNECTION_CLOSED.incrementStat();
        throw new IOException(""String_Node_Str"");
      }
      i+=got;
    }
  }
 else   payload=new byte[0];
  byte hardMax=(byte)14;
  if (hops < 0) {
    if (RECORD_STATS)     ReceivedErrorStat.INVALID_HOPS.incrementStat();
    throw new BadPacketException(""String_Node_Str"");
  }
 else   if (ttl < 0) {
    if (RECORD_STATS)     ReceivedErrorStat.INVALID_TTL.incrementStat();
    throw new BadPacketException(""String_Node_Str"");
  }
 else   if ((hops >= softMax) && (func != F_QUERY_REPLY) && (func != F_PING_REPLY)) {
    if (RECORD_STATS)     ReceivedErrorStat.HOPS_EXCEED_SOFT_MAX.incrementStat();
    throw BadPacketException.HOPS_EXCEED_SOFT_MAX;
  }
 else   if (ttl + hops > hardMax) {
    if (RECORD_STATS)     ReceivedErrorStat.HOPS_AND_TTL_OVER_HARD_MAX.incrementStat();
    throw new BadPacketException(""String_Node_Str"");
  }
 else   if ((ttl + hops > softMax) && (func != F_QUERY_REPLY) && (func != F_PING_REPLY)) {
    ttl=(byte)(softMax - hops);
    Assert.that(ttl >= 0);
  }
  byte[] guid=new byte[16];
  for (int i=0; i < 16; i++)   guid[i]=buf[i];
switch (func) {
case F_PING:
    if (length > 0)     return new PingRequest(guid,ttl,hops,payload);
  return new PingRequest(guid,ttl,hops);
case F_PING_REPLY:
return PingReply.createFromNetwork(guid,ttl,hops,payload);
case F_QUERY:
if (length < 3) break;
return QueryRequest.createNetworkQuery(guid,ttl,hops,payload,network);
case F_QUERY_REPLY:
if (length < 26) break;
return new QueryReply(guid,ttl,hops,payload);
case F_PUSH:
return new PushRequest(guid,ttl,hops,payload,network);
case F_ROUTE_TABLE_UPDATE:
return RouteTableMessage.read(guid,ttl,hops,payload);
case F_VENDOR_MESSAGE:
if ((ttl != 1) || (hops != 0)) throw new BadPacketException(""String_Node_Str"" + ttl + ""String_Node_Str""+ hops);
return VendorMessage.deriveVendorMessage(guid,ttl,hops,payload);
case F_VENDOR_MESSAGE_STABLE:
if ((ttl != 1) || (hops != 0)) throw new BadPacketException(""String_Node_Str"" + ttl + ""String_Node_Str""+ hops);
return VendorMessage.deriveVendorMessage(guid,ttl,hops,payload);
}
if (RECORD_STATS) ReceivedErrorStat.INVALID_CODE.incrementStat();
throw new BadPacketException(""String_Node_Str"" + func);
}","/** 
 * @param network the network this was received from.
 * @requires buf.length==23
 * @effects exactly like Message.read(in), but buf is used as scratch forreading the header.  This is an optimization that lets you avoid repeatedly allocating 23-byte arrays.  buf may be used when this returns, but the contents are not guaranteed to contain any useful data.  
 */
public static Message read(InputStream in,byte[] buf,int network,byte softMax) throws BadPacketException, IOException {
  for (int i=0; i < 23; ) {
    int got;
    try {
      got=in.read(buf,i,23 - i);
    }
 catch (    InterruptedIOException e) {
      if (i == 0)       return null;
 else       throw e;
    }
    if (got == -1) {
      if (RECORD_STATS)       ReceivedErrorStat.CONNECTION_CLOSED.incrementStat();
      throw new IOException(""String_Node_Str"");
    }
    i+=got;
  }
  byte func=buf[16];
  byte ttl=buf[17];
  byte hops=buf[18];
  int length=ByteOrder.leb2int(buf,19);
  if (length < 0 || length > MessageSettings.MAX_LENGTH.getValue()) {
    if (RECORD_STATS)     ReceivedErrorStat.INVALID_LENGTH.incrementStat();
    throw new IOException(""String_Node_Str"" + length);
  }
  byte[] payload=null;
  if (length != 0) {
    payload=new byte[length];
    for (int i=0; i < length; ) {
      int got=in.read(payload,i,length - i);
      if (got == -1) {
        if (RECORD_STATS)         ReceivedErrorStat.CONNECTION_CLOSED.incrementStat();
        throw new IOException(""String_Node_Str"");
      }
      i+=got;
    }
  }
 else   payload=new byte[0];
  byte hardMax=(byte)14;
  if (hops < 0) {
    if (RECORD_STATS)     ReceivedErrorStat.INVALID_HOPS.incrementStat();
    throw new BadPacketException(""String_Node_Str"");
  }
 else   if (ttl < 0) {
    if (RECORD_STATS)     ReceivedErrorStat.INVALID_TTL.incrementStat();
    throw new BadPacketException(""String_Node_Str"");
  }
 else   if ((hops > softMax) && (func != F_QUERY_REPLY) && (func != F_PING_REPLY)) {
    if (RECORD_STATS)     ReceivedErrorStat.HOPS_EXCEED_SOFT_MAX.incrementStat();
    throw BadPacketException.HOPS_EXCEED_SOFT_MAX;
  }
 else   if (ttl + hops > hardMax) {
    if (RECORD_STATS)     ReceivedErrorStat.HOPS_AND_TTL_OVER_HARD_MAX.incrementStat();
    throw new BadPacketException(""String_Node_Str"");
  }
 else   if ((ttl + hops > softMax) && (func != F_QUERY_REPLY) && (func != F_PING_REPLY)) {
    ttl=(byte)(softMax - hops);
    Assert.that(ttl >= 0);
  }
  byte[] guid=new byte[16];
  for (int i=0; i < 16; i++)   guid[i]=buf[i];
switch (func) {
case F_PING:
    if (length > 0)     return new PingRequest(guid,ttl,hops,payload);
  return new PingRequest(guid,ttl,hops);
case F_PING_REPLY:
return PingReply.createFromNetwork(guid,ttl,hops,payload);
case F_QUERY:
if (length < 3) break;
return QueryRequest.createNetworkQuery(guid,ttl,hops,payload,network);
case F_QUERY_REPLY:
if (length < 26) break;
return new QueryReply(guid,ttl,hops,payload);
case F_PUSH:
return new PushRequest(guid,ttl,hops,payload,network);
case F_ROUTE_TABLE_UPDATE:
return RouteTableMessage.read(guid,ttl,hops,payload);
case F_VENDOR_MESSAGE:
if ((ttl != 1) || (hops != 0)) throw new BadPacketException(""String_Node_Str"" + ttl + ""String_Node_Str""+ hops);
return VendorMessage.deriveVendorMessage(guid,ttl,hops,payload);
case F_VENDOR_MESSAGE_STABLE:
if ((ttl != 1) || (hops != 0)) throw new BadPacketException(""String_Node_Str"" + ttl + ""String_Node_Str""+ hops);
return VendorMessage.deriveVendorMessage(guid,ttl,hops,payload);
}
if (RECORD_STATS) ReceivedErrorStat.INVALID_CODE.incrementStat();
throw new BadPacketException(""String_Node_Str"" + func);
}",0.9998609372827144
4584,"/** 
 * Constructs a new URN based on the specified <tt>File</tt> instance. The constructor calculates the SHA1 value for the file, and is a costly operation as a result.
 * @param file the <tt>File</tt> instance to construct the URN from
 * @param urnType the type of URN to construct for the <tt>File</tt>instance, such as SHA1_URN
 */
private URN(final String urnString,final UrnType urnType){
  this._urnString=urnString;
  this._urnType=urnType;
}","/** 
 * Constructs a new URN based on the specified <tt>File</tt> instance. The constructor calculates the SHA1 value for the file, and is a costly operation as a result.
 * @param file the <tt>File</tt> instance to construct the URN from
 * @param urnType the type of URN to construct for the <tt>File</tt>instance, such as SHA1_URN
 */
private URN(final String urnString,final UrnType urnType){
  int lastColon=urnString.lastIndexOf(""String_Node_Str"");
  String nameSpace=urnString.substring(0,lastColon + 1);
  String hash=urnString.substring(lastColon + 1);
  this._urnString=nameSpace.toLowerCase() + hash.toUpperCase();
  this._urnType=urnType;
}",0.7934782608695652
4585,"/** 
 * The idea is that this is smaller than any AlternateLocation who has a greater value of _count. There is one exception to this rule -- a demoted AlternateLocation has a higher value irrespective of count. <p>  This is because we want to have a sorted set of AlternateLocation where any demoted AlternateLocation is put  at the end of the list because it probably does not work.   <p>  Further we want to get AlternateLocations with smaller counts to be propogated more, since this will serve to get better load balancing of uploader. 
 */
public int compareTo(Object obj){
  if (this == obj)   return 0;
  if (obj == null)   return 1;
  if (!(obj instanceof AlternateLocation))   return 1;
  AlternateLocation other=(AlternateLocation)obj;
  if (_demoted != other._demoted) {
    if (_demoted)     return 1;
    return -1;
  }
  int ret=_count - other._count;
  if (ret != 0)   return ret;
  if (this.URL.equals(other.URL))   return 0;
  ret=this.URL.getHost().compareTo(other.URL.getHost());
  if (ret != 0)   return ret;
  return (this.URL.getPort() - other.URL.getPort());
}","/** 
 * The idea is that this is smaller than any AlternateLocation who has a greater value of _count. There is one exception to this rule -- a demoted AlternateLocation has a higher value irrespective of count. <p>  This is because we want to have a sorted set of AlternateLocation where any demoted AlternateLocation is put  at the end of the list because it probably does not work.   <p>  Further we want to get AlternateLocations with smaller counts to be propogated more, since this will serve to get better load balancing of uploader. 
 */
public int compareTo(Object obj){
  if (this == obj)   return 0;
  if (obj == null)   return 1;
  if (!(obj instanceof AlternateLocation))   return 1;
  AlternateLocation other=(AlternateLocation)obj;
  if (_demoted != other._demoted) {
    if (_demoted)     return 1;
    return -1;
  }
  int ret=_count - other._count;
  if (ret != 0)   return ret;
  ret=this.URL.getHost().compareTo(other.URL.getHost());
  if (ret != 0)   return ret;
  ret=(this.URL.getPort() - other.URL.getPort());
  if (ret != 0)   return ret;
  ret=SHA1_URN.hashCode() - other.SHA1_URN.hashCode();
  if (ret != 0)   return ret;
  return URL.getProtocol().hashCode() - other.URL.getProtocol().hashCode();
}",0.8406926406926407
4586,"/** 
 * Overrides the hashCode method of Object to meet the contract of  hashCode.  Since we override equals, it is necessary to also  override hashcode to ensure that two ""equal"" alternate locations return the same hashCode, less we unleash unknown havoc on the hash-based collections.
 * @return a hash code value for this object
 */
public int hashCode(){
  if (hashCode == 0)   hashCode=37 * this.URL.hashCode();
  return hashCode;
}","/** 
 * Overrides the hashCode method of Object to meet the contract of  hashCode.  Since we override equals, it is necessary to also  override hashcode to ensure that two ""equal"" alternate locations return the same hashCode, less we unleash unknown havoc on the hash-based collections.
 * @return a hash code value for this object
 */
public int hashCode(){
  if (hashCode == 0) {
    int result=17;
    result=(37 * result) + this.URL.getHost().hashCode();
    result=(37 * result) + this.URL.getPort();
    result=(37 * result) + this.SHA1_URN.hashCode();
    result=(37 * result) + this.URL.getProtocol().hashCode();
    hashCode=result;
  }
  return hashCode;
}",0.7452402538531279
4587,"/** 
 * Overrides the equals method to accurately compare  <tt>AlternateLocation</tt> instances.  <tt>AlternateLocation</tt>s  are equal if their <tt>URL</tt>s are equal.
 * @param obj the <tt>Object</tt> instance to compare to
 * @return <tt>true</tt> if the <tt>URL</tt> of this<tt>AlternateLocation</tt> is equal to the <tt>URL</tt> of the <tt>AlternateLocation</tt> location argument, and otherwise returns <tt>false</tt>
 */
public boolean equals(Object obj){
  if (obj == this)   return true;
  if (!(obj instanceof AlternateLocation))   return false;
  AlternateLocation al=(AlternateLocation)obj;
  return URL == null ? al.URL == null : URL.equals(al.URL);
}","/** 
 * Overrides the equals method to accurately compare  <tt>AlternateLocation</tt> instances.  <tt>AlternateLocation</tt>s  are equal if their <tt>URL</tt>s are equal.
 * @param obj the <tt>Object</tt> instance to compare to
 * @return <tt>true</tt> if the <tt>URL</tt> of this<tt>AlternateLocation</tt> is equal to the <tt>URL</tt> of the <tt>AlternateLocation</tt> location argument, and otherwise returns <tt>false</tt>
 */
public boolean equals(Object obj){
  if (obj == this)   return true;
  if (!(obj instanceof AlternateLocation))   return false;
  AlternateLocation other=(AlternateLocation)obj;
  return (URL.getHost().equals(other.URL.getHost()) && URL.getPort() == other.URL.getPort() && SHA1_URN.equals(other.SHA1_URN) && URL.getProtocol().equals(other.URL.getProtocol()));
}",0.8620452985586822
4588,"/** 
 * Creates a new <tt>URL</tt> instance based on the URL specified in the alternate location header.
 * @param locationHeader the alternate location header from an HTTPheader
 * @return a new <tt>URL</tt> instance for the URL in the alternatelocation header
 * @throws <tt>IOException</tt> if the url could not be extracted fromthe header in the expected format
 * @throws <tt>MalformedURLException</tt> if the enclosed URL is notformatted correctly
 */
private static URL createUrl(final String locationHeader) throws IOException {
  String test=locationHeader.toLowerCase();
  if (!test.startsWith(""String_Node_Str""))   throw new IOException(""String_Node_Str"" + locationHeader);
  if (test.lastIndexOf(""String_Node_Str"") > 4)   throw new IOException(""String_Node_Str"" + locationHeader);
  String urlStr=AlternateLocation.removeTimestamp(locationHeader);
  URL url=new URL(urlStr);
  String host=url.getHost();
  if (host == null || host.equals(""String_Node_Str""))   throw new IOException(""String_Node_Str"" + locationHeader);
  if (url.getPort() == -1)   url=new URL(""String_Node_Str"",url.getHost(),80,url.getFile());
  return url;
}","/** 
 * Creates a new <tt>URL</tt> instance based on the URL specified in the alternate location header.
 * @param locationHeader the alternate location header from an HTTPheader
 * @return a new <tt>URL</tt> instance for the URL in the alternatelocation header
 * @throws <tt>IOException</tt> if the url could not be extracted fromthe header in the expected format
 * @throws <tt>MalformedURLException</tt> if the enclosed URL is notformatted correctly
 */
private static URL createUrl(final String locationHeader) throws IOException {
  String locHeader=locationHeader.toLowerCase();
  if (!locHeader.startsWith(""String_Node_Str""))   throw new IOException(""String_Node_Str"" + locationHeader);
  if (locHeader.lastIndexOf(""String_Node_Str"") > 4)   throw new IOException(""String_Node_Str"" + locationHeader);
  String urlStr=AlternateLocation.removeTimestamp(locHeader);
  URL url=new URL(urlStr);
  String host=url.getHost();
  if (host == null || host.equals(""String_Node_Str""))   throw new IOException(""String_Node_Str"" + locationHeader);
  if (url.getPort() == -1)   url=new URL(""String_Node_Str"",url.getHost(),80,url.getFile());
  return url;
}",0.9807524059492564
4589,"/** 
 * Top level method of the thread. Calls three methods  a. Establish a TCP Connection. b. Assign this thread a part of the file, and do HTTP handshaking c. get the file. Each of these steps can run into errors, which have to be dealt with differently.
 * @return true if this worker thread should notify, false otherwise.currently this method returns false iff NSEEx is  thrown. 
 */
private boolean connectAndDownload(RemoteFileDesc rfd){
  HTTPDownloader dloader=null;
  dloader=establishConnection(rfd);
  if (dloader == null)   return true;
  if (validAlts != null) {
    Iterator iter=validAlts.iterator();
synchronized (validAlts) {
      int count=0;
      while (iter.hasNext() && count < 10) {
        dloader.addSuccessfulAltLoc((AlternateLocation)iter.next());
        count++;
      }
    }
  }
  boolean http11=true;
  while (http11) {
    int connected;
    http11=rfd.isHTTP11();
    while (true) {
      int[] a={-1,-1};
      connected=assignAndRequest(dloader,a,http11);
      boolean addQueued=killQueuedIfNecessary(connected,a[1]);
      if (connected == 4)       continue;
      if (connected != 1)       break;
      if (connected == 1 && !addQueued) {
        return true;
      }
      if (connected == 1) {
        Assert.that(a[0] > -1 && a[1] > -1,""String_Node_Str"");
        try {
          Thread.sleep(a[0]);
        }
 catch (        InterruptedException ix) {
          debug(""String_Node_Str"" + ""String_Node_Str"" + dloader);
          queuedThreads.remove(Thread.currentThread());
          dloader.stop();
          return true;
        }
      }
 else       Assert.that(false,""String_Node_Str"");
    }
synchronized (this) {
      queuedThreads.remove(Thread.currentThread());
    }
    Assert.that(connected == 0 || connected == 2 || connected == 3,""String_Node_Str"" + connected);
    if (connected == 0) {
      dloader.stop();
      return true;
    }
 else     if (connected == 3) {
      dloader.stop();
      return false;
    }
    boolean downloadOK=doDownload(dloader,http11);
    if (!downloadOK)     break;
  }
  return true;
}","/** 
 * Top level method of the thread. Calls three methods  a. Establish a TCP Connection. b. Assign this thread a part of the file, and do HTTP handshaking c. get the file. Each of these steps can run into errors, which have to be dealt with differently.
 * @return true if this worker thread should notify, false otherwise.currently this method returns false iff NSEEx is  thrown. 
 */
private boolean connectAndDownload(RemoteFileDesc rfd){
  HTTPDownloader dloader=null;
  dloader=establishConnection(rfd);
  if (dloader == null)   return true;
  if (validAlts != null) {
    Iterator iter=validAlts.iterator();
synchronized (validAlts) {
      int count=0;
      while (iter.hasNext() && count < 10) {
        dloader.addSuccessfulAltLoc((AlternateLocation)iter.next());
        count++;
      }
    }
  }
  boolean http11=true;
  while (http11) {
    int connected;
    http11=rfd.isHTTP11();
    while (true) {
      int[] qInfo={-1,-1};
      connected=assignAndRequest(dloader,qInfo,http11);
      boolean addQueued=killQueuedIfNecessary(connected,qInfo[1]);
      if (connected == 4)       continue;
      if (connected != 1)       break;
      if (connected == 1 && !addQueued) {
        return true;
      }
      if (connected == 1) {
        Assert.that(qInfo[0] > -1 && qInfo[1] > -1,""String_Node_Str"");
        try {
          Thread.sleep(qInfo[0]);
        }
 catch (        InterruptedException ix) {
          debug(""String_Node_Str"" + ""String_Node_Str"" + dloader);
          queuedThreads.remove(Thread.currentThread());
          dloader.stop();
          return true;
        }
      }
 else       Assert.that(false,""String_Node_Str"");
    }
synchronized (this) {
      queuedThreads.remove(Thread.currentThread());
    }
    Assert.that(connected == 0 || connected == 2 || connected == 3,""String_Node_Str"" + connected);
    if (connected == 0) {
      dloader.stop();
      return true;
    }
 else     if (connected == 3) {
      dloader.stop();
      return false;
    }
    boolean downloadOK=doDownload(dloader,http11);
    if (!downloadOK)     break;
  }
  return true;
}",0.9913834370512208
4590,"/** 
 * @param connectCode 0 means no connection, 1 means connection queued, 2means connection made, 3 means no connection required, 4 means partial range available
 * @param queuePos the position of this downloader in the remote queue, MUSTbe equal to -1 unless connectCode == 1  <P> Interrupts a remotely queued thread if the value of connectCode is 2 (meaning queuePos is -1) or connectCode is 1(meaning queuePos is the the remote position of this thread) AND a thread has a worse position than queuePos.  
 * @return true if this thread should be kept around, false otherwise --explicitly, there is no need to kill any threads, or if the currentThread is already in the queuedThreads, or if we did kill a thread worse than this thread.  
 */
private boolean killQueuedIfNecessary(int connectCode,int queuePos){
  Assert.that(connectCode >= 0 && connectCode <= 4,""String_Node_Str"");
  if (connectCode == 2)   Assert.that(queuePos == -1,""String_Node_Str"");
  if (queuePos > -1)   Assert.that(connectCode == 1,""String_Node_Str"");
  if (connectCode == 0)   return false;
  if (connectCode == 3)   return false;
  if (connectCode == 4)   return false;
  Thread killThread=null;
  Thread currentThread=Thread.currentThread();
synchronized (this) {
    if (getNumDownloaders() < getSwarmCapacity()) {
      if (connectCode == 1)       queuedThreads.put(currentThread,new Integer(queuePos));
      return true;
    }
    if (queuedThreads.containsKey(currentThread)) {
      if (connectCode == 1)       queuedThreads.put(currentThread,new Integer(queuePos));
      return true;
    }
    Iterator iter=queuedThreads.keySet().iterator();
    while (iter.hasNext()) {
      Object o=iter.next();
      int currQueue=((Integer)queuedThreads.get(o)).intValue();
      if (currQueue > queuePos)       killThread=(Thread)o;
    }
    if (killThread == null)     return false;
    killThread.interrupt();
    if (connectCode == 1)     queuedThreads.put(currentThread,new Integer(queuePos));
    return true;
  }
}","/** 
 * @param connectCode 0 means no connection, 1 means connection queued, 2means connection made, 3 means no connection required, 4 means partial range available
 * @param queuePos the position of this downloader in the remote queue, MUSTbe equal to -1 unless connectCode == 1  <P> Interrupts a remotely queued thread if the value of connectCode is 2 (meaning queuePos is -1) or connectCode is 1(meaning queuePos is the the remote position of this thread) AND a thread has a worse position than queuePos.  
 * @return true if this thread should be kept around, false otherwise --explicitly, there is no need to kill any threads, or if the currentThread is already in the queuedThreads, or if we did kill a thread worse than this thread.  
 */
private boolean killQueuedIfNecessary(int connectCode,int queuePos){
  Assert.that(connectCode >= 0 && connectCode <= 4,""String_Node_Str"");
  if (connectCode == 2)   Assert.that(queuePos == -1,""String_Node_Str"");
  if (queuePos > -1)   Assert.that(connectCode == 1,""String_Node_Str"");
  if (connectCode == 0)   return false;
  if (connectCode == 3)   return false;
  if (connectCode == 4)   return false;
  Thread killThread=null;
  Thread currentThread=Thread.currentThread();
synchronized (this) {
    if (getNumDownloaders() < getSwarmCapacity()) {
      if (connectCode == 1)       queuedThreads.put(currentThread,new Integer(queuePos));
      return true;
    }
    if (queuedThreads.containsKey(currentThread)) {
      if (connectCode == 1)       queuedThreads.put(currentThread,new Integer(queuePos));
      return true;
    }
    Iterator iter=queuedThreads.keySet().iterator();
    int highest=queuePos;
    while (iter.hasNext()) {
      Object o=iter.next();
      int currQueue=((Integer)queuedThreads.get(o)).intValue();
      if (currQueue > highest) {
        killThread=(Thread)o;
        highest=currQueue;
      }
    }
    if (killThread == null)     return false;
    killThread.interrupt();
    if (connectCode == 1)     queuedThreads.put(currentThread,new Integer(queuePos));
    return true;
  }
}",0.97984267453294
4591,"/** 
 * @param connectCode 0 means no connection, 1 means connection queued, 2means connection made, 3 means no connection required, 4 means partial range available
 * @param queuePos the position of this downloader in the remote queue, MUSTbe equal to -1 unless connectCode == 1  <P> Interrupts a remotely queued thread if the value of connectCode is 2 (meaning queuePos is -1) or connectCode is 1(meaning queuePos is the the remote position of this thread) AND a thread has a worse position than queuePos.  
 * @return true if there is no need to kill any threads, or if thecurrentThread is already in the queuedThreads, or if we did kill a thread worse than this thread. 
 */
private boolean killQueuedIfNecessary(int connectCode,int queuePos){
  Assert.that(connectCode >= 0 && connectCode <= 4,""String_Node_Str"");
  if (connectCode == 2)   Assert.that(queuePos == -1,""String_Node_Str"");
  if (queuePos > -1)   Assert.that(connectCode == 1,""String_Node_Str"");
  if (connectCode == 0)   return false;
  if (connectCode == 3)   return false;
  if (connectCode == 4)   return false;
  Thread killThread=null;
synchronized (this) {
    if (getNumDownloaders() < getSwarmCapacity())     return true;
    if (queuedThreads.containsKey(Thread.currentThread()))     return true;
    Iterator iter=queuedThreads.keySet().iterator();
    while (iter.hasNext()) {
      Object o=iter.next();
      int currQueue=((Integer)queuedThreads.get(o)).intValue();
      if (currQueue > queuePos)       killThread=(Thread)o;
    }
    if (killThread == null)     return false;
    killThread.interrupt();
    if (connectCode == 1)     queuedThreads.put(Thread.currentThread(),new Integer(queuePos));
    return true;
  }
}","/** 
 * @param connectCode 0 means no connection, 1 means connection queued, 2means connection made, 3 means no connection required, 4 means partial range available
 * @param queuePos the position of this downloader in the remote queue, MUSTbe equal to -1 unless connectCode == 1  <P> Interrupts a remotely queued thread if the value of connectCode is 2 (meaning queuePos is -1) or connectCode is 1(meaning queuePos is the the remote position of this thread) AND a thread has a worse position than queuePos.  
 * @return true if this thread should be kept around, false otherwise --explicitly, there is no need to kill any threads, or if the currentThread is already in the queuedThreads, or if we did kill a thread worse than this thread.  
 */
private boolean killQueuedIfNecessary(int connectCode,int queuePos){
  Assert.that(connectCode >= 0 && connectCode <= 4,""String_Node_Str"");
  if (connectCode == 2)   Assert.that(queuePos == -1,""String_Node_Str"");
  if (queuePos > -1)   Assert.that(connectCode == 1,""String_Node_Str"");
  if (connectCode == 0)   return false;
  if (connectCode == 3)   return false;
  if (connectCode == 4)   return false;
  Thread killThread=null;
  Thread currentThread=Thread.currentThread();
synchronized (this) {
    if (getNumDownloaders() < getSwarmCapacity()) {
      if (connectCode == 1)       queuedThreads.put(currentThread,new Integer(queuePos));
      return true;
    }
    if (queuedThreads.containsKey(currentThread)) {
      if (connectCode == 1)       queuedThreads.put(currentThread,new Integer(queuePos));
      return true;
    }
    Iterator iter=queuedThreads.keySet().iterator();
    while (iter.hasNext()) {
      Object o=iter.next();
      int currQueue=((Integer)queuedThreads.get(o)).intValue();
      if (currQueue > queuePos)       killThread=(Thread)o;
    }
    if (killThread == null)     return false;
    killThread.interrupt();
    if (connectCode == 1)     queuedThreads.put(currentThread,new Integer(queuePos));
    return true;
  }
}",0.8376483279395901
4592,"/** 
 * Returns true if this incoming connections should be rejected with a 503. 
 */
private boolean reject(HandshakeResponse response){
  boolean allowedNow=_manager.allowConnection(response);
  if (allowedNow)   return false;
  boolean allowedAsLeaf=_manager.allowConnectionAsLeaf(response);
  return !(response.isUltrapeer() && allowedAsLeaf);
}","/** 
 * Returns true if this incoming connections should be rejected with a 503. 
 */
private boolean reject(HandshakeResponse response){
  boolean allowedNow=_manager.allowConnection(response);
  if (allowedNow)   return false;
  if (!response.isUltrapeer())   return true;
  return !_manager.allowConnectionAsLeaf(response);
}",0.8094534711964549
4593,"/** 
 * Respond to an outgoing connection request.
 * @param response the headers read from the connection
 */
private HandshakeResponse respondToOutgoing(HandshakeResponse response){
  if (!_manager.allowConnection(response)) {
    return HandshakeResponse.createRejectOutgoingResponse();
  }
  Properties ret=new Properties();
  if (response.hasLeafGuidance() && isNotBearshare(response) && _manager.allowLeafDemotion()) {
    ret.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
  }
  if (response.isDeflateAccepted()) {
    ret.put(HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  }
  return HandshakeResponse.createAcceptOutgoingResponse(ret);
}","/** 
 * Respond to an outgoing connection request.
 * @param response the headers read from the connection
 */
private HandshakeResponse respondToOutgoing(HandshakeResponse response){
  if (!response.isUltrapeer())   return HandshakeResponse.createRejectOutgoingResponse();
  if (!_manager.allowConnection(response)) {
    return HandshakeResponse.createRejectOutgoingResponse();
  }
  Properties ret=new Properties();
  if (response.hasLeafGuidance() && isNotBearshare(response) && _manager.allowLeafDemotion()) {
    ret.put(HeaderNames.X_ULTRAPEER,""String_Node_Str"");
  }
  if (response.isDeflateAccepted()) {
    ret.put(HeaderNames.CONTENT_ENCODING,HeaderNames.DEFLATE_VALUE);
  }
  return HandshakeResponse.createAcceptOutgoingResponse(ret);
}",0.9360795454545454
4594,"/** 
 * Returns the number of connections we should try depending on our speed, and how many downloaders we have active now.
 */
private synchronized int getNumAllowedDownloads(){
  int downloads=threads.size();
  int capacity=ConnectionSettings.CONNECTION_SPEED.getValue();
  if (capacity <= SpeedConstants.MODEM_SPEED_INT)   return Math.max(2 - downloads,0);
 else   if (capacity <= SpeedConstants.T1_SPEED_INT)   return Math.max(6 - downloads,0);
 else   return Math.max(8 - downloads,0);
}","/** 
 * Returns the number of connections we should try depending on our speed, and how many downloaders we have active now.
 */
private synchronized int getNumAllowedDownloads(){
  int downloads=threads.size();
  return Math.max(getSwarmCapacity() - downloads,0);
}",0.613965744400527
4595,"public void open(File file,ManagedDownloader md) throws IOException {
  this.managedDownloader=md;
  File parentFile=FileUtils.getParentFile(file);
  FileUtils.setWriteable(parentFile);
  FileUtils.setWriteable(file);
  this.fos=new RandomAccessFile(file,""String_Node_Str"");
}","public void open(File file,ManagedDownloader md) throws IOException {
  this.managedDownloader=md;
  File parentFile=FileUtils.getParentFile(file);
  if (parentFile != null)   FileUtils.setWriteable(parentFile);
  FileUtils.setWriteable(file);
  this.fos=new RandomAccessFile(file,""String_Node_Str"");
}",0.9550173010380624
4596,"/** 
 * An MPEG audio file is built up from smaller parts called frames, which are generally independent items. Each frame has its own header and audio data that follows. There is NO MPEG file header; therefore, you can cut any part of MPEG file and play it correctly (cut on frame boundaries!), excluding MPEG 1 Layer III frames which are often dependent on another. To read info about an MPEG file, you can find the first frame, read its header and assume that the other frames are the same. Exceptions to this are VBR (variable bit rate) and ABR (average bit rate) files. The frame header is constituted by the very first four bytes (32bits) in a frame. The first 11 bits are always set on(1) and they're called ""frame sync"". Frame CRC is optional and 16 bits long; it follows the frame header. After the CRC comes the audio data. ::EXAMPLE:: MP3 file header format (4 byte length or 32 bits) byte[4] = { -1, -5, 80, 108 }  -1 << 24  +  -5 << 16  +  80 << 08  +  108 << 0    {HdrCRC} 11111111     11101010     00110000     11000000     {0000} AAAAAAAA     AAABBCCD     EEEEFFGH     IIJJKLMM     {ZZZZ} Label, Position(bits), Description	  A (31-21) Frame sync  All bits set (1) B (20,19) MPEG Audio version ID 00 - MPEG Ver 2.5, 01 - reserved, 10 - Ver 2, 11 - Ver 1 Note: MPEG Ver 2.5 is not official; bit # 20 indicates 2.5 C (18,17) Layer description 00 - reserved, 01 - Layer III, 10 - Layer II, 11 - Layer I D    (16) Protection bit 0 - None, 1 - Protected by CRC (16bit crc follows header) E (15,12) Bitrate index, version and layer bits V1,L1 V1,L2 V1,L3 V2,L1 V2, L2 & L3 F (11,10)  G     (9) Padding bit    0 - frame not padded, 1 - frame padded with one extra slot Note: Padding is used to fit the bit rates exactly. H     (8) Private bit  0 - not private, 1 - private Note: May be freely used for other needs of an application. I   (7,6) Channel Mode 00 - Stereo, 01 - Joint stereo, 10 - Dual (Stereo), 11 - Mono J   (5,4) Mode extension (Only if Joint stereo) Used to join data; bits dynamically generated by an encoder. K     (3) Copyright 0 - Audio is not copyrighted, 1 - Audio is marked copyrighted L     (2) Original 0 - Copy of original media, 1 - Original media  M   (1,0) Emphasis 00 - none, 01 - 50/15 ms, 10 - reserved, 11 - CCIT J.17 Z (32-35) CRC  !!OPTIONAL!! Note: NOT part of header, just appended on end when needed We read in bytes from the beginning of the mp3 file looking for the 4 byte header; we can't assume it starts at byte 0 because ID3 tags may be prepended before the first valid header. The loop below strolls through buffered chunks of the file looking for the header. As an optimization, we check the first 10 bytes initially as it may contain the header; if it doesn't we then check the first 10 bytes for an ID3v2 header and fetch the tag's length, skipping those bytes leading us directly to the header. If neither are found, it's a brute force search. With each chunk, we step forward one byte at a time, and test the current byte plus the next 3 bytes for a valid mp3 header.
 * @exception java.io.IOException mp3 fileName had no valid header
 */
public MP3Info(String file) throws IOException {
  _file=file;
  int i=0;
  int pos=0;
  int adjustedEOB=0;
  int c=0;
  FileInputStream fis=null;
  byte[] buf=new byte[2048];
  try {
    fis=new FileInputStream(_file);
    c=fis.read(buf,0,buf.length);
    if (c < -1)     throw new IOException(""String_Node_Str"");
    if ((buf[0] == 'i' || buf[0] == 'I') && (buf[1] == 'd' || buf[1] == 'D') && (buf[2] == '3')) {
      i=buf[6] << 7 | buf[7] << 7 | buf[8] << 7 | buf[9];
      if (i > 0) {
        i+=10;
      }
 else       if (i < 0) {
        i=0;
      }
    }
    endheadersearch:     do {
      if (pos < buf.length - 3) {
        adjustedEOB=c - 3;
      }
 else {
        i=0;
        adjustedEOB=c;
      }
      for (; i < adjustedEOB; i++) {
        if (buf[i] != -1 || (buf[i + 1] & 255) < 224) {
          continue;
        }
        _header=(ByteOrder.ubyte2int(buf[i + 3])) | (ByteOrder.ubyte2int(buf[i + 2]) << 8) | (ByteOrder.ubyte2int(buf[i + 1]) << 16)| (ByteOrder.ubyte2int(buf[i]) << 24);
        if ((getVersionIndex() != 1) && (getLayerIndex() != 0) && (getBitrateIndex() != 0)&& (getBitrateIndex() != 15)&& (getFrequencyIndex() != 3)&& (getEmphasisIndex() != 2)) {
          pos+=i;
          break endheadersearch;
        }
      }
      if (adjustedEOB != -1) {
        buf[0]=buf[c - 3];
        buf[1]=buf[c - 2];
        buf[2]=buf[c - 1];
      }
      pos+=c - 3;
      c=fis.read(buf,3,buf.length - 3);
      if (c < 6)       throw new IOException(""String_Node_Str"");
    }
 while (c != -1 && pos < 100000);
    if (c == -1 || pos >= 100000) {
      _header=0;
      throw new IOException(""String_Node_Str"");
    }
    int need=buf.length - i - 3- 120- 36;
    if (need < 0) {
      need=-need;
      i-=need;
      int j=0;
      for (; need < buf.length; j++, need++) {
        buf[j]=buf[need];
      }
      c=fis.read(buf,j,buf.length - j);
    }
    if (getVersionIndex() == 3) {
      i+=(getModeIndex() == 3 ? 21 : 36);
    }
 else {
      i+=(getModeIndex() == 3 ? 23 : 21);
    }
switch (buf[i + 0]) {
case 88:
      if (((buf[i + 1] == 'i' || buf[i + 1] == 'I') && (buf[i + 2] == 'n' || buf[i + 2] == 'N') && (buf[i + 3] == 'g' || buf[i + 3] == 'G')))       loadXingHeader(buf,i + 4);
    break;
case 86:
  if ((buf[i + 1] == 'B' && buf[i + 2] == 'R' && buf[i + 3] == 'I'))   loadFhgHeader(buf,i + 4);
break;
}
}
  finally {
try {
if (fis != null) fis.close();
}
 catch (IOException e) {
}
}
}","/** 
 * An MPEG audio file is built up from smaller parts called frames, which are generally independent items. Each frame has its own header and audio data that follows. There is NO MPEG file header; therefore, you can cut any part of MPEG file and play it correctly (cut on frame boundaries!), excluding MPEG 1 Layer III frames which are often dependent on another. To read info about an MPEG file, you can find the first frame, read its header and assume that the other frames are the same. Exceptions to this are VBR (variable bit rate) and ABR (average bit rate) files. The frame header is constituted by the very first four bytes (32bits) in a frame. The first 11 bits are always set on(1) and they're called ""frame sync"". Frame CRC is optional and 16 bits long; it follows the frame header. After the CRC comes the audio data. ::EXAMPLE:: MP3 file header format (4 byte length or 32 bits) byte[4] = { -1, -5, 80, 108 }  -1 << 24  +  -5 << 16  +  80 << 08  +  108 << 0    {HdrCRC} 11111111     11101010     00110000     11000000     {0000} AAAAAAAA     AAABBCCD     EEEEFFGH     IIJJKLMM     {ZZZZ} Label, Position(bits), Description	  A (31-21) Frame sync  All bits set (1) B (20,19) MPEG Audio version ID 00 - MPEG Ver 2.5, 01 - reserved, 10 - Ver 2, 11 - Ver 1 Note: MPEG Ver 2.5 is not official; bit # 20 indicates 2.5 C (18,17) Layer description 00 - reserved, 01 - Layer III, 10 - Layer II, 11 - Layer I D    (16) Protection bit 0 - None, 1 - Protected by CRC (16bit crc follows header) E (15,12) Bitrate index, version and layer bits V1,L1 V1,L2 V1,L3 V2,L1 V2, L2 & L3 F (11,10)  G     (9) Padding bit    0 - frame not padded, 1 - frame padded with one extra slot Note: Padding is used to fit the bit rates exactly. H     (8) Private bit  0 - not private, 1 - private Note: May be freely used for other needs of an application. I   (7,6) Channel Mode 00 - Stereo, 01 - Joint stereo, 10 - Dual (Stereo), 11 - Mono J   (5,4) Mode extension (Only if Joint stereo) Used to join data; bits dynamically generated by an encoder. K     (3) Copyright 0 - Audio is not copyrighted, 1 - Audio is marked copyrighted L     (2) Original 0 - Copy of original media, 1 - Original media  M   (1,0) Emphasis 00 - none, 01 - 50/15 ms, 10 - reserved, 11 - CCIT J.17 Z (32-35) CRC  !!OPTIONAL!! Note: NOT part of header, just appended on end when needed We read in bytes from the beginning of the mp3 file looking for the 4 byte header; we can't assume it starts at byte 0 because ID3 tags may be prepended before the first valid header. The loop below strolls through buffered chunks of the file looking for the header. As an optimization, we check the first 10 bytes initially as it may contain the header; if it doesn't we then check the first 10 bytes for an ID3v2 header and fetch the tag's length, skipping those bytes leading us directly to the header. If neither are found, it's a brute force search. With each chunk, we step forward one byte at a time, and test the current byte plus the next 3 bytes for a valid mp3 header.
 * @exception java.io.IOException mp3 fileName had no valid header
 */
public MP3Info(String file) throws IOException {
  _file=file;
  int i=0;
  int pos=0;
  int adjustedEOB=0;
  int c=0;
  FileInputStream fis=null;
  byte[] buf=new byte[2048];
  try {
    fis=new FileInputStream(_file);
    c=fis.read(buf,0,buf.length);
    if (c < 4)     throw new IOException(""String_Node_Str"");
    if ((buf[0] == 'i' || buf[0] == 'I') && (buf[1] == 'd' || buf[1] == 'D') && (buf[2] == '3')) {
      i=buf[6] << 7 | buf[7] << 7 | buf[8] << 7 | buf[9];
      if (i > 0) {
        i+=10;
      }
 else       if (i < 0) {
        i=0;
      }
    }
    endheadersearch:     do {
      if (pos < buf.length - 3) {
        adjustedEOB=c - 3;
      }
 else {
        i=0;
        adjustedEOB=c;
      }
      for (; i < adjustedEOB; i++) {
        if (buf[i] != -1 || (buf[i + 1] & 255) < 224) {
          continue;
        }
        _header=(ByteOrder.ubyte2int(buf[i + 3])) | (ByteOrder.ubyte2int(buf[i + 2]) << 8) | (ByteOrder.ubyte2int(buf[i + 1]) << 16)| (ByteOrder.ubyte2int(buf[i]) << 24);
        if ((getVersionIndex() != 1) && (getLayerIndex() != 0) && (getBitrateIndex() != 0)&& (getBitrateIndex() != 15)&& (getFrequencyIndex() != 3)&& (getEmphasisIndex() != 2)) {
          pos+=i;
          break endheadersearch;
        }
      }
      if (adjustedEOB != -1) {
        buf[0]=buf[c - 3];
        buf[1]=buf[c - 2];
        buf[2]=buf[c - 1];
      }
      pos+=c - 3;
      c=fis.read(buf,3,buf.length - 3);
      if (c < 6)       throw new IOException(""String_Node_Str"");
    }
 while (c != -1 && pos < 100000);
    if (c == -1 || pos >= 100000) {
      _header=0;
      throw new IOException(""String_Node_Str"");
    }
    int need=buf.length - i - 3- 120- 36;
    if (need < 0) {
      need=-need;
      i-=need;
      int j=0;
      for (; need < buf.length; j++, need++) {
        buf[j]=buf[need];
      }
      c=fis.read(buf,j,buf.length - j);
    }
    if (getVersionIndex() == 3) {
      i+=(getModeIndex() == 3 ? 21 : 36);
    }
 else {
      i+=(getModeIndex() == 3 ? 23 : 21);
    }
switch (buf[i + 0]) {
case 88:
      if (((buf[i + 1] == 'i' || buf[i + 1] == 'I') && (buf[i + 2] == 'n' || buf[i + 2] == 'N') && (buf[i + 3] == 'g' || buf[i + 3] == 'G')))       loadXingHeader(buf,i + 4);
    break;
case 86:
  if ((buf[i + 1] == 'B' && buf[i + 2] == 'R' && buf[i + 3] == 'I'))   loadFhgHeader(buf,i + 4);
break;
}
}
  finally {
try {
if (fis != null) fis.close();
}
 catch (IOException e) {
}
}
}",0.999729070712544
4597,"/** 
 * Utility method to set a file as non read only. If the file is already writable, does nothing.
 * @param f the <tt>File</tt> instance whose read only flag shouldbe unset.
 */
public static boolean setWriteable(File f){
  if (f.canWrite())   return true;
  String fName;
  try {
    fName=f.getCanonicalPath();
  }
 catch (  IOException ioe) {
    fName=f.getPath();
  }
  String cmds[]=null;
  if (CommonUtils.isWindows())   cmds=new String[]{""String_Node_Str"",""String_Node_Str"",fName};
 else   if (CommonUtils.isMacClassic())   cmds=null;
 else   cmds=new String[]{""String_Node_Str"",""String_Node_Str"",fName};
  if (cmds != null) {
    try {
      Process p=Runtime.getRuntime().exec(cmds);
      p.waitFor();
    }
 catch (    SecurityException ignored) {
    }
catch (    IOException ignored) {
    }
catch (    InterruptedException ignored) {
    }
  }
  return f.canWrite();
}","/** 
 * Utility method to set a file as non read only. If the file is already writable, does nothing.
 * @param f the <tt>File</tt> instance whose read only flag shouldbe unset.
 */
public static boolean setWriteable(File f){
  if (f.canWrite() || !f.exists())   return true;
  String fName;
  try {
    fName=f.getCanonicalPath();
  }
 catch (  IOException ioe) {
    fName=f.getPath();
  }
  if (UNWRITEABLE.contains(fName))   return false;
  String cmds[]=null;
  if (CommonUtils.isWindows())   cmds=new String[]{""String_Node_Str"",""String_Node_Str"",fName};
 else   if (CommonUtils.isMacClassic())   cmds=null;
 else   cmds=new String[]{""String_Node_Str"",""String_Node_Str"",fName};
  if (cmds != null) {
    try {
      Process p=Runtime.getRuntime().exec(cmds);
      p.waitFor();
    }
 catch (    SecurityException ignored) {
    }
catch (    IOException ignored) {
    }
catch (    InterruptedException ignored) {
    }
  }
  if (!f.canWrite()) {
    UNWRITEABLE.add(fName);
    return false;
  }
 else   return true;
}",0.9188906331763474
4598,"/** 
 * Returns a new socket to the given host/port.  If the socket couldn't be established withing timeout milliseconds, throws IOException.  If timeout==0, no timeout occurs.  If this thread is interrupted while making connection, throws IOException.
 * @requires connect has only been called once, no other thread callingconnect.  Timeout must be non-negative.  
 */
public synchronized Socket connect(int timeout) throws IOException {
  Thread t=new Thread(new SocketOpenerThread(),""String_Node_Str"");
  t.setDaemon(true);
  t.start();
  try {
    this.wait(timeout);
  }
 catch (  InterruptedException e) {
    if (socket == null)     timedOut=true;
 else     try {
      socket.close();
    }
 catch (    IOException e2) {
    }
    throw new IOException();
  }
  if (!completed)   t.stop();
  if (socket != null) {
    return socket;
  }
 else {
    timedOut=true;
    throw new IOException();
  }
}","/** 
 * Returns a new socket to the given host/port.  If the socket couldn't be established withing timeout milliseconds, throws IOException.  If timeout==0, no timeout occurs.  If this thread is interrupted while making connection, throws IOException.
 * @requires connect has only been called once, no other thread callingconnect.  Timeout must be non-negative.  
 */
public synchronized Socket connect(int timeout) throws IOException {
  Thread t=new Thread(new SocketOpenerThread(),""String_Node_Str"");
  t.setDaemon(true);
  t.start();
  try {
    this.wait(timeout);
  }
 catch (  InterruptedException e) {
    if (socket == null)     timedOut=true;
 else     try {
      socket.close();
    }
 catch (    IOException e2) {
    }
    throw new IOException();
  }
  if (!completed)   t.interrupt();
  if (socket != null) {
    return socket;
  }
 else {
    timedOut=true;
    throw new IOException();
  }
}",0.9928453494771602
4599,"/** 
 * Reads a message from the network and updates the appropriate statistics.
 */
private Message readAndUpdateStatistics() throws IOException, BadPacketException {
  int pCompressed=0, pUncompressed=0;
  Message msg=null;
  try {
    if (isReadDeflated()) {
      pCompressed=_inflater.getTotalIn();
      pUncompressed=_inflater.getTotalOut();
    }
    try {
      msg=Message.read(_in,HEADER_BUF,Message.N_TCP,_softMax);
    }
 catch (    IOException ioe) {
      close();
      throw ioe;
    }
    if (isReadDeflated()) {
      _compressedBytesReceived=_inflater.getTotalIn();
      _bytesReceived=_inflater.getTotalOut();
      if (!CommonUtils.isJava118()) {
        CompressionStat.GNUTELLA_UNCOMPRESSED_DOWNSTREAM.addData((int)(_inflater.getTotalOut() - pUncompressed));
        CompressionStat.GNUTELLA_COMPRESSED_DOWNSTREAM.addData((int)(_inflater.getTotalIn() - pCompressed));
      }
    }
 else     if (msg != null) {
      _bytesReceived+=msg.getTotalLength();
    }
  }
 catch (  NullPointerException npe) {
    throw CONNECTION_CLOSED;
  }
  return msg;
}","/** 
 * Reads a message from the network and updates the appropriate statistics.
 */
private Message readAndUpdateStatistics() throws IOException, BadPacketException {
  int pCompressed=0, pUncompressed=0;
  Message msg=null;
  try {
    if (isReadDeflated()) {
      pCompressed=_inflater.getTotalIn();
      pUncompressed=_inflater.getTotalOut();
    }
    msg=Message.read(_in,HEADER_BUF,Message.N_TCP,_softMax);
    if (isReadDeflated()) {
      _compressedBytesReceived=_inflater.getTotalIn();
      _bytesReceived=_inflater.getTotalOut();
      if (!CommonUtils.isJava118()) {
        CompressionStat.GNUTELLA_UNCOMPRESSED_DOWNSTREAM.addData((int)(_inflater.getTotalOut() - pUncompressed));
        CompressionStat.GNUTELLA_COMPRESSED_DOWNSTREAM.addData((int)(_inflater.getTotalIn() - pCompressed));
      }
    }
 else     if (msg != null) {
      _bytesReceived+=msg.getTotalLength();
    }
  }
 catch (  NullPointerException npe) {
    throw CONNECTION_CLOSED;
  }
  return msg;
}",0.9578692493946732
4600,"/** 
 * Sends a message.  The message may be buffered, so call flush() to guarantee that the message is sent synchronously.  This method is NOT thread-safe. Behavior is undefined if two threads are in a send call at the same time for a given connection.
 * @requires this is fully initialized
 * @modifies the network underlying this
 * @effects send m on the network.  Throws IOException if problemsarise.
 */
public void send(Message m) throws IOException {
  long priorCompressed=0, priorUncompressed=0;
  try {
    if (isWriteDeflated()) {
      priorUncompressed=_deflater.getTotalIn();
      priorCompressed=_deflater.getTotalOut();
    }
    try {
      m.write(_out);
    }
 catch (    IOException ioe) {
      close();
      throw ioe;
    }
    updateWriteStatistics(m,priorUncompressed,priorCompressed);
  }
 catch (  NullPointerException e) {
    throw CONNECTION_CLOSED;
  }
}","/** 
 * Sends a message.  The message may be buffered, so call flush() to guarantee that the message is sent synchronously.  This method is NOT thread-safe. Behavior is undefined if two threads are in a send call at the same time for a given connection.
 * @requires this is fully initialized
 * @modifies the network underlying this
 * @effects send m on the network.  Throws IOException if problemsarise.
 */
public void send(Message m) throws IOException {
  long priorCompressed=0, priorUncompressed=0;
  try {
    if (isWriteDeflated()) {
      priorUncompressed=_deflater.getTotalIn();
      priorCompressed=_deflater.getTotalOut();
    }
    m.write(_out);
    updateWriteStatistics(m,priorUncompressed,priorCompressed);
  }
 catch (  NullPointerException e) {
    throw CONNECTION_CLOSED;
  }
}",0.9485511531638084
4601,"/** 
 * Flushes any buffered messages sent through the send method.
 */
public void flush() throws IOException {
  long priorCompressed=0, priorUncompressed=0;
  try {
    if (isWriteDeflated()) {
      priorUncompressed=_deflater.getTotalIn();
      priorCompressed=_deflater.getTotalOut();
    }
    try {
      _out.flush();
    }
 catch (    IOException ioe) {
      close();
      throw ioe;
    }
    updateWriteStatistics(null,priorUncompressed,priorCompressed);
  }
 catch (  NullPointerException npe) {
    throw CONNECTION_CLOSED;
  }
}","/** 
 * Flushes any buffered messages sent through the send method.
 */
public void flush() throws IOException {
  long priorCompressed=0, priorUncompressed=0;
  try {
    if (isWriteDeflated()) {
      priorUncompressed=_deflater.getTotalIn();
      priorCompressed=_deflater.getTotalOut();
    }
    _out.flush();
    updateWriteStatistics(null,priorUncompressed,priorCompressed);
  }
 catch (  NullPointerException npe) {
    throw CONNECTION_CLOSED;
  }
}",0.9134328358208956
4602,"/** 
 * Closes the Connection's socket and thus the connection itself.
 */
public void close(){
  _closed=true;
  if (_socket != null) {
    try {
      _socket.close();
    }
 catch (    IOException e) {
    }
  }
  if (_deflater != null)   _deflater.end();
  if (_inflater != null)   _inflater.end();
  if (_in != null) {
    try {
      _in.close();
    }
 catch (    IOException e) {
    }
  }
  if (_out != null) {
    try {
      _out.close();
    }
 catch (    IOException e) {
    }
  }
}","/** 
 * Closes the Connection's socket and thus the connection itself.
 */
public void close(){
  if (_closed)   return;
  _closed=true;
  if (_socket != null) {
    try {
      _socket.close();
    }
 catch (    IOException e) {
    }
  }
  if (_deflater != null)   _deflater.end();
  if (_inflater != null)   _inflater.end();
  if (_in != null) {
    try {
      _in.close();
    }
 catch (    IOException e) {
    }
  }
  if (_out != null) {
    try {
      _out.close();
    }
 catch (    IOException e) {
    }
  }
}",0.975417895771878
4603,"/** 
 * Runs standard calls that should be made whenever a connection is fully established and should wait for messages.
 * @param conn the <tt>ManagedConnection</tt> instance to start
 * @throws <tt>IOException</tt> if there is an excpetion while loopingfor messages
 */
private void startConnection(ManagedConnection conn) throws IOException {
  Thread.currentThread().setName(""String_Node_Str"");
  try {
    if (conn.isGUESSUltrapeer()) {
      QueryUnicaster.instance().addUnicastEndpoint(conn.getInetAddress(),conn.getListeningPort());
    }
    conn.loopForMessages();
  }
  finally {
    remove(conn);
  }
}","/** 
 * Runs standard calls that should be made whenever a connection is fully established and should wait for messages.
 * @param conn the <tt>ManagedConnection</tt> instance to start
 * @throws <tt>IOException</tt> if there is an excpetion while loopingfor messages
 */
private void startConnection(ManagedConnection conn) throws IOException {
  Thread.currentThread().setName(""String_Node_Str"");
  if (conn.isGUESSUltrapeer()) {
    QueryUnicaster.instance().addUnicastEndpoint(conn.getInetAddress(),conn.getListeningPort());
  }
  conn.loopForMessages();
}",0.9540034071550256
4604,"/** 
 * While the connection is not closed, sends all data delay. 
 */
public void run(){
  try {
    while (true) {
      repOk();
      waitForQueued();
      sendQueued();
      repOk();
    }
  }
 catch (  IOException e) {
    _runnerDied=true;
  }
catch (  Throwable t) {
    _runnerDied=true;
    ErrorService.error(t);
  }
}","/** 
 * While the connection is not closed, sends all data delay. 
 */
public void run(){
  try {
    while (true) {
      repOk();
      waitForQueued();
      sendQueued();
      repOk();
    }
  }
 catch (  IOException e) {
    if (_manager != null)     _manager.remove(ManagedConnection.this);
    _runnerDied=true;
  }
catch (  Throwable t) {
    if (_manager != null)     _manager.remove(ManagedConnection.this);
    _runnerDied=true;
    ErrorService.error(t);
  }
}",0.8233830845771144
4605,"/** 
 * Override of receive to do MessageRouter stats and to properly shut down the connection on IOException
 */
public Message receive(int timeout) throws IOException, BadPacketException, InterruptedIOException {
  Message m=super.receive(timeout);
  addReceived();
  return m;
}","/** 
 * Override of receive to do MessageRouter stats and to properly shut down the connection on IOException
 */
public Message receive(int timeout) throws IOException, BadPacketException, InterruptedIOException {
  Message m=null;
  try {
    m=super.receive(timeout);
  }
 catch (  IOException e) {
    if (_manager != null)     _manager.remove(this);
    throw e;
  }
  addReceived();
  return m;
}",0.8228404099560761
4606,"public String toString(){
  return (""String_Node_Str"" + getHost() + ""String_Node_Str""+ getPort()+ ""String_Node_Str""+ getFileName()+ ""String_Node_Str""+ getSize()+ ""String_Node_Str""+ getSpeed()+ ""String_Node_Str""+ getSHA1Urn()+ ""String_Node_Str""+ getQuality()+ ""String_Node_Str""+ _replyToMulticast+ ""String_Node_Str"");
}","public String toString(){
  return (""String_Node_Str"" + getHost() + ""String_Node_Str""+ getPort()+ ""String_Node_Str""+ getFileName()+ ""String_Node_Str"");
}",0.6496815286624203
4607,"/** 
 * Returns true if 'other' should be accepted as a new download location.
 */
protected boolean allowAddition(RemoteFileDesc other){
  if (!initDone) {
synchronized (matcher) {
      matcher.setIgnoreCase(true);
      matcher.setIgnoreWhitespace(true);
      matcher.setCompareBackwards(true);
    }
    initDone=true;
  }
  if (other.getQuality() < 1)   return false;
  final URN otherUrn=other.getSHA1Urn();
  final String otherName=other.getFileName();
  final long otherLength=other.getSize();
synchronized (this) {
    for (int i=0; i < allFiles.length; i++) {
      RemoteFileDesc rfd=(RemoteFileDesc)allFiles[i];
      final URN urn=rfd.getSHA1Urn();
      if (otherUrn != null && urn != null) {
        return otherUrn.equals(urn);
      }
      final String thisName=rfd.getFileName();
      final long thisLength=rfd.getSize();
      if (sizeClose(otherLength,thisLength))       if (namesClose(otherName,thisName))       return true;
    }
  }
  return false;
}","/** 
 * Returns true if 'other' should be accepted as a new download location.
 */
protected boolean allowAddition(RemoteFileDesc other){
  if (!initDone) {
synchronized (matcher) {
      matcher.setIgnoreCase(true);
      matcher.setIgnoreWhitespace(true);
      matcher.setCompareBackwards(true);
    }
    initDone=true;
  }
  if (other.getQuality() < 1)   return false;
  if (other.isFromAlternateLocation() && invalidAlts.containsKey(other))   return false;
  final URN otherUrn=other.getSHA1Urn();
  final String otherName=other.getFileName();
  final long otherLength=other.getSize();
synchronized (this) {
    for (int i=0; i < allFiles.length; i++) {
      RemoteFileDesc rfd=(RemoteFileDesc)allFiles[i];
      final URN urn=rfd.getSHA1Urn();
      if (otherUrn != null && urn != null) {
        return otherUrn.equals(urn);
      }
      final String thisName=rfd.getFileName();
      final long thisLength=rfd.getSize();
      if (sizeClose(otherLength,thisLength))       if (namesClose(otherName,thisName))       return true;
    }
  }
  return false;
}",0.9563939245467908
4608,"private synchronized void informMesh(RemoteFileDesc rfd,boolean good){
  if (!rfd.isAltLocCapable())   return;
  AlternateLocation loc=null;
  try {
    loc=AlternateLocation.create(rfd);
  }
 catch (  IOException iox) {
    return;
  }
  for (Iterator iter=dloaders.iterator(); iter.hasNext(); ) {
    HTTPDownloader httpDloader=(HTTPDownloader)iter.next();
    RemoteFileDesc r=httpDloader.getRemoteFileDesc();
    if (r.getHost() == rfd.getHost() && r.getPort() == rfd.getPort())     continue;
    if (good)     httpDloader.addSuccessfulAltLoc(loc);
 else     httpDloader.addFailedAltLoc(loc);
  }
  if (!good)   validAlts.remove(loc);
  if (RECORD_STATS && (""String_Node_Str"".equals(rfd.getVendor()))) {
    if (good)     DownloadStat.ALTERNATE_WORKED.incrementStat();
 else     DownloadStat.ALTERNATE_NOT_ADDED.incrementStat();
  }
}","/** 
 * Notifies all existing HTTPDownloaders about this RFD. If good is true, it notifies them of a succesful alternate location, otherwise it notifies them of a failed alternate location. The internal validAlts is also updated if good is true, and invalidAlts is updated if good is false. The IncompleteFileDesc is also notified of new locations for this file.
 */
private synchronized void informMesh(RemoteFileDesc rfd,boolean good){
  if (!rfd.isAltLocCapable())   return;
  AlternateLocation loc=null;
  AlternateLocation forFD=null;
  try {
    loc=AlternateLocation.create(rfd);
    forFD=AlternateLocation.create(rfd);
  }
 catch (  IOException iox) {
    return;
  }
  for (Iterator iter=dloaders.iterator(); iter.hasNext(); ) {
    HTTPDownloader httpDloader=(HTTPDownloader)iter.next();
    RemoteFileDesc r=httpDloader.getRemoteFileDesc();
    if (r.getHost() == rfd.getHost() && r.getPort() == rfd.getPort())     continue;
    if (good)     httpDloader.addSuccessfulAltLoc(loc);
 else     httpDloader.addFailedAltLoc(loc);
  }
  FileDesc fd=fileManager.getFileDescForFile(incompleteFile);
  IncompleteFileDesc ifd=null;
  if (fd != null && fd instanceof IncompleteFileDesc)   ifd=(IncompleteFileDesc)fd;
  if (good) {
    if (RECORD_STATS && rfd.isFromAlternateLocation())     DownloadStat.ALTERNATE_WORKED.incrementStat();
    validAlts.add(loc);
    if (ifd != null)     ifd.addVerified(forFD);
  }
 else {
    if (RECORD_STATS && rfd.isFromAlternateLocation())     DownloadStat.ALTERNATE_NOT_ADDED.incrementStat();
    validAlts.remove(loc);
    if (ifd != null)     ifd.remove(forFD);
    invalidAlts.put(rfd,rfd);
  }
}",0.6025848142164781
4609,"/** 
 * Like addDownload, but doesn't call allowAddition(..). If cache is false, the RFD is not added to allFiles, but is added to the appropriate bucket. If the RFD matches one already in allFiles, the new one is NOT added to allFiles, but IS added the appropriate bucket if and only if a matching RFD is not currently in the bucket. If the file is ultimately added to buckets, either reqLock is released or this is notified. This ALWAYS returns true, because the download is either allowed or silently ignored (because we're already downloading or going to attempt to download from the host described in the RFD).
 */
protected final synchronized boolean addDownloadForced(RemoteFileDesc rfd,boolean cache){
  if (NetworkUtils.isMe(rfd.getHost(),rfd.getPort()))   return true;
  boolean exists=false;
  for (int i=0; i < allFiles.length; i++) {
    if (rfd.equals(allFiles[i])) {
      cache=false;
      exists=true;
      break;
    }
  }
  boolean added=false;
  if (buckets != null) {
    added=(buckets.add(rfd,exists) != -1);
  }
  if (cache) {
    RemoteFileDesc[] newAllFiles=new RemoteFileDesc[allFiles.length + 1];
    System.arraycopy(allFiles,0,newAllFiles,0,allFiles.length);
    newAllFiles[newAllFiles.length - 1]=rfd;
    allFiles=newAllFiles;
  }
  if (added) {
    if ((state == Downloader.WAITING_FOR_RETRY) || (state == Downloader.WAITING_FOR_RESULTS) || (state == Downloader.GAVE_UP)|| (state == Downloader.WAITING_FOR_USER))     reqLock.releaseDueToNewResults();
 else     this.notify();
  }
  return true;
}","/** 
 * Like addDownload, but doesn't call allowAddition(..). If cache is false, the RFD is not added to allFiles, but is added to the appropriate bucket. If the RFD matches one already in allFiles, the new one is NOT added to allFiles, but IS added the appropriate bucket if and only if a matching RFD is not currently in the bucket. If the file is ultimately added to buckets, either reqLock is released or this is notified. This ALWAYS returns true, because the download is either allowed or silently ignored (because we're already downloading or going to attempt to download from the host described in the RFD).
 */
protected final synchronized boolean addDownloadForced(RemoteFileDesc rfd,boolean cache){
  if (NetworkUtils.isMe(rfd.getHost(),rfd.getPort()))   return true;
  for (int i=0; i < allFiles.length; i++) {
    if (rfd.equals(allFiles[i])) {
      cache=false;
      break;
    }
  }
  boolean added=false;
  if (buckets != null) {
    added=(buckets.add(rfd,true) != -1);
  }
  if (cache) {
    RemoteFileDesc[] newAllFiles=new RemoteFileDesc[allFiles.length + 1];
    System.arraycopy(allFiles,0,newAllFiles,0,allFiles.length);
    newAllFiles[newAllFiles.length - 1]=rfd;
    allFiles=newAllFiles;
  }
  if (added) {
    if ((state == Downloader.WAITING_FOR_RETRY) || (state == Downloader.WAITING_FOR_RESULTS) || (state == Downloader.GAVE_UP)|| (state == Downloader.WAITING_FOR_USER))     reqLock.releaseDueToNewResults();
 else     this.notify();
  }
  return true;
}",0.9824445180523352
4610,"/** 
 * Attempts to run downloader.doDownload, notifying manager of termination via downloaders.notify().  To determine when this downloader should be removed from the dloaders list: never remove the downloader from dloaders if the uploader supports persistence, unless we get an exception - in which case we do not add it back to files.  If !http11, then we remove from the dloaders in the finally block and add to files as before if no problem was encountered.   
 * @param downloader the normal or push downloader to use for the transfer,which MUST be initialized (i.e., downloader.connectTCP() and connectHTTP() have been called)
 * @return true if there was no IOException while downloading, falseotherwise.  
 */
private boolean doDownload(HTTPDownloader downloader,boolean http11){
  debug(""String_Node_Str"" + downloader);
  boolean problem=false;
  RemoteFileDesc rfd=downloader.getRemoteFileDesc();
  try {
    downloader.doDownload(commonOutFile);
    rfd.resetFailedCount();
    if (RECORD_STATS) {
      if (http11)       DownloadStat.SUCCESFULL_HTTP11.incrementStat();
 else       DownloadStat.SUCCESFULL_HTTP10.incrementStat();
    }
    return true;
  }
 catch (  IOException e) {
    if (RECORD_STATS) {
      if (http11)       DownloadStat.FAILED_HTTP11.incrementStat();
 else       DownloadStat.FAILED_HTTP10.incrementStat();
    }
    problem=true;
    informMesh(downloader.getRemoteFileDesc(),false);
    chatList.removeHost(downloader);
    browseList.removeHost(downloader);
    return false;
  }
 finally {
    int stop=downloader.getInitialReadingPoint() + downloader.getAmountRead();
    debug(""String_Node_Str"" + downloader + ""String_Node_Str""+ stop+ ""String_Node_Str""+ problem);
synchronized (this) {
      if (problem) {
        updateNeeded(downloader);
        downloader.stop();
        rfd.incrementFailedCount();
        if (rfd.getFailedCount() < 2)         busy.add(rfd);
      }
      dloaders.remove(downloader);
      if (!problem && !http11)       files.add(rfd);
      if (!problem && rfd.isAltLocCapable()) {
        try {
          AlternateLocation loc=AlternateLocation.create(rfd);
          AlternateLocation loc2=AlternateLocation.create(rfd);
          informMesh(rfd,true);
          FileDesc desc=fileManager.getFileDescForFile(incompleteFile);
          if (desc != null)           desc.add(loc);
          addAlternateLocation(loc2);
        }
 catch (        IOException ignored) {
        }
      }
    }
  }
}","/** 
 * Attempts to run downloader.doDownload, notifying manager of termination via downloaders.notify().  To determine when this downloader should be removed from the dloaders list: never remove the downloader from dloaders if the uploader supports persistence, unless we get an exception - in which case we do not add it back to files.  If !http11, then we remove from the dloaders in the finally block and add to files as before if no problem was encountered.   
 * @param downloader the normal or push downloader to use for the transfer,which MUST be initialized (i.e., downloader.connectTCP() and connectHTTP() have been called)
 * @return true if there was no IOException while downloading, falseotherwise.  
 */
private boolean doDownload(HTTPDownloader downloader,boolean http11){
  debug(""String_Node_Str"" + downloader);
  boolean problem=false;
  RemoteFileDesc rfd=downloader.getRemoteFileDesc();
  try {
    downloader.doDownload(commonOutFile);
    rfd.resetFailedCount();
    if (RECORD_STATS) {
      if (http11)       DownloadStat.SUCCESFULL_HTTP11.incrementStat();
 else       DownloadStat.SUCCESFULL_HTTP10.incrementStat();
    }
  }
 catch (  IOException e) {
    if (RECORD_STATS) {
      if (http11)       DownloadStat.FAILED_HTTP11.incrementStat();
 else       DownloadStat.FAILED_HTTP10.incrementStat();
    }
    problem=true;
    chatList.removeHost(downloader);
    browseList.removeHost(downloader);
  }
 finally {
    int stop=downloader.getInitialReadingPoint() + downloader.getAmountRead();
    debug(""String_Node_Str"" + downloader + ""String_Node_Str""+ stop+ ""String_Node_Str""+ problem);
synchronized (this) {
      if (problem) {
        updateNeeded(downloader);
        downloader.stop();
        rfd.incrementFailedCount();
        if (rfd.getFailedCount() < 2)         busy.add(rfd);
 else         informMesh(rfd,false);
      }
 else {
        informMesh(rfd,true);
        if (!http11)         files.add(rfd);
      }
      dloaders.remove(downloader);
    }
  }
  return !problem;
}",0.8258639910813824
4611,"/** 
 * Returns an un-initialized (only established a TCP Connection,  no HTTP headers have been exchanged yet) connectable downloader  from the given list of locations. <p>  method tries to establish connection either by push or by normal ways. <p> If the connection fails for some reason, or needs a push the mesh needs  to be informed that this location failed.
 * @param rfd the RemoteFileDesc to connect to<p>  The following exceptions may be thrown within this method, but they are all dealt with internally. So this method does not throw any exception <p> NoSuchElementException thrown when (both normal and push) connections  to the given rfd fail. We discard the rfd by doing nothing and return  null.
 * @exception InterruptedException this thread was interrupted while waitingto connect. Remember this rfd by putting it back into files and return null 
 */
private HTTPDownloader establishConnection(RemoteFileDesc rfd){
  if (rfd == null)   return null;
  if (stopped) {
synchronized (this) {
      files.add(rfd);
    }
    return null;
  }
  File incFile=incompleteFileManager.getFile(rfd);
  HTTPDownloader ret;
  boolean needsPush=needsPush(rfd);
synchronized (this) {
    currentLocation=rfd.getHost();
    if (dloaders.size() == 0 && getState() != COMPLETE && getState() != ABORTED && getState() != GAVE_UP && getState() != COULDNT_MOVE_TO_LIBRARY && getState() != CORRUPT_FILE && getState() != HASHING && getState() != SAVING && queuedCount == 0)     setState(CONNECTING,needsPush ? PUSH_CONNECT_TIME : NORMAL_CONNECT_TIME);
  }
  debug(""String_Node_Str"" + rfd.getHost() + ""String_Node_Str""+ rfd.getPort());
  if (RECORD_STATS)   DownloadStat.CONNECTION_ATTEMPTS.incrementStat();
  if (rfd.isReplyToMulticast()) {
    try {
      ret=connectWithPush(rfd,incFile);
    }
 catch (    IOException e) {
      try {
        ret=connectDirectly(rfd,incFile);
      }
 catch (      IOException e2) {
        informMesh(rfd,false);
        return null;
      }
    }
    return ret;
  }
  if (!needsPush) {
    try {
      ret=connectDirectly(rfd,incFile);
      return ret;
    }
 catch (    IOException e) {
      informMesh(rfd,false);
    }
  }
  try {
    ret=connectWithPush(rfd,incFile);
    return ret;
  }
 catch (  IOException e) {
  }
  informMesh(rfd,false);
  return null;
}","/** 
 * Returns an un-initialized (only established a TCP Connection,  no HTTP headers have been exchanged yet) connectable downloader  from the given list of locations. <p>  method tries to establish connection either by push or by normal ways. <p> If the connection fails for some reason, or needs a push the mesh needs  to be informed that this location failed.
 * @param rfd the RemoteFileDesc to connect to<p>  The following exceptions may be thrown within this method, but they are all dealt with internally. So this method does not throw any exception <p> NoSuchElementException thrown when (both normal and push) connections  to the given rfd fail. We discard the rfd by doing nothing and return  null.
 * @exception InterruptedException this thread was interrupted while waitingto connect. Remember this rfd by putting it back into files and return null 
 */
private HTTPDownloader establishConnection(RemoteFileDesc rfd){
  if (rfd == null)   return null;
  if (stopped) {
synchronized (this) {
      files.add(rfd);
    }
    return null;
  }
  File incFile=incompleteFileManager.getFile(rfd);
  HTTPDownloader ret;
  boolean needsPush=needsPush(rfd);
synchronized (this) {
    currentLocation=rfd.getHost();
    if (dloaders.size() == 0 && getState() != COMPLETE && getState() != ABORTED && getState() != GAVE_UP && getState() != COULDNT_MOVE_TO_LIBRARY && getState() != CORRUPT_FILE && getState() != HASHING && getState() != SAVING && queuedCount == 0)     setState(CONNECTING,needsPush ? PUSH_CONNECT_TIME : NORMAL_CONNECT_TIME);
  }
  debug(""String_Node_Str"" + rfd.getHost() + ""String_Node_Str""+ rfd.getPort());
  if (RECORD_STATS)   DownloadStat.CONNECTION_ATTEMPTS.incrementStat();
  if (rfd.isReplyToMulticast()) {
    try {
      ret=connectWithPush(rfd,incFile);
    }
 catch (    IOException e) {
      try {
        ret=connectDirectly(rfd,incFile);
      }
 catch (      IOException e2) {
        return null;
      }
    }
    return ret;
  }
  if (!needsPush) {
    try {
      ret=connectDirectly(rfd,incFile);
      return ret;
    }
 catch (    IOException e) {
    }
  }
  informMesh(rfd,false);
  try {
    ret=connectWithPush(rfd,incFile);
    return ret;
  }
 catch (  IOException e) {
  }
  return null;
}",0.9792768959435626
4612,"/** 
 * Assigns a white area or a grey area to a downloader. Sets the state, and checks if this downloader has been interrupted.
 * @param dloader The downloader to which this method assigns eithera grey area or white area.
 * @param refSleepTime this parameter is used for pass by reference, thismethod puts the minPollTime as the 0th element of this array.
 * @return 0 if (the server is not giving us the file)TryAgainLater, FileNotFound, NotSharing, Stopped, Misc IOE otherwise if queued return 1 otherwise if connected successfully return 2 otherwise if NoSuchElement( we have no areas to steal) return 3 otherwise if rfd was partial uploader and gave us ranges to try return 4
 */
private int assignAndRequest(HTTPDownloader dloader,int[] refSleepTime,boolean http11){
synchronized (stealLock) {
    RemoteFileDesc rfd=dloader.getRemoteFileDesc();
    boolean updateNeeded=true;
    try {
      if (!needed.isEmpty()) {
        assignWhite(dloader,http11);
      }
 else {
        updateNeeded=false;
        assignGrey(dloader,http11);
      }
      updateNeeded=false;
    }
 catch (    NoSuchElementException nsex) {
      if (RECORD_STATS)       DownloadStat.NSE_EXCEPTION.incrementStat();
      Assert.that(updateNeeded == false,""String_Node_Str"");
      debug(""String_Node_Str"" + dloader);
synchronized (this) {
        files.add(rfd);
      }
      return 3;
    }
catch (    NoSuchRangeException nsrx) {
      if (RECORD_STATS)       DownloadStat.NSR_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
synchronized (this) {
        rfd.setAvailableRanges(null);
        busy.add(rfd);
      }
      rfd.resetFailedCount();
      return 0;
    }
catch (    TryAgainLaterException talx) {
      if (RECORD_STATS)       DownloadStat.TAL_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
synchronized (this) {
        busy.add(rfd);
      }
      rfd.resetFailedCount();
      return 0;
    }
catch (    RangeNotAvailableException rnae) {
      if (RECORD_STATS)       DownloadStat.RNA_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      rfd.resetFailedCount();
      informMesh(dloader.getRemoteFileDesc(),true);
      return 4;
    }
catch (    FileNotFoundException fnfx) {
      if (RECORD_STATS)       DownloadStat.FNF_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      informMesh(dloader.getRemoteFileDesc(),false);
      return 0;
    }
catch (    NotSharingException nsx) {
      if (RECORD_STATS)       DownloadStat.NS_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      informMesh(dloader.getRemoteFileDesc(),false);
      return 0;
    }
catch (    QueuedException qx) {
      if (RECORD_STATS)       DownloadStat.Q_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      refSleepTime[0]=qx.getMinPollTime() * 1000 + 1000;
synchronized (this) {
        if (dloaders.size() == 0) {
          setState(REMOTE_QUEUED);
        }
        int oldPos=queuePosition.equals(""String_Node_Str"") ? Integer.MAX_VALUE : Integer.parseInt(queuePosition);
        int newPos=qx.getQueuePosition();
        if (newPos < oldPos) {
          queuePosition=""String_Node_Str"" + newPos;
          queuedVendor=dloader.getVendor();
        }
      }
      rfd.resetFailedCount();
      return 1;
    }
catch (    ProblemReadingHeaderException prhe) {
      if (RECORD_STATS)       DownloadStat.PRH_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      informMesh(dloader.getRemoteFileDesc(),false);
      return 0;
    }
catch (    UnknownCodeException uce) {
      if (RECORD_STATS)       DownloadStat.UNKNOWN_CODE_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + uce.getCode() + ""String_Node_Str""+ dloader);
      informMesh(dloader.getRemoteFileDesc(),false);
      return 0;
    }
catch (    IOException iox) {
      if (RECORD_STATS)       DownloadStat.IO_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      rfd.incrementFailedCount();
      if (rfd.getFailedCount() < 2) synchronized (this) {
        busy.add(rfd);
      }
 else       informMesh(dloader.getRemoteFileDesc(),false);
      return 0;
    }
 finally {
      AlternateLocationCollection c=dloader.getAltLocsReceived();
      if (c != null) {
synchronized (c) {
          Iterator iter=c.iterator();
          while (iter.hasNext()) {
            AlternateLocation al=(AlternateLocation)iter.next();
            RemoteFileDesc rfd1=al.createRemoteFileDesc(dloader.getRemoteFileDesc().getSize());
            addDownload(rfd1,false);
          }
        }
      }
      if (updateNeeded)       updateNeeded(dloader);
    }
    if (RECORD_STATS && rfd.getFailedCount() > 0)     DownloadStat.RETRIED_SUCCESS.incrementStat();
    rfd.resetFailedCount();
synchronized (this) {
      setState(DOWNLOADING);
    }
    if (stopped) {
      debug(""String_Node_Str"");
      updateNeeded(dloader);
synchronized (this) {
        files.add(rfd);
      }
      return 0;
    }
synchronized (this) {
      dloaders.add(dloader);
      chatList.addHost(dloader);
      browseList.addHost(dloader);
    }
    if (RECORD_STATS)     DownloadStat.RESPONSE_OK.incrementStat();
    return 2;
  }
}","/** 
 * Assigns a white area or a grey area to a downloader. Sets the state, and checks if this downloader has been interrupted.
 * @param dloader The downloader to which this method assigns eithera grey area or white area.
 * @param refSleepTime this parameter is used for pass by reference, thismethod puts the minPollTime as the 0th element of this array.
 * @return 0 if (the server is not giving us the file)TryAgainLater, FileNotFound, NotSharing, Stopped, Misc IOE otherwise if queued return 1 otherwise if connected successfully return 2 otherwise if NoSuchElement( we have no areas to steal) return 3 otherwise if rfd was partial uploader and gave us ranges to try return 4
 */
private int assignAndRequest(HTTPDownloader dloader,int[] refSleepTime,boolean http11){
synchronized (stealLock) {
    RemoteFileDesc rfd=dloader.getRemoteFileDesc();
    boolean updateNeeded=true;
    try {
      if (!needed.isEmpty()) {
        assignWhite(dloader,http11);
      }
 else {
        updateNeeded=false;
        assignGrey(dloader,http11);
      }
      updateNeeded=false;
    }
 catch (    NoSuchElementException nsex) {
      if (RECORD_STATS)       DownloadStat.NSE_EXCEPTION.incrementStat();
      Assert.that(updateNeeded == false,""String_Node_Str"");
      debug(""String_Node_Str"" + dloader);
synchronized (this) {
        files.add(rfd);
      }
      return 3;
    }
catch (    NoSuchRangeException nsrx) {
      if (RECORD_STATS)       DownloadStat.NSR_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
synchronized (this) {
        rfd.setAvailableRanges(null);
        busy.add(rfd);
      }
      rfd.resetFailedCount();
      return 0;
    }
catch (    TryAgainLaterException talx) {
      if (RECORD_STATS)       DownloadStat.TAL_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
synchronized (this) {
        busy.add(rfd);
      }
      rfd.resetFailedCount();
      return 0;
    }
catch (    RangeNotAvailableException rnae) {
      if (RECORD_STATS)       DownloadStat.RNA_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      rfd.resetFailedCount();
      informMesh(rfd,true);
      return 4;
    }
catch (    FileNotFoundException fnfx) {
      if (RECORD_STATS)       DownloadStat.FNF_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      informMesh(rfd,false);
      return 0;
    }
catch (    NotSharingException nsx) {
      if (RECORD_STATS)       DownloadStat.NS_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      informMesh(rfd,false);
      return 0;
    }
catch (    QueuedException qx) {
      if (RECORD_STATS)       DownloadStat.Q_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      refSleepTime[0]=qx.getMinPollTime() * 1000 + 1000;
synchronized (this) {
        if (dloaders.size() == 0) {
          setState(REMOTE_QUEUED);
        }
        int oldPos=queuePosition.equals(""String_Node_Str"") ? Integer.MAX_VALUE : Integer.parseInt(queuePosition);
        int newPos=qx.getQueuePosition();
        if (newPos < oldPos) {
          queuePosition=""String_Node_Str"" + newPos;
          queuedVendor=dloader.getVendor();
        }
      }
      rfd.resetFailedCount();
      return 1;
    }
catch (    ProblemReadingHeaderException prhe) {
      if (RECORD_STATS)       DownloadStat.PRH_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      informMesh(rfd,false);
      return 0;
    }
catch (    UnknownCodeException uce) {
      if (RECORD_STATS)       DownloadStat.UNKNOWN_CODE_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + uce.getCode() + ""String_Node_Str""+ dloader);
      informMesh(rfd,false);
      return 0;
    }
catch (    IOException iox) {
      if (RECORD_STATS)       DownloadStat.IO_EXCEPTION.incrementStat();
      debug(""String_Node_Str"" + dloader);
      rfd.incrementFailedCount();
      if (rfd.getFailedCount() < 2) synchronized (this) {
        busy.add(rfd);
      }
 else       informMesh(rfd,false);
      return 0;
    }
 finally {
      AlternateLocationCollection c=dloader.getAltLocsReceived();
      if (c != null) {
synchronized (c) {
          Iterator iter=c.iterator();
          while (iter.hasNext()) {
            AlternateLocation al=(AlternateLocation)iter.next();
            RemoteFileDesc rfd1=al.createRemoteFileDesc(rfd.getSize());
            addDownload(rfd1,false);
          }
        }
      }
      if (updateNeeded)       updateNeeded(dloader);
    }
    if (RECORD_STATS && rfd.getFailedCount() > 0)     DownloadStat.RETRIED_SUCCESS.incrementStat();
    rfd.resetFailedCount();
synchronized (this) {
      setState(DOWNLOADING);
    }
    if (stopped) {
      debug(""String_Node_Str"");
      updateNeeded(dloader);
synchronized (this) {
        files.add(rfd);
      }
      return 0;
    }
synchronized (this) {
      dloaders.add(dloader);
      chatList.addHost(dloader);
      browseList.addHost(dloader);
    }
    if (RECORD_STATS)     DownloadStat.RESPONSE_OK.incrementStat();
    return 2;
  }
}",0.9795600545065212
4613,"/** 
 * Initializes a ManagedDownloader read from disk. Also used for internally initializing or resuming a normal download; there is no need to explicitly call this method in that case. After the call, this is in the queued state, at least for the moment.
 * @requires this is uninitialized or stopped, and allFiles, and incompleteFileManager are set
 * @modifies everything but the above fields 
 * @param deserialized True if this downloader is being initialized after being read from disk, false otherwise.
 */
public void initialize(DownloadManager manager,FileManager fileManager,ActivityCallback callback,final boolean deserialized){
  this.manager=manager;
  this.fileManager=fileManager;
  this.callback=callback;
  dloaders=new LinkedList();
  threads=new ArrayList();
  chatList=new DownloadChatList();
  browseList=new DownloadBrowseHostList();
  stealLock=new Object();
  stopped=false;
  setState(QUEUED);
  miniRFDToLock=Collections.synchronizedMap(new HashMap());
  threadLockToSocket=Collections.synchronizedMap(new HashMap());
  corruptState=NOT_CORRUPT_STATE;
  corruptStateLock=new Object();
  numMeasures=0;
  averageBandwidth=0f;
  this.dloaderManagerThread=new Thread(""String_Node_Str""){
    public void run(){
      try {
        tryAllDownloads(deserialized);
      }
 catch (      Throwable e) {
        ErrorService.error(e);
      }
    }
  }
;
  dloaderManagerThread.setDaemon(true);
  dloaderManagerThread.start();
}","/** 
 * Initializes a ManagedDownloader read from disk. Also used for internally initializing or resuming a normal download; there is no need to explicitly call this method in that case. After the call, this is in the queued state, at least for the moment.
 * @requires this is uninitialized or stopped, and allFiles, and incompleteFileManager are set
 * @modifies everything but the above fields 
 * @param deserialized True if this downloader is being initialized after being read from disk, false otherwise.
 */
public void initialize(DownloadManager manager,FileManager fileManager,ActivityCallback callback,final boolean deserialized){
  this.manager=manager;
  this.fileManager=fileManager;
  this.callback=callback;
  dloaders=new LinkedList();
  threads=new ArrayList();
  chatList=new DownloadChatList();
  browseList=new DownloadBrowseHostList();
  stealLock=new Object();
  stopped=false;
  setState(QUEUED);
  miniRFDToLock=Collections.synchronizedMap(new HashMap());
  threadLockToSocket=Collections.synchronizedMap(new HashMap());
  corruptState=NOT_CORRUPT_STATE;
  corruptStateLock=new Object();
  numMeasures=0;
  averageBandwidth=0f;
  invalidAlts=new FixedsizeForgetfulHashMap(100);
  this.dloaderManagerThread=new Thread(""String_Node_Str""){
    public void run(){
      try {
        tryAllDownloads(deserialized);
      }
 catch (      Throwable e) {
        ErrorService.error(e);
      }
    }
  }
;
  dloaderManagerThread.setDaemon(true);
  dloaderManagerThread.start();
}",0.9830047586675732
4614,"/** 
 * Starts ""uploading"" the requested file.  The behavior of the upload, however, depends on the current upload state.  If the file was not found, for example, the upload sends a 404 Not Found message, whereas in the case of a normal upload, the file is transferred as expected.<p> This method also handles storing any newly discovered alternate  locations for this file in the corresponding <tt>FileDesc</tt>.  The new alternate locations are discovered through the requesting client's HTTP headers.<p> Implements the <tt>Uploader</tt> interface.
 */
public void writeResponse() throws IOException {
  try {
    _method.writeHttpResponse(_state,_ostream);
  }
 catch (  IOException e) {
    if (_amountRead < _amountRequested)     throw e;
  }
 finally {
    if (_fileDesc != null) {
synchronized (_badLocs) {
        Iterator iter=_badLocs.iterator();
        while (iter.hasNext()) {
          AlternateLocation loc=((AlternateLocation)iter.next()).createClone();
          Assert.that(loc != null,""String_Node_Str"");
          _fileDesc.remove(loc);
        }
      }
synchronized (_goodLocs) {
        Iterator iter=_goodLocs.iterator();
        while (iter.hasNext()) {
          AlternateLocation loc=((AlternateLocation)iter.next()).createClone();
          Assert.that(loc != null,""String_Node_Str"");
          _fileDesc.add(loc);
        }
      }
    }
  }
}","/** 
 * Starts ""uploading"" the requested file.  The behavior of the upload, however, depends on the current upload state.  If the file was not found, for example, the upload sends a 404 Not Found message, whereas in the case of a normal upload, the file is transferred as expected.<p> This method also handles storing any newly discovered alternate  locations for this file in the corresponding <tt>FileDesc</tt>.  The new alternate locations are discovered through the requesting client's HTTP headers.<p> Implements the <tt>Uploader</tt> interface.
 */
public void writeResponse() throws IOException {
  try {
    _method.writeHttpResponse(_state,_ostream);
  }
 catch (  IOException e) {
    if (_amountRead < _amountRequested)     throw e;
  }
 finally {
    if (_fileDesc != null) {
      if (_badLocs != null) {
synchronized (_badLocs) {
          Iterator iter=_badLocs.iterator();
          while (iter.hasNext()) {
            AlternateLocation loc=((AlternateLocation)iter.next()).createClone();
            Assert.that(loc != null,""String_Node_Str"");
            _fileDesc.remove(loc);
          }
        }
      }
      if (_goodLocs != null) {
synchronized (_goodLocs) {
          Iterator iter=_goodLocs.iterator();
          while (iter.hasNext()) {
            AlternateLocation loc=((AlternateLocation)iter.next()).createClone();
            Assert.that(loc != null,""String_Node_Str"");
            _fileDesc.add(loc);
          }
        }
      }
    }
  }
}",0.9631449631449632
4615,"/** 
 * Busy loop that accepts incoming messages sent over UDP and  dispatches them to their appropriate handlers.
 */
public void run(){
  try {
    byte[] datagramBytes=new byte[BUFFER_SIZE];
    MessageRouter router=RouterService.getMessageRouter();
    while (true) {
      DatagramPacket datagram=new DatagramPacket(datagramBytes,BUFFER_SIZE);
synchronized (_receiveLock) {
        while (_socket == null) {
          try {
            _receiveLock.wait();
          }
 catch (          InterruptedException ignored) {
            continue;
          }
        }
        try {
          _socket.receive(datagram);
        }
 catch (        InterruptedIOException e) {
          continue;
        }
catch (        IOException e) {
          continue;
        }
      }
      byte[] data=datagram.getData();
      try {
        InputStream in=new ByteArrayInputStream(data);
        Message message=Message.read(in,Message.N_UDP);
        if (!isGUESSCapable()) {
          if (message instanceof PingRequest) {
            GUID guidReceived=new GUID(message.getGUID());
            if (CONNECT_BACK_GUID.equals(guidReceived))             _acceptedUnsolicitedIncoming=true;
          }
 else           _acceptedSolicitedIncoming=true;
        }
        if (message == null)         continue;
        router.handleUDPMessage(message,datagram);
      }
 catch (      IOException e) {
        continue;
      }
catch (      BadPacketException e) {
        continue;
      }
    }
  }
 catch (  Throwable t) {
    ErrorService.error(t);
  }
}","/** 
 * Busy loop that accepts incoming messages sent over UDP and  dispatches them to their appropriate handlers.
 */
public void run(){
  try {
    byte[] datagramBytes=new byte[BUFFER_SIZE];
    MessageRouter router=RouterService.getMessageRouter();
    while (true) {
      DatagramPacket datagram=new DatagramPacket(datagramBytes,BUFFER_SIZE);
synchronized (_receiveLock) {
        while (_socket == null) {
          try {
            _receiveLock.wait();
          }
 catch (          InterruptedException ignored) {
            continue;
          }
        }
        try {
          _socket.receive(datagram);
        }
 catch (        InterruptedIOException e) {
          continue;
        }
catch (        IOException e) {
          continue;
        }
      }
      byte[] data=datagram.getData();
      try {
        InputStream in=new ByteArrayInputStream(data);
        Message message=Message.read(in,Message.N_UDP);
        if (message == null)         continue;
        if (!isGUESSCapable()) {
          if (message instanceof PingRequest) {
            GUID guidReceived=new GUID(message.getGUID());
            if (CONNECT_BACK_GUID.equals(guidReceived))             _acceptedUnsolicitedIncoming=true;
          }
 else           _acceptedSolicitedIncoming=true;
        }
        router.handleUDPMessage(message,datagram);
      }
 catch (      IOException e) {
        continue;
      }
catch (      BadPacketException e) {
        continue;
      }
    }
  }
 catch (  Throwable t) {
    ErrorService.error(t);
  }
}",0.9695003244646332
4616,"/** 
 * Blocks certain vendors from being queued, because of buggy downloading implementations on their side.
 */
private boolean isValidQueueingAgent(){
  return !_userAgent.startsWith(""String_Node_Str"");
}","/** 
 * Blocks certain vendors from being queued, because of buggy downloading implementations on their side.
 */
private boolean isValidQueueingAgent(){
  if (_userAgent == null)   return true;
  return !_userAgent.startsWith(""String_Node_Str"");
}",0.90989010989011
4617,"private static void aggregateResponse(HashMap uriToString,LimeXMLDocument doc,int index){
  if (doc == null)   return;
  String uri=doc.getSchemaURI();
  StringBuffer currStringB=(StringBuffer)uriToString.get(uri);
  if (currStringB == null) {
    String str=null;
    try {
      str=doc.getXMLString();
    }
 catch (    SchemaNotFoundException e) {
      return;
    }
    if (str == null || str.equals(""String_Node_Str""))     return;
    str=str.substring(0,str.lastIndexOf(""String_Node_Str""));
    int p=str.indexOf(""String_Node_Str"");
    Assert.that(p >= 0,""String_Node_Str"");
    p=str.indexOf(""String_Node_Str"",p + 1);
    Assert.that(p >= 0,""String_Node_Str"");
    p=str.indexOf(""String_Node_Str"",p + 1);
    Assert.that(p >= 0,""String_Node_Str"");
    int q=str.indexOf(""String_Node_Str"",p + 1);
    int k=str.lastIndexOf(""String_Node_Str"",q - 1);
    if (k != -1 && p < k && k < q)     if (str.substring(k + 1,q).trim().equals(""String_Node_Str""))     p=k;
 else     p=q;
 else     p=q;
    String first=str.substring(0,p);
    String last=str.substring(p);
    StringBuffer strB=new StringBuffer(first.length() + 15 + last.length());
    strB.append(first);
    strB.append(""String_Node_Str"");
    strB.append(index);
    strB.append(""String_Node_Str"");
    strB.append(last);
    uriToString.put(uri,strB);
  }
 else {
    String str=null;
    try {
      str=doc.getXMLString();
    }
 catch (    SchemaNotFoundException e) {
      return;
    }
    int begin=str.indexOf(""String_Node_Str"");
    begin=str.indexOf(""String_Node_Str"",begin + 1);
    begin=str.indexOf(""String_Node_Str"",begin + 1);
    int end=str.lastIndexOf(""String_Node_Str"");
    str=str.substring(begin,end);
    int p=str.indexOf(""String_Node_Str"");
    int q=str.lastIndexOf(""String_Node_Str"",p - 1);
    if (q != -1 && q < p)     if (str.substring(q + 1,p).trim().equals(""String_Node_Str""))     p=q;
    String first=str.substring(0,p);
    String last=str.substring(p);
    currStringB.append(first);
    currStringB.append(""String_Node_Str"");
    currStringB.append(index);
    currStringB.append(""String_Node_Str"");
    currStringB.append(last);
    uriToString.put(uri,currStringB);
  }
}","private static void aggregateResponse(HashMap uriToString,LimeXMLDocument doc,int index){
  if (doc == null)   return;
  String uri=doc.getSchemaURI();
  StringBuffer currStringB=(StringBuffer)uriToString.get(uri);
  if (currStringB == null) {
    String str=null;
    try {
      str=doc.getXMLString();
    }
 catch (    SchemaNotFoundException e) {
      return;
    }
    if (str == null || str.equals(""String_Node_Str""))     return;
    str=str.substring(0,str.lastIndexOf(""String_Node_Str""));
    int p=str.indexOf(""String_Node_Str"");
    Assert.that(p >= 0,""String_Node_Str"");
    p=str.indexOf(""String_Node_Str"",p + 1);
    Assert.that(p >= 0,""String_Node_Str"");
    p=str.indexOf(""String_Node_Str"",p + 1);
    Assert.that(p >= 0,""String_Node_Str"");
    int q=str.indexOf(""String_Node_Str"",p + 1);
    int k=str.lastIndexOf(""String_Node_Str"",q - 1);
    if (k != -1 && p < k && k < q)     if (str.substring(k + 1,q).trim().equals(""String_Node_Str""))     p=k;
 else     p=q;
 else     p=q;
    String first=str.substring(0,p);
    String last=str.substring(p);
    StringBuffer strB=new StringBuffer(first.length() + 15 + last.length());
    strB.append(first);
    strB.append(""String_Node_Str"");
    strB.append(index);
    strB.append(""String_Node_Str"");
    strB.append(last);
    uriToString.put(uri,strB);
  }
 else {
    String str=null;
    try {
      str=doc.getXMLString();
    }
 catch (    SchemaNotFoundException e) {
      return;
    }
    int begin=str.indexOf(""String_Node_Str"");
    Assert.that(begin != -1,str);
    begin=str.indexOf(""String_Node_Str"",begin + 1);
    Assert.that(begin != -1,str);
    begin=str.indexOf(""String_Node_Str"",begin + 1);
    Assert.that(begin != -1,str);
    int end=str.lastIndexOf(""String_Node_Str"");
    Assert.that(end != -1,str);
    str=str.substring(begin,end);
    int p=str.indexOf(""String_Node_Str"");
    int q=str.lastIndexOf(""String_Node_Str"",p - 1);
    if (q != -1 && q < p)     if (str.substring(q + 1,p).trim().equals(""String_Node_Str""))     p=q;
    String first=str.substring(0,p);
    String last=str.substring(p);
    currStringB.append(first);
    currStringB.append(""String_Node_Str"");
    currStringB.append(index);
    currStringB.append(""String_Node_Str"");
    currStringB.append(last);
    uriToString.put(uri,currStringB);
  }
}",0.9701426024955436
4618,"/** 
 * Reloads the file from disk to read values from.
 */
public static void reload(){
  File themeFile=ThemeSettings.THEME_FILE.getValue();
  File themeDir=ThemeSettings.extractThemeDir(themeFile);
  if (!themeDir.isDirectory()) {
    ThemeSettings.expandTheme(themeFile,themeDir,false);
  }
  final File THEME_PROPS=new File(themeDir,""String_Node_Str"");
  handleFactory(THEME_PROPS);
  ThemeSettings.THEME_DIR.setValue(themeDir);
}","/** 
 * Reloads the file from disk to read values from.
 */
public static void reload(){
  File themeFile=ThemeSettings.THEME_FILE.getValue();
  if (!ThemeSettings.isThemeFile(themeFile))   ThemeSettings.THEME_FILE.revertToDefault();
  themeFile=ThemeSettings.THEME_FILE.getValue();
  File themeDir=ThemeSettings.extractThemeDir(themeFile);
  if (!themeDir.isDirectory()) {
    if (!themeFile.exists()) {
      ThemeSettings.THEME_FILE.revertToDefault();
      themeFile=ThemeSettings.THEME_FILE.getValue();
      themeDir=ThemeSettings.extractThemeDir(themeFile);
    }
    ThemeSettings.expandTheme(themeFile,themeDir,false);
  }
  final File THEME_PROPS=new File(themeDir,""String_Node_Str"");
  handleFactory(THEME_PROPS);
  ThemeSettings.THEME_DIR.setValue(themeDir);
}",0.6992543496271748
4619,"/** 
 * Returns the keywords for a requery, i.e., the keywords found in all filenames.  REQUIRES: allFiles.length MUST be greater than 0. 
 */
private final synchronized String extractQueryString(){
  Assert.that(allFiles.length > 0,""String_Node_Str"");
  Set intersection=keywords(allFiles[0].getFileName());
  StringBuffer sb=new StringBuffer();
  int numWritten=0;
  for (Iterator keys=intersection.iterator(); keys.hasNext() && (numWritten < 30); ) {
    String currKey=(String)keys.next();
    numWritten+=currKey.length() + 1;
    sb.append(currKey);
    if (keys.hasNext())     sb.append(""String_Node_Str"");
  }
  return sb.toString();
}","/** 
 * Returns the keywords for a requery, i.e., the keywords found in all filenames.  REQUIRES: allFiles.length MUST be greater than 0. 
 */
private final synchronized String extractQueryString(){
  Assert.that(allFiles.length > 0,""String_Node_Str"");
  final int MAX_LEN=30;
  Set intersection=keywords(allFiles[0].getFileName());
  StringBuffer sb=new StringBuffer();
  int numWritten=0;
  for (Iterator keys=intersection.iterator(); keys.hasNext() && (numWritten < MAX_LEN); ) {
    String currKey=(String)keys.next();
    if ((numWritten + currKey.length()) < MAX_LEN) {
      if (numWritten > 0)       sb.append(""String_Node_Str"");
      sb.append(currKey);
      numWritten+=currKey.length() + (numWritten == 0 ? 0 : 1);
    }
  }
  String retString=sb.toString();
  Assert.that(retString.length() <= MAX_LEN);
  return retString;
}",0.7503373819163293
4620,"/** 
 * Helper method left from SettingsManager. Sets the directory for saving files. <p><b>Modifies:</b> DIRECTORY_FOR_SAVING_FILES, INCOMPLETE_DIRECTORY,  DOWNLOAD_SNAPSHOT_FILE</p>
 * @param saveDir  A <tt>File</tt> instance denoting theabstract pathname of the directory for saving files.
 * @throws  <tt>IOException</tt>If the directory denoted by the directory pathname String parameter did not exist prior to this method call and could not be created, or if the canonical path could not be retrieved from the file system.
 * @throws  <tt>NullPointerException</tt>If the ""dir"" parameter is null.
 */
public static final void setSaveDirectory(File saveDir) throws IOException {
  if (saveDir == null)   throw new NullPointerException();
  if (!saveDir.isDirectory()) {
    if (!saveDir.mkdirs())     throw new IOException();
  }
  String parentDir=saveDir.getParent();
  File incDir=new File(parentDir,""String_Node_Str"");
  if (!incDir.isDirectory()) {
    if (!incDir.mkdirs())     throw new IOException();
  }
  if (!saveDir.canRead() || !saveDir.canWrite() || !incDir.canRead()|| !incDir.canWrite()) {
    throw new IOException();
  }
  try {
    saveDir=FileUtils.getCanonicalFile(saveDir);
  }
 catch (  IOException ignored) {
  }
  try {
    incDir=FileUtils.getCanonicalFile(incDir);
  }
 catch (  IOException ignored) {
  }
  File snapFile=new File(incDir,""String_Node_Str"");
  try {
    snapFile=FileUtils.getCanonicalFile(snapFile);
  }
 catch (  IOException ignored) {
  }
  File snapBackup=new File(incDir,""String_Node_Str"");
  try {
    snapBackup=FileUtils.getCanonicalFile(snapBackup);
  }
 catch (  IOException ignored) {
  }
  DIRECTORY_FOR_SAVING_FILES.setValue(saveDir);
  INCOMPLETE_DIRECTORY.setValue(incDir);
  DOWNLOAD_SNAPSHOT_FILE.setValue(snapFile);
  DOWNLOAD_SNAPSHOT_BACKUP_FILE.setValue(snapBackup);
}","/** 
 * Helper method left from SettingsManager. Sets the directory for saving files. <p><b>Modifies:</b> DIRECTORY_FOR_SAVING_FILES, INCOMPLETE_DIRECTORY,  DOWNLOAD_SNAPSHOT_FILE</p>
 * @param saveDir  A <tt>File</tt> instance denoting theabstract pathname of the directory for saving files.
 * @throws  <tt>IOException</tt>If the directory denoted by the directory pathname String parameter did not exist prior to this method call and could not be created, or if the canonical path could not be retrieved from the file system.
 * @throws  <tt>NullPointerException</tt>If the ""dir"" parameter is null.
 */
public static final void setSaveDirectory(File saveDir) throws IOException {
  if (saveDir == null)   throw new NullPointerException();
  if (!saveDir.isDirectory()) {
    if (!saveDir.mkdirs())     throw new IOException(""String_Node_Str"");
  }
  String parentDir=saveDir.getParent();
  File incDir=new File(parentDir,""String_Node_Str"");
  if (!incDir.isDirectory()) {
    if (!incDir.mkdirs())     throw new IOException(""String_Node_Str"");
  }
  if (!saveDir.canRead() || !saveDir.canWrite() || !incDir.canRead()|| !incDir.canWrite()) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    saveDir=FileUtils.getCanonicalFile(saveDir);
  }
 catch (  IOException ignored) {
  }
  try {
    incDir=FileUtils.getCanonicalFile(incDir);
  }
 catch (  IOException ignored) {
  }
  File snapFile=new File(incDir,""String_Node_Str"");
  try {
    snapFile=FileUtils.getCanonicalFile(snapFile);
  }
 catch (  IOException ignored) {
  }
  File snapBackup=new File(incDir,""String_Node_Str"");
  try {
    snapBackup=FileUtils.getCanonicalFile(snapBackup);
  }
 catch (  IOException ignored) {
  }
  DIRECTORY_FOR_SAVING_FILES.setValue(saveDir);
  INCOMPLETE_DIRECTORY.setValue(incDir);
  DOWNLOAD_SNAPSHOT_FILE.setValue(snapFile);
  DOWNLOAD_SNAPSHOT_BACKUP_FILE.setValue(snapBackup);
}",0.9863013698630136
4621,"/** 
 * Factory method for instantiating individual responses from an <tt>InputStream</tt> instance.
 * @param is the <tt>InputStream</tt> to read from
 * @throws <tt>IOException</tt> if there are any problems reading fromor writing to the stream
 */
public static Response createFromStream(InputStream is) throws IOException {
  long index=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  long size=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IOException(""String_Node_Str"" + index);
  if ((size & 0xFFFFFFFF00000000L) != 0)   throw new IOException(""String_Node_Str"" + size);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int c;
  while ((c=is.read()) != 0) {
    baos.write(c);
  }
  String name=new String(baos.toByteArray());
  if (name.length() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  baos.reset();
  while ((c=is.read()) != 0) {
    baos.write(c);
  }
  byte[] rawMeta=baos.toByteArray();
  String betweenNulls=new String(rawMeta);
  if (betweenNulls == null || betweenNulls.equals(""String_Node_Str"")) {
    if (is.available() < 16) {
      throw new IOException(""String_Node_Str"");
    }
    return new Response(index,size,name);
  }
 else {
    StringTokenizer stok=new StringTokenizer(betweenNulls,""String_Node_Str"");
    Set urns=null;
    String metaString=null;
    while (stok.hasMoreTokens()) {
      String ext=stok.nextToken();
      if (URN.isUrn(ext)) {
        try {
          URN urn=URN.createSHA1Urn(ext);
          if (urns == null)           urns=new HashSet();
          urns.add(urn);
        }
 catch (        IOException e) {
          continue;
        }
      }
 else {
        metaString=createXmlString(name,ext);
      }
    }
    return new Response(index,size,name,metaString,urns,null,rawMeta);
  }
}","/** 
 * Factory method for instantiating individual responses from an <tt>InputStream</tt> instance.
 * @param is the <tt>InputStream</tt> to read from
 * @throws <tt>IOException</tt> if there are any problems reading fromor writing to the stream
 */
public static Response createFromStream(InputStream is) throws IOException {
  long index=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  long size=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IOException(""String_Node_Str"" + index);
  if (size > Integer.MAX_VALUE || size < 0)   throw new IOException(""String_Node_Str"" + size);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int c;
  while ((c=is.read()) != 0) {
    baos.write(c);
  }
  String name=new String(baos.toByteArray());
  if (name.length() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  baos.reset();
  while ((c=is.read()) != 0) {
    baos.write(c);
  }
  byte[] rawMeta=baos.toByteArray();
  String betweenNulls=new String(rawMeta);
  if (betweenNulls == null || betweenNulls.equals(""String_Node_Str"")) {
    if (is.available() < 16) {
      throw new IOException(""String_Node_Str"");
    }
    return new Response(index,size,name);
  }
 else {
    StringTokenizer stok=new StringTokenizer(betweenNulls,""String_Node_Str"");
    Set urns=null;
    String metaString=null;
    while (stok.hasMoreTokens()) {
      String ext=stok.nextToken();
      if (URN.isUrn(ext)) {
        try {
          URN urn=URN.createSHA1Urn(ext);
          if (urns == null)           urns=new HashSet();
          urns.add(urn);
        }
 catch (        IOException e) {
          continue;
        }
      }
 else {
        metaString=createXmlString(name,ext);
      }
    }
    return new Response(index,size,name,metaString,urns,null,rawMeta);
  }
}",0.98548342919748
4622,"/** 
 * Overloaded constructor that allows the creation of Responses with meta-data and a <tt>Set</tt> of <tt>URN</tt> instances.  This  is the primary constructor that establishes all of the class's  invariants, does any necessary parameter validation, etc.
 * @param index the index of the file referenced in the response
 * @param size the size of the file (in bytes)
 * @param name the name of the file
 * @param metadata the string of metadata associated with the file
 * @param urns the <tt>Set</tt> of <tt>URN</tt> instances associatedwith the file
 * @param doc the <tt>LimeXMLDocument</tt> instance associated withthe file
 */
public Response(long index,long size,String name,String metadata,Set urns,LimeXMLDocument doc,byte[] rawMeta){
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IllegalArgumentException(""String_Node_Str"" + index);
  if ((size & 0xFFFFFFFF00000000L) != 0)   throw new IllegalArgumentException(""String_Node_Str"" + size);
  this.index=index;
  this.size=size;
  if (name == null) {
    this.name=""String_Node_Str"";
  }
 else {
    this.name=name;
  }
  this.nameBytes=this.name.getBytes();
  if (urns == null) {
    this.urns=DataUtils.EMPTY_SET;
  }
 else {
    this.urns=Collections.unmodifiableSet(urns);
  }
  if (rawMeta != null)   this.extBytes=rawMeta;
 else   this.extBytes=createExtBytes(this.urns);
  if (((metadata == null) || (metadata.equals(""String_Node_Str""))) && (doc != null)) {
    this.metadata=extractMetadata(doc);
  }
 else   if (metadata == null) {
    this.metadata=""String_Node_Str"";
  }
 else {
    this.metadata=metadata.trim();
  }
  Assert.that(this.metadata != null,""String_Node_Str"");
  try {
    this.metaBytes=this.metadata.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException ueex) {
    this.metaBytes=this.metadata.getBytes();
  }
  this.document=doc;
}","/** 
 * Overloaded constructor that allows the creation of Responses with meta-data and a <tt>Set</tt> of <tt>URN</tt> instances.  This  is the primary constructor that establishes all of the class's  invariants, does any necessary parameter validation, etc.
 * @param index the index of the file referenced in the response
 * @param size the size of the file (in bytes)
 * @param name the name of the file
 * @param metadata the string of metadata associated with the file
 * @param urns the <tt>Set</tt> of <tt>URN</tt> instances associatedwith the file
 * @param doc the <tt>LimeXMLDocument</tt> instance associated withthe file
 */
public Response(long index,long size,String name,String metadata,Set urns,LimeXMLDocument doc,byte[] rawMeta){
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IllegalArgumentException(""String_Node_Str"" + index);
  if (size > Integer.MAX_VALUE || size < 0)   throw new IllegalArgumentException(""String_Node_Str"" + size);
  this.index=index;
  this.size=size;
  if (name == null) {
    this.name=""String_Node_Str"";
  }
 else {
    this.name=name;
  }
  this.nameBytes=this.name.getBytes();
  if (urns == null) {
    this.urns=DataUtils.EMPTY_SET;
  }
 else {
    this.urns=Collections.unmodifiableSet(urns);
  }
  if (rawMeta != null)   this.extBytes=rawMeta;
 else   this.extBytes=createExtBytes(this.urns);
  if (((metadata == null) || (metadata.equals(""String_Node_Str""))) && (doc != null)) {
    this.metadata=extractMetadata(doc);
  }
 else   if (metadata == null) {
    this.metadata=""String_Node_Str"";
  }
 else {
    this.metadata=metadata.trim();
  }
  Assert.that(this.metadata != null,""String_Node_Str"");
  try {
    this.metaBytes=this.metadata.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException ueex) {
    this.metaBytes=this.metadata.getBytes();
  }
  this.document=doc;
}",0.9856485242350392
4623,"/** 
 * Sends the <tt>Message</tt> via UDP to the port and IP address specified. This method should not be called if the client is not GUESS enabled.
 * @param msg  the <tt>Message</tt> to send
 * @param ip   the <tt>InetAddress</tt> to send to
 * @param port the port to send to
 */
public synchronized void send(Message msg,InetAddress ip,int port) throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    msg.write(baos);
  }
 catch (  IOException e) {
    ErrorService.error(e);
    return;
  }
  byte[] data=baos.toByteArray();
  DatagramPacket dg=new DatagramPacket(data,data.length,ip,port);
synchronized (_sendLock) {
    if (_socket == null)     return;
    _socket.send(dg);
  }
}","/** 
 * Sends the <tt>Message</tt> via UDP to the port and IP address specified. This method should not be called if the client is not GUESS enabled.
 * @param msg  the <tt>Message</tt> to send
 * @param ip   the <tt>InetAddress</tt> to send to
 * @param port the port to send to
 */
public synchronized void send(Message msg,InetAddress ip,int port) throws IOException {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    msg.write(baos);
  }
 catch (  IOException e) {
    ErrorService.error(e);
    return;
  }
  byte[] data=baos.toByteArray();
  DatagramPacket dg=new DatagramPacket(data,data.length,ip,port);
synchronized (_sendLock) {
    if (_socket == null)     return;
    try {
      _socket.send(dg);
    }
 catch (    IOException ioe) {
      if (""String_Node_Str"".equals(ioe.getMessage()))       return;
      throw ioe;
    }
  }
}",0.91183879093199
4624,"private void requestFromOneHost(GWebCacheRequest request,BootstrapServer server){
  if (request == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (server == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  BufferedReader in=null;
  try {
    URL url=new URL(server.getURL().toString() + ""String_Node_Str"" + CommonUtils.QHD_VENDOR_NAME+ ""String_Node_Str""+ URLEncoder.encode(CommonUtils.getLimeWireVersion())+ ""String_Node_Str""+ request.parameters());
    HttpURLConnection connection=(HttpURLConnection)url.openConnection();
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",CommonUtils.getHttpServer());
    connection.setRequestProperty(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
    try {
      in=new BufferedReader(new InputStreamReader(connection.getInputStream(),""String_Node_Str""));
    }
 catch (    NullPointerException e) {
      throw new IOException(""String_Node_Str"");
    }
    boolean firstLine=true;
    boolean errors=false;
    while (true) {
      String line=in.readLine();
      if (line == null)       break;
      if (firstLine && StringUtils.startsWithIgnoreCase(line,""String_Node_Str"")) {
        request.handleError(server);
        errors=true;
      }
 else {
        request.handleResponseData(server,line);
      }
      firstLine=false;
    }
    if (!errors)     _lastConnectable=server;
  }
 catch (  IOException ioe) {
    request.handleError(server);
  }
 finally {
    if (in != null)     try {
      in.close();
    }
 catch (    IOException e) {
    }
  }
}","private void requestFromOneHost(GWebCacheRequest request,BootstrapServer server){
  if (request == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (server == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  BufferedReader in=null;
  try {
    URL url=new URL(server.getURL().toString() + ""String_Node_Str"" + CommonUtils.QHD_VENDOR_NAME+ ""String_Node_Str""+ URLEncoder.encode(CommonUtils.getLimeWireVersion())+ ""String_Node_Str""+ request.parameters());
    HttpURLConnection connection=(HttpURLConnection)url.openConnection();
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",CommonUtils.getHttpServer());
    connection.setRequestProperty(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
    try {
      in=new BufferedReader(new InputStreamReader(connection.getInputStream(),""String_Node_Str""));
    }
 catch (    NullPointerException e) {
      throw new IOException(""String_Node_Str"");
    }
catch (    ArrayIndexOutOfBoundsException e) {
      throw new IOException(""String_Node_Str"");
    }
    boolean firstLine=true;
    boolean errors=false;
    while (true) {
      String line=in.readLine();
      if (line == null)       break;
      if (firstLine && StringUtils.startsWithIgnoreCase(line,""String_Node_Str"")) {
        request.handleError(server);
        errors=true;
      }
 else {
        request.handleResponseData(server,line);
      }
      firstLine=false;
    }
    if (!errors)     _lastConnectable=server;
  }
 catch (  IOException ioe) {
    request.handleError(server);
  }
 finally {
    if (in != null)     try {
      in.close();
    }
 catch (    IOException e) {
    }
  }
}",0.6644437708396483
4625,"/** 
 * Sends a push request for the given file.  Returns false iff no push could be sent, i.e., because no routing entry exists. That generally means you shouldn't send any more pushes for this file.
 * @param file the <tt>RemoteFileDesc</tt> constructed from the query hit, containing data about the host we're pushing to
 * @return <tt>true</tt> if the push was successfully sent, otherwise<tt>false</tt>
 */
public boolean sendPush(RemoteFileDesc file){
  debug(""String_Node_Str"");
  Set proxies=file.getPushProxies();
  if (!proxies.isEmpty()) {
    debug(""String_Node_Str"");
    boolean requestSuccessful=false;
    final String requestString=""String_Node_Str"" + Base32.encode(file.getClientGUID());
    final String nodeString=""String_Node_Str"";
    final String nodeValue=NetworkUtils.ip2string(RouterService.getAddress()) + ""String_Node_Str"" + RouterService.getPort();
    Iterator iter=proxies.iterator();
    while (iter.hasNext() && !requestSuccessful) {
      PushProxyInterface ppi=(PushProxyInterface)iter.next();
      try {
        String ip=ppi.getPushProxyAddress().getHostName();
        int port=ppi.getPushProxyPort();
        URL url=new URL(""String_Node_Str"",ip,port,requestString);
        HttpURLConnection connection=(HttpURLConnection)url.openConnection();
        connection.setUseCaches(false);
        connection.setRequestProperty(nodeString,nodeValue);
        requestSuccessful=(connection.getResponseCode() == 202);
        connection.disconnect();
      }
 catch (      MalformedURLException url) {
        ErrorService.error(url);
      }
catch (      IOException ioe) {
      }
    }
    if (requestSuccessful)     return requestSuccessful;
  }
  boolean multicast=file.isReplyToMulticast();
  byte ttl=multicast ? 1 : ConnectionSettings.TTL.getValue();
  byte[] address=multicast ? RouterService.getNonForcedAddress() : RouterService.getAddress();
  int port=multicast ? RouterService.getNonForcedPort() : RouterService.getPort();
  PushRequest pr=new PushRequest(GUID.makeGuid(),ttl,file.getClientGUID(),file.getIndex(),address,port);
  try {
    if (file.isReplyToMulticast())     router.sendMulticastPushRequest(pr);
 else     router.sendPushRequest(pr);
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}","/** 
 * Sends a push request for the given file.  Returns false iff no push could be sent, i.e., because no routing entry exists. That generally means you shouldn't send any more pushes for this file.
 * @param file the <tt>RemoteFileDesc</tt> constructed from the query hit, containing data about the host we're pushing to
 * @return <tt>true</tt> if the push was successfully sent, otherwise<tt>false</tt>
 */
public boolean sendPush(RemoteFileDesc file){
  debug(""String_Node_Str"");
  if (file.isReplyToMulticast()) {
    PushRequest pr=new PushRequest(GUID.makeGuid(),(byte)1,file.getClientGUID(),file.getIndex(),RouterService.getNonForcedAddress(),RouterService.getNonForcedPort());
    router.sendMulticastPushRequest(pr);
    return true;
  }
  Set proxies=file.getPushProxies();
  if (!proxies.isEmpty()) {
    debug(""String_Node_Str"");
    boolean requestSuccessful=false;
    final String requestString=""String_Node_Str"" + Base32.encode(file.getClientGUID());
    final String nodeString=""String_Node_Str"";
    final String nodeValue=NetworkUtils.ip2string(RouterService.getAddress()) + ""String_Node_Str"" + RouterService.getPort();
    Iterator iter=proxies.iterator();
    while (iter.hasNext() && !requestSuccessful) {
      PushProxyInterface ppi=(PushProxyInterface)iter.next();
      try {
        String ip=ppi.getPushProxyAddress().getHostName();
        int port=ppi.getPushProxyPort();
        URL url=new URL(""String_Node_Str"",ip,port,requestString);
        HttpURLConnection connection=(HttpURLConnection)url.openConnection();
        connection.setUseCaches(false);
        connection.setRequestProperty(nodeString,nodeValue);
        requestSuccessful=(connection.getResponseCode() == 202);
        connection.disconnect();
      }
 catch (      MalformedURLException url) {
        ErrorService.error(url);
      }
catch (      IOException ioe) {
      }
    }
    if (requestSuccessful)     return requestSuccessful;
  }
  PushRequest pr=new PushRequest(GUID.makeGuid(),ConnectionSettings.TTL.getValue(),file.getClientGUID(),file.getIndex(),RouterService.getAddress(),RouterService.getPort());
  try {
    router.sendPushRequest(pr);
  }
 catch (  IOException e) {
    return false;
  }
  return true;
}",0.8378197997775306
4626,"/** 
 * This method calculates the quality of service for a given host.  The calculation is some function of whether or not the host is busy, whether or not the host has ever received an incoming connection, etc. Moved this code from SearchView to here permanently, so we avoid duplication.  It makes sense from a data point of view, but this method isn't really essential an essential method.
 * @return a int from -1 to 3, with -1 for ""never work"" and 3 for ""alwayswork"".  Typically a return value of N means N+1 stars will be displayed in the GUI.
 * @param iFirewalled switch to indicate if the client is firewalled ornot.  See RouterService.acceptingIncomingConnection or Acceptor for details.  
 */
public int calculateQualityOfService(boolean iFirewalled){
  final int YES=1;
  final int MAYBE=0;
  final int NO=-1;
  int busy;
  try {
    busy=this.getIsBusy() ? YES : NO;
  }
 catch (  BadPacketException e) {
    busy=MAYBE;
  }
  boolean isMCastReply;
  try {
    isMCastReply=this.isReplyToMulticastQuery();
  }
 catch (  BadPacketException e) {
    isMCastReply=false;
  }
  int heFirewalled;
  if (isMCastReply) {
    iFirewalled=false;
    heFirewalled=NO;
  }
 else   if (NetworkUtils.isPrivateAddress(this.getIPBytes())) {
    heFirewalled=YES;
  }
 else {
    try {
      heFirewalled=this.getNeedsPush() ? YES : NO;
    }
 catch (    BadPacketException e) {
      heFirewalled=MAYBE;
    }
  }
  if (Arrays.equals(_address,RouterService.getAddress())) {
    return 3;
  }
 else   if (isMCastReply) {
    return 4;
  }
 else   if (iFirewalled && heFirewalled == YES) {
    return -1;
  }
 else   if (busy == MAYBE || heFirewalled == MAYBE) {
    return 0;
  }
 else   if (busy == YES) {
    Assert.that(heFirewalled == NO || !iFirewalled);
    if (heFirewalled == YES)     return 0;
 else     return 1;
  }
 else   if (busy == NO) {
    Assert.that(heFirewalled == NO || !iFirewalled);
    if (heFirewalled == YES)     return 2;
 else     return 3;
  }
 else {
    Assert.that(false,""String_Node_Str"");
    return -1;
  }
}","/** 
 * This method calculates the quality of service for a given host.  The calculation is some function of whether or not the host is busy, whether or not the host has ever received an incoming connection, etc. Moved this code from SearchView to here permanently, so we avoid duplication.  It makes sense from a data point of view, but this method isn't really essential an essential method.
 * @return a int from -1 to 3, with -1 for ""never work"" and 3 for ""alwayswork"".  Typically a return value of N means N+1 stars will be displayed in the GUI.
 * @param iFirewalled switch to indicate if the client is firewalled ornot.  See RouterService.acceptingIncomingConnection or Acceptor for details.  
 */
public int calculateQualityOfService(boolean iFirewalled){
  final int YES=1;
  final int MAYBE=0;
  final int NO=-1;
  int busy;
  try {
    busy=this.getIsBusy() ? YES : NO;
  }
 catch (  BadPacketException e) {
    busy=MAYBE;
  }
  boolean isMCastReply;
  try {
    isMCastReply=this.isReplyToMulticastQuery();
  }
 catch (  BadPacketException e) {
    isMCastReply=false;
  }
  int heFirewalled;
  if (isMCastReply) {
    iFirewalled=false;
    heFirewalled=NO;
  }
 else   if (NetworkUtils.isPrivateAddress(this.getIPBytes())) {
    heFirewalled=YES;
  }
 else {
    try {
      heFirewalled=this.getNeedsPush() ? YES : NO;
    }
 catch (    BadPacketException e) {
      heFirewalled=MAYBE;
    }
  }
  boolean hasPushProxies=false;
  if ((this.getPushProxies() != null) && (this.getPushProxies().size() > 1))   hasPushProxies=true;
  if (Arrays.equals(_address,RouterService.getAddress())) {
    return 3;
  }
 else   if (isMCastReply) {
    return 4;
  }
 else   if (iFirewalled && heFirewalled == YES) {
    return -1;
  }
 else   if (busy == MAYBE || heFirewalled == MAYBE) {
    return 0;
  }
 else   if (busy == YES) {
    Assert.that(heFirewalled == NO || !iFirewalled);
    if (heFirewalled == YES)     return 0;
 else     return 1;
  }
 else   if (busy == NO) {
    Assert.that(heFirewalled == NO || !iFirewalled);
    if (heFirewalled == YES && !hasPushProxies)     return 2;
 else     return 3;
  }
 else {
    Assert.that(false,""String_Node_Str"");
    return -1;
  }
}",0.9643278998346326
4627,"/** 
 * Responds to the handshake from the host on the other end of the connection, till a conclusion reaches. Handshaking may involve multiple steps.
 * @exception NoGnutellaOkException one of the participants respondedwith an error code other than 200 OK (possibly after several rounds of 401's)
 * @exception IOException any other error.  May wish to retry at 0.4
 */
private void concludeIncomingHandshake() throws IOException {
  for (int i=0; i < MAX_HANDSHAKE_ATTEMPTS; i++) {
    boolean isCrawler=_headers.isCrawler();
    HandshakeResponse ourResponse=RESPONSE_HEADERS.respond(_headers,false);
    writeLine(GNUTELLA_06 + ""String_Node_Str"" + ourResponse.getStatusLine()+ CRLF);
    sendHeaders(ourResponse.props());
    int code=ourResponse.getStatusCode();
    if ((code != HandshakeResponse.OK) && (code != HandshakeResponse.UNAUTHORIZED_CODE)) {
      if (code == HandshakeResponse.SLOTS_FULL) {
        throw NoGnutellaOkException.CLIENT_REJECT;
      }
 else {
        throw NoGnutellaOkException.createClientUnknown(code);
      }
    }
    String connectLine;
    if (ourResponse.getStatusCode() == HandshakeResponse.UNAUTHORIZED_CODE) {
      connectLine=readLine(USER_INPUT_WAIT_TIME);
      readHeaders(USER_INPUT_WAIT_TIME);
      _headers=HandshakeResponse.createResponse(HEADERS_READ);
    }
 else {
      connectLine=readLine();
      readHeaders();
    }
    if (!connectLine.startsWith(GNUTELLA_06))     throw new IOException(""String_Node_Str"");
    HandshakeResponse theirResponse=HandshakeResponse.createResponse(connectLine.substring(GNUTELLA_06.length()).trim(),HEADERS_READ);
    code=ourResponse.getStatusCode();
    if (code == HandshakeResponse.OK && theirResponse.getStatusCode() == HandshakeResponse.OK) {
      if (isCrawler) {
        throw new IOException(""String_Node_Str"");
      }
      return;
    }
 else {
      Assert.that(code == HandshakeResponse.UNAUTHORIZED_CODE,""String_Node_Str"" + code);
      if (theirResponse.getStatusCode() == HandshakeResponse.OK)       continue;
    }
    throw NoGnutellaOkException.createServerUnknown(theirResponse.getStatusCode());
  }
  throw NoGnutellaOkException.UNRESOLVED_CLIENT;
}","/** 
 * Responds to the handshake from the host on the other end of the connection, till a conclusion reaches. Handshaking may involve multiple steps.
 * @exception NoGnutellaOkException one of the participants respondedwith an error code other than 200 OK (possibly after several rounds of 401's)
 * @exception IOException any other error.  May wish to retry at 0.4
 */
private void concludeIncomingHandshake() throws IOException {
  for (int i=0; i < MAX_HANDSHAKE_ATTEMPTS; i++) {
    boolean isCrawler=_headers.isCrawler();
    HandshakeResponse ourResponse=RESPONSE_HEADERS.respond(_headers,false);
    writeLine(GNUTELLA_06 + ""String_Node_Str"" + ourResponse.getStatusLine()+ CRLF);
    sendHeaders(ourResponse.props());
    int code=ourResponse.getStatusCode();
    if ((code != HandshakeResponse.OK) && (code != HandshakeResponse.UNAUTHORIZED_CODE)) {
      if (code == HandshakeResponse.SLOTS_FULL) {
        throw NoGnutellaOkException.CLIENT_REJECT;
      }
 else {
        throw NoGnutellaOkException.createClientUnknown(code);
      }
    }
    String connectLine;
    if (ourResponse.getStatusCode() == HandshakeResponse.UNAUTHORIZED_CODE) {
      connectLine=readLine(USER_INPUT_WAIT_TIME);
      readHeaders(USER_INPUT_WAIT_TIME);
      _headers=HandshakeResponse.createResponse(HEADERS_READ);
    }
 else {
      connectLine=readLine();
      readHeaders();
    }
    if (!connectLine.startsWith(GNUTELLA_06))     throw new IOException(""String_Node_Str"");
    HandshakeResponse theirResponse=HandshakeResponse.createResponse(connectLine.substring(GNUTELLA_06.length()).trim(),HEADERS_READ);
    code=ourResponse.getStatusCode();
    if (code == HandshakeResponse.OK) {
      if (theirResponse.getStatusCode() == HandshakeResponse.OK) {
        if (isCrawler) {
          throw new IOException(""String_Node_Str"");
        }
        return;
      }
    }
 else {
      Assert.that(code == HandshakeResponse.UNAUTHORIZED_CODE,""String_Node_Str"" + code);
      if (theirResponse.getStatusCode() == HandshakeResponse.OK)       continue;
    }
    throw NoGnutellaOkException.createServerUnknown(theirResponse.getStatusCode());
  }
  throw NoGnutellaOkException.UNRESOLVED_CLIENT;
}",0.9889807162534436
4628,"/** 
 * Like addDownload, but doesn't call allowAddition(..). 
 * @return true, since download always allowed 
 */
protected final synchronized boolean addDownloadForced(RemoteFileDesc rfd,boolean cache){
  for (int i=0; i < allFiles.length; i++) {
    if (rfd.equals(allFiles[i]))     return true;
  }
  if (buckets != null)   buckets.add(rfd);
  if (cache) {
    RemoteFileDesc[] newAllFiles=new RemoteFileDesc[allFiles.length + 1];
    System.arraycopy(allFiles,0,newAllFiles,0,allFiles.length);
    newAllFiles[newAllFiles.length - 1]=rfd;
    allFiles=newAllFiles;
  }
  if ((state == Downloader.WAITING_FOR_RETRY) || (state == Downloader.WAITING_FOR_RESULTS) || (state == Downloader.GAVE_UP))   reqLock.release();
 else   this.notify();
  return true;
}","/** 
 * Like addDownload, but doesn't call allowAddition(..). 
 * @return true, since download always allowed or silently ignored 
 */
protected final synchronized boolean addDownloadForced(RemoteFileDesc rfd,boolean cache){
  if (NetworkUtils.isMe(rfd.getHost(),rfd.getPort()))   return true;
  for (int i=0; i < allFiles.length; i++) {
    if (rfd.equals(allFiles[i]))     return true;
  }
  if (buckets != null)   buckets.add(rfd);
  if (cache) {
    RemoteFileDesc[] newAllFiles=new RemoteFileDesc[allFiles.length + 1];
    System.arraycopy(allFiles,0,newAllFiles,0,allFiles.length);
    newAllFiles[newAllFiles.length - 1]=rfd;
    allFiles=newAllFiles;
  }
  if ((state == Downloader.WAITING_FOR_RETRY) || (state == Downloader.WAITING_FOR_RESULTS) || (state == Downloader.GAVE_UP))   reqLock.release();
 else   this.notify();
  return true;
}",0.9446172993154948
4629,"/** 
 * If host is not a valid host address, returns false. Otherwise, returns true if connecting to host:port would connect to the manager's listening port.
 * @return <tt>true</tt> if the specified host/port combo is this servent,otherwise <tt>false</tt>.
 */
public static boolean isMe(String host,int port){
  byte[] cIP;
  try {
    cIP=InetAddress.getByName(host).getAddress();
  }
 catch (  IOException e) {
    return false;
  }
  if (cIP[0] == (byte)127) {
    return port == RouterService.getPort();
  }
 else {
    byte[] managerIP=RouterService.getAddress();
    return port == RouterService.getPort() && Arrays.equals(cIP,managerIP);
  }
}","/** 
 * If host is not a valid host address, returns false. Otherwise, returns true if connecting to host:port would connect to this servent's listening port.
 * @return <tt>true</tt> if the specified host/port combo is this servent,otherwise <tt>false</tt>.
 */
public static boolean isMe(String host,int port){
  byte[] cIP;
  try {
    cIP=InetAddress.getByName(host).getAddress();
  }
 catch (  IOException e) {
    return false;
  }
  if (cIP[0] == (byte)127) {
    return port == RouterService.getPort();
  }
 else {
    byte[] managerIP=RouterService.getAddress();
    return port == RouterService.getPort() && Arrays.equals(cIP,managerIP);
  }
}",0.98544061302682
4630,"public String toString(){
  return ""String_Node_Str"" + _host + ""String_Node_Str""+ _port;
}","public String toString(){
  return ""String_Node_Str"" + _host + ""String_Node_Str""+ _port+ ""String_Node_Str""+ getUserAgent();
}",0.8372093023255814
4631,"/** 
 * Respond to the query request.  Implementations typically will either do nothing (if they don't think a response is appropriate) or call sendQueryReply(QueryReply). This method is called from the default handleQueryRequest.
 */
protected abstract void respondToQueryRequest(QueryRequest queryRequest,byte[] clientGUID);","/** 
 * Respond to the query request.  Implementations typically will either do nothing (if they don't think a response is appropriate) or call sendQueryReply(QueryReply). This method is called from the default handleQueryRequest.
 */
protected abstract boolean respondToQueryRequest(QueryRequest queryRequest,byte[] clientGUID);",0.983206106870229
4632,"/** 
 * Forwards the query request to any leaf connections.
 * @param request the query to forward
 * @param handler the <tt>ReplyHandler</tt> that responds to therequest appropriately
 * @param manager the <tt>ConnectionManager</tt> that providesaccess to any leaf connections that we should forward to
 */
public final void forwardQueryRequestToLeaves(QueryRequest query,ReplyHandler handler){
  if (!RouterService.isSupernode())   return;
  List list=_manager.getInitializedClientConnections2();
  List hitConnections=new ArrayList();
  for (int i=0; i < list.size(); i++) {
    ManagedConnection mc=(ManagedConnection)list.get(i);
    if (mc == handler)     continue;
    if (mc.hitsQueryRouteTable(query)) {
      hitConnections.add(mc);
    }
  }
  if (list.size() > 8 && (double)hitConnections.size() / (double)list.size() > .8) {
    hitConnections=hitConnections.subList(0,hitConnections.size() / 4);
  }
  int notSent=list.size() - hitConnections.size();
  RoutedQueryStat.LEAF_DROP.addData(notSent);
  for (int i=0; i < hitConnections.size(); i++) {
    ManagedConnection mc=(ManagedConnection)list.get(i);
    if (mc == handler)     continue;
    sendQueryRequest(query,mc,handler);
    RoutedQueryStat.LEAF_SEND.incrementStat();
  }
}","/** 
 * Forwards the query request to any leaf connections.
 * @param request the query to forward
 * @param handler the <tt>ReplyHandler</tt> that responds to therequest appropriately
 * @param manager the <tt>ConnectionManager</tt> that providesaccess to any leaf connections that we should forward to
 */
public final void forwardQueryRequestToLeaves(QueryRequest query,ReplyHandler handler){
  if (!RouterService.isSupernode())   return;
  List list=_manager.getInitializedClientConnections2();
  List hitConnections=new ArrayList();
  for (int i=0; i < list.size(); i++) {
    ManagedConnection mc=(ManagedConnection)list.get(i);
    if (mc == handler)     continue;
    if (mc.hitsQueryRouteTable(query)) {
      hitConnections.add(mc);
    }
  }
  if (list.size() > 8 && (double)hitConnections.size() / (double)list.size() > .8) {
    hitConnections=hitConnections.subList(0,hitConnections.size() / 4);
  }
  int notSent=list.size() - hitConnections.size();
  RoutedQueryStat.LEAF_DROP.addData(notSent);
  for (int i=0; i < hitConnections.size(); i++) {
    ManagedConnection mc=(ManagedConnection)hitConnections.get(i);
    sendQueryRequest(query,mc,handler);
    RoutedQueryStat.LEAF_SEND.incrementStat();
  }
}",0.977705715443859
4633,"protected void respondToQueryRequest(QueryRequest queryRequest,byte[] clientGUID){
  Response[] responses=_fileManager.query(queryRequest);
  if (RouterService.isShieldedLeaf() && queryRequest.isTCP()) {
    if (responses != null && responses.length > 0)     RoutedQueryStat.LEAF_HIT.incrementStat();
 else     RoutedQueryStat.LEAF_FALSE_POSITIVE.incrementStat();
  }
  sendResponses(responses,queryRequest,clientGUID);
}","protected boolean respondToQueryRequest(QueryRequest queryRequest,byte[] clientGUID){
  Response[] responses=_fileManager.query(queryRequest);
  if (RouterService.isShieldedLeaf() && queryRequest.isTCP()) {
    if (responses != null && responses.length > 0)     RoutedQueryStat.LEAF_HIT.incrementStat();
 else     RoutedQueryStat.LEAF_FALSE_POSITIVE.incrementStat();
  }
  return sendResponses(responses,queryRequest,clientGUID);
}",0.9788732394366196
4634,"public void sendResponses(Response[] responses,QueryRequest query,byte[] clientGUID){
  if ((responses == null) || ((responses.length < 1)))   return;
  if (query.desiresOutOfBandReplies() && (query.getHops() > 1) && !query.isFirewalledSource()&& RouterService.isGUESSCapable()&& RouterService.acceptedIncomingConnection()&& !RouterService.getUploadManager().isBusy()) {
    if (bufferResponsesForLaterDelivery(query,responses)) {
      InetAddress addr=null;
      try {
        addr=InetAddress.getByName(query.getReplyAddress());
      }
 catch (      UnknownHostException uhe) {
        return;
      }
      int port=query.getReplyPort();
      try {
        int resultCount=(responses.length > 255) ? 255 : responses.length;
        ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(query.getGUID()),resultCount);
        UDPService.instance().send(vm,addr,port);
      }
 catch (      BadPacketException bpe) {
        ErrorService.error(bpe);
      }
    }
    return;
  }
  Iterator iterator=responsesToQueryReplies(responses,query);
  try {
    while (iterator.hasNext()) {
      QueryReply queryReply=(QueryReply)iterator.next();
      sendQueryReply(query,queryReply);
    }
  }
 catch (  IOException e) {
  }
}","public boolean sendResponses(Response[] responses,QueryRequest query,byte[] clientGUID){
  if ((responses == null) || ((responses.length < 1)))   return false;
  if (query.desiresOutOfBandReplies() && (query.getHops() > 1) && !query.isFirewalledSource()&& RouterService.isGUESSCapable()&& RouterService.acceptedIncomingConnection()&& !RouterService.getUploadManager().isBusy()) {
    if (bufferResponsesForLaterDelivery(query,responses)) {
      InetAddress addr=null;
      try {
        addr=InetAddress.getByName(query.getReplyAddress());
      }
 catch (      UnknownHostException uhe) {
        return false;
      }
      int port=query.getReplyPort();
      try {
        int resultCount=(responses.length > 255) ? 255 : responses.length;
        ReplyNumberVendorMessage vm=new ReplyNumberVendorMessage(new GUID(query.getGUID()),resultCount);
        UDPService.instance().send(vm,addr,port);
      }
 catch (      BadPacketException bpe) {
        ErrorService.error(bpe);
      }
      return true;
    }
    return false;
  }
  Iterator iterator=responsesToQueryReplies(responses,query);
  try {
    while (iterator.hasNext()) {
      QueryReply queryReply=(QueryReply)iterator.next();
      sendQueryReply(query,queryReply);
    }
  }
 catch (  IOException e) {
  }
  return true;
}",0.9751283063560996
4635,"public boolean equals(Object o){
  MiniRemoteFileDesc other=(MiniRemoteFileDesc)o;
  if ((((other.getIndex() == 0) && ((other.getFile() == null) || (other.getFile().equals(""String_Node_Str"")))) || ((getIndex() == 0) && ((getFile() == null) || (getFile().equals(""String_Node_Str""))))) && Arrays.equals(clientGUID,other.getGUID()))   return true;
 else   if (index == other.getIndex() && file.equals(other.getFile()) && Arrays.equals(clientGUID,other.getGUID()))   return true;
  return false;
}","public boolean equals(Object o){
  MiniRemoteFileDesc other=(MiniRemoteFileDesc)o;
  if (Arrays.equals(clientGUID,other.getGUID()))   return true;
  return false;
}",0.4992389649923896
4636,"/** 
 * Factory method for instantiating individual responses from an <tt>InputStream</tt> instance.
 * @param is the <tt>InputStream</tt> to read from
 * @throws <tt>IOException</tt> if there are any problems reading fromor writing to the stream
 */
public static Response createFromStream(InputStream is) throws IOException {
  long index=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  long size=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int c;
  while ((c=is.read()) != 0) {
    baos.write(c);
  }
  String name=new String(baos.toByteArray());
  if (name.length() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  baos.reset();
  while ((c=is.read()) != 0) {
    baos.write(c);
  }
  byte[] rawMeta=baos.toByteArray();
  String betweenNulls=new String(rawMeta);
  if (betweenNulls == null || betweenNulls.equals(""String_Node_Str"")) {
    if (is.available() < 16) {
      throw new IOException(""String_Node_Str"");
    }
    return new Response(index,size,name);
  }
 else {
    StringTokenizer stok=new StringTokenizer(betweenNulls,""String_Node_Str"");
    Set urns=null;
    String metaString=null;
    while (stok.hasMoreTokens()) {
      String ext=stok.nextToken();
      if (URN.isUrn(ext)) {
        try {
          URN urn=URN.createSHA1Urn(ext);
          if (urns == null)           urns=new HashSet();
          urns.add(urn);
        }
 catch (        IOException e) {
          continue;
        }
      }
 else {
        metaString=createXmlString(name,ext);
      }
    }
    return new Response(index,size,name,metaString,urns,null,rawMeta);
  }
}","/** 
 * Factory method for instantiating individual responses from an <tt>InputStream</tt> instance.
 * @param is the <tt>InputStream</tt> to read from
 * @throws <tt>IOException</tt> if there are any problems reading fromor writing to the stream
 */
public static Response createFromStream(InputStream is) throws IOException {
  long index=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  long size=ByteOrder.ubytes2long(ByteOrder.leb2int(is));
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IOException(""String_Node_Str"" + index);
  if ((size & 0xFFFFFFFF00000000L) != 0)   throw new IOException(""String_Node_Str"" + size);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  int c;
  while ((c=is.read()) != 0) {
    baos.write(c);
  }
  String name=new String(baos.toByteArray());
  if (name.length() == 0) {
    throw new IOException(""String_Node_Str"");
  }
  baos.reset();
  while ((c=is.read()) != 0) {
    baos.write(c);
  }
  byte[] rawMeta=baos.toByteArray();
  String betweenNulls=new String(rawMeta);
  if (betweenNulls == null || betweenNulls.equals(""String_Node_Str"")) {
    if (is.available() < 16) {
      throw new IOException(""String_Node_Str"");
    }
    return new Response(index,size,name);
  }
 else {
    StringTokenizer stok=new StringTokenizer(betweenNulls,""String_Node_Str"");
    Set urns=null;
    String metaString=null;
    while (stok.hasMoreTokens()) {
      String ext=stok.nextToken();
      if (URN.isUrn(ext)) {
        try {
          URN urn=URN.createSHA1Urn(ext);
          if (urns == null)           urns=new HashSet();
          urns.add(urn);
        }
 catch (        IOException e) {
          continue;
        }
      }
 else {
        metaString=createXmlString(name,ext);
      }
    }
    return new Response(index,size,name,metaString,urns,null,rawMeta);
  }
}",0.6903523974581167
4637,"/** 
 * Overloaded constructor that allows the creation of Responses with meta-data and a <tt>Set</tt> of <tt>URN</tt> instances.  This  is the primary constructor that establishes all of the class's  invariants, does any necessary parameter validation, etc.
 * @param index the index of the file referenced in the response
 * @param size the size of the file (in bytes)
 * @param name the name of the file
 * @param metadata the string of metadata associated with the file
 * @param urns the <tt>Set</tt> of <tt>URN</tt> instances associatedwith the file
 * @param doc the <tt>LimeXMLDocument</tt> instance associated withthe file
 */
public Response(long index,long size,String name,String metadata,Set urns,LimeXMLDocument doc,byte[] rawMeta){
  Assert.that((index & 0xFFFFFFFF00000000l) == 0,""String_Node_Str"");
  Assert.that((size & 0xFFFFFFFF00000000l) == 0,""String_Node_Str"");
  this.index=index;
  this.size=size;
  if (name == null) {
    this.name=""String_Node_Str"";
  }
 else {
    this.name=name;
  }
  this.nameBytes=this.name.getBytes();
  if (urns == null) {
    this.urns=EMPTY_SET;
  }
 else {
    this.urns=Collections.unmodifiableSet(urns);
  }
  if (rawMeta != null)   this.extBytes=rawMeta;
 else   this.extBytes=createExtBytes(this.urns);
  if (((metadata == null) || (metadata.equals(""String_Node_Str""))) && (doc != null)) {
    this.metadata=extractMetadata(doc);
  }
 else   if (metadata == null) {
    this.metadata=""String_Node_Str"";
  }
 else {
    this.metadata=metadata.trim();
  }
  Assert.that(this.metadata != null,""String_Node_Str"");
  try {
    this.metaBytes=this.metadata.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException ueex) {
    this.metaBytes=this.metadata.getBytes();
  }
  this.document=doc;
}","/** 
 * Overloaded constructor that allows the creation of Responses with meta-data and a <tt>Set</tt> of <tt>URN</tt> instances.  This  is the primary constructor that establishes all of the class's  invariants, does any necessary parameter validation, etc.
 * @param index the index of the file referenced in the response
 * @param size the size of the file (in bytes)
 * @param name the name of the file
 * @param metadata the string of metadata associated with the file
 * @param urns the <tt>Set</tt> of <tt>URN</tt> instances associatedwith the file
 * @param doc the <tt>LimeXMLDocument</tt> instance associated withthe file
 */
public Response(long index,long size,String name,String metadata,Set urns,LimeXMLDocument doc,byte[] rawMeta){
  if ((index & 0xFFFFFFFF00000000L) != 0)   throw new IllegalArgumentException(""String_Node_Str"" + index);
  if ((size & 0xFFFFFFFF00000000L) != 0)   throw new IllegalArgumentException(""String_Node_Str"" + size);
  this.index=index;
  this.size=size;
  if (name == null) {
    this.name=""String_Node_Str"";
  }
 else {
    this.name=name;
  }
  this.nameBytes=this.name.getBytes();
  if (urns == null) {
    this.urns=EMPTY_SET;
  }
 else {
    this.urns=Collections.unmodifiableSet(urns);
  }
  if (rawMeta != null)   this.extBytes=rawMeta;
 else   this.extBytes=createExtBytes(this.urns);
  if (((metadata == null) || (metadata.equals(""String_Node_Str""))) && (doc != null)) {
    this.metadata=extractMetadata(doc);
  }
 else   if (metadata == null) {
    this.metadata=""String_Node_Str"";
  }
 else {
    this.metadata=metadata.trim();
  }
  Assert.that(this.metadata != null,""String_Node_Str"");
  try {
    this.metaBytes=this.metadata.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException ueex) {
    this.metaBytes=this.metadata.getBytes();
  }
  this.document=doc;
}",0.9579972183588316
4638,"/** 
 * Returns the fully-qualified temporary download file for the given file/location pair.  The location of the file is determined by the INCOMPLETE_DIRECTORY property.  For example, getFile(""test.txt"", 1999) may return ""C:\Program Files\LimeWire\Incomplete\T-1999-Test.txt"".  The disk is not modified.<p> This method gives duplicate files the same temporary file, which is critical for resume and swarmed downloads.  That is, for all rfd_i and  rfd_j <pre> similar(rfd_i, rfd_j) <==> getFile(rfd_i).equals(getFile(rfd_j))<p>   </pre>
 */
public synchronized File getFile(RemoteFileDesc rfd){
  File incDir=null;
  try {
    incDir=SettingsManager.instance().getIncompleteDirectory();
  }
 catch (  java.io.FileNotFoundException fnfe) {
  }
  URN sha1=rfd.getSHA1Urn();
  if (sha1 != null) {
    File file=(File)hashes.get(sha1);
    if (file != null) {
      return file;
    }
 else {
      for (int i=1; ; i++) {
        file=new File(incDir,tempName(CommonUtils.convertFileName(rfd.getFileName()),rfd.getSize(),i));
        if (!hashes.values().contains(file))         break;
      }
      hashes.put(sha1,file);
      return file;
    }
  }
 else {
    return new File(incDir,tempName(rfd.getFileName(),rfd.getSize(),0));
  }
}","/** 
 * Returns the fully-qualified temporary download file for the given file/location pair.  The location of the file is determined by the INCOMPLETE_DIRECTORY property.  For example, getFile(""test.txt"", 1999) may return ""C:\Program Files\LimeWire\Incomplete\T-1999-Test.txt"".  The disk is not modified.<p> This method gives duplicate files the same temporary file, which is critical for resume and swarmed downloads.  That is, for all rfd_i and  rfd_j <pre> similar(rfd_i, rfd_j) <==> getFile(rfd_i).equals(getFile(rfd_j))<p>   </pre>
 */
public synchronized File getFile(RemoteFileDesc rfd){
  File incDir=null;
  try {
    incDir=SettingsManager.instance().getIncompleteDirectory();
    incDir.mkdirs();
  }
 catch (  java.io.FileNotFoundException fnfe) {
  }
  String convertedName=CommonUtils.convertFileName(rfd.getFileName());
  URN sha1=rfd.getSHA1Urn();
  if (sha1 != null) {
    File file=(File)hashes.get(sha1);
    if (file != null) {
      return file;
    }
 else {
      for (int i=1; ; i++) {
        file=new File(incDir,tempName(convertedName,rfd.getSize(),i));
        if (!hashes.values().contains(file))         break;
      }
      hashes.put(sha1,file);
      return file;
    }
  }
 else {
    return new File(incDir,tempName(convertedName,rfd.getSize(),0));
  }
}",0.94019801980198
4639,"public int writeID3DataToDisk(String fileName){
  File f=null;
  RandomAccessFile file=null;
  try {
    f=new File(fileName);
    file=new RandomAccessFile(f,""String_Node_Str"");
  }
 catch (  IOException e) {
    return LimeXMLReplyCollection.FILE_DEFECTIVE;
  }
  long length=0;
  try {
    length=file.length();
    if (length < 128)     return LimeXMLReplyCollection.FILE_DEFECTIVE;
    file.seek(length - 128);
  }
 catch (  IOException ee) {
    return LimeXMLReplyCollection.RW_ERROR;
  }
  byte[] buffer=new byte[30];
  String tag=""String_Node_Str"";
  try {
    file.readFully(buffer,0,3);
    tag=new String(buffer,0,3);
  }
 catch (  EOFException e) {
    return LimeXMLReplyCollection.RW_ERROR;
  }
catch (  IOException e) {
    return LimeXMLReplyCollection.RW_ERROR;
  }
  if (!tag.equals(""String_Node_Str"")) {
    try {
      byte[] tagBytes=""String_Node_Str"".getBytes();
      file.seek(length - 128);
      file.write(tagBytes,0,3);
    }
 catch (    Exception eee) {
      return LimeXMLReplyCollection.BAD_ID3;
    }
  }
  debug(""String_Node_Str"");
  boolean b;
  b=toFile(title_,30,file,buffer);
  if (!b)   return LimeXMLReplyCollection.FAILED_TITLE;
  b=toFile(artist_,30,file,buffer);
  if (!b)   return LimeXMLReplyCollection.FAILED_ARTIST;
  b=toFile(album_,30,file,buffer);
  if (!b)   return LimeXMLReplyCollection.FAILED_ALBUM;
  b=toFile(year_,4,file,buffer);
  if (!b)   return LimeXMLReplyCollection.FAILED_YEAR;
  b=toFile(comment_,28,file,buffer);
  if (!b)   return LimeXMLReplyCollection.FAILED_COMMENT;
  byte trackByte=(byte)-1;
  try {
    if (track_ == null || track_.equals(""String_Node_Str""))     trackByte=(byte)0;
 else     trackByte=Byte.parseByte(track_);
  }
 catch (  NumberFormatException nfe) {
    return LimeXMLReplyCollection.FAILED_TRACK;
  }
  try {
    file.write(0);
    file.write(trackByte);
  }
 catch (  IOException e) {
    return LimeXMLReplyCollection.RW_ERROR;
  }
  byte genreByte=getGenreByte();
  if (genreByte == -1) {
    return LimeXMLReplyCollection.FAILED_GENRE;
  }
  try {
    file.write(genreByte);
  }
 catch (  IOException e) {
    return LimeXMLReplyCollection.FAILED_GENRE;
  }
  try {
    file.close();
  }
 catch (  IOException ioe) {
    return LimeXMLReplyCollection.RW_ERROR;
  }
  return LimeXMLReplyCollection.NORMAL;
}","public int writeID3DataToDisk(String fileName){
  File f=null;
  RandomAccessFile file=null;
  try {
    try {
      f=new File(fileName);
      file=new RandomAccessFile(f,""String_Node_Str"");
    }
 catch (    IOException e) {
      return LimeXMLReplyCollection.FILE_DEFECTIVE;
    }
    long length=0;
    try {
      length=file.length();
      if (length < 128)       return LimeXMLReplyCollection.FILE_DEFECTIVE;
      file.seek(length - 128);
    }
 catch (    IOException ee) {
      return LimeXMLReplyCollection.RW_ERROR;
    }
    byte[] buffer=new byte[30];
    String tag=""String_Node_Str"";
    try {
      file.readFully(buffer,0,3);
      tag=new String(buffer,0,3);
    }
 catch (    EOFException e) {
      return LimeXMLReplyCollection.RW_ERROR;
    }
catch (    IOException e) {
      return LimeXMLReplyCollection.RW_ERROR;
    }
    if (!tag.equals(""String_Node_Str"")) {
      try {
        byte[] tagBytes=""String_Node_Str"".getBytes();
        file.seek(length - 128);
        file.write(tagBytes,0,3);
      }
 catch (      Exception eee) {
        return LimeXMLReplyCollection.BAD_ID3;
      }
    }
    debug(""String_Node_Str"");
    boolean b;
    b=toFile(title_,30,file,buffer);
    if (!b)     return LimeXMLReplyCollection.FAILED_TITLE;
    b=toFile(artist_,30,file,buffer);
    if (!b)     return LimeXMLReplyCollection.FAILED_ARTIST;
    b=toFile(album_,30,file,buffer);
    if (!b)     return LimeXMLReplyCollection.FAILED_ALBUM;
    b=toFile(year_,4,file,buffer);
    if (!b)     return LimeXMLReplyCollection.FAILED_YEAR;
    b=toFile(comment_,28,file,buffer);
    if (!b)     return LimeXMLReplyCollection.FAILED_COMMENT;
    byte trackByte=(byte)-1;
    try {
      if (track_ == null || track_.equals(""String_Node_Str""))       trackByte=(byte)0;
 else       trackByte=Byte.parseByte(track_);
    }
 catch (    NumberFormatException nfe) {
      return LimeXMLReplyCollection.FAILED_TRACK;
    }
    try {
      file.write(0);
      file.write(trackByte);
    }
 catch (    IOException e) {
      return LimeXMLReplyCollection.RW_ERROR;
    }
    byte genreByte=getGenreByte();
    if (genreByte == -1) {
      return LimeXMLReplyCollection.FAILED_GENRE;
    }
    try {
      file.write(genreByte);
    }
 catch (    IOException e) {
      return LimeXMLReplyCollection.FAILED_GENRE;
    }
    try {
      file.close();
    }
 catch (    IOException ioe) {
      return LimeXMLReplyCollection.RW_ERROR;
    }
    return LimeXMLReplyCollection.NORMAL;
  }
  finally {
    if (file != null) {
      try {
        file.close();
      }
 catch (      IOException ignored) {
      }
    }
  }
}",0.9300344757655647
4640,"/** 
 * An MPEG audio file is built up from smaller parts called frames, which are generally independent items. Each frame has its own header and audio data that follows. There is NO MPEG file header; therefore, you can cut any part of MPEG file and play it correctly (cut on frame boundaries!), excluding MPEG 1 Layer III frames which are often dependent on another. To read info about an MPEG file, you can find the first frame, read its header and assume that the other frames are the same. Exceptions to this are VBR (variable bit rate) and ABR (average bit rate) files. The frame header is constituted by the very first four bytes (32bits) in a frame. The first 11 bits are always set on(1) and they're called ""frame sync"". Frame CRC is optional and 16 bits long; it follows the frame header. After the CRC comes the audio data. ::EXAMPLE:: MP3 file header format (4 byte length or 32 bits) byte[4] = { -1, -5, 80, 108 }  -1 << 24  +  -5 << 16  +  80 << 08  +  108 << 0    {HdrCRC} 11111111     11101010     00110000     11000000     {0000} AAAAAAAA     AAABBCCD     EEEEFFGH     IIJJKLMM     {ZZZZ} Label, Position(bits), Description	  A (31-21) Frame sync  All bits set (1) B (20,19) MPEG Audio version ID 00 - MPEG Ver 2.5, 01 - reserved, 10 - Ver 2, 11 - Ver 1 Note: MPEG Ver 2.5 is not official; bit # 20 indicates 2.5 C (18,17) Layer description 00 - reserved, 01 - Layer III, 10 - Layer II, 11 - Layer I D    (16) Protection bit 0 - None, 1 - Protected by CRC (16bit crc follows header) E (15,12) Bitrate index, version and layer bits V1,L1 V1,L2 V1,L3 V2,L1 V2, L2 & L3 F (11,10)  G     (9) Padding bit    0 - frame not padded, 1 - frame padded with one extra slot Note: Padding is used to fit the bit rates exactly. H     (8) Private bit  0 - not private, 1 - private Note: May be freely used for other needs of an application. I   (7,6) Channel Mode 00 - Stereo, 01 - Joint stereo, 10 - Dual (Stereo), 11 - Mono J   (5,4) Mode extension (Only if Joint stereo) Used to join data; bits dynamically generated by an encoder. K     (3) Copyright 0 - Audio is not copyrighted, 1 - Audio is marked copyrighted L     (2) Original 0 - Copy of original media, 1 - Original media  M   (1,0) Emphasis 00 - none, 01 - 50/15 ms, 10 - reserved, 11 - CCIT J.17 Z (32-35) CRC  !!OPTIONAL!! Note: NOT part of header, just appended on end when needed We read in bytes from the beginning of the mp3 file looking for the 4 byte header; we can't assume it starts at byte 0 because ID3 tags may be prepended before the first valid header. The loop below strolls through buffered chunks of the file looking for the header. As an optimization, we check the first 10 bytes initially as it may contain the header; if it doesn't we then check the first 10 bytes for an ID3v2 header and fetch the tag's length, skipping those bytes leading us directly to the header. If neither are found, it's a brute force search. With each chunk, we step forward one byte at a time, and test the current byte plus the next 3 bytes for a valid mp3 header.
 * @exception java.io.IOException mp3 fileName had no valid header
 */
public MP3Info(String file) throws IOException {
  _file=file;
  int i=0;
  int pos=0;
  int adjustedEOB=0;
  int c=0;
  FileInputStream fis=null;
  byte[] buf=new byte[2048];
  try {
    fis=new FileInputStream(_file);
    c=fis.read(buf,0,buf.length);
    if ((buf[0] == 'i' || buf[0] == 'I') && (buf[1] == 'd' || buf[1] == 'D') && (buf[2] == '3')) {
      i=buf[6] << 7 | buf[7] << 7 | buf[8] << 7 | buf[9];
      if (i > 0) {
        i+=10;
      }
 else       if (i < 0) {
        i=0;
      }
    }
    endheadersearch:     do {
      if (pos < buf.length - 3) {
        adjustedEOB=c - 3;
      }
 else {
        i=0;
        adjustedEOB=c;
      }
      for (; i < adjustedEOB; i++) {
        if (buf[i] != -1 || (buf[i + 1] & 255) < 224) {
          continue;
        }
        _header=(ByteOrder.ubyte2int(buf[i + 3])) | (ByteOrder.ubyte2int(buf[i + 2]) << 8) | (ByteOrder.ubyte2int(buf[i + 1]) << 16)| (ByteOrder.ubyte2int(buf[i]) << 24);
        if ((getVersionIndex() != 1) && (getLayerIndex() != 0) && (getBitrateIndex() != 0)&& (getBitrateIndex() != 15)&& (getFrequencyIndex() != 3)&& (getEmphasisIndex() != 2)) {
          pos+=i;
          break endheadersearch;
        }
      }
      if (adjustedEOB != -1) {
        buf[0]=buf[c - 3];
        buf[1]=buf[c - 2];
        buf[2]=buf[c - 1];
      }
      pos+=c - 3;
      c=fis.read(buf,3,buf.length - 3);
    }
 while (c != -1 && pos < 20000);
    if (c == -1 || pos >= 20000) {
      _header=0;
      throw new IOException(""String_Node_Str"");
    }
    int need=(int)((adjustedEOB + 3) - (120 + 36 + i));
    if (need < 0) {
      i-=need;
      for (i=0, need=-need; need < buf.length; i++, need++) {
        buf[i]=buf[need];
      }
      c=fis.read(buf,0,buf.length);
    }
    if (getVersionIndex() == 3) {
      i+=(getModeIndex() == 3 ? 21 : 36);
    }
 else {
      i+=(getModeIndex() == 3 ? 23 : 21);
    }
switch (buf[i + 0]) {
case 88:
      if (((buf[i + 1] == 'i' || buf[i + 1] == 'I') && (buf[i + 2] == 'n' || buf[i + 2] == 'N') && (buf[i + 3] == 'g' || buf[i + 3] == 'G')))       loadXingHeader(buf,i + 4);
    break;
case 86:
  if ((buf[i + 1] == 'B' && buf[i + 2] == 'R' && buf[i + 3] == 'I'))   loadFhgHeader(buf,i + 4);
break;
}
}
 catch (Throwable t) {
throw new IOException(""String_Node_Str"" + t);
}
 finally {
try {
fis.close();
}
 catch (IOException e) {
}
}
}","/** 
 * An MPEG audio file is built up from smaller parts called frames, which are generally independent items. Each frame has its own header and audio data that follows. There is NO MPEG file header; therefore, you can cut any part of MPEG file and play it correctly (cut on frame boundaries!), excluding MPEG 1 Layer III frames which are often dependent on another. To read info about an MPEG file, you can find the first frame, read its header and assume that the other frames are the same. Exceptions to this are VBR (variable bit rate) and ABR (average bit rate) files. The frame header is constituted by the very first four bytes (32bits) in a frame. The first 11 bits are always set on(1) and they're called ""frame sync"". Frame CRC is optional and 16 bits long; it follows the frame header. After the CRC comes the audio data. ::EXAMPLE:: MP3 file header format (4 byte length or 32 bits) byte[4] = { -1, -5, 80, 108 }  -1 << 24  +  -5 << 16  +  80 << 08  +  108 << 0    {HdrCRC} 11111111     11101010     00110000     11000000     {0000} AAAAAAAA     AAABBCCD     EEEEFFGH     IIJJKLMM     {ZZZZ} Label, Position(bits), Description	  A (31-21) Frame sync  All bits set (1) B (20,19) MPEG Audio version ID 00 - MPEG Ver 2.5, 01 - reserved, 10 - Ver 2, 11 - Ver 1 Note: MPEG Ver 2.5 is not official; bit # 20 indicates 2.5 C (18,17) Layer description 00 - reserved, 01 - Layer III, 10 - Layer II, 11 - Layer I D    (16) Protection bit 0 - None, 1 - Protected by CRC (16bit crc follows header) E (15,12) Bitrate index, version and layer bits V1,L1 V1,L2 V1,L3 V2,L1 V2, L2 & L3 F (11,10)  G     (9) Padding bit    0 - frame not padded, 1 - frame padded with one extra slot Note: Padding is used to fit the bit rates exactly. H     (8) Private bit  0 - not private, 1 - private Note: May be freely used for other needs of an application. I   (7,6) Channel Mode 00 - Stereo, 01 - Joint stereo, 10 - Dual (Stereo), 11 - Mono J   (5,4) Mode extension (Only if Joint stereo) Used to join data; bits dynamically generated by an encoder. K     (3) Copyright 0 - Audio is not copyrighted, 1 - Audio is marked copyrighted L     (2) Original 0 - Copy of original media, 1 - Original media  M   (1,0) Emphasis 00 - none, 01 - 50/15 ms, 10 - reserved, 11 - CCIT J.17 Z (32-35) CRC  !!OPTIONAL!! Note: NOT part of header, just appended on end when needed We read in bytes from the beginning of the mp3 file looking for the 4 byte header; we can't assume it starts at byte 0 because ID3 tags may be prepended before the first valid header. The loop below strolls through buffered chunks of the file looking for the header. As an optimization, we check the first 10 bytes initially as it may contain the header; if it doesn't we then check the first 10 bytes for an ID3v2 header and fetch the tag's length, skipping those bytes leading us directly to the header. If neither are found, it's a brute force search. With each chunk, we step forward one byte at a time, and test the current byte plus the next 3 bytes for a valid mp3 header.
 * @exception java.io.IOException mp3 fileName had no valid header
 */
public MP3Info(String file) throws IOException {
  _file=file;
  int i=0;
  int pos=0;
  int adjustedEOB=0;
  int c=0;
  FileInputStream fis=null;
  byte[] buf=new byte[2048];
  try {
    fis=new FileInputStream(_file);
    c=fis.read(buf,0,buf.length);
    if ((buf[0] == 'i' || buf[0] == 'I') && (buf[1] == 'd' || buf[1] == 'D') && (buf[2] == '3')) {
      i=buf[6] << 7 | buf[7] << 7 | buf[8] << 7 | buf[9];
      if (i > 0) {
        i+=10;
      }
 else       if (i < 0) {
        i=0;
      }
    }
    endheadersearch:     do {
      if (pos < buf.length - 3) {
        adjustedEOB=c - 3;
      }
 else {
        i=0;
        adjustedEOB=c;
      }
      for (; i < adjustedEOB; i++) {
        if (buf[i] != -1 || (buf[i + 1] & 255) < 224) {
          continue;
        }
        _header=(ByteOrder.ubyte2int(buf[i + 3])) | (ByteOrder.ubyte2int(buf[i + 2]) << 8) | (ByteOrder.ubyte2int(buf[i + 1]) << 16)| (ByteOrder.ubyte2int(buf[i]) << 24);
        if ((getVersionIndex() != 1) && (getLayerIndex() != 0) && (getBitrateIndex() != 0)&& (getBitrateIndex() != 15)&& (getFrequencyIndex() != 3)&& (getEmphasisIndex() != 2)) {
          pos+=i;
          break endheadersearch;
        }
      }
      if (adjustedEOB != -1) {
        buf[0]=buf[c - 3];
        buf[1]=buf[c - 2];
        buf[2]=buf[c - 1];
      }
      pos+=c - 3;
      c=fis.read(buf,3,buf.length - 3);
    }
 while (c != -1 && pos < 20000);
    if (c == -1 || pos >= 20000) {
      _header=0;
      throw new IOException(""String_Node_Str"");
    }
    int need=(int)((adjustedEOB + 3) - (120 + 36 + i));
    if (need < 0) {
      i-=need;
      for (i=0, need=-need; need < buf.length; i++, need++) {
        buf[i]=buf[need];
      }
      c=fis.read(buf,0,buf.length);
    }
    if (getVersionIndex() == 3) {
      i+=(getModeIndex() == 3 ? 21 : 36);
    }
 else {
      i+=(getModeIndex() == 3 ? 23 : 21);
    }
switch (buf[i + 0]) {
case 88:
      if (((buf[i + 1] == 'i' || buf[i + 1] == 'I') && (buf[i + 2] == 'n' || buf[i + 2] == 'N') && (buf[i + 3] == 'g' || buf[i + 3] == 'G')))       loadXingHeader(buf,i + 4);
    break;
case 86:
  if ((buf[i + 1] == 'B' && buf[i + 2] == 'R' && buf[i + 3] == 'I'))   loadFhgHeader(buf,i + 4);
break;
}
}
 catch (Throwable t) {
throw new IOException(""String_Node_Str"" + t);
}
 finally {
try {
if (fis != null) fis.close();
}
 catch (IOException e) {
}
}
}",0.9984436510116268
4641,"/** 
 * There are two possible places for important document information  may be stored.  1. it may be in the root element. In which case the root variable should be set as true. In this case all the important doc info will be remembered, and any non-doc info present as attributes will be put into the hashmap <p> The other possible place is at the (only) child of the root element. If this is the node that is being passed. then root variable should be set to false. In this case. Just the doc info is grabbed. The non-doc info of a non-doc Node is not even looked at in this method. <p>  For this method to be effective, keep the following points in mind. The doc info mey be either in the root alone or in both the root and the only child of root. If it is only in root - call this method on  root, and create map on root. <p> If the doc-info is spread out b/w the root and the child. First call this method with root, then call it with child, and then  call createMap wht root. This will ensure no loss of data
 */
private void grabDocInfo(Node docElement,boolean root) throws SchemaNotFoundException, IOException {
  if (docElement == null)   throw new IOException(""String_Node_Str"");
  List attributes=LimeXMLUtils.getAttributes(docElement.getAttributes());
  int size=attributes.size();
  for (int i=0; i < size; i++) {
    Node att=(Node)attributes.get(i);
    String attName=att.getNodeName();
    String lowerAttName=attName.toLowerCase();
    if (lowerAttName.indexOf(""String_Node_Str"") >= 0)     schemaUri=att.getNodeValue();
 else     if (lowerAttName.indexOf(XML_ID_ATTRIBUTE_STRING) >= 0) {
      identifier=att.getNodeValue();
      Element e=(Element)docElement;
      e.removeAttribute(attName);
    }
 else     if (lowerAttName.indexOf(""String_Node_Str"") >= 0)     action=att.getNodeValue();
 else     if (lowerAttName.indexOf(""String_Node_Str"") >= 0) {
      Element e=(Element)docElement;
      e.removeAttribute(attName);
    }
 else {
      if (root) {
        String canonicalizedAttName=docElement.getNodeName() + XMLStringUtils.DELIMITER + att.getNodeName()+ XMLStringUtils.DELIMITER;
        fieldToValue.put(canonicalizedAttName.trim(),att.getNodeValue().trim());
      }
    }
  }
  if (schemaUri == null)   throw new SchemaNotFoundException();
}","/** 
 * There are two possible places for important document information  may be stored.  1. it may be in the root element. In which case the root variable should be set as true. In this case all the important doc info will be remembered, and any non-doc info present as attributes will be put into the hashmap <p> The other possible place is at the (only) child of the root element. If this is the node that is being passed. then root variable should be set to false. In this case. Just the doc info is grabbed. The non-doc info of a non-doc Node is not even looked at in this method. <p>  For this method to be effective, keep the following points in mind. The doc info mey be either in the root alone or in both the root and the only child of root. If it is only in root - call this method on  root, and create map on root. <p> If the doc-info is spread out b/w the root and the child. First call this method with root, then call it with child, and then  call createMap wht root. This will ensure no loss of data
 */
private void grabDocInfo(Node docElement,boolean root) throws SchemaNotFoundException, IOException {
  if (docElement == null)   throw new IOException(""String_Node_Str"");
  NamedNodeMap nnm=docElement.getAttributes();
  if (nnm == null)   throw new IOException(""String_Node_Str"");
  List attributes=LimeXMLUtils.getAttributes(nnm);
  int size=attributes.size();
  for (int i=0; i < size; i++) {
    Node att=(Node)attributes.get(i);
    String attName=att.getNodeName();
    String lowerAttName=attName.toLowerCase();
    if (lowerAttName.indexOf(""String_Node_Str"") >= 0)     schemaUri=att.getNodeValue();
 else     if (lowerAttName.indexOf(XML_ID_ATTRIBUTE_STRING) >= 0) {
      identifier=att.getNodeValue();
      Element e=(Element)docElement;
      e.removeAttribute(attName);
    }
 else     if (lowerAttName.indexOf(""String_Node_Str"") >= 0)     action=att.getNodeValue();
 else     if (lowerAttName.indexOf(""String_Node_Str"") >= 0) {
      Element e=(Element)docElement;
      e.removeAttribute(attName);
    }
 else {
      if (root) {
        String canonicalizedAttName=docElement.getNodeName() + XMLStringUtils.DELIMITER + att.getNodeName()+ XMLStringUtils.DELIMITER;
        fieldToValue.put(canonicalizedAttName.trim(),att.getNodeValue().trim());
      }
    }
  }
  if (schemaUri == null)   throw new SchemaNotFoundException();
}",0.9700366458288424
4642,"/** 
 * Returns true iff the connection is an Ultrapeer and I am a Ultrapeer, ie: if I wrote ""X-Ultrapeer: true"", this connection wrote  ""X-Ultrapeer: true"" (not necessarily in that order).  <b>Does  NOT require that QRP is enabled</b> between the two; the Ultrapeer  could be using reflector indexing, for example. 
 */
public boolean isSupernodeSupernodeConnection(){
  if (_isUltrapeer == null) {
    _isUltrapeer=new Boolean(isClientSupernodeConnection2());
  }
  return _isUltrapeer.booleanValue();
}","/** 
 * Returns true iff the connection is an Ultrapeer and I am a Ultrapeer, ie: if I wrote ""X-Ultrapeer: true"", this connection wrote  ""X-Ultrapeer: true"" (not necessarily in that order).  <b>Does  NOT require that QRP is enabled</b> between the two; the Ultrapeer  could be using reflector indexing, for example. 
 */
public boolean isSupernodeSupernodeConnection(){
  if (_isUltrapeerToUltrapeer == null) {
    _isUltrapeerToUltrapeer=new Boolean(isSupernodeSupernodeConnection2());
  }
  return _isUltrapeerToUltrapeer.booleanValue();
}",0.9541108986615678
4643,"/** 
 * Reads a message from the network and updates the appropriate statistics.
 */
private Message readAndUpdateStatistics() throws IOException, BadPacketException {
  int pCompressed=0, pUncompressed=0;
  try {
    if (isReadDeflated()) {
      pCompressed=_inflater.getTotalIn();
      pUncompressed=_inflater.getTotalOut();
    }
    Message m=Message.read(_in,HEADER_BUF,_softMax);
    if (isReadDeflated()) {
      _compressedBytesReceived=_inflater.getTotalIn();
      _bytesReceived=_inflater.getTotalOut();
      if (!CommonUtils.isJava118()) {
        CompressionStat.GNUTELLA_UNCOMPRESSED_DOWNSTREAM.addData((int)(_inflater.getTotalOut() - pUncompressed));
        CompressionStat.GNUTELLA_COMPRESSED_DOWNSTREAM.addData((int)(_inflater.getTotalIn() - pCompressed));
      }
    }
 else     if (m != null) {
      _bytesReceived+=m.getTotalLength();
    }
  }
 catch (  NullPointerException npe) {
    throw CONNECTION_CLOSED;
  }
  return m;
}","/** 
 * Reads a message from the network and updates the appropriate statistics.
 */
private Message readAndUpdateStatistics() throws IOException, BadPacketException {
  int pCompressed=0, pUncompressed=0;
  Message msg=null;
  try {
    if (isReadDeflated()) {
      pCompressed=_inflater.getTotalIn();
      pUncompressed=_inflater.getTotalOut();
    }
    msg=Message.read(_in,HEADER_BUF,_softMax);
    if (isReadDeflated()) {
      _compressedBytesReceived=_inflater.getTotalIn();
      _bytesReceived=_inflater.getTotalOut();
      if (!CommonUtils.isJava118()) {
        CompressionStat.GNUTELLA_UNCOMPRESSED_DOWNSTREAM.addData((int)(_inflater.getTotalOut() - pUncompressed));
        CompressionStat.GNUTELLA_COMPRESSED_DOWNSTREAM.addData((int)(_inflater.getTotalIn() - pCompressed));
      }
    }
 else     if (msg != null) {
      _bytesReceived+=msg.getTotalLength();
    }
  }
 catch (  NullPointerException npe) {
    throw CONNECTION_CLOSED;
  }
  return msg;
}",0.9803108808290156
4644,"/** 
 * Loads values from cache file, if available
 */
private static Map createMap(){
  try {
    ObjectInputStream ois=new ObjectInputStream(new FileInputStream(URN_CACHE_FILE));
    return (Map)ois.readObject();
  }
 catch (  Exception e) {
    return new HashMap();
  }
 finally {
    try {
      ois.close();
    }
 catch (    IOException e) {
    }
  }
}","/** 
 * Loads values from cache file, if available
 */
private static Map createMap(){
  ObjectInputStream ois=null;
  try {
    ois=new ObjectInputStream(new FileInputStream(URN_CACHE_FILE));
    return (Map)ois.readObject();
  }
 catch (  Exception e) {
    return new HashMap();
  }
 finally {
    try {
      ois.close();
    }
 catch (    IOException e) {
    }
  }
}",0.9562841530054644
4645,"/** 
 * Accepts a new upload, creating a new <tt>HTTPUploader</tt> if it successfully parses the HTTP request.  BLOCKING.
 * @param method the initial request type to use, e.g., GET or HEAD
 * @param socket the <tt>Socket</tt> that will be used for the new upload.It is assumed that the initial word of the request (e.g., ""GET"") has been consumed (e.g., by Acceptor)
 * @param forceAllow forces the UploadManager to allow all requestson this socket to take place.
 */
public void acceptUpload(final HTTPRequestMethod method,Socket socket,boolean forceAllow){
  debug(""String_Node_Str"");
  HTTPUploader uploader=null;
  try {
    int queued=-1;
    String oldFileName=""String_Node_Str"";
    HTTPRequestMethod currentMethod=method;
    StalledUploadWatchdog watchdog=new StalledUploadWatchdog();
    while (true) {
      HttpRequestLine line=parseHttpRequest(socket);
      debug(""String_Node_Str"");
      String fileName=line._fileName;
      if (uploader != null && shouldShowInGUI(uploader) && !oldFileName.equalsIgnoreCase(fileName)) {
        RouterService.getCallback().removeUpload(uploader);
      }
      removeFromList(uploader);
      uploader=new HTTPUploader(currentMethod,fileName,socket,line._index,uploader,watchdog);
      uploader.readHeader();
      debug(uploader + ""String_Node_Str"");
      boolean giveSlot=(oldFileName.equalsIgnoreCase(fileName) && queued == ACCEPTED);
      giveSlot|=forceAllow;
      queued=doSingleUpload(uploader,socket,socket.getInetAddress().getHostAddress(),line._index,giveSlot);
      oldFileName=fileName;
      if ((!line.isHTTP11() || uploader.getCloseConnection()) && queued != QUEUED)       return;
      debug(uploader + ""String_Node_Str"");
      int oldTimeout=socket.getSoTimeout();
      if (queued != QUEUED)       socket.setSoTimeout(SettingsManager.instance().getPersistentHTTPConnectionTimeout());
      String word=IOUtils.readWord(socket.getInputStream(),4);
      debug(uploader + ""String_Node_Str"");
      socket.setSoTimeout(oldTimeout);
      if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.GET;
 else       if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.HEAD;
 else       return;
    }
  }
 catch (  IOException ioe) {
    debug(""String_Node_Str"");
  }
catch (  ArrayIndexOutOfBoundsException ae) {
    debug(""String_Node_Str"");
  }
 finally {
synchronized (this) {
      removeFromList(uploader);
      boolean found=false;
      for (Iterator iter=_queuedUploads.iterator(); iter.hasNext(); ) {
        KeyValue kv=(KeyValue)iter.next();
        if (kv.getKey() == socket) {
          found=true;
          iter.remove();
        }
      }
      if (found)       uploader.setState(Uploader.INTERRUPTED);
    }
    if (uploader != null && shouldShowInGUI(uploader))     RouterService.getCallback().removeUpload(uploader);
    debug(""String_Node_Str"");
    close(socket);
  }
}","/** 
 * Accepts a new upload, creating a new <tt>HTTPUploader</tt> if it successfully parses the HTTP request.  BLOCKING.
 * @param method the initial request type to use, e.g., GET or HEAD
 * @param socket the <tt>Socket</tt> that will be used for the new upload.It is assumed that the initial word of the request (e.g., ""GET"") has been consumed (e.g., by Acceptor)
 * @param forceAllow forces the UploadManager to allow all requestson this socket to take place.
 */
public void acceptUpload(final HTTPRequestMethod method,Socket socket,boolean forceAllow){
  debug(""String_Node_Str"");
  HTTPUploader uploader=null;
  try {
    int queued=-1;
    String oldFileName=""String_Node_Str"";
    HTTPRequestMethod currentMethod=method;
    StalledUploadWatchdog watchdog=new StalledUploadWatchdog();
    while (true) {
      HttpRequestLine line=parseHttpRequest(socket);
      debug(""String_Node_Str"");
      String fileName=line._fileName;
      if (uploader != null && shouldShowInGUI(uploader) && !oldFileName.equalsIgnoreCase(fileName)) {
        RouterService.getCallback().removeUpload(uploader);
      }
      removeFromList(uploader);
      uploader=new HTTPUploader(currentMethod,fileName,socket,line._index,uploader,watchdog);
      uploader.readHeader();
      debug(uploader + ""String_Node_Str"");
      boolean giveSlot=(oldFileName.equalsIgnoreCase(fileName) && queued == ACCEPTED);
      giveSlot|=forceAllow;
      queued=doSingleUpload(uploader,socket,socket.getInetAddress().getHostAddress(),line._index,giveSlot);
      oldFileName=fileName;
      if ((!line.isHTTP11() || uploader.getCloseConnection()) && queued != QUEUED)       return;
      debug(uploader + ""String_Node_Str"");
      int oldTimeout=socket.getSoTimeout();
      if (queued != QUEUED)       socket.setSoTimeout(SettingsManager.instance().getPersistentHTTPConnectionTimeout());
      String word=IOUtils.readWord(socket.getInputStream(),4);
      debug(uploader + ""String_Node_Str"");
      socket.setSoTimeout(oldTimeout);
      if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.GET;
 else       if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.HEAD;
 else       return;
    }
  }
 catch (  IOException ioe) {
    debug(""String_Node_Str"");
  }
catch (  ArrayIndexOutOfBoundsException ae) {
    debug(""String_Node_Str"");
  }
 finally {
    if (uploader != null && uploader.getState() != Uploader.COMPLETE)     uploader.setState(Uploader.INTERRUPTED);
synchronized (this) {
      removeFromList(uploader);
      boolean found=false;
      for (Iterator iter=_queuedUploads.iterator(); iter.hasNext(); ) {
        KeyValue kv=(KeyValue)iter.next();
        if (kv.getKey() == socket) {
          found=true;
          iter.remove();
        }
      }
    }
    if (uploader != null && shouldShowInGUI(uploader))     RouterService.getCallback().removeUpload(uploader);
    debug(""String_Node_Str"");
    close(socket);
  }
}",0.883530015392509
4646,"public HTTPRequestMethod getMethod(){
  return _method;
}","/** 
 * Returns the current HTTP Request Method.
 */
public HTTPRequestMethod getMethod(){
  return _method;
}",0.6826347305389222
4647,"/** 
 * Accepts a new push upload, creating a new <tt>HTTPUploader</tt>. NON-BLOCKING: creates a new thread to transfer the file. <p> The thread makes the uploader connect (which does the connecting  and also writes out the GIV, so the state of the returned socket  is the same as a socket which the accpetUpload methos would  expect)and delegates to the acceptUpload method with the socket  it gets from connecting. <p>
 * @param file the fully qualified pathname of the file to upload
 * @param host the ip address of the host to upload to
 * @param port the port over which the transfer will occur
 * @param index the index of the file in <tt>FileManager</tt>
 * @param guid the unique identifying client guid of the uploading client
 * @param forceAllow whether or not to force the UploadManager to sendaccept this request when it comes back.
 */
public synchronized void acceptPushUpload(final String file,final String host,final int port,final int index,final String guid,final boolean forceAllow){
  final HTTPUploader GIVuploader=new HTTPUploader(file,host,port,index,guid);
  clearFailedPushes();
  if (!forceAllow && ((!testAttemptingPush(host,index)) || (!testFailedPush(host,index))))   return;
  insertAttemptingPush(host,index);
  Thread runner=new Thread(){
    public void run(){
      try {
        Socket s=GIVuploader.connect();
        String word=IOUtils.readWord(s.getInputStream(),4);
        if (word.equals(""String_Node_Str""))         acceptUpload(HTTPRequestMethod.GET,s,forceAllow);
 else         if (word.equals(""String_Node_Str""))         acceptUpload(HTTPRequestMethod.HEAD,s,forceAllow);
 else         throw new IOException();
      }
 catch (      IOException ioe) {
synchronized (UploadManager.this) {
          insertFailedPush(host,index);
        }
      }
catch (      Throwable e) {
        ErrorService.error(e);
      }
 finally {
        GIVuploader.stop();
synchronized (UploadManager.this) {
          removeAttemptingPush(host,index);
        }
      }
    }
  }
;
  runner.start();
}","/** 
 * Accepts a new push upload, creating a new <tt>HTTPUploader</tt>. NON-BLOCKING: creates a new thread to transfer the file. <p> The thread makes the uploader connect (which does the connecting  and also writes out the GIV, so the state of the returned socket  is the same as a socket which the accpetUpload methos would  expect)and delegates to the acceptUpload method with the socket  it gets from connecting. <p>
 * @param file the fully qualified pathname of the file to upload
 * @param host the ip address of the host to upload to
 * @param port the port over which the transfer will occur
 * @param index the index of the file in <tt>FileManager</tt>
 * @param guid the unique identifying client guid of the uploading client
 * @param forceAllow whether or not to force the UploadManager to sendaccept this request when it comes back.
 */
public void acceptPushUpload(final String file,final String host,final int port,final int index,final String guid,final boolean forceAllow){
  final HTTPUploader GIVuploader=new HTTPUploader(file,host,port,index,guid);
synchronized (UploadManager.this) {
    clearFailedPushes();
    if (!forceAllow && ((!testAttemptingPush(host,index)) || (!testFailedPush(host,index))))     return;
    insertAttemptingPush(host,index);
  }
  Thread runner=new Thread(){
    public void run(){
      try {
        Socket s=GIVuploader.connect();
        String word=IOUtils.readWord(s.getInputStream(),4);
        if (word.equals(""String_Node_Str""))         acceptUpload(HTTPRequestMethod.GET,s,forceAllow);
 else         if (word.equals(""String_Node_Str""))         acceptUpload(HTTPRequestMethod.HEAD,s,forceAllow);
 else         throw new IOException();
      }
 catch (      IOException ioe) {
synchronized (UploadManager.this) {
          insertFailedPush(host,index);
        }
      }
catch (      Throwable e) {
        ErrorService.error(e);
      }
 finally {
        GIVuploader.stop();
synchronized (UploadManager.this) {
          removeAttemptingPush(host,index);
        }
      }
    }
  }
;
  runner.start();
}",0.9850892202395504
4648,"/** 
 * The handler for Multicast messages. Processes a message based on the message type.
 * @param msg the <tt>Message</tt> recieved.
 * @param datagram the <tt>DatagramPacket</tt> containing the IP andport of the client node.
 */
public void handleMulticastMessage(Message msg,DatagramPacket datagram){
  if (msg.getTTL() > 1)   return;
  msg.hop();
  InetAddress address=datagram.getAddress();
  int port=datagram.getPort();
  if (NetworkUtils.isLocalAddress(address))   return;
  ReplyHandler handler=new UDPReplyHandler(address,port);
  if (msg instanceof QueryRequest) {
    if (!handleUDPQueryRequestPossibleDuplicate((QueryRequest)msg,handler)) {
      ReceivedMessageStatHandler.MULTICAST_DUPLICATE_QUERIES.addMessage(msg);
    }
    if (RECORD_STATS)     ReceivedMessageStatHandler.MULTICAST_QUERY_REQUESTS.addMessage(msg);
  }
 else   if (msg instanceof PingRequest) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.MULTICAST_PING_REQUESTS.addMessage(msg);
    handleUDPPingRequestPossibleDuplicate((PingRequest)msg,handler,datagram);
  }
 else   if (msg instanceof PushRequest) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.MULTICAST_PUSH_REQUESTS.addMessage(msg);
    handlePushRequest((PushRequest)msg,handler);
  }
}","/** 
 * The handler for Multicast messages. Processes a message based on the message type.
 * @param msg the <tt>Message</tt> recieved.
 * @param datagram the <tt>DatagramPacket</tt> containing the IP andport of the client node.
 */
public void handleMulticastMessage(Message msg,DatagramPacket datagram){
  if (msg.getTTL() > 1)   return;
  msg.hop();
  InetAddress address=datagram.getAddress();
  int port=datagram.getPort();
  if (NetworkUtils.isLocalAddress(address) && !ConnectionSettings.ALLOW_MULTICAST_LOOPBACK.getValue())   return;
  ReplyHandler handler=new UDPReplyHandler(address,port);
  if (msg instanceof QueryRequest) {
    if (!handleUDPQueryRequestPossibleDuplicate((QueryRequest)msg,handler)) {
      ReceivedMessageStatHandler.MULTICAST_DUPLICATE_QUERIES.addMessage(msg);
    }
    if (RECORD_STATS)     ReceivedMessageStatHandler.MULTICAST_QUERY_REQUESTS.addMessage(msg);
  }
 else   if (msg instanceof PingRequest) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.MULTICAST_PING_REQUESTS.addMessage(msg);
    handleUDPPingRequestPossibleDuplicate((PingRequest)msg,handler,datagram);
  }
 else   if (msg instanceof PushRequest) {
    if (RECORD_STATS)     ReceivedMessageStatHandler.MULTICAST_PUSH_REQUESTS.addMessage(msg);
    handlePushRequest((PushRequest)msg,handler);
  }
}",0.9768899334116724
4649,"/** 
 * Checks if the <tt>QueryReply</tt> should be dropped based on per-TTL hard limits for the number of bytes routed for the given reply guid. This algorithm favors replies that don't have as far to go on the  network -- i.e., low TTL hits have more liberal limits than high TTL hits.  This ensures that hits that are closer to the query originator -- hits for which we've already done most of the work, are not  dropped unless we've routed a really large number of bytes for that guid.  This method also checks that hard number of results that have been sent for this GUID.  If this number is greater than a specified limit, we simply drop the reply.
 * @param rrp the <tt>ReplyRoutePair</tt> containing data about what's been routed for this GUID
 * @param ttl the time to live of the query hit
 * @return <tt>true if the reply should be dropped, otherwise <tt>false</tt>
 */
private static boolean shouldDropReply(RouteTable.ReplyRoutePair rrp,byte ttl){
  int resultsRouted=rrp.getResultsRouted();
  if (resultsRouted > 100)   return true;
  int bytesRouted=rrp.getBytesRouted();
  if (ttl > 2 && bytesRouted < 50 * 1024)   return false;
  if (ttl == 0 && bytesRouted < 50 * 1024)   return false;
  if (ttl == 1 && bytesRouted < 200 * 1024)   return false;
  if (ttl == 2 && bytesRouted < 100 * 1024)   return false;
  return true;
}","/** 
 * Checks if the <tt>QueryReply</tt> should be dropped based on per-TTL hard limits for the number of bytes routed for the given reply guid. This algorithm favors replies that don't have as far to go on the  network -- i.e., low TTL hits have more liberal limits than high TTL hits.  This ensures that hits that are closer to the query originator -- hits for which we've already done most of the work, are not  dropped unless we've routed a really large number of bytes for that guid.  This method also checks that hard number of results that have been sent for this GUID.  If this number is greater than a specified limit, we simply drop the reply.
 * @param rrp the <tt>ReplyRoutePair</tt> containing data about what's been routed for this GUID
 * @param ttl the time to live of the query hit
 * @return <tt>true if the reply should be dropped, otherwise <tt>false</tt>
 */
private static boolean shouldDropReply(RouteTable.ReplyRoutePair rrp,byte ttl){
  int resultsRouted=rrp.getResultsRouted();
  if (resultsRouted > 100)   return true;
  if (ttl == 0)   return true;
  int bytesRouted=rrp.getBytesRouted();
  if (ttl > 2 && bytesRouted < 50 * 1024)   return false;
  if (ttl == 1 && bytesRouted < 200 * 1024)   return false;
  if (ttl == 2 && bytesRouted < 100 * 1024)   return false;
  return true;
}",0.9547511312217196
4650,"/** 
 * Internal constructor.  Only creates QHD if includeQHD==true.  
 */
private QueryReply(byte[] guid,byte ttl,int port,byte[] ip,long speed,Response[] responses,byte[] clientGUID,byte[] xmlBytes,boolean includeQHD,boolean needsPush,boolean isBusy,boolean finishedUpload,boolean measuredSpeed,boolean supportsChat,boolean supportsBH,boolean isMulticastReply){
  super(guid,Message.F_QUERY_REPLY,ttl,(byte)0,11 + rLength(responses) + qhdLength(includeQHD,xmlBytes,supportsBH,isMulticastReply)+ 16);
  if (xmlBytes.length > XML_MAX_SIZE)   return;
  final int n=responses.length;
  if ((port & 0xFFFF0000) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + port);
  }
 else   if (ip.length != 4) {
    throw new IllegalArgumentException(""String_Node_Str"" + ip.length);
  }
 else   if ((speed & 0xFFFFFFFF00000000l) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + speed);
  }
 else   if (n >= 256) {
    throw new IllegalArgumentException(""String_Node_Str"" + n);
  }
  payload=new byte[getLength()];
  payload[0]=(byte)n;
  ByteOrder.short2leb((short)port,payload,1);
  payload[3]=ip[0];
  payload[4]=ip[1];
  payload[5]=ip[2];
  payload[6]=ip[3];
  ByteOrder.int2leb((int)speed,payload,7);
  int i=11;
  for (int left=n; left > 0; left--) {
    Response r=responses[n - left];
    i=r.writeToArray(payload,i);
  }
  if (includeQHD) {
    payload[i++]=(byte)76;
    payload[i++]=(byte)73;
    payload[i++]=(byte)77;
    payload[i++]=(byte)69;
    payload[i++]=(byte)COMMON_PAYLOAD_LEN;
    int ggepLen=_ggepUtil.getQRGGEP(false,false).length;
    payload[i++]=(byte)((needsPush ? PUSH_MASK : 0) | BUSY_MASK | UPLOADED_MASK| SPEED_MASK| GGEP_MASK);
    payload[i++]=(byte)(PUSH_MASK | (isBusy ? BUSY_MASK : 0) | (finishedUpload ? UPLOADED_MASK : 0)| (measuredSpeed ? SPEED_MASK : 0)| (supportsBH || isMulticastReply ? GGEP_MASK : (ggepLen > 0 ? GGEP_MASK : 0)));
    int xmlSize=xmlBytes.length + 1;
    if (xmlSize > XML_MAX_SIZE)     xmlSize=XML_MAX_SIZE;
    ByteOrder.short2leb(((short)xmlSize),payload,i);
    i+=2;
    payload[i++]=(byte)(supportsChat ? CHAT_MASK : 0);
    byte[] ggepBytes=_ggepUtil.getQRGGEP(supportsBH,isMulticastReply);
    System.arraycopy(ggepBytes,0,payload,i,ggepBytes.length);
    i+=ggepBytes.length;
    System.arraycopy(xmlBytes,0,payload,i,xmlSize - 1);
    i+=xmlSize - 1;
    payload[i++]=(byte)0;
  }
  for (int j=0; j < 16; j++) {
    payload[i + j]=clientGUID[j];
  }
  setAddress();
}","/** 
 * Internal constructor.  Only creates QHD if includeQHD==true.  
 */
private QueryReply(byte[] guid,byte ttl,int port,byte[] ip,long speed,Response[] responses,byte[] clientGUID,byte[] xmlBytes,boolean includeQHD,boolean needsPush,boolean isBusy,boolean finishedUpload,boolean measuredSpeed,boolean supportsChat,boolean supportsBH,boolean isMulticastReply){
  super(guid,Message.F_QUERY_REPLY,ttl,(byte)0,11 + rLength(responses) + qhdLength(includeQHD,xmlBytes,supportsBH,isMulticastReply)+ 16);
  if (xmlBytes.length > XML_MAX_SIZE)   return;
  final int n=responses.length;
  if ((port & 0xFFFF0000) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + port);
  }
 else   if (ip.length != 4) {
    throw new IllegalArgumentException(""String_Node_Str"" + ip.length);
  }
 else   if ((speed & 0xFFFFFFFF00000000l) != 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + speed);
  }
 else   if (n >= 256) {
    throw new IllegalArgumentException(""String_Node_Str"" + n);
  }
  payload=new byte[getLength()];
  payload[0]=(byte)n;
  ByteOrder.short2leb((short)port,payload,1);
  payload[3]=ip[0];
  payload[4]=ip[1];
  payload[5]=ip[2];
  payload[6]=ip[3];
  ByteOrder.int2leb((int)speed,payload,7);
  int i=11;
  for (int left=n; left > 0; left--) {
    Response r=responses[n - left];
    i=r.writeToArray(payload,i);
  }
  if (includeQHD) {
    payload[i++]=(byte)76;
    payload[i++]=(byte)73;
    payload[i++]=(byte)77;
    payload[i++]=(byte)69;
    payload[i++]=(byte)COMMON_PAYLOAD_LEN;
    int ggepLen=_ggepUtil.getQRGGEP(false,false).length;
    payload[i++]=(byte)((needsPush && !isMulticastReply ? PUSH_MASK : 0) | BUSY_MASK | UPLOADED_MASK| SPEED_MASK| GGEP_MASK);
    payload[i++]=(byte)(PUSH_MASK | (isBusy && !isMulticastReply ? BUSY_MASK : 0) | (finishedUpload ? UPLOADED_MASK : 0)| (measuredSpeed || isMulticastReply ? SPEED_MASK : 0)| (supportsBH || isMulticastReply ? GGEP_MASK : (ggepLen > 0 ? GGEP_MASK : 0)));
    int xmlSize=xmlBytes.length + 1;
    if (xmlSize > XML_MAX_SIZE)     xmlSize=XML_MAX_SIZE;
    ByteOrder.short2leb(((short)xmlSize),payload,i);
    i+=2;
    payload[i++]=(byte)(supportsChat ? CHAT_MASK : 0);
    byte[] ggepBytes=_ggepUtil.getQRGGEP(supportsBH,isMulticastReply);
    System.arraycopy(ggepBytes,0,payload,i,ggepBytes.length);
    i+=ggepBytes.length;
    System.arraycopy(xmlBytes,0,payload,i,xmlSize - 1);
    i+=xmlSize - 1;
    payload[i++]=(byte)0;
  }
  for (int j=0; j < 16; j++) {
    payload[i + j]=clientGUID[j];
  }
  setAddress();
}",0.9875601926163724
4651,"/** 
 * Initializes the internal data structures
 * @requires Should be called from Constructor only
 */
protected void initialize(){
  File[] schemaFiles=LimeXMLProperties.instance().getAllXMLSchemaFiles();
  if (schemaFiles != null) {
    LimeXMLSchema limeXmlSchema;
    for (int i=0; i < schemaFiles.length; i++) {
      try {
        limeXmlSchema=new LimeXMLSchema(schemaFiles[i]);
        _uriSchemaMap.put(limeXmlSchema.getSchemaURI(),limeXmlSchema);
      }
 catch (      IOException ioe) {
        ioe.printStackTrace();
      }
    }
  }
}","/** 
 * Initializes the internal data structures
 * @requires Should be called from Constructor only
 */
protected void initialize(){
  File[] schemaFiles=LimeXMLProperties.instance().getAllXMLSchemaFiles();
  if (schemaFiles != null) {
    LimeXMLSchema limeXmlSchema;
    for (int i=0; i < schemaFiles.length; i++) {
      try {
        limeXmlSchema=new LimeXMLSchema(schemaFiles[i]);
        _uriSchemaMap.put(limeXmlSchema.getSchemaURI(),limeXmlSchema);
      }
 catch (      IOException ioe) {
      }
    }
  }
}",0.971000935453695
4652,"/** 
 * Runs the legacy unit test that was formerly in QueryReply.
 */
public void testLegacy() throws Exception {
  byte[] ip={(byte)0xFF,(byte)0,(byte)0,(byte)0x1};
  long u4=0x00000000FFFFFFFFl;
  byte[] guid=new byte[16];
  guid[0]=(byte)1;
  guid[15]=(byte)0xFF;
  Response[] responses=new Response[0];
  QueryReply qr=new QueryReply(guid,(byte)5,0xF3F1,ip,1,responses,guid,false);
  assertEquals(1,qr.getSpeed());
  assertEquals(Integer.toHexString(qr.getPort()),0xF3F1,qr.getPort());
  assertEquals(qr.getResults().hasNext(),false);
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,false);
  assertEquals(""String_Node_Str"",qr.getIP());
  assertEquals(0xFFFF,qr.getPort());
  assertEquals(u4,qr.getSpeed());
  assertTrue(Arrays.equals(qr.getClientGUID(),guid));
  Iterator iter=qr.getResults();
  Response r1=(Response)iter.next();
  assertEquals(r1,responses[0]);
  Response r2=(Response)iter.next();
  assertEquals(r2,responses[1]);
  assertFalse(iter.hasNext());
  byte[] payload=new byte[11 + 11 + 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  iter=qr.getResults();
  Response response=(Response)iter.next();
  assertEquals(""String_Node_Str"",response.getName());
  assertFalse(iter.hasNext());
  try {
    qr.getVendor();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getNeedsPush();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + 15];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    iter=qr.getResults();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getVendor();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 5)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)76;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1+ 2]=(byte)5;
  payload[11 + 11 + 4+ 1+ 3]=(byte)0;
  payload[11 + 11 + 4+ 1+ 4]=(byte)'S';
  payload[11 + 11 + 4+ 1+ 4+ 1]=(byte)'U';
  payload[11 + 11 + 4+ 1+ 4+ 2]=(byte)'S';
  payload[11 + 11 + 4+ 1+ 4+ 3]=(byte)'H';
  payload[11 + 11 + 4+ 1+ 4+ 4]=(byte)0;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    iter=qr.getResults();
    Response r=(Response)iter.next();
    assertEquals(""String_Node_Str"",1,r.getNameBytesSize());
    assertEquals(""String_Node_Str"",0,r.getMetaBytesSize());
    byte[] name=r.getNameBytes();
    assertEquals(""String_Node_Str"",'A',name[0]);
    assertEquals(""String_Node_Str"",""String_Node_Str"",r.getName());
    assertEquals(""String_Node_Str"",""String_Node_Str"",(new String(qr.getXMLBytes())));
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"",e);
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 4)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0xB1;
  payload[11 + 11 + 4+ 1+ 2]=(byte)4;
  payload[11 + 11 + 4+ 1+ 3]=(byte)0;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  String vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  assertTrue(qr.getNeedsPush());
  payload=new byte[11 + 11 + (4 + 1 + 4+ 20000)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)76;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0xF0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)32;
  payload[11 + 11 + 4+ 1+ 3]=(byte)78;
  for (int i=0; i < 20000; i++)   payload[11 + 11 + 4+ 1+ 4+ i]='a';
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  assertFalse(qr.getNeedsPush());
  try {
    qr.getSupportsChat();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 2)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 4+ 1+ 0]=(byte)1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    qr.getNeedsPush();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getVendor();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 2 + 0)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)2;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  qr.getResults();
  try {
    qr.getVendor();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  vendor=qr.getVendor();
  assertEquals(""String_Node_Str"",""String_Node_Str"",vendor);
  assertTrue(!qr.getNeedsPush());
  try {
    qr.getIsBusy();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getHadSuccessfulUpload();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsMeasuredSpeed();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)73;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x1d;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x1c;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  payload[11 + 11 + 4+ 1+ 4]=(byte)0x1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  assertTrue(qr.getNeedsPush());
  assertTrue(qr.getNeedsPush());
  assertTrue(qr.getIsBusy());
  assertTrue(qr.getIsBusy());
  assertTrue(qr.getIsMeasuredSpeed());
  assertTrue(qr.getIsMeasuredSpeed());
  assertTrue(qr.getHadSuccessfulUpload());
  assertTrue(qr.getHadSuccessfulUpload());
  assertTrue(qr.getSupportsChat());
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x1c;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  assertFalse(qr.getNeedsPush());
  assertFalse(qr.getIsBusy());
  assertFalse(qr.getIsMeasuredSpeed());
  assertFalse(qr.getHadSuccessfulUpload());
  try {
    qr.getSupportsChat();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,false,true,true,false,true,false);
  assertEquals(""String_Node_Str"",qr.getIP());
  assertEquals(0xFFFF,qr.getPort());
  assertEquals(u4,qr.getSpeed());
  assertTrue(Arrays.equals(qr.getClientGUID(),guid));
  iter=qr.getResults();
  r1=(Response)iter.next();
  assertEquals(r1,responses[0]);
  r2=(Response)iter.next();
  assertEquals(r2,responses[1]);
  assertFalse(iter.hasNext());
  assertEquals(""String_Node_Str"",qr.getVendor());
  assertFalse(qr.getNeedsPush());
  assertTrue(qr.getIsBusy());
  assertTrue(qr.getHadSuccessfulUpload());
  assertFalse(qr.getIsMeasuredSpeed());
  assertTrue(qr.getSupportsChat());
  assertTrue(qr.getSupportsBrowseHost());
  assertTrue(!qr.isReplyToMulticastQuery());
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,true,false,false,true,false,false);
  assertEquals(""String_Node_Str"",qr.getVendor());
  assertTrue(qr.getNeedsPush());
  assertFalse(qr.getIsBusy());
  assertFalse(qr.getHadSuccessfulUpload());
  assertTrue(qr.getIsMeasuredSpeed());
  assertFalse(qr.getSupportsChat());
  assertTrue(qr.getSupportsBrowseHost());
  assertTrue(!qr.isReplyToMulticastQuery());
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  qr.write(out);
  byte[] bytes=out.toByteArray();
  int ggepLen=_ggepUtil.getQRGGEP(true,false).length;
  assertEquals((23 + 11 + 16) + (8 + 10 + 2) + (8 + 14 + 2)+ (4 + 1 + QueryReply.COMMON_PAYLOAD_LEN+ 1+ 1)+ ggepLen,bytes.length);
  assertEquals(0x3d,bytes[bytes.length - 16 - 6- ggepLen]);
  assertEquals(0x31,bytes[bytes.length - 16 - 5- ggepLen]);
  qr=(QueryReply)Message.read(new ByteArrayInputStream(bytes));
  assertEquals(""String_Node_Str"",qr.getVendor());
  assertTrue(qr.getNeedsPush());
  assertFalse(qr.getIsBusy());
  assertFalse(qr.getHadSuccessfulUpload());
  assertTrue(qr.getIsMeasuredSpeed());
  assertFalse(qr.getSupportsChat());
  assertTrue(qr.getSupportsBrowseHost());
  assertTrue(!qr.isReplyToMulticastQuery());
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,true,false,false,true,false,true);
  assertEquals(""String_Node_Str"",qr.getVendor());
  assertTrue(qr.getNeedsPush());
  assertFalse(qr.getIsBusy());
  assertFalse(qr.getHadSuccessfulUpload());
  assertTrue(qr.getIsMeasuredSpeed());
  assertFalse(qr.getSupportsChat());
  assertTrue(qr.getSupportsBrowseHost());
  assertTrue(qr.isReplyToMulticastQuery());
  out=new ByteArrayOutputStream();
  qr.write(out);
  bytes=out.toByteArray();
  ggepLen=_ggepUtil.getQRGGEP(true,true).length;
  assertEquals(bytes.length,(23 + 11 + 16) + (8 + 10 + 2) + (8 + 14 + 2)+ (4 + 1 + QueryReply.COMMON_PAYLOAD_LEN+ 1+ 1)+ ggepLen);
  assertEquals(bytes[bytes.length - 16 - 6- ggepLen],0x3d);
  assertEquals(bytes[bytes.length - 16 - 5- ggepLen],0x31);
  qr=(QueryReply)Message.read(new ByteArrayInputStream(bytes));
  assertEquals(""String_Node_Str"",qr.getVendor());
  assertTrue(qr.getNeedsPush());
  assertFalse(qr.getIsBusy());
  assertFalse(qr.getHadSuccessfulUpload());
  assertTrue(qr.getIsMeasuredSpeed());
  assertFalse(qr.getSupportsChat());
  assertTrue(qr.getSupportsBrowseHost());
  assertTrue(qr.isReplyToMulticastQuery());
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,false);
  try {
    qr.getVendor();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getNeedsPush();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsBusy();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getHadSuccessfulUpload();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsMeasuredSpeed();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
}","/** 
 * Runs the legacy unit test that was formerly in QueryReply.
 */
public void testLegacy() throws Exception {
  byte[] ip={(byte)0xFF,(byte)0,(byte)0,(byte)0x1};
  long u4=0x00000000FFFFFFFFl;
  byte[] guid=new byte[16];
  guid[0]=(byte)1;
  guid[15]=(byte)0xFF;
  Response[] responses=new Response[0];
  QueryReply qr=new QueryReply(guid,(byte)5,0xF3F1,ip,1,responses,guid,false);
  assertEquals(1,qr.getSpeed());
  assertEquals(Integer.toHexString(qr.getPort()),0xF3F1,qr.getPort());
  assertEquals(qr.getResults().hasNext(),false);
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,false);
  assertEquals(""String_Node_Str"",qr.getIP());
  assertEquals(0xFFFF,qr.getPort());
  assertEquals(u4,qr.getSpeed());
  assertTrue(Arrays.equals(qr.getClientGUID(),guid));
  Iterator iter=qr.getResults();
  Response r1=(Response)iter.next();
  assertEquals(r1,responses[0]);
  Response r2=(Response)iter.next();
  assertEquals(r2,responses[1]);
  assertFalse(iter.hasNext());
  byte[] payload=new byte[11 + 11 + 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  iter=qr.getResults();
  Response response=(Response)iter.next();
  assertEquals(""String_Node_Str"",response.getName());
  assertFalse(iter.hasNext());
  try {
    qr.getVendor();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getNeedsPush();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + 15];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    iter=qr.getResults();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getVendor();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 5)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)76;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1+ 2]=(byte)5;
  payload[11 + 11 + 4+ 1+ 3]=(byte)0;
  payload[11 + 11 + 4+ 1+ 4]=(byte)'S';
  payload[11 + 11 + 4+ 1+ 4+ 1]=(byte)'U';
  payload[11 + 11 + 4+ 1+ 4+ 2]=(byte)'S';
  payload[11 + 11 + 4+ 1+ 4+ 3]=(byte)'H';
  payload[11 + 11 + 4+ 1+ 4+ 4]=(byte)0;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    iter=qr.getResults();
    Response r=(Response)iter.next();
    assertEquals(""String_Node_Str"",1,r.getNameBytesSize());
    assertEquals(""String_Node_Str"",0,r.getMetaBytesSize());
    byte[] name=r.getNameBytes();
    assertEquals(""String_Node_Str"",'A',name[0]);
    assertEquals(""String_Node_Str"",""String_Node_Str"",r.getName());
    assertEquals(""String_Node_Str"",""String_Node_Str"",(new String(qr.getXMLBytes())));
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"",e);
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 4)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0xB1;
  payload[11 + 11 + 4+ 1+ 2]=(byte)4;
  payload[11 + 11 + 4+ 1+ 3]=(byte)0;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  String vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  assertTrue(qr.getNeedsPush());
  payload=new byte[11 + 11 + (4 + 1 + 4+ 20000)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)76;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0xF0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)32;
  payload[11 + 11 + 4+ 1+ 3]=(byte)78;
  for (int i=0; i < 20000; i++)   payload[11 + 11 + 4+ 1+ 4+ i]='a';
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  assertFalse(qr.getNeedsPush());
  try {
    qr.getSupportsChat();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 2)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 4+ 1+ 0]=(byte)1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    qr.getNeedsPush();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getVendor();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 2 + 0)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)2;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  qr.getResults();
  try {
    qr.getVendor();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  vendor=qr.getVendor();
  assertEquals(""String_Node_Str"",""String_Node_Str"",vendor);
  assertTrue(!qr.getNeedsPush());
  try {
    qr.getIsBusy();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getHadSuccessfulUpload();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsMeasuredSpeed();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)73;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x1d;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x1c;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  payload[11 + 11 + 4+ 1+ 4]=(byte)0x1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  assertTrue(qr.getNeedsPush());
  assertTrue(qr.getNeedsPush());
  assertTrue(qr.getIsBusy());
  assertTrue(qr.getIsBusy());
  assertTrue(qr.getIsMeasuredSpeed());
  assertTrue(qr.getIsMeasuredSpeed());
  assertTrue(qr.getHadSuccessfulUpload());
  assertTrue(qr.getHadSuccessfulUpload());
  assertTrue(qr.getSupportsChat());
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x1c;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  vendor=qr.getVendor();
  assertEquals(vendor,""String_Node_Str"",vendor);
  assertFalse(qr.getNeedsPush());
  assertFalse(qr.getIsBusy());
  assertFalse(qr.getIsMeasuredSpeed());
  assertFalse(qr.getHadSuccessfulUpload());
  try {
    qr.getSupportsChat();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,false,true,true,false,true,false);
  assertEquals(""String_Node_Str"",qr.getIP());
  assertEquals(0xFFFF,qr.getPort());
  assertEquals(u4,qr.getSpeed());
  assertTrue(Arrays.equals(qr.getClientGUID(),guid));
  iter=qr.getResults();
  r1=(Response)iter.next();
  assertEquals(r1,responses[0]);
  r2=(Response)iter.next();
  assertEquals(r2,responses[1]);
  assertFalse(iter.hasNext());
  assertEquals(""String_Node_Str"",qr.getVendor());
  assertFalse(qr.getNeedsPush());
  assertTrue(qr.getIsBusy());
  assertTrue(qr.getHadSuccessfulUpload());
  assertFalse(qr.getIsMeasuredSpeed());
  assertTrue(qr.getSupportsChat());
  assertTrue(qr.getSupportsBrowseHost());
  assertTrue(!qr.isReplyToMulticastQuery());
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,true,false,false,true,false,false);
  assertEquals(""String_Node_Str"",qr.getVendor());
  assertTrue(qr.getNeedsPush());
  assertFalse(qr.getIsBusy());
  assertFalse(qr.getHadSuccessfulUpload());
  assertTrue(qr.getIsMeasuredSpeed());
  assertFalse(qr.getSupportsChat());
  assertTrue(qr.getSupportsBrowseHost());
  assertTrue(!qr.isReplyToMulticastQuery());
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  qr.write(out);
  byte[] bytes=out.toByteArray();
  int ggepLen=_ggepUtil.getQRGGEP(true,false).length;
  assertEquals((23 + 11 + 16) + (8 + 10 + 2) + (8 + 14 + 2)+ (4 + 1 + QueryReply.COMMON_PAYLOAD_LEN+ 1+ 1)+ ggepLen,bytes.length);
  assertEquals(0x3d,bytes[bytes.length - 16 - 6- ggepLen]);
  assertEquals(0x31,bytes[bytes.length - 16 - 5- ggepLen]);
  qr=(QueryReply)Message.read(new ByteArrayInputStream(bytes));
  assertEquals(""String_Node_Str"",qr.getVendor());
  assertTrue(qr.getNeedsPush());
  assertFalse(qr.getIsBusy());
  assertFalse(qr.getHadSuccessfulUpload());
  assertTrue(qr.getIsMeasuredSpeed());
  assertFalse(qr.getSupportsChat());
  assertTrue(qr.getSupportsBrowseHost());
  assertTrue(!qr.isReplyToMulticastQuery());
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,true,false,false,true,false,false);
  assertEquals(""String_Node_Str"",qr.getVendor());
  assertTrue(qr.getNeedsPush());
  assertFalse(qr.getIsBusy());
  assertFalse(qr.getHadSuccessfulUpload());
  assertTrue(qr.getIsMeasuredSpeed());
  assertFalse(qr.getSupportsChat());
  assertTrue(qr.getSupportsBrowseHost());
  assertFalse(qr.isReplyToMulticastQuery());
  out=new ByteArrayOutputStream();
  qr.write(out);
  bytes=out.toByteArray();
  ggepLen=_ggepUtil.getQRGGEP(true,false).length;
  assertEquals((23 + 11 + 16) + (8 + 10 + 2) + (8 + 14 + 2)+ (4 + 1 + QueryReply.COMMON_PAYLOAD_LEN+ 1+ 1)+ ggepLen,bytes.length);
  assertEquals(0x3d,bytes[bytes.length - 16 - 6- ggepLen]);
  assertEquals(0x31,bytes[bytes.length - 16 - 5- ggepLen]);
  qr=(QueryReply)Message.read(new ByteArrayInputStream(bytes));
  assertEquals(""String_Node_Str"",qr.getVendor());
  assertTrue(qr.getNeedsPush());
  assertFalse(qr.getIsBusy());
  assertFalse(qr.getHadSuccessfulUpload());
  assertTrue(qr.getIsMeasuredSpeed());
  assertFalse(qr.getSupportsChat());
  assertTrue(qr.getSupportsBrowseHost());
  assertFalse(qr.isReplyToMulticastQuery());
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,false);
  try {
    qr.getVendor();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getNeedsPush();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsBusy();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getHadSuccessfulUpload();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsMeasuredSpeed();
    fail(""String_Node_Str"");
  }
 catch (  BadPacketException e) {
  }
}",0.991646390916464
4653,"/** 
 * Accepts a new upload, creating a new <tt>HTTPUploader</tt> if it successfully parses the HTTP request.  BLOCKING.
 * @param method the initial request type to use, e.g., GET or HEAD
 * @param socket the <tt>Socket</tt> that will be used for the new upload.It is assumed that the initial word of the request (e.g., ""GET"") has been consumed (e.g., by Acceptor)
 */
public void acceptUpload(final HTTPRequestMethod method,Socket socket){
  debug(""String_Node_Str"");
  HTTPUploader uploader=null;
  try {
    int queued=-1;
    String oldFileName=""String_Node_Str"";
    HTTPRequestMethod currentMethod=method;
    while (true) {
      HttpRequestLine line=parseHttpRequest(socket);
      debug(""String_Node_Str"");
      String fileName=line._fileName;
      if (uploader != null && uploader.getState() != Uploader.BROWSE_HOST && !oldFileName.equalsIgnoreCase(fileName)) {
        RouterService.getCallback().removeUpload(uploader);
      }
      removeFromList(uploader);
      uploader=new HTTPUploader(currentMethod,fileName,socket,line._index,uploader);
      uploader.readHeader();
      debug(uploader + ""String_Node_Str"");
      boolean giveSlot=(oldFileName.equalsIgnoreCase(fileName) && queued == ACCEPTED);
      if (giveSlot == false && (currentMethod == HTTPRequestMethod.HEAD)) {
        giveSlot=true;
      }
      queued=doSingleUpload(uploader,socket,socket.getInetAddress().getHostAddress(),line._index,giveSlot);
      oldFileName=fileName;
      if ((!line.isHTTP11() || uploader.getCloseConnection()) && queued != QUEUED)       return;
      debug(uploader + ""String_Node_Str"");
      int oldTimeout=socket.getSoTimeout();
      if (queued != QUEUED)       socket.setSoTimeout(SettingsManager.instance().getPersistentHTTPConnectionTimeout());
      String word=IOUtils.readWord(socket.getInputStream(),4);
      debug(uploader + ""String_Node_Str"");
      socket.setSoTimeout(oldTimeout);
      if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.GET;
 else       if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.HEAD;
 else       return;
    }
  }
 catch (  IOException ioe) {
    debug(""String_Node_Str"");
  }
catch (  ArrayIndexOutOfBoundsException ae) {
    debug(""String_Node_Str"");
  }
 finally {
synchronized (this) {
      removeFromList(uploader);
      boolean found=false;
      for (Iterator iter=_queuedUploads.iterator(); iter.hasNext(); ) {
        KeyValue kv=(KeyValue)iter.next();
        if (kv.getKey() == socket) {
          found=true;
          iter.remove();
        }
      }
      if (found)       uploader.setState(Uploader.INTERRUPTED);
    }
    if (uploader != null && (uploader.getState() != uploader.BROWSE_HOST))     RouterService.getCallback().removeUpload(uploader);
    debug(""String_Node_Str"");
    close(socket);
  }
}","/** 
 * Accepts a new upload, creating a new <tt>HTTPUploader</tt> if it successfully parses the HTTP request.  BLOCKING.
 * @param method the initial request type to use, e.g., GET or HEAD
 * @param socket the <tt>Socket</tt> that will be used for the new upload.It is assumed that the initial word of the request (e.g., ""GET"") has been consumed (e.g., by Acceptor)
 */
public void acceptUpload(final HTTPRequestMethod method,Socket socket){
  debug(""String_Node_Str"");
  HTTPUploader uploader=null;
  try {
    int queued=-1;
    String oldFileName=""String_Node_Str"";
    HTTPRequestMethod currentMethod=method;
    while (true) {
      HttpRequestLine line=parseHttpRequest(socket);
      debug(""String_Node_Str"");
      String fileName=line._fileName;
      if (uploader != null && shouldShowInGUI(uploader) && !oldFileName.equalsIgnoreCase(fileName)) {
        RouterService.getCallback().removeUpload(uploader);
      }
      removeFromList(uploader);
      uploader=new HTTPUploader(currentMethod,fileName,socket,line._index,uploader);
      uploader.readHeader();
      debug(uploader + ""String_Node_Str"");
      boolean giveSlot=(oldFileName.equalsIgnoreCase(fileName) && queued == ACCEPTED);
      queued=doSingleUpload(uploader,socket,socket.getInetAddress().getHostAddress(),line._index,giveSlot);
      oldFileName=fileName;
      if ((!line.isHTTP11() || uploader.getCloseConnection()) && queued != QUEUED)       return;
      debug(uploader + ""String_Node_Str"");
      int oldTimeout=socket.getSoTimeout();
      if (queued != QUEUED)       socket.setSoTimeout(SettingsManager.instance().getPersistentHTTPConnectionTimeout());
      String word=IOUtils.readWord(socket.getInputStream(),4);
      debug(uploader + ""String_Node_Str"");
      socket.setSoTimeout(oldTimeout);
      if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.GET;
 else       if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.HEAD;
 else       return;
    }
  }
 catch (  IOException ioe) {
    debug(""String_Node_Str"");
  }
catch (  ArrayIndexOutOfBoundsException ae) {
    debug(""String_Node_Str"");
  }
 finally {
synchronized (this) {
      removeFromList(uploader);
      boolean found=false;
      for (Iterator iter=_queuedUploads.iterator(); iter.hasNext(); ) {
        KeyValue kv=(KeyValue)iter.next();
        if (kv.getKey() == socket) {
          found=true;
          iter.remove();
        }
      }
      if (found)       uploader.setState(Uploader.INTERRUPTED);
    }
    if (uploader != null && shouldShowInGUI(uploader))     RouterService.getCallback().removeUpload(uploader);
    debug(""String_Node_Str"");
    close(socket);
  }
}",0.9562375158888688
4654,"/** 
 * Returns a new <tt>HttpRequestLine</tt> instance, where the  <tt>HttpRequestLine</tt> class is an immutable struct that contains all data for the ""GET"" line of the HTTP request.
 * @param socket the <tt>Socket</tt> instance over which we're reading
 * @return the <tt>HttpRequestLine</tt> struct for the HTTP request
 */
private HttpRequestLine parseHttpRequest(Socket socket) throws IOException {
  socket.setSoTimeout(Constants.TIMEOUT);
  ByteReader br=new ByteReader(socket.getInputStream());
  String str=br.readLine();
  if (str == null) {
    throw new IOException();
  }
  str.trim();
  if (this.isURNGet(str)) {
    return this.parseURNGet(str);
  }
 else   if (this.isMalformedURNGet(str)) {
    return this.parseMalformedURNGet(str);
  }
  return this.parseTraditionalGet(str);
}","/** 
 * Returns a new <tt>HttpRequestLine</tt> instance, where the  <tt>HttpRequestLine</tt> class is an immutable struct that contains all data for the ""GET"" line of the HTTP request.
 * @param socket the <tt>Socket</tt> instance over which we're reading
 * @return the <tt>HttpRequestLine</tt> struct for the HTTP request
 */
private HttpRequestLine parseHttpRequest(Socket socket) throws IOException {
  socket.setSoTimeout(Constants.TIMEOUT);
  ByteReader br=new ByteReader(socket.getInputStream());
  String str=br.readLine();
  try {
    if (str == null) {
      throw new IOException();
    }
    str.trim();
    if (this.isURNGet(str)) {
      return this.parseURNGet(str);
    }
 else     if (this.isMalformedURNGet(str)) {
      return this.parseMalformedURNGet(str);
    }
    return this.parseTraditionalGet(str);
  }
 catch (  IOException ioe) {
    if (str == null)     return new HttpRequestLine(MALFORMED_REQUEST_INDEX,""String_Node_Str"",false);
 else     return new HttpRequestLine(MALFORMED_REQUEST_INDEX,""String_Node_Str"",isHTTP11Request(str));
  }
}",0.8546916890080429
4655,"/** 
 * Parses the get line for a URN request, throwing an exception if  there are any errors in parsing.
 * @param requestLine the <tt>String</tt> instance containing the get request
 * @return a new <tt>RequestLine</tt> instance containing all of the datafor the get request
 */
private HttpRequestLine parseURNGet(final String requestLine) throws IOException {
  URN urn=URN.createSHA1UrnFromHttpRequest(requestLine);
  FileDesc desc=RouterService.getFileManager().getFileDescForUrn(urn);
  if (desc == null) {
    throw new IOException(""String_Node_Str"");
  }
  int fileIndex=desc.getIndex();
  String fileName=desc.getName();
  return new HttpRequestLine(desc.getIndex(),desc.getName(),isHTTP11Request(requestLine));
}","/** 
 * Parses the get line for a URN request, throwing an exception if  there are any errors in parsing. If we do not have the URN, we request a HttpRequestLine whose index is BAD_URN_QUERY_INDEX.  It is up to HTTPUploader to properly read the index and set the state to FILE_NOT_FOUND.
 * @param requestLine the <tt>String</tt> instance containing the get request
 * @return a new <tt>RequestLine</tt> instance containing all of the datafor the get request
 */
private HttpRequestLine parseURNGet(final String requestLine) throws IOException {
  URN urn=URN.createSHA1UrnFromHttpRequest(requestLine);
  FileDesc desc=RouterService.getFileManager().getFileDescForUrn(urn);
  if (desc == null) {
    return new HttpRequestLine(BAD_URN_QUERY_INDEX,""String_Node_Str"",isHTTP11Request(requestLine));
  }
  int fileIndex=desc.getIndex();
  String fileName=desc.getName();
  return new HttpRequestLine(desc.getIndex(),desc.getName(),isHTTP11Request(requestLine));
}",0.6801426872770512
4656,"/** 
 * Attempts to upload the given file for the given uploader.  May instead  reject or queue the upload.
 * @param uploader the uploader for this file, which MUST be connected
 * @param giveSlot whether the upload already has the slot for this fileIf false, the usual queueing rules apply.
 * @exception IOException if checkAndQueue throws an IOException, whichmeans that the GET request came too early for the queued uploader
 */
private int doSingleUpload(Uploader uploader,Socket socket,String host,int index,boolean giveSlot) throws IOException {
  long startTime=-1;
  debug(uploader + ""String_Node_Str"");
  boolean isBHUploader=(uploader.getState() == Uploader.BROWSE_HOST);
  boolean updateCheck=(uploader.getState() == Uploader.UPDATE_FILE);
  int queued=-1;
  if (!isBHUploader && !updateCheck) {
    if (uploader.getState() == Uploader.CONNECTING) {
      queued=checkAndQueue(uploader,host,socket,giveSlot);
      debug(uploader + ""String_Node_Str"" + queued);
      Assert.that(queued != -1);
    }
    if (uploader.getMethod() != HTTPRequestMethod.HEAD) {
      RouterService.getCallback().addUpload(uploader);
      FileDesc fd=uploader.getFileDesc();
      if (fd != null) {
        fd.incrementAttemptedUploads();
        RouterService.getCallback().handleSharedFileUpdate(fd.getFile());
      }
    }
  }
  if (queued == QUEUED) {
    socket.setSoTimeout(MAX_POLL_TIME);
    uploader.setState(Uploader.QUEUED);
  }
 else   if (queued == ACCEPTED) {
synchronized (this) {
      uploader.setState(Uploader.CONNECTING);
      _activeUploadList.add(uploader);
    }
  }
  startTime=System.currentTimeMillis();
  uploader.writeResponse();
  debug(uploader + ""String_Node_Str"");
  if (uploader.getState() == Uploader.UPLOADING || uploader.getState() == Uploader.CONNECTING) {
    uploader.setState(Uploader.INTERRUPTED);
  }
  if (uploader.getState() == Uploader.COMPLETE) {
    _hadSuccesfulUpload=true;
    if (!isBHUploader && uploader.getMethod() != HTTPRequestMethod.HEAD) {
      FileDesc fd=uploader.getFileDesc();
      if (fd != null) {
        fd.incrementCompletedUploads();
        RouterService.getCallback().handleSharedFileUpdate(fd.getFile());
      }
    }
  }
  long finishTime=System.currentTimeMillis();
synchronized (UploadManager.this) {
    if (startTime > 0)     reportUploadSpeed(finishTime - startTime,uploader.amountUploaded());
    return queued;
  }
}","/** 
 * Attempts to upload the given file for the given uploader.  May instead  reject or queue the upload.
 * @param uploader the uploader for this file, which MUST be connected
 * @param giveSlot whether the upload already has the slot for this fileIf false, the usual queueing rules apply.
 * @exception IOException if checkAndQueue throws an IOException, whichmeans that the GET request came too early for the queued uploader
 */
private int doSingleUpload(Uploader uploader,Socket socket,String host,int index,boolean giveSlot) throws IOException {
  long startTime=-1;
  debug(uploader + ""String_Node_Str"");
  int queued=-1;
  if (!shouldBypassQueue(uploader)) {
    if (uploader.getState() == Uploader.CONNECTING) {
      queued=checkAndQueue(uploader,host,socket,giveSlot);
      debug(uploader + ""String_Node_Str"" + queued);
      Assert.that(queued != -1);
    }
    if (shouldShowInGUI(uploader)) {
      RouterService.getCallback().addUpload(uploader);
      FileDesc fd=uploader.getFileDesc();
      if (fd != null) {
        fd.incrementAttemptedUploads();
        RouterService.getCallback().handleSharedFileUpdate(fd.getFile());
      }
    }
  }
  if (queued == QUEUED) {
    socket.setSoTimeout(MAX_POLL_TIME);
    uploader.setState(Uploader.QUEUED);
  }
 else   if (queued == ACCEPTED) {
synchronized (this) {
      uploader.setState(Uploader.CONNECTING);
      _activeUploadList.add(uploader);
    }
  }
  startTime=System.currentTimeMillis();
  uploader.writeResponse();
  debug(uploader + ""String_Node_Str"");
  if (uploader.getState() == Uploader.UPLOADING || uploader.getState() == Uploader.CONNECTING) {
    uploader.setState(Uploader.INTERRUPTED);
  }
  if (uploader.getState() == Uploader.COMPLETE) {
    _hadSuccesfulUpload=true;
    if (shouldShowInGUI(uploader)) {
      FileDesc fd=uploader.getFileDesc();
      if (fd != null) {
        fd.incrementCompletedUploads();
        RouterService.getCallback().handleSharedFileUpdate(fd.getFile());
      }
    }
  }
  long finishTime=System.currentTimeMillis();
synchronized (UploadManager.this) {
    if (startTime > 0)     reportUploadSpeed(finishTime - startTime,uploader.amountUploaded());
    return queued;
  }
}",0.7525615870939611
4657,"/** 
 * This method changes the appropriate state class based on the integer representing the state.  I'm not sure if this is a good idea, since it results in a case statement, that i was trying to avoid with. Implements the <tt>Uploader</tt> interface.
 */
public void setState(int state){
  _stateNum=state;
switch (state) {
case CONNECTING:
    _state=new NormalUploadState(this);
  break;
case QUEUED:
int pos=RouterService.getUploadManager().positionInQueue(_socket);
_state=new QueuedUploadState(pos,_fileDesc);
break;
case LIMIT_REACHED:
_state=new LimitReachedUploadState(_fileDesc);
break;
case PUSH_FAILED:
_state=new PushFailedUploadState();
break;
case FREELOADER:
_state=new FreeloaderUploadState();
break;
case BROWSE_HOST:
_state=new BrowseHostUploadState(this);
break;
case UPDATE_FILE:
_state=new UpdateFileState(this);
break;
case FILE_NOT_FOUND:
_state=new FileNotFoundUploadState();
case COMPLETE:
case INTERRUPTED:
break;
}
}","/** 
 * This method changes the appropriate state class based on the integer representing the state.  I'm not sure if this is a good idea, since it results in a case statement, that i was trying to avoid with. Implements the <tt>Uploader</tt> interface.
 */
public void setState(int state){
  _stateNum=state;
switch (state) {
case CONNECTING:
    _state=new NormalUploadState(this);
  break;
case QUEUED:
int pos=RouterService.getUploadManager().positionInQueue(_socket);
_state=new QueuedUploadState(pos,_fileDesc);
break;
case LIMIT_REACHED:
_state=new LimitReachedUploadState(_fileDesc);
break;
case PUSH_FAILED:
_state=new PushFailedUploadState();
break;
case FREELOADER:
_state=new FreeloaderUploadState();
break;
case BROWSE_HOST:
_state=new BrowseHostUploadState(this);
break;
case UPDATE_FILE:
_state=new UpdateFileState(this);
break;
case FILE_NOT_FOUND:
_state=new FileNotFoundUploadState();
break;
case MALFORMED_REQUEST:
_state=new MalformedRequestState();
case COMPLETE:
case INTERRUPTED:
break;
}
}",0.96579887697805
4658,"public void testLeafBroadcast() throws IOException, BadPacketException {
  debug(""String_Node_Str"");
  byte[] guid=rs.newQueryGUID();
  rs.query(guid,""String_Node_Str"");
  while (true) {
    Message m=ultrapeer1.receive(2000);
    if (m instanceof QueryRequest) {
      assertEquals(""String_Node_Str"",""String_Node_Str"",((QueryRequest)m).getQuery());
      break;
    }
  }
  while (true) {
    Message m=ultrapeer2.receive(2000);
    if (m instanceof QueryRequest) {
      assertEquals(""String_Node_Str"",""String_Node_Str"",((QueryRequest)m).getQuery());
      break;
    }
  }
  while (true) {
    Message m=old1.receive(2000);
    if (m instanceof QueryRequest) {
      assertEquals(""String_Node_Str"",""String_Node_Str"",((QueryRequest)m).getQuery());
      break;
    }
  }
}","public void testLeafBroadcast() throws IOException, BadPacketException {
  debug(""String_Node_Str"");
  byte[] guid=rs.newQueryGUID();
  rs.query(guid,""String_Node_Str"");
  while (true) {
    assertNotNull(""String_Node_Str"",ultrapeer1);
    Message m=ultrapeer1.receive(2000);
    if (m instanceof QueryRequest) {
      assertEquals(""String_Node_Str"",""String_Node_Str"",((QueryRequest)m).getQuery());
      break;
    }
  }
  while (true) {
    Message m=ultrapeer2.receive(2000);
    if (m instanceof QueryRequest) {
      assertEquals(""String_Node_Str"",""String_Node_Str"",((QueryRequest)m).getQuery());
      break;
    }
  }
  while (true) {
    Message m=old1.receive(2000);
    if (m instanceof QueryRequest) {
      assertEquals(""String_Node_Str"",""String_Node_Str"",((QueryRequest)m).getQuery());
      break;
    }
  }
}",0.9693174702567312
4659,"/** 
 * Tests to make sure that connections to old hosts are not allowed
 */
public void testConnectionToOldDisallowed(){
  Connection c=new Connection(""String_Node_Str"",PORT,new Properties(),new OldResponder());
  try {
    c.initialize();
    fail(""String_Node_Str"");
  }
 catch (  IOException e) {
  }
}","/** 
 * Tests to make sure that connections to old hosts are not allowed
 */
public void testConnectionToOldDisallowed(){
  Connection c=new Connection(""String_Node_Str"",PORT,new Properties(),new EmptyResponder());
  try {
    c.initialize();
    fail(""String_Node_Str"");
  }
 catch (  IOException e) {
  }
}",0.986970684039088
4660,"private static void replyToPing(Connection c,boolean ultrapeer) throws IOException, BadPacketException {
  Message m=c.receive(5000);
  assertTrue(m instanceof PingRequest);
  PingRequest pr=(PingRequest)m;
  byte[] localhost=new byte[]{(byte)127,(byte)0,(byte)0,(byte)1};
  PingReply reply=PingReply.createExternal(pr.getGUID(),(byte)7,c.getLocalPort(),ultrapeer ? ultrapeerIP : oldIP,ultrapeer);
  reply.hop();
  c.send(reply);
  c.flush();
}","private static void replyToPing(Connection c,boolean ultrapeer) throws IOException, BadPacketException {
  Message m=null;
  byte[] guid;
  try {
    while (!(m instanceof PingRequest)) {
      m=c.receive(500);
    }
    guid=((PingRequest)m).getGUID();
  }
 catch (  InterruptedIOException iioe) {
    guid=new GUID().bytes();
  }
  PingReply reply=PingReply.createExternal(guid,(byte)7,c.getLocalPort(),ultrapeer ? ultrapeerIP : oldIP,ultrapeer);
  reply.hop();
  c.send(reply);
  c.flush();
}",0.5404255319148936
4661,"public HandshakeResponse respond(HandshakeResponse response,boolean outgoing) throws IOException {
  Properties props=new Properties();
  return HandshakeResponse.createResponse(props);
}","public HandshakeResponse respond(HandshakeResponse response,boolean outgoing) throws IOException {
  Properties props=new UltrapeerHeaders(""String_Node_Str"");
  props.put(HeaderNames.X_DEGREE,""String_Node_Str"");
  return HandshakeResponse.createResponse(props);
}",0.7822222222222223
4662,"private static Connection connect(RouterService rs,int port,boolean ultrapeer) throws IOException, BadPacketException {
  ServerSocket ss=new ServerSocket(port);
  rs.connectToHostAsynchronously(""String_Node_Str"",port);
  Socket socket=ss.accept();
  ss.close();
  socket.setSoTimeout(3000);
  InputStream in=socket.getInputStream();
  String word=readWord(in);
  if (!word.equals(""String_Node_Str""))   throw new IOException(""String_Node_Str"" + word);
  HandshakeResponder responder;
  if (ultrapeer) {
    responder=new UltrapeerResponder();
  }
 else {
    responder=new OldResponder();
  }
  Connection con=new Connection(socket,responder);
  con.initialize();
  replyToPing(con,ultrapeer);
  return con;
}","private static Connection connect(RouterService rs,int port,boolean ultrapeer) throws IOException, BadPacketException {
  ServerSocket ss=new ServerSocket(port);
  rs.connectToHostAsynchronously(""String_Node_Str"",port);
  Socket socket=ss.accept();
  ss.close();
  socket.setSoTimeout(3000);
  InputStream in=socket.getInputStream();
  String word=readWord(in);
  if (!word.equals(""String_Node_Str""))   throw new IOException(""String_Node_Str"" + word);
  HandshakeResponder responder;
  if (ultrapeer) {
    responder=new UltrapeerResponder();
  }
 else {
    responder=new EmptyResponder();
  }
  Connection con=new Connection(socket,responder);
  con.initialize();
  replyToPing(con,ultrapeer);
  return con;
}",0.9943661971830986
4663,"/** 
 * Tests that the X-Try and X-Try-Ultrapeer headers are correctly being transferred in connection headers.
 */
public void testRedirect(){
  debug(""String_Node_Str"");
  Connection c=new Connection(""String_Node_Str"",PORT,new Properties(),new OldResponder());
  try {
    c.initialize();
    fail(""String_Node_Str"");
  }
 catch (  IOException e) {
    String hosts=c.headers().getProperty(HeaderNames.X_TRY_ULTRAPEERS);
    assertNotNull(""String_Node_Str"",hosts);
    Set s=list2set(hosts);
    assertEquals(""String_Node_Str"" + hosts,8,s.size());
    byte[] localhost=new byte[]{(byte)127,(byte)0,(byte)0,(byte)1};
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(ultrapeerIP,6350)));
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(ultrapeerIP,6351)));
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(ultrapeerIP,6352)));
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(ultrapeerIP,6353)));
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(localhost,6350)));
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(localhost,6351)));
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(localhost,6352)));
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(localhost,6353)));
  }
}","/** 
 * Tests that the X-Try and X-Try-Ultrapeer headers are correctly being transferred in connection headers.
 */
public void testRedirect(){
  debug(""String_Node_Str"");
  Connection c=new Connection(""String_Node_Str"",PORT,new Properties(),new EmptyResponder());
  try {
    c.initialize();
    fail(""String_Node_Str"");
  }
 catch (  IOException e) {
    String hosts=c.headers().getProperty(HeaderNames.X_TRY_ULTRAPEERS);
    assertNotNull(""String_Node_Str"",hosts);
    Set s=list2set(hosts);
    assertEquals(""String_Node_Str"" + hosts,4,s.size());
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(ultrapeerIP,6350)));
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(ultrapeerIP,6351)));
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(ultrapeerIP,6352)));
    assertTrue(""String_Node_Str"",s.contains(new Endpoint(ultrapeerIP,6353)));
  }
}",0.818785578747628
4664,"/** 
 * Constructs a new <tt>HeadRequester</tt> instance for the specified <tt>List</tt> of hosts to be notified, the <tt>URN</tt> to propagate, the <tt>AlternateLocationCollector</tt> to store newly discovered locations, and the list of alternate locations to report.
 * @param uploaders the hosts to send HEAD requests to
 * @param resourceName the <tt>URN</tt> of the resource
 * @param collector the <tt>AlternateLocationCollector</tt> that willstore any newly discovered locations
 * @param totalAlts the total known alternate locations to report
 */
public HeadRequester(List hosts,URN resourceName,AlternateLocationCollector collector,AlternateLocationCollection totalAlts){
  HOSTS=new HashSet(hosts);
  RESOURCE_NAME=resourceName;
  COLLECTOR=collector;
  TOTAL_ALTS=totalAlts;
}","/** 
 * Constructs a new <tt>HeadRequester</tt> instance for the specified <tt>List</tt> of hosts to be notified, the <tt>URN</tt> to propagate, the <tt>AlternateLocationCollector</tt> to store newly discovered locations, and the list of alternate locations to report.
 * @param uploaders the hosts to send HEAD requests to
 * @param resourceName the <tt>URN</tt> of the resource
 * @param collector the <tt>AlternateLocationCollector</tt> that willstore any newly discovered locations
 * @param totalAlts the total known alternate locations to report
 */
public HeadRequester(Set hosts,URN resourceName,AlternateLocationCollector collector,AlternateLocationCollection totalAlts){
  HOSTS=hosts;
  RESOURCE_NAME=resourceName;
  COLLECTOR=collector;
  TOTAL_ALTS=totalAlts;
}",0.9820742637644048
4665,"/** 
 * Tries one round of downloading of the given files.  Downloads from all locations until all locations fail or some locations succeed.  Moves incomplete file to the library on success.
 * @return COMPLETE if a file was successfully downloaded.  This canhappen even if the file is corrupt, if the user explicitly approved. CORRUPT_FILE a bytes mismatched when checking overlapping regions of resume or swarm, and the user decided they' did not want the download fragment, which is now quarantined. COULDNT_MOVE_TO_LIBRARY the download completed but the temporary file couldn't be moved to the library OR the download couldn't be written to the incomplete file WAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try.
 * @exception InterruptedException if the user stop()'ed this download. (Calls to resume() do not result in InterruptedException.)
 */
private int tryAllDownloads2() throws InterruptedException {
synchronized (this) {
    if (files.size() == 0)     return GAVE_UP;
  }
  incompleteFile=incompleteFileManager.getFile((RemoteFileDesc)files.get(0));
  File sharedDir;
  try {
    sharedDir=SettingsManager.instance().getSaveDirectory();
    completeFile=new File(sharedDir,getFileName());
    String sharedPath=sharedDir.getCanonicalPath();
    String completeFileParentPath=new File(completeFile.getParent()).getCanonicalPath();
    if (!sharedPath.equals(completeFileParentPath))     throw new InvalidPathException();
  }
 catch (  IOException e) {
    return COULDNT_MOVE_TO_LIBRARY;
  }
  totalAlternateLocations=null;
  RemoteFileDesc tempRFD;
  String rfdStr;
  URL rfdURL;
synchronized (this) {
    for (Iterator iter=files.iterator(); iter.hasNext(); ) {
      tempRFD=(RemoteFileDesc)iter.next();
      URN sha1=tempRFD.getSHA1Urn();
      if (sha1 == null)       continue;
      if (totalAlternateLocations == null) {
        totalAlternateLocations=AlternateLocationCollection.createCollection(sha1);
      }
      if (!sha1.equals(totalAlternateLocations.getSHA1Urn())) {
        continue;
      }
      try {
        AlternateLocation location=AlternateLocation.createAlternateLocation(tempRFD);
        totalAlternateLocations.addAlternateLocation(location);
      }
 catch (      IOException e) {
      }
    }
  }
  int status=-1;
  try {
    status=tryAllDownloads3();
  }
 catch (  InterruptedException e) {
  }
  commonOutFile.close();
  if (corruptState != NOT_CORRUPT_STATE) {
synchronized (corruptStateLock) {
      try {
        while (corruptState == CORRUPT_WAITING_STATE) {
          corruptStateLock.wait();
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
 else     if (corruptState == CORRUPT_CONTINUE_STATE) {
      ;
    }
  }
  if (status == -1)   throw new InterruptedException();
  if (status != COMPLETE)   return status;
  URN bucketHash=buckets.getURNForBucket(bucketNumber);
  URN fileHash=null;
  try {
    setState(HASHING);
    fileHash=URN.createSHA1Urn(incompleteFile);
  }
 catch (  IOException ignored) {
  }
  if (bucketHash != null) {
synchronized (corruptStateLock) {
      if (!bucketHash.equals(fileHash)) {
        setState(CORRUPT_FILE);
        promptAboutCorruptDownload();
        debug(""String_Node_Str"" + fileHash + ""String_Node_Str""+ bucketHash);
      }
      try {
        while (corruptState == CORRUPT_WAITING_STATE)         corruptStateLock.wait();
      }
 catch (      InterruptedException ignored2) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
  }
  setState(SAVING);
  completeFile.delete();
  if (!incompleteFile.renameTo(completeFile))   if (!CommonUtils.copy(incompleteFile,completeFile))   return COULDNT_MOVE_TO_LIBRARY;
  incompleteFileManager.removeEntry(incompleteFile);
  if (fileExists(completeFile))   fileManager.removeFileIfShared(completeFile);
  boolean fileAdded=fileManager.addFileIfShared(completeFile,getXMLDocuments());
  if (totalAlternateLocations != null && fileAdded) {
    FileDesc fileDesc=fileManager.getFileDescMatching(completeFile);
    if (fileDesc != null && fileDesc.getSHA1Urn().equals(totalAlternateLocations.getSHA1Urn())) {
      fileDesc.addAlternateLocationCollection(totalAlternateLocations);
      callback.handleSharedFileUpdate(completeFile);
      HeadRequester requester=new HeadRequester(files,fileHash,fileDesc,fileDesc.getAlternateLocationCollection());
      Thread headThread=new Thread(requester,""String_Node_Str"");
      headThread.setDaemon(true);
      headThread.start();
    }
  }
  return COMPLETE;
}","/** 
 * Tries one round of downloading of the given files.  Downloads from all locations until all locations fail or some locations succeed.  Moves incomplete file to the library on success.
 * @return COMPLETE if a file was successfully downloaded.  This canhappen even if the file is corrupt, if the user explicitly approved. CORRUPT_FILE a bytes mismatched when checking overlapping regions of resume or swarm, and the user decided they' did not want the download fragment, which is now quarantined. COULDNT_MOVE_TO_LIBRARY the download completed but the temporary file couldn't be moved to the library OR the download couldn't be written to the incomplete file WAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try.
 * @exception InterruptedException if the user stop()'ed this download. (Calls to resume() do not result in InterruptedException.)
 */
private int tryAllDownloads2() throws InterruptedException {
synchronized (this) {
    if (files.size() == 0)     return GAVE_UP;
  }
  incompleteFile=incompleteFileManager.getFile((RemoteFileDesc)files.get(0));
  File sharedDir;
  try {
    sharedDir=SettingsManager.instance().getSaveDirectory();
    completeFile=new File(sharedDir,getFileName());
    String sharedPath=sharedDir.getCanonicalPath();
    String completeFileParentPath=new File(completeFile.getParent()).getCanonicalPath();
    if (!sharedPath.equals(completeFileParentPath))     throw new InvalidPathException();
  }
 catch (  IOException e) {
    return COULDNT_MOVE_TO_LIBRARY;
  }
  totalAlternateLocations=null;
  RemoteFileDesc tempRFD;
  String rfdStr;
  URL rfdURL;
synchronized (this) {
    for (Iterator iter=files.iterator(); iter.hasNext(); ) {
      tempRFD=(RemoteFileDesc)iter.next();
      URN sha1=tempRFD.getSHA1Urn();
      if (sha1 == null)       continue;
      if (totalAlternateLocations == null) {
        totalAlternateLocations=AlternateLocationCollection.createCollection(sha1);
      }
      if (!sha1.equals(totalAlternateLocations.getSHA1Urn())) {
        continue;
      }
      try {
        AlternateLocation location=AlternateLocation.createAlternateLocation(tempRFD);
        totalAlternateLocations.addAlternateLocation(location);
      }
 catch (      IOException e) {
      }
    }
  }
  int status=-1;
  try {
    status=tryAllDownloads3();
  }
 catch (  InterruptedException e) {
  }
  commonOutFile.close();
  if (corruptState != NOT_CORRUPT_STATE) {
synchronized (corruptStateLock) {
      try {
        while (corruptState == CORRUPT_WAITING_STATE) {
          corruptStateLock.wait();
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
 else     if (corruptState == CORRUPT_CONTINUE_STATE) {
      ;
    }
  }
  if (status == -1)   throw new InterruptedException();
  if (status != COMPLETE)   return status;
  URN bucketHash=buckets.getURNForBucket(bucketNumber);
  URN fileHash=null;
  try {
    setState(HASHING);
    fileHash=URN.createSHA1Urn(incompleteFile);
  }
 catch (  IOException ignored) {
  }
  if (bucketHash != null) {
synchronized (corruptStateLock) {
      if (!bucketHash.equals(fileHash)) {
        setState(CORRUPT_FILE);
        promptAboutCorruptDownload();
        debug(""String_Node_Str"" + fileHash + ""String_Node_Str""+ bucketHash);
      }
      try {
        while (corruptState == CORRUPT_WAITING_STATE)         corruptStateLock.wait();
      }
 catch (      InterruptedException ignored2) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
  }
  setState(SAVING);
  completeFile.delete();
  if (!incompleteFile.renameTo(completeFile))   if (!CommonUtils.copy(incompleteFile,completeFile))   return COULDNT_MOVE_TO_LIBRARY;
  incompleteFileManager.removeEntry(incompleteFile);
  if (fileExists(completeFile))   fileManager.removeFileIfShared(completeFile);
  boolean fileAdded=fileManager.addFileIfShared(completeFile,getXMLDocuments());
  if (totalAlternateLocations != null && fileAdded) {
    FileDesc fileDesc=fileManager.getFileDescMatching(completeFile);
    if (fileDesc != null && fileDesc.getSHA1Urn().equals(totalAlternateLocations.getSHA1Urn())) {
      fileDesc.addAlternateLocationCollection(totalAlternateLocations);
      callback.handleSharedFileUpdate(completeFile);
      HashSet set=null;
synchronized (this) {
        set=new HashSet(files);
      }
      HeadRequester requester=new HeadRequester(set,fileHash,fileDesc,fileDesc.getAlternateLocationCollection());
      Thread headThread=new Thread(requester,""String_Node_Str"");
      headThread.setDaemon(true);
      headThread.start();
    }
  }
  return COMPLETE;
}",0.9905088852988692
4666,"/** 
 * Returns false if m is a ping or query reply message with a banned address.
 * @return false iff host is a banned address, true otherwise.     
 */
public boolean allow(Message m){
  String ip;
  if ((m instanceof PingReply)) {
    PingReply pr=(PingReply)m;
    ip=pr.getIP();
  }
 else   if ((m instanceof QueryReply)) {
    QueryReply qr=(QueryReply)m;
    ip=qr.getIP();
  }
 else   if (m instanceof PushRequest) {
    PushRequest push=(PushRequest)m;
    ip=NetworkUtils.ip2string(push.getIP());
  }
 else   return true;
  return allow(ip);
}","/** 
 * Checks if a given Message's host is banned.
 * @return true if this Message's host is allowed, false if it is bannedor we are unable to create correct IP addr out of it.
 */
public boolean allow(Message m){
  String ip;
  if ((m instanceof PingReply)) {
    PingReply pr=(PingReply)m;
    ip=pr.getIP();
  }
 else   if ((m instanceof QueryReply)) {
    QueryReply qr=(QueryReply)m;
    ip=qr.getIP();
  }
 else   if (m instanceof PushRequest) {
    PushRequest push=(PushRequest)m;
    ip=NetworkUtils.ip2string(push.getIP());
  }
 else   return true;
  return allow(ip);
}",0.7506607929515419
4667,"/** 
 * Obtains the time to wait for probe results to return.
 * @return the time to wait for this probe to complete, inmilliseconds
 */
long getTimeToWait(){
  if (!TTL_2_PROBES.isEmpty())   return (long)((double)QueryHandler.TIME_TO_WAIT_PER_HOP * 1.8);
  if (!TTL_1_PROBES.isEmpty())   return (long)((double)QueryHandler.TIME_TO_WAIT_PER_HOP * 2.0 * (double)TTL_1_PROBES.size());
  return 0L;
}","/** 
 * Obtains the time to wait for probe results to return.
 * @return the time to wait for this probe to complete, inmilliseconds
 */
long getTimeToWait(){
  if (!TTL_2_PROBES.isEmpty())   return (long)((double)QUERY_HANDLER.getTimeToWaitPerHop() * 1.8);
  if (!TTL_1_PROBES.isEmpty())   return (long)((double)QUERY_HANDLER.getTimeToWaitPerHop() * 2.0 * (double)TTL_1_PROBES.size());
  return 0L;
}",0.8546365914786967
4668,"/** 
 * Compares this to another interval by the 'low' element of the interval. If the low elements are the same, then the high element is compared.
 */
public int compareTo(Object o){
  Interval other=(Interval)o;
  if (this.low == other.low)   return this.low - other.low;
 else   return this.high - other.high;
}","/** 
 * Compares this to another interval by the 'low' element of the interval. If the low elements are the same, then the high element is compared.
 */
public int compareTo(Object o){
  Interval other=(Interval)o;
  if (this.low != other.low)   return this.low - other.low;
 else   return this.high - other.high;
}",0.9968253968253968
4669,"public void close(){
  if (fos == null)   return;
  try {
    fos.close();
  }
 catch (  IOException ioe) {
  }
}","public void close(){
  managedDownloader=null;
  if (fos == null)   return;
  try {
    fos.close();
  }
 catch (  IOException ioe) {
  }
}",0.8968253968253969
4670,"/** 
 * Accessor for the SHA1 URN for this <tt>RemoteFileDesc</tt>.
 * @return the SHA1 <tt>URN</tt> for this <tt>RemoteFileDesc</tt>, or <tt>null</tt> if there is none
 */
public final URN getSHA1Urn(){
  Iterator iter=_urns.iterator();
  while (iter.hasNext()) {
    URN urn=(URN)iter.next();
    if (urn.isSHA1()) {
      return urn;
    }
  }
  return null;
}","/** 
 * Accessor for the SHA1 URN for this <tt>RemoteFileDesc</tt>.
 * @return the SHA1 <tt>URN</tt> for this <tt>RemoteFileDesc</tt>, or <tt>null</tt> if there is none
 */
public final URN getSHA1Urn(){
  Iterator iter=_urns.iterator();
  while (iter.hasNext()) {
    URN urn=(URN)iter.next();
    if (urn == null)     continue;
    if (urn.isSHA1()) {
      return urn;
    }
  }
  return null;
}",0.9540078843626808
4671,"/** 
 * Test read & write of map
 */
public void testPersistence() throws Exception {
  assertTrue(""String_Node_Str"",!cacheExists());
  UrnCache cache=UrnCache.instance();
  FileDesc[] descs=createFileDescs();
  assertNotNull(""String_Node_Str"",descs);
  assertGreaterThan(""String_Node_Str"",0,descs.length);
  assertTrue(""String_Node_Str"",!cacheExists());
  cache.persistCache();
  assertTrue(""String_Node_Str"",cacheExists());
  for (int i=0; i < descs.length; i++) {
    Set set=cache.getUrns(descs[i].getFile());
    assertTrue(""String_Node_Str"",!set.equals(CommonUtils.EMPTY_SET));
    assertTrue(""String_Node_Str"",!set.isEmpty());
    assertEquals(""String_Node_Str"",descs[i].getUrns(),set);
  }
}","/** 
 * Test read & write of map
 */
public void testPersistence() throws Exception {
  assertTrue(""String_Node_Str"",!cacheExists());
  UrnCache cache=UrnCache.instance();
  FileDesc[] descs=createFileDescs();
  assertNotNull(""String_Node_Str"",descs);
  assertGreaterThan(""String_Node_Str"",0,descs.length);
  assertTrue(""String_Node_Str"",!cacheExists());
  cache.persistCache();
  assertTrue(""String_Node_Str"",cacheExists());
  for (int i=0; i < descs.length; i++) {
    Set set=cache.getUrns(descs[i].getFile());
    assertTrue(""String_Node_Str"",!set.equals(EMPTY_SET));
    assertTrue(""String_Node_Str"",!set.isEmpty());
    assertEquals(""String_Node_Str"",descs[i].getUrns(),set);
  }
}",0.9913419913419912
4672,"/** 
 * Implements the <tt>HTTPHeaderValue</tt> interface. This adds randomness to the order in which alternate locations are reported and only reports 10 locations.
 * @return an HTTP-compliant string of alternate locations, delimitedby commas, or the empty string if there are no alternate locations to report
 */
public String httpStringValue(){
  List list=new LinkedList(LOCATIONS);
  list=list.subList(0,list.size() >= 10 ? 10 : list.size());
  Iterator iter=list.iterator();
  final String commaSpace=""String_Node_Str"";
  StringBuffer writeBuffer=new StringBuffer();
  while (iter.hasNext()) {
    writeBuffer.append(((HTTPHeaderValue)iter.next()).httpStringValue());
    if (iter.hasNext()) {
      writeBuffer.append(commaSpace);
    }
  }
  return writeBuffer.toString();
}","/** 
 * Implements the <tt>HTTPHeaderValue</tt> interface. This adds randomness to the order in which alternate locations are reported and only reports 10 locations.
 * @return an HTTP-compliant string of alternate locations, delimitedby commas, or the empty string if there are no alternate locations to report
 */
public String httpStringValue(){
  List list=null;
synchronized (LOCATIONS) {
    list=new LinkedList(LOCATIONS);
  }
  list=list.subList(0,list.size() >= 10 ? 10 : list.size());
  Iterator iter=list.iterator();
  final String commaSpace=""String_Node_Str"";
  StringBuffer writeBuffer=new StringBuffer();
  while (iter.hasNext()) {
    writeBuffer.append(((HTTPHeaderValue)iter.next()).httpStringValue());
    if (iter.hasNext()) {
      writeBuffer.append(commaSpace);
    }
  }
  return writeBuffer.toString();
}",0.955334987593052
4673,"/** 
 * Creates a HandshakeResponse with the desired status code, status message,  and headers to respond with.
 * @param code the response code to use.
 * @param message the response message to use.
 * @param headers the headers to use in the response.
 */
HandshakeResponse(int code,String message,Properties headers){
  STATUS_CODE=code;
  STATUS_MESSAGE=message;
  HEADERS=Collections.unmodifiableMap(headers);
  DEGREE=extractIntHeaderValue(HEADERS,HeaderNames.X_DEGREE,6);
  HIGH_DEGREE=getNumIntraUltrapeerConnections() >= 15;
  ULTRAPEER_QRP=isVersionOrHigher(HEADERS,HeaderNames.X_ULTRAPEER_QUERY_ROUTING,0.1F);
  MAX_TTL=extractByteHeaderValue(HEADERS,HeaderNames.X_MAX_TTL,(byte)5);
  DYNAMIC_QUERY=isVersionOrHigher(HEADERS,HeaderNames.X_DYNAMIC_QUERY,0.1F);
  GOOD=isHighDegreeConnection() && isUltrapeerQueryRoutingConnection() && (getMaxTTL() < 5)&& isDynamicQueryConnection();
  ULTRAPEER=isTrueValue(HEADERS,HeaderNames.X_ULTRAPEER);
  LEAF=isFalseValue(HEADERS,HeaderNames.X_ULTRAPEER);
}","/** 
 * Creates a HandshakeResponse with the desired status code, status message,  and headers to respond with.
 * @param code the response code to use.
 * @param message the response message to use.
 * @param headers the headers to use in the response.
 */
HandshakeResponse(int code,String message,Properties headers){
  STATUS_CODE=code;
  STATUS_MESSAGE=message;
  HEADERS=headers;
  DEGREE=extractIntHeaderValue(HEADERS,HeaderNames.X_DEGREE,6);
  HIGH_DEGREE=getNumIntraUltrapeerConnections() >= 15;
  ULTRAPEER_QRP=isVersionOrHigher(HEADERS,HeaderNames.X_ULTRAPEER_QUERY_ROUTING,0.1F);
  MAX_TTL=extractByteHeaderValue(HEADERS,HeaderNames.X_MAX_TTL,(byte)5);
  DYNAMIC_QUERY=isVersionOrHigher(HEADERS,HeaderNames.X_DYNAMIC_QUERY,0.1F);
  GOOD=isHighDegreeConnection() && isUltrapeerQueryRoutingConnection() && (getMaxTTL() < 5)&& isDynamicQueryConnection();
  ULTRAPEER=isTrueValue(HEADERS,HeaderNames.X_ULTRAPEER);
  LEAF=isFalseValue(HEADERS,HeaderNames.X_ULTRAPEER);
}",0.978315683308119
4674,"public void testProbeIsTTL1Only() throws Exception {
  for (int i=2; i < 5; i++) {
    drainAll();
    QueryRequest request=QueryRequest.createQuery(""String_Node_Str"");
    request.setTTL((byte)i);
    ULTRAPEER_2.send(request);
    ULTRAPEER_2.flush();
    QueryRequest reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
    assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
    assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
    reqRecvd=(QueryRequest)ULTRAPEER_1.receive(TIMEOUT);
    assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
    assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
    assertEquals(reqRecvd.getHops(),(byte)1);
    Thread.sleep(2 * 1000);
    request.setTTL((byte)(i + 1));
    ULTRAPEER_2.send(request);
    ULTRAPEER_2.flush();
    try {
      LEAF.receive(TIMEOUT);
      assertTrue(false);
    }
 catch (    InterruptedIOException expected) {
    }
    try {
      ULTRAPEER_1.receive(TIMEOUT);
      assertTrue(false);
    }
 catch (    InterruptedIOException expected) {
    }
  }
}","public void testProbeIsTTL1Only() throws Exception {
  for (int i=2; i < 5; i++) {
    drainAll();
    QueryRequest request=QueryRequest.createQuery(""String_Node_Str"");
    request.setTTL((byte)i);
    ULTRAPEER_2.send(request);
    ULTRAPEER_2.flush();
    QueryRequest reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
    assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
    assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
    reqRecvd=getFirstQueryRequest(ULTRAPEER_1);
    assertTrue(reqRecvd != null);
    assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
    assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
    assertEquals(reqRecvd.getHops(),(byte)1);
    Thread.sleep(2 * 1000);
    request.setTTL((byte)(i + 1));
    ULTRAPEER_2.send(request);
    ULTRAPEER_2.flush();
    try {
      LEAF.receive(TIMEOUT);
      assertTrue(false);
    }
 catch (    InterruptedIOException expected) {
    }
    assertTrue(noUnexpectedMessages(ULTRAPEER_1));
  }
}",0.8984526112185687
4675,"public void testDuplicateProbes() throws Exception {
  drainAll();
  QueryRequest request=QueryRequest.createQuery(""String_Node_Str"");
  request.setTTL((byte)1);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  QueryRequest reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  try {
    ULTRAPEER_1.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  Thread.sleep(2 * 1000);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  try {
    reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  }
 catch (  InterruptedIOException expected) {
  }
  try {
    ULTRAPEER_1.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
}","public void testDuplicateProbes() throws Exception {
  drainAll();
  QueryRequest request=QueryRequest.createQuery(""String_Node_Str"");
  request.setTTL((byte)1);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  QueryRequest reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  assertTrue(noUnexpectedMessages(ULTRAPEER_1));
  Thread.sleep(2 * 1000);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  try {
    reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  }
 catch (  InterruptedIOException expected) {
  }
  assertTrue(noUnexpectedMessages(ULTRAPEER_1));
}",0.8157894736842105
4676,"public void testBasicProbeMechanicsFromUltrapeer() throws Exception {
  drainAll();
  QueryRequest request=QueryRequest.createQuery(""String_Node_Str"");
  request.setTTL((byte)1);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  QueryRequest reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  try {
    ULTRAPEER_1.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  Response response1=new Response(0L,0L,""String_Node_Str"");
  byte[] guid1=GUID.makeGuid();
  QueryReply reply1=new QueryReply(request.getGUID(),(byte)2,6346,new byte[4],56,new Response[]{response1},guid1,false);
  drain(ULTRAPEER_2);
  LEAF.send(reply1);
  LEAF.flush();
  QueryReply qRep=(QueryReply)ULTRAPEER_2.receive(TIMEOUT);
  assertEquals(new GUID(guid1),new GUID(qRep.getClientGUID()));
  Thread.sleep(2 * 1000);
  request.setTTL((byte)2);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  try {
    LEAF.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  reqRecvd=(QueryRequest)ULTRAPEER_1.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  assertEquals(reqRecvd.getHops(),(byte)1);
}","public void testBasicProbeMechanicsFromUltrapeer() throws Exception {
  drainAll();
  QueryRequest request=QueryRequest.createQuery(""String_Node_Str"");
  request.setTTL((byte)1);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  QueryRequest reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  assertTrue(noUnexpectedMessages(ULTRAPEER_1));
  Response response1=new Response(0L,0L,""String_Node_Str"");
  byte[] guid1=GUID.makeGuid();
  QueryReply reply1=new QueryReply(request.getGUID(),(byte)2,6346,new byte[4],56,new Response[]{response1},guid1,false);
  drain(ULTRAPEER_2);
  LEAF.send(reply1);
  LEAF.flush();
  QueryReply qRep=getFirstQueryReply(ULTRAPEER_2);
  assertTrue(qRep != null);
  assertEquals(new GUID(guid1),new GUID(qRep.getClientGUID()));
  Thread.sleep(2 * 1000);
  request.setTTL((byte)2);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  try {
    LEAF.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  reqRecvd=getFirstQueryRequest(ULTRAPEER_1);
  assertTrue(reqRecvd != null);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  assertEquals(reqRecvd.getHops(),(byte)1);
}",0.9080249175522168
4677,"public void testProbeIsLimited() throws Exception {
  drainAll();
  QueryRequest request=QueryRequest.createQuery(""String_Node_Str"");
  request.setTTL((byte)1);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  QueryRequest reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  try {
    ULTRAPEER_1.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  Thread.sleep(2 * 1000);
  request.setTTL((byte)3);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  try {
    LEAF.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  reqRecvd=(QueryRequest)ULTRAPEER_1.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  assertEquals(reqRecvd.getHops(),(byte)1);
  Thread.sleep(2 * 1000);
  request.setTTL((byte)4);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  try {
    reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  }
 catch (  InterruptedIOException expected) {
  }
  try {
    ULTRAPEER_1.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
}","public void testProbeIsLimited() throws Exception {
  drainAll();
  QueryRequest request=QueryRequest.createQuery(""String_Node_Str"");
  request.setTTL((byte)1);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  QueryRequest reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  assertTrue(noUnexpectedMessages(ULTRAPEER_1));
  Thread.sleep(2 * 1000);
  request.setTTL((byte)3);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  try {
    LEAF.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  reqRecvd=getFirstQueryRequest(ULTRAPEER_1);
  assertTrue(reqRecvd != null);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  assertEquals(reqRecvd.getHops(),(byte)1);
  Thread.sleep(2 * 1000);
  request.setTTL((byte)4);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  try {
    reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  }
 catch (  InterruptedIOException expected) {
  }
  assertTrue(noUnexpectedMessages(ULTRAPEER_1));
}",0.8633615477629988
4678,"public void testBasicProbeMechanicsFromLeaf() throws Exception {
  drainAll();
  QueryRequest request=QueryRequest.createQuery(""String_Node_Str"");
  request.hop();
  request.setTTL((byte)1);
  assertTrue((request.getHops() == 1));
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  QueryRequest reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  try {
    ULTRAPEER_1.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  Response response1=new Response(0L,0L,""String_Node_Str"");
  byte[] guid1=GUID.makeGuid();
  QueryReply reply1=new QueryReply(request.getGUID(),(byte)2,6346,new byte[4],56,new Response[]{response1},guid1,false);
  drain(ULTRAPEER_2);
  LEAF.send(reply1);
  LEAF.flush();
  QueryReply qRep=(QueryReply)ULTRAPEER_2.receive(TIMEOUT);
  assertEquals(new GUID(guid1),new GUID(qRep.getClientGUID()));
  Thread.sleep(2 * 1000);
  request.setTTL((byte)2);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  try {
    LEAF.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  reqRecvd=(QueryRequest)ULTRAPEER_1.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  assertEquals(reqRecvd.getHops(),(byte)2);
}","public void testBasicProbeMechanicsFromLeaf() throws Exception {
  drainAll();
  QueryRequest request=QueryRequest.createQuery(""String_Node_Str"");
  request.hop();
  request.setTTL((byte)1);
  assertTrue((request.getHops() == 1));
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  QueryRequest reqRecvd=(QueryRequest)LEAF.receive(TIMEOUT);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  assertTrue(noUnexpectedMessages(ULTRAPEER_1));
  Response response1=new Response(0L,0L,""String_Node_Str"");
  byte[] guid1=GUID.makeGuid();
  QueryReply reply1=new QueryReply(request.getGUID(),(byte)2,6346,new byte[4],56,new Response[]{response1},guid1,false);
  drain(ULTRAPEER_2);
  LEAF.send(reply1);
  LEAF.flush();
  QueryReply qRep=getFirstQueryReply(ULTRAPEER_2);
  assertTrue(qRep != null);
  assertEquals(new GUID(guid1),new GUID(qRep.getClientGUID()));
  Thread.sleep(2 * 1000);
  request.setTTL((byte)2);
  ULTRAPEER_2.send(request);
  ULTRAPEER_2.flush();
  try {
    LEAF.receive(TIMEOUT);
    assertTrue(false);
  }
 catch (  InterruptedIOException expected) {
  }
  reqRecvd=getFirstQueryRequest(ULTRAPEER_1);
  assertTrue(reqRecvd != null);
  assertTrue(reqRecvd.getQuery().equals(""String_Node_Str""));
  assertTrue(Arrays.equals(request.getGUID(),reqRecvd.getGUID()));
  assertEquals(reqRecvd.getHops(),(byte)2);
}",0.9114013413342746
4679,"public void checkAndUpdate(Connection connection){
  String nv=connection.getVersion();
  debug(""String_Node_Str"" + latestVersion + ""String_Node_Str""+ nv);
  if (nv.equals(SPECIAL_VERSION))   return;
  if (!isGreaterVersion(nv,latestVersion))   return;
  final Connection c=connection;
  Thread checker=new Thread(){
    public void run(){
      debug(""String_Node_Str"");
      final String UPDATE=""String_Node_Str"";
      String ip=c.getOrigHost();
      int port=c.getOrigPort();
      byte[] data=null;
      try {
        URL url=new URL(""String_Node_Str"",ip,port,UPDATE);
        HttpURLConnection connection=(HttpURLConnection)url.openConnection();
        connection.setUseCaches(false);
        connection.setRequestProperty(""String_Node_Str"",CommonUtils.getHttpServer());
        connection.setRequestProperty(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
        connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
        InputStream in=connection.getInputStream();
        int len=connection.getContentLength();
        debug(""String_Node_Str"" + len);
        data=new byte[len];
        int BUF_LEN=1024;
        byte[] buf=new byte[BUF_LEN];
        int iters=len % BUF_LEN == 0 ? len / BUF_LEN : (len / BUF_LEN) + 1;
        ByteReader byteReader=new ByteReader(in);
        int totalRead=0;
        for (int i=0; i < iters; i++) {
          int left=len - totalRead;
          int a=byteReader.read(buf,0,Math.min(BUF_LEN,left));
          if (a == -1)           break;
          System.arraycopy(buf,0,data,totalRead,a);
          totalRead+=a;
        }
        UpdateMessageVerifier verifier=new UpdateMessageVerifier(data);
        boolean verified=verifier.verifySource();
        if (!verified) {
          debug(""String_Node_Str"");
          return;
        }
        debug(""String_Node_Str"");
        String xml=new String(verifier.getMessageBytes(),""String_Node_Str"");
        UpdateFileParser parser=new UpdateFileParser(xml);
        debug(""String_Node_Str"" + parser.getVersion());
        String newVersion=parser.getVersion();
        if (newVersion == null)         return;
        if (isGreaterVersion(newVersion,latestVersion)) {
          debug(""String_Node_Str"");
synchronized (UpdateManager.this) {
            commitVersionFile(data);
            latestVersion=newVersion;
            debug(""String_Node_Str"" + latestVersion);
          }
        }
      }
 catch (      Exception e) {
        return;
      }
    }
  }
;
  checker.start();
}","public void checkAndUpdate(Connection connection){
  String nv=connection.getVersion();
  debug(""String_Node_Str"" + latestVersion + ""String_Node_Str""+ nv);
  if (!isGreaterVersion(nv,latestVersion))   return;
  if (nv.equals(SPECIAL_VERSION))   return;
  final Connection c=connection;
  Thread checker=new Thread(){
    public void run(){
      debug(""String_Node_Str"");
      final String UPDATE=""String_Node_Str"";
      String ip=c.getOrigHost();
      int port=c.getOrigPort();
      byte[] data=null;
      try {
        URL url=new URL(""String_Node_Str"",ip,port,UPDATE);
        HttpURLConnection connection=(HttpURLConnection)url.openConnection();
        connection.setUseCaches(false);
        connection.setRequestProperty(""String_Node_Str"",CommonUtils.getHttpServer());
        connection.setRequestProperty(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
        connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
        InputStream in=connection.getInputStream();
        int len=connection.getContentLength();
        debug(""String_Node_Str"" + len);
        data=new byte[len];
        int BUF_LEN=1024;
        byte[] buf=new byte[BUF_LEN];
        int iters=len % BUF_LEN == 0 ? len / BUF_LEN : (len / BUF_LEN) + 1;
        ByteReader byteReader=new ByteReader(in);
        int totalRead=0;
        for (int i=0; i < iters; i++) {
          int left=len - totalRead;
          int a=byteReader.read(buf,0,Math.min(BUF_LEN,left));
          if (a == -1)           break;
          System.arraycopy(buf,0,data,totalRead,a);
          totalRead+=a;
        }
        UpdateMessageVerifier verifier=new UpdateMessageVerifier(data);
        boolean verified=verifier.verifySource();
        if (!verified) {
          debug(""String_Node_Str"");
          return;
        }
        debug(""String_Node_Str"");
        String xml=new String(verifier.getMessageBytes(),""String_Node_Str"");
        UpdateFileParser parser=new UpdateFileParser(xml);
        debug(""String_Node_Str"" + parser.getVersion());
        String newVersion=parser.getVersion();
        if (newVersion == null)         return;
        if (isGreaterVersion(newVersion,latestVersion)) {
          debug(""String_Node_Str"");
synchronized (UpdateManager.this) {
            commitVersionFile(data);
            latestVersion=newVersion;
            debug(""String_Node_Str"" + latestVersion);
          }
        }
      }
 catch (      Exception e) {
        return;
      }
    }
  }
;
  checker.start();
}",0.9789012738853504
4680,"/** 
 * Overrides ManagedDownloader to display a reasonable file name even when no locations have been found.
 */
public synchronized String getFileName(){
  if (_filename != null)   return _filename;
 else {
    String fname=super.getFileName();
    if (fname == null || fname.equals(UNKNOWN_FILENAME))     fname=getFileNameHint();
    return fname;
  }
}","/** 
 * Overrides ManagedDownloader to display a reasonable file name even when no locations have been found.
 */
public synchronized String getFileName(){
  if (_filename != null)   return _filename;
 else {
    String fname=null;
    if (hasRFD())     fname=super.getFileName();
    if (fname == null || fname.equals(UNKNOWN_FILENAME))     fname=getFileNameHint();
    return fname;
  }
}",0.9544235924932976
4681,"/** 
 * The number of bytes read. The way we calculate the number of bytes  read is a little wierd if the range header begins from the middle of  the file (say from byte x). Then we consider that bytes 0-x have  already been read.  <p> This may lead to some wierd behaviour with chunking. For example if  a host requests the last 10% of a file, the GUI will display 90% downloaded. Later if the same host requests from 20% to 30% the  progress will reduce to 20% onwards.  Implements the Uploader interface.
 */
public int amountUploaded(){
  return _amountRead;
}","/** 
 * The amount of bytes that this upload has transferred. Implements the Uploader interface.
 */
public int amountUploaded(){
  return _amountRead;
}",0.3737796373779637
4682,"public void measureBandwidth(){
  bandwidthTracker.measureBandwidth(amountUploaded());
}","public void measureBandwidth(){
  bandwidthTracker.measureBandwidth(getTotalAmountUploaded());
}",0.9565217391304348
4683,"/** 
 * Sends a GET request using an already open socket, and reads all  headers.  <p>
 * @param start The byte at which the HTTPDownloader should begin
 * @param stop the index just past the last byte to read;stop-1 is the last byte the HTTPDownloader should download <p>
 * @exception TryAgainLaterException the host is busy
 * @exception FileNotFoundException the host doesn't recognize the file
 * @exception NotSharingException the host isn't sharing files (BearShare)
 * @exception IOException miscellaneous  error 
 */
public void connectHTTP(int start,int stop,boolean supportQueueing) throws IOException, TryAgainLaterException, FileNotFoundException, NotSharingException, QueuedException {
  _amountToRead=stop - start;
  _amountRead=0;
  _initialReadingPoint=start;
  OutputStream os=_socket.getOutputStream();
  OutputStreamWriter osw=new OutputStreamWriter(os);
  BufferedWriter out=new BufferedWriter(osw);
  String startRange=java.lang.String.valueOf(_initialReadingPoint);
  out.write(""String_Node_Str"" + _rfd.getUrl().getFile() + ""String_Node_Str"");
  out.write(""String_Node_Str"" + _host + ""String_Node_Str""+ _port+ ""String_Node_Str"");
  out.write(""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"");
  if (supportQueueing)   out.write(""String_Node_Str"");
  AlternateLocationCollection alts=null;
  if (_alternateLocationsToSend != null) {
    alts=AlternateLocationCollection.createCollection(_alternateLocationsToSend.getSHA1Urn());
synchronized (_alternateLocationsToSend) {
      alts.addAlternateLocationCollection(_alternateLocationsToSend);
    }
  }
  URN sha1=_rfd.getSHA1Urn();
  if (sha1 != null)   HTTPUtils.writeHeader(HTTPHeaderName.GNUTELLA_CONTENT_URN,sha1,out);
  if (alts != null && alts.numberOfAlternateLocations() > 0) {
    HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,alts,out);
  }
  out.write(""String_Node_Str"" + startRange + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str"");
  SettingsManager sm=SettingsManager.instance();
  if (sm.getChatEnabled()) {
    int port;
    String host;
    if (sm.getForceIPAddress()) {
      port=sm.getForcedPort();
      host=sm.getForcedIPAddressString();
    }
 else {
      port=sm.getPort();
      host=_socket.getLocalAddress().getHostAddress();
    }
    out.write(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str"");
  }
  out.write(""String_Node_Str"");
  out.flush();
  readHeaders();
}","/** 
 * Sends a GET request using an already open socket, and reads all  headers.  <p>
 * @param start The byte at which the HTTPDownloader should begin
 * @param stop the index just past the last byte to read;stop-1 is the last byte the HTTPDownloader should download <p>
 * @exception TryAgainLaterException the host is busy
 * @exception FileNotFoundException the host doesn't recognize the file
 * @exception NotSharingException the host isn't sharing files (BearShare)
 * @exception IOException miscellaneous  error 
 */
public void connectHTTP(int start,int stop,boolean supportQueueing) throws IOException, TryAgainLaterException, FileNotFoundException, NotSharingException, QueuedException {
  _amountToRead=stop - start;
  _totalAmountRead+=_amountRead;
  _amountRead=0;
  _initialReadingPoint=start;
  OutputStream os=_socket.getOutputStream();
  OutputStreamWriter osw=new OutputStreamWriter(os);
  BufferedWriter out=new BufferedWriter(osw);
  String startRange=java.lang.String.valueOf(_initialReadingPoint);
  out.write(""String_Node_Str"" + _rfd.getUrl().getFile() + ""String_Node_Str"");
  out.write(""String_Node_Str"" + _host + ""String_Node_Str""+ _port+ ""String_Node_Str"");
  out.write(""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"");
  if (supportQueueing)   out.write(""String_Node_Str"");
  AlternateLocationCollection alts=null;
  if (_alternateLocationsToSend != null) {
    alts=AlternateLocationCollection.createCollection(_alternateLocationsToSend.getSHA1Urn());
synchronized (_alternateLocationsToSend) {
      alts.addAlternateLocationCollection(_alternateLocationsToSend);
    }
  }
  URN sha1=_rfd.getSHA1Urn();
  if (sha1 != null)   HTTPUtils.writeHeader(HTTPHeaderName.GNUTELLA_CONTENT_URN,sha1,out);
  if (alts != null && alts.numberOfAlternateLocations() > 0) {
    HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,alts,out);
  }
  out.write(""String_Node_Str"" + startRange + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str"");
  SettingsManager sm=SettingsManager.instance();
  if (sm.getChatEnabled()) {
    int port;
    String host;
    if (sm.getForceIPAddress()) {
      port=sm.getForcedPort();
      host=sm.getForcedIPAddressString();
    }
 else {
      port=sm.getPort();
      host=_socket.getLocalAddress().getHostAddress();
    }
    out.write(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str"");
  }
  out.write(""String_Node_Str"");
  out.flush();
  readHeaders();
}",0.993205682520074
4684,"public void measureBandwidth(){
  bandwidthTracker.measureBandwidth(getAmountRead());
}","public void measureBandwidth(){
  bandwidthTracker.measureBandwidth(getTotalAmountRead());
}",0.9720670391061452
4685,"/** 
 * Top level method of the thread. Calls three methods  a. Establish a TCP Connection. b. Assign this thread a part of the file, and do HTTP handshaking c. get the file. Each of these steps can run into errors, which have to be dealt with differently.
 * @return true if this worker thread should notify, false otherwise.currently this method returns false iff NSEEx is  thrown. 
 */
private boolean connectAndDownload(RemoteFileDesc rfd){
  HTTPDownloader dloader=null;
  dloader=establishConnection(rfd);
  if (dloader == null)   return true;
  boolean http11=true;
  while (http11) {
    boolean wasQueued=false;
    int connected;
    http11=!(rfd.getUrns().isEmpty());
    while (true) {
      int[] a={-1};
      connected=assignAndRequest(dloader,a,http11);
      if (connected != 1)       break;
      if (!wasQueued) {
synchronized (this) {
          queuedCount++;
        }
        wasQueued=true;
      }
      try {
        if (a[0] > 0)         Thread.sleep(a[0]);
      }
 catch (      InterruptedException ix) {
        debug(""String_Node_Str"" + dloader);
synchronized (this) {
          queuedCount--;
        }
        dloader.stop();
        return true;
      }
    }
    if (wasQueued) {
synchronized (this) {
        queuedCount--;
      }
    }
    Assert.that(connected == 0 || connected == 2 || connected == 3,""String_Node_Str"" + connected);
    if (connected == 0)     return true;
 else     if (connected == 3)     return false;
    doDownload(dloader,http11);
  }
  return true;
}","/** 
 * Top level method of the thread. Calls three methods  a. Establish a TCP Connection. b. Assign this thread a part of the file, and do HTTP handshaking c. get the file. Each of these steps can run into errors, which have to be dealt with differently.
 * @return true if this worker thread should notify, false otherwise.currently this method returns false iff NSEEx is  thrown. 
 */
private boolean connectAndDownload(RemoteFileDesc rfd){
  HTTPDownloader dloader=null;
  dloader=establishConnection(rfd);
  if (dloader == null)   return true;
  boolean http11=true;
  while (http11) {
    boolean wasQueued=false;
    int connected;
    http11=!(rfd.getUrns().isEmpty());
    while (true) {
      int[] a={-1};
      connected=assignAndRequest(dloader,a,http11);
      if (connected != 1)       break;
      if (!wasQueued) {
synchronized (this) {
          queuedCount++;
        }
        wasQueued=true;
      }
      try {
        if (a[0] > 0)         Thread.sleep(a[0]);
      }
 catch (      InterruptedException ix) {
        debug(""String_Node_Str"" + dloader);
synchronized (this) {
          queuedCount--;
        }
        dloader.stop();
        return true;
      }
    }
    if (wasQueued) {
synchronized (this) {
        queuedCount--;
      }
    }
    Assert.that(connected == 0 || connected == 2 || connected == 3,""String_Node_Str"" + connected);
    if (connected == 0) {
      dloader.stop();
      return true;
    }
 else     if (connected == 3) {
      dloader.stop();
      return false;
    }
    doDownload(dloader,http11);
  }
  return true;
}",0.9579288025889968
4686,"/** 
 * Replaces OS specific illegal characters from any filename with '_',  including ( / \n \r \t ) on all operating systems, ( ? * \  < > | "" )  on Windows, ( ` ) on unix.
 * @param name the filename to check for illegal characters
 * @return String containing the cleaned filename
 */
public static String convertFileName(String name){
  for (int i=0; i < ILLEGAL_CHARS_ANY_OS.length; i++)   name=name.replace(ILLEGAL_CHARS_ANY_OS[i],'_');
  if (_isWindows) {
    for (int i=0; i < ILLEGAL_CHARS_WINDOWS.length; i++)     name=name.replace(ILLEGAL_CHARS_WINDOWS[i],'_');
  }
 else   if (_isLinux || _isSolaris) {
    for (int i=0; i < ILLEGAL_CHARS_UNIX.length; i++)     name=name.replace(ILLEGAL_CHARS_UNIX[i],'_');
  }
  return name;
}","/** 
 * Replaces OS specific illegal characters from any filename with '_',  including ( / \n \r \t ) on all operating systems, ( ? * \  < > | "" )  on Windows, ( ` ) on unix.
 * @param name the filename to check for illegal characters
 * @return String containing the cleaned filename
 */
public static String convertFileName(String name){
  if (name.length() > 180) {
    name=name.substring(0,180);
  }
  for (int i=0; i < ILLEGAL_CHARS_ANY_OS.length; i++)   name=name.replace(ILLEGAL_CHARS_ANY_OS[i],'_');
  if (_isWindows) {
    for (int i=0; i < ILLEGAL_CHARS_WINDOWS.length; i++)     name=name.replace(ILLEGAL_CHARS_WINDOWS[i],'_');
  }
 else   if (_isLinux || _isSolaris) {
    for (int i=0; i < ILLEGAL_CHARS_UNIX.length; i++)     name=name.replace(ILLEGAL_CHARS_UNIX[i],'_');
  }
  return name;
}",0.9579288025889968
4687,"private void tMismatchedVerifyHash(boolean deleteCorrupt) throws Exception {
  shouldRun(MISMATCHED_VERIFY_HASH);
  debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=100;
  uploader1.setRate(RATE);
  RemoteFileDesc rfd1=newRFDWithURN(PORT_1,100,""String_Node_Str"");
  Downloader download=null;
  download=dm.download(new RemoteFileDesc[]{rfd1},false);
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}","private void tMismatchedVerifyHash(boolean deleteCorrupt) throws Exception {
  shouldRun(MISMATCHED_VERIFY_HASH);
  debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=100;
  uploader1.setRate(RATE);
  RemoteFileDesc rfd1=newRFDWithURN(PORT_1,100,""String_Node_Str"");
  Downloader download=null;
  download=dm.download(rfd1.getFileName(),new RemoteFileDesc[]{rfd1},false);
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}",0.9831111111111112
4688,"private void tOverlapCheckWhite(boolean deleteCorrupt) throws Exception {
  shouldRun(OVERLAP_CHECK_WHITE);
  debug(""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=500;
  uploader1.setCorruption(true);
  uploader1.stopAfter(TestFile.length() / 8);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFD(PORT_1,100);
  RemoteFileDesc rfd2=newRFD(PORT_2,100);
  Downloader download=null;
  download=dm.download(new RemoteFileDesc[]{rfd1,rfd2},false);
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}","private void tOverlapCheckWhite(boolean deleteCorrupt) throws Exception {
  shouldRun(OVERLAP_CHECK_WHITE);
  debug(""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=500;
  uploader1.setCorruption(true);
  uploader1.stopAfter(TestFile.length() / 8);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFD(PORT_1,100);
  RemoteFileDesc rfd2=newRFD(PORT_2,100);
  Downloader download=null;
  download=dm.download(rfd1.getFileName(),new RemoteFileDesc[]{rfd1,rfd2},false);
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}",0.9850980392156864
4689,"public void testAddDownload() throws Exception {
  shouldRun(ADD_DOWNLOAD);
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFD(PORT_1,100);
  RemoteFileDesc rfd2=newRFD(PORT_2,100);
  Downloader download=null;
  download=dm.download(new RemoteFileDesc[]{rfd1},false);
  ((ManagedDownloader)download).addDownload(rfd2);
  waitForComplete(download);
  if (isComplete())   debug(""String_Node_Str"" + ""String_Node_Str"");
 else   fail(""String_Node_Str"");
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  assertLessThan(""String_Node_Str"",(TestFile.length() / 2 + FUDGE_FACTOR),u1);
  assertLessThan(""String_Node_Str"",(TestFile.length() / 2 + FUDGE_FACTOR),u2);
}","public void testAddDownload() throws Exception {
  shouldRun(ADD_DOWNLOAD);
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFD(PORT_1,100);
  RemoteFileDesc rfd2=newRFD(PORT_2,100);
  Downloader download=null;
  download=dm.download(rfd1.getFileName(),new RemoteFileDesc[]{rfd1},false);
  ((ManagedDownloader)download).addDownload(rfd2);
  waitForComplete(download);
  if (isComplete())   debug(""String_Node_Str"" + ""String_Node_Str"");
 else   fail(""String_Node_Str"");
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  assertLessThan(""String_Node_Str"",(TestFile.length() / 2 + FUDGE_FACTOR),u1);
  assertLessThan(""String_Node_Str"",(TestFile.length() / 2 + FUDGE_FACTOR),u2);
}",0.9902813299232736
4690,"private void tOverlapCheckGrey(boolean deleteCorrupt) throws Exception {
  shouldRun(OVERLAP_CHECK_GREY);
  debug(""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=500;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE / 100);
  uploader2.setCorruption(true);
  RemoteFileDesc rfd1=newRFD(PORT_1,100);
  RemoteFileDesc rfd2=newRFD(PORT_2,100);
  Downloader download=null;
  download=dm.download(new RemoteFileDesc[]{rfd1,rfd2},false);
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}","private void tOverlapCheckGrey(boolean deleteCorrupt) throws Exception {
  shouldRun(OVERLAP_CHECK_GREY);
  debug(""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=500;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE / 100);
  uploader2.setCorruption(true);
  RemoteFileDesc rfd1=newRFD(PORT_1,100);
  RemoteFileDesc rfd2=newRFD(PORT_2,100);
  Downloader download=null;
  download=dm.download(rfd1.getFileName(),new RemoteFileDesc[]{rfd1,rfd2},false);
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}",0.9847389558232932
4691,"/** 
 * Performs a generic download of the file specified in <tt>rfds</tt>.
 */
private static void tGeneric(RemoteFileDesc[] rfds) throws Exception {
  Downloader download=null;
  download=dm.download(rfds,false);
  waitForComplete(download);
  if (isComplete())   debug(""String_Node_Str"" + ""String_Node_Str"");
 else   fail(""String_Node_Str"");
  IncompleteFileManager ifm=dm.getIncompleteFileManager();
  for (int i=0; i < rfds.length; i++) {
    File incomplete=ifm.getFile(rfds[i]);
    VerifyingFile vf=ifm.getEntry(incomplete);
    assertNull(""String_Node_Str"",vf);
  }
}","/** 
 * Performs a generic download of the file specified in <tt>rfds</tt>.
 */
private static void tGeneric(RemoteFileDesc[] rfds) throws Exception {
  Downloader download=null;
  download=dm.download(rfds[0].getFileName(),rfds,false);
  waitForComplete(download);
  if (isComplete())   debug(""String_Node_Str"" + ""String_Node_Str"");
 else   fail(""String_Node_Str"");
  IncompleteFileManager ifm=dm.getIncompleteFileManager();
  for (int i=0; i < rfds.length; i++) {
    File incomplete=ifm.getFile(rfds[i]);
    VerifyingFile vf=ifm.getEntry(incomplete);
    assertNull(""String_Node_Str"",vf);
  }
}",0.9812606473594548
4692,"/** 
 * Tests that the progress is retained for deserialized downloaders. 
 */
public void testSerializedProgress() throws Exception {
  DownloadManager manager=new DownloadManagerStub();
  FileManager fileman=new FileManagerStub();
  ActivityCallback callback=new ActivityCallbackStub();
  IncompleteFileManager ifm=new IncompleteFileManager();
  RemoteFileDesc rfd=newRFD(""String_Node_Str"");
  File incompleteFile=ifm.getFile(rfd);
  int amountDownloaded=100;
  VerifyingFile vf=new VerifyingFile(false);
  vf.addInterval(new Interval(0,amountDownloaded - 1));
  ifm.addEntry(incompleteFile,vf);
  ManagedDownloader downloader=new ManagedDownloader(new RemoteFileDesc[]{rfd},ifm);
  downloader.initialize(manager,fileman,callback);
  try {
    Thread.sleep(200);
  }
 catch (  InterruptedException e) {
  }
  assertEquals(amountDownloaded,downloader.getAmountRead());
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    ObjectOutputStream out=new ObjectOutputStream(baos);
    out.writeObject(downloader);
    out.flush();
    out.close();
    downloader.stop();
    ObjectInputStream in=new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
    downloader=(ManagedDownloader)in.readObject();
    in.close();
    downloader.initialize(manager,fileman,callback);
  }
 catch (  IOException e) {
    fail(""String_Node_Str"",e);
  }
  try {
    Thread.sleep(200);
  }
 catch (  InterruptedException e) {
  }
  assertEquals(amountDownloaded,downloader.getAmountRead());
  downloader.stop();
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
  }
}","/** 
 * Tests that the progress is retained for deserialized downloaders. 
 */
public void testSerializedProgress() throws Exception {
  DownloadManager manager=new DownloadManagerStub();
  FileManager fileman=new FileManagerStub();
  ActivityCallback callback=new ActivityCallbackStub();
  IncompleteFileManager ifm=new IncompleteFileManager();
  RemoteFileDesc rfd=newRFD(""String_Node_Str"");
  File incompleteFile=ifm.getFile(rfd);
  int amountDownloaded=100;
  VerifyingFile vf=new VerifyingFile(false);
  vf.addInterval(new Interval(0,amountDownloaded - 1));
  ifm.addEntry(incompleteFile,vf);
  ManagedDownloader downloader=new ManagedDownloader(""String_Node_Str"",new RemoteFileDesc[]{rfd},ifm);
  downloader.initialize(manager,fileman,callback);
  try {
    Thread.sleep(200);
  }
 catch (  InterruptedException e) {
  }
  assertEquals(amountDownloaded,downloader.getAmountRead());
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    ObjectOutputStream out=new ObjectOutputStream(baos);
    out.writeObject(downloader);
    out.flush();
    out.close();
    downloader.stop();
    ObjectInputStream in=new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
    downloader=(ManagedDownloader)in.readObject();
    in.close();
    downloader.initialize(manager,fileman,callback);
  }
 catch (  IOException e) {
    fail(""String_Node_Str"",e);
  }
  try {
    Thread.sleep(200);
  }
 catch (  InterruptedException e) {
  }
  assertEquals(amountDownloaded,downloader.getAmountRead());
  downloader.stop();
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
  }
}",0.9944029850746268
4693,"public void testLegacy(){
  ManagedDownloader.unitTest();
}","public void testLegacy(){
}",0.627906976744186
4694,"public TestManagedDownloader(RemoteFileDesc[] files){
  super(files);
}","public TestManagedDownloader(RemoteFileDesc[] files){
  super(files[0].getFileName(),files,new IncompleteFileManager());
}",0.7357512953367875
4695,"/** 
 * Tests that the progress is not 0% when resume button is hit while requerying.  This was caused by the call to cleanup() from tryAllDownloads3() and was reported by Sam Berlin. 
 */
public void testRequeryProgress() throws Exception {
  TestUploader uploader=null;
  ManagedDownloader downloader=null;
  try {
    uploader=new TestUploader(""String_Node_Str"",PORT);
    uploader.stopAfter(100);
    downloader=new ManagedDownloader(new RemoteFileDesc[]{newRFD(""String_Node_Str"")},new IncompleteFileManager());
    downloader.initialize(new DownloadManagerStub(),new FileManagerStub(),new ActivityCallbackStub());
    try {
      Thread.sleep(6000);
    }
 catch (    InterruptedException e) {
    }
    assertEquals(""String_Node_Str"",Downloader.WAITING_FOR_RESULTS,downloader.getState());
    assertEquals(""String_Node_Str"",100,downloader.getAmountRead());
    try {
      downloader.resume();
    }
 catch (    AlreadyDownloadingException e) {
      fail(""String_Node_Str"",e);
    }
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    assertEquals(Downloader.WAITING_FOR_RESULTS,downloader.getState());
    assertEquals(100,downloader.getAmountRead());
  }
  finally {
    if (uploader != null)     uploader.stopThread();
    if (downloader != null)     downloader.stop();
  }
}","/** 
 * Tests that the progress is not 0% when resume button is hit while requerying.  This was caused by the call to cleanup() from tryAllDownloads3() and was reported by Sam Berlin. 
 */
public void testRequeryProgress() throws Exception {
  TestUploader uploader=null;
  ManagedDownloader downloader=null;
  try {
    uploader=new TestUploader(""String_Node_Str"",PORT);
    uploader.stopAfter(100);
    downloader=new ManagedDownloader(""String_Node_Str"",new RemoteFileDesc[]{newRFD(""String_Node_Str"")},new IncompleteFileManager());
    downloader.initialize(new DownloadManagerStub(),new FileManagerStub(),new ActivityCallbackStub());
    try {
      Thread.sleep(6000);
    }
 catch (    InterruptedException e) {
    }
    assertEquals(""String_Node_Str"",Downloader.WAITING_FOR_RESULTS,downloader.getState());
    assertEquals(""String_Node_Str"",100,downloader.getAmountRead());
    try {
      downloader.resume();
    }
 catch (    AlreadyDownloadingException e) {
      fail(""String_Node_Str"",e);
    }
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    assertEquals(Downloader.WAITING_FOR_RESULTS,downloader.getState());
    assertEquals(100,downloader.getAmountRead());
  }
  finally {
    if (uploader != null)     uploader.stopThread();
    if (downloader != null)     downloader.stop();
  }
}",0.9932432432432432
4696,"public synchronized String getFileName(){
  return _fileName;
}","public synchronized String getFileName(){
  if (_fileName != null)   return _fileName;
  String ret=null;
  if (dloaders.size() > 0)   ret=((HTTPDownloader)dloaders.get(0)).getRemoteFileDesc().getFileName();
 else   if (files != null && files.size() > 0)   ret=((RemoteFileDesc)files.get(0)).getFileName();
 else   if (allFiles.length > 0)   ret=allFiles[0].getFileName();
 else   ret=UNKNOWN_FILENAME;
  return CommonUtils.convertFileName(ret);
}",0.2196078431372549
4697,"/** 
 * Removes and returns the RemoteFileDesc with the highest quality in filesLeft.  If two or more entries have the same quality, returns the entry with the highest speed.  
 * @param filesLeft the list of file/locations to choose from, which MUSThave length of at least one.  Each entry MUST be an instance of RemoteFileDesc.  The assumption is that all are ""same"", though this isn't strictly needed.
 * @return the best file/endpoint location 
 */
private static RemoteFileDesc removeBest(List filesLeft){
  Iterator iter=filesLeft.iterator();
  RemoteFileDesc ret=(RemoteFileDesc)iter.next();
  while (iter.hasNext()) {
    RemoteFileDesc rfd=(RemoteFileDesc)iter.next();
    if (rfd.getSHA1Urn() != null && ret.getSHA1Urn() == null)     ret=rfd;
 else     if ((rfd.getSHA1Urn() == null) == (ret.getSHA1Urn() == null)) {
      if (rfd.getQuality() > ret.getQuality())       ret=rfd;
 else       if (rfd.getQuality() == ret.getQuality()) {
        if (rfd.getSpeed() > ret.getSpeed())         ret=rfd;
      }
    }
  }
  filesLeft.remove(ret);
  return ret;
}","/** 
 * Removes and returns the RemoteFileDesc with the highest quality in filesLeft.  If two or more entries have the same quality, returns the entry with the highest speed.  
 * @param filesLeft the list of file/locations to choose from, which MUSThave length of at least one.  Each entry MUST be an instance of RemoteFileDesc.  The assumption is that all are ""same"", though this isn't strictly needed.
 * @return the best file/endpoint location 
 */
private synchronized RemoteFileDesc removeBest(List filesLeft){
  Iterator iter=filesLeft.iterator();
  RemoteFileDesc ret=(RemoteFileDesc)iter.next();
  while (iter.hasNext()) {
    RemoteFileDesc rfd=(RemoteFileDesc)iter.next();
    if (rfd.getSHA1Urn() != null && ret.getSHA1Urn() == null)     ret=rfd;
 else     if ((rfd.getSHA1Urn() == null) == (ret.getSHA1Urn() == null)) {
      if (rfd.getQuality() > ret.getQuality())       ret=rfd;
 else       if (rfd.getQuality() == ret.getQuality()) {
        if (rfd.getSpeed() > ret.getSpeed())         ret=rfd;
      }
    }
  }
  filesLeft.remove(ret);
  return ret;
}",0.99250936329588
4698,"protected void handlePingReply(PingReply reply,ReplyHandler handler){
  super.handlePingReply(reply,handler);
  try {
    if (!Endpoint.isPrivateAddress(reply.getIPBytes()) && notMe(InetAddress.getByName(reply.getIP()),reply.getPort()) && reply.supportsUnicast()) {
synchronized (_guessPongs) {
        _guessPongs.add(reply);
        _guessPongs.notify();
      }
    }
  }
 catch (  UnknownHostException ignored) {
  }
}","protected void handlePingReply(PingReply reply,ReplyHandler handler){
  super.handlePingReply(reply,handler);
  try {
    if (!CommonUtils.isPrivateAddress(reply.getIPBytes()) && notMe(InetAddress.getByName(reply.getIP()),reply.getPort()) && reply.supportsUnicast()) {
synchronized (_guessPongs) {
        _guessPongs.add(reply);
        _guessPongs.notify();
      }
    }
  }
 catch (  UnknownHostException ignored) {
  }
}",0.9775678866587958
4699,"/** 
 * Creates a new MAGNET downloader.  Immediately tries to download from <tt>defaultURLs</tt>, if specified. If that fails, or if defaultURLs does not provide alternate locations, issues a requery with <tt>textQuery</tt> and </tt>urn</tt>, as provided.  (Note that at least one must be non-null.)  If <tt>filename</tt> is specified, it will be used as the name of the complete file; otherwise it will be taken from any search results or guessed from <tt>defaultURLs</tt>.
 * @param manager controls download queuing; passed to superclass
 * @param filemanager shares saved files; passed to superclass
 * @param ifm maintains blocks stored on disk; passed to superclass
 * @param callback notifies GUI of updates; passed to superclass
 * @param urn the hash of the file (exact topic), or null if unknown
 * @param textQuery requery keywords (keyword topic), or null if unknown
 * @param filename the final file name, or null if unknown
 * @param defaultURLs the initial locations to try (exact source), or null if unknown
 * @exception IllegalArgumentException both urn and textQuery are null 
 */
public MagnetDownloader(DownloadManager manager,FileManager filemanager,IncompleteFileManager ifm,ActivityCallback callback,URN urn,String textQuery,String filename,String[] defaultURLs) throws IllegalArgumentException {
  super(new RemoteFileDesc[0],ifm);
  this._textQuery=textQuery;
  this._urn=urn;
  this._filename=filename;
  this._defaultURLs=defaultURLs;
}","/** 
 * Creates a new MAGNET downloader.  Immediately tries to download from <tt>defaultURLs</tt>, if specified. If that fails, or if defaultURLs does not provide alternate locations, issues a requery with <tt>textQuery</tt> and </tt>urn</tt>, as provided.  (Note that at least one must be non-null.)  If <tt>filename</tt> is specified, it will be used as the name of the complete file; otherwise it will be taken from any search results or guessed from <tt>defaultURLs</tt>.
 * @param manager controls download queuing; passed to superclass
 * @param filemanager shares saved files; passed to superclass
 * @param ifm maintains blocks stored on disk; passed to superclass
 * @param callback notifies GUI of updates; passed to superclass
 * @param urn the hash of the file (exact topic), or null if unknown
 * @param textQuery requery keywords (keyword topic), or null if unknown
 * @param filename the final file name, or null if unknown
 * @param defaultURLs the initial locations to try (exact source), or null if unknown
 */
public MagnetDownloader(DownloadManager manager,FileManager filemanager,IncompleteFileManager ifm,ActivityCallback callback,URN urn,String textQuery,String filename,String[] defaultURLs){
  super(""String_Node_Str"",new RemoteFileDesc[0],ifm);
  this._textQuery=textQuery;
  this._urn=urn;
  this._filename=filename;
  this._defaultURLs=defaultURLs;
}",0.9504045022863172
4700,"public synchronized String getFileName(){
  String ret=null;
  if (dloaders.size() > 0)   ret=((HTTPDownloader)dloaders.get(0)).getRemoteFileDesc().getFileName();
 else   if (files != null && files.size() > 0)   ret=((RemoteFileDesc)files.get(0)).getFileName();
 else   if (allFiles.length > 0)   ret=allFiles[0].getFileName();
 else   ret=UNKNOWN_FILENAME;
  return CommonUtils.convertFileName(ret);
}","public synchronized String getFileName(){
  return _fileName;
}",0.2580645161290322
4701,"/** 
 * Stub constructor for testing only.  Does not actually start downloads. 
 */
protected ManagedDownloader(RemoteFileDesc[] allFiles){
  this.allFiles=allFiles;
}","/** 
 * Creates a new ManagedDownload to download the given files.  The download does not start until initialize(..) is called, nor is it safe to call any other methods until that point.
 * @param name the name of the file on disk -- this can change slightlyto eliminate any characters that are problematic on certain  platforms
 * @param files the list of files to get.  This stops after ANY of thefiles is downloaded.
 * @param incompleteFileManager the repository of incomplete files forresuming
 */
public ManagedDownloader(String name,RemoteFileDesc[] files,IncompleteFileManager ifc){
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name.length() == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (files == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (files.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (ifc == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  _fileName=CommonUtils.convertFileName(name);
  this.allFiles=files;
  this.incompleteFileManager=ifc;
}",0.0839160839160839
4702,"/** 
 * Creates a new RequeryDownloader - a RequeryDownloader has no files initially associated with it, but it may have them later (via calls to addDownload().  Non-blocking.     
 * @param incompleteFileManager the repository of incomplete files forresuming
 * @param add the keywords to requery with
 */
public RequeryDownloader(IncompleteFileManager incompleteFileManager,AutoDownloadDetails add){
  super(new RemoteFileDesc[0],incompleteFileManager);
  Assert.that(add != null,""String_Node_Str"");
  _add=add;
}","/** 
 * Creates a new RequeryDownloader - a RequeryDownloader has no files initially associated with it, but it may have them later (via calls to addDownload().  Non-blocking.     
 * @param incompleteFileManager the repository of incomplete files forresuming
 * @param add the keywords to requery with
 */
public RequeryDownloader(IncompleteFileManager incompleteFileManager,AutoDownloadDetails add){
  super(""String_Node_Str"",new RemoteFileDesc[0],incompleteFileManager);
  Assert.that(add != null,""String_Node_Str"");
  _add=add;
}",0.982824427480916
4703,"/** 
 * Overrides ManagedDownloader to allow any RemoteFileDesc that matches this' keywords.  If a match has already been found and a download has been started, only allows those RemoteFileDesc's that actually match  the download.
 */
protected boolean allowAddition(RemoteFileDesc other){
  if (_hasFile)   return super.allowAddition(other);
 else {
synchronized (_add) {
      if (_add.addDownload(other)) {
        _add.commitDownload(other);
        _hasFile=true;
        return true;
      }
 else {
        return false;
      }
    }
  }
}","/** 
 * Overrides ManagedDownloader to allow any RemoteFileDesc that matches this' keywords.  If a match has already been found and a download has been started, only allows those RemoteFileDesc's that actually match  the download.
 */
protected boolean allowAddition(RemoteFileDesc other){
  if (_hasFile)   return super.allowAddition(other);
 else {
synchronized (_add) {
      if (_add.addDownload(other)) {
        _add.commitDownload(other);
        _hasFile=true;
        _fileName=CommonUtils.convertFileName(other.getFileName());
        return true;
      }
 else {
        return false;
      }
    }
  }
}",0.9225473321858864
4704,"/** 
 * Creates a RequeryDownloader to finish downloading incompleteFile.  This constructor has preconditions on several parameters; putting the burden on the caller makes the method easier to implement, since the superclass constructor immediately starts a download thread.
 * @param incompleteFile the incomplete file to resume to, whichMUST be the result of IncompleteFileManager.getFile.
 * @param name the name of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedName(incompleteFile)
 * @param size the size of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedSize(incompleteFile) 
 */
public ResumeDownloader(IncompleteFileManager incompleteFileManager,File incompleteFile,String name,int size){
  super(new RemoteFileDesc[0],incompleteFileManager);
  this._incompleteFile=incompleteFile;
  this._name=name;
  this._size=size;
  this._hash=incompleteFileManager.getCompletedHash(incompleteFile);
}","/** 
 * Creates a RequeryDownloader to finish downloading incompleteFile.  This constructor has preconditions on several parameters; putting the burden on the caller makes the method easier to implement, since the superclass constructor immediately starts a download thread.
 * @param incompleteFile the incomplete file to resume to, whichMUST be the result of IncompleteFileManager.getFile.
 * @param name the name of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedName(incompleteFile)
 * @param size the size of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedSize(incompleteFile) 
 */
public ResumeDownloader(IncompleteFileManager incompleteFileManager,File incompleteFile,String name,int size){
  super(name,new RemoteFileDesc[0],incompleteFileManager);
  this._incompleteFile=incompleteFile;
  this._name=name;
  this._size=size;
  this._hash=incompleteFileManager.getCompletedHash(incompleteFile);
}",0.997421351211965
4705,"/** 
 * Tests URN queries from the leaf.
 */
public void testUrnQueryFromLeaf() throws Exception {
  QueryRequest qr=QueryRequest.createRequery(HugeTestUtils.SHA1);
  LEAF.send(qr);
  LEAF.flush();
  Message m=ULTRAPEER_1.receive(TIMEOUT);
  assertQuery(m);
  QueryRequest qrRead=(QueryRequest)m;
  assertTrue(""String_Node_Str"",Arrays.equals(qr.getGUID(),qrRead.getGUID()));
  m=ULTRAPEER_2.receive(TIMEOUT);
  assertQuery(m);
  qrRead=(QueryRequest)m;
  assertTrue(""String_Node_Str"",Arrays.equals(qr.getGUID(),qrRead.getGUID()));
  qr=QueryRequest.createRequery(HugeTestUtils.SHA1,(byte)2);
  LEAF.send(qr);
  LEAF.flush();
  assertTrue(""String_Node_Str"",!drainQuery(ULTRAPEER_2));
  assertTrue(""String_Node_Str"",!drainQuery(ULTRAPEER_1));
}","/** 
 * Tests URN queries from the leaf.
 */
public void testUrnQueryFromLeaf() throws Exception {
  QueryRequest qr=QueryRequest.createRequery(HugeTestUtils.SHA1);
  LEAF.send(qr);
  LEAF.flush();
  Message m=ULTRAPEER_1.receive(TIMEOUT);
  assertQuery(m);
  QueryRequest qrRead=(QueryRequest)m;
  assertTrue(""String_Node_Str"",Arrays.equals(qr.getGUID(),qrRead.getGUID()));
  m=ULTRAPEER_2.receive(TIMEOUT);
  assertQuery(m);
  qrRead=(QueryRequest)m;
  assertTrue(""String_Node_Str"",Arrays.equals(qr.getGUID(),qrRead.getGUID()));
  qr=QueryRequest.createRequery(HugeTestUtils.SHA1,(byte)2);
  LEAF.send(qr);
  LEAF.flush();
  assertTrue(""String_Node_Str"",!drain(ULTRAPEER_2));
  assertTrue(""String_Node_Str"",!drain(ULTRAPEER_1));
}",0.9932157394843962
4706,"public void testMisroutedPong() throws Exception {
  drain(ULTRAPEER_2);
  drain(LEAF);
  Message m=new PingReply(GUID.makeGuid(),(byte)7,6399,new byte[4],0,0,false);
  ULTRAPEER_1.send(m);
  ULTRAPEER_1.flush();
  assertTrue(""String_Node_Str"",!drain(ULTRAPEER_2));
  assertTrue(""String_Node_Str"",!drain(LEAF));
}","/** 
 * Tests to make sure that pongs that had no entry in the routing tables (that had no corresponding ping) are not forwarded.
 */
public void testMisroutedPong() throws Exception {
  Message m=new PingReply(GUID.makeGuid(),(byte)6,7399,new byte[4],0,0,false);
  ULTRAPEER_1.send(m);
  ULTRAPEER_1.flush();
  assertTrue(""String_Node_Str"",!drain(ULTRAPEER_2));
  assertTrue(""String_Node_Str"",!drain(LEAF));
}",0.7524204702627939
4707,"public void testUltrapeerPong() throws Exception {
  drain(ULTRAPEER_2);
  drain(LEAF);
  byte[] guid=GUID.makeGuid();
  byte[] ip={(byte)18,(byte)239,(byte)0,(byte)143};
  Message m=new PingReply(guid,(byte)7,6399,ip,0,0,true);
  ULTRAPEER_1.send(m);
  ULTRAPEER_1.flush();
  m=LEAF.receive(TIMEOUT);
  assertTrue(""String_Node_Str"",m instanceof PingReply);
  assertEquals(""String_Node_Str"",6399,((PingReply)m).getPort());
  assertTrue(""String_Node_Str"",!drain(ULTRAPEER_2));
}","/** 
 * Tests that Ultrapeer pongs are correctly sent to leaves to provide them with distributed host data.
 */
public void testUltrapeerPong() throws Exception {
  byte[] guid=GUID.makeGuid();
  byte[] ip={(byte)18,(byte)239,(byte)0,(byte)143};
  Message m=new PingReply(guid,(byte)7,7399,ip,0,0,true);
  ULTRAPEER_1.send(m);
  ULTRAPEER_1.flush();
  m=LEAF.receive(TIMEOUT);
  assertTrue(""String_Node_Str"",m instanceof PingReply);
  assertEquals(""String_Node_Str"",7399,((PingReply)m).getPort());
  assertTrue(""String_Node_Str"",!drain(ULTRAPEER_2));
}",0.8513119533527697
4708,"private static FileDesc[] createFileDescs(){
  File[] files=CommonUtils.getResourceFile(FILE_PATH).listFiles();
  FileDesc[] fileDescs=new FileDesc[files.length];
  for (int i=0; i < files.length; i++) {
    Set urns=FileDesc.calculateAndCacheURN(files[i]);
    fileDescs[i]=new FileDesc(files[i],urns,i);
  }
  return fileDescs;
}","private static FileDesc[] createFileDescs(){
  File path=CommonUtils.getResourceFile(FILE_PATH);
  File[] files=path.listFiles(new FileFilter(){
    public boolean accept(    File file){
      return !file.isDirectory();
    }
  }
);
  FileDesc[] fileDescs=new FileDesc[files.length];
  for (int i=0; i < files.length; i++) {
    Set urns=FileDesc.calculateAndCacheURN(files[i]);
    fileDescs[i]=new FileDesc(files[i],urns,i);
  }
  return fileDescs;
}",0.7959183673469388
4709,"public void testDisallow(){
  guid[0]=(byte)0x41;
  guid[1]=(byte)0x61;
  guid[2]=(byte)0x42;
  guid[3]=(byte)0x62;
  guid[4]=(byte)0x5A;
  QueryRequest query=QueryRequest.createQuery(""String_Node_Str"",(byte)3);
  assertTrue(!filter.allow(query));
}","public void testDisallow(){
  guid[0]=(byte)0x41;
  guid[1]=(byte)0x61;
  guid[2]=(byte)0x42;
  guid[3]=(byte)0x62;
  guid[4]=(byte)0x5A;
  QueryRequest query=QueryRequest.createQuery(guid,""String_Node_Str"",""String_Node_Str"");
  assertTrue(!filter.allow(query));
}",0.9434697855750488
4710,"public void testAllow1(){
  guid[0]=(byte)0x41;
  guid[1]=(byte)0x61;
  guid[2]=(byte)0x42;
  guid[3]=(byte)0x62;
  guid[4]=(byte)0x5B;
  QueryRequest query=QueryRequest.createQuery(""String_Node_Str"",(byte)3);
  assertTrue(filter.allow(query));
}","public void testAllow1(){
  guid[0]=(byte)0x41;
  guid[1]=(byte)0x61;
  guid[2]=(byte)0x42;
  guid[3]=(byte)0x62;
  guid[4]=(byte)0x5B;
  QueryRequest query=QueryRequest.createQuery(guid,""String_Node_Str"",""String_Node_Str"");
  assertTrue(filter.allow(query));
}",0.9428007889546351
4711,"public void testAllow2(){
  guid[0]=(byte)0x42;
  guid[1]=(byte)0x61;
  guid[2]=(byte)0x42;
  guid[3]=(byte)0x62;
  guid[4]=(byte)0x5A;
  QueryRequest query=QueryRequest.createQuery(""String_Node_Str"",(byte)3);
  assertTrue(filter.allow(query));
}","public void testAllow2(){
  guid[0]=(byte)0x42;
  guid[1]=(byte)0x61;
  guid[2]=(byte)0x42;
  guid[3]=(byte)0x62;
  guid[4]=(byte)0x5A;
  QueryRequest query=QueryRequest.createQuery(guid,""String_Node_Str"",""String_Node_Str"");
  assertTrue(filter.allow(query));
}",0.9428007889546351
4712,"/** 
 * Generic serialization testing routing. 
 * @param file the serialized ResumeDownloader to read
 * @param expectHash true iff there should be a hash in the downloader 
 */
private void tSerialization(String file,boolean expectHash) throws IOException, ClassNotFoundException {
  ObjectInputStream in=new ObjectInputStream(new FileInputStream(CommonUtils.getResourceFile(filePath + file)));
  ResumeDownloader rd=(ResumeDownloader)in.readObject();
  QueryRequest qr=rd.newRequery(0);
  assertEquals(""String_Node_Str"",qr.getQuery());
  if (expectHash) {
    assertEquals(1,qr.getQueryUrns().size());
    assertEquals(hash,qr.getQueryUrns().iterator().next());
  }
 else {
    assertEquals(0,qr.getQueryUrns().size());
  }
}","/** 
 * Generic serialization testing routing. 
 * @param file the serialized ResumeDownloader to read
 * @param expectHash true iff there should be a hash in the downloader 
 */
private void tSerialization(String file,boolean expectHash) throws IOException, ClassNotFoundException {
  ObjectInputStream in=new ObjectInputStream(new FileInputStream(CommonUtils.getResourceFile(filePath + file)));
  ResumeDownloader rd=(ResumeDownloader)in.readObject();
  QueryRequest qr=rd.newRequery(1);
  if (expectHash) {
    assertEquals(""String_Node_Str"",1,qr.getQueryUrns().size());
    assertEquals(""String_Node_Str"",hash,qr.getQueryUrns().iterator().next());
    assertEquals(""String_Node_Str"",""String_Node_Str"",qr.getQuery());
  }
 else {
    assertEquals(""String_Node_Str"",0,qr.getQueryUrns().size());
    assertEquals(""String_Node_Str"",""String_Node_Str"",qr.getQuery());
  }
}",0.8430268918073797
4713,"/** 
 * Tests that the progress is not 0% while requerying. This issue was reported by Sam Berlin. 
 */
public void testRequeryProgress() throws Exception {
  ResumeDownloader downloader=newResumeDownloader();
  while (downloader.getState() != Downloader.WAITING_FOR_RESULTS) {
    if (downloader.getState() != Downloader.QUEUED)     assertEquals(Downloader.WAITING_FOR_RESULTS,downloader.getState());
    try {
      Thread.sleep(200);
    }
 catch (    InterruptedException e) {
    }
  }
  assertEquals(Downloader.WAITING_FOR_RESULTS,downloader.getState());
  assertEquals(amountDownloaded,downloader.getAmountRead());
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  ObjectOutputStream out=new ObjectOutputStream(baos);
  out.writeObject(downloader);
  out.flush();
  out.close();
  downloader.stop();
  ObjectInputStream in=new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
  downloader=(ResumeDownloader)in.readObject();
  in.close();
  downloader.initialize(new DownloadManagerStub(),new FileManagerStub(),new ActivityCallbackStub());
  try {
    Thread.sleep(200);
  }
 catch (  InterruptedException e) {
  }
  assertEquals(Downloader.WAITING_FOR_RESULTS,downloader.getState());
  assertEquals(amountDownloaded,downloader.getAmountRead());
  downloader.stop();
}","/** 
 * Tests that the progress is not 0% while requerying. This issue was reported by Sam Berlin. 
 */
public void testRequeryProgress() throws Exception {
  ResumeDownloader downloader=newResumeDownloader();
  while (downloader.getState() != Downloader.WAITING_FOR_RESULTS) {
    if (downloader.getState() != Downloader.QUEUED)     assertEquals(Downloader.WAITING_FOR_RESULTS,downloader.getState());
    Thread.sleep(200);
  }
  assertEquals(Downloader.WAITING_FOR_RESULTS,downloader.getState());
  assertEquals(amountDownloaded,downloader.getAmountRead());
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  ObjectOutputStream out=new ObjectOutputStream(baos);
  out.writeObject(downloader);
  out.flush();
  out.close();
  downloader.stop();
  ObjectInputStream in=new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));
  downloader=(ResumeDownloader)in.readObject();
  in.close();
  downloader.initialize(new DownloadManagerStub(),new FileManagerStub(),new ActivityCallbackStub());
  try {
    Thread.sleep(200);
  }
 catch (  InterruptedException e) {
  }
  assertEquals(Downloader.WAITING_FOR_RESULTS,downloader.getState());
  assertEquals(amountDownloaded,downloader.getAmountRead());
  downloader.stop();
}",0.975571315996848
4714,"/** 
 * Tests to make sure that queries are still created correctly if some of the potential data is not filled in, such as XML vs. no XML, URN vs. no URN, etc.
 */
public void testStillAcceptedIfOnlyPartsAreEmpty() throws Exception {
  QueryRequest qr=null;
  qr=QueryRequest.createQuery(""String_Node_Str"");
  qr=QueryRequest.createQuery(""String_Node_Str"",""String_Node_Str"");
  qr=QueryRequest.createRequery(HugeTestUtils.SHA1);
  byte[] payload=new byte[2 + 3];
  payload[2]=(byte)65;
  qr=QueryRequest.createNetworkQuery(new byte[16],(byte)0,(byte)0,payload);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  baos.write((short)2);
  baos.write(0);
  baos.write(0);
  baos.write(HugeTestUtils.URNS[0].toString().getBytes());
  baos.write(0);
  qr=QueryRequest.createNetworkQuery(new byte[16],(byte)0,(byte)0,payload);
}","/** 
 * Tests to make sure that queries are still created correctly if some of the potential data is not filled in, such as XML vs. no XML, URN vs. no URN, etc.
 */
public void testStillAcceptedIfOnlyPartsAreEmpty() throws Exception {
  QueryRequest qr=null;
  byte[] payload=new byte[2 + 3];
  payload[2]=(byte)65;
  qr=QueryRequest.createNetworkQuery(new byte[16],(byte)0,(byte)0,payload);
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  baos.write((short)2);
  baos.write(0);
  baos.write(0);
  baos.write(HugeTestUtils.URNS[0].toString().getBytes());
  baos.write(0);
  qr=QueryRequest.createNetworkQuery(new byte[16],(byte)0,(byte)0,payload);
}",0.8854655056932351
4715,"/** 
 * Writes the specified query out to a stream and then reads the stream back in to make sure we end up with the same query we started with.
 * @param qr the query to check
 */
private void runIOChecks(QueryRequest qr){
  QueryRequest storedQuery=qr;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    qr.write(baos);
    baos.flush();
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
  ByteArrayInputStream bais=new ByteArrayInputStream(baos.toByteArray());
  QueryRequest qrTest=null;
  try {
    qrTest=(QueryRequest)Message.read(bais);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}","/** 
 * Writes the specified query out to a stream and then reads the stream back in to make sure we end up with the same query we started with.
 * @param qr the query to check
 */
private void runIOChecks(QueryRequest qr){
  QueryRequest storedQuery=qr;
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    qr.write(baos);
    baos.flush();
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
  ByteArrayInputStream bais=new ByteArrayInputStream(baos.toByteArray());
  QueryRequest qrTest=null;
  try {
    qrTest=(QueryRequest)Message.read(bais);
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
  assertEquals(""String_Node_Str"",storedQuery,qrTest);
}",0.962809917355372
4716,"/** 
 * Constructs and launches a new <tt>Backend</tt>.
 * @param reject true to launch a reject server
 */
private Backend(boolean reject) throws IOException {
  super(""String_Node_Str"");
  System.out.println(reject ? ""String_Node_Str"" : ""String_Node_Str"");
  int port=(reject ? REJECT_PORT : PORT);
  int shutdownPort=(reject ? SHUTDOWN_REJECT_PORT : SHUTDOWN_PORT);
  ServerSocket shutdownSocket=null;
  try {
    shutdownSocket=new ServerSocket(shutdownPort);
    preSetUp();
    setStandardSettings(port,reject);
    populateSharedDirectory();
    ROUTER_SERVICE=new RouterService(new ActivityCallbackStub());
    ROUTER_SERVICE.start();
    if (!reject)     ROUTER_SERVICE.connect();
    try {
      Thread.sleep(2000);
    }
 catch (    InterruptedException e) {
    }
    if (ROUTER_SERVICE.getPort() != port) {
      throw new IOException(""String_Node_Str"");
    }
    waitForShutdown(shutdownSocket);
    doShutdown(reject,""String_Node_Str"");
  }
 catch (  Exception ex) {
    ErrorService.error(ex);
    doShutdown(reject,""String_Node_Str"");
  }
 finally {
    try {
      if (shutdownSocket != null)       shutdownSocket.close();
    }
 catch (    IOException ex2) {
    }
    try {
      postTearDown();
    }
  finally {
      deleteFiles(_baseDir,true);
    }
  }
}","/** 
 * Constructs and launches a new <tt>Backend</tt>.
 * @param reject true to launch a reject server
 */
private Backend(boolean reject) throws IOException {
  super(""String_Node_Str"");
  System.out.println(reject ? ""String_Node_Str"" : ""String_Node_Str"");
  int port=(reject ? REJECT_PORT : PORT);
  int shutdownPort=(reject ? SHUTDOWN_REJECT_PORT : SHUTDOWN_PORT);
  ServerSocket shutdownSocket=null;
  try {
    shutdownSocket=new ServerSocket(shutdownPort);
    preSetUp();
    setStandardSettings(port,reject);
    populateSharedDirectory();
    ROUTER_SERVICE=new RouterService(new ActivityCallbackStub());
    ROUTER_SERVICE.start();
    if (!reject)     ROUTER_SERVICE.connect();
    try {
      Thread.sleep(2000);
    }
 catch (    InterruptedException e) {
    }
    if (ROUTER_SERVICE.getPort() != port) {
      throw new IOException(""String_Node_Str"");
    }
    waitForShutdown(shutdownSocket);
    doShutdown(reject,""String_Node_Str"");
  }
 catch (  Exception ex) {
    ErrorService.error(ex);
    doShutdown(reject,""String_Node_Str"");
  }
 finally {
    try {
      if (shutdownSocket != null)       shutdownSocket.close();
    }
 catch (    IOException ex2) {
    }
    try {
      postTearDown();
    }
  finally {
      cleanFiles(_baseDir,true);
    }
  }
}",0.9957014458772958
4717,"/** 
 * Tests requests that follow the traditional ""get"" syntax but that also include the X-Gnutella-Content-URN header.  In these requests, both the URN and the file name and index are correct, so a valid result is expected.
 */
public void testTraditionalGetWithContentUrn(){
  for (int i=0; i < _fileManager.getNumFiles(); i++) {
    FileDesc fd=_fileManager.get(i);
    sendRequestThatShouldSucceed(HTTPRequestMethod.GET,""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str"",fd);
    sendRequestThatShouldSucceed(HTTPRequestMethod.HEAD,""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str"",fd);
  }
}","/** 
 * Tests requests that follow the traditional ""get"" syntax but that also include the X-Gnutella-Content-URN header.  In these requests, both the URN and the file name and index are correct, so a valid result is expected.
 */
public void testTraditionalGetWithContentUrn(){
  for (int i=0; i < RouterService.getFileManager().getNumFiles(); i++) {
    FileDesc fd=RouterService.getFileManager().get(i);
    sendRequestThatShouldSucceed(HTTPRequestMethod.GET,""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str"",fd);
    sendRequestThatShouldSucceed(HTTPRequestMethod.HEAD,""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str"",fd);
  }
}",0.9680232558139537
4718,"/** 
 * Sends an HTTP request that should succeed and send back all of the expected headers.
 */
private void sendRequestThatShouldSucceed(HTTPRequestMethod method,String request,FileDesc fd){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    baos.write(request.getBytes());
    Socket sock=new TestSocket(new ByteArrayInputStream(baos.toByteArray()));
    _uploadManager.acceptUpload(method,sock);
    String reply=sock.getOutputStream().toString();
    StringTokenizer st=new StringTokenizer(reply,""String_Node_Str"");
    boolean contentUrnHeaderPresent=false;
    boolean OKPresent=false;
    assertTrue(""String_Node_Str"" + fd,st.countTokens() > 0);
    while (st.hasMoreTokens()) {
      String curString=st.nextToken();
      if (HTTPHeaderName.ALT_LOCATION.matchesStartOfString(curString)) {
        continue;
      }
 else       if (HTTPHeaderName.GNUTELLA_CONTENT_URN.matchesStartOfString(curString)) {
        URN curUrn=null;
        try {
          String tmpString=HTTPUtils.extractHeaderValue(curString);
          curUrn=URN.createSHA1Urn(tmpString);
        }
 catch (        IOException e) {
          assertTrue(""String_Node_Str"" + e,false);
        }
        assertEquals(HTTPHeaderName.GNUTELLA_CONTENT_URN.toString() + ""String_Node_Str"" + fd,fd.getSHA1Urn(),curUrn);
        contentUrnHeaderPresent=true;
      }
 else       if (HTTPHeaderName.CONTENT_RANGE.matchesStartOfString(curString)) {
        continue;
      }
 else       if (HTTPHeaderName.CONTENT_TYPE.matchesStartOfString(curString)) {
        continue;
      }
 else       if (HTTPHeaderName.CONTENT_LENGTH.matchesStartOfString(curString)) {
        String value=HTTPUtils.extractHeaderValue(curString);
        assertEquals(""String_Node_Str"" + fd,(int)fd.getSize(),Integer.parseInt(value));
      }
 else       if (HTTPHeaderName.SERVER.matchesStartOfString(curString)) {
        continue;
      }
 else       if (curString.equals(""String_Node_Str"")) {
        OKPresent=true;
      }
    }
    assertTrue(""String_Node_Str"" + fd,OKPresent);
    assertTrue(""String_Node_Str"" + fd + ""String_Node_Str""+ ""String_Node_Str""+ reply,contentUrnHeaderPresent);
  }
 catch (  IOException e) {
    assertTrue(""String_Node_Str"" + e,false);
  }
}","/** 
 * Sends an HTTP request that should succeed and send back all of the expected headers.
 */
private void sendRequestThatShouldSucceed(HTTPRequestMethod method,String request,FileDesc fd){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    baos.write(request.getBytes());
    Socket sock=new TestSocket(new ByteArrayInputStream(baos.toByteArray()));
    RouterService.getUploadManager().acceptUpload(method,sock);
    String reply=sock.getOutputStream().toString();
    StringTokenizer st=new StringTokenizer(reply,""String_Node_Str"");
    boolean contentUrnHeaderPresent=false;
    boolean OKPresent=false;
    assertTrue(""String_Node_Str"" + fd,st.countTokens() > 0);
    while (st.hasMoreTokens()) {
      String curString=st.nextToken();
      if (HTTPHeaderName.ALT_LOCATION.matchesStartOfString(curString)) {
        continue;
      }
 else       if (HTTPHeaderName.GNUTELLA_CONTENT_URN.matchesStartOfString(curString)) {
        URN curUrn=null;
        try {
          String tmpString=HTTPUtils.extractHeaderValue(curString);
          curUrn=URN.createSHA1Urn(tmpString);
        }
 catch (        IOException e) {
          assertTrue(""String_Node_Str"" + e,false);
        }
        assertEquals(HTTPHeaderName.GNUTELLA_CONTENT_URN.toString() + ""String_Node_Str"" + fd,fd.getSHA1Urn(),curUrn);
        contentUrnHeaderPresent=true;
      }
 else       if (HTTPHeaderName.CONTENT_RANGE.matchesStartOfString(curString)) {
        continue;
      }
 else       if (HTTPHeaderName.CONTENT_TYPE.matchesStartOfString(curString)) {
        continue;
      }
 else       if (HTTPHeaderName.CONTENT_LENGTH.matchesStartOfString(curString)) {
        String value=HTTPUtils.extractHeaderValue(curString);
        assertEquals(""String_Node_Str"" + fd,(int)fd.getSize(),Integer.parseInt(value));
      }
 else       if (HTTPHeaderName.SERVER.matchesStartOfString(curString)) {
        continue;
      }
 else       if (curString.equals(""String_Node_Str"")) {
        OKPresent=true;
      }
    }
    assertTrue(""String_Node_Str"" + fd,OKPresent);
    assertTrue(""String_Node_Str"" + fd + ""String_Node_Str""+ ""String_Node_Str""+ reply,contentUrnHeaderPresent);
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}",0.985134235633459
4719,"/** 
 * Tests requests that follow the traditional ""get"" syntax to make sure that  the X-Gnutella-Content-URN header is always returned.
 */
public void testTraditionalGetForReturnedUrn(){
  for (int i=0; i < _fileManager.getNumFiles(); i++) {
    FileDesc fd=_fileManager.get(i);
    String request=""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str""+ HTTPHeaderName.GNUTELLA_CONTENT_URN.httpStringValue()+ ""String_Node_Str""+ fd.getSHA1Urn()+ ""String_Node_Str"";
    sendRequestThatShouldSucceed(HTTPRequestMethod.GET,request,fd);
    sendRequestThatShouldSucceed(HTTPRequestMethod.HEAD,request,fd);
  }
}","/** 
 * Tests requests that follow the traditional ""get"" syntax to make sure that  the X-Gnutella-Content-URN header is always returned.
 */
public void testTraditionalGetForReturnedUrn(){
  for (int i=0; i < RouterService.getFileManager().getNumFiles(); i++) {
    FileDesc fd=RouterService.getFileManager().get(i);
    String request=""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str""+ HTTPHeaderName.GNUTELLA_CONTENT_URN.httpStringValue()+ ""String_Node_Str""+ fd.getSHA1Urn()+ ""String_Node_Str"";
    sendRequestThatShouldSucceed(HTTPRequestMethod.GET,request,fd);
    sendRequestThatShouldSucceed(HTTPRequestMethod.HEAD,request,fd);
  }
}",0.9665653495440728
4720,"/** 
 * Tests get requests that follow the traditional Gnutella get format and that include an invalid content URN header -- these should fail with error code 404.
 */
public void testTraditionalGetWithInvalidContentUrn(){
  for (int i=0; i < _fileManager.getNumFiles(); i++) {
    FileDesc fd=_fileManager.get(i);
    String request=""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str""+ HTTPHeaderName.GNUTELLA_CONTENT_URN.httpStringValue()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    sendRequestThatShouldFail(HTTPRequestMethod.GET,request,fd,STATUS_404);
    sendRequestThatShouldFail(HTTPRequestMethod.HEAD,request,fd,STATUS_404);
  }
}","/** 
 * Tests get requests that follow the traditional Gnutella get format and that include an invalid content URN header -- these should fail with error code 404.
 */
public void testTraditionalGetWithInvalidContentUrn(){
  for (int i=0; i < RouterService.getFileManager().getNumFiles(); i++) {
    FileDesc fd=RouterService.getFileManager().get(i);
    String request=""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str""+ HTTPHeaderName.GNUTELLA_CONTENT_URN.httpStringValue()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    sendRequestThatShouldFail(HTTPRequestMethod.GET,request,fd,STATUS_404);
    sendRequestThatShouldFail(HTTPRequestMethod.HEAD,request,fd,STATUS_404);
  }
}",0.9690140845070424
4721,"/** 
 * Tests requests that follow the traditional ""get"" syntax to make sure that  the X-Gnutella-Content-URN header is always returned.
 */
public void testLimitReachedRequests(){
  int maxUploads=SettingsManager.instance().getMaxUploads();
  SettingsManager.instance().setMaxUploads(0);
  for (int i=0; i < _fileManager.getNumFiles(); i++) {
    FileDesc fd=_fileManager.get(i);
    String request=""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str""+ HTTPHeaderName.GNUTELLA_CONTENT_URN.httpStringValue()+ ""String_Node_Str""+ fd.getSHA1Urn()+ ""String_Node_Str"";
    sendRequestThatShouldFail(HTTPRequestMethod.GET,request,fd,STATUS_503);
    sendRequestThatShouldFail(HTTPRequestMethod.HEAD,request,fd,STATUS_503);
  }
  SettingsManager.instance().setMaxUploads(maxUploads);
}","/** 
 * Tests requests that follow the traditional ""get"" syntax to make sure that  the X-Gnutella-Content-URN header is always returned.
 */
public void testLimitReachedRequests(){
  int maxUploads=SettingsManager.instance().getMaxUploads();
  SettingsManager.instance().setMaxUploads(0);
  for (int i=0; i < RouterService.getFileManager().getNumFiles(); i++) {
    FileDesc fd=RouterService.getFileManager().get(i);
    String request=""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str""+ HTTPHeaderName.GNUTELLA_CONTENT_URN.httpStringValue()+ ""String_Node_Str""+ fd.getSHA1Urn()+ ""String_Node_Str"";
    sendRequestThatShouldFail(HTTPRequestMethod.GET,request,fd,STATUS_503);
  }
  SettingsManager.instance().setMaxUploads(maxUploads);
}",0.8288060644346178
4722,"/** 
 * Tests to make sure that invalid traditional Gnutella get requests with matching X-Gnutella-Content-URN header values also fail with 404.
 */
public void testInvalidTraditionalGetWithValidContentUrn(){
  for (int i=0; i < _fileManager.getNumFiles(); i++) {
    FileDesc fd=_fileManager.get(i);
    String request=""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ HTTPHeaderName.GNUTELLA_CONTENT_URN.httpStringValue()+ ""String_Node_Str""+ fd.getSHA1Urn();
    sendRequestThatShouldFail(HTTPRequestMethod.GET,request,fd,STATUS_404);
    sendRequestThatShouldFail(HTTPRequestMethod.HEAD,request,fd,STATUS_404);
  }
}","/** 
 * Tests to make sure that invalid traditional Gnutella get requests with matching X-Gnutella-Content-URN header values also fail with 404.
 */
public void testInvalidTraditionalGetWithValidContentUrn(){
  for (int i=0; i < RouterService.getFileManager().getNumFiles(); i++) {
    FileDesc fd=RouterService.getFileManager().get(i);
    String request=""String_Node_Str"" + fd.getIndex() + ""String_Node_Str""+ fd.getName()+ ""String_Node_Str""+ ""String_Node_Str""+ HTTPHeaderName.GNUTELLA_CONTENT_URN.httpStringValue()+ ""String_Node_Str""+ fd.getSHA1Urn();
    sendRequestThatShouldFail(HTTPRequestMethod.GET,request,fd,STATUS_404);
    sendRequestThatShouldFail(HTTPRequestMethod.HEAD,request,fd,STATUS_404);
  }
}",0.968299711815562
4723,"protected void setUp(){
  _testDir=new File(CommonUtils.getCurrentDirectory(),""String_Node_Str"");
  if (!_testDir.isDirectory()) {
    _testDir=new File(CommonUtils.getCurrentDirectory(),""String_Node_Str"");
  }
  if (!_testDir.isDirectory()) {
    _testDir=new File(CommonUtils.getCurrentDirectory(),""String_Node_Str"");
  }
  if (!_testDir.isDirectory()) {
    _testDir=new File(CommonUtils.getCurrentDirectory(),""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",_testDir.isDirectory());
  File flagsDir=new File(_testDir,""String_Node_Str"");
  if (flagsDir.isDirectory()) {
    File[] files=flagsDir.listFiles();
    for (int i=0; i < files.length; i++) {
      if (!files[i].isFile())       continue;
      assertTrue(""String_Node_Str"",files[i].delete());
    }
  }
  File searchingFile=new File(_testDir,""String_Node_Str"");
  searchingFile.delete();
  _fileManager=RouterService.getFileManager();
  _uploadManager=RouterService.getUploadManager();
  try {
    Thread.sleep(4000);
  }
 catch (  InterruptedException e) {
    assertTrue(""String_Node_Str"" + e,false);
  }
  assertTrue(""String_Node_Str"",4 < _fileManager.getNumFiles());
}","protected void setUp(){
  if (ROUTER_SERVICE.isStarted())   return;
  final File TEMP_DIR=new File(""String_Node_Str"");
  TEMP_DIR.mkdirs();
  TEMP_DIR.deleteOnExit();
  SettingsManager.instance().setDirectories(new File[]{TEMP_DIR});
  SettingsManager.instance().setExtensions(""String_Node_Str"");
  String dirString=""String_Node_Str"";
  File testDir=CommonUtils.getResourceFile(dirString);
  assertTrue(""String_Node_Str"",testDir.isDirectory());
  File[] files=testDir.listFiles();
  if (files != null) {
    for (int i=0; i < files.length; i++) {
      if (!files[i].isFile())       continue;
      CommonUtils.copyResourceFile(dirString + ""String_Node_Str"" + files[i].getName(),new File(TEMP_DIR,files[i].getName() + ""String_Node_Str""));
    }
  }
  ROUTER_SERVICE.start();
  try {
    Thread.sleep(4000);
  }
 catch (  InterruptedException e) {
    assertTrue(""String_Node_Str"" + e,false);
  }
  assertTrue(""String_Node_Str"",4 < RouterService.getFileManager().getNumFiles());
}",0.2594339622641509
4724,"/** 
 * Sends an HTTP request that should fail if everything is working  correctly.
 */
private void sendRequestThatShouldFail(HTTPRequestMethod method,String request,FileDesc fd,String error){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    baos.write(request.getBytes());
    Socket sock=new TestSocket(new ByteArrayInputStream(baos.toByteArray()));
    _uploadManager.acceptUpload(method,sock);
    String reply=sock.getOutputStream().toString();
    StringTokenizer st=new StringTokenizer(reply,""String_Node_Str"");
    boolean sentExpectedError=false;
    while (st.hasMoreTokens()) {
      String curString=st.nextToken();
      if (curString.equals(error)) {
        sentExpectedError=true;
      }
    }
    assertTrue(error + ""String_Node_Str"",sentExpectedError);
  }
 catch (  IOException e) {
    assertTrue(""String_Node_Str"" + e,false);
  }
}","/** 
 * Sends an HTTP request that should fail if everything is working  correctly.
 */
private void sendRequestThatShouldFail(HTTPRequestMethod method,String request,FileDesc fd,String error){
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    baos.write(request.getBytes());
    Socket sock=new TestSocket(new ByteArrayInputStream(baos.toByteArray()));
    RouterService.getUploadManager().acceptUpload(method,sock);
    String reply=sock.getOutputStream().toString();
    StringTokenizer st=new StringTokenizer(reply,""String_Node_Str"");
    boolean sentExpectedError=false;
    String curString=st.nextToken().trim();
    assertEquals(""String_Node_Str"",error,curString);
  }
 catch (  IOException e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}",0.8463385354141657
4725,"/** 
 * Test requests by URN.
 */
public void testHttpUrnRequest(){
  for (int i=0; i < _fileManager.getNumFiles(); i++) {
    FileDesc fd=_fileManager.get(i);
    String request=""String_Node_Str"" + fd.getSHA1Urn().httpStringValue() + ""String_Node_Str"";
    sendRequestThatShouldSucceed(HTTPRequestMethod.GET,request,fd);
    sendRequestThatShouldSucceed(HTTPRequestMethod.HEAD,request,fd);
  }
}","/** 
 * Test requests by URN.
 */
public void testHttpUrnRequest(){
  for (int i=0; i < RouterService.getFileManager().getNumFiles(); i++) {
    FileDesc fd=RouterService.getFileManager().get(i);
    String request=""String_Node_Str"" + fd.getSHA1Urn().httpStringValue() + ""String_Node_Str"";
    sendRequestThatShouldSucceed(HTTPRequestMethod.GET,request,fd);
    sendRequestThatShouldSucceed(HTTPRequestMethod.HEAD,request,fd);
  }
}",0.9468599033816424
4726,"/** 
 * Dynamically scans this class to load up a HashMap with default values. Used to determine whether or not a value is default at save them (to know if we should save it or not)
 */
private void reflectUponDefaults(){
  Field[] fields=SettingsManager.class.getDeclaredFields();
  String theKey;
  String theValue;
  Class theClass;
  defaultValues=new HashMap(PROPS.size());
  for (int i=0; i < fields.length; i++) {
    if (fields[i].getName().startsWith(""String_Node_Str"")) {
      theKey=fields[i].getName().substring(8);
      theClass=fields[i].getType();
      try {
        if (theClass == String.class)         theValue=(String)fields[i].get(this);
 else         if (theClass == Boolean.TYPE)         theValue=Boolean.toString(fields[i].getBoolean(this));
 else         if (theClass == Byte.TYPE)         theValue=Byte.toString(fields[i].getByte(this));
 else         if (theClass == Character.TYPE)         theValue=Character.toString(fields[i].getChar(this));
 else         if (theClass == Double.TYPE)         theValue=Double.toString(fields[i].getDouble(this));
 else         if (theClass == Float.TYPE)         theValue=Float.toString(fields[i].getFloat(this));
 else         if (theClass == Integer.TYPE)         theValue=Integer.toString(fields[i].getInt(this));
 else         if (theClass == Long.TYPE)         theValue=Long.toString(fields[i].getLong(this));
 else         if (theClass == Short.TYPE)         theValue=Short.toString(fields[i].getShort(this));
 else         continue;
        defaultValues.put(theKey,theValue);
      }
 catch (      Exception ignored) {
      }
    }
  }
}","/** 
 * Dynamically scans this class to load up a HashMap with default values. Used to determine whether or not a value is default at save them (to know if we should save it or not)
 */
private void reflectUponDefaults(){
  Field[] fields=SettingsManager.class.getDeclaredFields();
  String theKey;
  String theValue;
  Class theClass;
  defaultValues=new HashMap(PROPS.size());
  for (int i=0; i < fields.length; i++) {
    if (fields[i].getName().startsWith(""String_Node_Str"")) {
      theKey=fields[i].getName().substring(8);
      theClass=fields[i].getType();
      try {
        if (theClass == String.class)         theValue=(String)fields[i].get(this);
 else         if (theClass == Boolean.TYPE)         theValue=new Boolean(fields[i].getBoolean(this)).toString();
 else         if (theClass == Byte.TYPE)         theValue=Byte.toString(fields[i].getByte(this));
 else         if (theClass == Character.TYPE)         theValue=new Character(fields[i].getChar(this)).toString();
 else         if (theClass == Double.TYPE)         theValue=Double.toString(fields[i].getDouble(this));
 else         if (theClass == Float.TYPE)         theValue=Float.toString(fields[i].getFloat(this));
 else         if (theClass == Integer.TYPE)         theValue=Integer.toString(fields[i].getInt(this));
 else         if (theClass == Long.TYPE)         theValue=Long.toString(fields[i].getLong(this));
 else         if (theClass == Short.TYPE)         theValue=Short.toString(fields[i].getShort(this));
 else         continue;
        defaultValues.put(theKey,theValue);
      }
 catch (      Exception ignored) {
      }
    }
  }
}",0.9851576994434136
4727,"/** 
 * @modifies socket, this' managers
 * @effects starts a new thread to handle the given socket andregisters it with the appropriate protocol-specific manager. Returns once the thread has been started.  If socket does not speak a known protocol, closes the socket immediately and returns.
 */
public ConnectionDispatchRunner(Socket socket){
  super(""String_Node_Str"");
  _socket=socket;
  setDaemon(true);
  start();
}","/** 
 * @modifies socket, this' managers
 * @effects starts a new thread to handle the given socket andregisters it with the appropriate protocol-specific manager. Returns once the thread has been started.  If socket does not speak a known protocol, closes the socket immediately and returns.
 */
public ConnectionDispatchRunner(Socket socket){
  super(""String_Node_Str"");
  _socket=socket;
  setDaemon(true);
  this.start();
}",0.994110718492344
4728,"private String getLinuxMac() throws IOException {
  String result=runCommand(""String_Node_Str"");
  return parseResult(result,""String_Node_Str"");
}","private String getLinuxMac() throws IOException {
  String result=runCommand(""String_Node_Str"");
  if (result.length() < 17)   result=runCommand(""String_Node_Str"");
  if (result.length() < 17)   result=runCommand(""String_Node_Str"");
  return parseResult(result,""String_Node_Str"");
}",0.6822429906542056
4729,"private String parseResult(String result,String delimiter){
  StringTokenizer tok=new StringTokenizer(result,""String_Node_Str"");
  while (tok.hasMoreTokens()) {
    String line=tok.nextToken();
    int index=line.indexOf(delimiter);
    if (index >= 0) {
      String address=line.substring(index + delimiter.length()).trim();
      address=canonicalizeMacAddress(address);
      if (address != null)       return address;
    }
  }
  return null;
}","private String parseResult(String result,String delimiter){
  result=result.toLowerCase();
  StringTokenizer tok=new StringTokenizer(result,""String_Node_Str"");
  while (tok.hasMoreTokens()) {
    String line=tok.nextToken();
    int index=line.indexOf(delimiter);
    if (index >= 0) {
      String address=line.substring(index + delimiter.length()).trim();
      address=canonicalizeMacAddress(address);
      if (address != null)       return address;
    }
  }
  return null;
}",0.9666307857911732
4730,"/** 
 * Indirectly checks that the GWebCache is hit when there is no gnutella.net file. 
 */
public void testGetAnEndpoint_ImmediateFetch(){
  try {
    assertEquals(0,gWebCache.hostfiles);
    Thread responder=new Thread(){
      public void run(){
        hc.add(new Endpoint(""String_Node_Str"",6346),false);
        hc.add(new Endpoint(""String_Node_Str"",6346),false);
        hc.add(new Endpoint(""String_Node_Str"",6346),false);
      }
    }
;
    responder.start();
    assertTrue(hc.getAnEndpoint() != null);
    assertEquals(1,gWebCache.hostfiles);
    assertTrue(hc.getAnEndpoint() != null);
    assertEquals(1,gWebCache.hostfiles);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
}","/** 
 * Indirectly checks that the GWebCache is hit when there is no gnutella.net file. 
 */
public void testGetAnEndpoint_ImmediateFetch(){
  try {
    assertEquals(""String_Node_Str"",0,gWebCache.hostfiles);
    Thread responder=new Thread(){
      public void run(){
        yield();
        hc.add(new Endpoint(""String_Node_Str"",6346),false);
      }
    }
;
    responder.start();
    assertTrue(""String_Node_Str"",hc.getAnEndpoint() != null);
    assertEquals(""String_Node_Str"",1,gWebCache.hostfiles);
    hc.add(new Endpoint(""String_Node_Str"",6346),false);
    assertTrue(""String_Node_Str"",hc.getAnEndpoint() != null);
    assertEquals(""String_Node_Str"",1,gWebCache.hostfiles);
    responder=new Thread(){
      public void run(){
        yield();
        hc.add(new Endpoint(""String_Node_Str"",6346),false);
      }
    }
;
    responder.start();
    assertTrue(""String_Node_Str"",hc.getAnEndpoint() != null);
    assertEquals(""String_Node_Str"",2,gWebCache.hostfiles);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    fail(""String_Node_Str"");
  }
}",0.720840243228303
4731,"public void setUp(){
  new RouterService(new ActivityCallbackStub());
  hc=new HostCatcher();
  gWebCache=new RecordingBootstrapServerManager();
  try {
    PrivilegedAccessor.setValue(hc,""String_Node_Str"",gWebCache);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
}","public void setUp(){
  new RouterService(new ActivityCallbackStub());
  gWebCache=new RecordingBootstrapServerManager();
  hc=new HostCatcher();
  try {
    PrivilegedAccessor.setValue(hc,""String_Node_Str"",gWebCache);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
}",0.8113879003558719
4732,"public void run(){
  hc.add(new Endpoint(""String_Node_Str"",6346),false);
  hc.add(new Endpoint(""String_Node_Str"",6346),false);
  hc.add(new Endpoint(""String_Node_Str"",6346),false);
}","public void run(){
  yield();
  hc.add(new Endpoint(""String_Node_Str"",6346),false);
}",0.6067415730337079
4733,"/** 
 * Test the equals method.
 */
public void testAlternateLocationEquals(){
  for (int i=0; i < equalLocs.length; i++) {
    try {
      AlternateLocation curLoc=AlternateLocation.createAlternateLocation(equalLocs[i]);
      for (int j=0; j < equalLocs.length; j++) {
        AlternateLocation newLoc=AlternateLocation.createAlternateLocation(equalLocs[j]);
        assertEquals(""String_Node_Str"",curLoc,newLoc);
      }
    }
 catch (    IOException e) {
      assertTrue(""String_Node_Str"" + e,false);
    }
  }
  TreeMap timeStampedAltLocs0=new TreeMap();
  TreeMap testMap=new TreeMap();
  for (int i=0; i < HugeTestUtils.VALID_TIMESTAMPED_LOCS.length; i++) {
    try {
      AlternateLocation al0=AlternateLocation.createAlternateLocation(HugeTestUtils.VALID_TIMESTAMPED_LOCS[i]);
      AlternateLocation al1=AlternateLocation.createAlternateLocation(HugeTestUtils.VALID_TIMESTAMPED_LOCS[i]);
      assertTrue(""String_Node_Str"",al0.isTimestamped());
      assertTrue(""String_Node_Str"",al1.isTimestamped());
      timeStampedAltLocs0.put(al0,al0);
      testMap.put(al1,al1);
    }
 catch (    IOException e) {
      assertTrue(""String_Node_Str"" + e,false);
    }
  }
  assertEquals(""String_Node_Str"",timeStampedAltLocs0,testMap);
  TreeMap timeStampedAltLocs1=new TreeMap(timeStampedAltLocs0);
  Iterator iter0=timeStampedAltLocs0.values().iterator();
  Iterator iter1=timeStampedAltLocs1.values().iterator();
  while (iter0.hasNext()) {
    AlternateLocation al0=(AlternateLocation)iter0.next();
    AlternateLocation al1=(AlternateLocation)iter1.next();
    assertEquals(""String_Node_Str"",al0,al1);
  }
  Iterator iter20=timeStampedAltLocs0.keySet().iterator();
  Iterator iter21=timeStampedAltLocs1.keySet().iterator();
  while (iter20.hasNext()) {
    AlternateLocation al0=(AlternateLocation)iter20.next();
    AlternateLocation al1=(AlternateLocation)iter21.next();
    assertEquals(""String_Node_Str"",al0,al1);
  }
  Iterator iter30=timeStampedAltLocs0.entrySet().iterator();
  Iterator iter31=timeStampedAltLocs1.entrySet().iterator();
  while (iter20.hasNext()) {
    Map.Entry al0=(Map.Entry)iter30.next();
    Map.Entry al1=(Map.Entry)iter31.next();
    assertEquals(""String_Node_Str"",al0,al1);
  }
  assertEquals(""String_Node_Str"",timeStampedAltLocs1.size(),timeStampedAltLocs0.size());
  Iterator i=timeStampedAltLocs0.entrySet().iterator();
  while (i.hasNext()) {
    Map.Entry e=(Map.Entry)i.next();
    Object key=e.getKey();
    Object value=e.getValue();
    if (value == null) {
      if (!(timeStampedAltLocs1.get(key) == null && timeStampedAltLocs1.containsKey(key)))       assertTrue(""String_Node_Str"",false);
    }
 else {
      if (!value.equals(timeStampedAltLocs1.get(key)))       assertTrue(""String_Node_Str"",false);
    }
  }
}","/** 
 * Test the equals method.
 */
public void testAlternateLocationEquals(){
  for (int i=0; i < equalLocs.length; i++) {
    try {
      AlternateLocation curLoc=AlternateLocation.createAlternateLocation(equalLocs[i]);
      for (int j=0; j < equalLocs.length; j++) {
        AlternateLocation newLoc=AlternateLocation.createAlternateLocation(equalLocs[j]);
        assertEquals(""String_Node_Str"",curLoc,newLoc);
      }
    }
 catch (    IOException e) {
      assertTrue(""String_Node_Str"" + e,false);
    }
  }
  TreeMap timeStampedAltLocs0=new TreeMap();
  TreeMap testMap=new TreeMap();
  for (int i=0; i < HugeTestUtils.VALID_TIMESTAMPED_LOCS.length; i++) {
    try {
      AlternateLocation al0=AlternateLocation.createAlternateLocation(HugeTestUtils.VALID_TIMESTAMPED_LOCS[i]);
      AlternateLocation al1=AlternateLocation.createAlternateLocation(HugeTestUtils.VALID_TIMESTAMPED_LOCS[i]);
      assertTrue(""String_Node_Str"",al0.isTimestamped());
      assertTrue(""String_Node_Str"",al1.isTimestamped());
      timeStampedAltLocs0.put(al0,al0);
      testMap.put(al1,al1);
    }
 catch (    IOException e) {
      assertTrue(""String_Node_Str"" + e,false);
    }
  }
  TreeMap timeStampedAltLocs1=new TreeMap(timeStampedAltLocs0);
  Iterator iter0=timeStampedAltLocs0.values().iterator();
  Iterator iter1=timeStampedAltLocs1.values().iterator();
  while (iter0.hasNext()) {
    AlternateLocation al0=(AlternateLocation)iter0.next();
    AlternateLocation al1=(AlternateLocation)iter1.next();
    assertEquals(""String_Node_Str"",al0,al1);
  }
  Iterator iter20=timeStampedAltLocs0.keySet().iterator();
  Iterator iter21=timeStampedAltLocs1.keySet().iterator();
  while (iter20.hasNext()) {
    AlternateLocation al0=(AlternateLocation)iter20.next();
    AlternateLocation al1=(AlternateLocation)iter21.next();
    assertEquals(""String_Node_Str"",al0,al1);
  }
  Iterator iter30=timeStampedAltLocs0.entrySet().iterator();
  Iterator iter31=timeStampedAltLocs1.entrySet().iterator();
  while (iter20.hasNext()) {
    Map.Entry al0=(Map.Entry)iter30.next();
    Map.Entry al1=(Map.Entry)iter31.next();
    assertEquals(""String_Node_Str"",al0,al1);
  }
  assertEquals(""String_Node_Str"",timeStampedAltLocs1.size(),timeStampedAltLocs0.size());
  Iterator i=timeStampedAltLocs0.entrySet().iterator();
  while (i.hasNext()) {
    Map.Entry e=(Map.Entry)i.next();
    Object key=e.getKey();
    Object value=e.getValue();
    if (value == null) {
      if (!(timeStampedAltLocs1.get(key) == null && timeStampedAltLocs1.containsKey(key)))       assertTrue(""String_Node_Str"",false);
    }
 else {
      if (!value.equals(timeStampedAltLocs1.get(key)))       assertTrue(""String_Node_Str"",false);
    }
  }
}",0.9884636513459072
4734,"/** 
 * Returns whether or not this node is capable of sending its own GUESS queries.  This would not be the case only if this node has not successfully received an incoming UDP packet.
 * @return <tt>true</tt> if this node is capable of running its ownGUESS queries, <tt>false</tt> otherwise
 */
public static boolean isGUESSCapable(){
  return udpService.isGUESSCapable() && SearchSettings.GUESS_ENABLED.getValue();
}","/** 
 * Returns whether or not this node is capable of sending its own GUESS queries.  This would not be the case only if this node has not successfully received an incoming UDP packet.
 * @return <tt>true</tt> if this node is capable of running its ownGUESS queries, <tt>false</tt> otherwise
 */
public static boolean isGUESSCapable(){
  return udpService.isGUESSCapable();
}",0.9459119496855346
4735,"/** 
 * Runs the legacy unit test that was formerly in QueryReply.
 */
public void testLegacyUnitTest(){
  byte[] ip={(byte)0xFF,(byte)0,(byte)0,(byte)0x1};
  long u4=0x00000000FFFFFFFFl;
  byte[] guid=new byte[16];
  guid[0]=(byte)1;
  guid[15]=(byte)0xFF;
  Response[] responses=new Response[0];
  QueryReply qr=new QueryReply(guid,(byte)5,0xF3F1,ip,1,responses,guid);
  assertEquals(qr.getSpeed(),1);
  assertEquals(Integer.toHexString(qr.getPort()),qr.getPort(),0xF3F1);
  try {
    assertEquals(qr.getResults().hasNext(),false);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid);
  assertEquals(qr.getIP(),""String_Node_Str"");
  assertEquals(qr.getPort(),0xFFFF);
  assertEquals(qr.getSpeed(),u4);
  assertEquals(Arrays.equals(qr.getClientGUID(),guid),true);
  try {
    Iterator iter=qr.getResults();
    Response r1=(Response)iter.next();
    assertEquals(r1,responses[0]);
    Response r2=(Response)iter.next();
    assertEquals(r2,responses[1]);
    assertEquals(iter.hasNext(),false);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
catch (  NoSuchElementException e) {
    assertTrue(false);
  }
  byte[] payload=new byte[11 + 11 + 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    Iterator iter=qr.getResults();
    Response response=(Response)iter.next();
    assertEquals(""String_Node_Str"" + response.getName() + ""String_Node_Str"",response.getName(),""String_Node_Str"");
    assertEquals(iter.hasNext(),false);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
  try {
    qr.getVendor();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getNeedsPush();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + 15];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    Iterator iter=qr.getResults();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getVendor();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 5)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)76;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1+ 2]=(byte)5;
  payload[11 + 11 + 4+ 1+ 3]=(byte)0;
  payload[11 + 11 + 4+ 1+ 4]=(byte)'S';
  payload[11 + 11 + 4+ 1+ 4+ 1]=(byte)'U';
  payload[11 + 11 + 4+ 1+ 4+ 2]=(byte)'S';
  payload[11 + 11 + 4+ 1+ 4+ 3]=(byte)'H';
  payload[11 + 11 + 4+ 1+ 4+ 4]=(byte)0;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    Iterator iter=qr.getResults();
    Response r=(Response)iter.next();
    assertEquals(""String_Node_Str"",r.getNameBytesSize(),1);
    assertEquals(""String_Node_Str"",r.getMetaBytesSize(),0);
    byte[] name=r.getNameBytes();
    assertEquals(""String_Node_Str"",name[0],'A');
    assertEquals(""String_Node_Str"",r.getName(),""String_Node_Str"");
    assertEquals(""String_Node_Str"" + (new String(qr.getXMLBytes())),(new String(qr.getXMLBytes())),""String_Node_Str"");
  }
 catch (  BadPacketException e) {
    System.out.println(""String_Node_Str"");
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 4)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0xB1;
  payload[11 + 11 + 4+ 1+ 2]=(byte)4;
  payload[11 + 11 + 4+ 1+ 3]=(byte)0;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    String vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    assertEquals(qr.getNeedsPush(),true);
  }
 catch (  BadPacketException e) {
    System.out.println(e.toString());
    assertTrue(false);
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 20000)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)76;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0xF0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)32;
  payload[11 + 11 + 4+ 1+ 3]=(byte)78;
  for (int i=0; i < 20000; i++)   payload[11 + 11 + 4+ 1+ 4+ i]='a';
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    String vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    assertEquals(qr.getNeedsPush(),false);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
    e.printStackTrace();
  }
  try {
    qr.getSupportsChat();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 2)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 4+ 1+ 0]=(byte)1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    qr.getNeedsPush();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getVendor();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 2 + 0)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)2;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    qr.getResults();
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
  try {
    qr.getVendor();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    String vendor=qr.getVendor();
    assertEquals(vendor,vendor,""String_Node_Str"");
    vendor=qr.getVendor();
    assertEquals(vendor,vendor,""String_Node_Str"");
  }
 catch (  BadPacketException e) {
    System.out.println(e.toString());
    assertTrue(false);
  }
  try {
    assertEquals(qr.getNeedsPush(),false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsBusy();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getHadSuccessfulUpload();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsMeasuredSpeed();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)73;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x1d;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x1c;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  payload[11 + 11 + 4+ 1+ 4]=(byte)0x1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    String vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    assertEquals(qr.getNeedsPush(),true);
    assertEquals(qr.getNeedsPush(),true);
    assertEquals(qr.getIsBusy(),true);
    assertEquals(qr.getIsBusy(),true);
    assertEquals(qr.getIsMeasuredSpeed(),true);
    assertEquals(qr.getIsMeasuredSpeed(),true);
    assertEquals(qr.getHadSuccessfulUpload(),true);
    assertEquals(qr.getHadSuccessfulUpload(),true);
    assertEquals(qr.getSupportsChat(),true);
  }
 catch (  BadPacketException e) {
    System.out.println(e.toString());
    assertTrue(false);
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x1c;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  try {
    String vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    assertEquals(qr.getNeedsPush(),false);
    assertEquals(qr.getIsBusy(),false);
    assertEquals(qr.getIsMeasuredSpeed(),false);
    assertEquals(qr.getHadSuccessfulUpload(),false);
  }
 catch (  BadPacketException e) {
    System.out.println(e.toString());
    assertTrue(false);
  }
  try {
    qr.getSupportsChat();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,false,true,true,false,true);
  assertEquals(qr.getIP(),""String_Node_Str"");
  assertEquals(qr.getPort(),0xFFFF);
  assertEquals(qr.getSpeed(),u4);
  assertTrue(Arrays.equals(qr.getClientGUID(),guid));
  try {
    Iterator iter=qr.getResults();
    Response r1=(Response)iter.next();
    assertEquals(r1,responses[0]);
    Response r2=(Response)iter.next();
    assertEquals(r2,responses[1]);
    assertEquals(iter.hasNext(),false);
    assertEquals(qr.getVendor(),""String_Node_Str"");
    assertEquals(qr.getNeedsPush(),false);
    assertEquals(qr.getIsBusy(),true);
    assertEquals(qr.getHadSuccessfulUpload(),true);
    assertEquals(qr.getIsMeasuredSpeed(),false);
    assertEquals(qr.getSupportsChat(),true);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
catch (  NoSuchElementException e) {
    assertTrue(false);
  }
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,true,false,false,true,false);
  try {
    assertEquals(qr.getVendor(),""String_Node_Str"");
    assertEquals(qr.getNeedsPush(),true);
    assertEquals(qr.getIsBusy(),false);
    assertEquals(qr.getHadSuccessfulUpload(),false);
    assertEquals(qr.getIsMeasuredSpeed(),true);
    assertEquals(qr.getSupportsChat(),false);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
catch (  NoSuchElementException e) {
    assertTrue(false);
  }
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  try {
    qr.write(out);
  }
 catch (  IOException e) {
    assertTrue(false);
  }
  byte[] bytes=out.toByteArray();
  final int ggepLen=GGEPUtil.getQRGGEP(true).length;
  assertEquals(bytes.length,(23 + 11 + 16) + (8 + 10 + 2) + (8 + 14 + 2)+ (4 + 1 + QueryReply.COMMON_PAYLOAD_LEN+ 1+ 1)+ ggepLen);
  assertEquals(bytes[bytes.length - 16 - 6- ggepLen],0x3d);
  assertEquals(bytes[bytes.length - 16 - 5- ggepLen],0x31);
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid);
  try {
    qr.getVendor();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getNeedsPush();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsBusy();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getHadSuccessfulUpload();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsMeasuredSpeed();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
}","/** 
 * Runs the legacy unit test that was formerly in QueryReply.
 */
public void testLegacyUnitTest(){
  byte[] ip={(byte)0xFF,(byte)0,(byte)0,(byte)0x1};
  long u4=0x00000000FFFFFFFFl;
  byte[] guid=new byte[16];
  guid[0]=(byte)1;
  guid[15]=(byte)0xFF;
  Response[] responses=new Response[0];
  QueryReply qr=new QueryReply(guid,(byte)5,0xF3F1,ip,1,responses,guid);
  assertEquals(qr.getSpeed(),1);
  assertEquals(Integer.toHexString(qr.getPort()),qr.getPort(),0xF3F1);
  try {
    assertEquals(qr.getResults().hasNext(),false);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid);
  assertEquals(qr.getIP(),""String_Node_Str"");
  assertEquals(qr.getPort(),0xFFFF);
  assertEquals(qr.getSpeed(),u4);
  assertEquals(Arrays.equals(qr.getClientGUID(),guid),true);
  try {
    Iterator iter=qr.getResults();
    Response r1=(Response)iter.next();
    assertEquals(r1,responses[0]);
    Response r2=(Response)iter.next();
    assertEquals(r2,responses[1]);
    assertEquals(iter.hasNext(),false);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
catch (  NoSuchElementException e) {
    assertTrue(false);
  }
  byte[] payload=new byte[11 + 11 + 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  try {
    qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"" + e);
  }
  try {
    Iterator iter=qr.getResults();
    Response response=(Response)iter.next();
    assertEquals(""String_Node_Str"" + response.getName() + ""String_Node_Str"",response.getName(),""String_Node_Str"");
    assertEquals(iter.hasNext(),false);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
  try {
    qr.getVendor();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getNeedsPush();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + 15];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  try {
    qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"" + e);
  }
  try {
    Iterator iter=qr.getResults();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getVendor();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 5)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)76;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1+ 2]=(byte)5;
  payload[11 + 11 + 4+ 1+ 3]=(byte)0;
  payload[11 + 11 + 4+ 1+ 4]=(byte)'S';
  payload[11 + 11 + 4+ 1+ 4+ 1]=(byte)'U';
  payload[11 + 11 + 4+ 1+ 4+ 2]=(byte)'S';
  payload[11 + 11 + 4+ 1+ 4+ 3]=(byte)'H';
  payload[11 + 11 + 4+ 1+ 4+ 4]=(byte)0;
  try {
    qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"" + e);
  }
  try {
    Iterator iter=qr.getResults();
    Response r=(Response)iter.next();
    assertEquals(""String_Node_Str"",r.getNameBytesSize(),1);
    assertEquals(""String_Node_Str"",r.getMetaBytesSize(),0);
    byte[] name=r.getNameBytes();
    assertEquals(""String_Node_Str"",name[0],'A');
    assertEquals(""String_Node_Str"",r.getName(),""String_Node_Str"");
    assertEquals(""String_Node_Str"" + (new String(qr.getXMLBytes())),(new String(qr.getXMLBytes())),""String_Node_Str"");
  }
 catch (  BadPacketException e) {
    System.out.println(""String_Node_Str"");
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 4)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0xB1;
  payload[11 + 11 + 4+ 1+ 2]=(byte)4;
  payload[11 + 11 + 4+ 1+ 3]=(byte)0;
  try {
    qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"" + e);
  }
  try {
    String vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    assertEquals(qr.getNeedsPush(),true);
  }
 catch (  BadPacketException e) {
    System.out.println(e.toString());
    assertTrue(false);
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 20000)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)76;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0xF0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)32;
  payload[11 + 11 + 4+ 1+ 3]=(byte)78;
  for (int i=0; i < 20000; i++)   payload[11 + 11 + 4+ 1+ 4+ i]='a';
  try {
    qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"" + e);
  }
  try {
    String vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    assertEquals(qr.getNeedsPush(),false);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
    e.printStackTrace();
  }
  try {
    qr.getSupportsChat();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 2)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 4+ 1+ 0]=(byte)1;
  try {
    qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"" + e);
  }
  try {
    qr.getNeedsPush();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getVendor();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 2 + 0)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)2;
  try {
    qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"" + e);
  }
  try {
    qr.getResults();
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
  try {
    qr.getVendor();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4+ 0]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  try {
    qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"" + e);
  }
  try {
    String vendor=qr.getVendor();
    assertEquals(vendor,vendor,""String_Node_Str"");
    vendor=qr.getVendor();
    assertEquals(vendor,vendor,""String_Node_Str"");
  }
 catch (  BadPacketException e) {
    System.out.println(e.toString());
    assertTrue(false);
  }
  try {
    assertEquals(qr.getNeedsPush(),false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsBusy();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getHadSuccessfulUpload();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsMeasuredSpeed();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)73;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x1d;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x1c;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  payload[11 + 11 + 4+ 1+ 4]=(byte)0x1;
  try {
    qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"" + e);
  }
  try {
    String vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    assertEquals(qr.getNeedsPush(),true);
    assertEquals(qr.getNeedsPush(),true);
    assertEquals(qr.getIsBusy(),true);
    assertEquals(qr.getIsBusy(),true);
    assertEquals(qr.getIsMeasuredSpeed(),true);
    assertEquals(qr.getIsMeasuredSpeed(),true);
    assertEquals(qr.getHadSuccessfulUpload(),true);
    assertEquals(qr.getHadSuccessfulUpload(),true);
    assertEquals(qr.getSupportsChat(),true);
  }
 catch (  BadPacketException e) {
    System.out.println(e.toString());
    assertTrue(false);
  }
  payload=new byte[11 + 11 + (4 + 1 + 4+ 1)+ 16];
  payload[0]=1;
  payload[11 + 8]=(byte)65;
  payload[11 + 11 + 0]=(byte)76;
  payload[11 + 11 + 1]=(byte)105;
  payload[11 + 11 + 2]=(byte)77;
  payload[11 + 11 + 3]=(byte)69;
  payload[11 + 11 + 4]=(byte)QueryReply.COMMON_PAYLOAD_LEN;
  payload[11 + 11 + 4+ 1]=(byte)0x1c;
  payload[11 + 11 + 4+ 1+ 1]=(byte)0x0;
  payload[11 + 11 + 4+ 1+ 2]=(byte)1;
  try {
    qr=new QueryReply(new byte[16],(byte)5,(byte)0,payload);
  }
 catch (  BadPacketException e) {
    fail(""String_Node_Str"" + e);
  }
  try {
    String vendor=qr.getVendor();
    assertEquals(vendor,""String_Node_Str"",vendor);
    assertEquals(qr.getNeedsPush(),false);
    assertEquals(qr.getIsBusy(),false);
    assertEquals(qr.getIsMeasuredSpeed(),false);
    assertEquals(qr.getHadSuccessfulUpload(),false);
  }
 catch (  BadPacketException e) {
    System.out.println(e.toString());
    assertTrue(false);
  }
  try {
    qr.getSupportsChat();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,false,true,true,false,true);
  assertEquals(qr.getIP(),""String_Node_Str"");
  assertEquals(qr.getPort(),0xFFFF);
  assertEquals(qr.getSpeed(),u4);
  assertTrue(Arrays.equals(qr.getClientGUID(),guid));
  try {
    Iterator iter=qr.getResults();
    Response r1=(Response)iter.next();
    assertEquals(r1,responses[0]);
    Response r2=(Response)iter.next();
    assertEquals(r2,responses[1]);
    assertEquals(iter.hasNext(),false);
    assertEquals(qr.getVendor(),""String_Node_Str"");
    assertEquals(qr.getNeedsPush(),false);
    assertEquals(qr.getIsBusy(),true);
    assertEquals(qr.getHadSuccessfulUpload(),true);
    assertEquals(qr.getIsMeasuredSpeed(),false);
    assertEquals(qr.getSupportsChat(),true);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
catch (  NoSuchElementException e) {
    assertTrue(false);
  }
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid,true,false,false,true,false);
  try {
    assertEquals(qr.getVendor(),""String_Node_Str"");
    assertEquals(qr.getNeedsPush(),true);
    assertEquals(qr.getIsBusy(),false);
    assertEquals(qr.getHadSuccessfulUpload(),false);
    assertEquals(qr.getIsMeasuredSpeed(),true);
    assertEquals(qr.getSupportsChat(),false);
  }
 catch (  BadPacketException e) {
    assertTrue(false);
  }
catch (  NoSuchElementException e) {
    assertTrue(false);
  }
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  try {
    qr.write(out);
  }
 catch (  IOException e) {
    assertTrue(false);
  }
  byte[] bytes=out.toByteArray();
  final int ggepLen=GGEPUtil.getQRGGEP(true).length;
  assertEquals(bytes.length,(23 + 11 + 16) + (8 + 10 + 2) + (8 + 14 + 2)+ (4 + 1 + QueryReply.COMMON_PAYLOAD_LEN+ 1+ 1)+ ggepLen);
  assertEquals(bytes[bytes.length - 16 - 6- ggepLen],0x3d);
  assertEquals(bytes[bytes.length - 16 - 5- ggepLen],0x31);
  responses=new Response[2];
  responses[0]=new Response(11,22,""String_Node_Str"");
  responses[1]=new Response(0x2FF2,0xF11F,""String_Node_Str"");
  qr=new QueryReply(guid,(byte)5,0xFFFF,ip,u4,responses,guid);
  try {
    qr.getVendor();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getNeedsPush();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsBusy();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getHadSuccessfulUpload();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
  try {
    qr.getIsMeasuredSpeed();
    assertTrue(false);
  }
 catch (  BadPacketException e) {
  }
}",0.9662698412698412
4736,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(GGEPTest.suite());
  suite.addTest(PingReplyTest.suite());
  suite.addTest(PingRequestTest.suite());
  suite.addTest(PushRequestTest.suite());
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(GGEPTest.suite());
  suite.addTest(PingReplyTest.suite());
  suite.addTest(PingRequestTest.suite());
  suite.addTest(PushRequestTest.suite());
  suite.addTest(MessageUtilsTest.suite());
  return suite;
}",0.9225225225225224
4737,"private static void tAddDownload(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc rfd2=newRFDWithURN(6347,100);
  Downloader download=null;
  try {
    download=dm.download(new RemoteFileDesc[]{rfd1},false);
    ((ManagedDownloader)download).addDownload(rfd2);
  }
 catch (  FileExistsException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  AlreadyDownloadingException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  java.io.FileNotFoundException e) {
    check(false,""String_Node_Str"");
    return;
  }
  waitForComplete(download);
  if (isComplete())   debug(""String_Node_Str"" + ""String_Node_Str"");
 else   check(false,""String_Node_Str"");
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 < (TestFile.length() / 2 + (FUDGE_FACTOR)),""String_Node_Str"");
  check(u2 < (TestFile.length() / 2 + (FUDGE_FACTOR)),""String_Node_Str"");
}","private static void tAddDownload(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFD(6346,100);
  RemoteFileDesc rfd2=newRFD(6347,100);
  Downloader download=null;
  try {
    download=dm.download(new RemoteFileDesc[]{rfd1},false);
    ((ManagedDownloader)download).addDownload(rfd2);
  }
 catch (  FileExistsException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  AlreadyDownloadingException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  java.io.FileNotFoundException e) {
    check(false,""String_Node_Str"");
    return;
  }
  waitForComplete(download);
  if (isComplete())   debug(""String_Node_Str"" + ""String_Node_Str"");
 else   check(false,""String_Node_Str"");
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 < (TestFile.length() / 2 + (FUDGE_FACTOR)),""String_Node_Str"");
  check(u2 < (TestFile.length() / 2 + (FUDGE_FACTOR)),""String_Node_Str"");
}",0.9942669942669944
4738,"private static void tUnbalancedSwarm(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE / 10);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc rfd2=newRFDWithURN(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 < 9 * TestFile.length() / 10 + FUDGE_FACTOR * 10,""String_Node_Str"");
  check(u2 < TestFile.length() / 10 + FUDGE_FACTOR,""String_Node_Str"");
}","private static void tUnbalancedSwarm(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE / 10);
  RemoteFileDesc rfd1=newRFD(6346,100);
  RemoteFileDesc rfd2=newRFD(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 < 9 * TestFile.length() / 10 + FUDGE_FACTOR * 10,""String_Node_Str"");
  check(u2 < TestFile.length() / 10 + FUDGE_FACTOR,""String_Node_Str"");
}",0.9902912621359224
4739,"private static void tUpdateWhiteWithFailingFirstUploader(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader1.setBusy(true);
  uploader2.setRate(RATE / 4);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc rfd2=newRFDWithURN(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  debug(""String_Node_Str"");
}","private static void tUpdateWhiteWithFailingFirstUploader(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader1.setBusy(true);
  uploader2.setRate(RATE / 4);
  RemoteFileDesc rfd1=newRFD(6346,100);
  RemoteFileDesc rfd2=newRFD(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  debug(""String_Node_Str"");
}",0.9891304347826086
4740,"private static void tQueuedDownloader(){
  debug(""String_Node_Str"");
  uploader1.setQueue(true);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc[] rfds={rfd1};
  tGeneric(rfds);
}","private static void tQueuedDownloader(){
  debug(""String_Node_Str"");
  uploader1.setQueue(true);
  RemoteFileDesc rfd1=newRFD(6346,100);
  RemoteFileDesc[] rfds={rfd1};
  tGeneric(rfds);
}",0.9817232375979112
4741,"private static void tSwarmWithInterrupt(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int STOP_AFTER=TestFile.length() / 4;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE);
  uploader2.stopAfter(STOP_AFTER);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc rfd2=newRFDWithURN(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 < TestFile.length() - STOP_AFTER + FUDGE_FACTOR,""String_Node_Str"");
  check(u2 == STOP_AFTER,""String_Node_Str"" + u2 + ""String_Node_Str"");
}","private static void tSwarmWithInterrupt(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int STOP_AFTER=TestFile.length() / 4;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE);
  uploader2.stopAfter(STOP_AFTER);
  RemoteFileDesc rfd1=newRFD(6346,100);
  RemoteFileDesc rfd2=newRFD(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 < TestFile.length() - STOP_AFTER + FUDGE_FACTOR,""String_Node_Str"");
  check(u2 == STOP_AFTER,""String_Node_Str"" + u2 + ""String_Node_Str"");
}",0.9912280701754386
4742,"private static void tMismatchedVerifyHash(boolean deleteCorrupt){
  debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=100;
  uploader1.setRate(RATE);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100,null);
  Downloader download=null;
  try {
    download=dm.download(new RemoteFileDesc[]{rfd1},false);
  }
 catch (  FileExistsException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  AlreadyDownloadingException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  java.io.FileNotFoundException e) {
    check(false,""String_Node_Str"");
    return;
  }
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}","private static void tMismatchedVerifyHash(boolean deleteCorrupt){
  debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=100;
  uploader1.setRate(RATE);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100,""String_Node_Str"");
  Downloader download=null;
  try {
    download=dm.download(new RemoteFileDesc[]{rfd1},false);
  }
 catch (  FileExistsException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  AlreadyDownloadingException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  java.io.FileNotFoundException e) {
    check(false,""String_Node_Str"");
    return;
  }
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}",0.9866666666666668
4743,"private static void tSimpleDownload(){
  debug(""String_Node_Str"");
  RemoteFileDesc rfd=newRFDWithURN(6346,100);
  RemoteFileDesc[] rfds={rfd};
  tGeneric(rfds);
}","private static void tSimpleDownload(){
  debug(""String_Node_Str"");
  RemoteFileDesc rfd=newRFD(6346,100);
  RemoteFileDesc[] rfds={rfd};
  tGeneric(rfds);
}",0.9780564263322884
4744,"private static void tStealerInterrupted(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int STOP_AFTER=5 * TestFile.length() / 8;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE / 10);
  uploader2.setRate(RATE);
  uploader2.stopAfter(STOP_AFTER);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc rfd2=newRFDWithURN(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 < TestFile.length() - STOP_AFTER + 2 * FUDGE_FACTOR,""String_Node_Str"");
  check(u2 == STOP_AFTER,""String_Node_Str"");
}","private static void tStealerInterrupted(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int STOP_AFTER=5 * TestFile.length() / 8;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE / 10);
  uploader2.setRate(RATE);
  uploader2.stopAfter(STOP_AFTER);
  RemoteFileDesc rfd1=newRFD(6346,100);
  RemoteFileDesc rfd2=newRFD(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 < TestFile.length() - STOP_AFTER + 2 * FUDGE_FACTOR,""String_Node_Str"");
  check(u2 == STOP_AFTER,""String_Node_Str"");
}",0.9910941475826972
4745,"private static void tOverlapCheckWhite(boolean deleteCorrupt){
  debug(""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=500;
  uploader1.setCorruption(true);
  uploader1.stopAfter(TestFile.length() / 8);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc rfd2=newRFDWithURN(6347,100);
  Downloader download=null;
  try {
    download=dm.download(new RemoteFileDesc[]{rfd1,rfd2},false);
  }
 catch (  FileExistsException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  AlreadyDownloadingException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  java.io.FileNotFoundException e) {
    check(false,""String_Node_Str"");
    return;
  }
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}","private static void tOverlapCheckWhite(boolean deleteCorrupt){
  debug(""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=500;
  uploader1.setCorruption(true);
  uploader1.stopAfter(TestFile.length() / 8);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFD(6346,100);
  RemoteFileDesc rfd2=newRFD(6347,100);
  Downloader download=null;
  try {
    download=dm.download(new RemoteFileDesc[]{rfd1,rfd2},false);
  }
 catch (  FileExistsException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  AlreadyDownloadingException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  java.io.FileNotFoundException e) {
    check(false,""String_Node_Str"");
    return;
  }
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}",0.992018244013683
4746,"private static void tStallingUploaderReplaced(){
  debug(""String_Node_Str"");
  final int RATE=500;
  uploader1.setRate(0);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc rfd2=newRFDWithURN(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  debug(""String_Node_Str"" + ""String_Node_Str"");
}","private static void tStallingUploaderReplaced(){
  debug(""String_Node_Str"");
  final int RATE=500;
  uploader1.setRate(0);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFD(6346,100);
  RemoteFileDesc rfd2=newRFD(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  debug(""String_Node_Str"" + ""String_Node_Str"");
}",0.9879518072289156
4747,"private static void tOverlapCheckGrey(boolean deleteCorrupt){
  debug(""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=500;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE / 100);
  uploader2.setCorruption(true);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc rfd2=newRFDWithURN(6347,100);
  Downloader download=null;
  try {
    download=dm.download(new RemoteFileDesc[]{rfd1,rfd2},false);
  }
 catch (  FileExistsException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  AlreadyDownloadingException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  java.io.FileNotFoundException e) {
    check(false,""String_Node_Str"");
    return;
  }
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}","private static void tOverlapCheckGrey(boolean deleteCorrupt){
  debug(""String_Node_Str"" + ""String_Node_Str"" + deleteCorrupt + ""String_Node_Str"");
  final int RATE=500;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE / 100);
  uploader2.setCorruption(true);
  RemoteFileDesc rfd1=newRFD(6346,100);
  RemoteFileDesc rfd2=newRFD(6347,100);
  Downloader download=null;
  try {
    download=dm.download(new RemoteFileDesc[]{rfd1,rfd2},false);
  }
 catch (  FileExistsException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  AlreadyDownloadingException e) {
    check(false,""String_Node_Str"");
    return;
  }
catch (  java.io.FileNotFoundException e) {
    check(false,""String_Node_Str"");
    return;
  }
  if (deleteCorrupt)   waitForCorrupt(download);
 else   waitForComplete(download);
  debug(""String_Node_Str"" + ""String_Node_Str"");
}",0.9918887601390498
4748,"private static void tAlternateLocationsExchangedWithBusy(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setBusy(true);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100,testHash.toString());
  RemoteFileDesc rfd2=newRFDWithURN(6347,100,testHash.toString());
  RemoteFileDesc[] rfds={rfd1};
  AlternateLocationCollection ualt=AlternateLocationCollection.createCollection(rfd1.getSHA1Urn());
  try {
    URL url2=rfd2.getUrl();
    AlternateLocation al2=AlternateLocation.createAlternateLocation(url2);
    ualt.addAlternateLocation(al2);
  }
 catch (  Exception e) {
    check(false,""String_Node_Str"");
  }
  uploader1.setAlternateLocations(ualt);
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 == 0,""String_Node_Str"");
  check(u2 < TestFile.length() + FUDGE_FACTOR,""String_Node_Str"");
}","private static void tAlternateLocationsExchangedWithBusy(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setBusy(true);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc rfd2=newRFDWithURN(6347,100);
  RemoteFileDesc[] rfds={rfd1};
  AlternateLocationCollection ualt=AlternateLocationCollection.createCollection(rfd1.getSHA1Urn());
  try {
    URL url2=rfd2.getUrl();
    AlternateLocation al2=AlternateLocation.createAlternateLocation(url2);
    ualt.addAlternateLocation(al2);
  }
 catch (  Exception e) {
    check(false,""String_Node_Str"");
  }
  uploader1.setAlternateLocations(ualt);
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 == 0,""String_Node_Str"");
  check(u2 < TestFile.length() + FUDGE_FACTOR,""String_Node_Str"");
}",0.9812382739212008
4749,"private static void tSimpleSwarm(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFDWithURN(6346,100);
  RemoteFileDesc rfd2=newRFDWithURN(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 < TestFile.length() / 2 + FUDGE_FACTOR,""String_Node_Str"");
  check(u2 < TestFile.length() / 2 + FUDGE_FACTOR,""String_Node_Str"");
}","private static void tSimpleSwarm(){
  debug(""String_Node_Str"");
  final int RATE=500;
  final int FUDGE_FACTOR=RATE * 1024;
  uploader1.setRate(RATE);
  uploader2.setRate(RATE);
  RemoteFileDesc rfd1=newRFD(6346,100);
  RemoteFileDesc rfd2=newRFD(6347,100);
  RemoteFileDesc[] rfds={rfd1,rfd2};
  tGeneric(rfds);
  int u1=uploader1.amountUploaded();
  int u2=uploader2.amountUploaded();
  debug(""String_Node_Str"" + u1 + ""String_Node_Str"");
  debug(""String_Node_Str"" + u2 + ""String_Node_Str"");
  debug(""String_Node_Str"" + (u1 + u2) + ""String_Node_Str"");
  check(u1 < TestFile.length() / 2 + FUDGE_FACTOR,""String_Node_Str"");
  check(u2 < TestFile.length() / 2 + FUDGE_FACTOR,""String_Node_Str"");
}",0.9900142653352354
4750,"/** 
 * Convenience method to generically compare any two comparable things. Handles comparison uniquely for 'native' types. This is for a few reasons: 1) We want to compare strings by lowercase comparison 2) Java 1.1.8 did not have native types implement Comparable Note that we check for both java.lang.Comparable and com.sun.java.util.collections.Comparable, and we do this _before_ checking for native types. So, this is slightly optimized for more recent JVMs Note that non-integer comparisons must specifically check if the difference is less or greater than 0 so that rounding won't be wrong. Of the native types, we check 'Integer' first since that's the most common, Boolean, then Double or Float, and finally, the rest will be caught in 'Number', which just uses an int comparison.
 */
public static int compare(Object o1,Object o2){
  int retval;
  if (o1 == null && o2 == null) {
    retval=0;
  }
 else   if (o1 == null) {
    retval=-1;
  }
 else   if (o2 == null) {
    retval=1;
  }
 else   if (o1.getClass() == String.class) {
    retval=StringUtils.compareIgnoreCase((String)o1,(String)o2);
  }
 else   if (o1 instanceof com.sun.java.util.collections.Comparable) {
    retval=((com.sun.java.util.collections.Comparable)o1).compareTo(o2);
  }
 else   if (o1 instanceof Integer) {
    retval=((Integer)o1).intValue() - ((Integer)o2).intValue();
  }
 else   if (o1 instanceof Boolean) {
    retval=o1.equals(o2) ? 0 : o1.equals(Boolean.TRUE) ? 1 : -1;
  }
 else   if (o1 instanceof Double || o1 instanceof Float) {
    double dbl=((Number)o1).doubleValue() - ((Number)o2).doubleValue();
    if (dbl > 0)     retval=1;
 else     if (dbl < 0)     retval=-1;
 else     retval=0;
  }
 else   if (o1 instanceof Number) {
    retval=((Number)o1).intValue() - ((Number)o2).intValue();
  }
 else {
    retval=0;
  }
  return retval;
}","/** 
 * Convenience method to generically compare any two comparable things. Handles comparison uniquely for 'native' types. This is for a few reasons: 1) We want to compare strings by lowercase comparison 2) Java 1.1.8 did not have native types implement Comparable Note that we check for both java.lang.Comparable and com.sun.java.util.collections.Comparable, and we do this _before_ checking for native types. So, this is slightly optimized for more recent JVMs Note that non-integer comparisons must specifically check if the difference is less or greater than 0 so that rounding won't be wrong. Of the native types, we check 'Integer' first since that's the most common, Boolean, then Double or Float, and finally, the rest will be caught in 'Number', which just uses an int comparison.
 */
public static int compare(Object o1,Object o2){
  int retval;
  if (o1 == null && o2 == null) {
    retval=0;
  }
 else   if (o1 == null) {
    retval=-1;
  }
 else   if (o2 == null) {
    retval=1;
  }
 else   if (o1.getClass() == String.class) {
    retval=compareIgnoreCase((String)o1,(String)o2);
  }
 else   if (o1 instanceof com.sun.java.util.collections.Comparable) {
    retval=((com.sun.java.util.collections.Comparable)o1).compareTo(o2);
  }
 else   if (o1 instanceof Integer) {
    retval=((Integer)o1).intValue() - ((Integer)o2).intValue();
  }
 else   if (o1 instanceof Boolean) {
    retval=o1.equals(o2) ? 0 : o1.equals(Boolean.TRUE) ? 1 : -1;
  }
 else   if (o1 instanceof Double || o1 instanceof Float) {
    double dbl=((Number)o1).doubleValue() - ((Number)o2).doubleValue();
    if (dbl > 0)     retval=1;
 else     if (dbl < 0)     retval=-1;
 else     retval=0;
  }
 else   if (o1 instanceof Number) {
    retval=((Number)o1).intValue() - ((Number)o2).intValue();
  }
 else {
    retval=0;
  }
  return retval;
}",0.9967302452316076
4751,"/** 
 * Checks if the <tt>QueryReply</tt> should be dropped based on per-TTL hard limits for the number of bytes routed for the given reply guid. This algorithm favors replies that don't have as far to go on the  network -- i.e., low TTL hits have more liberal limits than high TTL hits.  This ensures that hits that are closer to the query originator -- hits for which we've already done most of the work, are not  dropped unless we've routed a really large number of bytes for that guid.
 */
private static boolean shouldDropReply(int bytesRouted,int ttl){
  if (ttl > 3 && bytesRouted < 50 * 1024)   return true;
  if (ttl == 0 && bytesRouted < 50 * 1024)   return true;
  if (ttl == 1 && bytesRouted < 1000 * 1024)   return true;
  if (ttl == 2 && bytesRouted < 333 * 1024)   return true;
  if (ttl == 3 && bytesRouted < 111 * 1024)   return true;
  return false;
}","/** 
 * Checks if the <tt>QueryReply</tt> should be dropped based on per-TTL hard limits for the number of bytes routed for the given reply guid. This algorithm favors replies that don't have as far to go on the  network -- i.e., low TTL hits have more liberal limits than high TTL hits.  This ensures that hits that are closer to the query originator -- hits for which we've already done most of the work, are not  dropped unless we've routed a really large number of bytes for that guid.
 */
private static boolean shouldDropReply(int bytesRouted,int ttl){
  if (ttl > 3 && bytesRouted < 50 * 1024)   return false;
  if (ttl == 0 && bytesRouted < 50 * 1024)   return false;
  if (ttl == 1 && bytesRouted < 1000 * 1024)   return false;
  if (ttl == 2 && bytesRouted < 333 * 1024)   return false;
  if (ttl == 3 && bytesRouted < 111 * 1024)   return false;
  return true;
}",0.9758897818599312
4752,"/** 
 * Tests the constructor that takes a URL and a URN as arguments.
 */
public void testUrlUrnConstructor(){
  try {
    for (int i=0; i < HugeTestUtils.URNS.length; i++) {
      URN urn=URN.createSHA1Urn(HugeTestUtils.VALID_URN_STRINGS[i]);
      URL url1=new URL(""String_Node_Str"",HugeTestUtils.URL_STRINGS[i],6346,""String_Node_Str"" + HugeTestUtils.URNS[i].httpStringValue());
      URL url2=new URL(""String_Node_Str"",HugeTestUtils.URL_STRINGS[i],""String_Node_Str"");
      AlternateLocation al1=AlternateLocation.createAlternateLocation(url1);
      AlternateLocation al2=AlternateLocation.createAlternateLocation(url2);
    }
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + ""String_Node_Str"" + e);
  }
}","/** 
 * Tests the constructor that takes a URL and a URN as arguments.
 */
public void testUrlUrnConstructor(){
  try {
    for (int i=0; i < HugeTestUtils.URNS.length; i++) {
      URN urn=URN.createSHA1Urn(HugeTestUtils.VALID_URN_STRINGS[i]);
      URL url1=new URL(""String_Node_Str"",HugeTestUtils.URL_STRINGS[i],6346,""String_Node_Str"" + HugeTestUtils.URNS[i].httpStringValue());
      URL url2=new URL(""String_Node_Str"",HugeTestUtils.URL_STRINGS[i],6346,""String_Node_Str"");
      AlternateLocation al1=AlternateLocation.createAlternateLocation(url1);
      AlternateLocation al2=AlternateLocation.createAlternateLocation(url2);
    }
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + ""String_Node_Str"" + e);
  }
}",0.9965445749827228
4753,"/** 
 * Tests invalid alternate location strings to make sure they fail.
 */
public void testStringConstructorForInvalidLocs(){
  try {
    for (int i=0; i < HugeTestUtils.INVALID_LOCS.length; i++) {
      AlternateLocation al=AlternateLocation.createAlternateLocation(HugeTestUtils.INVALID_LOCS[i]);
      assertTrue(""String_Node_Str"",false);
    }
  }
 catch (  IOException e) {
  }
}","/** 
 * Tests invalid alternate location strings to make sure they fail.
 */
public void testStringConstructorForInvalidLocs(){
  try {
    for (int i=0; i < HugeTestUtils.INVALID_LOCS.length; i++) {
      AlternateLocation al=AlternateLocation.createAlternateLocation(HugeTestUtils.INVALID_LOCS[i]);
      fail(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
  }
}",0.9736842105263158
4754,"/** 
 * Reloads the settings with the specified settings file from disk.
 * @param settingsStream the <tt>InputStream</tt> to load
 */
public void reload(File file){
  try {
    PROPS.load(new FileInputStream(file));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Reloads the settings with the specified settings file from disk.
 * @param settingsStream the <tt>InputStream</tt> to load
 */
public void reload(File file){
  if (!file.isFile())   return;
  try {
    PROPS.load(new FileInputStream(file));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9455782312925172
4755,"/** 
 * Test the method for copying files from jars to disk.
 */
public void testCommonUtilsCopyResourceFile(){
  File newResourceFile=new File(""String_Node_Str"",""String_Node_Str"");
  newResourceFile.deleteOnExit();
  String fileName=""String_Node_Str"";
  try {
    JarFile collections=new JarFile(new File(""String_Node_Str"",""String_Node_Str""));
    JarEntry entry=collections.getJarEntry(fileName);
    long entrySize=entry.getCompressedSize();
    CommonUtils.copyResourceFile(fileName,newResourceFile);
    assertEquals(""String_Node_Str"",entrySize,newResourceFile.length());
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e);
  }
  newResourceFile.delete();
  new File(""String_Node_Str"").delete();
}","/** 
 * Test the method for copying files from jars to disk.
 */
public void testCommonUtilsCopyResourceFile(){
  File newResourceFile=new File(""String_Node_Str"",""String_Node_Str"");
  newResourceFile.deleteOnExit();
  String fileName=""String_Node_Str"";
  try {
    JarFile collections=new JarFile(new File(""String_Node_Str"",""String_Node_Str""));
    JarEntry entry=collections.getJarEntry(fileName);
    long entrySize=entry.getCompressedSize();
    CommonUtils.copyResourceFile(fileName,newResourceFile,false);
    assertEquals(""String_Node_Str"",entrySize,newResourceFile.length());
  }
 catch (  Exception e) {
    fail(""String_Node_Str"" + e);
  }
  newResourceFile.delete();
  new File(""String_Node_Str"").delete();
}",0.9958041958041958
4756,"/** 
 * This method will be called just once from RouterService at startup and it should prompt the user if there is an update message.
 */
public void postGuiInit(ActivityCallback gui){
  String myVersion=CommonUtils.getLimeWireVersion();
  if (isGreaterVersion(myVersion,latestVersion))   return;
  String guiMessage=latestVersion + ""String_Node_Str"" + message;
  gui.notifyUserAboutUpdate(guiMessage,CommonUtils.isPro(),usesLocale);
}","/** 
 * This method will be called just once from RouterService at startup and it should prompt the user if there is an update message.
 */
public void postGuiInit(ActivityCallback gui){
  String myVersion=CommonUtils.getLimeWireVersion();
  if (myVersion.equalsIgnoreCase(latestVersion))   return;
  if (isGreaterVersion(myVersion,latestVersion))   return;
  String guiMessage=latestVersion + ""String_Node_Str"" + message;
  gui.notifyUserAboutUpdate(guiMessage,CommonUtils.isPro(),usesLocale);
}",0.9367631296891747
4757,"/** 
 * writes data to signed_updateFile
 */
private void commitVersionFile(byte[] data) throws IOException {
  File f=new File(CommonUtils.getUserSettingsDir(),""String_Node_Str"");
  File nf=new File(CommonUtils.getUserSettingsDir(),""String_Node_Str"");
  RandomAccessFile raf=new RandomAccessFile(nf,""String_Node_Str"");
  raf.write(data);
  boolean deleted=nf.renameTo(f);
  if (!deleted)   throw new IOException();
}","/** 
 * writes data to signed_updateFile
 */
private void commitVersionFile(byte[] data) throws IOException {
  File f=new File(CommonUtils.getUserSettingsDir(),""String_Node_Str"");
  File nf=new File(CommonUtils.getUserSettingsDir(),""String_Node_Str"");
  RandomAccessFile raf=new RandomAccessFile(nf,""String_Node_Str"");
  raf.write(data);
  raf.close();
  boolean deleteOld=f.delete();
  if (deleteOld) {
    boolean renamed=nf.renameTo(f);
    if (!renamed) {
      nf.delete();
      throw new IOException();
    }
  }
 else {
    nf.delete();
    throw new IOException();
  }
}",0.8204613841524574
4758,"public void checkAndUpdate(Connection connection){
  String nv=connection.getProperty(ConnectionHandshakeHeaders.X_VERSION);
  debug(""String_Node_Str"" + latestVersion + ""String_Node_Str""+ nv);
  if (!isGreaterVersion(nv,latestVersion))   return;
  final Connection c=connection;
  Thread checker=new Thread(){
    public void run(){
      debug(""String_Node_Str"");
      final String UPDATE=""String_Node_Str"";
      String ip=c.getOrigHost();
      int port=c.getOrigPort();
      byte[] data=null;
      try {
        URL url=new URL(""String_Node_Str"",ip,port,UPDATE);
        HttpURLConnection connection=(HttpURLConnection)url.openConnection();
        connection.setUseCaches(false);
        connection.setRequestProperty(""String_Node_Str"",CommonUtils.getHttpServer());
        connection.setRequestProperty(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
        connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
        InputStream in=connection.getInputStream();
        int len=connection.getContentLength();
        debug(""String_Node_Str"" + len);
        data=new byte[len];
        int BUF_LEN=1024;
        byte[] buf=new byte[BUF_LEN];
        int iters=len % BUF_LEN == 0 ? len / BUF_LEN : (len / BUF_LEN) + 1;
        ByteReader byteReader=new ByteReader(in);
        int totalRead=0;
        for (int i=0; i < iters; i++) {
          int left=len - totalRead;
          int a=byteReader.read(buf,0,Math.min(BUF_LEN,left));
          if (a == -1)           break;
          System.arraycopy(buf,0,data,totalRead,a);
          totalRead+=a;
        }
        UpdateMessageVerifier verifier=new UpdateMessageVerifier(data);
        boolean verified=verifier.verifySource();
        if (!verified) {
          debug(""String_Node_Str"");
          return;
        }
        debug(""String_Node_Str"");
        String xml=new String(verifier.getMessageBytes(),""String_Node_Str"");
        UpdateFileParser parser=new UpdateFileParser(xml);
        debug(""String_Node_Str"" + parser.getVersion());
        String newVersion=parser.getVersion();
        if (newVersion == null)         return;
        if (isGreaterVersion(newVersion,latestVersion)) {
synchronized (UpdateManager.this) {
            commitVersionFile(data);
            latestVersion=newVersion;
          }
        }
      }
 catch (      Exception e) {
        return;
      }
    }
  }
;
  checker.start();
}","public void checkAndUpdate(Connection connection){
  String nv=connection.getProperty(ConnectionHandshakeHeaders.X_VERSION);
  debug(""String_Node_Str"" + latestVersion + ""String_Node_Str""+ nv);
  if (!isGreaterVersion(nv,latestVersion))   return;
  final Connection c=connection;
  Thread checker=new Thread(){
    public void run(){
      debug(""String_Node_Str"");
      final String UPDATE=""String_Node_Str"";
      String ip=c.getOrigHost();
      int port=c.getOrigPort();
      byte[] data=null;
      try {
        URL url=new URL(""String_Node_Str"",ip,port,UPDATE);
        HttpURLConnection connection=(HttpURLConnection)url.openConnection();
        connection.setUseCaches(false);
        connection.setRequestProperty(""String_Node_Str"",CommonUtils.getHttpServer());
        connection.setRequestProperty(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
        connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
        InputStream in=connection.getInputStream();
        int len=connection.getContentLength();
        debug(""String_Node_Str"" + len);
        data=new byte[len];
        int BUF_LEN=1024;
        byte[] buf=new byte[BUF_LEN];
        int iters=len % BUF_LEN == 0 ? len / BUF_LEN : (len / BUF_LEN) + 1;
        ByteReader byteReader=new ByteReader(in);
        int totalRead=0;
        for (int i=0; i < iters; i++) {
          int left=len - totalRead;
          int a=byteReader.read(buf,0,Math.min(BUF_LEN,left));
          if (a == -1)           break;
          System.arraycopy(buf,0,data,totalRead,a);
          totalRead+=a;
        }
        UpdateMessageVerifier verifier=new UpdateMessageVerifier(data);
        boolean verified=verifier.verifySource();
        if (!verified) {
          debug(""String_Node_Str"");
          return;
        }
        debug(""String_Node_Str"");
        String xml=new String(verifier.getMessageBytes(),""String_Node_Str"");
        UpdateFileParser parser=new UpdateFileParser(xml);
        debug(""String_Node_Str"" + parser.getVersion());
        String newVersion=parser.getVersion();
        if (newVersion == null)         return;
        if (isGreaterVersion(newVersion,latestVersion)) {
          debug(""String_Node_Str"");
synchronized (UpdateManager.this) {
            commitVersionFile(data);
            latestVersion=newVersion;
            debug(""String_Node_Str"" + latestVersion);
          }
        }
      }
 catch (      Exception e) {
        return;
      }
    }
  }
;
  checker.start();
}",0.9817073170731708
4759,"public void run(){
  debug(""String_Node_Str"");
  final String UPDATE=""String_Node_Str"";
  String ip=c.getOrigHost();
  int port=c.getOrigPort();
  byte[] data=null;
  try {
    URL url=new URL(""String_Node_Str"",ip,port,UPDATE);
    HttpURLConnection connection=(HttpURLConnection)url.openConnection();
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",CommonUtils.getHttpServer());
    connection.setRequestProperty(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    InputStream in=connection.getInputStream();
    int len=connection.getContentLength();
    debug(""String_Node_Str"" + len);
    data=new byte[len];
    int BUF_LEN=1024;
    byte[] buf=new byte[BUF_LEN];
    int iters=len % BUF_LEN == 0 ? len / BUF_LEN : (len / BUF_LEN) + 1;
    ByteReader byteReader=new ByteReader(in);
    int totalRead=0;
    for (int i=0; i < iters; i++) {
      int left=len - totalRead;
      int a=byteReader.read(buf,0,Math.min(BUF_LEN,left));
      if (a == -1)       break;
      System.arraycopy(buf,0,data,totalRead,a);
      totalRead+=a;
    }
    UpdateMessageVerifier verifier=new UpdateMessageVerifier(data);
    boolean verified=verifier.verifySource();
    if (!verified) {
      debug(""String_Node_Str"");
      return;
    }
    debug(""String_Node_Str"");
    String xml=new String(verifier.getMessageBytes(),""String_Node_Str"");
    UpdateFileParser parser=new UpdateFileParser(xml);
    debug(""String_Node_Str"" + parser.getVersion());
    String newVersion=parser.getVersion();
    if (newVersion == null)     return;
    if (isGreaterVersion(newVersion,latestVersion)) {
synchronized (UpdateManager.this) {
        commitVersionFile(data);
        latestVersion=newVersion;
      }
    }
  }
 catch (  Exception e) {
    return;
  }
}","public void run(){
  debug(""String_Node_Str"");
  final String UPDATE=""String_Node_Str"";
  String ip=c.getOrigHost();
  int port=c.getOrigPort();
  byte[] data=null;
  try {
    URL url=new URL(""String_Node_Str"",ip,port,UPDATE);
    HttpURLConnection connection=(HttpURLConnection)url.openConnection();
    connection.setUseCaches(false);
    connection.setRequestProperty(""String_Node_Str"",CommonUtils.getHttpServer());
    connection.setRequestProperty(HTTPHeaderName.CONNECTION.httpStringValue(),""String_Node_Str"");
    connection.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    InputStream in=connection.getInputStream();
    int len=connection.getContentLength();
    debug(""String_Node_Str"" + len);
    data=new byte[len];
    int BUF_LEN=1024;
    byte[] buf=new byte[BUF_LEN];
    int iters=len % BUF_LEN == 0 ? len / BUF_LEN : (len / BUF_LEN) + 1;
    ByteReader byteReader=new ByteReader(in);
    int totalRead=0;
    for (int i=0; i < iters; i++) {
      int left=len - totalRead;
      int a=byteReader.read(buf,0,Math.min(BUF_LEN,left));
      if (a == -1)       break;
      System.arraycopy(buf,0,data,totalRead,a);
      totalRead+=a;
    }
    UpdateMessageVerifier verifier=new UpdateMessageVerifier(data);
    boolean verified=verifier.verifySource();
    if (!verified) {
      debug(""String_Node_Str"");
      return;
    }
    debug(""String_Node_Str"");
    String xml=new String(verifier.getMessageBytes(),""String_Node_Str"");
    UpdateFileParser parser=new UpdateFileParser(xml);
    debug(""String_Node_Str"" + parser.getVersion());
    String newVersion=parser.getVersion();
    if (newVersion == null)     return;
    if (isGreaterVersion(newVersion,latestVersion)) {
      debug(""String_Node_Str"");
synchronized (UpdateManager.this) {
        commitVersionFile(data);
        latestVersion=newVersion;
        debug(""String_Node_Str"" + latestVersion);
      }
    }
  }
 catch (  Exception e) {
    return;
  }
}",0.9785002621919244
4760,"public Integer[] getStatHistory(){
  _statHistory=(Integer[])STAT_HISTORY.toArray(new Integer[0]);
  return _statHistory;
}","public Integer[] getStatHistory(){
synchronized (STAT_HISTORY) {
    _statHistory=(Integer[])STAT_HISTORY.toArray(new Integer[0]);
  }
  return _statHistory;
}",0.8723404255319149
4761,"public void storeCurrentStat(){
  STAT_HISTORY.remove(0);
  STAT_HISTORY.add(new Integer(_current));
  if (_current > _max) {
    _max=_current;
  }
  if (_writeStat) {
    if (_writer != null) {
      try {
        _writer.write(Integer.toString(_current));
        _writer.write(""String_Node_Str"");
        _writer.flush();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  _current=0;
  _totalStatsRecorded++;
}","public void storeCurrentStat(){
synchronized (STAT_HISTORY) {
    STAT_HISTORY.remove(0);
    STAT_HISTORY.add(new Integer(_current));
  }
  if (_current > _max) {
    _max=_current;
  }
  if (_writeStat) {
    if (_writer != null) {
      try {
        _writer.write(Integer.toString(_current));
        _writer.write(""String_Node_Str"");
        _writer.flush();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  _current=0;
  _totalStatsRecorded++;
}",0.929936305732484
4762,"/** 
 * Returns the version of the GUESS search scheme supported by the node at the other end of the connection.  This returns the version in whole numbers.  So, if the supported GUESS version is 0.1, this  will return 1.  If the other client has not sent an X-Guess header this returns -1.
 * @return the version of GUESS supported, reported as a whole number,or -1 if GUESS is not supported
 */
public int getGUESSVersion(){
  String value=super.getProperty(ConnectionHandshakeHeaders.X_GUESS);
  if (value == null)   return -1;
 else {
    float version=Float.parseFloat(value);
    version*=10;
    return (int)version;
  }
}","/** 
 * Returns the version of the GUESS search scheme supported by the node at the other end of the connection.  This returns the version in whole numbers.  So, if the supported GUESS version is 0.1, this  will return 1.  If the other client has not sent an X-Guess header this returns -1.
 * @return the version of GUESS supported, reported as a whole number,or -1 if GUESS is not supported
 */
public int getGUESSVersion(){
  String value=super.getProperty(ConnectionHandshakeHeaders.X_GUESS);
  if (value == null)   return -1;
 else {
    float version=Float.valueOf(value).floatValue();
    version*=10;
    return (int)version;
  }
}",0.9763406940063092
4763,"private void handleRequest(Socket socket) throws IOException {
  BufferedReader input=new BufferedReader(new InputStreamReader(socket.getInputStream()));
  ThrottledOutputStream output=new ThrottledOutputStream(new BufferedOutputStream(socket.getOutputStream()),new BandwidthThrottle(rate * 1024));
  int start=0;
  int stop=TestFile.length();
  boolean firstLine=true;
  while (true) {
    String line=input.readLine();
    if (firstLine) {
      request=line;
      firstLine=false;
    }
    if (line == null)     throw new IOException(""String_Node_Str"");
    if (line.equals(""String_Node_Str""))     break;
    if (HTTPHeaderName.ALT_LOCATION.matchesStartOfString(line)) {
      readAlternateLocations(line,incomingAltLocs);
    }
    if (HTTPHeaderName.CONTENT_URN.matchesStartOfString(line)) {
      sha1=readContentUrn(line);
    }
    int i=line.indexOf(""String_Node_Str"");
    Assert.that(i <= 0,""String_Node_Str"");
    if (i == 0) {
      IntPair p=null;
      try {
        p=parseRange(line);
      }
 catch (      Exception e) {
        Assert.that(false,""String_Node_Str"" + line + ""String_Node_Str"");
      }
      start=p.a;
      stop=p.b;
      ;
    }
    i=line.indexOf(""String_Node_Str"");
    if (i == 0)     http11=line.indexOf(""String_Node_Str"") > 0;
  }
  send(output,start,stop);
}","private void handleRequest(Socket socket) throws IOException {
  BufferedReader input=new BufferedReader(new InputStreamReader(socket.getInputStream()));
  ThrottledOutputStream output=new ThrottledOutputStream(new BufferedOutputStream(socket.getOutputStream()),new BandwidthThrottle(rate * 1024));
  int start=0;
  int stop=TestFile.length();
  boolean firstLine=true;
  while (true) {
    String line=input.readLine();
    if (firstLine) {
      request=line;
      firstLine=false;
    }
    if (line == null)     throw new IOException(""String_Node_Str"");
    if (line.equals(""String_Node_Str""))     break;
    if (HTTPHeaderName.ALT_LOCATION.matchesStartOfString(line)) {
      readAlternateLocations(line,incomingAltLocs);
    }
    if (HTTPHeaderName.GNUTELLA_CONTENT_URN.matchesStartOfString(line)) {
      sha1=readContentUrn(line);
    }
    int i=line.indexOf(""String_Node_Str"");
    Assert.that(i <= 0,""String_Node_Str"");
    if (i == 0) {
      IntPair p=null;
      try {
        p=parseRange(line);
      }
 catch (      Exception e) {
        Assert.that(false,""String_Node_Str"" + line + ""String_Node_Str"");
      }
      start=p.a;
      stop=p.b;
      ;
    }
    i=line.indexOf(""String_Node_Str"");
    if (i == 0)     http11=line.indexOf(""String_Node_Str"") > 0;
  }
  send(output,start,stop);
}",0.9965609476499808
4764,"public void incrementStat(){
  QUERY_REPLY_ROUTE_ERRORS.incrementStat();
}","public void incrementStat(){
  super.incrementStat();
  QUERY_REPLY_ROUTE_ERRORS.incrementStat();
}",0.8554913294797688
4765,"/** 
 * @modifies this
 * @effects atomically removes and returns the highest priority host inthis.  If no host is available, blocks until one is.  If the calling thread is interrupted during this process, throws InterruptedException. The caller should call doneWithConnect and doneWithMessageLoop when done with the returned value.
 */
public synchronized Endpoint getAnEndpoint() throws InterruptedException {
  while (true) {
    if (getNumUltrapeerHosts() == 0)     gWebCache.fetchEndpointsAsync();
    try {
      return getAnEndpointInternal();
    }
 catch (    NoSuchElementException e) {
    }
    wait();
  }
}","/** 
 * @modifies this
 * @effects atomically removes and returns the highest priority host inthis.  If no host is available, blocks until one is.  If the calling thread is interrupted during this process, throws InterruptedException. The caller should call doneWithConnect and doneWithMessageLoop when done with the returned value.
 */
public synchronized Endpoint getAnEndpoint() throws InterruptedException {
  while (true) {
    if (getNumHosts() == 0) {
      gWebCache.fetchEndpointsAsync();
    }
 else     if (getNumUltrapeerHosts() == 0) {
      long now=System.currentTimeMillis();
      if (now < nextAllowedFetchTime) {
        nextAllowedFetchTime=Math.min(nextAllowedFetchTime,now + GWEBCACHE_DELAY);
      }
 else {
        gWebCache.fetchEndpointsAsync();
        nextAllowedFetchTime=Long.MAX_VALUE;
      }
    }
    try {
      return getAnEndpointInternal();
    }
 catch (    NoSuchElementException e) {
    }
    wait();
  }
}",0.7767857142857143
4766,"/** 
 * Notifies this that connect() has been called.  This may decide to give out bootstrap pongs if necessary.
 */
public synchronized void expire(){
  gWebCache.fetchBootstrapServersAsync();
  gWebCache.fetchEndpointsAsync();
}","/** 
 * Notifies this that connect() has been called.  This may decide to give out bootstrap pongs if necessary.
 */
public synchronized void expire(){
  gWebCache.fetchBootstrapServersAsync();
}",0.9176470588235294
4767,"/** 
 * Returns the directory where all user settings should be stored.  This is where all application data should be stored.  If the directory does does not already exist, this attempts to create the directory, although this is not guaranteed to succeed.
 * @return the <tt>File</tt> instance denoting the user's home directory for the application, or <tt>null</tt> if that directory  does not exist
 */
public static File getUserSettingsDir(){
  File settingsDir=null;
  if (CommonUtils.isWindows()) {
    settingsDir=CommonUtils.getCurrentDirectory();
  }
 else   if (CommonUtils.isMacOSX()) {
    File userPrefsDir;
    try {
      short userDomainCode=-32763;
      userPrefsDir=MRJFileUtils.findFolder(userDomainCode,new MRJOSType(""String_Node_Str""));
      settingsDir=new File(userPrefsDir,""String_Node_Str"");
    }
 catch (    FileNotFoundException e) {
    }
catch (    NoSuchMethodError e) {
      settingsDir=CommonUtils.getCurrentDirectory();
    }
  }
 else {
    settingsDir=new File(CommonUtils.getUserHomeDir(),""String_Node_Str"");
  }
  if (settingsDir == null) {
    settingsDir=new File(CommonUtils.getUserHomeDir(),""String_Node_Str"");
  }
  if (!settingsDir.isDirectory()) {
    settingsDir.mkdirs();
  }
  return settingsDir;
}","/** 
 * Returns the directory where all user settings should be stored.  This is where all application data should be stored.  If the directory does does not already exist, this attempts to create the directory, although this is not guaranteed to succeed.
 * @return the <tt>File</tt> instance denoting the user's home directory for the application, or <tt>null</tt> if that directory  does not exist
 */
public synchronized static File getUserSettingsDir(){
  File settingsDir=new File(getUserHomeDir(),LIMEWIRE_PREFS_DIR_NAME);
  if (CommonUtils.isMacOSX()) {
    File tempSettingsDir=new File(getUserHomeDir(),""String_Node_Str"");
    settingsDir=new File(tempSettingsDir,""String_Node_Str"");
  }
  if (!settingsDir.isDirectory()) {
    if (!settingsDir.mkdirs()) {
      String msg=""String_Node_Str"" + settingsDir;
      throw new RuntimeException(msg);
    }
  }
  moveWindowsFiles(settingsDir);
  return settingsDir;
}",0.5059907834101383
4768,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(BootstrapServerTest.suite());
  suite.addTest(BootstrapServerManagerTest.suite());
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(BootstrapServerTest.suite());
  suite.addTest(BootstrapServerManagerTest.suite());
  suite.addTest(HostCatcherFetchTest.suite());
  return suite;
}",0.8929384965831435
4769,"public void run(){
  Iterator keys=null;
  Set toRemove=new HashSet();
synchronized (_pushedHosts) {
    keys=_pushedHosts.keySet().iterator();
    while (keys.hasNext()) {
      Object currKey=keys.next();
      PushRequestDetails currPRD=null;
      currPRD=(PushRequestDetails)_pushedHosts.get(currKey);
      if ((currPRD != null) && (currPRD.isExpired())) {
        debug(""String_Node_Str"");
        toRemove.add(currKey);
        currPRD.bhh._callback.browseHostFailed(currPRD.bhh._guid);
      }
    }
    keys=toRemove.iterator();
    while (keys.hasNext())     _pushedHosts.remove(keys.next());
  }
}","public void run(){
  try {
    Iterator keys=null;
    Set toRemove=new HashSet();
synchronized (_pushedHosts) {
      keys=_pushedHosts.keySet().iterator();
      while (keys.hasNext()) {
        Object currKey=keys.next();
        PushRequestDetails currPRD=null;
        currPRD=(PushRequestDetails)_pushedHosts.get(currKey);
        if ((currPRD != null) && (currPRD.isExpired())) {
          debug(""String_Node_Str"");
          toRemove.add(currKey);
          currPRD.bhh._callback.browseHostFailed(currPRD.bhh._guid);
        }
      }
      keys=toRemove.iterator();
      while (keys.hasNext())       _pushedHosts.remove(keys.next());
    }
  }
 catch (  Throwable t) {
    RouterService.error(t);
  }
}",0.9220287660862982
4770,"public void run(){
  Endpoint endpoint=null;
  do {
    try {
      endpoint=_catcher.getAnEndpoint();
    }
 catch (    InterruptedException exc2) {
      return;
    }
  }
 while (isConnected(endpoint));
  Assert.that(endpoint != null);
  ManagedConnection connection=new ManagedConnection(endpoint.getHostname(),endpoint.getPort(),_router,ConnectionManager.this);
  try {
    try {
      initializeFetchedConnection(connection,this);
      _catcher.doneWithConnect(endpoint,true);
    }
 catch (    NoGnutellaOkException e) {
      _catcher.doneWithConnect(endpoint,true);
      throw e;
    }
catch (    IOException e) {
      _catcher.doneWithConnect(endpoint,false);
      throw e;
    }
    startConnection(connection);
  }
 catch (  IOException e) {
  }
catch (  Exception e) {
    RouterService.error(ActivityCallback.INTERNAL_ERROR,e);
  }
 finally {
    if (connection.isClientSupernodeConnection())     lostShieldedClientSupernodeConnection();
  }
}","public void run(){
  Endpoint endpoint=null;
  do {
    try {
      endpoint=_catcher.getAnEndpoint();
    }
 catch (    InterruptedException exc2) {
      return;
    }
  }
 while (isConnected(endpoint));
  Assert.that(endpoint != null);
  ManagedConnection connection=new ManagedConnection(endpoint.getHostname(),endpoint.getPort(),_router,ConnectionManager.this);
  try {
    try {
      initializeFetchedConnection(connection,this);
      _catcher.doneWithConnect(endpoint,true);
    }
 catch (    NoGnutellaOkException e) {
      _catcher.doneWithConnect(endpoint,true);
      throw e;
    }
catch (    IOException e) {
      _catcher.doneWithConnect(endpoint,false);
      throw e;
    }
    startConnection(connection);
  }
 catch (  IOException e) {
  }
catch (  Throwable e) {
    RouterService.error(ActivityCallback.INTERNAL_ERROR,e);
  }
 finally {
    if (connection.isClientSupernodeConnection())     lostShieldedClientSupernodeConnection();
  }
}",0.9906347554630592
4771,"/** 
 * Loop forever, replacing old dud connections with new good ones. 
 */
public void run(){
  while (true) {
    List duds=findDuds();
    if (duds.size() > 0) {
      killIfStillDud(duds);
    }
  }
}","/** 
 * Loop forever, replacing old dud connections with new good ones. 
 */
public void run(){
  try {
    while (true) {
      List duds=findDuds();
      if (duds.size() > 0) {
        killIfStillDud(duds);
      }
    }
  }
 catch (  Throwable t) {
    RouterService.error(t);
  }
}",0.745417515274949
4772,"public void run(){
  if (downloadsInProgress() > 0)   writeSnapshot();
}","public void run(){
  try {
    if (downloadsInProgress() > 0)     writeSnapshot();
  }
 catch (  Throwable t) {
    RouterService.error(t);
  }
}",0.663594470046083
4773,"/** 
 * Performs the slow, low-priority initialization tasks: reading in snapshots and scheduling snapshot checkpointing.
 */
public void postGuiInit(){
  readSnapshot(SettingsManager.instance().getDownloadSnapshotFile());
  Runnable checkpointer=new Runnable(){
    public void run(){
      if (downloadsInProgress() > 0)       writeSnapshot();
    }
  }
;
  RouterService.schedule(checkpointer,SNAPSHOT_CHECKPOINT_TIME,SNAPSHOT_CHECKPOINT_TIME);
}","/** 
 * Performs the slow, low-priority initialization tasks: reading in snapshots and scheduling snapshot checkpointing.
 */
public void postGuiInit(){
  readSnapshot(SettingsManager.instance().getDownloadSnapshotFile());
  Runnable checkpointer=new Runnable(){
    public void run(){
      try {
        if (downloadsInProgress() > 0)         writeSnapshot();
      }
 catch (      Throwable t) {
        RouterService.error(t);
      }
    }
  }
;
  RouterService.schedule(checkpointer,SNAPSHOT_CHECKPOINT_TIME,SNAPSHOT_CHECKPOINT_TIME);
}",0.9061553985872856
4774,"public void run(){
  try {
    loadSettingsBlocking(notifyOnClearFinal);
  }
 catch (  Exception e) {
    _callback.error(e);
  }
}","public void run(){
  try {
    loadSettingsBlocking(notifyOnClearFinal);
  }
 catch (  Throwable t) {
    _callback.error(t);
  }
}",0.9236641221374046
4775,"/** 
 * Ensures this contains exactly the files specified by the EXTENSIONS_TO_SEARCH_FOR and DIRECTORIES_TO_SEARCH_FOR_FILES properties. That is, clears this and loads all files with the given extensions in the given directories <i>and their children</i>.  Note that some files in this before the call will not be in this after the call, or they may have a different index.  If DIRECTORIES_TO_SEARCH_FOR_FILES contains duplicate directories, the duplicates will be ignored.  If it contains files, they will be ignored.<p> This method is thread-safe but non-blocking.  When the method returns, the directory and extension settings used by addFileIfShared() are initialized.  However, files will actually be indexed asynchronously in another thread.  This is useful because indexing may take up to 30 seconds or so if sharing many files.  If loadSettings is subsequently called before the indexing is complete, the original settings are discarded, and loading starts over immediately. Modification 8/01 - This method is still non-blocking and thread safe, but it was refactored to make for easier subclassing of FileManager. Now, a protected method called loadSettingsBlocking() is used to index the files asynchronously.  Subclasses can override or extend this method to impose their own functionality.  For example, see MetaFileManager.
 * @modifies this 
 * @param notifyOnClear if true, callback is notified via clearSharedFileswhen the previous load settings thread has been killed.
 */
public void loadSettings(boolean notifyOnClear){
synchronized (_loadThreadLock) {
    if (_loadThread != null) {
      _loadThreadInterrupted=true;
      _loadThread.interrupt();
      try {
        _loadThread.join();
      }
 catch (      InterruptedException e) {
        return;
      }
    }
    final boolean notifyOnClearFinal=notifyOnClear;
    _loadThreadInterrupted=false;
    _loadThread=new Thread(""String_Node_Str""){
      public void run(){
        try {
          loadSettingsBlocking(notifyOnClearFinal);
        }
 catch (        Exception e) {
          _callback.error(e);
        }
      }
    }
;
    _loadThread.start();
  }
}","/** 
 * Ensures this contains exactly the files specified by the EXTENSIONS_TO_SEARCH_FOR and DIRECTORIES_TO_SEARCH_FOR_FILES properties. That is, clears this and loads all files with the given extensions in the given directories <i>and their children</i>.  Note that some files in this before the call will not be in this after the call, or they may have a different index.  If DIRECTORIES_TO_SEARCH_FOR_FILES contains duplicate directories, the duplicates will be ignored.  If it contains files, they will be ignored.<p> This method is thread-safe but non-blocking.  When the method returns, the directory and extension settings used by addFileIfShared() are initialized.  However, files will actually be indexed asynchronously in another thread.  This is useful because indexing may take up to 30 seconds or so if sharing many files.  If loadSettings is subsequently called before the indexing is complete, the original settings are discarded, and loading starts over immediately. Modification 8/01 - This method is still non-blocking and thread safe, but it was refactored to make for easier subclassing of FileManager. Now, a protected method called loadSettingsBlocking() is used to index the files asynchronously.  Subclasses can override or extend this method to impose their own functionality.  For example, see MetaFileManager.
 * @modifies this 
 * @param notifyOnClear if true, callback is notified via clearSharedFileswhen the previous load settings thread has been killed.
 */
public void loadSettings(boolean notifyOnClear){
synchronized (_loadThreadLock) {
    if (_loadThread != null) {
      _loadThreadInterrupted=true;
      _loadThread.interrupt();
      try {
        _loadThread.join();
      }
 catch (      InterruptedException e) {
        return;
      }
    }
    final boolean notifyOnClearFinal=notifyOnClear;
    _loadThreadInterrupted=false;
    _loadThread=new Thread(""String_Node_Str""){
      public void run(){
        try {
          loadSettingsBlocking(notifyOnClearFinal);
        }
 catch (        Throwable t) {
          _callback.error(t);
        }
      }
    }
;
    _loadThread.start();
  }
}",0.994389901823282
4776,"public void run(){
  if (RouterService.acceptedIncomingConnection() && RouterService.isSupernode()) {
    Endpoint e=new Endpoint(RouterService.getAddress(),RouterService.getPort());
    gWebCache.sendUpdatesAsync(e);
  }
}","public void run(){
  try {
    if (RouterService.acceptedIncomingConnection() && RouterService.isSupernode()) {
      Endpoint e=new Endpoint(RouterService.getAddress(),RouterService.getPort());
      gWebCache.sendUpdatesAsync(e);
    }
  }
 catch (  Throwable t) {
    RouterService.error(t);
  }
}",0.8527724665391969
4777,"/** 
 * Links the HostCatcher up with the other back end pieces, and, if quick connect is not specified in the SettingsManager, loads the hosts in the host list into the maybe set.  (The likelys set is empty.)  If filename does not exist, then no error message is printed and this is initially empty.  The file is expected to contain a sequence of lines in the format ""<host>:port\n"".  Lines not in this format are silently ignored.
 */
public void initialize(){
  String filename=settings.getHostList();
  try {
    if (filename != null)     read(filename);
  }
 catch (  FileNotFoundException e) {
  }
catch (  IOException e) {
  }
  Runnable updater=new Runnable(){
    public void run(){
      if (RouterService.acceptedIncomingConnection() && RouterService.isSupernode()) {
        Endpoint e=new Endpoint(RouterService.getAddress(),RouterService.getPort());
        gWebCache.sendUpdatesAsync(e);
      }
    }
  }
;
  RouterService.schedule(updater,BootstrapServerManager.UPDATE_DELAY_MSEC,BootstrapServerManager.UPDATE_DELAY_MSEC);
}","/** 
 * Links the HostCatcher up with the other back end pieces, and, if quick connect is not specified in the SettingsManager, loads the hosts in the host list into the maybe set.  (The likelys set is empty.)  If filename does not exist, then no error message is printed and this is initially empty.  The file is expected to contain a sequence of lines in the format ""<host>:port\n"".  Lines not in this format are silently ignored.
 */
public void initialize(){
  String filename=settings.getHostList();
  try {
    if (filename != null)     read(filename);
  }
 catch (  FileNotFoundException e) {
  }
catch (  IOException e) {
  }
  Runnable updater=new Runnable(){
    public void run(){
      try {
        if (RouterService.acceptedIncomingConnection() && RouterService.isSupernode()) {
          Endpoint e=new Endpoint(RouterService.getAddress(),RouterService.getPort());
          gWebCache.sendUpdatesAsync(e);
        }
      }
 catch (      Throwable t) {
        RouterService.error(t);
      }
    }
  }
;
  RouterService.schedule(updater,BootstrapServerManager.UPDATE_DELAY_MSEC,BootstrapServerManager.UPDATE_DELAY_MSEC);
}",0.9554841670491052
4778,"/** 
 * While the connection is not closed, sends all data delay. 
 */
public void run(){
  while (true) {
    repOk();
    try {
      waitForQueued();
      sendQueued();
    }
 catch (    IOException e) {
      if (_manager != null)       _manager.remove(ManagedConnection.this);
      _runnerDied=true;
      return;
    }
    repOk();
  }
}","/** 
 * While the connection is not closed, sends all data delay. 
 */
public void run(){
  try {
    while (true) {
      repOk();
      try {
        waitForQueued();
        sendQueued();
      }
 catch (      IOException e) {
        if (_manager != null)         _manager.remove(ManagedConnection.this);
        _runnerDied=true;
        return;
      }
      repOk();
    }
  }
 catch (  Throwable t) {
    RouterService.error(t);
  }
}",0.8081321473951716
4779,"public void run(){
  queryLoop();
}","public void run(){
  try {
    queryLoop();
  }
 catch (  Throwable t) {
    RouterService.error(t);
  }
}",0.4964539007092198
4780,"private QueryUnicaster(){
  _queries=new Hashtable();
  _queryHosts=new LinkedList();
  _pingList=new FixedSizeList(25);
  _querySets=new Hashtable();
  _qGuidsToRemove=new Vector();
  _querier=new Thread(){
    public void run(){
      queryLoop();
    }
  }
;
  if (SettingsManager.instance().getGuessEnabled())   _querier.start();
}","private QueryUnicaster(){
  _queries=new Hashtable();
  _queryHosts=new LinkedList();
  _pingList=new FixedSizeList(25);
  _querySets=new Hashtable();
  _qGuidsToRemove=new Vector();
  _querier=new Thread(){
    public void run(){
      try {
        queryLoop();
      }
 catch (      Throwable t) {
        RouterService.error(t);
      }
    }
  }
;
  if (SettingsManager.instance().getGuessEnabled())   _querier.start();
}",0.8804204993429697
4781,"public void run(){
  Set reqUrns=new HashSet();
  reqUrns.add(UrnType.ANY_TYPE);
  QueryRequest qr=new QueryRequest(guid,SETTINGS.getTTL(),minSpeed,query,richQuery,false,reqUrns,null);
  verifier.record(qr,type);
  router.broadcastQueryRequest(qr);
}","public void run(){
  try {
    Set reqUrns=new HashSet();
    reqUrns.add(UrnType.ANY_TYPE);
    QueryRequest qr=new QueryRequest(guid,SETTINGS.getTTL(),minSpeed,query,richQuery,false,reqUrns,null);
    verifier.record(qr,type);
    router.broadcastQueryRequest(qr);
  }
 catch (  Throwable t) {
    RouterService.error(t);
  }
}",0.8635578583765112
4782,"/** 
 * Shuts down the backend and writes the gnutella.net file.
 */
public static void shutdown(){
  Statistics.instance().shutdown();
  try {
    catcher.write(SETTINGS.getHostList());
  }
 catch (  IOException e) {
  }
 finally {
    SETTINGS.writeProperties();
  }
  File incompleteDir=null;
  try {
    incompleteDir=SETTINGS.getIncompleteDirectory();
  }
 catch (  java.io.FileNotFoundException fnfe) {
    return;
  }
  String[] files=incompleteDir.list();
  if (files == null)   return;
  for (int i=0; i < files.length; i++) {
    if (files[i].startsWith(IncompleteFileManager.PREVIEW_PREFIX)) {
      File file=new File(incompleteDir,files[i]);
      file.delete();
    }
  }
  downloader.writeSnapshot();
  Cookies.instance().save();
  UrnCache.instance().persistCache();
}","/** 
 * Shuts down the backend and writes the gnutella.net file.
 */
public static void shutdown(){
  try {
    Statistics.instance().shutdown();
    try {
      catcher.write(SETTINGS.getHostList());
    }
 catch (    IOException e) {
    }
 finally {
      SETTINGS.writeProperties();
    }
    File incompleteDir=null;
    try {
      incompleteDir=SETTINGS.getIncompleteDirectory();
    }
 catch (    java.io.FileNotFoundException fnfe) {
      return;
    }
    String[] files=incompleteDir.list();
    if (files == null)     return;
    for (int i=0; i < files.length; i++) {
      if (files[i].startsWith(IncompleteFileManager.PREVIEW_PREFIX)) {
        File file=new File(incompleteDir,files[i]);
        file.delete();
      }
    }
    downloader.writeSnapshot();
    Cookies.instance().save();
    UrnCache.instance().persistCache();
  }
 catch (  Throwable t) {
    RouterService.error(t);
  }
}",0.9083382613837966
4783,"/** 
 * Writes out the properties file to with the specified name in the user's install directory.  This should only get called once when the program shuts down.
 */
public void writeProperties(){
  FileOutputStream ostream=null;
  try {
    ostream=new FileOutputStream(PROPS_FILE);
    PROPS.save(ostream,""String_Node_Str"");
    ostream.close();
  }
 catch (  Exception e) {
    showInternalError(e);
  }
 finally {
    try {
      if (ostream != null)       ostream.close();
    }
 catch (    IOException e) {
      showInternalError(e);
    }
  }
}","/** 
 * Writes out the properties file to with the specified name in the user's install directory.  This should only get called once when the program shuts down.
 */
public void writeProperties(){
  FileOutputStream ostream=null;
  try {
    ostream=new FileOutputStream(PROPS_FILE);
    PROPS.save(ostream,""String_Node_Str"");
    ostream.close();
  }
 catch (  Throwable e) {
    showInternalError(e);
  }
 finally {
    try {
      if (ostream != null)       ostream.close();
    }
 catch (    IOException e) {
      showInternalError(e);
    }
  }
}",0.9836956521739132
4784,"/** 
 * Schedules a timer event to continually updates the upload and download bandwidth used.  Non-blocking.
 * @param router provides the schedule(..) method for the timing
 */
public void start(){
  Runnable task=new Runnable(){
    public void run(){
      collectBandwidthData();
    }
  }
;
  RouterService.schedule(task,0,TIMER_DELAY);
}","/** 
 * Schedules a timer event to continually updates the upload and download bandwidth used.  Non-blocking.
 * @param router provides the schedule(..) method for the timing
 */
public void start(){
  Runnable task=new Runnable(){
    public void run(){
      try {
        collectBandwidthData();
      }
 catch (      Throwable t) {
        RouterService.error(t);
      }
    }
  }
;
  RouterService.schedule(task,0,TIMER_DELAY);
}",0.883183568677792
4785,"public void run(){
  collectBandwidthData();
}","public void run(){
  try {
    collectBandwidthData();
  }
 catch (  Throwable t) {
    RouterService.error(t);
  }
}",0.5644171779141104
4786,"public synchronized boolean resume() throws AlreadyDownloadingException {
  if (!(state == WAITING_FOR_RETRY || state == GAVE_UP || state == ABORTED || state == WAITING_FOR_RESULTS))   return false;
  String conflict=this.manager.conflicts(allFiles,this);
  if (conflict != null)   throw new AlreadyDownloadingException(conflict);
  if (state == GAVE_UP || state == ABORTED) {
    initialize(this.manager,this.fileManager,this.callback);
  }
 else   if (state == WAITING_FOR_RETRY) {
    if (dloaderManagerThread != null)     dloaderManagerThread.interrupt();
  }
 else   if (state == WAITING_FOR_RESULTS) {
    reqLock.release();
  }
  return true;
}","public boolean resume() throws AlreadyDownloadingException {
synchronized (this) {
    if (!(state == WAITING_FOR_RETRY || state == GAVE_UP || state == ABORTED || state == WAITING_FOR_RESULTS))     return false;
  }
  String conflict=this.manager.conflicts(allFiles,this);
  if (conflict != null)   throw new AlreadyDownloadingException(conflict);
synchronized (this) {
    if (state == GAVE_UP || state == ABORTED) {
      initialize(this.manager,this.fileManager,this.callback);
    }
 else     if (state == WAITING_FOR_RETRY) {
      if (dloaderManagerThread != null)       dloaderManagerThread.interrupt();
    }
 else     if (state == WAITING_FOR_RESULTS) {
      reqLock.release();
    }
    return true;
  }
}",0.9334308705193856
4787,"/** 
 * Accepts a new upload, creating a new <tt>HTTPUploader</tt> if it successfully parses the HTTP request.  BLOCKING.
 * @param method the initial request type to use, e.g., GET or HEAD
 * @param socket the <tt>Socket</tt> that will be used for the new upload.It is assumed that the initial word of the request (e.g., ""GET"") has been consumed (e.g., by Acceptor)
 */
public void acceptUpload(final HTTPRequestMethod method,Socket socket){
  debug(""String_Node_Str"");
  HTTPUploader uploader=null;
  try {
    int queued=-1;
    String oldFileName=""String_Node_Str"";
    HTTPRequestMethod currentMethod=method;
    while (true) {
      HttpRequestLine line=parseHttpRequest(socket);
      debug(""String_Node_Str"");
      String fileName=line._fileName;
      uploader=new HTTPUploader(currentMethod,fileName,socket,line._index);
      uploader.readHeader();
      debug(uploader + ""String_Node_Str"");
      boolean giveSlot=(oldFileName.equalsIgnoreCase(fileName) && queued == ACCEPTED);
      queued=doSingleUpload(uploader,socket,socket.getInetAddress().getHostAddress(),line._index,giveSlot);
      oldFileName=fileName;
      if ((!line.isHTTP11() || uploader.getCloseConnection()) && queued != QUEUED)       return;
      debug(uploader + ""String_Node_Str"");
      int oldTimeout=socket.getSoTimeout();
      if (queued != QUEUED)       socket.setSoTimeout(SettingsManager.instance().getPersistentHTTPConnectionTimeout());
      String word=IOUtils.readWord(socket.getInputStream(),4);
      debug(uploader + ""String_Node_Str"");
      socket.setSoTimeout(oldTimeout);
      if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.GET;
 else       if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.HEAD;
 else       return;
    }
  }
 catch (  IOException ioe) {
    debug(""String_Node_Str"");
  }
 finally {
synchronized (this) {
      boolean found=false;
      for (Iterator iter=_queuedUploads.iterator(); iter.hasNext(); ) {
        KeyValue kv=(KeyValue)iter.next();
        if (kv.getKey() == socket) {
          found=true;
          iter.remove();
        }
      }
      if (found)       uploader.setState(Uploader.INTERRUPTED);
    }
    debug(""String_Node_Str"");
    close(socket);
  }
}","/** 
 * Accepts a new upload, creating a new <tt>HTTPUploader</tt> if it successfully parses the HTTP request.  BLOCKING.
 * @param method the initial request type to use, e.g., GET or HEAD
 * @param socket the <tt>Socket</tt> that will be used for the new upload.It is assumed that the initial word of the request (e.g., ""GET"") has been consumed (e.g., by Acceptor)
 */
public void acceptUpload(final HTTPRequestMethod method,Socket socket){
  debug(""String_Node_Str"");
  HTTPUploader uploader=null;
  try {
    int queued=-1;
    String oldFileName=""String_Node_Str"";
    HTTPRequestMethod currentMethod=method;
    while (true) {
      HttpRequestLine line=parseHttpRequest(socket);
      debug(""String_Node_Str"");
      String fileName=line._fileName;
      uploader=new HTTPUploader(currentMethod,fileName,socket,line._index,uploader);
      uploader.readHeader();
      debug(uploader + ""String_Node_Str"");
      boolean giveSlot=(oldFileName.equalsIgnoreCase(fileName) && queued == ACCEPTED);
      queued=doSingleUpload(uploader,socket,socket.getInetAddress().getHostAddress(),line._index,giveSlot);
      oldFileName=fileName;
      if ((!line.isHTTP11() || uploader.getCloseConnection()) && queued != QUEUED)       return;
      debug(uploader + ""String_Node_Str"");
      int oldTimeout=socket.getSoTimeout();
      if (queued != QUEUED)       socket.setSoTimeout(SettingsManager.instance().getPersistentHTTPConnectionTimeout());
      String word=IOUtils.readWord(socket.getInputStream(),4);
      debug(uploader + ""String_Node_Str"");
      socket.setSoTimeout(oldTimeout);
      if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.GET;
 else       if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.HEAD;
 else       return;
    }
  }
 catch (  IOException ioe) {
    debug(""String_Node_Str"");
  }
 finally {
synchronized (this) {
      boolean found=false;
      for (Iterator iter=_queuedUploads.iterator(); iter.hasNext(); ) {
        KeyValue kv=(KeyValue)iter.next();
        if (kv.getKey() == socket) {
          found=true;
          iter.remove();
        }
      }
      if (found)       uploader.setState(Uploader.INTERRUPTED);
    }
    debug(""String_Node_Str"");
    close(socket);
  }
}",0.9980013324450366
4788,"public void testSoftMax(){
  UploadManager upManager=new UploadManager();
  SettingsManager.instance().setMaxUploads(9999);
  SettingsManager.instance().setSoftMaxUploads(2);
  SettingsManager.instance().setUploadsPerPerson(99999);
  SettingsManager.instance().setUploadQueueSize(2);
  HTTPDownloader d3=null;
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd2,true);
    try {
      d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
      connectDloader(d3,true,rfd3,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(1,qx.getQueuePosition());
    }
catch (    Exception ioe) {
      ioe.printStackTrace();
      fail(""String_Node_Str"");
    }
    kill(d1);
    Thread.sleep((UploadManager.MIN_POLL_TIME + UploadManager.MAX_POLL_TIME) / 2);
    try {
      connectDloader(d3,false,rfd3,true);
    }
 catch (    QueuedException e) {
      e.printStackTrace();
      fail(""String_Node_Str"" + e.getQueuePosition());
    }
catch (    TryAgainLaterException tlx) {
      fail(""String_Node_Str"");
    }
catch (    Exception ign) {
      ign.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception anyother) {
    System.out.println(""String_Node_Str"");
    anyother.printStackTrace();
  }
}","public void testSoftMax(){
  UploadManager upManager=new UploadManager();
  setUploadManager(upManager);
  SettingsManager.instance().setMaxUploads(9999);
  SettingsManager.instance().setSoftMaxUploads(2);
  SettingsManager.instance().setUploadsPerPerson(99999);
  SettingsManager.instance().setUploadQueueSize(2);
  HTTPDownloader d3=null;
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd2,true);
    try {
      d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
      connectDloader(d3,true,rfd3,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(1,qx.getQueuePosition());
    }
catch (    Exception ioe) {
      ioe.printStackTrace();
      fail(""String_Node_Str"");
    }
    kill(d1);
    Thread.sleep((UploadManager.MIN_POLL_TIME + UploadManager.MAX_POLL_TIME) / 2);
    try {
      connectDloader(d3,false,rfd3,true);
    }
 catch (    QueuedException e) {
      e.printStackTrace();
      fail(""String_Node_Str"" + e.getQueuePosition());
    }
catch (    TryAgainLaterException tlx) {
      fail(""String_Node_Str"");
    }
catch (    Exception ign) {
      ign.printStackTrace();
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception anyother) {
    System.out.println(""String_Node_Str"");
    anyother.printStackTrace();
  }
}",0.9894017094017094
4789,"/** 
 * Makes sure that if downloaders reconnect too soon they are dropped also if uploaders respond too late they should be dropped. Downloader MUST respond bewteen MIN_POLL_TIME and MAX_POLL_TIME
 */
public void testQueueTiming(){
  UploadManager upManager=new UploadManager();
  SettingsManager.instance().setMaxUploads(2);
  SettingsManager.instance().setSoftMaxUploads(9999);
  SettingsManager.instance().setUploadsPerPerson(99999);
  SettingsManager.instance().setUploadQueueSize(2);
  HTTPDownloader d3=null;
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd2,true);
    try {
      d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
      connectDloader(d3,true,rfd3,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(1,qx.getQueuePosition());
    }
catch (    Exception ioe) {
      ioe.printStackTrace();
      fail(""String_Node_Str"");
    }
    HTTPDownloader d4=null;
    try {
      d4=addUploader(upManager,rfd4,""String_Node_Str"",true);
      connectDloader(d4,true,rfd4,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(2,qx.getQueuePosition());
    }
catch (    Exception ioe) {
      fail(""String_Node_Str"");
    }
    try {
      connectDloader(d3,false,rfd3,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      fail(""String_Node_Str"");
    }
catch (    IOException ioe) {
    }
catch (    Exception e) {
      e.printStackTrace();
      fail(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception anyother) {
    System.out.println(""String_Node_Str"");
    anyother.printStackTrace();
  }
}","/** 
 * Makes sure that if downloaders reconnect too soon they are dropped also if uploaders respond too late they should be dropped. Downloader MUST respond bewteen MIN_POLL_TIME and MAX_POLL_TIME
 */
public void testQueueTiming(){
  UploadManager upManager=new UploadManager();
  setUploadManager(upManager);
  SettingsManager.instance().setMaxUploads(2);
  SettingsManager.instance().setSoftMaxUploads(9999);
  SettingsManager.instance().setUploadsPerPerson(99999);
  SettingsManager.instance().setUploadQueueSize(2);
  HTTPDownloader d3=null;
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd2,true);
    try {
      d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
      connectDloader(d3,true,rfd3,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(1,qx.getQueuePosition());
    }
catch (    Exception ioe) {
      ioe.printStackTrace();
      fail(""String_Node_Str"");
    }
    HTTPDownloader d4=null;
    try {
      d4=addUploader(upManager,rfd4,""String_Node_Str"",true);
      connectDloader(d4,true,rfd4,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(2,qx.getQueuePosition());
    }
catch (    Exception ioe) {
      fail(""String_Node_Str"");
    }
    try {
      connectDloader(d3,false,rfd3,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      fail(""String_Node_Str"");
    }
catch (    IOException ioe) {
    }
catch (    Exception e) {
      e.printStackTrace();
      fail(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception anyother) {
    System.out.println(""String_Node_Str"");
    anyother.printStackTrace();
  }
}",0.9916912355936748
4790,"public void testPerHostLimitedNotQueued(){
  UploadManager upManager=new UploadManager();
  SettingsManager.instance().setMaxUploads(2);
  SettingsManager.instance().setSoftMaxUploads(9999);
  SettingsManager.instance().setUploadsPerPerson(2);
  SettingsManager.instance().setUploadQueueSize(2);
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd1,true);
    HTTPDownloader d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
    try {
      connectDloader(d3,true,rfd1,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      fail(""String_Node_Str"");
    }
catch (    TryAgainLaterException expectedException) {
    }
catch (    IOException ioe) {
    }
    HTTPDownloader d4=addUploader(upManager,rfd4,""String_Node_Str"",true);
    try {
      connectDloader(d4,true,rfd1,true);
      fail(""String_Node_Str"");
    }
 catch (    TryAgainLaterException tx) {
      fail(""String_Node_Str"");
    }
catch (    QueuedException expectedException) {
    }
catch (    IOException ioe) {
      fail(""String_Node_Str"");
    }
  }
 catch (  Exception anyOther) {
    System.out.println(""String_Node_Str"");
    anyOther.printStackTrace();
  }
  System.out.println(""String_Node_Str"");
}","public void testPerHostLimitedNotQueued(){
  UploadManager upManager=new UploadManager();
  setUploadManager(upManager);
  SettingsManager.instance().setMaxUploads(2);
  SettingsManager.instance().setSoftMaxUploads(9999);
  SettingsManager.instance().setUploadsPerPerson(2);
  SettingsManager.instance().setUploadQueueSize(2);
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd1,true);
    HTTPDownloader d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
    try {
      connectDloader(d3,true,rfd1,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      fail(""String_Node_Str"");
    }
catch (    TryAgainLaterException expectedException) {
    }
catch (    IOException ioe) {
    }
    HTTPDownloader d4=addUploader(upManager,rfd4,""String_Node_Str"",true);
    try {
      connectDloader(d4,true,rfd1,true);
      fail(""String_Node_Str"");
    }
 catch (    TryAgainLaterException tx) {
      fail(""String_Node_Str"");
    }
catch (    QueuedException expectedException) {
    }
catch (    IOException ioe) {
      fail(""String_Node_Str"");
    }
  }
 catch (  Exception anyOther) {
    System.out.println(""String_Node_Str"");
    anyOther.printStackTrace();
  }
  System.out.println(""String_Node_Str"");
}",0.9888769285970578
4791,"/** 
 * We should count the number of uploads in progress AND the number of uploads the upload queue before deciding the upload per host limit. Tests this. 
 */
public void testUploadLimtIncludesQueue(){
  UploadManager upManager=new UploadManager();
  SettingsManager.instance().setMaxUploads(1);
  SettingsManager.instance().setSoftMaxUploads(1);
  SettingsManager.instance().setUploadsPerPerson(1);
  SettingsManager.instance().setUploadQueueSize(10);
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    try {
      HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
      connectDloader(d2,true,rfd2,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(1,qx.getQueuePosition());
    }
catch (    Exception e) {
      fail(""String_Node_Str"");
    }
    try {
      HTTPDownloader d3=addUploader(upManager,rfd2,""String_Node_Str"",true);
      connectDloader(d3,true,rfd2,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      fail(""String_Node_Str"");
    }
catch (    TryAgainLaterException talx) {
    }
catch (    Exception e) {
      fail(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception anyother) {
    System.out.println(""String_Node_Str"");
    anyother.printStackTrace();
  }
}","/** 
 * We should count the number of uploads in progress AND the number of uploads the upload queue before deciding the upload per host limit. Tests this. 
 */
public void testUploadLimtIncludesQueue(){
  UploadManager upManager=new UploadManager();
  setUploadManager(upManager);
  SettingsManager.instance().setMaxUploads(1);
  SettingsManager.instance().setSoftMaxUploads(1);
  SettingsManager.instance().setUploadsPerPerson(1);
  SettingsManager.instance().setUploadQueueSize(10);
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    try {
      HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
      connectDloader(d2,true,rfd2,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(1,qx.getQueuePosition());
    }
catch (    Exception e) {
      fail(""String_Node_Str"");
    }
    try {
      HTTPDownloader d3=addUploader(upManager,rfd2,""String_Node_Str"",true);
      connectDloader(d3,true,rfd2,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      fail(""String_Node_Str"");
    }
catch (    TryAgainLaterException talx) {
    }
catch (    IOException e) {
    }
catch (    Exception e) {
      fail(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception anyother) {
    System.out.println(""String_Node_Str"");
    anyother.printStackTrace();
  }
}",0.9168712732374604
4792,"/** 
 * Tests that Uploader only queues downloaders that specify that they  support queueing
 */
public void testNotQueuedUnlessHeaderSent(){
  UploadManager upManager=new UploadManager();
  SettingsManager.instance().setMaxUploads(1);
  SettingsManager.instance().setSoftMaxUploads(9999);
  SettingsManager.instance().setUploadsPerPerson(99999);
  SettingsManager.instance().setUploadQueueSize(1);
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    try {
      connectDloader(d2,true,rfd2,false);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qe) {
      fail(""String_Node_Str"");
    }
catch (    TryAgainLaterException expectedException) {
    }
catch (    IOException ioe) {
    }
    HTTPDownloader d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
    try {
      connectDloader(d3,true,rfd3,true);
      fail(""String_Node_Str"");
    }
 catch (    TryAgainLaterException tx) {
      fail(""String_Node_Str"");
    }
catch (    QueuedException expectedException) {
      assertEquals(1,expectedException.getQueuePosition());
    }
  }
 catch (  Exception anyOther) {
    System.out.println(""String_Node_Str"");
    anyOther.printStackTrace();
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * Tests that Uploader only queues downloaders that specify that they  support queueing
 */
public void testNotQueuedUnlessHeaderSent(){
  UploadManager upManager=new UploadManager();
  setUploadManager(upManager);
  SettingsManager.instance().setMaxUploads(1);
  SettingsManager.instance().setSoftMaxUploads(9999);
  SettingsManager.instance().setUploadsPerPerson(99999);
  SettingsManager.instance().setUploadQueueSize(1);
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    try {
      connectDloader(d2,true,rfd2,false);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qe) {
      fail(""String_Node_Str"");
    }
catch (    TryAgainLaterException expectedException) {
    }
catch (    IOException ioe) {
    }
    HTTPDownloader d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
    try {
      connectDloader(d3,true,rfd3,true);
      fail(""String_Node_Str"");
    }
 catch (    TryAgainLaterException tx) {
      fail(""String_Node_Str"");
    }
catch (    QueuedException expectedException) {
      assertEquals(1,expectedException.getQueuePosition());
    }
  }
 catch (  Exception anyOther) {
    System.out.println(""String_Node_Str"");
    anyOther.printStackTrace();
  }
  System.out.println(""String_Node_Str"");
}",0.9887477313974592
4793,"/** 
 * Tests that two requests for the same file on the same connection, does not cause the second request to be queued.
 */
public void testSameFileSameHostGivenSlot(){
  UploadManager upManager=new UploadManager();
  SettingsManager.instance().setMaxUploads(1);
  SettingsManager.instance().setSoftMaxUploads(1);
  SettingsManager.instance().setUploadsPerPerson(99999);
  SettingsManager.instance().setUploadQueueSize(2);
  PipedSocketFactory psf=null;
  try {
    psf=new PipedSocketFactory(""String_Node_Str"",""String_Node_Str"",-1,-1);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
  final Socket sa=psf.getSocketA();
  final UploadManager upman=upManager;
  Thread t=new Thread(){
    public void run(){
      upman.acceptUpload(HTTPRequestMethod.GET,sa);
    }
  }
;
  t.setDaemon(true);
  t.start();
  BufferedWriter out=null;
  ByteReader byteReader=null;
  String s=null;
  try {
    Socket sb=psf.getSocketB();
    OutputStream os=sb.getOutputStream();
    out=new BufferedWriter(new OutputStreamWriter(os));
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.flush();
    byteReader=new ByteReader(sb.getInputStream());
    s=byteReader.readLine();
    assertEquals(""String_Node_Str"",s);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
  try {
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd2,true);
    fail(""String_Node_Str"");
  }
 catch (  QueuedException qEx) {
    assertEquals(1,qEx.getQueuePosition());
  }
catch (  Exception other) {
    fail(""String_Node_Str"");
  }
  try {
    while (!s.equals(""String_Node_Str""))     s=byteReader.readLine();
    byte[] buf=new byte[1024];
    int d=0;
    while (true) {
      int u=byteReader.read(buf,0,1024);
      d+=u;
      if (d > 11999)       break;
    }
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.flush();
    s=byteReader.readLine();
    assertEquals(""String_Node_Str"",s);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
  try {
    HTTPDownloader d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
    connectDloader(d3,true,rfd2,true);
  }
 catch (  QueuedException q) {
    assertEquals(2,q.getQueuePosition());
  }
catch (  Exception other) {
    fail(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * Tests that two requests for the same file on the same connection, does not cause the second request to be queued.
 */
public void testSameFileSameHostGivenSlot(){
  UploadManager upManager=new UploadManager();
  setUploadManager(upManager);
  SettingsManager.instance().setMaxUploads(1);
  SettingsManager.instance().setSoftMaxUploads(1);
  SettingsManager.instance().setUploadsPerPerson(99999);
  SettingsManager.instance().setUploadQueueSize(2);
  PipedSocketFactory psf=null;
  try {
    psf=new PipedSocketFactory(""String_Node_Str"",""String_Node_Str"",-1,-1);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
  final Socket sa=psf.getSocketA();
  final UploadManager upman=upManager;
  Thread t=new Thread(){
    public void run(){
      upman.acceptUpload(HTTPRequestMethod.GET,sa);
    }
  }
;
  t.setDaemon(true);
  t.start();
  BufferedWriter out=null;
  ByteReader byteReader=null;
  String s=null;
  try {
    Socket sb=psf.getSocketB();
    OutputStream os=sb.getOutputStream();
    out=new BufferedWriter(new OutputStreamWriter(os));
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.flush();
    byteReader=new ByteReader(sb.getInputStream());
    s=byteReader.readLine();
    assertEquals(""String_Node_Str"",s);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
  try {
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd2,true);
    fail(""String_Node_Str"");
  }
 catch (  QueuedException qEx) {
    assertEquals(1,qEx.getQueuePosition());
  }
catch (  Exception other) {
    fail(""String_Node_Str"");
  }
  try {
    while (!s.equals(""String_Node_Str""))     s=byteReader.readLine();
    byte[] buf=new byte[1024];
    int d=0;
    while (true) {
      int u=byteReader.read(buf,0,1024);
      d+=u;
      if (d > 11999)       break;
    }
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.write(""String_Node_Str"");
    out.flush();
    s=byteReader.readLine();
    assertEquals(""String_Node_Str"",s);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
  try {
    HTTPDownloader d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
    connectDloader(d3,true,rfd2,true);
  }
 catch (  QueuedException q) {
    assertEquals(2,q.getQueuePosition());
  }
catch (  Exception other) {
    fail(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
}",0.9941958434750048
4794,"public void setUp(){
  ac=new ActivityCallbackStub();
  mr=new MessageRouterStub();
  fm=new FileManagerStub();
  a=new DummyAuthenticator();
  rs=new RouterService(ac);
  FileDesc fd=fm.get(0);
  rfd1=new RemoteFileDesc(""String_Node_Str"",0,0,""String_Node_Str"",1000000,new byte[16],56,false,3,false,null,null);
  rfd2=new RemoteFileDesc(""String_Node_Str"",0,0,""String_Node_Str"",1000000,new byte[16],56,false,3,false,null,null);
  rfd3=new RemoteFileDesc(""String_Node_Str"",0,0,""String_Node_Str"",1000000,new byte[16],56,false,3,false,null,null);
  rfd4=new RemoteFileDesc(""String_Node_Str"",0,0,""String_Node_Str"",1000000,new byte[16],56,false,3,false,null,null);
  rfd5=new RemoteFileDesc(""String_Node_Str"",0,0,""String_Node_Str"",1000000,new byte[16],56,false,3,false,null,null);
}","public void setUp(){
  ac=new ActivityCallbackStub();
  mr=new MessageRouterStub();
  fm=new FileManagerStub();
  a=new DummyAuthenticator();
  rs=new RouterService(ac);
  try {
    PrivilegedAccessor.setValue(rs,""String_Node_Str"",fm);
  }
 catch (  Exception e) {
    fail(""String_Node_Str"");
  }
  FileDesc fd=fm.get(0);
  rfd1=new RemoteFileDesc(""String_Node_Str"",0,0,""String_Node_Str"",1000000,new byte[16],56,false,3,false,null,null);
  rfd2=new RemoteFileDesc(""String_Node_Str"",0,0,""String_Node_Str"",1000000,new byte[16],56,false,3,false,null,null);
  rfd3=new RemoteFileDesc(""String_Node_Str"",0,0,""String_Node_Str"",1000000,new byte[16],56,false,3,false,null,null);
  rfd4=new RemoteFileDesc(""String_Node_Str"",0,0,""String_Node_Str"",1000000,new byte[16],56,false,3,false,null,null);
  rfd5=new RemoteFileDesc(""String_Node_Str"",0,0,""String_Node_Str"",1000000,new byte[16],56,false,3,false,null,null);
}",0.923809523809524
4795,"/** 
 * Tests that: - uploads upto maxUploads get slots - uploader after that but upto uploadQueueSize get queued - uploads beyond that get try again later - when an uploade with slot terminates first uploader gets slot - when an uploader with slot terminates, everyone in queue advances.
 */
public void testNormalQueueing(){
  UploadManager upManager=new UploadManager();
  SettingsManager.instance().setMaxUploads(2);
  SettingsManager.instance().setSoftMaxUploads(9999);
  SettingsManager.instance().setUploadsPerPerson(99999);
  SettingsManager.instance().setUploadQueueSize(2);
  HTTPDownloader d3=null;
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd2,true);
    try {
      d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
      connectDloader(d3,true,rfd3,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(1,qx.getQueuePosition());
    }
catch (    Exception ioe) {
      ioe.printStackTrace();
      fail(""String_Node_Str"");
    }
    HTTPDownloader d4=null;
    try {
      d4=addUploader(upManager,rfd4,""String_Node_Str"",true);
      connectDloader(d4,true,rfd4,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(2,qx.getQueuePosition());
    }
catch (    Exception ioe) {
      fail(""String_Node_Str"");
    }
    HTTPDownloader d5=null;
    try {
      d5=addUploader(upManager,rfd5,""String_Node_Str"",true);
      connectDloader(d5,true,rfd5,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      fail(""String_Node_Str"");
    }
catch (    TryAgainLaterException tax) {
    }
catch (    IOException ioe) {
    }
catch (    Exception e) {
      e.printStackTrace();
      fail(""String_Node_Str"");
    }
    kill(d1);
    Thread.sleep((UploadManager.MIN_POLL_TIME + UploadManager.MAX_POLL_TIME) / 2);
    try {
      connectDloader(d4,false,rfd4,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException talx) {
    }
catch (    Exception e) {
      e.printStackTrace();
      fail(""String_Node_Str"");
    }
    try {
      connectDloader(d3,false,rfd3,true);
    }
 catch (    QueuedException e) {
      e.printStackTrace();
      fail(""String_Node_Str"" + e.getQueuePosition());
    }
catch (    TryAgainLaterException tlx) {
      fail(""String_Node_Str"");
    }
catch (    Exception ign) {
      ign.printStackTrace();
    }
    Thread.sleep((UploadManager.MIN_POLL_TIME + UploadManager.MAX_POLL_TIME) / 2);
    try {
      connectDloader(d4,false,rfd4,true);
    }
 catch (    QueuedException qx) {
      assertEquals(1,qx.getQueuePosition());
    }
catch (    Exception other) {
      other.printStackTrace();
      fail(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception anyother) {
    System.out.println(""String_Node_Str"");
    anyother.printStackTrace();
  }
}","/** 
 * Tests that: - uploads upto maxUploads get slots - uploader after that but upto uploadQueueSize get queued - uploads beyond that get try again later - when an uploade with slot terminates first uploader gets slot - when an uploader with slot terminates, everyone in queue advances.
 */
public void testNormalQueueing(){
  UploadManager upManager=new UploadManager();
  setUploadManager(upManager);
  SettingsManager.instance().setMaxUploads(2);
  SettingsManager.instance().setSoftMaxUploads(9999);
  SettingsManager.instance().setUploadsPerPerson(99999);
  SettingsManager.instance().setUploadQueueSize(2);
  HTTPDownloader d3=null;
  try {
    HTTPDownloader d1=addUploader(upManager,rfd1,""String_Node_Str"",true);
    connectDloader(d1,true,rfd1,true);
    HTTPDownloader d2=addUploader(upManager,rfd2,""String_Node_Str"",true);
    connectDloader(d2,true,rfd2,true);
    try {
      d3=addUploader(upManager,rfd3,""String_Node_Str"",true);
      connectDloader(d3,true,rfd3,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(1,qx.getQueuePosition());
    }
catch (    Exception ioe) {
      ioe.printStackTrace();
      fail(""String_Node_Str"");
    }
    HTTPDownloader d4=null;
    try {
      d4=addUploader(upManager,rfd4,""String_Node_Str"",true);
      connectDloader(d4,true,rfd4,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      assertEquals(2,qx.getQueuePosition());
    }
catch (    Exception ioe) {
      fail(""String_Node_Str"");
    }
    HTTPDownloader d5=null;
    try {
      d5=addUploader(upManager,rfd5,""String_Node_Str"",true);
      connectDloader(d5,true,rfd5,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException qx) {
      fail(""String_Node_Str"");
    }
catch (    TryAgainLaterException tax) {
    }
catch (    IOException ioe) {
    }
catch (    Exception e) {
      e.printStackTrace();
      fail(""String_Node_Str"");
    }
    kill(d1);
    Thread.sleep((UploadManager.MIN_POLL_TIME + UploadManager.MAX_POLL_TIME) / 2);
    try {
      connectDloader(d4,false,rfd4,true);
      fail(""String_Node_Str"");
    }
 catch (    QueuedException talx) {
    }
catch (    Exception e) {
      e.printStackTrace();
      fail(""String_Node_Str"");
    }
    try {
      connectDloader(d3,false,rfd3,true);
    }
 catch (    QueuedException e) {
      e.printStackTrace();
      fail(""String_Node_Str"" + e.getQueuePosition());
    }
catch (    TryAgainLaterException tlx) {
      fail(""String_Node_Str"");
    }
catch (    Exception ign) {
      ign.printStackTrace();
    }
    Thread.sleep((UploadManager.MIN_POLL_TIME + UploadManager.MAX_POLL_TIME) / 2);
    try {
      connectDloader(d4,false,rfd4,true);
    }
 catch (    QueuedException qx) {
      assertEquals(1,qx.getQueuePosition());
    }
catch (    Exception other) {
      other.printStackTrace();
      fail(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception anyother) {
    System.out.println(""String_Node_Str"");
    anyother.printStackTrace();
  }
}",0.9949271804941908
4796,"/** 
 * Starts a ""requery download"", aka, a ""wishlist download"".  A ""requery download"" should be started when the user has not received any results for her query, and wants LimeWire to spawn a specialized Downloader that requeries the network until a 'appropriate' file is found.
 * @param query The original query string.
 * @param richQuery The original richQuery string.
 * @param guid The guid associated with this query request.
 * @param type The mediatype associated with this search.  
 */
public synchronized Downloader download(String query,String richQuery,byte[] guid,MediaType type) throws AlreadyDownloadingException {
  AutoDownloadDetails add=new AutoDownloadDetails(query,richQuery,guid,type);
  if (requeryConflicts(add))   throw new AlreadyDownloadingException(query);
  incompleteFileManager.purge(false);
  Downloader downloader=new RequeryDownloader(this,fileManager,incompleteFileManager,add,callback);
  waiting.add(downloader);
  callback.addDownload(downloader);
  writeSnapshot();
  return downloader;
}","/** 
 * Starts a ""requery download"", aka, a ""wishlist download"".  A ""requery download"" should be started when the user has not received any results for her query, and wants LimeWire to spawn a specialized Downloader that requeries the network until a 'appropriate' file is found.
 * @param query The original query string.
 * @param richQuery The original richQuery string.
 * @param guid The guid associated with this query request.
 * @param type The mediatype associated with this search.  
 */
public synchronized Downloader download(String query,String richQuery,byte[] guid,MediaType type) throws AlreadyDownloadingException {
  AutoDownloadDetails add=new AutoDownloadDetails(query,richQuery,guid,type);
  if (requeryConflicts(add))   throw new AlreadyDownloadingException(query);
  incompleteFileManager.purge(false);
  RequeryDownloader downloader=new RequeryDownloader(incompleteFileManager,add);
  downloader.initialize(this,fileManager,callback);
  waiting.add(downloader);
  callback.addDownload(downloader);
  writeSnapshot();
  return downloader;
}",0.9593884376493071
4797,"private void cleanup(){
  miniRFDToLock.clear();
  threadLockToSocket.clear();
  commonOutFile=null;
  if (needed != null)   needed.clear();
  busy=null;
  files=null;
}","private void cleanup(){
  miniRFDToLock.clear();
  threadLockToSocket.clear();
  if (needed != null)   needed.clear();
  busy=null;
  files=null;
}",0.930379746835443
4798,"/** 
 * Creates a new RequeryDownloader - a RequeryDownloader has no files initially associated with it, but it may have them later (via calls to addDownload(). Non-blocking.
 * @param manager the delegate for queueing purposes.  Also the callbackfor changes in state.
 * @param incompleteFileManager the repository of incomplete files forresuming
 */
public RequeryDownloader(DownloadManager manager,FileManager fileManager,IncompleteFileManager incompleteFileManager,AutoDownloadDetails add,ActivityCallback callback){
  super(manager,new RemoteFileDesc[0],fileManager,incompleteFileManager,callback);
  Assert.that(add != null,""String_Node_Str"");
  _add=add;
}","/** 
 * Creates a new RequeryDownloader - a RequeryDownloader has no files initially associated with it, but it may have them later (via calls to addDownload().  Non-blocking.     
 * @param incompleteFileManager the repository of incomplete files forresuming
 * @param add the keywords to requery with
 */
public RequeryDownloader(IncompleteFileManager incompleteFileManager,AutoDownloadDetails add){
  super(new RemoteFileDesc[0],incompleteFileManager);
  Assert.that(add != null,""String_Node_Str"");
  _add=add;
}",0.6638370118845501
4799,"/** 
 * Creates a RequeryDownloader to finish downloading incompleteFile.  This constructor has preconditions on several parameters; putting the burden on the caller makes the method easier to implement, since the superclass constructor immediately starts a download thread.
 * @param incompleteFile the incomplete file to resume to, whichMUST be the result of IncompleteFileManager.getFile.
 * @param name the name of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedName(incompleteFile)
 * @param size the size of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedSize(incompleteFile) 
 */
public ResumeDownloader(DownloadManager manager,FileManager fileManager,IncompleteFileManager incompleteFileManager,ActivityCallback callback,File incompleteFile,String name,int size){
  super(manager,new RemoteFileDesc[0],fileManager,incompleteFileManager,callback);
  this._incompleteFile=incompleteFile;
  this._name=name;
  this._size=size;
  this._hash=incompleteFileManager.getCompletedHash(incompleteFile);
}","/** 
 * Creates a RequeryDownloader to finish downloading incompleteFile.  This constructor has preconditions on several parameters; putting the burden on the caller makes the method easier to implement, since the superclass constructor immediately starts a download thread.
 * @param incompleteFile the incomplete file to resume to, whichMUST be the result of IncompleteFileManager.getFile.
 * @param name the name of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedName(incompleteFile)
 * @param size the size of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedSize(incompleteFile) 
 */
public ResumeDownloader(IncompleteFileManager incompleteFileManager,File incompleteFile,String name,int size){
  super(new RemoteFileDesc[0],incompleteFileManager);
  this._incompleteFile=incompleteFile;
  this._name=name;
  this._size=size;
  this._hash=incompleteFileManager.getCompletedHash(incompleteFile);
}",0.9150711831124202
4800,"private static RemoteFileDesc newRFD(String name,String hash){
  Set urns=null;
  if (hash != null) {
    urns=new HashSet(1);
    try {
      urns.add(URN.createSHA1Urn(hash));
    }
 catch (    IOException e) {
      fail(""String_Node_Str"");
    }
  }
  return new RemoteFileDesc(""String_Node_Str"",6346,13l,name,1024,new byte[16],56,false,4,true,null,urns);
}","private static RemoteFileDesc newRFD(String name,String hash){
  Set urns=null;
  if (hash != null) {
    urns=new HashSet(1);
    try {
      urns.add(URN.createSHA1Urn(hash));
    }
 catch (    IOException e) {
      fail(""String_Node_Str"");
    }
  }
  return new RemoteFileDesc(""String_Node_Str"",PORT,13l,name,1024,new byte[16],56,false,4,true,null,urns);
}",0.9889196675900276
4801,"public void testLegacy(){
  AutoDownloadDetails details=new AutoDownloadDetails(""String_Node_Str"",""String_Node_Str"",new byte[16],new MediaType(""String_Node_Str"",""String_Node_Str"",new String[0]));
  IncompleteFileManager ifm=new IncompleteFileManager();
  VerifyingFile vf=new VerifyingFile(true);
  vf.addInterval(new Interval(10,20));
  ifm.addEntry(new File(""String_Node_Str""),vf);
  RequeryDownloader downloader=new RequeryDownloader(new DownloadManager(),new FileManager(),ifm,details,new ActivityCallbackStub());
  try {
    File tmp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(tmp));
    out.writeObject(downloader);
    out.close();
    ObjectInputStream in=new ObjectInputStream(new FileInputStream(tmp));
    RequeryDownloader downloader2=(RequeryDownloader)in.readObject();
    in.close();
    assertTrue(downloader.hasFile() == downloader2.hasFile());
    tmp.delete();
  }
 catch (  IOException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"",false);
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"",false);
  }
}","public void testLegacy(){
  AutoDownloadDetails details=new AutoDownloadDetails(""String_Node_Str"",""String_Node_Str"",new byte[16],new MediaType(""String_Node_Str"",""String_Node_Str"",new String[0]));
  IncompleteFileManager ifm=new IncompleteFileManager();
  VerifyingFile vf=new VerifyingFile(true);
  vf.addInterval(new Interval(10,20));
  ifm.addEntry(new File(""String_Node_Str""),vf);
  RequeryDownloader downloader=new RequeryDownloader(ifm,details);
  downloader.initialize(new DownloadManager(),new FileManager(),new ActivityCallbackStub());
  try {
    File tmp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(tmp));
    out.writeObject(downloader);
    out.close();
    ObjectInputStream in=new ObjectInputStream(new FileInputStream(tmp));
    RequeryDownloader downloader2=(RequeryDownloader)in.readObject();
    in.close();
    assertTrue(downloader.hasFile() == downloader2.hasFile());
    tmp.delete();
  }
 catch (  IOException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"",false);
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"",false);
  }
}",0.9789562289562288
4802,"/** 
 * Returns a new ResumeDownloader with stubbed-out DownloadManager, etc. 
 */
private static ResumeDownloader newResumeDownloader(){
  return new ResumeDownloader(new DownloadManagerStub(),new FileManagerStub(),ifm,new ActivityCallbackStub(),incompleteFile,name,size);
}","/** 
 * Returns a new ResumeDownloader with stubbed-out DownloadManager, etc. 
 */
private static ResumeDownloader newResumeDownloader(){
  ResumeDownloader ret=new ResumeDownloader(ifm,incompleteFile,name,size);
  ret.initialize(new DownloadManagerStub(),new FileManagerStub(),new ActivityCallbackStub());
  return ret;
}",0.7336683417085427
4803,"public void run(){
  try {
    Socket s=GIVuploader.connect();
    acceptUpload(HTTPRequestMethod.GET,s);
  }
 catch (  IOException ioe) {
synchronized (UploadManager.this) {
      insertFailedPush(host,index);
    }
  }
catch (  Exception e) {
    _callback.error(e);
  }
 finally {
    GIVuploader.stop();
synchronized (UploadManager.this) {
      removeAttemptingPush(host,index);
    }
  }
}","public void run(){
  try {
    Socket s=GIVuploader.connect();
    String word=IOUtils.readWord(s.getInputStream(),4);
    if (word.equals(""String_Node_Str""))     acceptUpload(HTTPRequestMethod.GET,s);
 else     if (word.equals(""String_Node_Str""))     acceptUpload(HTTPRequestMethod.HEAD,s);
 else     throw new IOException();
  }
 catch (  IOException ioe) {
synchronized (UploadManager.this) {
      insertFailedPush(host,index);
    }
  }
catch (  Exception e) {
    _callback.error(e);
  }
 finally {
    GIVuploader.stop();
synchronized (UploadManager.this) {
      removeAttemptingPush(host,index);
    }
  }
}",0.7576656775469832
4804,"/** 
 * Accepts a new push upload, creating a new <tt>HTTPUploader</tt>. NON-BLOCKING: creates a new thread to transfer the file. <p> The thread makes the uploader connect (which does the connecting  and also writes out the GIV, so the state of the returned socket  is the same as a socket which the accpetUpload methos would  expect)and delegates to the acceptUpload method with the socket  it gets from connecting. <p>
 * @param file the fully qualified pathname of the file to upload
 * @param host the ip address of the host to upload to
 * @param port the port over which the transfer will occur
 * @param index the index of the file in <tt>FileManager</tt>
 * @param guid the unique identifying client guid of the uploading client
 */
public synchronized void acceptPushUpload(final String file,final String host,final int port,final int index,final String guid){
  final HTTPUploader GIVuploader=new HTTPUploader(file,host,port,index,guid,this,_fileManager,_router);
  clearFailedPushes();
  if ((!testAttemptingPush(host,index)) || (!testFailedPush(host,index)))   return;
  insertAttemptingPush(host,index);
  Thread runner=new Thread(){
    public void run(){
      try {
        Socket s=GIVuploader.connect();
        acceptUpload(HTTPRequestMethod.GET,s);
      }
 catch (      IOException ioe) {
synchronized (UploadManager.this) {
          insertFailedPush(host,index);
        }
      }
catch (      Exception e) {
        _callback.error(e);
      }
 finally {
        GIVuploader.stop();
synchronized (UploadManager.this) {
          removeAttemptingPush(host,index);
        }
      }
    }
  }
;
  runner.start();
}","/** 
 * Accepts a new push upload, creating a new <tt>HTTPUploader</tt>. NON-BLOCKING: creates a new thread to transfer the file. <p> The thread makes the uploader connect (which does the connecting  and also writes out the GIV, so the state of the returned socket  is the same as a socket which the accpetUpload methos would  expect)and delegates to the acceptUpload method with the socket  it gets from connecting. <p>
 * @param file the fully qualified pathname of the file to upload
 * @param host the ip address of the host to upload to
 * @param port the port over which the transfer will occur
 * @param index the index of the file in <tt>FileManager</tt>
 * @param guid the unique identifying client guid of the uploading client
 */
public synchronized void acceptPushUpload(final String file,final String host,final int port,final int index,final String guid){
  final HTTPUploader GIVuploader=new HTTPUploader(file,host,port,index,guid,this,_fileManager,_router);
  clearFailedPushes();
  if ((!testAttemptingPush(host,index)) || (!testFailedPush(host,index)))   return;
  insertAttemptingPush(host,index);
  Thread runner=new Thread(){
    public void run(){
      try {
        Socket s=GIVuploader.connect();
        String word=IOUtils.readWord(s.getInputStream(),4);
        if (word.equals(""String_Node_Str""))         acceptUpload(HTTPRequestMethod.GET,s);
 else         if (word.equals(""String_Node_Str""))         acceptUpload(HTTPRequestMethod.HEAD,s);
 else         throw new IOException();
      }
 catch (      IOException ioe) {
synchronized (UploadManager.this) {
          insertFailedPush(host,index);
        }
      }
catch (      Exception e) {
        _callback.error(e);
      }
 finally {
        GIVuploader.stop();
synchronized (UploadManager.this) {
          removeAttemptingPush(host,index);
        }
      }
    }
  }
;
  runner.start();
}",0.9200113862795332
4805,"/** 
 * This method is called in the case of a push only. <p> The method creates the socket, and send the GIV message. When this method returns the socket, is in the same state as a  socket created as a result of a normal upload - ready to receive GET <p>
 * @return The returned socket is used for a normal upload.
 */
public Socket connect() throws IOException {
  if (_socket != null)   return _socket;
  try {
    _socket=new Socket(_hostName,_port);
    _ostream=_socket.getOutputStream();
    Assert.that(_fileName != null);
    Assert.that(_fileName != ""String_Node_Str"");
    String giv=""String_Node_Str"" + _index + ""String_Node_Str""+ _guid+ ""String_Node_Str""+ _fileName+ ""String_Node_Str"";
    _ostream.write(giv.getBytes());
    _ostream.flush();
    InputStream in=_socket.getInputStream();
    String word=IOUtils.readWord(in,3);
    if (!word.equalsIgnoreCase(""String_Node_Str""))     throw new IOException();
    return _socket;
  }
 catch (  SecurityException e) {
    this.setState(Uploader.PUSH_FAILED);
    throw new IOException();
  }
catch (  IndexOutOfBoundsException e) {
    this.setState(Uploader.PUSH_FAILED);
    throw new IOException();
  }
catch (  NumberFormatException e) {
    this.setState(Uploader.PUSH_FAILED);
    throw new IOException();
  }
catch (  IllegalArgumentException e) {
    this.setState(Uploader.PUSH_FAILED);
    throw new IOException();
  }
catch (  IOException e) {
    this.setState(Uploader.PUSH_FAILED);
    throw new IOException();
  }
}","/** 
 * Establishes a push upload.  If this is already connected, returns immediately.  Otherwise attempts to establish a TCP connection to the remote host and send a GIV request.
 * @return this' underlying socket, for which a GIV has been sent butnothing has been read.  Typically the caller will read the GET or HEAD request from this socket.  The socket is needed for persistence and queueing purposes; caller must be careful when modifying it.
 * @throws IOException couldn't establish the connection
 */
public Socket connect() throws IOException {
  if (_socket != null)   return _socket;
  try {
    _socket=new Socket(_hostName,_port);
    _ostream=_socket.getOutputStream();
    Assert.that(_fileName != null);
    Assert.that(_fileName != ""String_Node_Str"");
    String giv=""String_Node_Str"" + _index + ""String_Node_Str""+ _guid+ ""String_Node_Str""+ _fileName+ ""String_Node_Str"";
    _ostream.write(giv.getBytes());
    _ostream.flush();
    return _socket;
  }
 catch (  SecurityException e) {
    this.setState(Uploader.PUSH_FAILED);
    throw new IOException();
  }
catch (  IndexOutOfBoundsException e) {
    this.setState(Uploader.PUSH_FAILED);
    throw new IOException();
  }
catch (  NumberFormatException e) {
    this.setState(Uploader.PUSH_FAILED);
    throw new IOException();
  }
catch (  IllegalArgumentException e) {
    this.setState(Uploader.PUSH_FAILED);
    throw new IOException();
  }
catch (  IOException e) {
    this.setState(Uploader.PUSH_FAILED);
    throw new IOException();
  }
}",0.6957100099767209
4806,"public void testAll(){
  try {
    boolean passed;
    try {
      Thread.sleep(200);
    }
 catch (    InterruptedException e) {
    }
    passed=downloadPush(file,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush(encodedFile,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(file,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    assertEquals(""String_Node_Str"" + URLDecoder.decode(encodedFile),file,URLDecoder.decode(encodedFile));
    passed=download(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"" + ""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    assertEquals(""String_Node_Str"" + URLDecoder.decode(encodedFile),file,URLDecoder.decode(encodedFile));
    passed=download1(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=pipelineDownloadNormal(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=pipelineDownloadPush(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    tMixedPersistentRequests();
    tPersistentURIRequests();
    System.out.println(""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"" + e,false);
  }
catch (  BadPacketException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"" + e,false);
  }
}","public void testAll(){
  try {
    boolean passed;
    try {
      Thread.sleep(200);
    }
 catch (    InterruptedException e) {
    }
    passed=downloadPush(file,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush(encodedFile,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(file,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    assertTrue(""String_Node_Str"",downloadPush1(""String_Node_Str"",""String_Node_Str"" + index + ""String_Node_Str""+ encodedFile,null,""String_Node_Str""));
    passed=download(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    assertEquals(""String_Node_Str"" + URLDecoder.decode(encodedFile),file,URLDecoder.decode(encodedFile));
    passed=download(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"" + ""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    assertEquals(""String_Node_Str"" + URLDecoder.decode(encodedFile),file,URLDecoder.decode(encodedFile));
    passed=download1(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=pipelineDownloadNormal(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=pipelineDownloadPush(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    tMixedPersistentRequests();
    tPersistentURIRequests();
    System.out.println(""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"" + e,false);
  }
catch (  BadPacketException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"" + e,false);
  }
}",0.977638640429338
4807,"private static boolean downloadPush1(String file,String header,String expResp) throws IOException, BadPacketException {
  Connection c=new Connection(address,port);
  c.initialize();
  QueryRequest query=new QueryRequest((byte)5,0,""String_Node_Str"");
  c.send(query);
  c.flush();
  QueryReply reply=null;
  while (true) {
    Message m=c.receive(2000);
    if (m instanceof QueryReply) {
      reply=(QueryReply)m;
      break;
    }
  }
  PushRequest push=new PushRequest(GUID.makeGuid(),(byte)5,reply.getClientGUID(),0,new byte[]{(byte)127,(byte)0,(byte)0,(byte)1},callbackPort);
  ServerSocket ss=new ServerSocket(callbackPort);
  c.send(push);
  c.flush();
  Socket s=ss.accept();
  BufferedReader in=new BufferedReader(new InputStreamReader(s.getInputStream()));
  BufferedWriter out=new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  in.readLine();
  in.readLine();
  String retStr=downloadInternal1(file,header,out,in,expResp.length());
  assertEquals(""String_Node_Str"",expResp,retStr);
  boolean ret=retStr.equals(expResp);
  retStr=downloadInternal1(file,header,out,in,expResp.length());
  assertEquals(""String_Node_Str"",expResp,retStr);
  ret=ret && retStr.equals(expResp);
  c.close();
  s.close();
  ss.close();
  return ret;
}","/** 
 * Does an arbitrary push download. 
 * @param request an HTTP request such as ""GET"" or ""HEAD""
 * @param file the full filename, e.g., ""/get/0/file.txt""    
 */
private static boolean downloadPush1(String request,String file,String header,String expResp) throws IOException, BadPacketException {
  Connection c=new Connection(address,port);
  c.initialize();
  QueryRequest query=new QueryRequest((byte)5,0,""String_Node_Str"");
  c.send(query);
  c.flush();
  QueryReply reply=null;
  while (true) {
    Message m=c.receive(2000);
    if (m instanceof QueryReply) {
      reply=(QueryReply)m;
      break;
    }
  }
  PushRequest push=new PushRequest(GUID.makeGuid(),(byte)5,reply.getClientGUID(),0,new byte[]{(byte)127,(byte)0,(byte)0,(byte)1},callbackPort);
  ServerSocket ss=new ServerSocket(callbackPort);
  c.send(push);
  c.flush();
  Socket s=ss.accept();
  BufferedReader in=new BufferedReader(new InputStreamReader(s.getInputStream()));
  BufferedWriter out=new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  in.readLine();
  in.readLine();
  String retStr=downloadInternal1(request,file,header,out,in,expResp.length());
  assertEquals(""String_Node_Str"",expResp,retStr);
  boolean ret=retStr.equals(expResp);
  retStr=downloadInternal1(request,file,header,out,in,expResp.length());
  assertEquals(""String_Node_Str"",expResp,retStr);
  ret=ret && retStr.equals(expResp);
  c.close();
  s.close();
  ss.close();
  return ret;
}",0.927279438907346
4808,"/** 
 * @return true if the number of uploads from the host is strictly LESS thanthe MAX, although we want to allow exactly MAX uploads from the same host. This is because this method is called BEFORE we add/allow the. upload.
 */
private synchronized boolean hostLimitReached(String host){
  int max=SettingsManager.instance().getUploadsPerPerson();
  int i=0;
  Iterator iter=_activeUploadList.iterator();
  while (iter.hasNext()) {
    Uploader u=(Uploader)iter.next();
    if (u.getHost().equals(host))     i++;
  }
  return i >= max;
}","/** 
 * @return true if the number of uploads from the host is strictly LESS thanthe MAX, although we want to allow exactly MAX uploads from the same host. This is because this method is called BEFORE we add/allow the. upload.
 */
private synchronized boolean hostLimitReached(String host){
  int max=SettingsManager.instance().getUploadsPerPerson();
  int i=0;
  Iterator iter=_activeUploadList.iterator();
  while (iter.hasNext()) {
    Uploader u=(Uploader)iter.next();
    if (u.getHost().equals(host))     i++;
  }
  iter=_queuedUploads.iterator();
  while (iter.hasNext()) {
    Socket s=(Socket)((KeyValue)iter.next()).getKey();
    if (s.getInetAddress().getHostAddress().equals(host))     i++;
  }
  return i >= max;
}",0.8524072612470402
4809,"/** 
 * Returns the fully-qualified temporary download file for the given file/location pair.  The location of the file is determined by the INCOMPLETE_DIRECTORY property.  For example, getFile(""test.txt"", 1999) may return ""C:\Program Files\LimeWire\Incomplete\T-1999-Test.txt"".  The disk is not modified.<p> This method gives duplicate files the same temporary file, which is critical for resume and swarmed downloads.  That is, for all rfd_i and  rfd_j <pre> rfd_i~=rfd_j <==> getFile(rfd_i).equals(getFile(rfd_j))<p>   </pre> Where ""~="" means ""has the same content as"".  Currently rfd_i~=rfd_j iff either of the following conditions hold:  <ul> <li>Both files have the same hash, i.e.,  rfd_i.getSHA1Urn().equals(rfd_j.getSHA1Urn().  Note that this (almost) always means that rfd_i.getSize()==rfd_j.getSize(), though rfd_i and rfd_j may have different names. <li>Both files have the same name and size and don't have conflicting hashes, i.e., rfd_i.getName().equals(rfd_j.getName()) && rfd_i.getSize()==rfd_j.getSize() && (rfd_i.getSHA1Urn()==null || rfd_j.getSHA1Urn()==null ||  rfd_i.getSHA1Urn().equals(rfd_j.getSHA1Urn())). </ul> Note that the second condition allows risky resumes, i.e., resumes when  one (or both) of the files doesn't have a hash.
 */
public synchronized File getFile(RemoteFileDesc rfd){
  File incDir=null;
  try {
    incDir=SettingsManager.instance().getIncompleteDirectory();
  }
 catch (  java.io.FileNotFoundException fnfe) {
  }
  URN sha1=rfd.getSHA1Urn();
  if (sha1 != null) {
    File file=(File)hashes.get(sha1);
    if (file != null) {
      return file;
    }
 else {
      for (int i=1; ; i++) {
        file=new File(incDir,tempName(rfd.getFileName(),rfd.getSize(),i));
        if (!hashes.values().contains(file))         break;
      }
      hashes.put(sha1,file);
      return file;
    }
  }
 else {
    return new File(incDir,tempName(rfd.getFileName(),rfd.getSize(),0));
  }
}","/** 
 * Returns the fully-qualified temporary download file for the given file/location pair.  The location of the file is determined by the INCOMPLETE_DIRECTORY property.  For example, getFile(""test.txt"", 1999) may return ""C:\Program Files\LimeWire\Incomplete\T-1999-Test.txt"".  The disk is not modified.<p> This method gives duplicate files the same temporary file, which is critical for resume and swarmed downloads.  That is, for all rfd_i and  rfd_j <pre> similar(rfd_i, rfd_j) <==> getFile(rfd_i).equals(getFile(rfd_j))<p>   </pre>
 */
public synchronized File getFile(RemoteFileDesc rfd){
  File incDir=null;
  try {
    incDir=SettingsManager.instance().getIncompleteDirectory();
  }
 catch (  java.io.FileNotFoundException fnfe) {
  }
  URN sha1=rfd.getSHA1Urn();
  if (sha1 != null) {
    File file=(File)hashes.get(sha1);
    if (file != null) {
      return file;
    }
 else {
      for (int i=1; ; i++) {
        file=new File(incDir,tempName(rfd.getFileName(),rfd.getSize(),i));
        if (!hashes.values().contains(file))         break;
      }
      hashes.put(sha1,file);
      return file;
    }
  }
 else {
    return new File(incDir,tempName(rfd.getFileName(),rfd.getSize(),0));
  }
}",0.6264367816091954
4810,"/** 
 * Returns the name of the complete file associated with the given incomplete file, i.e., what incompleteFile will be renamed to when the download completes (without path information).
 * @param incompleteFile a file returned by getFile
 * @return the complete file name, without path
 * @exception IllegalArgumentException incompleteFile was not thereturn value from getFile
 */
public static String getCompletedName(File incompleteFile) throws IllegalArgumentException {
  String name=incompleteFile.getName();
  int i=name.indexOf(SEPARATOR);
  if (i < 0)   throw new IllegalArgumentException(""String_Node_Str"" + name);
  int j=name.indexOf(SEPARATOR,i + 1);
  if (j < 0)   throw new IllegalArgumentException(""String_Node_Str"" + name);
  if (j == name.length() - 1)   throw new IllegalArgumentException(""String_Node_Str"");
  return name.substring(j + 1);
}","/** 
 * Returns the name of the complete file associated with the given incomplete file, i.e., what incompleteFile will be renamed to when the download completes (without path information).  Slow; runs in linear time with respect to the number of hashes in this.
 * @param incompleteFile a file returned by getFile
 * @return the complete file name, without path
 * @exception IllegalArgumentException incompleteFile was not thereturn value from getFile
 */
public static String getCompletedName(File incompleteFile) throws IllegalArgumentException {
  String name=incompleteFile.getName();
  int i=name.indexOf(SEPARATOR);
  if (i < 0)   throw new IllegalArgumentException(""String_Node_Str"" + name);
  int j=name.indexOf(SEPARATOR,i + 1);
  if (j < 0)   throw new IllegalArgumentException(""String_Node_Str"" + name);
  if (j == name.length() - 1)   throw new IllegalArgumentException(""String_Node_Str"");
  return name.substring(j + 1);
}",0.9594669627984452
4811,"public QueryRequest newRequery(){
  URN hash=_incompleteFileManager.getCompletedHash(_incompleteFile);
  Set queryUrns=null;
  if (hash != null) {
    queryUrns=new HashSet(1);
    queryUrns.add(hash);
  }
  return new QueryRequest(QueryRequest.newQueryGUID(true),(byte)7,0,getFileName(),null,true,null,queryUrns);
}","public QueryRequest newRequery(){
  Set queryUrns=null;
  if (_hash != null) {
    queryUrns=new HashSet(1);
    queryUrns.add(_hash);
  }
  return new QueryRequest(QueryRequest.newQueryGUID(true),(byte)7,0,getFileName(),null,true,null,queryUrns);
}",0.1557522123893805
4812,"/** 
 * Creates a RequeryDownloader to finish downloading incompleteFile.  This constructor has preconditions on several parameters; putting the burden on the caller makes the method easier to implement, since the superclass constructor immediately starts a download thread.
 * @param incompleteFile the incomplete file to resume to, whichMUST be the result of IncompleteFileManager.getFile.
 * @param name the name of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedName(incompleteFile)
 * @param size the size of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedSize(incompleteFile) 
 */
public ResumeDownloader(DownloadManager manager,FileManager fileManager,IncompleteFileManager incompleteFileManager,ActivityCallback callback,File incompleteFile,String name,int size){
  super(manager,new RemoteFileDesc[0],fileManager,incompleteFileManager,callback);
  this._incompleteFileManager=incompleteFileManager;
  this._incompleteFile=incompleteFile;
  this._name=name;
  this._size=size;
}","/** 
 * Creates a RequeryDownloader to finish downloading incompleteFile.  This constructor has preconditions on several parameters; putting the burden on the caller makes the method easier to implement, since the superclass constructor immediately starts a download thread.
 * @param incompleteFile the incomplete file to resume to, whichMUST be the result of IncompleteFileManager.getFile.
 * @param name the name of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedName(incompleteFile)
 * @param size the size of the completed file, which MUST be the result ofIncompleteFileManager.getCompletedSize(incompleteFile) 
 */
public ResumeDownloader(DownloadManager manager,FileManager fileManager,IncompleteFileManager incompleteFileManager,ActivityCallback callback,File incompleteFile,String name,int size){
  super(manager,new RemoteFileDesc[0],fileManager,incompleteFileManager,callback);
  this._incompleteFile=incompleteFile;
  this._name=name;
  this._size=size;
  this._hash=incompleteFileManager.getCompletedHash(incompleteFile);
}",0.9416195856873822
4813,"/** 
 * Overrides ManagedDownloader to allow any RemoteFileDesc that would resume from _incompleteFile.
 */
protected boolean allowAddition(RemoteFileDesc other){
  return _incompleteFile.equals(_incompleteFileManager.getFile(other));
}","/** 
 * Overrides ManagedDownloader to allow any RemoteFileDesc that would resume from _incompleteFile.
 */
protected boolean allowAddition(RemoteFileDesc other){
  return IncompleteFileManager.same(_name,_size,_hash,other.getFileName(),other.getSize(),other.getSHA1Urn());
}",0.7749510763209393
4814,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(RemoteFileDescGrouperTest.suite());
  suite.addTest(DownloadTest.suite());
  suite.addTest(ManagedDownloaderTest.suite());
  suite.addTest(TestOldDownloads.suite());
  suite.addTest(HTTPDownloaderTest.suite());
  suite.addTest(IntervalTest.suite());
  suite.addTest(MiniRemoteFileDescTest.suite());
  suite.addTest(RequeryDownloaderTest.suite());
  suite.addTest(RequeryDownloadTest.suite());
  suite.addTest(IncompleteFileManagerTest.suite());
  suite.addTest(AutoDownloaderDetailsTest.suite());
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(RemoteFileDescGrouperTest.suite());
  suite.addTest(DownloadTest.suite());
  suite.addTest(ManagedDownloaderTest.suite());
  suite.addTest(TestOldDownloads.suite());
  suite.addTest(HTTPDownloaderTest.suite());
  suite.addTest(IntervalTest.suite());
  suite.addTest(MiniRemoteFileDescTest.suite());
  suite.addTest(RequeryDownloaderTest.suite());
  suite.addTest(ResumeDownloaderTest.suite());
  suite.addTest(RequeryDownloadTest.suite());
  suite.addTest(IncompleteFileManagerTest.suite());
  suite.addTest(AutoDownloaderDetailsTest.suite());
  return suite;
}",0.9629044988161012
4815,"/** 
 * Different name or size ==> different temp file 
 */
public void testGetFile_DifferentSize(){
  rfd1=newRFD(""String_Node_Str"",1839,null);
  rfd2=newRFD(""String_Node_Str"",1223,null);
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertTrue(!tmp2.equals(tmp1));
}","/** 
 * Different name or size ==> different temp file 
 */
public void testGetFile_DifferentSize(){
  rfd1=newRFD(""String_Node_Str"",1839,null);
  rfd2=newRFD(""String_Node_Str"",1223,null);
  assertTrue(!IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertTrue(!tmp2.equals(tmp1));
}",0.7891373801916933
4816,"/** 
 * Risky resumes are allowed: no hashes 
 */
public void testGetFile_NoHash(){
  rfd1=newRFD(""String_Node_Str"",1839,null);
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertEquals(tmp1,tmp2);
}","/** 
 * Risky resumes are allowed: no hashes 
 */
public void testGetFile_NoHash(){
  rfd1=newRFD(""String_Node_Str"",1839,null);
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  assertTrue(IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertEquals(tmp1,tmp2);
}",0.912106135986733
4817,"/** 
 * You should NOT be able to resume to file w/ same name but different hash.
 */
public void testGetFile_SameNameDifferentHash(){
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertTrue(!tmp2.equals(tmp1));
}","/** 
 * You should NOT be able to resume to file w/ same name but different hash.
 */
public void testGetFile_SameNameDifferentHash(){
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  assertTrue(!IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertTrue(!tmp2.equals(tmp1));
}",0.9276139410187668
4818,"/** 
 * You should be able to resume to a file with same hash but different name.
 */
public void testGetFile_DifferentNameSameHash(){
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertEquals(tmp1,tmp2);
}","/** 
 * You should be able to resume to a file with same hash but different name.
 */
public void testGetFile_DifferentNameSameHash(){
  rfd1=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  rfd2=newRFD(""String_Node_Str"",1839,""String_Node_Str"");
  assertTrue(IncompleteFileManager.same(rfd1,rfd2));
  File tmp1=ifm.getFile(rfd1);
  File tmp2=ifm.getFile(rfd2);
  assertEquals(tmp1,tmp2);
}",0.9274965800273598
4819,"/** 
 * Does some book-keeping and makes the downloader, start the download
 * @param uploader This method assumes that uploader is connected.
 * @exception IOException thrown if insertAndTest throws an IOException
 */
private boolean doSingleUpload(Uploader uploader,Socket socket,String host,int index) throws IOException {
  long startTime=-1;
  debug(uploader + ""String_Node_Str"");
  boolean isBHUploader=(uploader.getState() == Uploader.BROWSE_HOST);
  int queued=-1;
  boolean ret=false;
  if (!isBHUploader) {
    queued=insertAndTest(uploader,host,socket);
    debug(uploader + ""String_Node_Str"" + queued);
    Assert.that(queued != -1);
    _callback.addUpload(uploader);
    FileDesc fd=uploader.getFileDesc();
    if (fd != null) {
      fd.incrementAttemptedUploads();
      _callback.handleSharedFileUpdate(fd.getFile());
    }
  }
  if (queued == 1) {
    socket.setSoTimeout(MAX_POLL_TIME);
    uploader.setState(Uploader.QUEUED);
    ret=true;
  }
 else   if (queued == 2) {
synchronized (this) {
      uploader.setState(Uploader.CONNECTING);
      _activeUploadList.add(uploader);
    }
  }
  startTime=System.currentTimeMillis();
  uploader.writeResponse();
  debug(uploader + ""String_Node_Str"");
  if (uploader.getState() == Uploader.UPLOADING || uploader.getState() == Uploader.CONNECTING) {
    uploader.setState(Uploader.INTERRUPTED);
  }
  if (uploader.getState() == Uploader.COMPLETE) {
    _hadSuccesfulUpload=true;
    if (!isBHUploader) {
      FileDesc fd=uploader.getFileDesc();
      if (fd != null) {
        fd.incrementCompletedUploads();
        _callback.handleSharedFileUpdate(fd.getFile());
      }
    }
  }
  long finishTime=System.currentTimeMillis();
synchronized (UploadManager.this) {
    if (startTime > 0)     reportUploadSpeed(finishTime - startTime,uploader.amountUploaded());
    removeFromList(uploader);
    if (!isBHUploader)     _callback.removeUpload(uploader);
    return ret;
  }
}","/** 
 * Does some book-keeping and makes the downloader, start the download
 * @param uploader This method assumes that uploader is connected.
 * @exception IOException thrown if insertAndTest throws an IOException
 */
private boolean doSingleUpload(Uploader uploader,Socket socket,String host,int index) throws IOException {
  long startTime=-1;
  debug(uploader + ""String_Node_Str"");
  boolean isBHUploader=(uploader.getState() == Uploader.BROWSE_HOST);
  int queued=-1;
  boolean ret=false;
  if (!isBHUploader) {
    if (uploader.getState() == Uploader.CONNECTING) {
      queued=insertAndTest(uploader,host,socket);
      debug(uploader + ""String_Node_Str"" + queued);
      Assert.that(queued != -1);
    }
    _callback.addUpload(uploader);
    FileDesc fd=uploader.getFileDesc();
    if (fd != null) {
      fd.incrementAttemptedUploads();
      _callback.handleSharedFileUpdate(fd.getFile());
    }
  }
  if (queued == 1) {
    socket.setSoTimeout(MAX_POLL_TIME);
    uploader.setState(Uploader.QUEUED);
    ret=true;
  }
 else   if (queued == 2) {
synchronized (this) {
      uploader.setState(Uploader.CONNECTING);
      _activeUploadList.add(uploader);
    }
  }
  startTime=System.currentTimeMillis();
  uploader.writeResponse();
  debug(uploader + ""String_Node_Str"");
  if (uploader.getState() == Uploader.UPLOADING || uploader.getState() == Uploader.CONNECTING) {
    uploader.setState(Uploader.INTERRUPTED);
  }
  if (uploader.getState() == Uploader.COMPLETE) {
    _hadSuccesfulUpload=true;
    if (!isBHUploader) {
      FileDesc fd=uploader.getFileDesc();
      if (fd != null) {
        fd.incrementCompletedUploads();
        _callback.handleSharedFileUpdate(fd.getFile());
      }
    }
  }
  long finishTime=System.currentTimeMillis();
synchronized (UploadManager.this) {
    if (startTime > 0)     reportUploadSpeed(finishTime - startTime,uploader.amountUploaded());
    removeFromList(uploader);
    if (!isBHUploader)     _callback.removeUpload(uploader);
    return ret;
  }
}",0.9832402234636872
4820,"/** 
 * Note: Called when we encounter a 503, and need to check if the uploader has queued us or not. Consuming all the headers is required, because if queued, we intend to use the same stream again, and residual headers will cause problems. Further, these headers are of no use to anyone else.
 */
private void supportsQueueing() throws IOException, QueuedException {
  int position=-1;
  int minPollTime=-1;
  int maxPollTime=-1;
  String str=_byteReader.readLine();
  while (!str.equals(""String_Node_Str"")) {
    StringTokenizer tokenizer=new StringTokenizer(str,""String_Node_Str"");
    if (!tokenizer.hasMoreTokens()) {
      str=_byteReader.readLine();
      continue;
    }
    String token=tokenizer.nextToken();
    if (!token.equals(""String_Node_Str"")) {
      str=_byteReader.readLine();
      continue;
    }
    while (tokenizer.hasMoreTokens()) {
      token=tokenizer.nextToken();
      String value;
      if (token.equals(""String_Node_Str"")) {
        value=tokenizer.nextToken();
        minPollTime=Integer.parseInt(value);
      }
 else       if (token.equals(""String_Node_Str"")) {
        value=tokenizer.nextToken();
        maxPollTime=Integer.parseInt(value);
      }
 else       if (token.equals(""String_Node_Str"")) {
        value=tokenizer.nextToken();
        position=Integer.parseInt(value);
      }
    }
    str=_byteReader.readLine();
  }
  if (minPollTime == -1 && maxPollTime == -1 && position == -1)   throw new IOException();
  throw new QueuedException(minPollTime,maxPollTime,position);
}","/** 
 * Note: Called when we encounter a 503, and need to check if the uploader has queued us or not. Consuming all the headers is required, because if queued, we intend to use the same stream again, and residual headers will cause problems. Further, these headers are of no use to anyone else.
 */
private void supportsQueueing() throws IOException, QueuedException {
  int position=-1;
  int minPollTime=-1;
  int maxPollTime=-1;
  String str=_byteReader.readLine();
  if (str == null)   throw new IOException();
  while (!str.equals(""String_Node_Str"")) {
    StringTokenizer tokenizer=new StringTokenizer(str,""String_Node_Str"");
    if (!tokenizer.hasMoreTokens()) {
      str=_byteReader.readLine();
      continue;
    }
    String token=tokenizer.nextToken();
    if (!token.equals(""String_Node_Str"")) {
      str=_byteReader.readLine();
      continue;
    }
    while (tokenizer.hasMoreTokens()) {
      token=tokenizer.nextToken();
      String value;
      if (token.equals(""String_Node_Str"")) {
        value=tokenizer.nextToken();
        minPollTime=Integer.parseInt(value);
      }
 else       if (token.equals(""String_Node_Str"")) {
        value=tokenizer.nextToken();
        maxPollTime=Integer.parseInt(value);
      }
 else       if (token.equals(""String_Node_Str"")) {
        value=tokenizer.nextToken();
        position=Integer.parseInt(value);
      }
    }
    str=_byteReader.readLine();
  }
  if (minPollTime == -1 && maxPollTime == -1 && position == -1)   throw new IOException();
  throw new QueuedException(minPollTime,maxPollTime,position);
}",0.3595868302130406
4821,"/** 
 * Accepts a new upload, creating a new <tt>HTTPUploader</tt> if it successfully parses the HTTP request.  BLOCKING.
 * @param method the <tt>HTTPRequestMethod</tt> that will delegate tothe appropriate response handlers for the type of request
 * @param socket the <tt>Socket</tt> that will be used for the new upload
 */
public void acceptUpload(HTTPRequestMethod method,Socket socket){
  debug(""String_Node_Str"");
  HTTPUploader uploader=null;
  try {
    int queued=-1;
    String oldFileName=""String_Node_Str"";
    while (true) {
      HttpRequestLine line=parseHttpRequest(socket);
      debug(""String_Node_Str"");
      String fileName=line._fileName;
      uploader=new HTTPUploader(method,fileName,socket,line._index,this,_fileManager,_router);
      uploader.readHeader();
      debug(uploader + ""String_Node_Str"");
      boolean giveSlot=(oldFileName.equalsIgnoreCase(fileName) && queued == ACCEPTED);
      queued=doSingleUpload(uploader,socket,socket.getInetAddress().getHostAddress(),line._index,giveSlot);
      oldFileName=fileName;
      if ((!line.isHTTP11() || uploader.getCloseConnection()) && queued != QUEUED)       return;
      debug(uploader + ""String_Node_Str"");
      int oldTimeout=socket.getSoTimeout();
      if (queued != QUEUED)       socket.setSoTimeout(SettingsManager.instance().getPersistentHTTPConnectionTimeout());
      String word=IOUtils.readWord(socket.getInputStream(),4);
      debug(uploader + ""String_Node_Str"");
      socket.setSoTimeout(oldTimeout);
      if (!word.equalsIgnoreCase(""String_Node_Str"") && !word.equalsIgnoreCase(""String_Node_Str""))       return;
    }
  }
 catch (  IOException ioe) {
    debug(""String_Node_Str"");
  }
 finally {
synchronized (this) {
      boolean found=false;
      for (Iterator iter=_queuedUploads.iterator(); iter.hasNext(); ) {
        KeyValue kv=(KeyValue)iter.next();
        if (kv.getKey() == socket) {
          found=true;
          iter.remove();
        }
      }
      if (found)       uploader.setState(Uploader.INTERRUPTED);
    }
    debug(""String_Node_Str"");
    close(socket);
  }
}","/** 
 * Accepts a new upload, creating a new <tt>HTTPUploader</tt> if it successfully parses the HTTP request.  BLOCKING.
 * @param method the initial request type to use, e.g., GET or HEAD
 * @param socket the <tt>Socket</tt> that will be used for the new upload.It is assumed that the initial word of the request (e.g., ""GET"") has been consumed (e.g., by Acceptor)
 */
public void acceptUpload(final HTTPRequestMethod method,Socket socket){
  debug(""String_Node_Str"");
  HTTPUploader uploader=null;
  try {
    int queued=-1;
    String oldFileName=""String_Node_Str"";
    HTTPRequestMethod currentMethod=method;
    while (true) {
      HttpRequestLine line=parseHttpRequest(socket);
      debug(""String_Node_Str"");
      String fileName=line._fileName;
      uploader=new HTTPUploader(currentMethod,fileName,socket,line._index,this,_fileManager,_router);
      uploader.readHeader();
      debug(uploader + ""String_Node_Str"");
      boolean giveSlot=(oldFileName.equalsIgnoreCase(fileName) && queued == ACCEPTED);
      queued=doSingleUpload(uploader,socket,socket.getInetAddress().getHostAddress(),line._index,giveSlot);
      oldFileName=fileName;
      if ((!line.isHTTP11() || uploader.getCloseConnection()) && queued != QUEUED)       return;
      debug(uploader + ""String_Node_Str"");
      int oldTimeout=socket.getSoTimeout();
      if (queued != QUEUED)       socket.setSoTimeout(SettingsManager.instance().getPersistentHTTPConnectionTimeout());
      String word=IOUtils.readWord(socket.getInputStream(),4);
      debug(uploader + ""String_Node_Str"");
      socket.setSoTimeout(oldTimeout);
      if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.GET;
 else       if (word.equals(""String_Node_Str""))       currentMethod=HTTPRequestMethod.HEAD;
 else       return;
    }
  }
 catch (  IOException ioe) {
    debug(""String_Node_Str"");
  }
 finally {
synchronized (this) {
      boolean found=false;
      for (Iterator iter=_queuedUploads.iterator(); iter.hasNext(); ) {
        KeyValue kv=(KeyValue)iter.next();
        if (kv.getKey() == socket) {
          found=true;
          iter.remove();
        }
      }
      if (found)       uploader.setState(Uploader.INTERRUPTED);
    }
    debug(""String_Node_Str"");
    close(socket);
  }
}",0.7371559633027523
4822,"public void testAll(){
  try {
    boolean passed;
    try {
      Thread.sleep(200);
    }
 catch (    InterruptedException e) {
    }
    passed=downloadPush(file,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush(encodedFile,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(file,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    assertEquals(""String_Node_Str"" + URLDecoder.decode(encodedFile),file,URLDecoder.decode(encodedFile));
    passed=download(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"" + ""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    assertEquals(""String_Node_Str"" + URLDecoder.decode(encodedFile),file,URLDecoder.decode(encodedFile));
    passed=download1(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=pipelineDownloadNormal(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=pipelineDownloadPush(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    System.out.println(""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"" + e,false);
  }
catch (  BadPacketException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"" + e,false);
  }
}","public void testAll(){
  try {
    boolean passed;
    try {
      Thread.sleep(200);
    }
 catch (    InterruptedException e) {
    }
    passed=downloadPush(file,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush(encodedFile,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(file,null,alphabet);
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=downloadPush1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    assertEquals(""String_Node_Str"" + URLDecoder.decode(encodedFile),file,URLDecoder.decode(encodedFile));
    passed=download(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"" + ""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    assertEquals(""String_Node_Str"" + URLDecoder.decode(encodedFile),file,URLDecoder.decode(encodedFile));
    passed=download1(encodedFile,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=pipelineDownloadNormal(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    passed=pipelineDownloadPush(file,null,""String_Node_Str"");
    assertTrue(""String_Node_Str"",passed);
    tMixedPersistentRequests();
    System.out.println(""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"" + e,false);
  }
catch (  BadPacketException e) {
    e.printStackTrace();
    assertTrue(""String_Node_Str"" + e,false);
  }
}",0.995051036189298
4823,"/** 
 * Sends a get request to out, reads the response from in, and returns the content.  Doesn't close in or out.
 */
private static String downloadInternal1(String file,String header,BufferedWriter out,BufferedReader in,int expectedSize) throws IOException {
  out.write(""String_Node_Str"" + index + ""String_Node_Str""+ file+ ""String_Node_Str"");
  if (header != null)   out.write(header + ""String_Node_Str"");
  out.write(""String_Node_Str"");
  out.write(""String_Node_Str"");
  out.flush();
  while (!in.readLine().equals(""String_Node_Str"")) {
  }
  StringBuffer buf=new StringBuffer();
  for (int i=0; i < expectedSize; i++) {
    int c=in.read();
    buf.append((char)c);
  }
  return buf.toString();
}","/** 
 * Same as downloadInternal1(file, header, out, in, expectedSize), but uses the given request type.
 * @param request an HTTP request such as ""GET"" or ""HEAD""
 */
private static String downloadInternal1(String request,String file,String header,BufferedWriter out,BufferedReader in,int expectedSize) throws IOException {
  out.write(request + ""String_Node_Str"" + index+ ""String_Node_Str""+ file+ ""String_Node_Str"");
  if (header != null)   out.write(header + ""String_Node_Str"");
  out.write(""String_Node_Str"");
  out.write(""String_Node_Str"");
  out.flush();
  while (!in.readLine().equals(""String_Node_Str"")) {
  }
  StringBuffer buf=new StringBuffer();
  for (int i=0; i < expectedSize; i++) {
    int c=in.read();
    buf.append((char)c);
  }
  return buf.toString();
}",0.824966078697422
4824,"protected void setUp(){
  try {
    address=InetAddress.getLocalHost().getHostAddress();
  }
 catch (  UnknownHostException e) {
    assertTrue(""String_Node_Str"" + e,false);
  }
  port=6668;
  File testDir=new File(""String_Node_Str"");
  if (!testDir.isDirectory()) {
    testDir=new File(""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",testDir.isDirectory());
  assertTrue(""String_Node_Str"",new File(testDir,file).isFile());
  SettingsManager.instance().setPort(port);
  SettingsManager.instance().setDirectories(new File[]{testDir});
  SettingsManager.instance().setExtensions(""String_Node_Str"");
  SettingsManager.instance().setKeepAlive(6);
  SettingsManager.instance().setMaxUploads(10);
  SettingsManager.instance().setUploadsPerPerson(10);
  SettingsManager.instance().setConnectOnStartup(true);
  SettingsManager.instance().writeProperties();
  ActivityCallback callback=new ActivityCallbackStub();
  FileManager fm=new MetaFileManager();
  fm.initialize(callback);
  MessageRouter mr=new StandardMessageRouter(callback,fm);
  RouterService router=new RouterService(callback,mr,fm,new ServerAuthenticator());
  router.initialize();
  assertEquals(port,SettingsManager.instance().getPort());
}","protected void setUp(){
  try {
    address=InetAddress.getLocalHost().getHostAddress();
  }
 catch (  UnknownHostException e) {
    assertTrue(""String_Node_Str"" + e,false);
  }
  port=6668;
  File testDir=new File(""String_Node_Str"");
  if (!testDir.isDirectory()) {
    testDir=new File(""String_Node_Str"");
  }
  assertTrue(""String_Node_Str"",testDir.isDirectory());
  assertTrue(""String_Node_Str"",new File(testDir,file).isFile());
  SettingsManager.instance().setPort(port);
  SettingsManager.instance().setDirectories(new File[]{testDir});
  SettingsManager.instance().setExtensions(""String_Node_Str"");
  SettingsManager.instance().setKeepAlive(8);
  SettingsManager.instance().setMaxUploads(10);
  SettingsManager.instance().setUploadsPerPerson(10);
  SettingsManager.instance().setConnectOnStartup(true);
  SettingsManager.instance().setFilterDuplicates(false);
  SettingsManager.instance().setEverSupernodeCapable(true);
  SettingsManager.instance().setForceSupernodeMode(true);
  SettingsManager.instance().setDisableSupernodeMode(false);
  SettingsManager.instance().writeProperties();
  ActivityCallback callback=new ActivityCallbackStub();
  FileManager fm=new MetaFileManager();
  fm.initialize(callback);
  MessageRouter mr=new StandardMessageRouter(callback,fm);
  RouterService router=new RouterService(callback,mr,fm,new ServerAuthenticator());
  router.initialize();
  assertEquals(port,SettingsManager.instance().getPort());
}",0.9101208459214502
4825,"/** 
 * Increments the count of uploads in progress for host. If uploader has exceeded its limits, places it in LIMIT_REACHED state. Always accept Browse Host requests, though.... Notifies callback of this. Corollary: wontAccept is true iff hasQueue is true Corollary: (hasQueue==false) => (wontaccept==false) Corollary: (hasQueue==false) => posInQueue == -1
 * @modifies uploader, _callback 
 * @exception if an uploader gets a request too soon, we are going to throwan IOException, which will cause the socket to be closed. 
 * @return 0 if rejected, 1 if queued, 2 if given a slot
 */
private synchronized int insertAndTest(Uploader uploader,String host,Socket socket) throws IOException {
  boolean limitReached=hostLimitReached(host);
  int size=_queuedUploads.size();
  int posInQueue=positionInQueue(socket);
  int maxQueueSize=SettingsManager.instance().getUploadQueueSize();
  boolean wontAccept=size >= maxQueueSize;
  int ret=-1;
  boolean queue=uploader.supportsQueueing();
  Assert.that(maxQueueSize > 0,""String_Node_Str"");
  Assert.that(uploader.getState() != Uploader.BROWSE_HOST);
  if (posInQueue == -1) {
    debug(uploader + ""String_Node_Str"" + maxQueueSize+ ""String_Node_Str"");
    if (limitReached || wontAccept) {
      debug(uploader + ""String_Node_Str"" + limitReached+ ""String_Node_Str""+ wontAccept);
      uploader.setState(Uploader.LIMIT_REACHED);
      return 0;
    }
    addToQueue(socket);
    posInQueue=size;
    ret=1;
    debug(uploader + ""String_Node_Str"");
  }
 else {
    KeyValue kv=(KeyValue)_queuedUploads.get(posInQueue);
    Long prev=(Long)kv.getValue();
    if (prev.longValue() + MIN_POLL_TIME > System.currentTimeMillis()) {
      _queuedUploads.remove(posInQueue);
      debug(uploader + ""String_Node_Str"");
      throw new IOException();
    }
    kv.setValue(new Long(System.currentTimeMillis()));
    debug(uploader + ""String_Node_Str"");
    ret=1;
  }
  debug(uploader + ""String_Node_Str"");
  if (!this.isBusy() && posInQueue == 0) {
    ret=2;
    debug(uploader + ""String_Node_Str"");
    _queuedUploads.remove(0);
  }
  if (!queue) {
    _queuedUploads.remove(posInQueue);
    uploader.setState(Uploader.LIMIT_REACHED);
    ret=0;
  }
  return ret;
}","/** 
 * Increments the count of uploads in progress for host. If uploader has exceeded its limits, places it in LIMIT_REACHED state. Always accept Browse Host requests, though.... Notifies callback of this. Corollary: wontAccept is true iff hasQueue is true Corollary: (hasQueue==false) => (wontaccept==false) Corollary: (hasQueue==false) => posInQueue == -1
 * @modifies uploader, _callback 
 * @exception if an uploader gets a request too soon, we are going to throwan IOException, which will cause the socket to be closed. 
 * @return 0 if rejected, 1 if queued, 2 if given a slot
 */
private synchronized int insertAndTest(Uploader uploader,String host,Socket socket) throws IOException {
  boolean limitReached=hostLimitReached(host);
  int size=_queuedUploads.size();
  int posInQueue=positionInQueue(socket);
  int maxQueueSize=SettingsManager.instance().getUploadQueueSize();
  boolean wontAccept=size >= maxQueueSize;
  int ret=-1;
  boolean queue=uploader.supportsQueueing();
  Assert.that(maxQueueSize > 0,""String_Node_Str"");
  Assert.that(uploader.getState() != Uploader.BROWSE_HOST);
  if (posInQueue == -1) {
    debug(uploader + ""String_Node_Str"" + maxQueueSize+ ""String_Node_Str"");
    if (limitReached || wontAccept) {
      debug(uploader + ""String_Node_Str"" + limitReached+ ""String_Node_Str""+ wontAccept);
      uploader.setState(Uploader.LIMIT_REACHED);
      return 0;
    }
    addToQueue(socket);
    posInQueue=size;
    ret=1;
    debug(uploader + ""String_Node_Str"");
  }
 else {
    KeyValue kv=(KeyValue)_queuedUploads.get(posInQueue);
    Long prev=(Long)kv.getValue();
    if (prev.longValue() + MIN_POLL_TIME > System.currentTimeMillis()) {
      _queuedUploads.remove(posInQueue);
      debug(uploader + ""String_Node_Str"");
      throw new IOException();
    }
    kv.setValue(new Long(System.currentTimeMillis()));
    debug(uploader + ""String_Node_Str"");
    ret=1;
  }
  debug(uploader + ""String_Node_Str"");
  if (!this.isBusy() && posInQueue == 0) {
    ret=2;
    debug(uploader + ""String_Node_Str"");
    _queuedUploads.remove(0);
  }
 else {
    if (!queue) {
      _queuedUploads.remove(posInQueue);
      uploader.setState(Uploader.LIMIT_REACHED);
      ret=0;
    }
  }
  return ret;
}",0.9896115627822945
4826,"public String getValue(String fieldName){
  String retValue=null;
  fieldName=fieldName.trim();
  retValue=(String)fieldToValue.get(fieldName);
  if (fieldName.equals(""String_Node_Str"") && (retValue != null)) {
    try {
      short index=Short.parseShort(retValue);
      retValue=ID3Reader.getGenreString(index);
      fieldToValue.put(fieldName,retValue);
    }
 catch (    NumberFormatException ignored) {
    }
 finally {
      if (retValue.equals(""String_Node_Str"")) {
        fieldToValue.remove(fieldName);
        retValue=null;
      }
    }
  }
  return retValue;
}","public String getValue(String fieldName){
  String retValue=null;
  fieldName=fieldName.trim();
  retValue=(String)fieldToValue.get(fieldName);
  if (fieldName.equals(""String_Node_Str"") && (retValue != null)) {
    try {
      short index=Short.parseShort(retValue);
      retValue=ID3Reader.getGenreString(index);
      fieldToValue.put(fieldName,retValue);
    }
 catch (    NumberFormatException ignored) {
    }
  }
  return retValue;
}",0.8326771653543307
4827,"/** 
 * Tries one round of downloading of the given files.  Downloads from all locations until all locations fail or some locations succeed.  Moves incomplete file to the library on success.
 * @return COMPLETE if a file was successfully downloaded.  This canhappen even if the file is corrupt, if the user explicitly approved. CORRUPT_FILE a bytes mismatched when checking overlapping regions of resume or swarm, and the user decided they' did not want the download fragment, which is now quarantined. COULDNT_MOVE_TO_LIBRARY the download completed but the temporary file couldn't be moved to the library OR the download couldn't be written to the incomplete file WAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try.
 * @exception InterruptedException if the user stop()'ed this download. (Calls to resume() do not result in InterruptedException.)
 */
private int tryAllDownloads2() throws InterruptedException {
synchronized (this) {
    if (files.size() == 0)     return GAVE_UP;
  }
  RemoteFileDesc rfd=null;
synchronized (this) {
    rfd=(RemoteFileDesc)files.get(0);
  }
  int fileSize=rfd.getSize();
  String filename=rfd.getFileName();
  File incompleteFile=incompleteFileManager.getFile(rfd);
  File sharedDir;
  File completeFile;
  try {
    sharedDir=SettingsManager.instance().getSaveDirectory();
    completeFile=new File(sharedDir,filename);
    String sharedPath=sharedDir.getCanonicalPath();
    String completeFileParentPath=new File(completeFile.getParent()).getCanonicalPath();
    if (!sharedPath.equals(completeFileParentPath))     throw new InvalidPathException();
  }
 catch (  IOException e) {
    return COULDNT_MOVE_TO_LIBRARY;
  }
  totalAlternateLocations=new AlternateLocationCollection();
  RemoteFileDesc tempRFD;
  String rfdStr;
  URL rfdURL;
synchronized (this) {
    for (Iterator iter=files.iterator(); iter.hasNext(); ) {
      tempRFD=(RemoteFileDesc)iter.next();
      if (tempRFD.getSHA1Urn() == null)       continue;
      try {
        totalAlternateLocations.addAlternateLocation(AlternateLocation.createAlternateLocation(tempRFD));
      }
 catch (      IOException e) {
      }
    }
  }
  int status=-1;
  try {
    status=tryAllDownloads3();
  }
 catch (  InterruptedException e) {
  }
  commonOutFile.close();
  if (corruptState != NOT_CORRUPT_STATE) {
synchronized (corruptStateLock) {
      try {
        while (corruptState == CORRUPT_WAITING_STATE) {
          corruptStateLock.wait();
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
 else     if (corruptState == CORRUPT_CONTINUE_STATE) {
      ;
    }
  }
  if (status == -1)   throw new InterruptedException();
  if (status != COMPLETE)   return status;
  URN bucketHash=buckets.getURNForBucket(bucketNumber);
  URN fileHash=null;
  try {
    fileHash=URN.createSHA1Urn(incompleteFile);
  }
 catch (  IOException ignored) {
  }
  if (bucketHash != null) {
synchronized (corruptStateLock) {
      if (!bucketHash.equals(fileHash)) {
        promptAboutCorruptDownload();
        debug(""String_Node_Str"" + fileHash + ""String_Node_Str""+ bucketHash);
      }
      try {
        while (corruptState == CORRUPT_WAITING_STATE)         corruptStateLock.wait();
      }
 catch (      InterruptedException ignored2) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
  }
  completeFile.delete();
  if (!incompleteFile.renameTo(completeFile))   if (!CommonUtils.copy(incompleteFile,completeFile))   return COULDNT_MOVE_TO_LIBRARY;
  incompleteFileManager.removeEntry(incompleteFile);
  if (fileExists(completeFile))   fileManager.removeFileIfShared(completeFile);
  boolean fileAdded=fileManager.addFileIfShared(completeFile,getXMLDocuments());
  if (totalAlternateLocations != null && fileAdded) {
    FileDesc fileDesc=fileManager.getFileDescMatching(completeFile);
    if (fileDesc != null) {
      fileDesc.addAlternateLocationCollection(totalAlternateLocations);
      callback.handleSharedFileUpdate(completeFile);
      HeadRequester requester=new HeadRequester(files,fileHash,fileDesc,totalAlternateLocations);
      Thread headThread=new Thread(requester);
      headThread.setDaemon(true);
      headThread.start();
    }
  }
  return COMPLETE;
}","/** 
 * Tries one round of downloading of the given files.  Downloads from all locations until all locations fail or some locations succeed.  Moves incomplete file to the library on success.
 * @return COMPLETE if a file was successfully downloaded.  This canhappen even if the file is corrupt, if the user explicitly approved. CORRUPT_FILE a bytes mismatched when checking overlapping regions of resume or swarm, and the user decided they' did not want the download fragment, which is now quarantined. COULDNT_MOVE_TO_LIBRARY the download completed but the temporary file couldn't be moved to the library OR the download couldn't be written to the incomplete file WAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try.
 * @exception InterruptedException if the user stop()'ed this download. (Calls to resume() do not result in InterruptedException.)
 */
private int tryAllDownloads2() throws InterruptedException {
synchronized (this) {
    if (files.size() == 0)     return GAVE_UP;
  }
  RemoteFileDesc rfd=null;
synchronized (this) {
    rfd=(RemoteFileDesc)files.get(0);
  }
  int fileSize=rfd.getSize();
  String filename=rfd.getFileName();
  incompleteFile=incompleteFileManager.getFile(rfd);
  File sharedDir;
  try {
    sharedDir=SettingsManager.instance().getSaveDirectory();
    completeFile=new File(sharedDir,filename);
    String sharedPath=sharedDir.getCanonicalPath();
    String completeFileParentPath=new File(completeFile.getParent()).getCanonicalPath();
    if (!sharedPath.equals(completeFileParentPath))     throw new InvalidPathException();
  }
 catch (  IOException e) {
    return COULDNT_MOVE_TO_LIBRARY;
  }
  totalAlternateLocations=new AlternateLocationCollection();
  RemoteFileDesc tempRFD;
  String rfdStr;
  URL rfdURL;
synchronized (this) {
    for (Iterator iter=files.iterator(); iter.hasNext(); ) {
      tempRFD=(RemoteFileDesc)iter.next();
      if (tempRFD.getSHA1Urn() == null)       continue;
      try {
        totalAlternateLocations.addAlternateLocation(AlternateLocation.createAlternateLocation(tempRFD));
      }
 catch (      IOException e) {
      }
    }
  }
  int status=-1;
  try {
    status=tryAllDownloads3();
  }
 catch (  InterruptedException e) {
  }
  commonOutFile.close();
  if (corruptState != NOT_CORRUPT_STATE) {
synchronized (corruptStateLock) {
      try {
        while (corruptState == CORRUPT_WAITING_STATE) {
          corruptStateLock.wait();
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
 else     if (corruptState == CORRUPT_CONTINUE_STATE) {
      ;
    }
  }
  if (status == -1)   throw new InterruptedException();
  if (status != COMPLETE)   return status;
  URN bucketHash=buckets.getURNForBucket(bucketNumber);
  URN fileHash=null;
  try {
    fileHash=URN.createSHA1Urn(incompleteFile);
  }
 catch (  IOException ignored) {
  }
  if (bucketHash != null) {
synchronized (corruptStateLock) {
      if (!bucketHash.equals(fileHash)) {
        promptAboutCorruptDownload();
        debug(""String_Node_Str"" + fileHash + ""String_Node_Str""+ bucketHash);
      }
      try {
        while (corruptState == CORRUPT_WAITING_STATE)         corruptStateLock.wait();
      }
 catch (      InterruptedException ignored2) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
  }
  completeFile.delete();
  if (!incompleteFile.renameTo(completeFile))   if (!CommonUtils.copy(incompleteFile,completeFile))   return COULDNT_MOVE_TO_LIBRARY;
  incompleteFileManager.removeEntry(incompleteFile);
  if (fileExists(completeFile))   fileManager.removeFileIfShared(completeFile);
  boolean fileAdded=fileManager.addFileIfShared(completeFile,getXMLDocuments());
  if (totalAlternateLocations != null && fileAdded) {
    FileDesc fileDesc=fileManager.getFileDescMatching(completeFile);
    if (fileDesc != null) {
      fileDesc.addAlternateLocationCollection(totalAlternateLocations);
      callback.handleSharedFileUpdate(completeFile);
      HeadRequester requester=new HeadRequester(files,fileHash,fileDesc,totalAlternateLocations);
      Thread headThread=new Thread(requester);
      headThread.setDaemon(true);
      headThread.start();
    }
  }
  return COMPLETE;
}",0.997177594442032
4828,"/** 
 * Actually does the download, finding duplicate files, trying all locations, resuming, waiting, and retrying as necessary. Also takes care of moving file from incomplete directory to save directory and adding file to the library.  Called from dloadManagerThread.  
 */
private void tryAllDownloads(){
  int numRequeries=0;
  long nextRequeryTime=System.currentTimeMillis() + TIME_BETWEEN_REQUERIES;
synchronized (this) {
    buckets=new RemoteFileDescGrouper(allFiles,incompleteFileManager);
  }
  while (true) {
    try {
      setState(QUEUED);
      queuePosition=""String_Node_Str"";
      queuedCount=0;
      manager.waitForSlot(this);
      boolean waitForRetry=false;
      bucketNumber=0;
      try {
        for (Iterator iter=buckets.buckets(); iter.hasNext(); bucketNumber++) {
          cleanup();
          files=(List)iter.next();
          if (checkHosts()) {
            setState(GAVE_UP);
            return;
          }
          if (files.size() <= 0)           continue;
synchronized (this) {
            RemoteFileDesc rfd=(RemoteFileDesc)files.get(0);
            currentFileName=rfd.getFileName();
            currentFileSize=rfd.getSize();
          }
          int status=tryAllDownloads2();
          if (status == COMPLETE) {
            setState(COMPLETE);
            manager.remove(this,true);
            return;
          }
 else           if (status == COULDNT_MOVE_TO_LIBRARY) {
            setState(COULDNT_MOVE_TO_LIBRARY);
            manager.remove(this,false);
            return;
          }
 else           if (status == CORRUPT_FILE) {
            setState(CORRUPT_FILE);
            manager.remove(this,false);
            return;
          }
 else           if (status == WAITING_FOR_RETRY) {
            waitForRetry=true;
          }
 else {
            Assert.that(status == GAVE_UP,""String_Node_Str"" + status);
          }
        }
      }
 catch (      InterruptedException e) {
        if (!stopped)         ManagedDownloader.this.manager.internalError(e);
      }
      manager.yieldSlot(this);
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
      final long currTime=System.currentTimeMillis();
      if ((currTime >= nextRequeryTime) && (numRequeries < REQUERY_ATTEMPTS)) {
        try {
          if (manager.sendQuery(this,newRequery()))           numRequeries++;
        }
 catch (        CantResumeException ignore) {
        }
        nextRequeryTime=currTime + TIME_BETWEEN_REQUERIES;
      }
      if (waitForRetry) {
synchronized (this) {
          retriesWaiting=0;
          for (Iterator iter=buckets.buckets(); iter.hasNext(); ) {
            List bucket=(List)iter.next();
            retriesWaiting+=bucket.size();
          }
        }
        long time=calculateWaitTime();
        setState(WAITING_FOR_RETRY,time);
        reqLock.lock(time);
      }
 else {
        if (numRequeries <= REQUERY_ATTEMPTS) {
          final long waitTime=nextRequeryTime - System.currentTimeMillis();
          if (waitTime > 0) {
            setState(WAITING_FOR_RESULTS,waitTime);
            reqLock.lock(waitTime);
          }
        }
 else {
          setState(GAVE_UP);
          manager.remove(this,false);
          return;
        }
      }
    }
 catch (    InterruptedException e) {
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
    }
  }
}","/** 
 * Actually does the download, finding duplicate files, trying all locations, resuming, waiting, and retrying as necessary. Also takes care of moving file from incomplete directory to save directory and adding file to the library.  Called from dloadManagerThread.  
 */
private void tryAllDownloads(){
  int numRequeries=0;
  long nextRequeryTime=System.currentTimeMillis() + TIME_BETWEEN_REQUERIES;
synchronized (this) {
    buckets=new RemoteFileDescGrouper(allFiles,incompleteFileManager);
  }
  while (true) {
    try {
      setState(QUEUED);
      queuePosition=""String_Node_Str"";
      queuedCount=0;
      manager.waitForSlot(this);
      boolean waitForRetry=false;
      bucketNumber=0;
      try {
        for (Iterator iter=buckets.buckets(); iter.hasNext(); bucketNumber++) {
          cleanup();
          files=(List)iter.next();
          if (checkHosts()) {
            setState(GAVE_UP);
            return;
          }
          if (files.size() <= 0)           continue;
          int status=tryAllDownloads2();
          if (status == COMPLETE) {
            setState(COMPLETE);
            manager.remove(this,true);
            return;
          }
 else           if (status == COULDNT_MOVE_TO_LIBRARY) {
            setState(COULDNT_MOVE_TO_LIBRARY);
            manager.remove(this,false);
            return;
          }
 else           if (status == CORRUPT_FILE) {
            setState(CORRUPT_FILE);
            manager.remove(this,false);
            return;
          }
 else           if (status == WAITING_FOR_RETRY) {
            waitForRetry=true;
          }
 else {
            Assert.that(status == GAVE_UP,""String_Node_Str"" + status);
          }
        }
      }
 catch (      InterruptedException e) {
        if (!stopped)         ManagedDownloader.this.manager.internalError(e);
      }
      manager.yieldSlot(this);
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
      final long currTime=System.currentTimeMillis();
      if ((currTime >= nextRequeryTime) && (numRequeries < REQUERY_ATTEMPTS)) {
        try {
          if (manager.sendQuery(this,newRequery()))           numRequeries++;
        }
 catch (        CantResumeException ignore) {
        }
        nextRequeryTime=currTime + TIME_BETWEEN_REQUERIES;
      }
      if (waitForRetry) {
synchronized (this) {
          retriesWaiting=0;
          for (Iterator iter=buckets.buckets(); iter.hasNext(); ) {
            List bucket=(List)iter.next();
            retriesWaiting+=bucket.size();
          }
        }
        long time=calculateWaitTime();
        setState(WAITING_FOR_RETRY,time);
        reqLock.lock(time);
      }
 else {
        if (numRequeries <= REQUERY_ATTEMPTS) {
          final long waitTime=nextRequeryTime - System.currentTimeMillis();
          if (waitTime > 0) {
            setState(WAITING_FOR_RESULTS,waitTime);
            reqLock.lock(waitTime);
          }
        }
 else {
          setState(GAVE_UP);
          manager.remove(this,false);
          return;
        }
      }
    }
 catch (    InterruptedException e) {
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
    }
  }
}",0.9723178213377226
4829,"public File getDownloadFragment(){
  if (currentFileName == null)   return null;
  if (state == CORRUPT_FILE)   return corruptFile;
 else   if (state != COMPLETE) {
    RemoteFileDesc rfd=buckets.getRemoteFileDescForBucket(bucketNumber);
    File incomplete=incompleteFileManager.getFile(rfd);
    File file=new File(incomplete.getParent(),IncompleteFileManager.PREVIEW_PREFIX + incomplete.getName());
    int size=amountForPreview();
    if (size <= 0)     return null;
    if (CommonUtils.copy(incomplete,size,file) <= 0)     return null;
    return file;
  }
 else {
    File saveDir=null;
    try {
      saveDir=SettingsManager.instance().getSaveDirectory();
    }
 catch (    java.io.FileNotFoundException fnfe) {
      return null;
    }
    return new File(saveDir,currentFileName);
  }
}","public File getDownloadFragment(){
  if (incompleteFile == null)   return null;
  if (state == CORRUPT_FILE)   return corruptFile;
 else   if (state != COMPLETE) {
    File file=new File(incompleteFile.getParent(),IncompleteFileManager.PREVIEW_PREFIX + incompleteFile.getName());
    int size=amountForPreview();
    if (size <= 0)     return null;
    if (CommonUtils.copy(incompleteFile,size,file) <= 0)     return null;
    return file;
  }
 else {
    return completeFile;
  }
}",0.3661971830985915
4830,"/** 
 * Assigns a white area or a grey area to a downloader. Sets the state, and checks if this downloader has been interrupted.
 * @param dloader The downloader to which this method assigns eithera grey area or white area.
 * @param refSleepTime this parameter is used for pass by reference, thismethod puts the minPollTime as the 0th element of this array.
 * @return 0 ifNoSuchElement, TryAgainLater, FileNotFound, NotSharing, Stopped, Misc IOE otherwise if queued return 1 otherwise if connected successfully return 2
 */
private int assignAndRequest(HTTPDownloader dloader,int[] refSleepTime){
synchronized (stealLock) {
    boolean updateNeeded=true;
    try {
      if (needed.size() > 0)       assignWhite(dloader);
 else {
        updateNeeded=false;
        assignGrey(dloader);
      }
      updateNeeded=false;
    }
 catch (    NoSuchElementException nsex) {
      Assert.that(updateNeeded == false,""String_Node_Str"");
      debug(""String_Node_Str"" + dloader);
synchronized (this) {
        files.add(dloader.getRemoteFileDesc());
      }
      return 0;
    }
catch (    TryAgainLaterException talx) {
      debug(""String_Node_Str"" + dloader);
synchronized (this) {
        busy.add(dloader.getRemoteFileDesc());
      }
      return 0;
    }
catch (    FileNotFoundException fnfx) {
      debug(""String_Node_Str"" + dloader);
      return 0;
    }
catch (    NotSharingException nsx) {
      debug(""String_Node_Str"" + dloader);
      return 0;
    }
catch (    QueuedException qx) {
      debug(""String_Node_Str"" + dloader);
      refSleepTime[0]=qx.getMinPollTime() * 1000 + 1000;
synchronized (this) {
        if (dloaders.size() == 0) {
          setState(REMOTE_QUEUED);
        }
        int oldPos=queuePosition.equals(""String_Node_Str"") ? Integer.MAX_VALUE : Integer.parseInt(queuePosition);
        int newPos=qx.getQueuePosition();
        queuePosition=oldPos < newPos ? ""String_Node_Str"" + oldPos : ""String_Node_Str"" + newPos;
      }
      return 1;
    }
catch (    IOException iox) {
      debug(""String_Node_Str"" + dloader);
      return 0;
    }
 finally {
      if (updateNeeded)       updateNeeded(dloader);
    }
synchronized (this) {
      setState(DOWNLOADING);
    }
    if (stopped) {
      debug(""String_Node_Str"");
      updateNeeded(dloader);
synchronized (this) {
        files.add(dloader.getRemoteFileDesc());
      }
      return 0;
    }
synchronized (this) {
      dloaders.add(dloader);
      chatList.addHost(dloader);
      browseList.addHost(dloader);
      addAlternateLocations(dloader.getAlternateLocations(),dloader.getRemoteFileDesc());
    }
    return 2;
  }
}","/** 
 * Assigns a white area or a grey area to a downloader. Sets the state, and checks if this downloader has been interrupted.
 * @param dloader The downloader to which this method assigns eithera grey area or white area.
 * @param refSleepTime this parameter is used for pass by reference, thismethod puts the minPollTime as the 0th element of this array.
 * @return 0 ifNoSuchElement, TryAgainLater, FileNotFound, NotSharing, Stopped, Misc IOE otherwise if queued return 1 otherwise if connected successfully return 2
 */
private int assignAndRequest(HTTPDownloader dloader,int[] refSleepTime){
synchronized (stealLock) {
    boolean updateNeeded=true;
    try {
      if (needed.size() > 0)       assignWhite(dloader);
 else {
        updateNeeded=false;
        assignGrey(dloader);
      }
      updateNeeded=false;
    }
 catch (    NoSuchElementException nsex) {
      Assert.that(updateNeeded == false,""String_Node_Str"");
      debug(""String_Node_Str"" + dloader);
synchronized (this) {
        files.add(dloader.getRemoteFileDesc());
      }
      return 0;
    }
catch (    TryAgainLaterException talx) {
      debug(""String_Node_Str"" + dloader);
synchronized (this) {
        busy.add(dloader.getRemoteFileDesc());
      }
      return 0;
    }
catch (    FileNotFoundException fnfx) {
      debug(""String_Node_Str"" + dloader);
      return 0;
    }
catch (    NotSharingException nsx) {
      debug(""String_Node_Str"" + dloader);
      return 0;
    }
catch (    QueuedException qx) {
      debug(""String_Node_Str"" + dloader);
      refSleepTime[0]=qx.getMinPollTime() * 1000 + 1000;
synchronized (this) {
        if (dloaders.size() == 0) {
          setState(REMOTE_QUEUED);
        }
        int oldPos=queuePosition.equals(""String_Node_Str"") ? Integer.MAX_VALUE : Integer.parseInt(queuePosition);
        int newPos=qx.getQueuePosition();
        queuePosition=oldPos < newPos ? ""String_Node_Str"" + oldPos : ""String_Node_Str"" + newPos;
      }
      return 1;
    }
catch (    IOException iox) {
      debug(""String_Node_Str"" + dloader);
      return 0;
    }
 finally {
synchronized (this) {
        addAlternateLocations(dloader.getAlternateLocations(),dloader.getRemoteFileDesc());
      }
      if (updateNeeded)       updateNeeded(dloader);
    }
synchronized (this) {
      setState(DOWNLOADING);
    }
    if (stopped) {
      debug(""String_Node_Str"");
      updateNeeded(dloader);
synchronized (this) {
        files.add(dloader.getRemoteFileDesc());
      }
      return 0;
    }
synchronized (this) {
      dloaders.add(dloader);
      chatList.addHost(dloader);
      browseList.addHost(dloader);
    }
    return 2;
  }
}",0.9597417394606912
4831,"public void testLegacy(){
  String args[]={};
  try {
    testFile=new File(""String_Node_Str"");
    RandomAccessFile raf=new RandomAccessFile(testFile,""String_Node_Str"");
    for (int i=0; i < TestFile.length(); i++)     raf.writeByte(TestFile.getByte(i));
    raf.close();
    testHash=URN.createSHA1Urn(testFile);
  }
 catch (  IOException iox) {
    debug(""String_Node_Str"");
    System.exit(1);
  }
catch (  InterruptedException ignored) {
  }
  try {
    file=new File(""String_Node_Str"");
    file.delete();
    SettingsManager.instance().setSaveDirectory(directory);
    SettingsManager.instance().setConnectionSpeed(1000);
  }
 catch (  IOException e) {
    debug(""String_Node_Str"");
    System.exit(1);
  }
  RouterService rs=new RouterService(null,null,null,null);
  dm.initialize(callback,new MessageRouterStub(),null,new FileManagerStub());
  dm.postGuiInit(rs);
  SimpleTimer timer=new SimpleTimer(true);
  Runnable click=new Runnable(){
    public void run(){
      dm.measureBandwidth();
    }
  }
;
  timer.schedule(click,0,SupernodeAssigner.TIMER_DELAY);
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleDownload();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleSwarm();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUnbalancedSwarm();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSwarmWithInterrupt();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStealerInterrupted();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tAddDownload();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStallingUploaderReplaced();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckGrey(false);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckWhite(false);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tMismatchedVerifyHash(false);
    cleanup();
  }
  callback.delCorrupt=true;
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckGrey(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckWhite(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tMismatchedVerifyHash(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tTwoAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUploaderAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tWeirdAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStealerInterruptedWithAlternate();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tTwoAlternatesButOneWithNoSHA1();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUpdateWhiteWithFailingFirstUploader();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tQueuedDownloader();
    cleanup();
  }
}","public void testLegacy(){
  String args[]={};
  try {
    testFile=new File(""String_Node_Str"");
    RandomAccessFile raf=new RandomAccessFile(testFile,""String_Node_Str"");
    for (int i=0; i < TestFile.length(); i++)     raf.writeByte(TestFile.getByte(i));
    raf.close();
    testHash=URN.createSHA1Urn(testFile);
  }
 catch (  IOException iox) {
    debug(""String_Node_Str"");
    System.exit(1);
  }
catch (  InterruptedException ignored) {
  }
  try {
    file=new File(""String_Node_Str"");
    file.delete();
    SettingsManager.instance().setSaveDirectory(directory);
    SettingsManager.instance().setConnectionSpeed(1000);
  }
 catch (  IOException e) {
    debug(""String_Node_Str"");
    System.exit(1);
  }
  RouterService rs=new RouterService(null,null,null,null);
  dm.initialize(callback,new MessageRouterStub(),null,new FileManagerStub());
  dm.postGuiInit(rs);
  SimpleTimer timer=new SimpleTimer(true);
  Runnable click=new Runnable(){
    public void run(){
      dm.measureBandwidth();
    }
  }
;
  timer.schedule(click,0,SupernodeAssigner.TIMER_DELAY);
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleDownload();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleSwarm();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUnbalancedSwarm();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSwarmWithInterrupt();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStealerInterrupted();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tAddDownload();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStallingUploaderReplaced();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckGrey(false);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckWhite(false);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tMismatchedVerifyHash(false);
    cleanup();
  }
  callback.delCorrupt=true;
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckGrey(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckWhite(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tMismatchedVerifyHash(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tTwoAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUploaderAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tWeirdAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStealerInterruptedWithAlternate();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUpdateWhiteWithFailingFirstUploader();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tQueuedDownloader();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tAlternateLocationsExchangedWithBusy();
    cleanup();
  }
}",0.9269419578400232
4832,"private void send(OutputStream out,int start,int stop) throws IOException {
  long t0=System.currentTimeMillis();
  if (minPollTime > 0)   Assert.that(t0 > minPollTime,""String_Node_Str"" + (minPollTime - t0) + ""String_Node_Str"");
  if (maxPollTime > 0)   Assert.that(t0 < maxPollTime,""String_Node_Str"" + (t0 - maxPollTime) + ""String_Node_Str"");
  String str=busy | queue ? ""String_Node_Str"" : ""String_Node_Str"";
  out.write(str.getBytes());
  if (busy) {
    String s=""String_Node_Str"";
    out.write(s.getBytes());
    out.flush();
    out.close();
    return;
  }
  if (queue) {
    String s=""String_Node_Str"";
    out.write(s.getBytes());
    s=""String_Node_Str"";
    out.write(s.getBytes());
    out.flush();
    long t=System.currentTimeMillis();
    minPollTime=t + MIN_POLL;
    maxPollTime=t + MAX_POLL;
    return;
  }
  str=""String_Node_Str"" + (stop - start) + ""String_Node_Str"";
  out.write(str.getBytes());
  if (start != 0) {
    str=""String_Node_Str"" + start + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str""+ TestFile.length()+ ""String_Node_Str"";
    out.write(str.getBytes());
  }
  if (storedAltLocs.hasAlternateLocations())   HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,storedAltLocs,out);
  str=""String_Node_Str"";
  out.write(str.getBytes());
  out.flush();
  for (int i=start; i < stop; ) {
    long startTime=System.currentTimeMillis();
    for (int j=0; j < Math.max(1,(rate * 1024)) && i < stop; j++) {
      if (stopAfter > -1 && totalUploaded >= stopAfter) {
        stopped=true;
        out.flush();
        throw new IOException();
      }
      if (sendCorrupt)       out.write(TestFile.getByte(i) + (byte)1);
 else       out.write(TestFile.getByte(i));
      totalUploaded++;
      i++;
    }
    long elapsed=System.currentTimeMillis() - startTime;
    long wait=1000 - elapsed;
    if (wait > 0)     try {
      Thread.sleep(wait);
    }
 catch (    InterruptedException e) {
    }
  }
  out.flush();
}","private void send(OutputStream out,int start,int stop) throws IOException {
  long t0=System.currentTimeMillis();
  if (minPollTime > 0)   Assert.that(t0 > minPollTime,""String_Node_Str"" + (minPollTime - t0) + ""String_Node_Str"");
  if (maxPollTime > 0)   Assert.that(t0 < maxPollTime,""String_Node_Str"" + (t0 - maxPollTime) + ""String_Node_Str"");
  String str=busy | queue ? ""String_Node_Str"" : ""String_Node_Str"";
  out.write(str.getBytes());
  if (queue) {
    String s=""String_Node_Str"";
    out.write(s.getBytes());
    s=""String_Node_Str"";
    out.write(s.getBytes());
    out.flush();
    long t=System.currentTimeMillis();
    minPollTime=t + MIN_POLL;
    maxPollTime=t + MAX_POLL;
    return;
  }
  str=""String_Node_Str"" + (stop - start) + ""String_Node_Str"";
  out.write(str.getBytes());
  if (start != 0) {
    str=""String_Node_Str"" + start + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str""+ TestFile.length()+ ""String_Node_Str"";
    out.write(str.getBytes());
  }
  if (storedAltLocs.hasAlternateLocations())   HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,storedAltLocs,out);
  str=""String_Node_Str"";
  out.write(str.getBytes());
  out.flush();
  if (busy) {
    out.close();
    return;
  }
  for (int i=start; i < stop; ) {
    long startTime=System.currentTimeMillis();
    for (int j=0; j < Math.max(1,(rate * 1024)) && i < stop; j++) {
      if (stopAfter > -1 && totalUploaded >= stopAfter) {
        stopped=true;
        out.flush();
        throw new IOException();
      }
      if (sendCorrupt)       out.write(TestFile.getByte(i) + (byte)1);
 else       out.write(TestFile.getByte(i));
      totalUploaded++;
      i++;
    }
    long elapsed=System.currentTimeMillis() - startTime;
    long wait=1000 - elapsed;
    if (wait > 0)     try {
      Thread.sleep(wait);
    }
 catch (    InterruptedException e) {
    }
  }
  out.flush();
}",0.9547606522882692
4833,"/** 
 * Returns the <tt>UrnCache</tt> instance.
 * @return the <tt>UrnCache</tt> instance
 */
public static UrnCache instance(){
  if (instance == null) {
    instance=new UrnCache();
  }
  return instance;
}","/** 
 * Returns the <tt>UrnCache</tt> instance.
 * @return the <tt>UrnCache</tt> instance
 */
public static synchronized UrnCache instance(){
  if (instance == null) {
    instance=new UrnCache();
  }
  return instance;
}",0.9696969696969696
4834,"/** 
 * Write cache so that we only have to calculate them once.
 */
public void persistCache(){
  try {
    ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(URN_CACHE_FILE));
    oos.writeObject(URN_MAP);
    oos.close();
  }
 catch (  Exception e) {
  }
}","/** 
 * Write cache so that we only have to calculate them once.
 */
public synchronized void persistCache(){
  try {
    ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(URN_CACHE_FILE));
    oos.writeObject(URN_MAP);
    oos.close();
  }
 catch (  Exception e) {
  }
}",0.9769094138543516
4835,"/** 
 * Find any URNs remembered from a previous session for the specified <tt>File</tt> instance.  The returned <tt>Set</tt> is guaranteed to be non-null, but it may be empty.
 * @param file the <tt>File</tt> instance to look up URNs for
 * @return a new <tt>Set</tt> containing any cached URNs for thespeficied <tt>File</tt> instance, guaranteed to be non-null and  unmodifiable, but possibly empty
 */
public Set getUrns(File file){
  if (file.lastModified() == 0L) {
    return EMPTY_SET;
  }
  UrnSetKey key=new UrnSetKey(file);
  Set cachedUrns=(Set)URN_MAP.get(key);
  if (cachedUrns == null) {
    return EMPTY_SET;
  }
  return Collections.unmodifiableSet(cachedUrns);
}","/** 
 * Find any URNs remembered from a previous session for the specified <tt>File</tt> instance.  The returned <tt>Set</tt> is guaranteed to be non-null, but it may be empty.
 * @param file the <tt>File</tt> instance to look up URNs for
 * @return a new <tt>Set</tt> containing any cached URNs for thespeficied <tt>File</tt> instance, guaranteed to be non-null and  unmodifiable, but possibly empty
 */
public synchronized Set getUrns(File file){
  if (file.lastModified() == 0L) {
    return EMPTY_SET;
  }
  UrnSetKey key=new UrnSetKey(file);
  Set cachedUrns=(Set)URN_MAP.get(key);
  if (cachedUrns == null) {
    return EMPTY_SET;
  }
  return Collections.unmodifiableSet(cachedUrns);
}",0.9905178701677608
4836,"private boolean readQueueVersion(String str){
  if (indexOfIgnoreCase(str,""String_Node_Str"") == -1)   return false;
  String s=HTTPUtils.extractHeaderValue(str);
  float version=Float.parseFloat(s);
  if (version > 0)   _supportsQueueing=true;
  return true;
}","private boolean readQueueVersion(String str){
  if (indexOfIgnoreCase(str,""String_Node_Str"") == -1)   return false;
  String s=HTTPUtils.extractHeaderValue(str);
  float version=(new Float(s)).floatValue();
  if (version > 0)   _supportsQueueing=true;
  return true;
}",0.9393939393939394
4837,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(UploadTest.suite());
  return suite;
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(UploadTest.suite());
  suite.addTest(UploaderTest.suite());
  return suite;
}",0.8729641693811075
4838,"static File createNewTestFile(int size){
  try {
    File file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    OutputStream out=new FileOutputStream(file);
    out.write(new byte[size]);
    out.flush();
    out.close();
    return FileManager.getCanonicalFile(file);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
    System.exit(1);
    return null;
  }
}","File createNewTestFile(int size){
  try {
    File file=File.createTempFile(""String_Node_Str"",""String_Node_Str"",directory);
    OutputStream out=new FileOutputStream(file);
    out.write(new byte[size]);
    out.flush();
    out.close();
    return FileManager.getCanonicalFile(file);
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
    System.exit(1);
    return null;
  }
}",0.9798816568047336
4839,"/** 
 * Same a createNewTestFile but doesn't actually allocate the requested number of bytes on disk.  Instead returns a subclass of File. 
 */
static File createFakeTestFile(long size){
  File real=createNewTestFile(1);
  return new HugeFakeFile(real.getParentFile(),real.getName(),size);
}","/** 
 * Same a createNewTestFile but doesn't actually allocate the requested number of bytes on disk.  Instead returns a subclass of File. 
 */
File createFakeTestFile(long size){
  File real=createNewTestFile(1);
  return new HugeFakeFile(real.getParentFile(),real.getName(),size);
}",0.9878260869565216
4840,"/** 
 * Unit test.  REQUIRES JAVA2 FOR createTempFile Note that many tests are STRONGER than required by the specifications for simplicity.  For example, we assume an order on the values returned by getSharedFiles. 
 */
public void testLegacy(){
  File f1=null;
  File f2=null;
  File f3=null;
  File f4=null;
  File f5=null;
  File f6=null;
  try {
    f1=createNewTestFile(1);
    File directory=FileManager.getParentFile(f1);
    FileManager fman=new FileManager();
    File[] files=fman.getSharedFiles(directory);
    assertTrue(files == null);
    SettingsManager settings=SettingsManager.instance();
    settings.setExtensions(""String_Node_Str"");
    settings.setDirectories(new File[]{directory});
    fman.loadSettings(false);
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    f2=createNewTestFile(3);
    f3=createNewTestFile(11);
    assertTrue(fman.getNumFiles() + ""String_Node_Str"",fman.getNumFiles() == 1);
    assertTrue(fman.getSize() + ""String_Node_Str"",fman.getSize() == 1);
    Response[] responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(responses.length == 1);
    assertTrue(fman.removeFileIfShared(f3) == false);
    responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(responses.length == 1);
    assertTrue(fman.getSize() == 1);
    assertTrue(fman.getNumFiles() == 1);
    fman.get(0);
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 1);
    assertTrue(files[0] + ""String_Node_Str"" + f1,files[0].equals(f1));
    files=fman.getSharedFiles(FileManager.getParentFile(directory));
    assertTrue(files == null);
    assertTrue(fman.addFileIfShared(new File(""String_Node_Str"")) == false);
    assertTrue(fman.addFileIfShared(f2) == true);
    assertTrue(fman.getNumFiles() + ""String_Node_Str"",fman.getNumFiles() == 2);
    assertTrue(fman.getSize() + ""String_Node_Str"",fman.getSize() == 4);
    responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(responses[0].getIndex() != responses[1].getIndex());
    for (int i=0; i < responses.length; i++) {
      assertTrue(responses[i].getIndex() == 0 || responses[i].getIndex() == 1);
    }
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 2);
    assertTrue(files[0] + ""String_Node_Str"" + f1,files[0].equals(f1));
    assertTrue(files[1] + ""String_Node_Str"" + f2,files[1].equals(f2));
    assertTrue(fman.removeFileIfShared(f3) == false);
    assertTrue(fman.removeFileIfShared(f2) == true);
    assertTrue(fman.getSize() == 1);
    assertTrue(fman.getNumFiles() == 1);
    responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(responses.length == 1);
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 1);
    assertTrue(files[0] + ""String_Node_Str"" + f1,files[0].equals(f1));
    assertTrue(fman.addFileIfShared(f3) == true);
    assertTrue(""String_Node_Str"" + fman.getSize(),fman.getSize() == 12);
    assertTrue(""String_Node_Str"" + fman.getNumFiles(),fman.getNumFiles() == 2);
    responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(""String_Node_Str"" + responses.length,responses.length == 2);
    assertTrue(responses[0].getIndex() != 1);
    assertTrue(responses[1].getIndex() != 1);
    fman.get(0);
    fman.get(2);
    try {
      fman.get(1);
      assertTrue(false);
    }
 catch (    IndexOutOfBoundsException e) {
    }
    responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(""String_Node_Str"" + responses.length,responses.length == 2);
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 2);
    assertTrue(files[0] + ""String_Node_Str"" + f1,files[0].equals(f1));
    assertTrue(files[1] + ""String_Node_Str"" + f3,files[1].equals(f3));
    files=fman.getSharedFiles(null);
    assertTrue(files.length == 2);
    assertTrue(files[0] + ""String_Node_Str"" + f1,files[0].equals(f1));
    assertTrue(files[1] + ""String_Node_Str"" + f3,files[1].equals(f3));
    assertTrue(fman.renameFileIfShared(f2,f2) == false);
    assertTrue(fman.renameFileIfShared(f1,f2) == true);
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 2);
    assertTrue(files[0].equals(f3));
    assertTrue(files[1].equals(f2));
    assertTrue(fman.renameFileIfShared(f2,new File(""String_Node_Str"")) == false);
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 1);
    assertTrue(files[0].equals(f3));
    f4=createFakeTestFile(Integer.MAX_VALUE + 1l);
    assertTrue(fman.addFileIfShared(f4) == false);
    assertTrue(fman.getNumFiles() == 1);
    assertTrue(fman.getSize() == 11);
    f5=createFakeTestFile(Integer.MAX_VALUE - 1);
    f6=createFakeTestFile(Integer.MAX_VALUE);
    assertTrue(fman.addFileIfShared(f5) == true);
    assertTrue(fman.addFileIfShared(f6) == true);
    assertTrue(fman.getNumFiles() == 3);
    assertTrue(fman.getSize() == Integer.MAX_VALUE);
    responses=fman.query(new QueryRequest((byte)3,(byte)0,""String_Node_Str""));
    assertTrue(responses.length == 3);
    assertTrue(responses[0].getName().equals(f3.getName()));
    assertTrue(responses[1].getName().equals(f5.getName()));
    assertTrue(responses[2].getName().equals(f6.getName()));
  }
  finally {
    if (f1 != null)     f1.delete();
    if (f2 != null)     f2.delete();
    if (f3 != null)     f3.delete();
    if (f4 != null)     f4.delete();
    if (f5 != null)     f5.delete();
    if (f6 != null)     f6.delete();
  }
}","/** 
 * Unit test.  REQUIRES JAVA2 FOR createTempFile Note that many tests are STRONGER than required by the specifications for simplicity.  For example, we assume an order on the values returned by getSharedFiles. 
 */
public void testLegacy(){
  File f1=null;
  File f2=null;
  File f3=null;
  File f4=null;
  File f5=null;
  File f6=null;
  try {
    f1=createNewTestFile(1);
    File directory=FileManager.getParentFile(f1);
    FileManager fman=new FileManager();
    File[] files=fman.getSharedFiles(directory);
    assertTrue(files == null);
    SettingsManager settings=SettingsManager.instance();
    settings.setExtensions(""String_Node_Str"");
    settings.setDirectories(new File[]{directory});
    fman.loadSettings(false);
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
    f2=createNewTestFile(3);
    f3=createNewTestFile(11);
    assertEquals(1,fman.getNumFiles());
    assertTrue(fman.getSize() + ""String_Node_Str"",fman.getSize() == 1);
    Response[] responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(responses.length == 1);
    assertTrue(fman.removeFileIfShared(f3) == false);
    responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(responses.length == 1);
    assertTrue(fman.getSize() == 1);
    assertTrue(fman.getNumFiles() == 1);
    fman.get(0);
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 1);
    assertTrue(files[0] + ""String_Node_Str"" + f1,files[0].equals(f1));
    files=fman.getSharedFiles(FileManager.getParentFile(directory));
    assertTrue(files == null);
    assertTrue(fman.addFileIfShared(new File(""String_Node_Str"")) == false);
    assertTrue(fman.addFileIfShared(f2) == true);
    assertTrue(fman.getNumFiles() + ""String_Node_Str"",fman.getNumFiles() == 2);
    assertTrue(fman.getSize() + ""String_Node_Str"",fman.getSize() == 4);
    responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(responses[0].getIndex() != responses[1].getIndex());
    for (int i=0; i < responses.length; i++) {
      assertTrue(responses[i].getIndex() == 0 || responses[i].getIndex() == 1);
    }
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 2);
    assertTrue(files[0] + ""String_Node_Str"" + f1,files[0].equals(f1));
    assertTrue(files[1] + ""String_Node_Str"" + f2,files[1].equals(f2));
    assertTrue(fman.removeFileIfShared(f3) == false);
    assertTrue(fman.removeFileIfShared(f2) == true);
    assertTrue(fman.getSize() == 1);
    assertTrue(fman.getNumFiles() == 1);
    responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(responses.length == 1);
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 1);
    assertTrue(files[0] + ""String_Node_Str"" + f1,files[0].equals(f1));
    assertTrue(fman.addFileIfShared(f3) == true);
    assertTrue(""String_Node_Str"" + fman.getSize(),fman.getSize() == 12);
    assertTrue(""String_Node_Str"" + fman.getNumFiles(),fman.getNumFiles() == 2);
    responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(""String_Node_Str"" + responses.length,responses.length == 2);
    assertTrue(responses[0].getIndex() != 1);
    assertTrue(responses[1].getIndex() != 1);
    fman.get(0);
    fman.get(2);
    try {
      fman.get(1);
      assertTrue(false);
    }
 catch (    IndexOutOfBoundsException e) {
    }
    responses=fman.query(new QueryRequest((byte)3,0,""String_Node_Str""));
    assertTrue(""String_Node_Str"" + responses.length,responses.length == 2);
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 2);
    assertTrue(files[0] + ""String_Node_Str"" + f1,files[0].equals(f1));
    assertTrue(files[1] + ""String_Node_Str"" + f3,files[1].equals(f3));
    files=fman.getSharedFiles(null);
    assertTrue(files.length == 2);
    assertTrue(files[0] + ""String_Node_Str"" + f1,files[0].equals(f1));
    assertTrue(files[1] + ""String_Node_Str"" + f3,files[1].equals(f3));
    assertTrue(fman.renameFileIfShared(f2,f2) == false);
    assertTrue(fman.renameFileIfShared(f1,f2) == true);
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 2);
    assertTrue(files[0].equals(f3));
    assertTrue(files[1].equals(f2));
    assertTrue(fman.renameFileIfShared(f2,new File(""String_Node_Str"")) == false);
    files=fman.getSharedFiles(directory);
    assertTrue(files.length == 1);
    assertTrue(files[0].equals(f3));
    f4=createFakeTestFile(Integer.MAX_VALUE + 1l);
    assertTrue(fman.addFileIfShared(f4) == false);
    assertTrue(fman.getNumFiles() == 1);
    assertTrue(fman.getSize() == 11);
    f5=createFakeTestFile(Integer.MAX_VALUE - 1);
    f6=createFakeTestFile(Integer.MAX_VALUE);
    assertTrue(fman.addFileIfShared(f5) == true);
    assertTrue(fman.addFileIfShared(f6) == true);
    assertTrue(fman.getNumFiles() == 3);
    assertTrue(fman.getSize() == Integer.MAX_VALUE);
    responses=fman.query(new QueryRequest((byte)3,(byte)0,""String_Node_Str""));
    assertTrue(responses.length == 3);
    assertTrue(responses[0].getName().equals(f3.getName()));
    assertTrue(responses[1].getName().equals(f5.getName()));
    assertTrue(responses[2].getName().equals(f6.getName()));
  }
  finally {
    if (f1 != null)     f1.delete();
    if (f2 != null)     f2.delete();
    if (f3 != null)     f3.delete();
    if (f4 != null)     f4.delete();
    if (f5 != null)     f5.delete();
    if (f6 != null)     f6.delete();
  }
}",0.9947311046511628
4841,"/** 
 * Parses out the timestamp string from the alternate location header string, throwing an exception if there is any error.
 * @param location the full alternate-location HTTP header string,as specified in HUGE v0.93
 * @return the date/time string from the the alternate locationheader, or <tt>null</tt> if the date/time string could not be extracted, is invalid, or does not exist
 */
private static String extractTimestamp(final String location){
  StringTokenizer st=new StringTokenizer(location);
  int numToks=st.countTokens();
  if (numToks != 2 && numToks != 3) {
    return null;
  }
 else {
    String curTok=null;
    for (int i=0; i < numToks; i++) {
      curTok=st.nextToken();
    }
    if (AlternateLocation.isValidTimestamp(curTok)) {
      return curTok;
    }
 else {
      return null;
    }
  }
}","/** 
 * Parses out the timestamp string from the alternate location header string, throwing an exception if there is any error.
 * @param location the full alternate-location HTTP header string,as specified in HUGE v0.93
 * @return the date/time string from the the alternate locationheader, or <tt>null</tt> if the date/time string could not be extracted, is invalid, or does not exist
 */
private static String extractTimestamp(final String location){
  StringTokenizer st=new StringTokenizer(location);
  int numToks=st.countTokens();
  String curTok=null;
  for (int i=0; i < numToks; i++) {
    curTok=st.nextToken();
  }
  if (AlternateLocation.isValidTimestamp(curTok)) {
    return curTok;
  }
 else {
    return null;
  }
}",0.9259497746297488
4842,"/** 
 * Removes the timestamp from an alternate location header.  This will remove the timestamp from an alternate location header string that  includes the header name, or from an alternate location string that only contains the alternate location header value.
 * @param locationHeader the string containing the full header, or onlythe header value
 * @return the same string as supplied in the <tt>locationHeader</tt> argument, but with the timestamp removed
 */
private static String removeTimestamp(final String locationHeader){
  StringTokenizer st=new StringTokenizer(locationHeader);
  int numToks=st.countTokens();
  if (numToks == 1 || numToks == 2 || numToks == 3) {
    return st.nextToken();
  }
 else {
    return null;
  }
}","/** 
 * Removes the timestamp from an alternate location header.  This will remove the timestamp from an alternate location header string that  includes the header name, or from an alternate location string that only contains the alternate location header value.
 * @param locationHeader the string containing the full header, or onlythe header value
 * @return the same string as supplied in the <tt>locationHeader</tt> argument, but with the timestamp removed
 */
private static String removeTimestamp(final String locationHeader){
  StringTokenizer st=new StringTokenizer(locationHeader);
  int numToks=st.countTokens();
  if (numToks == 1) {
    return locationHeader;
  }
  String curTok=null;
  for (int i=0; i < numToks; i++) {
    curTok=st.nextToken();
  }
  int tsIndex=locationHeader.indexOf(curTok);
  if (tsIndex == -1)   return null;
  return locationHeader.substring(0,tsIndex);
}",0.8310893512851897
4843,"/** 
 * Throttles the uploads by sleeping periodically
 * @exception IOException If there is any I/O problem while uploading file
 */
private void uploadThrottled(OutputStream ostream) throws IOException {
  while (true) {
    int max=_uploader.getManager().calculateBandwidth();
    int burstSize=max * CYCLE_TIME;
    int c=-1;
    byte[] buf=new byte[1024];
    int burstSent=0;
    long start=System.currentTimeMillis();
    while (burstSent < burstSize) {
      c=_fis.read(buf);
      if (c == -1)       return;
      if (c > (_uploadEnd - _amountRead))       c=_uploadEnd - _amountRead;
      try {
        ostream.write(buf,0,c);
      }
 catch (      java.net.SocketException e) {
        throw new IOException();
      }
      _amountRead+=c;
      _uploader.setAmountUploaded(_amountRead);
      burstSent+=c;
      if (_amountRead >= _uploadEnd)       break;
    }
    long stop=System.currentTimeMillis();
    int elapsed=(int)(stop - start);
    int sleepTime=CYCLE_TIME - elapsed;
    if (sleepTime > 0) {
      try {
        Thread.currentThread().sleep(sleepTime);
      }
 catch (      InterruptedException e) {
        throw new IOException();
      }
    }
  }
}","/** 
 * Throttles the uploads by sleeping periodically
 * @exception IOException If there is any I/O problem while uploading file
 */
private void uploadThrottled(OutputStream ostream) throws IOException {
  while (true) {
    int max=_uploader.getManager().calculateBandwidth();
    int burstSize=max * CYCLE_TIME;
    int c=-1;
    byte[] buf=new byte[1024];
    int burstSent=0;
    long start=System.currentTimeMillis();
    while (burstSent < burstSize) {
      c=_fis.read(buf);
      if (c == -1)       return;
      if (c > (_uploadEnd - _amountRead))       c=_uploadEnd - _amountRead;
      try {
        ostream.write(buf,0,c);
      }
 catch (      java.net.SocketException e) {
        throw new IOException();
      }
      _amountRead+=c;
      _uploader.setAmountUploaded(_amountRead);
      burstSent+=c;
      if (_amountRead >= _uploadEnd)       return;
    }
    long stop=System.currentTimeMillis();
    int elapsed=(int)(stop - start);
    int sleepTime=CYCLE_TIME - elapsed;
    if (sleepTime > 0) {
      try {
        Thread.currentThread().sleep(sleepTime);
      }
 catch (      InterruptedException e) {
        throw new IOException();
      }
    }
  }
}",0.9953488372093025
4844,"public void writeMessageHeaders(OutputStream ostream) throws IOException {
  String str;
  str=""String_Node_Str"";
  ostream.write(str.getBytes());
  str=""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"";
  ostream.write(str.getBytes());
  str=""String_Node_Str"";
  ostream.write(str.getBytes());
  str=""String_Node_Str"" + ERROR_MESSAGE.length + ""String_Node_Str"";
  ostream.write(str.getBytes());
  if (FILE_DESC != null) {
    HTTPUtils.writeHeader(HTTPHeaderName.CONTENT_URN,FILE_DESC.getSHA1Urn(),ostream);
    if (FILE_DESC.hasAlternateLocations()) {
      HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,FILE_DESC.getAlternateLocationCollection(),ostream);
    }
  }
  str=""String_Node_Str"";
  ostream.write(str.getBytes());
}","public void writeMessageHeaders(OutputStream ostream) throws IOException {
  String str;
  str=""String_Node_Str"";
  ostream.write(str.getBytes());
  str=""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"";
  ostream.write(str.getBytes());
  str=""String_Node_Str"";
  ostream.write(str.getBytes());
  str=""String_Node_Str"" + ERROR_MESSAGE.length + ""String_Node_Str"";
  ostream.write(str.getBytes());
  if (FILE_DESC != null) {
    URN sha1=FILE_DESC.getSHA1Urn();
    if (sha1 != null) {
      HTTPUtils.writeHeader(HTTPHeaderName.CONTENT_URN,sha1,ostream);
    }
    if (FILE_DESC.hasAlternateLocations()) {
      HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,FILE_DESC.getAlternateLocationCollection(),ostream);
    }
  }
  str=""String_Node_Str"";
  ostream.write(str.getBytes());
}",0.7943262411347518
4845,"/** 
 * Reads the HTTP header sent by the requesting client -- note that the 'GET' portion of the request header has already been read.
 * @throws <tt>IOException</tt> if there are any io issues while readingthe header
 */
private void readHeader() throws IOException {
  _uploadBegin=0;
  _uploadEnd=0;
  String userAgent;
  _clientAcceptsXGnutellaQueryreplies=false;
  ByteReader br=new ByteReader(_socket.getInputStream());
  while (true) {
    String str=br.readLine();
    debug(""String_Node_Str"" + str);
    if ((str == null) || (str.equals(""String_Node_Str"")))     break;
 else     if (str.toUpperCase().indexOf(""String_Node_Str"") != -1) {
      String sub;
      try {
        sub=str.substring(5);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new IOException();
      }
      sub=sub.trim();
      int colon=sub.indexOf(""String_Node_Str"");
      String host=sub.substring(0,colon);
      host=host.trim();
      String sport=sub.substring(colon + 1);
      sport=sport.trim();
      int port;
      try {
        port=java.lang.Integer.parseInt(sport);
      }
 catch (      NumberFormatException e) {
        throw new IOException();
      }
      _chatEnabled=true;
      _chatHost=host;
      _chatPort=port;
    }
 else     if (indexOfIgnoreCase(str,""String_Node_Str"") == 0) {
      String sub;
      String second;
      try {
        int i=str.indexOf(""String_Node_Str"");
        if (i < 0)         throw new IOException();
        i+=6;
        sub=str.substring(i);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new IOException();
      }
      sub=sub.trim();
      char c;
      try {
        c=sub.charAt(0);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new IOException();
      }
      if (c == '-') {
        try {
          second=sub.substring(1);
        }
 catch (        IndexOutOfBoundsException e) {
          throw new IOException();
        }
        second=second.trim();
        try {
          _uploadBegin=Math.max(0,_fileSize - Integer.parseInt(second));
          _uploadEnd=_fileSize;
        }
 catch (        NumberFormatException e) {
          throw new IOException();
        }
      }
 else {
        int dash=sub.indexOf(""String_Node_Str"");
        String first;
        try {
          first=sub.substring(0,dash);
        }
 catch (        IndexOutOfBoundsException e) {
          throw new IOException();
        }
        first=first.trim();
        try {
          _uploadBegin=java.lang.Integer.parseInt(first);
        }
 catch (        NumberFormatException e) {
          throw new IOException();
        }
        try {
          second=sub.substring(dash + 1);
        }
 catch (        IndexOutOfBoundsException e) {
          throw new IOException();
        }
        second=second.trim();
        if (!second.equals(""String_Node_Str""))         try {
          _uploadEnd=java.lang.Integer.parseInt(second) + 1;
        }
 catch (        NumberFormatException e) {
          throw new IOException();
        }
      }
    }
 else     if (indexOfIgnoreCase(str,""String_Node_Str"") != -1) {
      if (SettingsManager.instance().getAllowBrowser() == false && !(_stateNum == BROWSE_HOST) && !(_fileName.toUpperCase().startsWith(""String_Node_Str""))) {
        if ((str.indexOf(""String_Node_Str"") != -1) || (str.indexOf(""String_Node_Str"") != -1) || (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)) {
          throw new FreeloaderUploadingException();
        }
      }
      userAgent=str.substring(11).trim();
    }
 else     if (HTTPHeaderName.CONTENT_URN.matchesStartOfString(str)) {
      URN requestedURN=HTTPUploader.readContentUrn(str);
      if (requestedURN == null) {
        setState(FILE_NOT_FOUND);
      }
      if (_fileDesc != null) {
        if (!_fileDesc.equals(_fileManager.getFileDescForUrn(requestedURN))) {
          setState(FILE_NOT_FOUND);
        }
      }
    }
 else     if (HTTPHeaderName.ALT_LOCATION.matchesStartOfString(str)) {
      if (_alternateLocationCollection == null) {
        _alternateLocationCollection=new AlternateLocationCollection();
      }
      HTTPUploader.readAlternateLocations(str,_alternateLocationCollection);
    }
    if (indexOfIgnoreCase(str,""String_Node_Str"") != -1) {
      if (indexOfIgnoreCase(str,Constants.QUERYREPLY_MIME_TYPE) != -1) {
        _clientAcceptsXGnutellaQueryreplies=true;
      }
    }
  }
  if (_uploadEnd == 0)   _uploadEnd=_fileSize;
}","/** 
 * Reads the HTTP header sent by the requesting client -- note that the 'GET' portion of the request header has already been read.
 * @throws <tt>IOException</tt> if there are any io issues while readingthe header
 */
private void readHeader() throws IOException {
  _uploadBegin=0;
  _uploadEnd=0;
  String userAgent;
  _clientAcceptsXGnutellaQueryreplies=false;
  ByteReader br=new ByteReader(_socket.getInputStream());
  while (true) {
    String str=br.readLine();
    debug(""String_Node_Str"" + str);
    if ((str == null) || (str.equals(""String_Node_Str"")))     break;
 else     if (str.toUpperCase().indexOf(""String_Node_Str"") != -1) {
      String sub;
      try {
        sub=str.substring(5);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new IOException();
      }
      sub=sub.trim();
      int colon=sub.indexOf(""String_Node_Str"");
      String host=sub.substring(0,colon);
      host=host.trim();
      String sport=sub.substring(colon + 1);
      sport=sport.trim();
      int port;
      try {
        port=java.lang.Integer.parseInt(sport);
      }
 catch (      NumberFormatException e) {
        throw new IOException();
      }
      _chatEnabled=true;
      _chatHost=host;
      _chatPort=port;
    }
 else     if (indexOfIgnoreCase(str,""String_Node_Str"") == 0) {
      String sub;
      String second;
      try {
        int i=str.indexOf(""String_Node_Str"");
        if (i < 0)         throw new IOException();
        i+=6;
        sub=str.substring(i);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new IOException();
      }
      sub=sub.trim();
      char c;
      try {
        c=sub.charAt(0);
      }
 catch (      IndexOutOfBoundsException e) {
        throw new IOException();
      }
      if (c == '-') {
        try {
          second=sub.substring(1);
        }
 catch (        IndexOutOfBoundsException e) {
          throw new IOException();
        }
        second=second.trim();
        try {
          _uploadBegin=Math.max(0,_fileSize - Integer.parseInt(second));
          _uploadEnd=_fileSize;
        }
 catch (        NumberFormatException e) {
          throw new IOException();
        }
      }
 else {
        int dash=sub.indexOf(""String_Node_Str"");
        String first;
        try {
          first=sub.substring(0,dash);
        }
 catch (        IndexOutOfBoundsException e) {
          throw new IOException();
        }
        first=first.trim();
        try {
          _uploadBegin=java.lang.Integer.parseInt(first);
        }
 catch (        NumberFormatException e) {
          throw new IOException();
        }
        try {
          second=sub.substring(dash + 1);
        }
 catch (        IndexOutOfBoundsException e) {
          throw new IOException();
        }
        second=second.trim();
        if (!second.equals(""String_Node_Str""))         try {
          _uploadEnd=java.lang.Integer.parseInt(second) + 1;
        }
 catch (        NumberFormatException e) {
          throw new IOException();
        }
      }
    }
 else     if (indexOfIgnoreCase(str,""String_Node_Str"") != -1) {
      if (SettingsManager.instance().getAllowBrowser() == false && !(_stateNum == BROWSE_HOST) && !(_fileName.toUpperCase().startsWith(""String_Node_Str""))) {
        if ((str.indexOf(""String_Node_Str"") != -1) || (str.indexOf(""String_Node_Str"") != -1) || (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)|| (str.indexOf(""String_Node_Str"") != -1)) {
          throw new FreeloaderUploadingException();
        }
      }
      userAgent=str.substring(11).trim();
    }
 else     if (HTTPHeaderName.CONTENT_URN.matchesStartOfString(str)) {
      URN requestedURN=HTTPUploader.readContentUrn(str);
      if (requestedURN == null) {
        setState(FILE_NOT_FOUND);
      }
      if (_fileDesc != null) {
        if (!_fileDesc.containsUrn(requestedURN)) {
          setState(FILE_NOT_FOUND);
        }
      }
    }
 else     if (HTTPHeaderName.ALT_LOCATION.matchesStartOfString(str)) {
      if (_alternateLocationCollection == null) {
        _alternateLocationCollection=new AlternateLocationCollection();
      }
      HTTPUploader.readAlternateLocations(str,_alternateLocationCollection);
    }
    if (indexOfIgnoreCase(str,""String_Node_Str"") != -1) {
      if (indexOfIgnoreCase(str,Constants.QUERYREPLY_MIME_TYPE) != -1) {
        _clientAcceptsXGnutellaQueryreplies=true;
      }
    }
  }
  if (_uploadEnd == 0)   _uploadEnd=_fileSize;
}",0.99569181444745
4846,"/** 
 * Takes a short and returns the corresponding genre string
 */
private String getGenreString(short genre){
switch (genre) {
case 0:
    return ""String_Node_Str"";
case 1:
  return ""String_Node_Str"";
case 2:
return ""String_Node_Str"";
case 3:
return ""String_Node_Str"";
case 4:
return ""String_Node_Str"";
case 5:
return ""String_Node_Str"";
case 6:
return ""String_Node_Str"";
case 7:
return ""String_Node_Str"";
case 8:
return ""String_Node_Str"";
case 9:
return ""String_Node_Str"";
case 10:
return ""String_Node_Str"";
case 11:
return ""String_Node_Str"";
case 12:
return ""String_Node_Str"";
case 13:
return ""String_Node_Str"";
case 14:
return ""String_Node_Str"";
case 15:
return ""String_Node_Str"";
case 16:
return ""String_Node_Str"";
case 17:
return ""String_Node_Str"";
case 18:
return ""String_Node_Str"";
case 19:
return ""String_Node_Str"";
case 20:
return ""String_Node_Str"";
case 21:
return ""String_Node_Str"";
case 22:
return ""String_Node_Str"";
case 23:
return ""String_Node_Str"";
case 24:
return ""String_Node_Str"";
case 25:
return ""String_Node_Str"";
case 26:
return ""String_Node_Str"";
case 27:
return ""String_Node_Str"";
case 28:
return ""String_Node_Str"";
case 29:
return ""String_Node_Str"";
case 30:
return ""String_Node_Str"";
case 31:
return ""String_Node_Str"";
case 32:
return ""String_Node_Str"";
case 33:
return ""String_Node_Str"";
case 34:
return ""String_Node_Str"";
case 35:
return ""String_Node_Str"";
case 36:
return ""String_Node_Str"";
case 37:
return ""String_Node_Str"";
case 38:
return ""String_Node_Str"";
case 39:
return ""String_Node_Str"";
case 40:
return ""String_Node_Str"";
case 41:
return ""String_Node_Str"";
case 42:
return ""String_Node_Str"";
case 43:
return ""String_Node_Str"";
case 44:
return ""String_Node_Str"";
case 45:
return ""String_Node_Str"";
case 46:
return ""String_Node_Str"";
case 47:
return ""String_Node_Str"";
case 48:
return ""String_Node_Str"";
case 49:
return ""String_Node_Str"";
case 50:
return ""String_Node_Str"";
case 51:
return ""String_Node_Str"";
case 52:
return ""String_Node_Str"";
case 53:
return ""String_Node_Str"";
case 54:
return ""String_Node_Str"";
case 55:
return ""String_Node_Str"";
case 56:
return ""String_Node_Str"";
case 57:
return ""String_Node_Str"";
case 58:
return ""String_Node_Str"";
case 59:
return ""String_Node_Str"";
case 60:
return ""String_Node_Str"";
case 61:
return ""String_Node_Str"";
case 62:
return ""String_Node_Str"";
case 63:
return ""String_Node_Str"";
case 64:
return ""String_Node_Str"";
case 65:
return ""String_Node_Str"";
case 66:
return ""String_Node_Str"";
case 67:
return ""String_Node_Str"";
case 68:
return ""String_Node_Str"";
case 69:
return ""String_Node_Str"";
case 70:
return ""String_Node_Str"";
case 71:
return ""String_Node_Str"";
case 72:
return ""String_Node_Str"";
case 73:
return ""String_Node_Str"";
case 74:
return ""String_Node_Str"";
case 75:
return ""String_Node_Str"";
case 76:
return ""String_Node_Str"";
case 77:
return ""String_Node_Str"";
case 78:
return ""String_Node_Str"";
case 79:
return ""String_Node_Str"";
case 80:
return ""String_Node_Str"";
case 81:
return ""String_Node_Str"";
case 82:
return ""String_Node_Str"";
case 83:
return ""String_Node_Str"";
case 84:
return ""String_Node_Str"";
case 85:
return ""String_Node_Str"";
case 86:
return ""String_Node_Str"";
case 87:
return ""String_Node_Str"";
case 88:
return ""String_Node_Str"";
case 89:
return ""String_Node_Str"";
case 90:
return ""String_Node_Str"";
case 91:
return ""String_Node_Str"";
case 92:
return ""String_Node_Str"";
case 93:
return ""String_Node_Str"";
case 94:
return ""String_Node_Str"";
case 95:
return ""String_Node_Str"";
case 96:
return ""String_Node_Str"";
case 97:
return ""String_Node_Str"";
case 98:
return ""String_Node_Str"";
case 99:
return ""String_Node_Str"";
case 100:
return ""String_Node_Str"";
case 101:
return ""String_Node_Str"";
case 102:
return ""String_Node_Str"";
case 103:
return ""String_Node_Str"";
case 104:
return ""String_Node_Str"";
case 105:
return ""String_Node_Str"";
case 106:
return ""String_Node_Str"";
case 107:
return ""String_Node_Str"";
case 108:
return ""String_Node_Str"";
case 109:
return ""String_Node_Str"";
case 110:
return ""String_Node_Str"";
case 111:
return ""String_Node_Str"";
case 112:
return ""String_Node_Str"";
case 113:
return ""String_Node_Str"";
case 114:
return ""String_Node_Str"";
case 115:
return ""String_Node_Str"";
case 116:
return ""String_Node_Str"";
case 117:
return ""String_Node_Str"";
case 118:
return ""String_Node_Str"";
case 119:
return ""String_Node_Str"";
case 120:
return ""String_Node_Str"";
case 121:
return ""String_Node_Str"";
case 122:
return ""String_Node_Str"";
case 123:
return ""String_Node_Str"";
case 124:
return ""String_Node_Str"";
case 125:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}","/** 
 * Takes a short and returns the corresponding genre string
 */
public static String getGenreString(short genre){
switch (genre) {
case 0:
    return ""String_Node_Str"";
case 1:
  return ""String_Node_Str"";
case 2:
return ""String_Node_Str"";
case 3:
return ""String_Node_Str"";
case 4:
return ""String_Node_Str"";
case 5:
return ""String_Node_Str"";
case 6:
return ""String_Node_Str"";
case 7:
return ""String_Node_Str"";
case 8:
return ""String_Node_Str"";
case 9:
return ""String_Node_Str"";
case 10:
return ""String_Node_Str"";
case 11:
return ""String_Node_Str"";
case 12:
return ""String_Node_Str"";
case 13:
return ""String_Node_Str"";
case 14:
return ""String_Node_Str"";
case 15:
return ""String_Node_Str"";
case 16:
return ""String_Node_Str"";
case 17:
return ""String_Node_Str"";
case 18:
return ""String_Node_Str"";
case 19:
return ""String_Node_Str"";
case 20:
return ""String_Node_Str"";
case 21:
return ""String_Node_Str"";
case 22:
return ""String_Node_Str"";
case 23:
return ""String_Node_Str"";
case 24:
return ""String_Node_Str"";
case 25:
return ""String_Node_Str"";
case 26:
return ""String_Node_Str"";
case 27:
return ""String_Node_Str"";
case 28:
return ""String_Node_Str"";
case 29:
return ""String_Node_Str"";
case 30:
return ""String_Node_Str"";
case 31:
return ""String_Node_Str"";
case 32:
return ""String_Node_Str"";
case 33:
return ""String_Node_Str"";
case 34:
return ""String_Node_Str"";
case 35:
return ""String_Node_Str"";
case 36:
return ""String_Node_Str"";
case 37:
return ""String_Node_Str"";
case 38:
return ""String_Node_Str"";
case 39:
return ""String_Node_Str"";
case 40:
return ""String_Node_Str"";
case 41:
return ""String_Node_Str"";
case 42:
return ""String_Node_Str"";
case 43:
return ""String_Node_Str"";
case 44:
return ""String_Node_Str"";
case 45:
return ""String_Node_Str"";
case 46:
return ""String_Node_Str"";
case 47:
return ""String_Node_Str"";
case 48:
return ""String_Node_Str"";
case 49:
return ""String_Node_Str"";
case 50:
return ""String_Node_Str"";
case 51:
return ""String_Node_Str"";
case 52:
return ""String_Node_Str"";
case 53:
return ""String_Node_Str"";
case 54:
return ""String_Node_Str"";
case 55:
return ""String_Node_Str"";
case 56:
return ""String_Node_Str"";
case 57:
return ""String_Node_Str"";
case 58:
return ""String_Node_Str"";
case 59:
return ""String_Node_Str"";
case 60:
return ""String_Node_Str"";
case 61:
return ""String_Node_Str"";
case 62:
return ""String_Node_Str"";
case 63:
return ""String_Node_Str"";
case 64:
return ""String_Node_Str"";
case 65:
return ""String_Node_Str"";
case 66:
return ""String_Node_Str"";
case 67:
return ""String_Node_Str"";
case 68:
return ""String_Node_Str"";
case 69:
return ""String_Node_Str"";
case 70:
return ""String_Node_Str"";
case 71:
return ""String_Node_Str"";
case 72:
return ""String_Node_Str"";
case 73:
return ""String_Node_Str"";
case 74:
return ""String_Node_Str"";
case 75:
return ""String_Node_Str"";
case 76:
return ""String_Node_Str"";
case 77:
return ""String_Node_Str"";
case 78:
return ""String_Node_Str"";
case 79:
return ""String_Node_Str"";
case 80:
return ""String_Node_Str"";
case 81:
return ""String_Node_Str"";
case 82:
return ""String_Node_Str"";
case 83:
return ""String_Node_Str"";
case 84:
return ""String_Node_Str"";
case 85:
return ""String_Node_Str"";
case 86:
return ""String_Node_Str"";
case 87:
return ""String_Node_Str"";
case 88:
return ""String_Node_Str"";
case 89:
return ""String_Node_Str"";
case 90:
return ""String_Node_Str"";
case 91:
return ""String_Node_Str"";
case 92:
return ""String_Node_Str"";
case 93:
return ""String_Node_Str"";
case 94:
return ""String_Node_Str"";
case 95:
return ""String_Node_Str"";
case 96:
return ""String_Node_Str"";
case 97:
return ""String_Node_Str"";
case 98:
return ""String_Node_Str"";
case 99:
return ""String_Node_Str"";
case 100:
return ""String_Node_Str"";
case 101:
return ""String_Node_Str"";
case 102:
return ""String_Node_Str"";
case 103:
return ""String_Node_Str"";
case 104:
return ""String_Node_Str"";
case 105:
return ""String_Node_Str"";
case 106:
return ""String_Node_Str"";
case 107:
return ""String_Node_Str"";
case 108:
return ""String_Node_Str"";
case 109:
return ""String_Node_Str"";
case 110:
return ""String_Node_Str"";
case 111:
return ""String_Node_Str"";
case 112:
return ""String_Node_Str"";
case 113:
return ""String_Node_Str"";
case 114:
return ""String_Node_Str"";
case 115:
return ""String_Node_Str"";
case 116:
return ""String_Node_Str"";
case 117:
return ""String_Node_Str"";
case 118:
return ""String_Node_Str"";
case 119:
return ""String_Node_Str"";
case 120:
return ""String_Node_Str"";
case 121:
return ""String_Node_Str"";
case 122:
return ""String_Node_Str"";
case 123:
return ""String_Node_Str"";
case 124:
return ""String_Node_Str"";
case 125:
return ""String_Node_Str"";
default :
return ""String_Node_Str"";
}
}",0.9980451781059948
4847,"public String getValue(String fieldName){
  fieldName=fieldName.trim();
  return (String)fieldToValue.get(fieldName);
}","public String getValue(String fieldName){
  String retValue=null;
  fieldName=fieldName.trim();
  retValue=(String)fieldToValue.get(fieldName);
  if (fieldName.equals(""String_Node_Str"") && (retValue != null)) {
    try {
      short index=Short.parseShort(retValue);
      retValue=ID3Reader.getGenreString(index);
      fieldToValue.put(fieldName,retValue);
    }
 catch (    NumberFormatException ignored) {
    }
 finally {
      if (retValue.equals(""String_Node_Str"")) {
        fieldToValue.remove(fieldName);
        retValue=null;
      }
    }
  }
  return retValue;
}",0.2359712230215827
4848,"/** 
 * Notifies this that connect() has been called.  This may decide to give out bootstrap pongs if necessary.
 */
public synchronized void expire(){
  bootstrapHostInProgress=null;
  bootstrapHosts.clear();
  String[] hosts=settings.getQuickConnectHosts();
  for (int i=0; i < hosts.length; i++) {
    Endpoint e=new Endpoint(hosts[i]);
    bootstrapHosts.addLast(e);
    notify();
  }
  int n=getNumUltrapeerHosts();
  for (int i=0; i < n; i++) {
    try {
      ExtendedEndpoint e=getAnEndpointInternal();
      add(e,NORMAL_PRIORITY);
    }
 catch (    NoSuchElementException e) {
      Assert.that(false,i + ""String_Node_Str"" + n);
    }
  }
}","/** 
 * Notifies this that connect() has been called.  This may decide to give out bootstrap pongs if necessary.
 */
public synchronized void expire(){
  bootstrapHostInProgress=null;
  bootstrapHosts.clear();
  String[] hosts=settings.getQuickConnectHosts();
  for (int i=0; i < hosts.length; i++) {
    try {
      Endpoint e=new Endpoint(hosts[i]);
      bootstrapHosts.addLast(e);
      notify();
    }
 catch (    IllegalArgumentException ignore) {
    }
  }
  int n=getNumUltrapeerHosts();
  for (int i=0; i < n; i++) {
    try {
      ExtendedEndpoint e=getAnEndpointInternal();
      add(e,NORMAL_PRIORITY);
    }
 catch (    NoSuchElementException e) {
      Assert.that(false,i + ""String_Node_Str"" + n);
    }
  }
}",0.9454545454545454
4849,"public void testBootstraps(){
  try {
    SettingsManager.instance().setQuickConnectHosts(new String[]{""String_Node_Str"",""String_Node_Str""});
    hc.expire();
    hc.add(new Endpoint(""String_Node_Str"",6346),false);
    hc.add(new Endpoint(""String_Node_Str"",6346),false);
    hc.add(new Endpoint(""String_Node_Str"",6346),false);
    Endpoint router1=hc.getAnEndpoint();
    assertTrue(router1.equals(new Endpoint(""String_Node_Str"",6346)));
    assertTrue(hc.getAnEndpoint().equals(new Endpoint(""String_Node_Str"",6346)));
    hc.add(new Endpoint(""String_Node_Str"",6346),true);
    hc.doneWithConnect(router1,false);
    hc.doneWithMessageLoop(router1);
    assertTrue(hc.getAnEndpoint().equals(new Endpoint(""String_Node_Str"",6346)));
    Endpoint router2=hc.getAnEndpoint();
    assertTrue(router2.equals(new Endpoint(""String_Node_Str"",6347)));
    assertTrue(hc.getAnEndpoint().equals(new Endpoint(""String_Node_Str"",6346)));
    hc.doneWithConnect(router2,false);
    hc.doneWithMessageLoop(router2);
    assertTrue(hc.getAnEndpoint().equals(new Endpoint(""String_Node_Str"",6346)));
  }
 catch (  InterruptedException e) {
    assertTrue(""String_Node_Str"",false);
  }
}","public void testBootstraps(){
  try {
    SettingsManager.instance().setQuickConnectHosts(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    hc.expire();
    hc.add(new Endpoint(""String_Node_Str"",6346),false);
    hc.add(new Endpoint(""String_Node_Str"",6346),false);
    hc.add(new Endpoint(""String_Node_Str"",6346),false);
    Endpoint router1=hc.getAnEndpoint();
    assertTrue(router1.equals(new Endpoint(""String_Node_Str"",6346)));
    assertTrue(hc.getAnEndpoint().equals(new Endpoint(""String_Node_Str"",6346)));
    hc.add(new Endpoint(""String_Node_Str"",6346),true);
    hc.doneWithConnect(router1,false);
    hc.doneWithMessageLoop(router1);
    assertTrue(hc.getAnEndpoint().equals(new Endpoint(""String_Node_Str"",6346)));
    Endpoint router2=hc.getAnEndpoint();
    assertTrue(router2.equals(new Endpoint(""String_Node_Str"",6347)));
    assertTrue(hc.getAnEndpoint().equals(new Endpoint(""String_Node_Str"",6346)));
    hc.doneWithConnect(router2,false);
    hc.doneWithMessageLoop(router2);
    assertTrue(hc.getAnEndpoint().equals(new Endpoint(""String_Node_Str"",6346)));
  }
 catch (  InterruptedException e) {
    assertTrue(""String_Node_Str"",false);
  }
}",0.9923404255319148
4850,"public void testAudio(){
  clearDirectory();
  LimeXMLReplyCollection collection=new LimeXMLReplyCollection(files,schemaURI,mfm,audio);
  Assert.assertTrue(""String_Node_Str"" + collection.getCount(),(collection.getCount() == 2));
  LimeXMLDocument doc=null;
  doc=collection.getDocForHash(mfm.readFromMap(mason));
  Assert.assertTrue(""String_Node_Str"",doc == null);
  doc=collection.getDocForHash(mfm.readFromMap(vader));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  doc=collection.getDocForHash(mfm.readFromMap(swing));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  List keywords=collection.getKeyWords();
  Assert.assertTrue(""String_Node_Str"" + keywords.size(),(keywords.size() == 4));
  Assert.assertTrue(""String_Node_Str"",(keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"")&& keywords.contains(""String_Node_Str"")));
}","public void testAudio(){
  clearDirectory();
  LimeXMLReplyCollection collection=new LimeXMLReplyCollection(files,schemaURI,mfm,audio);
  Assert.assertTrue(""String_Node_Str"" + collection.getCount(),(collection.getCount() == 2));
  LimeXMLDocument doc=null;
  doc=collection.getDocForHash(mfm.readFromMap(mason));
  Assert.assertTrue(""String_Node_Str"",doc == null);
  doc=collection.getDocForHash(mfm.readFromMap(vader));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  doc=collection.getDocForHash(mfm.readFromMap(swing));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  List keywords=collection.getKeyWords();
  Assert.assertTrue(""String_Node_Str"" + keywords.size(),(keywords.size() == 6));
  Assert.assertTrue(""String_Node_Str"",(keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"")&& keywords.contains(""String_Node_Str"")&& keywords.contains(""String_Node_Str"")&& keywords.contains(""String_Node_Str"")));
}",0.9575371549893844
4851,"public void testSerialized(){
  createFiles();
  populateDirectory();
  LimeXMLReplyCollection audioCollection=new LimeXMLReplyCollection(files,schemaURI,mfm,audio);
  LimeXMLReplyCollection videoCollection=new LimeXMLReplyCollection(files,schemaURIVideo,mfm,!audio);
  Assert.assertTrue(""String_Node_Str"" + audioCollection.getCount(),(audioCollection.getCount() == 2));
  Assert.assertTrue(""String_Node_Str"" + videoCollection.getCount(),(videoCollection.getCount() == 2));
  LimeXMLDocument doc=null;
  doc=audioCollection.getDocForHash(mfm.readFromMap(mason));
  Assert.assertTrue(""String_Node_Str"",doc == null);
  doc=audioCollection.getDocForHash(mfm.readFromMap(vader));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  doc=audioCollection.getDocForHash(mfm.readFromMap(swing));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  doc=videoCollection.getDocForHash(mfm.readFromMap(mason));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  doc=videoCollection.getDocForHash(mfm.readFromMap(vader));
  Assert.assertTrue(""String_Node_Str"",doc == null);
  doc=videoCollection.getDocForHash(mfm.readFromMap(swing));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  List keywords=audioCollection.getKeyWords();
  Assert.assertTrue(""String_Node_Str"" + keywords.size(),(keywords.size() == 4));
  Assert.assertTrue(""String_Node_Str"",(keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"")&& keywords.contains(""String_Node_Str"")));
  keywords=videoCollection.getKeyWords();
  Assert.assertTrue(""String_Node_Str"" + keywords.size(),(keywords.size() == 4));
  Assert.assertTrue(""String_Node_Str"",(keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"")&& keywords.contains(""String_Node_Str"")));
  clearDirectory();
}","public void testSerialized(){
  createFiles();
  populateDirectory();
  LimeXMLReplyCollection audioCollection=new LimeXMLReplyCollection(files,schemaURI,mfm,audio);
  LimeXMLReplyCollection videoCollection=new LimeXMLReplyCollection(files,schemaURIVideo,mfm,!audio);
  Assert.assertTrue(""String_Node_Str"" + audioCollection.getCount(),(audioCollection.getCount() == 2));
  Assert.assertTrue(""String_Node_Str"" + videoCollection.getCount(),(videoCollection.getCount() == 2));
  LimeXMLDocument doc=null;
  doc=audioCollection.getDocForHash(mfm.readFromMap(mason));
  Assert.assertTrue(""String_Node_Str"",doc == null);
  doc=audioCollection.getDocForHash(mfm.readFromMap(vader));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  doc=audioCollection.getDocForHash(mfm.readFromMap(swing));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  doc=videoCollection.getDocForHash(mfm.readFromMap(mason));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  doc=videoCollection.getDocForHash(mfm.readFromMap(vader));
  Assert.assertTrue(""String_Node_Str"",doc == null);
  doc=videoCollection.getDocForHash(mfm.readFromMap(swing));
  Assert.assertTrue(""String_Node_Str"",doc != null);
  List keywords=audioCollection.getKeyWords();
  Assert.assertTrue(""String_Node_Str"" + keywords.size(),(keywords.size() == 6));
  Assert.assertTrue(""String_Node_Str"",(keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"")&& keywords.contains(""String_Node_Str"")&& keywords.contains(""String_Node_Str"")&& keywords.contains(""String_Node_Str"")));
  keywords=videoCollection.getKeyWords();
  Assert.assertTrue(""String_Node_Str"" + keywords.size(),(keywords.size() == 4));
  Assert.assertTrue(""String_Node_Str"",(keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"") && keywords.contains(""String_Node_Str"")&& keywords.contains(""String_Node_Str"")));
  clearDirectory();
}",0.8706942236354
4852,"/** 
 * Instructs this to stop after reading the given byte in the file.
 * @param stop the byte offset to stop at
 */
public void stopAt(int stop){
  _amountToRead=(stop - _initialReadingPoint);
}","/** 
 * Instructs this stop just before reading the given byte.
 * @param stop the index just past the last byte to read;stop-1 is the index of the last byte to be downloaded
 */
public void stopAt(int stop){
  _amountToRead=(stop - _initialReadingPoint);
}",0.6035242290748899
4853,"/** 
 * Sends a GET request using an already open socket, and reads all  headers.  <p>
 * @param start The byte at which the HTTPDownloader should begin
 * @param stop The byte at which the HTTPDownloader should stop<p>
 * @exception TryAgainLaterException the host is busy
 * @exception FileNotFoundException the host doesn't recognize the file
 * @exception NotSharingException the host isn't sharing files (BearShare)
 * @exception IOException miscellaneous  error 
 */
public void connectHTTP(int start,int stop) throws IOException, TryAgainLaterException, FileNotFoundException, NotSharingException {
  _amountToRead=stop - start;
  _initialReadingPoint=start;
  OutputStream os=_socket.getOutputStream();
  OutputStreamWriter osw=new OutputStreamWriter(os);
  BufferedWriter out=new BufferedWriter(osw);
  String startRange=java.lang.String.valueOf(_initialReadingPoint);
  out.write(""String_Node_Str"" + _index + ""String_Node_Str""+ _filename+ ""String_Node_Str"");
  out.write(""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"");
  AlternateLocationCollection alts=new AlternateLocationCollection();
synchronized (_alternateLocationsToSend) {
    alts.addAlternateLocationCollection(_alternateLocationsToSend);
  }
  URN sha1=_rfd.getSHA1Urn();
  if (sha1 != null)   HTTPUtils.writeHeader(HTTPHeaderName.CONTENT_URN,sha1,out);
  if (alts.size() > 0) {
    HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,alts,out);
  }
  out.write(""String_Node_Str"" + startRange + ""String_Node_Str"");
  SettingsManager sm=SettingsManager.instance();
  if (sm.getChatEnabled()) {
    int port;
    String host;
    if (sm.getForceIPAddress()) {
      port=sm.getForcedPort();
      host=sm.getForcedIPAddressString();
    }
 else {
      port=sm.getPort();
      host=_socket.getLocalAddress().getHostAddress();
    }
    out.write(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str"");
  }
  out.write(""String_Node_Str"");
  out.flush();
  readHeaders();
}","/** 
 * Sends a GET request using an already open socket, and reads all  headers.  <p>
 * @param start The byte at which the HTTPDownloader should begin
 * @param stop the index just past the last byte to read;stop-1 is the last byte the HTTPDownloader should download <p>
 * @exception TryAgainLaterException the host is busy
 * @exception FileNotFoundException the host doesn't recognize the file
 * @exception NotSharingException the host isn't sharing files (BearShare)
 * @exception IOException miscellaneous  error 
 */
public void connectHTTP(int start,int stop) throws IOException, TryAgainLaterException, FileNotFoundException, NotSharingException {
  _amountToRead=stop - start;
  _initialReadingPoint=start;
  OutputStream os=_socket.getOutputStream();
  OutputStreamWriter osw=new OutputStreamWriter(os);
  BufferedWriter out=new BufferedWriter(osw);
  String startRange=java.lang.String.valueOf(_initialReadingPoint);
  out.write(""String_Node_Str"" + _index + ""String_Node_Str""+ _filename+ ""String_Node_Str"");
  out.write(""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"");
  AlternateLocationCollection alts=new AlternateLocationCollection();
synchronized (_alternateLocationsToSend) {
    alts.addAlternateLocationCollection(_alternateLocationsToSend);
  }
  URN sha1=_rfd.getSHA1Urn();
  if (sha1 != null)   HTTPUtils.writeHeader(HTTPHeaderName.CONTENT_URN,sha1,out);
  if (alts.size() > 0) {
    HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,alts,out);
  }
  out.write(""String_Node_Str"" + startRange + ""String_Node_Str"");
  SettingsManager sm=SettingsManager.instance();
  if (sm.getChatEnabled()) {
    int port;
    String host;
    if (sm.getForceIPAddress()) {
      port=sm.getForcedPort();
      host=sm.getForcedIPAddressString();
    }
 else {
      port=sm.getPort();
      host=_socket.getLocalAddress().getHostAddress();
    }
    out.write(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str"");
  }
  out.write(""String_Node_Str"");
  out.flush();
  readHeaders();
}",0.9792965826889498
4854,"/** 
 * Tries one round of downloading of the given files.  Downloads from all locations until all locations fail or some locations succeed.  Moves incomplete file to the library on success.
 * @return COMPLETE if a file was successfully downloaded.  This canhappen even if the file is corrupt, if the user explicitly approved. CORRUPT_FILE a bytes mismatched when checking overlapping regions of resume or swarm, and the user decided they' did not want the download fragment, which is now quarantined. COULDNT_MOVE_TO_LIBRARY the download completed but the temporary file couldn't be moved to the library OR the download couldn't be written to the incomplete file WAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try.
 * @exception InterruptedException if the user stop()'ed this download. (Calls to resume() do not result in InterruptedException.)
 */
private int tryAllDownloads2() throws InterruptedException {
synchronized (this) {
    if (files.size() == 0)     return GAVE_UP;
  }
  RemoteFileDesc rfd=null;
synchronized (this) {
    rfd=(RemoteFileDesc)files.get(0);
  }
  int fileSize=rfd.getSize();
  String filename=rfd.getFileName();
  File incompleteFile=incompleteFileManager.getFile(rfd);
  File sharedDir;
  File completeFile;
  try {
    sharedDir=SettingsManager.instance().getSaveDirectory();
    completeFile=new File(sharedDir,filename);
    String sharedPath=sharedDir.getCanonicalPath();
    String completeFileParentPath=new File(completeFile.getParent()).getCanonicalPath();
    if (!sharedPath.equals(completeFileParentPath))     throw new InvalidPathException();
  }
 catch (  IOException e) {
    return COULDNT_MOVE_TO_LIBRARY;
  }
  totalAlternateLocations=new AlternateLocationCollection();
  RemoteFileDesc tempRFD;
  String rfdStr;
  URL rfdURL;
synchronized (this) {
    for (Iterator iter=files.iterator(); iter.hasNext(); ) {
      tempRFD=(RemoteFileDesc)iter.next();
      if (tempRFD.getSHA1Urn() == null)       continue;
      try {
        totalAlternateLocations.addAlternateLocation(AlternateLocation.createAlternateLocation(tempRFD));
      }
 catch (      IOException e) {
      }
    }
  }
  int status=-1;
  try {
    status=tryAllDownloads3();
  }
 catch (  InterruptedException e) {
  }
  commonOutFile.close();
  if (corruptState != NOT_CORRUPT_STATE) {
synchronized (corruptStateLock) {
      try {
        while (corruptState == CORRUPT_WAITING_STATE) {
          corruptStateLock.wait();
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
 else     if (corruptState == CORRUPT_CONTINUE_STATE) {
      ;
    }
  }
  if (status == -1)   throw new InterruptedException();
  if (status != COMPLETE)   return status;
  URN bucketHash=buckets.getURNForBucket(bucketNumber);
  URN fileHash=null;
  try {
    fileHash=URN.createSHA1Urn(incompleteFile);
  }
 catch (  IOException ignored) {
  }
  if (bucketHash != null) {
synchronized (corruptStateLock) {
      if (!fileHash.equals(bucketHash))       promptAboutCorruptDownload();
      try {
        while (corruptState == CORRUPT_WAITING_STATE)         corruptStateLock.wait();
      }
 catch (      InterruptedException ignored2) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
  }
  completeFile.delete();
  if (!incompleteFile.renameTo(completeFile))   if (!CommonUtils.copy(incompleteFile,completeFile))   return COULDNT_MOVE_TO_LIBRARY;
  if (fileExists(completeFile))   fileManager.removeFileIfShared(completeFile);
  fileManager.addFileIfShared(completeFile,getXMLDocuments());
  if (totalAlternateLocations != null) {
    FileDesc fileDesc=fileManager.getFileDescMatching(completeFile);
    if (fileDesc != null)     fileDesc.addAlternateLocationCollection(totalAlternateLocations);
  }
  return COMPLETE;
}","/** 
 * Tries one round of downloading of the given files.  Downloads from all locations until all locations fail or some locations succeed.  Moves incomplete file to the library on success.
 * @return COMPLETE if a file was successfully downloaded.  This canhappen even if the file is corrupt, if the user explicitly approved. CORRUPT_FILE a bytes mismatched when checking overlapping regions of resume or swarm, and the user decided they' did not want the download fragment, which is now quarantined. COULDNT_MOVE_TO_LIBRARY the download completed but the temporary file couldn't be moved to the library OR the download couldn't be written to the incomplete file WAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try.
 * @exception InterruptedException if the user stop()'ed this download. (Calls to resume() do not result in InterruptedException.)
 */
private int tryAllDownloads2() throws InterruptedException {
synchronized (this) {
    if (files.size() == 0)     return GAVE_UP;
  }
  RemoteFileDesc rfd=null;
synchronized (this) {
    rfd=(RemoteFileDesc)files.get(0);
  }
  int fileSize=rfd.getSize();
  String filename=rfd.getFileName();
  File incompleteFile=incompleteFileManager.getFile(rfd);
  File sharedDir;
  File completeFile;
  try {
    sharedDir=SettingsManager.instance().getSaveDirectory();
    completeFile=new File(sharedDir,filename);
    String sharedPath=sharedDir.getCanonicalPath();
    String completeFileParentPath=new File(completeFile.getParent()).getCanonicalPath();
    if (!sharedPath.equals(completeFileParentPath))     throw new InvalidPathException();
  }
 catch (  IOException e) {
    return COULDNT_MOVE_TO_LIBRARY;
  }
  totalAlternateLocations=new AlternateLocationCollection();
  RemoteFileDesc tempRFD;
  String rfdStr;
  URL rfdURL;
synchronized (this) {
    for (Iterator iter=files.iterator(); iter.hasNext(); ) {
      tempRFD=(RemoteFileDesc)iter.next();
      if (tempRFD.getSHA1Urn() == null)       continue;
      try {
        totalAlternateLocations.addAlternateLocation(AlternateLocation.createAlternateLocation(tempRFD));
      }
 catch (      IOException e) {
      }
    }
  }
  int status=-1;
  try {
    status=tryAllDownloads3();
  }
 catch (  InterruptedException e) {
  }
  commonOutFile.close();
  if (corruptState != NOT_CORRUPT_STATE) {
synchronized (corruptStateLock) {
      try {
        while (corruptState == CORRUPT_WAITING_STATE) {
          corruptStateLock.wait();
        }
      }
 catch (      InterruptedException ignored) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
 else     if (corruptState == CORRUPT_CONTINUE_STATE) {
      ;
    }
  }
  if (status == -1)   throw new InterruptedException();
  if (status != COMPLETE)   return status;
  URN bucketHash=buckets.getURNForBucket(bucketNumber);
  URN fileHash=null;
  try {
    fileHash=URN.createSHA1Urn(incompleteFile);
  }
 catch (  IOException ignored) {
  }
  if (bucketHash != null) {
synchronized (corruptStateLock) {
      if (!bucketHash.equals(fileHash)) {
        promptAboutCorruptDownload();
        debug(""String_Node_Str"" + fileHash + ""String_Node_Str""+ bucketHash);
      }
      try {
        while (corruptState == CORRUPT_WAITING_STATE)         corruptStateLock.wait();
      }
 catch (      InterruptedException ignored2) {
      }
    }
    if (corruptState == CORRUPT_STOP_STATE) {
      cleanupCorrupt(incompleteFile,completeFile.getName());
      return CORRUPT_FILE;
    }
  }
  completeFile.delete();
  if (!incompleteFile.renameTo(completeFile))   if (!CommonUtils.copy(incompleteFile,completeFile))   return COULDNT_MOVE_TO_LIBRARY;
  if (fileExists(completeFile))   fileManager.removeFileIfShared(completeFile);
  fileManager.addFileIfShared(completeFile,getXMLDocuments());
  if (totalAlternateLocations != null) {
    FileDesc fileDesc=fileManager.getFileDescMatching(completeFile);
    if (fileDesc != null)     fileDesc.addAlternateLocationCollection(totalAlternateLocations);
  }
  return COMPLETE;
}",0.987092954410894
4855,"/** 
 * Assigns a white part of the file to a HTTPDownloader and returns it. This method has side effects.
 */
private void assignWhite(HTTPDownloader dloader) throws IOException, TryAgainLaterException, FileNotFoundException, NotSharingException {
  Interval interval=null;
synchronized (this) {
    interval=(Interval)needed.remove(0);
  }
  dloader.connectHTTP(getOverlapOffset(interval.low),interval.high);
  dloader.stopAt(interval.high + 1);
  debug(""String_Node_Str"" + interval + ""String_Node_Str""+ dloader);
}","/** 
 * Assigns a white part of the file to a HTTPDownloader and returns it. This method has side effects.
 */
private void assignWhite(HTTPDownloader dloader) throws IOException, TryAgainLaterException, FileNotFoundException, NotSharingException {
  Interval interval=null;
synchronized (this) {
    interval=(Interval)needed.remove(0);
  }
  dloader.connectHTTP(getOverlapOffset(interval.low),interval.high + 1);
  dloader.stopAt(interval.high + 1);
  debug(""String_Node_Str"" + interval + ""String_Node_Str""+ dloader);
}",0.9961464354527938
4856,"public void testLegacy(){
  String args[]={};
  try {
    testFile=new File(""String_Node_Str"");
    RandomAccessFile raf=new RandomAccessFile(testFile,""String_Node_Str"");
    for (int i=0; i < TestFile.length(); i++)     raf.writeByte(TestFile.getByte(i));
    raf.close();
    testHash=URN.createSHA1Urn(testFile);
  }
 catch (  IOException iox) {
    debug(""String_Node_Str"");
    System.exit(1);
  }
catch (  InterruptedException ignored) {
  }
  try {
    file=new File(""String_Node_Str"");
    file.delete();
    SettingsManager.instance().setSaveDirectory(directory);
    SettingsManager.instance().setConnectionSpeed(1000);
  }
 catch (  IOException e) {
    debug(""String_Node_Str"");
    System.exit(1);
  }
  RouterService rs=new RouterService(null,null,null,null);
  dm.initialize(callback,new MessageRouterStub(),null,new FileManagerStub());
  dm.postGuiInit(rs);
  SimpleTimer timer=new SimpleTimer(true);
  Runnable click=new Runnable(){
    public void run(){
      dm.measureBandwidth();
    }
  }
;
  timer.schedule(click,0,SupernodeAssigner.TIMER_DELAY);
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleDownload();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleSwarm();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUnbalancedSwarm();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSwarmWithInterrupt();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStealerInterrupted();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tAddDownload();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStallingUploaderReplaced();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckGrey(false);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckWhite(false);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tMismatchedVerifyHash(false);
    cleanup();
  }
  callback.delCorrupt=true;
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckGrey(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckWhite(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tMismatchedVerifyHash(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tTwoAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUploaderAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tWeirdAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStealerInterruptedWithAlternate();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tTwoAlternatesButOneWithNoSHA1();
    cleanup();
  }
}","public void testLegacy(){
  String args[]={};
  try {
    testFile=new File(""String_Node_Str"");
    RandomAccessFile raf=new RandomAccessFile(testFile,""String_Node_Str"");
    for (int i=0; i < TestFile.length(); i++)     raf.writeByte(TestFile.getByte(i));
    raf.close();
    testHash=URN.createSHA1Urn(testFile);
  }
 catch (  IOException iox) {
    debug(""String_Node_Str"");
    System.exit(1);
  }
catch (  InterruptedException ignored) {
  }
  try {
    file=new File(""String_Node_Str"");
    file.delete();
    SettingsManager.instance().setSaveDirectory(directory);
    SettingsManager.instance().setConnectionSpeed(1000);
  }
 catch (  IOException e) {
    debug(""String_Node_Str"");
    System.exit(1);
  }
  RouterService rs=new RouterService(null,null,null,null);
  dm.initialize(callback,new MessageRouterStub(),null,new FileManagerStub());
  dm.postGuiInit(rs);
  SimpleTimer timer=new SimpleTimer(true);
  Runnable click=new Runnable(){
    public void run(){
      dm.measureBandwidth();
    }
  }
;
  timer.schedule(click,0,SupernodeAssigner.TIMER_DELAY);
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleDownload();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleSwarm();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUnbalancedSwarm();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSwarmWithInterrupt();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStealerInterrupted();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tAddDownload();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStallingUploaderReplaced();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckGrey(false);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckWhite(false);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tMismatchedVerifyHash(false);
    cleanup();
  }
  callback.delCorrupt=true;
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckGrey(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tOverlapCheckWhite(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tMismatchedVerifyHash(true);
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tSimpleAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tTwoAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUploaderAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tWeirdAlternateLocations();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tStealerInterruptedWithAlternate();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tTwoAlternatesButOneWithNoSHA1();
    cleanup();
  }
  if (args.length == 0 || args[0].equals(""String_Node_Str"")) {
    tUpdateWhiteWithFailingFirstUploader();
    cleanup();
  }
}",0.9808510638297872
4857,"private void send(OutputStream out,int start,int stop) throws IOException {
  String str=""String_Node_Str"";
  out.write(str.getBytes());
  str=""String_Node_Str"" + (stop - start) + ""String_Node_Str"";
  out.write(str.getBytes());
  if (start != 0) {
    str=""String_Node_Str"" + start + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str""+ TestFile.length()+ ""String_Node_Str"";
    out.write(str.getBytes());
  }
  if (storedAltLocs.hasAlternateLocations())   HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,storedAltLocs,out);
  str=""String_Node_Str"";
  out.write(str.getBytes());
  out.flush();
  for (int i=start; i < stop; ) {
    long startTime=System.currentTimeMillis();
    for (int j=0; j < Math.max(1,(rate * 1024)) && i < stop; j++) {
      if (stopAfter > -1 && totalUploaded >= stopAfter) {
        stopped=true;
        out.flush();
        throw new IOException();
      }
      if (sendCorrupt)       out.write(TestFile.getByte(i) + (byte)1);
 else       out.write(TestFile.getByte(i));
      totalUploaded++;
      i++;
    }
    long elapsed=System.currentTimeMillis() - startTime;
    long wait=1000 - elapsed;
    if (wait > 0)     try {
      Thread.sleep(wait);
    }
 catch (    InterruptedException e) {
    }
  }
  out.flush();
}","private void send(OutputStream out,int start,int stop) throws IOException {
  String str=busy ? ""String_Node_Str"" : ""String_Node_Str"";
  out.write(str.getBytes());
  if (busy) {
    String s=""String_Node_Str"";
    out.write(s.getBytes());
    out.flush();
    out.close();
    return;
  }
  str=""String_Node_Str"" + (stop - start) + ""String_Node_Str"";
  out.write(str.getBytes());
  if (start != 0) {
    str=""String_Node_Str"" + start + ""String_Node_Str""+ (stop - 1)+ ""String_Node_Str""+ TestFile.length()+ ""String_Node_Str"";
    out.write(str.getBytes());
  }
  if (storedAltLocs.hasAlternateLocations())   HTTPUtils.writeHeader(HTTPHeaderName.ALT_LOCATION,storedAltLocs,out);
  str=""String_Node_Str"";
  out.write(str.getBytes());
  out.flush();
  for (int i=start; i < stop; ) {
    long startTime=System.currentTimeMillis();
    for (int j=0; j < Math.max(1,(rate * 1024)) && i < stop; j++) {
      if (stopAfter > -1 && totalUploaded >= stopAfter) {
        stopped=true;
        out.flush();
        throw new IOException();
      }
      if (sendCorrupt)       out.write(TestFile.getByte(i) + (byte)1);
 else       out.write(TestFile.getByte(i));
      totalUploaded++;
      i++;
    }
    long elapsed=System.currentTimeMillis() - startTime;
    long wait=1000 - elapsed;
    if (wait > 0)     try {
      Thread.sleep(wait);
    }
 catch (    InterruptedException e) {
    }
  }
  out.flush();
}",0.942684766214178
4858,"/** 
 * @return Correctly uncompressed data (according to Content-Type header) May return a byte[] of length 0 if something bad happens. 
 */
public static byte[] uncompress(byte[] data) throws Exception {
  byte[] retBytes=new byte[0];
  String headerFragment=new String(data,0,C_HEADER_BEGIN.length());
  if (headerFragment.equals(C_HEADER_BEGIN)) {
    headerFragment=new String(data,(C_HEADER_BEGIN.length()),max3(C_HEADER_NONE_VAL.length(),C_HEADER_ZLIB_VAL.length(),C_HEADER_GZIP_VAL.length()));
    if (headerFragment.indexOf(C_HEADER_NONE_VAL) == 0) {
      retBytes=new byte[data.length - COMPRESS_HEADER_NONE.length()];
      System.arraycopy(data,COMPRESS_HEADER_NONE.length(),retBytes,0,data.length - COMPRESS_HEADER_NONE.length());
    }
 else     if (headerFragment.indexOf(C_HEADER_GZIP_VAL) == 0) {
      retBytes=new byte[data.length - COMPRESS_HEADER_GZIP.length()];
      System.arraycopy(data,COMPRESS_HEADER_GZIP.length(),retBytes,0,data.length - COMPRESS_HEADER_GZIP.length());
      retBytes=uncompressGZIP(retBytes);
    }
 else     if (headerFragment.indexOf(C_HEADER_ZLIB_VAL) == 0) {
      retBytes=new byte[data.length - COMPRESS_HEADER_ZLIB.length()];
      System.arraycopy(data,COMPRESS_HEADER_ZLIB.length(),retBytes,0,data.length - COMPRESS_HEADER_ZLIB.length());
      retBytes=uncompressZLIB(retBytes);
    }
 else     ;
  }
 else   return data;
  return retBytes;
}","/** 
 * @return Correctly uncompressed data (according to Content-Type header) May return a byte[] of length 0 if something bad happens. 
 */
public static byte[] uncompress(byte[] data) throws Exception {
  byte[] retBytes=new byte[0];
  String headerFragment=new String(data,0,C_HEADER_BEGIN.length());
  if (headerFragment.equals(C_HEADER_BEGIN)) {
    boolean found=false;
    int i=0;
    for (; i < data.length && !found; i++)     if (data[i] == (byte)125)     found=true;
    headerFragment=new String(data,1,i - 1 - 1);
    int comp=getCompressionType(headerFragment);
    if (comp == NONE) {
      retBytes=new byte[data.length - (headerFragment.length() + 2)];
      System.arraycopy(data,i,retBytes,0,data.length - (headerFragment.length() + 2));
    }
 else     if (comp == GZIP) {
      retBytes=new byte[data.length - COMPRESS_HEADER_GZIP.length()];
      System.arraycopy(data,COMPRESS_HEADER_GZIP.length(),retBytes,0,data.length - COMPRESS_HEADER_GZIP.length());
      retBytes=uncompressGZIP(retBytes);
    }
 else     if (comp == ZLIB) {
      retBytes=new byte[data.length - COMPRESS_HEADER_ZLIB.length()];
      System.arraycopy(data,COMPRESS_HEADER_ZLIB.length(),retBytes,0,data.length - COMPRESS_HEADER_ZLIB.length());
      retBytes=uncompressZLIB(retBytes);
    }
 else     ;
  }
 else   return data;
  return retBytes;
}",0.5428051001821493
4859,"public void testEncode() throws java.io.IOException {
  for (int num=1; num < 512; num++) {
    System.out.println(""String_Node_Str"" + num);
    byte[] bytes=new byte[num];
    for (int i=0; i < bytes.length; i++)     bytes[i]=0;
    byte[] after=COBSUtil.cobsEncode(bytes);
    assertTrue(bytes.length == (after.length - 1));
    for (int i=0; i < after.length; i++)     assertTrue(after[i] == 0x01);
    for (int i=0; i < bytes.length; i++)     if (i % 2 == 0)     bytes[i]=0;
 else     bytes[i]=1;
    after=COBSUtil.cobsEncode(bytes);
    assertTrue(bytes.length == (after.length - 1));
    for (int i=0; i < after.length; i++)     if (i % 2 == 0)     after[i]=2;
 else     after[i]=1;
    for (int i=0; i < bytes.length; i++)     if (i % 3 == 0)     bytes[i]=0;
 else     bytes[i]=1;
    after=COBSUtil.cobsEncode(bytes);
    assertTrue(bytes.length == (after.length - 1));
    for (int i=0; i < after.length; i++)     if (i % 3 == 0)     after[i]=3;
 else     after[i]=1;
    for (int i=0; i < bytes.length; i++)     if (i % 255 == 0)     bytes[i]=0;
 else     bytes[i]=1;
    after=COBSUtil.cobsEncode(bytes);
    assertTrue(bytes.length == (after.length - 1));
    for (int i=0; i < after.length; i++)     if (i % 255 == 0)     after[i]=(byte)0xFF;
 else     after[i]=1;
    for (int i=0; i < bytes.length; i++)     if (i % 2 == 0)     bytes[i]=1;
 else     bytes[i]=0;
    after=COBSUtil.cobsEncode(bytes);
    assertTrue(bytes.length == (after.length - 1));
    for (int i=0; i < bytes.length; i++)     if (i % 2 == 0)     after[i]=2;
 else     after[i]=1;
    assertTrue(after[num] == 1);
    for (int i=0; i < bytes.length; i++)     if ((i + 1) % 3 == 0)     bytes[i]=0;
 else     bytes[i]=1;
    after=COBSUtil.cobsEncode(bytes);
    assertTrue(bytes.length == (after.length - 1));
    for (int i=0; i < bytes.length; i++)     if ((i + 1) % 3 == 0)     after[i]=3;
 else     after[i]=1;
    assertTrue(after[num] == 1);
    for (int i=0; i < bytes.length; i++)     if ((i + 1) % 255 == 0)     bytes[i]=0;
 else     bytes[i]=1;
    after=COBSUtil.cobsEncode(bytes);
    assertTrue(bytes.length == (after.length - 1));
    for (int i=0; i < after.length; i++)     if ((i + 1) % 255 == 0)     after[i]=(byte)0xFF;
 else     after[i]=1;
    assertTrue(after[num] == 1);
  }
}","public void testEncode() throws java.io.IOException {
  for (int num=255; num < 260; num++)   encode(num);
}",0.084448160535117
4860,"public LimeXMLDocument readDocument(File file) throws IOException {
  Object[] info=parseFile(file);
  short track=((Short)info[4]).shortValue(), gen=((Short)info[6]).shortValue();
  int bitrate=((Integer)info[7]).intValue(), seconds=((Integer)info[8]).intValue();
  List nameValList=new ArrayList();
  nameValList.add(new NameValue(TITLE_KEY,info[0]));
  nameValList.add(new NameValue(ARTIST_KEY,info[1]));
  nameValList.add(new NameValue(ALBUM_KEY,info[2]));
  nameValList.add(new NameValue(YEAR_KEY,info[3]));
  nameValList.add(new NameValue(COMMENTS_KEY,info[5]));
  nameValList.add(new NameValue(TRACK_KEY,""String_Node_Str"" + track));
  nameValList.add(new NameValue(GENRE_KEY,""String_Node_Str"" + gen));
  nameValList.add(new NameValue(BITRATE_KEY,""String_Node_Str"" + bitrate));
  nameValList.add(new NameValue(SECONDS_KEY,""String_Node_Str"" + seconds));
  return new LimeXMLDocument(nameValList,schemaURI);
}","public LimeXMLDocument readDocument(File file) throws IOException {
  Object[] info=parseFile(file);
  short track=((Short)info[4]).shortValue();
  short gen=((Short)info[6]).shortValue();
  int bitrate=((Integer)info[7]).intValue();
  int seconds=((Integer)info[8]).intValue();
  String genre=getGenreString(gen);
  List nameValList=new ArrayList();
  if (!((String)info[0]).equals(""String_Node_Str""))   nameValList.add(new NameValue(TITLE_KEY,info[0]));
  if (!((String)info[1]).equals(""String_Node_Str""))   nameValList.add(new NameValue(ARTIST_KEY,info[1]));
  if (!((String)info[2]).equals(""String_Node_Str""))   nameValList.add(new NameValue(ALBUM_KEY,info[2]));
  if (!((String)info[3]).equals(""String_Node_Str""))   nameValList.add(new NameValue(YEAR_KEY,info[3]));
  if (!((String)info[5]).equals(""String_Node_Str""))   nameValList.add(new NameValue(COMMENTS_KEY,info[5]));
  if (track > 0)   nameValList.add(new NameValue(TRACK_KEY,""String_Node_Str"" + track));
  if (!genre.equals(""String_Node_Str""))   nameValList.add(new NameValue(GENRE_KEY,genre));
  if (bitrate > 0)   nameValList.add(new NameValue(BITRATE_KEY,""String_Node_Str"" + bitrate));
  if (seconds > 0)   nameValList.add(new NameValue(SECONDS_KEY,""String_Node_Str"" + seconds));
  return new LimeXMLDocument(nameValList,schemaURI);
}",0.7844554902846814
4861,"/** 
 * @requires buf.length==23
 * @effects exactly like Message.read(in), but buf is used as scratch forreading the header.  This is an optimization that lets you avoid repeatedly allocating 23-byte arrays.  buf may be used when this returns, but the contents are not guaranteed to contain any useful data.  
 */
static Message read(InputStream in,byte[] buf) throws BadPacketException, IOException {
  for (int i=0; i < 23; ) {
    int got;
    try {
      got=in.read(buf,i,23 - i);
    }
 catch (    InterruptedIOException e) {
      if (i == 0)       return null;
 else       throw e;
    }
    if (got == -1)     throw new IOException(""String_Node_Str"");
    i+=got;
  }
  byte[] guid=new byte[16];
  for (int i=0; i < 16; i++)   guid[i]=buf[i];
  byte func=buf[16];
  byte ttl=buf[17];
  byte hops=buf[18];
  int length=ByteOrder.leb2int(buf,19);
  if (length < 0 || length > SettingsManager.instance().getMaxLength())   throw new IOException(""String_Node_Str"" + length);
  byte[] payload=null;
  if (length != 0) {
    payload=new byte[length];
    for (int i=0; i < length; ) {
      int got=in.read(payload,i,length - i);
      if (got == -1)       throw new IOException(""String_Node_Str"");
      i+=got;
    }
  }
  byte softMax=SettingsManager.instance().getSoftMaxTTL();
  byte hardMax=SettingsManager.instance().getMaxTTL();
  if (hops < 0)   throw new BadPacketException(""String_Node_Str"");
 else   if (ttl < 0)   throw new BadPacketException(""String_Node_Str"");
 else   if (hops > softMax)   throw new BadPacketException(""String_Node_Str"");
 else   if (ttl + hops > hardMax)   throw new BadPacketException(""String_Node_Str"");
 else   if (ttl + hops > softMax) {
    ttl=(byte)(softMax - hops);
    Assert.that(ttl >= 0);
  }
switch (func) {
case F_PING:
    if (PARSE_GROUP_PINGS && length >= 15) {
      return new GroupPingRequest(guid,ttl,hops,payload);
    }
 else     if (length > 0)     return new PingRequest(guid,ttl,hops,payload);
  return new PingRequest(guid,ttl,hops);
case F_PING_REPLY:
return new PingReply(guid,ttl,hops,payload);
case F_QUERY:
if (length < 3) break;
return new QueryRequest(guid,ttl,hops,payload);
case F_QUERY_REPLY:
if (length < 26) break;
return new QueryReply(guid,ttl,hops,payload);
case F_PUSH:
return new PushRequest(guid,ttl,hops,payload);
case F_ROUTE_TABLE_UPDATE:
return RouteTableMessage.read(guid,ttl,hops,payload);
}
throw new BadPacketException(""String_Node_Str"" + func);
}","/** 
 * @requires buf.length==23
 * @effects exactly like Message.read(in), but buf is used as scratch forreading the header.  This is an optimization that lets you avoid repeatedly allocating 23-byte arrays.  buf may be used when this returns, but the contents are not guaranteed to contain any useful data.  
 */
static Message read(InputStream in,byte[] buf) throws BadPacketException, IOException {
  for (int i=0; i < 23; ) {
    int got;
    try {
      got=in.read(buf,i,23 - i);
    }
 catch (    InterruptedIOException e) {
      if (i == 0)       return null;
 else       throw e;
    }
    if (got == -1)     throw new IOException(""String_Node_Str"");
    i+=got;
  }
  byte[] guid=new byte[16];
  for (int i=0; i < 16; i++)   guid[i]=buf[i];
  byte func=buf[16];
  byte ttl=buf[17];
  byte hops=buf[18];
  int length=ByteOrder.leb2int(buf,19);
  if (length < 0 || length > SettingsManager.instance().getMaxLength())   throw new IOException(""String_Node_Str"" + length);
  byte[] payload=null;
  if (length != 0) {
    payload=new byte[length];
    for (int i=0; i < length; ) {
      int got=in.read(payload,i,length - i);
      if (got == -1)       throw new IOException(""String_Node_Str"");
      i+=got;
    }
  }
 else   payload=new byte[0];
  byte softMax=SettingsManager.instance().getSoftMaxTTL();
  byte hardMax=SettingsManager.instance().getMaxTTL();
  if (hops < 0)   throw new BadPacketException(""String_Node_Str"");
 else   if (ttl < 0)   throw new BadPacketException(""String_Node_Str"");
 else   if (hops > softMax)   throw new BadPacketException(""String_Node_Str"");
 else   if (ttl + hops > hardMax)   throw new BadPacketException(""String_Node_Str"");
 else   if (ttl + hops > softMax) {
    ttl=(byte)(softMax - hops);
    Assert.that(ttl >= 0);
  }
switch (func) {
case F_PING:
    if (PARSE_GROUP_PINGS && length >= 15) {
      return new GroupPingRequest(guid,ttl,hops,payload);
    }
 else     if (length > 0)     return new PingRequest(guid,ttl,hops,payload);
  return new PingRequest(guid,ttl,hops);
case F_PING_REPLY:
return new PingReply(guid,ttl,hops,payload);
case F_QUERY:
if (length < 3) break;
return new QueryRequest(guid,ttl,hops,payload);
case F_QUERY_REPLY:
if (length < 26) break;
return new QueryReply(guid,ttl,hops,payload);
case F_PUSH:
return new PushRequest(guid,ttl,hops,payload);
case F_ROUTE_TABLE_UPDATE:
return RouteTableMessage.read(guid,ttl,hops,payload);
}
throw new BadPacketException(""String_Node_Str"" + func);
}",0.9940852539261676
4862,"public void writeMessageHeaders(OutputStream os){
}","public void writeMessageHeaders(OutputStream os) throws IOException {
  String str;
  str=""String_Node_Str"";
  os.write(str.getBytes());
  str=""String_Node_Str"" + CommonUtils.getHttpServer() + ""String_Node_Str"";
  os.write(str.getBytes());
  str=""String_Node_Str"";
  os.write(str.getBytes());
  str=""String_Node_Str"" + RESPONSE_PAGE.length() + ""String_Node_Str"";
  os.write(str.getBytes());
  str=""String_Node_Str"";
  os.write(str.getBytes());
}",0.2056451612903226
4863,"public void writeMessageBody(OutputStream os){
}","public void writeMessageBody(OutputStream os) throws IOException {
  os.write(RESPONSE_PAGE.getBytes());
  os.flush();
}",0.5714285714285714
4864,"/** 
 * Converts the specified <tt>Date</tt> instance to a <tt>String</tt>  that fits the syntax specified in the ISO 8601 subset we're using, discussed at: http://www.w3.org/TR/NOTE-datetime.
 * @param date the <tt>Date</tt> instance to convert
 * @return a new <tt>String</tt> instance that matches the standardsyntax
 */
private static String convertDateToString(Date date){
  Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
  cal.setTime(date);
  int[] dateInts=new int[6];
  String[] dateStrs=new String[6];
  dateInts[0]=cal.get(Calendar.YEAR);
  dateInts[1]=cal.get(Calendar.MONTH);
  dateInts[2]=cal.get(Calendar.DAY_OF_MONTH);
  dateInts[3]=cal.get(Calendar.HOUR);
  dateInts[4]=cal.get(Calendar.MINUTE);
  dateInts[5]=cal.get(Calendar.SECOND);
  for (int i=0; i < dateInts.length; i++) {
    if (dateInts[i] < 10) {
      dateStrs[i]=""String_Node_Str"" + String.valueOf(dateInts[i]);
    }
 else {
      dateStrs[i]=String.valueOf(dateInts[i]);
    }
  }
  final String DASH=""String_Node_Str"";
  final String COLON=""String_Node_Str"";
  return (dateStrs[0] + DASH + dateStrs[1]+ DASH+ dateStrs[2]+ ""String_Node_Str""+ dateStrs[3]+ COLON+ dateStrs[4]+ COLON+ dateStrs[5]+ ""String_Node_Str"");
}","/** 
 * Converts the specified <tt>Date</tt> instance to a <tt>String</tt>  that fits the syntax specified in the ISO 8601 subset we're using, discussed at: http://www.w3.org/TR/NOTE-datetime.
 * @param date the <tt>Date</tt> instance to convert
 * @return a new <tt>String</tt> instance that matches the standardsyntax
 */
private static String convertDateToString(Date date){
  Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
  cal.setTime(date);
  int[] dateInts=new int[6];
  String[] dateStrs=new String[6];
  dateInts[0]=cal.get(Calendar.YEAR);
  dateInts[1]=cal.get(Calendar.MONTH) + 1;
  dateInts[2]=cal.get(Calendar.DAY_OF_MONTH);
  dateInts[3]=cal.get(Calendar.HOUR);
  dateInts[4]=cal.get(Calendar.MINUTE);
  dateInts[5]=cal.get(Calendar.SECOND);
  for (int i=0; i < dateInts.length; i++) {
    if (dateInts[i] < 10) {
      dateStrs[i]=""String_Node_Str"" + String.valueOf(dateInts[i]);
    }
 else {
      dateStrs[i]=String.valueOf(dateInts[i]);
    }
  }
  final String DASH=""String_Node_Str"";
  final String COLON=""String_Node_Str"";
  StringBuffer sb=new StringBuffer();
  sb.append(dateStrs[0]);
  sb.append(DASH);
  sb.append(dateStrs[1]);
  sb.append(DASH);
  sb.append(dateStrs[2]);
  sb.append(""String_Node_Str"");
  sb.append(dateStrs[3]);
  sb.append(COLON);
  sb.append(dateStrs[4]);
  sb.append(COLON);
  sb.append(dateStrs[5]);
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.8989861058956065
4865,"/** 
 * Returns the URN type string for this URN.  For example, if the String for this URN is:<p> urn:sha1:PLSTHIPQGSSZTS5FJUPAKUZWUGYQYPFB <p> then this method will return: <p> urn:sha1:
 */
private static String getTypeString(String fullUrnString){
  return fullUrnString.substring(0,fullUrnString.indexOf(':',4) + 1);
}","/** 
 * Returns the URN type string for this URN.  For example, if the String for this URN is:<p> urn:sha1:PLSTHIPQGSSZTS5FJUPAKUZWUGYQYPFB <p> then this method will return: <p> urn:sha1:
 */
private static String getTypeString(String fullUrnString){
  String protocol=fullUrnString.substring(0,fullUrnString.lastIndexOf(':') + 1);
  return protocol.trim();
}",0.9162995594713657
4866,"/** 
 * Create a new SHA1 hash string for the specified file on disk.
 * @param file the file to construct the hash from
 * @return the SHA1 hash string
 * @throws <tt>IOException</tt> if there is an error creating the hash
 * @throws <tt>NoSuchAlgorithmException</tt> if the specified algorithmcannot be found
 */
private static String createSHA1String(final File file) throws IOException {
  FileInputStream fis=new FileInputStream(file);
  MessageDigest md=null;
  try {
    md=MessageDigest.getInstance(""String_Node_Str"");
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IOException(""String_Node_Str"");
  }
  byte[] buffer=new byte[16384];
  int read;
  while ((read=fis.read(buffer)) != -1) {
    long start=System.currentTimeMillis();
    md.update(buffer,0,read);
    long end=System.currentTimeMillis();
    long interval=Math.abs(end - start);
    try {
      Thread.sleep(interval * 2);
    }
 catch (    InterruptedException e) {
    }
  }
  fis.close();
  byte[] sha1=md.digest();
  return UrnType.URN_NAMESPACE_ID + UrnType.SHA1_STRING + ""String_Node_Str""+ Base32.encode(sha1);
}","/** 
 * Create a new SHA1 hash string for the specified file on disk.
 * @param file the file to construct the hash from
 * @return the SHA1 hash string
 * @throws <tt>IOException</tt> if there is an error creating the hash
 * @throws <tt>NoSuchAlgorithmException</tt> if the specified algorithmcannot be found
 */
private static String createSHA1String(final File file) throws IOException {
  FileInputStream fis=new FileInputStream(file);
  MessageDigest md=null;
  try {
    md=MessageDigest.getInstance(""String_Node_Str"");
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IOException(""String_Node_Str"");
  }
  byte[] buffer=new byte[16384];
  int read;
  while ((read=fis.read(buffer)) != -1) {
    long start=System.currentTimeMillis();
    md.update(buffer,0,read);
    long end=System.currentTimeMillis();
    long interval=Math.abs(end - start);
    try {
      Thread.sleep(interval * 2);
    }
 catch (    InterruptedException e) {
    }
  }
  fis.close();
  byte[] sha1=md.digest();
  return UrnType.URN_NAMESPACE_ID + UrnType.SHA1_STRING + Base32.encode(sha1);
}",0.991304347826087
4867,"/** 
 * Walks back through the byte array to trim off null characters and spaces.  A helper for read(...) above.
 * @return the number of bytes with nulls and spaces trimmed.
 */
private static int getTrimmedLength(byte[] bytes,int includedLength){
  int i;
  for (i=includedLength - 1; (i >= 0) && ((bytes[i] == 0) || (bytes[i] == 32)); i--)   ;
  return i + 1;
}","/** 
 * Walks back through the byte array to trim off null characters and spaces.  A helper for read(...) above.
 * @return the number of bytes with nulls and spaces trimmed.
 */
private static int getTrimmedLength(byte[] bytes,int includedLength){
  int i;
  for (i=includedLength - 1; (i >= 0) && ((bytes[i] == 0) || (bytes[i] == 32)); i--)   ;
  for (int j=0; j <= i; j++)   if (bytes[j] == 0)   bytes[j]=(byte)32;
  return i + 1;
}",0.8886107634543179
4868,"/** 
 * Clears this', reloads this' extensions, generates an array of directories, and then indexes the generated directories files. NOTE TO SUBCLASSES: extend this method as needed, it shall be threaded and run asynchronously as to not slow down the main thread (the GUI).
 * @modifies this 
 */
protected void loadSettingsBlocking(boolean notifyOnClear){
  File[] tempDirVar;
synchronized (this) {
    _size=0;
    _numFiles=0;
    _files=new ArrayList();
    _index=new Trie(true);
    _extensions=new TreeSet(new StringComparator());
    _sharedDirectories=new TreeMap(new FileComparator());
    String[] extensions=StringUtils.split(SettingsManager.instance().getExtensions().trim(),';');
    for (int i=0; (i < extensions.length) && !_loadThreadInterrupted; i++)     _extensions.add(extensions[i].toLowerCase());
    final File[] directories=SettingsManager.instance().getDirectories();
    Arrays.sort(directories,new Comparator(){
      public int compare(      Object a,      Object b){
        return (a.toString()).length() - (b.toString()).length();
      }
    }
);
    tempDirVar=directories;
  }
  final File[] directories=tempDirVar;
  if (notifyOnClear)   _callback.clearSharedFiles();
{
    int i=0;
    while (i < directories.length && !_loadThreadInterrupted) {
      addDirectory(directories[i],null);
      i++;
    }
    if (!_loadThreadInterrupted)     trim();
  }
  UrnCache.instance().persistCache();
}","/** 
 * Clears this', reloads this' extensions, generates an array of directories, and then indexes the generated directories files. NOTE TO SUBCLASSES: extend this method as needed, it shall be threaded and run asynchronously as to not slow down the main thread (the GUI).
 * @modifies this 
 */
protected void loadSettingsBlocking(boolean notifyOnClear){
  File[] tempDirVar;
synchronized (this) {
    _size=0;
    _numFiles=0;
    _files=new ArrayList();
    _index=new Trie(true);
    _extensions=new TreeSet(new StringComparator());
    _sharedDirectories=new TreeMap(new FileComparator());
    String[] extensions=StringUtils.split(SettingsManager.instance().getExtensions().trim(),';');
    for (int i=0; (i < extensions.length) && !loadThreadInterrupted(); i++)     _extensions.add(extensions[i].toLowerCase());
    final File[] directories=SettingsManager.instance().getDirectories();
    Arrays.sort(directories,new Comparator(){
      public int compare(      Object a,      Object b){
        return (a.toString()).length() - (b.toString()).length();
      }
    }
);
    tempDirVar=directories;
  }
  final File[] directories=tempDirVar;
  if (notifyOnClear)   _callback.clearSharedFiles();
{
    int i=0;
    while (i < directories.length && !loadThreadInterrupted()) {
      addDirectory(directories[i],null);
      i++;
    }
    if (!loadThreadInterrupted())     trim();
  }
  UrnCache.instance().persistCache();
}",0.9968520461699896
4869,"/** 
 * @requires directory is part of DIRECTORIES_TO_SEARCH_FOR_FILES or one ofits children, and parent is directory's shared parent or null if directory's parent is not shared.
 * @modifies this
 * @effects adds all files with shared extensions in directory and its(recursive) children to this.  If directory doesn't exist, isn't a  directory, or has already been added, does nothing.  Entries in this  before the call are unmodified. This method is thread-safe.  It acquires locks on a per-file basis. If the _loadThread is interrupted while adding the contents of the directory, it returns immediately.  
 */
private void addDirectory(File directory,File parent){
  try {
    directory=getCanonicalFile(directory);
  }
 catch (  IOException e) {
    return;
  }
  File[] file_list=listFiles(directory);
  if (file_list == null)   return;
  int n=file_list.length;
synchronized (this) {
    if (_sharedDirectories.get(directory) != null)     return;
    _sharedDirectories.put(directory,new IntSet());
    if (_callback != null)     _callback.addSharedDirectory(directory,parent);
  }
  List directories=new ArrayList();
  for (int i=0; i < n && !_loadThreadInterrupted; i++) {
    if (file_list[i].isDirectory())     directories.add(file_list[i]);
 else     addFile((File)file_list[i]);
  }
  Iterator iter=directories.iterator();
  while (iter.hasNext() && !_loadThreadInterrupted)   addDirectory((File)iter.next(),directory);
}","/** 
 * @requires directory is part of DIRECTORIES_TO_SEARCH_FOR_FILES or one ofits children, and parent is directory's shared parent or null if directory's parent is not shared.
 * @modifies this
 * @effects adds all files with shared extensions in directory and its(recursive) children to this.  If directory doesn't exist, isn't a  directory, or has already been added, does nothing.  Entries in this  before the call are unmodified. This method is thread-safe.  It acquires locks on a per-file basis. If the _loadThread is interrupted while adding the contents of the directory, it returns immediately.  
 */
private void addDirectory(File directory,File parent){
  try {
    directory=getCanonicalFile(directory);
  }
 catch (  IOException e) {
    return;
  }
  File[] file_list=listFiles(directory);
  if (file_list == null)   return;
  int n=file_list.length;
synchronized (this) {
    if (_sharedDirectories.get(directory) != null)     return;
    _sharedDirectories.put(directory,new IntSet());
    if (_callback != null)     _callback.addSharedDirectory(directory,parent);
  }
  List directories=new ArrayList();
  for (int i=0; i < n && !loadThreadInterrupted(); i++) {
    if (file_list[i].isDirectory())     directories.add(file_list[i]);
 else     addFile((File)file_list[i]);
  }
  Iterator iter=directories.iterator();
  while (iter.hasNext() && !loadThreadInterrupted())   addDirectory((File)iter.next(),directory);
}",0.997907949790795
4870,"/** 
 * @requires the given file exists and is in a shared directory
 * @modifies this
 * @effects adds the given file to this if it is of the proper extension andnot too big (>~2GB).  Returns true iff the file was actually added. <b>WARNING: this is a potential security hazard; caller must ensure the file is in the shared directory.</b> 
 */
private boolean addFile(File file){
  repOk();
  if (!hasExtension(file.getName())) {
    return false;
  }
  long fileLength=file.length();
  if (fileLength > Integer.MAX_VALUE || fileLength < 0)   return false;
  Set urns=FileDesc.calculateAndCacheURN(file);
  if (_loadThreadInterrupted)   return false;
synchronized (this) {
    _size+=fileLength;
    int fileIndex=_files.size();
    FileDesc fileDesc=new FileDesc(file,urns,fileIndex);
    _files.add(fileDesc);
    _numFiles++;
    File parent=getParentFile(file);
    Assert.that(parent != null,""String_Node_Str"" + file + ""String_Node_Str"");
    IntSet siblings=(IntSet)_sharedDirectories.get(parent);
    Assert.that(siblings != null,""String_Node_Str"" + parent + ""String_Node_Str""+ _sharedDirectories);
    boolean added=siblings.add(fileIndex);
    Assert.that(added,""String_Node_Str"" + fileIndex + ""String_Node_Str""+ siblings);
    if (_callback != null)     _callback.addSharedFile(file,parent);
    String path=file.getAbsolutePath();
    String[] keywords=StringUtils.split(path,DELIMETERS);
    for (int i=0; i < keywords.length; i++) {
      String keyword=keywords[i];
      IntSet indices=(IntSet)_index.get(keyword);
      if (indices == null) {
        indices=new IntSet();
        _index.add(keyword,indices);
      }
      indices.add(fileIndex);
    }
    this.updateUrnIndex(fileDesc);
    repOk();
    return true;
  }
}","/** 
 * @requires the given file exists and is in a shared directory
 * @modifies this
 * @effects adds the given file to this if it is of the proper extension andnot too big (>~2GB).  Returns true iff the file was actually added. <b>WARNING: this is a potential security hazard; caller must ensure the file is in the shared directory.</b> 
 */
private boolean addFile(File file){
  repOk();
  if (!hasExtension(file.getName())) {
    return false;
  }
  long fileLength=file.length();
  if (fileLength > Integer.MAX_VALUE || fileLength < 0)   return false;
  Set urns=FileDesc.calculateAndCacheURN(file);
  if (loadThreadInterrupted())   return false;
synchronized (this) {
    _size+=fileLength;
    int fileIndex=_files.size();
    FileDesc fileDesc=new FileDesc(file,urns,fileIndex);
    _files.add(fileDesc);
    _numFiles++;
    File parent=getParentFile(file);
    Assert.that(parent != null,""String_Node_Str"" + file + ""String_Node_Str"");
    IntSet siblings=(IntSet)_sharedDirectories.get(parent);
    Assert.that(siblings != null,""String_Node_Str"" + parent + ""String_Node_Str""+ _sharedDirectories);
    boolean added=siblings.add(fileIndex);
    Assert.that(added,""String_Node_Str"" + fileIndex + ""String_Node_Str""+ siblings);
    if (_callback != null)     _callback.addSharedFile(file,parent);
    String path=file.getAbsolutePath();
    String[] keywords=StringUtils.split(path,DELIMETERS);
    for (int i=0; i < keywords.length; i++) {
      String keyword=keywords[i];
      IntSet indices=(IntSet)_index.get(keyword);
      if (indices == null) {
        indices=new IntSet();
        _index.add(keyword,indices);
      }
      indices.add(fileIndex);
    }
    this.updateUrnIndex(fileDesc);
    repOk();
    return true;
  }
}",0.9991386735572784
4871,"/** 
 * This method overrides FileManager.loadSettingsBlocking(), though it calls the super method to load up the shared file DB.  Then, it processes these files and annotates them automatically as apropos. TODO2: Eventually we will think that its too much of a burden to have this thread be blocking in which case we will have to  have the load thread also handle the reloading of the meta-data. Question: Do we really want to reload the meta-data whenever a we want to update the file information?? It depends on how we want to  handle the meta-data and its relation to the file system
 */
protected void loadSettingsBlocking(boolean notifyOnClear){
  super.loadSettingsBlocking(notifyOnClear);
  if (Thread.currentThread().isInterrupted())   return;
synchronized (metaLocker) {
    if (!initialized) {
      fileToHash.clear();
      createFileToHashMaps();
      SchemaReplyCollectionMapper mapper=SchemaReplyCollectionMapper.instance();
      LimeXMLSchemaRepository schemaRepository=LimeXMLSchemaRepository.instance();
      if (Thread.currentThread().isInterrupted())       return;
      String[] schemas=schemaRepository.getAvailableSchemaURIs();
      int len=schemas.length;
      LimeXMLReplyCollection collection;
      for (int i=0; (i < len) && !Thread.currentThread().isInterrupted(); i++) {
        String s=LimeXMLSchema.getDisplayString(schemas[i]);
        collection=new LimeXMLReplyCollection(fileToHash,schemas[i],this,s.equalsIgnoreCase(""String_Node_Str""));
        mapper.add(schemas[i],collection);
      }
    }
  }
}","/** 
 * This method overrides FileManager.loadSettingsBlocking(), though it calls the super method to load up the shared file DB.  Then, it processes these files and annotates them automatically as apropos. TODO2: Eventually we will think that its too much of a burden to have this thread be blocking in which case we will have to  have the load thread also handle the reloading of the meta-data. Question: Do we really want to reload the meta-data whenever a we want to update the file information?? It depends on how we want to  handle the meta-data and its relation to the file system
 */
protected void loadSettingsBlocking(boolean notifyOnClear){
  super.loadSettingsBlocking(notifyOnClear);
  if (loadThreadInterrupted())   return;
synchronized (metaLocker) {
    if (!initialized) {
      fileToHash.clear();
      createFileToHashMaps();
      SchemaReplyCollectionMapper mapper=SchemaReplyCollectionMapper.instance();
      LimeXMLSchemaRepository schemaRepository=LimeXMLSchemaRepository.instance();
      if (loadThreadInterrupted())       return;
      String[] schemas=schemaRepository.getAvailableSchemaURIs();
      int len=schemas.length;
      LimeXMLReplyCollection collection;
      for (int i=0; (i < len) && !loadThreadInterrupted(); i++) {
        String s=LimeXMLSchema.getDisplayString(schemas[i]);
        collection=new LimeXMLReplyCollection(fileToHash,schemas[i],this,s.equalsIgnoreCase(""String_Node_Str""));
        mapper.add(schemas[i],collection);
      }
    }
  }
}",0.9773100953633672
4872,"/** 
 * Scans all the shared directories recursively and finds files that have .mp3 extension, and adds them to a hashmap keyed by hashes. <p>  Also creates another map that stores the hash to File of non mp3 files
 */
private void createFileToHashMaps(){
  SettingsManager man=SettingsManager.instance();
  ArrayList dirs=new ArrayList(Arrays.asList(man.getDirectories()));
  int k=0;
  while (k < dirs.size()) {
    File currDir=(File)dirs.get(k);
    k++;
    String[] subFiles=currDir.list();
    int z=subFiles.length;
    for (int j=0; j < z; j++) {
      File f=new File(currDir,subFiles[j]);
      if (f.isDirectory())       dirs.add(f);
    }
    File[] files=getSharedFiles(currDir);
    int size=0;
    if (files != null)     size=files.length;
    for (int i=0; i < size; i++) {
      String name=""String_Node_Str"";
      String hash=""String_Node_Str"";
      try {
        name=files[i].getCanonicalPath();
        hash=new String(LimeXMLUtils.hashFile(files[i]));
      }
 catch (      Exception e) {
        continue;
      }
      writeToMap(files[i],hash);
    }
  }
}","/** 
 * Scans all the shared directories recursively and finds files that have .mp3 extension, and adds them to a hashmap keyed by hashes. <p>  Also creates another map that stores the hash to File of non mp3 files
 */
private void createFileToHashMaps(){
  SettingsManager man=SettingsManager.instance();
  ArrayList dirs=new ArrayList(Arrays.asList(man.getDirectories()));
  int k=0;
  while (k < dirs.size() && !loadThreadInterrupted()) {
    File currDir=(File)dirs.get(k);
    k++;
    String[] subFiles=currDir.list();
    int z=subFiles.length;
    for (int j=0; j < z; j++) {
      File f=new File(currDir,subFiles[j]);
      if (f.isDirectory())       dirs.add(f);
    }
    File[] files=getSharedFiles(currDir);
    int size=0;
    if (files != null)     size=files.length;
    for (int i=0; i < size && !loadThreadInterrupted(); i++) {
      String name=""String_Node_Str"";
      String hash=""String_Node_Str"";
      try {
        name=files[i].getCanonicalPath();
        hash=new String(LimeXMLUtils.hashFile(files[i]));
      }
 catch (      Exception e) {
        continue;
      }
      writeToMap(files[i],hash);
    }
  }
}",0.974820143884892
4873,"/** 
 * Build a new query with data snatched from network
 * @requires payload.length>=3
 */
public QueryRequest(byte[] guid,byte ttl,byte hops,byte[] payload){
  super(guid,Message.F_QUERY,ttl,hops,payload.length);
  if (payload == null) {
    this.payload=EMPTY_BYTE_ARRAY;
  }
 else {
    this.payload=payload;
  }
  String tempQuery=""String_Node_Str"";
  String tempRichQuery=""String_Node_Str"";
  int tempMinSpeed=0;
  Set tempQueryUrns=null;
  Set tempRequestedUrnTypes=null;
  try {
    ByteArrayInputStream bais=new ByteArrayInputStream(this.payload);
    short sp=ByteOrder.leb2short(bais);
    tempMinSpeed=ByteOrder.ubytes2int(sp);
    tempQuery=super.readNullTerminatedString(bais);
    String exts=super.readNullTerminatedString(bais);
    StringTokenizer stok=new StringTokenizer(exts,""String_Node_Str"");
    while (stok.hasMoreElements()) {
      String curExtStr=stok.nextToken();
      if (URN.isUrn(curExtStr)) {
        URN urn=null;
        try {
          urn=URN.createSHA1Urn(curExtStr);
        }
 catch (        IOException e) {
          continue;
        }
        if (tempQueryUrns == null) {
          tempQueryUrns=new HashSet();
        }
        tempQueryUrns.add(urn);
        if (tempRequestedUrnTypes == null) {
          tempRequestedUrnTypes=new HashSet();
        }
        tempRequestedUrnTypes.add(urn.getUrnType());
      }
 else       if (UrnType.isSupportedUrnType(curExtStr)) {
        if (tempRequestedUrnTypes == null) {
          tempRequestedUrnTypes=new HashSet();
        }
        tempRequestedUrnTypes.add(curExtStr);
      }
 else       if (curExtStr.startsWith(""String_Node_Str"")) {
        tempRichQuery=curExtStr;
      }
    }
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
  }
  query=tempQuery;
  richQuery=tempRichQuery;
  minSpeed=tempMinSpeed;
  if (tempQueryUrns == null) {
    this.queryUrns=EMPTY_SET;
  }
 else {
    this.queryUrns=Collections.unmodifiableSet(tempQueryUrns);
  }
  if (tempRequestedUrnTypes == null) {
    this.requestedUrnTypes=EMPTY_SET;
  }
 else {
    this.requestedUrnTypes=Collections.unmodifiableSet(tempRequestedUrnTypes);
  }
}","/** 
 * Build a new query with data snatched from network
 * @requires payload.length>=3
 */
public QueryRequest(byte[] guid,byte ttl,byte hops,byte[] payload){
  super(guid,Message.F_QUERY,ttl,hops,payload.length);
  if (payload == null) {
    this.payload=EMPTY_BYTE_ARRAY;
  }
 else {
    this.payload=payload;
  }
  String tempQuery=""String_Node_Str"";
  String tempRichQuery=""String_Node_Str"";
  int tempMinSpeed=0;
  Set tempQueryUrns=null;
  Set tempRequestedUrnTypes=null;
  try {
    ByteArrayInputStream bais=new ByteArrayInputStream(this.payload);
    short sp=ByteOrder.leb2short(bais);
    tempMinSpeed=ByteOrder.ubytes2int(sp);
    tempQuery=super.readNullTerminatedString(bais);
    String exts=super.readNullTerminatedString(bais);
    StringTokenizer stok=new StringTokenizer(exts,""String_Node_Str"");
    while (stok.hasMoreElements()) {
      String curExtStr=stok.nextToken();
      if (URN.isUrn(curExtStr)) {
        URN urn=null;
        try {
          urn=URN.createSHA1Urn(curExtStr);
        }
 catch (        IOException e) {
          continue;
        }
        if (tempQueryUrns == null) {
          tempQueryUrns=new HashSet();
        }
        tempQueryUrns.add(urn);
      }
 else       if (UrnType.isSupportedUrnType(curExtStr)) {
        if (tempRequestedUrnTypes == null) {
          tempRequestedUrnTypes=new HashSet();
        }
        tempRequestedUrnTypes.add(UrnType.createUrnType(curExtStr));
      }
 else       if (curExtStr.startsWith(""String_Node_Str"")) {
        tempRichQuery=curExtStr;
      }
    }
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
  }
  query=tempQuery;
  richQuery=tempRichQuery;
  minSpeed=tempMinSpeed;
  if (tempQueryUrns == null) {
    this.queryUrns=EMPTY_SET;
  }
 else {
    this.queryUrns=Collections.unmodifiableSet(tempQueryUrns);
  }
  if (tempRequestedUrnTypes == null) {
    this.requestedUrnTypes=EMPTY_SET;
  }
 else {
    this.requestedUrnTypes=Collections.unmodifiableSet(tempRequestedUrnTypes);
  }
}",0.9568798449612403
4874,"/** 
 * Sets the name of the jar file to load on startup, which is read in from the properties file by RunLime.
 * @param jarName the name of the jar file to load
 */
public void setJarName(final String jarName){
  setStringValue(JAR_NAME,jarName);
}","/** 
 * Sets the name of the jar file to load on startup, which is read in from the properties file by RunLime.
 * @param jarName the name of the jar file to load
 */
public void setJarName(final String jarName){
  setStringValue(JAR_NAME,jarName);
  setClasspath(jarName);
}",0.9523809523809524
4875,"/** 
 * Sets the classpath for legacy RunLime.jars.
 * @param classpath the classpath to set
 */
public void setClasspath(final String classpath){
  setStringValue(CLASSPATH,classpath);
}","/** 
 * Sets the classpath for legacy RunLime.jars.
 * @param classpath the classpath to set
 */
private void setClasspath(final String classpath){
  setStringValue(CLASSPATH,classpath);
  setJarName(classpath);
}",0.91
4876,"/** 
 * Sets the name of the jar file to load on startup, which is read in from the properties file by RunLime.
 * @param jarName the name of the jar file to load
 */
public void setJarName(final String jarName){
  setStringValue(JAR_NAME,jarName);
  setStringValue(CLASSPATH,jarName);
}","/** 
 * Sets the name of the jar file to load on startup, which is read in from the properties file by RunLime.
 * @param jarName the name of the jar file to load
 */
public void setJarName(final String jarName){
  setStringValue(JAR_NAME,jarName);
}",0.931098696461825
4877,"/** 
 * Load in the default values.  Any properties written to the real  properties file will overwrite these. This method ensures that some reasonable values are always loaded even in the case of any failure in loading the properties file from disk.
 */
public void loadDefaults(){
  setAllowBrowser(DEFAULT_ALLOW_BROWSER);
  setMaxTTL(DEFAULT_MAX_TTL);
  setSoftMaxTTL(DEFAULT_SOFT_MAX_TTL);
  setTTL(DEFAULT_TTL);
  setMaxLength(DEFAULT_MAX_LENGTH);
  setTimeout(DEFAULT_TIMEOUT);
  setPersistentHTTPConnectionTimeout(DEFAULT_PERSISTENT_HTTP_CONNECTION_TIMEOUT);
  setKeepAlive(DEFAULT_KEEP_ALIVE);
  setPort(DEFAULT_PORT);
  setConnectionSpeed(DEFAULT_SPEED);
  setUploadSpeed(DEFAULT_UPLOAD_SPEED);
  setSearchLimit(DEFAULT_SEARCH_LIMIT);
  setClientID((new GUID(Message.makeGuid())).toHexString());
  setBannedIps(DEFAULT_BANNED_IPS);
  setAllowedIps(DEFAULT_ALLOWED_IPS);
  setBannedWords(DEFAULT_BANNED_WORDS);
  setFilterAdult(DEFAULT_FILTER_ADULT);
  setFilterDuplicates(DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(DEFAULT_FILTER_VBS);
  setFilterHtml(DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setExtensions(DEFAULT_EXTENSIONS);
  setBannedIps(DEFAULT_BANNED_IPS);
  setBannedWords(DEFAULT_BANNED_WORDS);
  setFilterAdult(DEFAULT_FILTER_ADULT);
  setFilterDuplicates(DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(DEFAULT_FILTER_VBS);
  setFilterHtml(DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setFilterBearShareQueries(DEFAULT_FILTER_BEARSHARE_QUERIES);
  setUseQuickConnect(DEFAULT_USE_QUICK_CONNECT);
  setQuickConnectHosts(DEFAULT_QUICK_CONNECT_HOSTS);
  setParallelSearchMax(DEFAULT_PARALLEL_SEARCH);
  setClearCompletedUpload(DEFAULT_CLEAR_UPLOAD);
  setClearCompletedDownload(DEFAULT_CLEAR_DOWNLOAD);
  setMaxSimDownload(DEFAULT_MAX_SIM_DOWNLOAD);
  setPromptExeDownload(DEFAULT_PROMPT_EXE_DOWNLOAD);
  setMaxUploads(DEFAULT_MAX_UPLOADS);
  setSoftMaxUploads(DEFAULT_SOFT_MAX_UPLOADS);
  setConnectString(DEFAULT_CONNECT_STRING);
  setConnectOkString(DEFAULT_CONNECT_OK_STRING);
  setCheckAgain(DEFAULT_CHECK_AGAIN);
  setBasicInfoForQuery(DEFAULT_BASIC_INFO_FOR_QUERY);
  setAdvancedInfoForQuery(DEFAULT_ADVANCED_INFO_FOR_QUERY);
  setForceIPAddress(DEFAULT_FORCE_IP_ADDRESS);
  setForcedIPAddressString(DEFAULT_FORCED_IP_ADDRESS_STRING);
  setForcedPort(DEFAULT_FORCED_PORT);
  setFreeloaderFiles(DEFAULT_FREELOADER_FILES);
  setFreeloaderAllowed(DEFAULT_FREELOADER_ALLOWED);
  setUploadsPerPerson(DEFAULT_UPLOADS_PER_PERSON);
  setAverageUptime(DEFAULT_AVERAGE_UPTIME);
  setTotalUptime(DEFAULT_TOTAL_UPTIME);
  setLastShutdownTime(DEFAULT_LAST_SHUTDOWN_TIME);
  setFractionalUptime(DEFAULT_FRACTIONAL_UPTIME);
  setServantType(DEFAULT_SERVANT_TYPE);
  setInstalled(DEFAULT_INSTALLED);
  setRunOnce(DEFAULT_RUN_ONCE);
  setMinimizeToTray(DEFAULT_MINIMIZE_TO_TRAY);
  setShutdownAfterTransfers(DEFAULT_SHUTDOWN_AFTER_TRANSFERS);
  setAppWidth(DEFAULT_APP_WIDTH);
  setAppHeight(DEFAULT_APP_HEIGHT);
  setChatEnabled(DEFAULT_CHAT_ENABLED);
  setPlayerEnabled(DEFAULT_PLAYER_ENABLED);
  setBrowser(getDefaultBrowser());
  setMonitorViewEnabled(DEFAULT_MONITOR_VIEW_ENABLED);
  setConnectionViewEnabled(DEFAULT_CONNECTION_VIEW_ENABLED);
  setLibraryViewEnabled(DEFAULT_LIBRARY_VIEW_ENABLED);
  setShoppingViewEnabled(DEFAULT_SHOPPING_VIEW_ENABLED);
  setLanguage(DEFAULT_LANGUAGE);
  setCountry(DEFAULT_COUNTRY);
  setMinimumSearchQuality(DEFAULT_MINIMUM_SEARCH_QUALITY);
  setMinimumSearchSpeed(DEFAULT_MINIMUM_SEARCH_SPEED);
  setEverAcceptedIncoming(DEFAULT_EVER_ACCEPTED_INCOMING);
  setMaxUpstreamBytesPerSec(DEFAULT_MAX_UPSTREAM_BYTES_PER_SEC);
  setMaxDownstreamBytesPerSec(DEFAULT_MAX_DOWNSTREAM_BYTES_PER_SEC);
  setEverSupernodeCapable(DEFAULT_EVER_SUPERNODE_CAPABLE);
  setDisableSupernodeMode(DEFAULT_DISABLE_SUPERNODE_MODE);
  setForceSupernodeMode(DEFAULT_FORCE_SUPERNODE_MODE);
  setMaxShieldedClientConnections(DEFAULT_MAX_SHIELDED_CLIENT_CONNECTIONS);
  setMinShieldedClientConnections(DEFAULT_MIN_SHIELDED_CLIENT_CONNECTIONS);
  setAcceptAuthenticatedConnectionsOnly(DEFAULT_ACCEPT_AUTHENTICATED_CONNECTIONS_ONLY);
  setCookiesFile(DEFAULT_COOKIES_FILE);
  setServer(DEFAULT_SERVER);
  setSessions(DEFAULT_SESSIONS);
  setAverageUptime(DEFAULT_AVERAGE_UPTIME);
  setTotalUptime(DEFAULT_TOTAL_UPTIME);
  setConnectOnStartup(DEFAULT_CONNECT_ON_STARTUP);
  setIncompletePurgeTime(DEFAULT_INCOMPLETE_PURGE_TIME);
  setLastExpireTime(DEFAULT_LAST_EXPIRE_TIME);
  setAdVersion(DEFAULT_AD_VERSION);
  setJarName(DEFAULT_JAR_NAME);
}","/** 
 * Load in the default values.  Any properties written to the real  properties file will overwrite these. This method ensures that some reasonable values are always loaded even in the case of any failure in loading the properties file from disk.
 */
public void loadDefaults(){
  setAllowBrowser(DEFAULT_ALLOW_BROWSER);
  setMaxTTL(DEFAULT_MAX_TTL);
  setSoftMaxTTL(DEFAULT_SOFT_MAX_TTL);
  setTTL(DEFAULT_TTL);
  setMaxLength(DEFAULT_MAX_LENGTH);
  setTimeout(DEFAULT_TIMEOUT);
  setPersistentHTTPConnectionTimeout(DEFAULT_PERSISTENT_HTTP_CONNECTION_TIMEOUT);
  setKeepAlive(DEFAULT_KEEP_ALIVE);
  setPort(DEFAULT_PORT);
  setConnectionSpeed(DEFAULT_SPEED);
  setUploadSpeed(DEFAULT_UPLOAD_SPEED);
  setSearchLimit(DEFAULT_SEARCH_LIMIT);
  setClientID((new GUID(Message.makeGuid())).toHexString());
  setBannedIps(DEFAULT_BANNED_IPS);
  setAllowedIps(DEFAULT_ALLOWED_IPS);
  setBannedWords(DEFAULT_BANNED_WORDS);
  setFilterAdult(DEFAULT_FILTER_ADULT);
  setFilterDuplicates(DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(DEFAULT_FILTER_VBS);
  setFilterHtml(DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setExtensions(DEFAULT_EXTENSIONS);
  setBannedIps(DEFAULT_BANNED_IPS);
  setBannedWords(DEFAULT_BANNED_WORDS);
  setFilterAdult(DEFAULT_FILTER_ADULT);
  setFilterDuplicates(DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(DEFAULT_FILTER_VBS);
  setFilterHtml(DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setFilterBearShareQueries(DEFAULT_FILTER_BEARSHARE_QUERIES);
  setUseQuickConnect(DEFAULT_USE_QUICK_CONNECT);
  setQuickConnectHosts(DEFAULT_QUICK_CONNECT_HOSTS);
  setParallelSearchMax(DEFAULT_PARALLEL_SEARCH);
  setClearCompletedUpload(DEFAULT_CLEAR_UPLOAD);
  setClearCompletedDownload(DEFAULT_CLEAR_DOWNLOAD);
  setMaxSimDownload(DEFAULT_MAX_SIM_DOWNLOAD);
  setPromptExeDownload(DEFAULT_PROMPT_EXE_DOWNLOAD);
  setMaxUploads(DEFAULT_MAX_UPLOADS);
  setSoftMaxUploads(DEFAULT_SOFT_MAX_UPLOADS);
  setConnectString(DEFAULT_CONNECT_STRING);
  setConnectOkString(DEFAULT_CONNECT_OK_STRING);
  setCheckAgain(DEFAULT_CHECK_AGAIN);
  setBasicInfoForQuery(DEFAULT_BASIC_INFO_FOR_QUERY);
  setAdvancedInfoForQuery(DEFAULT_ADVANCED_INFO_FOR_QUERY);
  setForceIPAddress(DEFAULT_FORCE_IP_ADDRESS);
  setForcedIPAddressString(DEFAULT_FORCED_IP_ADDRESS_STRING);
  setForcedPort(DEFAULT_FORCED_PORT);
  setFreeloaderFiles(DEFAULT_FREELOADER_FILES);
  setFreeloaderAllowed(DEFAULT_FREELOADER_ALLOWED);
  setUploadsPerPerson(DEFAULT_UPLOADS_PER_PERSON);
  setAverageUptime(DEFAULT_AVERAGE_UPTIME);
  setTotalUptime(DEFAULT_TOTAL_UPTIME);
  setLastShutdownTime(DEFAULT_LAST_SHUTDOWN_TIME);
  setFractionalUptime(DEFAULT_FRACTIONAL_UPTIME);
  setServantType(DEFAULT_SERVANT_TYPE);
  setInstalled(DEFAULT_INSTALLED);
  setRunOnce(DEFAULT_RUN_ONCE);
  setMinimizeToTray(DEFAULT_MINIMIZE_TO_TRAY);
  setShutdownAfterTransfers(DEFAULT_SHUTDOWN_AFTER_TRANSFERS);
  setAppWidth(DEFAULT_APP_WIDTH);
  setAppHeight(DEFAULT_APP_HEIGHT);
  setChatEnabled(DEFAULT_CHAT_ENABLED);
  setPlayerEnabled(DEFAULT_PLAYER_ENABLED);
  setBrowser(getDefaultBrowser());
  setMonitorViewEnabled(DEFAULT_MONITOR_VIEW_ENABLED);
  setConnectionViewEnabled(DEFAULT_CONNECTION_VIEW_ENABLED);
  setLibraryViewEnabled(DEFAULT_LIBRARY_VIEW_ENABLED);
  setShoppingViewEnabled(DEFAULT_SHOPPING_VIEW_ENABLED);
  setLanguage(DEFAULT_LANGUAGE);
  setCountry(DEFAULT_COUNTRY);
  setMinimumSearchQuality(DEFAULT_MINIMUM_SEARCH_QUALITY);
  setMinimumSearchSpeed(DEFAULT_MINIMUM_SEARCH_SPEED);
  setEverAcceptedIncoming(DEFAULT_EVER_ACCEPTED_INCOMING);
  setMaxUpstreamBytesPerSec(DEFAULT_MAX_UPSTREAM_BYTES_PER_SEC);
  setMaxDownstreamBytesPerSec(DEFAULT_MAX_DOWNSTREAM_BYTES_PER_SEC);
  setEverSupernodeCapable(DEFAULT_EVER_SUPERNODE_CAPABLE);
  setDisableSupernodeMode(DEFAULT_DISABLE_SUPERNODE_MODE);
  setForceSupernodeMode(DEFAULT_FORCE_SUPERNODE_MODE);
  setMaxShieldedClientConnections(DEFAULT_MAX_SHIELDED_CLIENT_CONNECTIONS);
  setMinShieldedClientConnections(DEFAULT_MIN_SHIELDED_CLIENT_CONNECTIONS);
  setAcceptAuthenticatedConnectionsOnly(DEFAULT_ACCEPT_AUTHENTICATED_CONNECTIONS_ONLY);
  setCookiesFile(DEFAULT_COOKIES_FILE);
  setServer(DEFAULT_SERVER);
  setSessions(DEFAULT_SESSIONS);
  setAverageUptime(DEFAULT_AVERAGE_UPTIME);
  setTotalUptime(DEFAULT_TOTAL_UPTIME);
  setConnectOnStartup(DEFAULT_CONNECT_ON_STARTUP);
  setIncompletePurgeTime(DEFAULT_INCOMPLETE_PURGE_TIME);
  setLastExpireTime(DEFAULT_LAST_EXPIRE_TIME);
  setAdVersion(DEFAULT_AD_VERSION);
  setJarName(DEFAULT_JAR_NAME);
  setClasspath(DEFAULT_CLASSPATH);
}",0.996152577772892
4878,"/** 
 * Creates a new <tt>Date</tt> instance from the date specified in the alternate location header.
 * @param dateTimeString the extracted date-time string from thealternate location header
 * @return a new <tt>Date</tt> instance for the date specified inthe header, or a new <tt>Date</tt> instance of the oldest possible date (according to the <tt>Date</tt> class) in the case  where no timestamp data could be successfully created
 */
private static Date createDateInstance(final String dateTimeString){
  int dateTimeSepIndex=dateTimeString.indexOf(""String_Node_Str"");
  if ((dateTimeSepIndex == -1) || ((dateTimeSepIndex + 1) >= dateTimeString.length())) {
    return new Date(0);
  }
  String YYYYMMDD=dateTimeString.substring(0,dateTimeSepIndex);
  String hhmmss=dateTimeString.substring(dateTimeSepIndex + 1,dateTimeString.length() - 1);
  StringTokenizer stdate=new StringTokenizer(YYYYMMDD,""String_Node_Str"");
  if (stdate.countTokens() != 3) {
    return null;
  }
  String YYYYStr=stdate.nextToken();
  String MMStr=stdate.nextToken();
  String DDStr=stdate.nextToken();
  int YYYY=Integer.parseInt(YYYYStr);
  int MM=Integer.parseInt(MMStr) - 1;
  int DD=Integer.parseInt(DDStr);
  StringTokenizer sttime=new StringTokenizer(hhmmss,""String_Node_Str"");
  if (sttime.countTokens() != 3) {
    return new Date(0);
  }
  String hhStr=sttime.nextToken();
  String mmStr=sttime.nextToken();
  String ssStr=sttime.nextToken();
  int hh=Integer.parseInt(hhStr);
  int mm=Integer.parseInt(mmStr);
  int ss=Integer.parseInt(ssStr);
  Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
  cal.set(YYYY,MM,DD,hh,mm,ss);
  return cal.getTime();
}","/** 
 * Creates a new <tt>Date</tt> instance from the date specified in the alternate location header.
 * @param dateTimeString the extracted date-time string from thealternate location header
 * @return a new <tt>Date</tt> instance for the date specified inthe header, or a new <tt>Date</tt> instance of the oldest possible date (according to the <tt>Date</tt> class) in the case  where no timestamp data could be successfully created
 */
private static Date createDateInstance(final String dateTimeString){
  StringTokenizer st=new StringTokenizer(dateTimeString,""String_Node_Str"");
  int tokens=st.countTokens();
  if (tokens < 1 || tokens > 2) {
    return new Date(0);
  }
  String YYYYMMDD=st.nextToken();
  StringTokenizer stdate=new StringTokenizer(YYYYMMDD,""String_Node_Str"");
  if (stdate.countTokens() != 3) {
    return new Date(0);
  }
  String YYYYStr=stdate.nextToken();
  String MMStr=stdate.nextToken();
  String DDStr=stdate.nextToken();
  int YYYY=Integer.parseInt(YYYYStr);
  try {
    int MM=Integer.parseInt(MMStr) - 1;
    int DD=Integer.parseInt(DDStr);
    if (!st.hasMoreTokens()) {
      Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
      cal.set(YYYY,MM,DD);
      return cal.getTime();
    }
    String hhmmss=st.nextToken();
    if (!hhmmss.endsWith(""String_Node_Str"")) {
      return new Date(0);
    }
    hhmmss=hhmmss.substring(0,hhmmss.length() - 1);
    StringTokenizer sttime=new StringTokenizer(hhmmss,""String_Node_Str"");
    int numToks=sttime.countTokens();
    if (numToks < 2 || numToks > 3) {
      return new Date(0);
    }
    String hhStr=sttime.nextToken();
    String mmStr=sttime.nextToken();
    int hh=Integer.parseInt(hhStr);
    int mm=Integer.parseInt(mmStr);
    Calendar cal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
    if (sttime.hasMoreTokens()) {
      String ssStr=sttime.nextToken().substring(0,2);
      int ss=Integer.parseInt(ssStr);
      cal.set(YYYY,MM,DD,hh,mm,ss);
    }
 else {
      cal.set(YYYY,MM,DD,hh,mm);
    }
    return cal.getTime();
  }
 catch (  NumberFormatException e) {
    return new Date(0);
  }
}",0.5320378151260504
4879,"/** 
 * Checks to see if the specified date string is valid, according to our interpretation.  First, we are requiring date formats of the  form specified at: http://www.w3.org/TR/NOTE-datetime, a subset of  ISO 8601.  In addition to this, we require that the date at least specify the day of the month.  If it does not do this, it is so  general that it is useless for our purposes.
 * @param date the date string to validate
 * @return <tt>true</tt> if the string represents a valid date according to our critetia, <tt>false</tt> otherwise
 */
private static boolean isValidDate(final String date){
  int length=date.length();
  final String DASH=""String_Node_Str"";
  final String COLON=""String_Node_Str"";
  if (length < 10)   return false;
  if ((length != 10) && (length != 17) && (length != 20)&& (length != 22)) {
    return false;
  }
  if (!date.startsWith(""String_Node_Str"")) {
    return false;
  }
  int firstDashIndex=date.indexOf(DASH);
  int secondDashIndex=date.indexOf(DASH,firstDashIndex + 1);
  if ((firstDashIndex == -1) || (secondDashIndex == -1)) {
    return false;
  }
  if (length == 10)   return true;
  int firstColonIndex=date.indexOf(COLON);
  int secondColonIndex=date.indexOf(COLON,firstColonIndex + 1);
  if ((firstColonIndex != 13) || (secondColonIndex != 16)) {
    return false;
  }
  return true;
}","/** 
 * Checks to see if the date specified in the given string is a valid date according to the date-time formate specified at:<p> http://www.w3.org/TR/NOTE-datetime
 * @param date the date to check
 * @return <tt>true</tt> if the date fits the standard, <tt>false</tt> otherwise
 */
private static boolean isValidDate(final String date){
  StringTokenizer dateTokenizer=new StringTokenizer(date,""String_Node_Str"");
  if (dateTokenizer.countTokens() != 3) {
    return false;
  }
  String YYYYStr=dateTokenizer.nextToken();
  String MMStr=dateTokenizer.nextToken();
  String DDStr=dateTokenizer.nextToken();
  try {
    int YYYY=Integer.parseInt(YYYYStr);
    int MM=Integer.parseInt(MMStr);
    int DD=Integer.parseInt(DDStr);
    if (YYYY < 2001 || YYYY > 4000)     return false;
    if (MM < 1 || MM > 12)     return false;
    if (DD < 1 || DD > 31)     return false;
  }
 catch (  NumberFormatException e) {
    return false;
  }
  return true;
}",0.1225382932166301
4880,"/** 
 * Compares <tt>AlternateLocation</tt> instances by date.  This compares alternate locations by how ""good"" we think they are, based on their freshness.  So, an natural ordering will provide alternate locations from latest to earliest, as the more recent locations are the preferred locations.
 * @param obj the <tt>Object</tt> instance to be compared
 * @return  the value <tt>0</tt> if the argument is an <tt>AlternateLocation</tt> with a timestamp equal to this  <tt>AlternateLocation</tt>'s timestamp; a value less than <tt>0</tt>  if the argument is an <tt>AlternateLocation</tt> with a timestamp  before this <tt>AlternateLocation</tt>s timestamp; and a value greater  than <tt>0</tt> if the argument is an <tt>AlternateLocation</tt>  with a timestamp after the timestamp of this  <tt>AlternateLocation</tt>
 * @exception <tt>ClassCastException</tt> if the argument is not an<tt>AlternateLocation</tt> 
 * @see java.lang.Comparable
 */
public int compareTo(Object obj){
  if (equals(obj))   return 0;
  if (obj == this)   return 0;
  if (!(obj instanceof AlternateLocation))   return -1;
  AlternateLocation al=(AlternateLocation)obj;
  if (URL.equals(al.URL)) {
    return (this.TIME < al.TIME ? 1 : (this.TIME == al.TIME ? 0 : -1));
  }
  if (isTimestamped() && al.isTimestamped()) {
    return (this.TIME < al.TIME ? 1 : (this.TIME == al.TIME ? -1 : -1));
  }
  if (isTimestamped()) {
    return -1;
  }
  if (al.isTimestamped()) {
    return 1;
  }
  return -1;
}","/** 
 * Compares <tt>AlternateLocation</tt> instances by date.  This compares alternate locations by how ""good"" we think they are, based on their freshness.  So, an natural ordering will provide alternate locations from latest to earliest, as the more recent locations are the preferred locations.
 * @param obj the <tt>Object</tt> instance to be compared
 * @return  the value <tt>0</tt> if the argument is an <tt>AlternateLocation</tt> with a timestamp equal to this  <tt>AlternateLocation</tt>'s timestamp; a value less than <tt>0</tt>  if the argument is an <tt>AlternateLocation</tt> with a timestamp  before this <tt>AlternateLocation</tt>s timestamp; and a value greater  than <tt>0</tt> if the argument is an <tt>AlternateLocation</tt>  with a timestamp after the timestamp of this  <tt>AlternateLocation</tt>
 * @exception <tt>ClassCastException</tt> if the argument is not an<tt>AlternateLocation</tt> 
 * @see java.lang.Comparable
 */
public int compareTo(Object obj){
  if (equals(obj))   return 0;
  if (obj == this)   return 0;
  if (!(obj instanceof AlternateLocation))   return -1;
  AlternateLocation al=(AlternateLocation)obj;
  if (URL.equals(al.URL)) {
    return (this.TIME < al.TIME ? 1 : (this.TIME == al.TIME ? 0 : -1));
  }
  if (isTimestamped() && al.isTimestamped()) {
    if (this.TIME == al.TIME) {
      return URL.toString().compareTo(al.URL.toString());
    }
    return (this.TIME < al.TIME ? 1 : -1);
  }
  if (isTimestamped()) {
    return -1;
  }
  if (al.isTimestamped()) {
    return 1;
  }
  return -1;
}",0.9642384105960264
4881,"/** 
 * Creates a new <tt>AlternateLocation</tt> with the specified <tt>URL</tt> and <tt>Date</tt> timestamp.
 * @param url the <tt>URL</tt> for the <tt>AlternateLocation</tt>
 * @param date the <tt>Date</tt> timestamp for the <tt>AlternateLocation</tt>
 */
private AlternateLocation(final URL url,final Date date){
  this.URL=url;
  this.TIME=date.getTime();
  this.OUTPUT_DATE_TIME=AlternateLocation.convertDateToString(date);
}","/** 
 * Creates a new <tt>AlternateLocation</tt> with the specified <tt>URL</tt> and <tt>Date</tt> timestamp.
 * @param url the <tt>URL</tt> for the <tt>AlternateLocation</tt>
 * @param date the <tt>Date</tt> timestamp for the <tt>AlternateLocation</tt>
 */
private AlternateLocation(final URL url,final Date date){
  this.URL=url;
  this.TIME=date.getTime();
  if (TIME == 0) {
    this.OUTPUT_DATE_TIME=null;
  }
 else {
    this.OUTPUT_DATE_TIME=AlternateLocation.convertDateToString(date);
  }
}",0.8891280947255114
4882,"/** 
 * Parses out the timestamp string from the alternate location header string, throwing an exception if there is any error.
 * @param location the full alternate-location HTTP header string,as specified in HUGE v0.93
 * @return the date/time string from the the alternate locationheader, or <tt>null</tt> if the date/time string could not be extracted, is invalid, or does not exist
 */
private static String extractTimestamp(final String location){
  int dateIndex=getTimestampIndex(location);
  if (dateIndex == -1)   return null;
  String dateTimeString=location.substring(dateIndex).trim();
  if (AlternateLocation.isValidDate(dateTimeString)) {
    return dateTimeString;
  }
 else {
    return null;
  }
}","/** 
 * Parses out the timestamp string from the alternate location header string, throwing an exception if there is any error.
 * @param location the full alternate-location HTTP header string,as specified in HUGE v0.93
 * @return the date/time string from the the alternate locationheader, or <tt>null</tt> if the date/time string could not be extracted, is invalid, or does not exist
 */
private static String extractTimestamp(final String location){
  StringTokenizer st=new StringTokenizer(location);
  int numToks=st.countTokens();
  if (numToks != 2 && numToks != 3) {
    return null;
  }
 else {
    String curTok=null;
    for (int i=0; i < numToks; i++) {
      curTok=st.nextToken();
    }
    if (AlternateLocation.isValidTimestamp(curTok)) {
      return curTok;
    }
 else {
      return null;
    }
  }
}",0.72265625
4883,"/** 
 * Removes the timestamp from an alternate location header.  This will remove the timestamp from an alternate location header string that  includes the header name, or from an alternate location string that only contains the alternate location header value.
 * @param locationHeader the string containing the full header, or onlythe header value
 * @return the same string as supplied in the <tt>locationHeader</tt> argument, but with the timestamp removed
 */
private static String removeTimestamp(final String locationHeader){
  int timestampIndex=getTimestampIndex(locationHeader);
  if (timestampIndex != -1) {
    return locationHeader.substring(0,timestampIndex);
  }
  return locationHeader.trim();
}","/** 
 * Removes the timestamp from an alternate location header.  This will remove the timestamp from an alternate location header string that  includes the header name, or from an alternate location string that only contains the alternate location header value.
 * @param locationHeader the string containing the full header, or onlythe header value
 * @return the same string as supplied in the <tt>locationHeader</tt> argument, but with the timestamp removed
 */
private static String removeTimestamp(final String locationHeader){
  StringTokenizer st=new StringTokenizer(locationHeader);
  int numToks=st.countTokens();
  if (numToks == 1 || numToks == 2 || numToks == 3) {
    return st.nextToken();
  }
 else {
    return null;
  }
}",0.7787732598208132
4884,"public List getCollectionList(){
  if (replyDocs != null)   return replyDocs;
  replyDocs=new ArrayList();
synchronized (mainMap) {
    Iterator iter=mainMap.keySet().iterator();
    while (iter.hasNext()) {
      Object hash=iter.next();
      Object doc=mainMap.get(hash);
      replyDocs.add(doc);
    }
  }
  return replyDocs;
}","public List getCollectionList(){
  List replyDocs=new ArrayList();
synchronized (mainMap) {
    Iterator iter=mainMap.keySet().iterator();
    while (iter.hasNext()) {
      Object hash=iter.next();
      Object doc=mainMap.get(hash);
      replyDocs.add(doc);
    }
  }
  return replyDocs;
}",0.9230769230769232
4885,"public synchronized int mp3ToDisk(String mp3FileName){
  boolean wrote=false;
  int mp3WriteState=-1;
  if (ripMP3XML(mp3FileName))   mp3WriteState=commitID3Data(mp3FileName);
  wrote=write();
  this.changedHash=null;
  this.editor=null;
  if (!wrote)   return RW_ERROR;
  return mp3WriteState;
}","public int mp3ToDisk(String mp3FileName){
  boolean wrote=false;
  int mp3WriteState=-1;
  Object[] output=ripMP3XML(mp3FileName);
  if (((Boolean)output[0]).booleanValue())   mp3WriteState=commitID3Data(mp3FileName,(String)output[1],(ID3Editor)output[2]);
  wrote=write();
  if (!wrote)   return RW_ERROR;
  return mp3WriteState;
}",0.7452229299363057
4886,"public void addReply(String hash,LimeXMLDocument replyDoc){
synchronized (mainMap) {
    mainMap.put(hash,replyDoc);
  }
  replyDocs=null;
}","public void addReply(String hash,LimeXMLDocument replyDoc){
synchronized (mainMap) {
    mainMap.put(hash,replyDoc);
  }
}",0.931297709923664
4887,"private boolean ripMP3XML(String modifiedFile){
  if (!LimeXMLUtils.isMP3File(modifiedFile))   return false;
  try {
    String hash=new String(LimeXMLUtils.hashFile(new File(modifiedFile)));
    LimeXMLDocument doc=(LimeXMLDocument)mainMap.get(hash);
    String fName=doc.getIdentifier();
    if (LimeXMLUtils.isMP3File(modifiedFile)) {
      ID3Editor e=new ID3Editor();
      String xml=doc.getXMLStringWithIdentifier();
      e.removeID3Tags(xml);
      this.editor=e;
      this.changedHash=hash;
    }
    return true;
  }
 catch (  Exception e) {
    return false;
  }
}","/** 
 * @return A Object[] of size 3.  First object is a boolean indicatedwhether you should commit this ID3 to disk, second is the new hash (String) of the file, and third is the ID3Editor to use....
 */
private Object[] ripMP3XML(String modifiedFile){
  Object[] retObjs=new Object[3];
  retObjs[0]=new Boolean(false);
  if (!LimeXMLUtils.isMP3File(modifiedFile))   return retObjs;
  try {
    String hash=new String(LimeXMLUtils.hashFile(new File(modifiedFile)));
    LimeXMLDocument doc=null;
synchronized (mainMap) {
      doc=(LimeXMLDocument)mainMap.get(hash);
    }
    String fName=doc.getIdentifier();
    if (LimeXMLUtils.isMP3File(modifiedFile)) {
      ID3Editor e=new ID3Editor();
      String xml=doc.getXMLStringWithIdentifier();
      e.removeID3Tags(xml);
      retObjs[0]=new Boolean(true);
      retObjs[1]=hash;
      retObjs[2]=e;
    }
    return retObjs;
  }
 catch (  Exception e) {
    return retObjs;
  }
}",0.2516556291390728
4888,"/** 
 * Simply write() out the mainMap to disk. 
 */
public boolean write(){
  if (dataFile == null) {
    String fname=LimeXMLSchema.getDisplayString(schemaURI) + ""String_Node_Str"";
    LimeXMLProperties props=LimeXMLProperties.instance();
    String path=props.getXMLDocsDir();
    dataFile=new File(path,fname);
  }
  try {
    MapSerializer ms=new MapSerializer(dataFile,mainMap);
    ms.commit();
  }
 catch (  Exception e) {
    return false;
  }
  return true;
}","/** 
 * Simply write() out the mainMap to disk. 
 */
public boolean write(){
  if (dataFile == null) {
    String fname=LimeXMLSchema.getDisplayString(schemaURI) + ""String_Node_Str"";
    LimeXMLProperties props=LimeXMLProperties.instance();
    String path=props.getXMLDocsDir();
    dataFile=new File(path,fname);
  }
  try {
    MapSerializer ms=new MapSerializer(dataFile,mainMap);
synchronized (writeLock) {
      ms.commit();
    }
  }
 catch (  Exception e) {
    return false;
  }
  return true;
}",0.9640287769784172
4889,"/** 
 * @return the older document, which is being replaced. Can be null.
 */
public LimeXMLDocument replaceDoc(Object hash,LimeXMLDocument newDoc){
  LimeXMLDocument oldDoc=null;
synchronized (mainMap) {
    oldDoc=(LimeXMLDocument)mainMap.get(hash);
    mainMap.put(hash,newDoc);
  }
  replyDocs=null;
  return oldDoc;
}","/** 
 * @return the older document, which is being replaced. Can be null.
 */
public LimeXMLDocument replaceDoc(Object hash,LimeXMLDocument newDoc){
  LimeXMLDocument oldDoc=null;
synchronized (mainMap) {
    oldDoc=(LimeXMLDocument)mainMap.get(hash);
    mainMap.put(hash,newDoc);
  }
  return oldDoc;
}",0.9361022364217252
4890,"/** 
 * @param hashSet The set of Hashes you want us to make a collection out of.
 * @param URI This collection's schema URI
 * @param fm A pointer to the system wide (Meta)FileManager .
 * @param audio Whether this is a collection of audio files.
 */
public LimeXMLReplyCollection(Set hashSet,String URI,FileManager fm,boolean audio){
  this.schemaURI=URI;
  this.metaFileManager=(MetaFileManager)fm;
  this.audio=audio;
  debug(""String_Node_Str"" + audio);
  MapSerializer ms=initializeMapSerializer(URI);
  Map hashToXMLStr;
  if (ms == null)   hashToXMLStr=new HashMap();
 else   hashToXMLStr=ms.getMap();
  Iterator iter=hashSet.iterator();
  ID3Reader id3Reader=new ID3Reader();
  while ((iter != null) && iter.hasNext()) {
    File file=(File)iter.next();
    String hash=metaFileManager.readFromMap(file);
    Object xml=hashToXMLStr.get(hash);
    LimeXMLDocument doc=null;
    if ((xml != null) && xml instanceof LimeXMLDocument) {
      doc=(LimeXMLDocument)xml;
    }
 else {
      String xmlStr=(String)xml;
      if (audio && LimeXMLUtils.isMP3File(file)) {
        boolean onlyID3=((xmlStr == null) || xmlStr.equals(""String_Node_Str""));
        try {
          if (!onlyID3) {
            try {
              String id3XML=id3Reader.readDocument(file,onlyID3);
              String joinedXML=joinAudioXMLStrings(id3XML,xmlStr);
              doc=new LimeXMLDocument(joinedXML);
            }
 catch (            RuntimeException re) {
              doc=id3Reader.readDocument(file);
            }
          }
 else           doc=id3Reader.readDocument(file);
        }
 catch (        SAXException ignored1) {
          continue;
        }
catch (        IOException ignored2) {
          continue;
        }
catch (        SchemaNotFoundException ignored3) {
          continue;
        }
      }
 else {
        try {
          if ((xmlStr != null) && (!xmlStr.equals(""String_Node_Str"")))           doc=new LimeXMLDocument(xmlStr);
 else           continue;
        }
 catch (        SAXException ignored1) {
          continue;
        }
catch (        IOException ignored2) {
          continue;
        }
catch (        SchemaNotFoundException ignored3) {
          continue;
        }
      }
    }
    addReply(hash,doc);
  }
  if (hashSet != null)   checkDocuments(hashSet,false);
  debug(""String_Node_Str"");
  write();
}","/** 
 * @param fileToHash The map of files to hashes for all shared files.
 * @param URI This collection's schema URI
 * @param fm A pointer to the system wide (Meta)FileManager .
 * @param audio Whether this is a collection of audio files.
 */
public LimeXMLReplyCollection(Map fileToHash,String URI,FileManager fm,boolean audio){
  this.schemaURI=URI;
  this.metaFileManager=(MetaFileManager)fm;
  this.audio=audio;
  debug(""String_Node_Str"" + audio);
  MapSerializer ms=initializeMapSerializer(URI);
  Map hashToXMLStr;
  if (ms == null)   hashToXMLStr=new HashMap();
 else   hashToXMLStr=ms.getMap();
synchronized (fileToHash) {
    Iterator iter=fileToHash.keySet().iterator();
    ID3Reader id3Reader=new ID3Reader();
    while ((iter != null) && iter.hasNext()) {
      File file=(File)iter.next();
      String hash=(String)fileToHash.get(file);
      Object xml=hashToXMLStr.get(hash);
      LimeXMLDocument doc=null;
      if ((xml != null) && xml instanceof LimeXMLDocument) {
        doc=(LimeXMLDocument)xml;
      }
 else {
        String xmlStr=(String)xml;
        if (audio && LimeXMLUtils.isMP3File(file)) {
          boolean onlyID3=((xmlStr == null) || xmlStr.equals(""String_Node_Str""));
          try {
            if (!onlyID3) {
              try {
                String id3XML=id3Reader.readDocument(file,onlyID3);
                String joinedXML=joinAudioXMLStrings(id3XML,xmlStr);
                doc=new LimeXMLDocument(joinedXML);
              }
 catch (              RuntimeException re) {
                doc=id3Reader.readDocument(file);
              }
            }
 else             doc=id3Reader.readDocument(file);
          }
 catch (          SAXException ignored1) {
            continue;
          }
catch (          IOException ignored2) {
            continue;
          }
catch (          SchemaNotFoundException ignored3) {
            continue;
          }
        }
 else {
          try {
            if ((xmlStr != null) && (!xmlStr.equals(""String_Node_Str"")))             doc=new LimeXMLDocument(xmlStr);
 else             continue;
          }
 catch (          SAXException ignored1) {
            continue;
          }
catch (          IOException ignored2) {
            continue;
          }
catch (          SchemaNotFoundException ignored3) {
            continue;
          }
        }
      }
      addReply(hash,doc);
    }
    checkDocuments(fileToHash,false);
  }
  debug(""String_Node_Str"");
  write();
}",0.8767408023279983
4891,"private void checkDocuments(Set hashSet,boolean mp3){
  Iterator iter=null;
  if (hashSet != null)   iter=hashSet.iterator();
  if (iter == null)   return;
  while (iter.hasNext()) {
    File file=(File)iter.next();
    String hash=metaFileManager.readFromMap(file);
    LimeXMLDocument doc;
synchronized (mainMap) {
      doc=(LimeXMLDocument)mainMap.get(hash);
    }
    if (doc == null)     continue;
    String actualName=null;
    try {
      actualName=file.getCanonicalPath();
    }
 catch (    IOException ioe) {
synchronized (mainMap) {
        mainMap.remove(hash);
      }
    }
    String identifier=doc.getIdentifier();
    if (!actualName.equalsIgnoreCase(identifier))     doc.setIdentifier(actualName);
  }
}","/** 
 * This method resolves any discrepancy between the identifier in the  LimeXMLDocument with the actual file name of the file the LimeXMLDocument refers to.
 */
private void checkDocuments(Map fileToHash,boolean mp3){
synchronized (fileToHash) {
    Iterator iter=fileToHash.keySet().iterator();
    if (iter == null)     return;
    while (iter.hasNext()) {
      File file=(File)iter.next();
      String hash=(String)fileToHash.get(file);
      LimeXMLDocument doc;
synchronized (mainMap) {
        doc=(LimeXMLDocument)mainMap.get(hash);
      }
      if (doc == null)       continue;
      String actualName=null;
      try {
        actualName=file.getCanonicalPath();
      }
 catch (      IOException ioe) {
synchronized (mainMap) {
          mainMap.remove(hash);
        }
      }
      String identifier=doc.getIdentifier();
      if (!actualName.equalsIgnoreCase(identifier))       doc.setIdentifier(actualName);
    }
  }
}",0.4437763078773301
4892,"public synchronized void addReplyWithCommit(File f,String hash,LimeXMLDocument replyDoc){
  String identifier=""String_Node_Str"";
  try {
    identifier=f.getCanonicalPath();
  }
 catch (  IOException e) {
  }
  replyDoc.setIdentifier(identifier);
  addReply(hash,replyDoc);
  try {
    if (audio)     mp3ToDisk(f.getCanonicalPath());
 else     write();
  }
 catch (  Exception ignored) {
  }
}","public void addReplyWithCommit(File f,String hash,LimeXMLDocument replyDoc){
  String identifier=""String_Node_Str"";
  try {
    identifier=f.getCanonicalPath();
  }
 catch (  IOException e) {
  }
  replyDoc.setIdentifier(identifier);
  addReply(hash,replyDoc);
  try {
    if (audio)     mp3ToDisk(f.getCanonicalPath());
 else     write();
  }
 catch (  Exception ignored) {
  }
}",0.9831824062095732
4893,"public synchronized boolean removeDoc(String hash){
  replyDocs=null;
  boolean found;
  Object val;
synchronized (mainMap) {
    val=mainMap.remove(hash);
    found=val == null ? false : true;
  }
  boolean written=false;
  if (found) {
    written=write();
  }
  if (!written && found) {
synchronized (mainMap) {
      mainMap.put(hash,val);
    }
  }
 else   if (found && written)   return true;
  return false;
}","public boolean removeDoc(String hash){
  boolean found;
  Object val;
synchronized (mainMap) {
    val=mainMap.remove(hash);
    found=val == null ? false : true;
  }
  boolean written=false;
  if (found) {
    written=write();
  }
  if (!written && found) {
synchronized (mainMap) {
      mainMap.put(hash,val);
    }
  }
 else   if (found && written)   return true;
  return false;
}",0.961298377028714
4894,"private int commitID3Data(String mp3FileName){
  int retVal=this.editor.writeID3DataToDisk(mp3FileName);
  if (retVal != NORMAL)   return retVal;
  File file=new File(mp3FileName);
  String newHash=null;
  try {
    newHash=new String(LimeXMLUtils.hashFile(file));
  }
 catch (  Exception e) {
    retVal=HASH_FAILED;
    return retVal;
  }
synchronized (mainMap) {
    Object mainValue=mainMap.remove(changedHash);
    mainMap.put(newHash,mainValue);
  }
  metaFileManager.writeToMap(file,newHash);
  metaFileManager.handleChangedHash(changedHash,newHash,this);
  return retVal;
}","private int commitID3Data(String mp3FileName,String changedHash,ID3Editor editor){
  int retVal=editor.writeID3DataToDisk(mp3FileName);
  if (retVal != NORMAL)   return retVal;
  File file=new File(mp3FileName);
  String newHash=null;
  try {
    newHash=new String(LimeXMLUtils.hashFile(file));
  }
 catch (  Exception e) {
    retVal=HASH_FAILED;
    return retVal;
  }
synchronized (mainMap) {
    Object mainValue=mainMap.remove(changedHash);
    mainMap.put(newHash,mainValue);
  }
  metaFileManager.writeToMap(file,newHash);
  metaFileManager.handleChangedHash(changedHash,newHash,this);
  return retVal;
}",0.9656328583403184
4895,"/** 
 * This method overrides FileManager.loadSettingsBlocking(), though it calls the super method to load up the shared file DB.  Then, it processes these files and annotates them automatically as apropos. TODO2: Eventually we will think that its too much of a burden to have this thread be blocking in which case we will have to  have the load thread also handle the reloading of the meta-data. Question: Do we really want to reload the meta-data whenever a we want to update the file information?? It depends on how we want to  handle the meta-data and its relation to the file system
 */
protected void loadSettingsBlocking(boolean notifyOnClear){
  super.loadSettingsBlocking(notifyOnClear);
  if (Thread.currentThread().isInterrupted())   return;
synchronized (metaLocker) {
    if (!initialized) {
      fileToHash.clear();
      createFileToHashMaps();
      SchemaReplyCollectionMapper mapper=SchemaReplyCollectionMapper.instance();
      LimeXMLSchemaRepository schemaRepository=LimeXMLSchemaRepository.instance();
      if (Thread.currentThread().isInterrupted())       return;
      String[] schemas=schemaRepository.getAvailableSchemaURIs();
      int len=schemas.length;
      LimeXMLReplyCollection collection;
      for (int i=0; (i < len) && !Thread.currentThread().isInterrupted(); i++) {
        String s=LimeXMLSchema.getDisplayString(schemas[i]);
        if (s.equalsIgnoreCase(""String_Node_Str"")) {
          collection=new LimeXMLReplyCollection(fileToHash.keySet(),schemas[i],this,true);
        }
 else         collection=new LimeXMLReplyCollection(fileToHash.keySet(),schemas[i],this,false);
        mapper.add(schemas[i],collection);
      }
    }
  }
}","/** 
 * This method overrides FileManager.loadSettingsBlocking(), though it calls the super method to load up the shared file DB.  Then, it processes these files and annotates them automatically as apropos. TODO2: Eventually we will think that its too much of a burden to have this thread be blocking in which case we will have to  have the load thread also handle the reloading of the meta-data. Question: Do we really want to reload the meta-data whenever a we want to update the file information?? It depends on how we want to  handle the meta-data and its relation to the file system
 */
protected void loadSettingsBlocking(boolean notifyOnClear){
  super.loadSettingsBlocking(notifyOnClear);
  if (Thread.currentThread().isInterrupted())   return;
synchronized (metaLocker) {
    if (!initialized) {
      fileToHash.clear();
      createFileToHashMaps();
      SchemaReplyCollectionMapper mapper=SchemaReplyCollectionMapper.instance();
      LimeXMLSchemaRepository schemaRepository=LimeXMLSchemaRepository.instance();
      if (Thread.currentThread().isInterrupted())       return;
      String[] schemas=schemaRepository.getAvailableSchemaURIs();
      int len=schemas.length;
      LimeXMLReplyCollection collection;
      for (int i=0; (i < len) && !Thread.currentThread().isInterrupted(); i++) {
        String s=LimeXMLSchema.getDisplayString(schemas[i]);
        collection=new LimeXMLReplyCollection(fileToHash,schemas[i],this,s.equalsIgnoreCase(""String_Node_Str""));
        mapper.add(schemas[i],collection);
      }
    }
  }
}",0.9215017064846416
4896,"/** 
 * Parses out the header value from the HTTP header string.
 * @return the header value for the specified full header string, or<tt>null</tt> if the value could not be extracted
 */
public static String extractHeaderValue(final String header){
  int index=header.indexOf(""String_Node_Str"");
  if (index == 0)   return null;
  return header.substring(index + 2).trim();
}","/** 
 * Parses out the header value from the HTTP header string.
 * @return the header value for the specified full header string, or<tt>null</tt> if the value could not be extracted
 */
public static String extractHeaderValue(final String header){
  int index=header.indexOf(""String_Node_Str"");
  if (index == 0)   return null;
  return header.substring(index + 1).trim();
}",0.9973333333333332
4897,"/** 
 * Returns whether or not the specified Namespace Specific String (NSS)  is a valid NSS.
 * @param nss the Namespace Specific String for a URN
 * @return <tt>true</tt> if the NSS is valid, <tt>false</tt> otherwise
 */
private static boolean isValidNamespaceSpecificString(final String nss){
  int length=NSS.length();
  if ((length != 32) && (length != 72)) {
    return false;
  }
  return true;
}","/** 
 * Returns whether or not the specified Namespace Specific String (NSS)  is a valid NSS.
 * @param nss the Namespace Specific String for a URN
 * @return <tt>true</tt> if the NSS is valid, <tt>false</tt> otherwise
 */
private static boolean isValidNamespaceSpecificString(final String nss){
  int length=nss.length();
  if ((length != 32) && (length != 72)) {
    return false;
  }
  return true;
}",0.9925558312655088
4898,"/** 
 * Test requests by URN.
 */
public void testHttpUrnRequest(){
  for (int i=0; i < _fileManager.getNumFiles(); i++) {
    try {
      FileDesc fd=_fileManager.get(i);
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      baos.write(""String_Node_Str"".getBytes());
      baos.write(fd.getSHA1Urn().toString().getBytes());
      baos.write(""String_Node_Str"".getBytes());
      Socket sock=new TestSocket(new ByteArrayInputStream(baos.toByteArray()));
      _uploadManager.acceptUpload(sock);
      String reply=sock.getOutputStream().toString();
      StringTokenizer st=new StringTokenizer(""String_Node_Str"");
      while (st.hasMoreTokens()) {
        String curString=st.nextToken();
        if (HTTPHeaderName.ALT_LOCATION.matchesStartOfString(curString)) {
          continue;
        }
 else         if (HTTPHeaderName.CONTENT_URN.matchesStartOfString(curString)) {
          URN curUrn=null;
          try {
            curUrn=URNFactory.createUrnFromContentUrnHttpHeader(curString);
          }
 catch (          IOException e) {
            assertTrue(""String_Node_Str"" + e,false);
          }
          assertEquals(HTTPHeaderName.CONTENT_URN.toString() + ""String_Node_Str"",fd.getSHA1Urn(),curUrn);
        }
 else         if (HTTPHeaderName.CONTENT_RANGE.matchesStartOfString(curString)) {
          continue;
        }
 else         if (HTTPHeaderName.CONTENT_TYPE.matchesStartOfString(curString)) {
          String value=HTTPUtils.extractHeaderValue(curString);
          assertEquals(""String_Node_Str"",(int)fd.getSize(),Integer.parseInt(value));
        }
 else         if (HTTPHeaderName.SERVER.matchesStartOfString(curString)) {
          continue;
        }
      }
    }
 catch (    IOException e) {
      assertTrue(""String_Node_Str"" + e,false);
    }
  }
}","/** 
 * Test requests by URN.
 */
public void testHttpUrnRequest(){
  for (int i=0; i < _fileManager.getNumFiles(); i++) {
    try {
      FileDesc fd=_fileManager.get(i);
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      baos.write(""String_Node_Str"".getBytes());
      baos.write(fd.getSHA1Urn().toString().getBytes());
      baos.write(""String_Node_Str"".getBytes());
      Socket sock=new TestSocket(new ByteArrayInputStream(baos.toByteArray()));
      _uploadManager.acceptUpload(sock);
      String reply=sock.getOutputStream().toString();
      StringTokenizer st=new StringTokenizer(reply,""String_Node_Str"");
      boolean contentUrnHeaderPresent=false;
      while (st.hasMoreTokens()) {
        String curString=st.nextToken();
        if (HTTPHeaderName.ALT_LOCATION.matchesStartOfString(curString)) {
          continue;
        }
 else         if (HTTPHeaderName.CONTENT_URN.matchesStartOfString(curString)) {
          URN curUrn=null;
          try {
            curUrn=URNFactory.createUrnFromContentUrnHttpHeader(curString);
          }
 catch (          IOException e) {
            assertTrue(""String_Node_Str"" + e,false);
          }
          assertEquals(HTTPHeaderName.CONTENT_URN.toString() + ""String_Node_Str"",fd.getSHA1Urn(),curUrn);
          contentUrnHeaderPresent=true;
        }
 else         if (HTTPHeaderName.CONTENT_RANGE.matchesStartOfString(curString)) {
          continue;
        }
 else         if (HTTPHeaderName.CONTENT_TYPE.matchesStartOfString(curString)) {
          continue;
        }
 else         if (HTTPHeaderName.CONTENT_LENGTH.matchesStartOfString(curString)) {
          String value=HTTPUtils.extractHeaderValue(curString);
          assertEquals(""String_Node_Str"",(int)fd.getSize(),Integer.parseInt(value));
        }
 else         if (HTTPHeaderName.SERVER.matchesStartOfString(curString)) {
          continue;
        }
      }
      assertTrue(""String_Node_Str"" + fd,contentUrnHeaderPresent);
    }
 catch (    IOException e) {
      assertTrue(""String_Node_Str"" + e,false);
    }
  }
}",0.9299792531120332
4899,"/** 
 * Parses out the header value from the HTTP header string.
 * @return the header value for the specified full header string, or<tt>null</tt> if the value could not be extracted
 */
public static String extractHeaderValue(final String header){
  int index=header.indexOf(""String_Node_Str"");
  if (index == 0)   return null;
  return header.substring(index + 1);
}","/** 
 * Parses out the header value from the HTTP header string.
 * @return the header value for the specified full header string, or<tt>null</tt> if the value could not be extracted
 */
public static String extractHeaderValue(final String header){
  int index=header.indexOf(""String_Node_Str"");
  if (index == 0)   return null;
  return header.substring(index + 2).trim();
}",0.9878869448183042
4900,"/** 
 * Returns the union of all XML metadata documents from all hosts.
 */
private synchronized LimeXMLDocument[] getXMLDocuments(){
}","/** 
 * Returns the union of all XML metadata documents from all hosts.
 */
private synchronized LimeXMLDocument[] getXMLDocuments(){
  LimeXMLDocument[] retArray=null;
  List allDocs=new ArrayList();
  for (int i=0; i < this.allFiles.length; i++) {
    if (this.allFiles[i] != null) {
      LimeXMLDocument doc=this.allFiles[i].getXMLDoc();
      if (doc != null) {
        allDocs.add(doc);
      }
    }
  }
  if (allDocs.size() > 0) {
    retArray=(LimeXMLDocument[])allDocs.toArray(new LimeXMLDocument[0]);
  }
 else   retArray=null;
  return retArray;
}",0.3890489913544668
4901,"/** 
 * Returns an array of all responses matching the given request, or null if there are no responses.<p> Design note: this method returns null instead of an empty array to avoid allocations in the common case of no matches.)
 */
public synchronized Response[] query(QueryRequest request){
  String str=request.getQuery();
  if (str.equals(INDEXING_QUERY) || str.equals(BROWSE_QUERY)) {
    if (_numFiles == 0)     return null;
    Response[] ret=new Response[_numFiles];
    int j=0;
    for (int i=0; i < _files.size(); i++) {
      FileDesc desc=(FileDesc)_files.get(i);
      if (desc == null)       continue;
      Assert.that(j < ret.length,""String_Node_Str"");
      ret[j]=new Response(desc);
      j++;
    }
    Assert.that(j == ret.length,""String_Node_Str"");
    return ret;
  }
  IntSet matches=null;
  matches=search(str,matches);
  if (request.getQueryUrns() != null) {
    matches=urnSearch(request.getQueryUrns().iterator(),matches);
  }
  if (matches == null)   return null;
  Response[] response=new Response[matches.size()];
  int j=0;
  for (IntSet.IntSetIterator iter=matches.iterator(); iter.hasNext(); j++) {
    int i=iter.next();
    FileDesc desc=(FileDesc)_files.get(i);
    response[j]=new Response(desc);
  }
  return response;
}","/** 
 * Returns an array of all responses matching the given request, or null if there are no responses.<p> Design note: this method returns null instead of an empty array to avoid allocations in the common case of no matches.)
 */
public synchronized Response[] query(QueryRequest request){
  String str=request.getQuery();
  if (str.equals(INDEXING_QUERY) || str.equals(BROWSE_QUERY)) {
    if (_numFiles == 0)     return null;
    Response[] ret=new Response[_numFiles];
    int j=0;
    for (int i=0; i < _files.size(); i++) {
      FileDesc desc=(FileDesc)_files.get(i);
      if (desc == null)       continue;
      Assert.that(j < ret.length,""String_Node_Str"");
      ret[j]=new Response(desc);
      j++;
    }
    Assert.that(j == ret.length,""String_Node_Str"");
    return ret;
  }
  IntSet matches=null;
  matches=search(str,matches);
  if (request.getQueryUrns().size() > 0) {
    matches=urnSearch(request.getQueryUrns().iterator(),matches);
  }
  if (matches == null) {
    return null;
  }
  Response[] response=new Response[matches.size()];
  int j=0;
  for (IntSet.IntSetIterator iter=matches.iterator(); iter.hasNext(); j++) {
    int i=iter.next();
    FileDesc desc=(FileDesc)_files.get(i);
    response[j]=new Response(desc);
  }
  return response;
}",0.9782522736259393
4902,"/** 
 * Indicates that the node is in the client node, and has now lost its only connection to the supernode
 */
private synchronized void lostShieldedClientSupernodeConnection(){
  if (_keepAlive > 0 && !hasClientSupernodeConnection()) {
    connect();
  }
}","/** 
 * Indicates that the node is in client mode and has lost a leaf to ultrapeer connection.
 */
private synchronized void lostShieldedClientSupernodeConnection(){
}",0.6995305164319249
4903,"/** 
 * Initializes a ManagedDownloader read from disk. Also used for internally initializing or resuming a normal download; there is no need to explicitly call this method in that case. After the call, this is in the queued state, at least for the moment.
 * @requires this is uninitialized or stopped, and allFiles, and incompleteFileManager are set
 * @modifies everything but the above fields 
 */
public void initialize(DownloadManager manager,FileManager fileManager){
  this.manager=manager;
  this.fileManager=fileManager;
  dloaders=new LinkedList();
  chatList=new DownloadChatList();
  stopped=false;
  corrupted=false;
  setState(QUEUED);
  this.dloaderManagerThread=new Thread(){
    public void run(){
      try {
        tryAllDownloads();
      }
 catch (      Exception e) {
        ManagedDownloader.this.manager.internalError(e);
      }
    }
  }
;
  dloaderManagerThread.setDaemon(true);
  dloaderManagerThread.start();
}","/** 
 * Initializes a ManagedDownloader read from disk. Also used for internally initializing or resuming a normal download; there is no need to explicitly call this method in that case. After the call, this is in the queued state, at least for the moment.
 * @requires this is uninitialized or stopped, and allFiles, and incompleteFileManager are set
 * @modifies everything but the above fields 
 */
public void initialize(DownloadManager manager,FileManager fileManager){
  this.manager=manager;
  this.fileManager=fileManager;
  dloaders=new LinkedList();
  chatList=new DownloadChatList();
  stopped=false;
  corrupted=false;
  setState(QUEUED);
  miniRFDToLock=Collections.synchronizedMap(new HashMap());
  threadLockToSocket=Collections.synchronizedMap(new HashMap());
  this.dloaderManagerThread=new Thread(){
    public void run(){
      try {
        tryAllDownloads();
      }
 catch (      Exception e) {
        ManagedDownloader.this.manager.internalError(e);
      }
    }
  }
;
  dloaderManagerThread.setDaemon(true);
  dloaderManagerThread.start();
}",0.9377799900447984
4904,"/** 
 * Initializes a ManagedDownloader read from disk. Also used for internally initializing or resuming a normal download; there is no need to explicitly call this method in that case. After the call, this is in the queued state, at least for the moment.
 * @requires this is uninitialized or stopped, and allFiles, and incompleteFileManager are set
 * @modifies everything but the above fields 
 */
public void initialize(DownloadManager manager,FileManager fileManager){
  this.manager=manager;
  this.fileManager=fileManager;
  dloaders=new LinkedList();
  chatList=new DownloadChatList();
  stopped=false;
  corrupted=false;
  setState(QUEUED);
  miniRFDToLock=Collections.synchronizedMap(new HashMap());
  threadLockToSocket=Collections.synchronizedMap(new HashMap());
  this.dloaderManagerThread=new Thread(){
    public void run(){
      try {
        tryAllDownloads();
      }
 catch (      Exception e) {
        ManagedDownloader.this.manager.internalError(e);
      }
    }
  }
;
  dloaderManagerThread.setDaemon(true);
  dloaderManagerThread.start();
}","/** 
 * Initializes a ManagedDownloader read from disk. Also used for internally initializing or resuming a normal download; there is no need to explicitly call this method in that case. After the call, this is in the queued state, at least for the moment.
 * @requires this is uninitialized or stopped, and allFiles, and incompleteFileManager are set
 * @modifies everything but the above fields 
 */
public void initialize(DownloadManager manager,FileManager fileManager){
  this.manager=manager;
  this.fileManager=fileManager;
  dloaders=new LinkedList();
  chatList=new DownloadChatList();
  stealLock=new Object();
  stopped=false;
  corrupted=false;
  setState(QUEUED);
  miniRFDToLock=Collections.synchronizedMap(new HashMap());
  threadLockToSocket=Collections.synchronizedMap(new HashMap());
  this.dloaderManagerThread=new Thread(){
    public void run(){
      try {
        tryAllDownloads();
      }
 catch (      Exception e) {
        ManagedDownloader.this.manager.internalError(e);
      }
    }
  }
;
  dloaderManagerThread.setDaemon(true);
  dloaderManagerThread.start();
}",0.9879629629629628
4905,"/** 
 * Returns true if this can safely switch from supernode to leaf mode. Typically that means there are no leaf connections, but it could be stricter.  
 */
public boolean allowClientMode(){
  if (_settings.getForceSupernodeMode() || (isSupernode() && _incomingClientConnections > 0))   return false;
 else   return true;
}","/** 
 * Returns true if this can safely switch from supernode to leaf mode. Typically that means there are no leaf connections, but it could be stricter.  
 */
public boolean allowClientMode(){
  int connections=getNumInitializedConnections() + _initializedClientConnections.size();
  if (_settings.getForceSupernodeMode() || (isSupernode() && connections > 0))   return false;
 else   return true;
}",0.8539944903581267
4906,"public static void main(String args[]){
  String host=""String_Node_Str"";
  int port=6346;
  System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  SettingsManager settings=SettingsManager.instance();
  settings.setPort(6346);
  settings.setDirectories(new File[0]);
  settings.setUseQuickConnect(false);
  settings.setQuickConnectHosts(new String[0]);
  settings.setConnectOnStartup(false);
  settings.setEverSupernodeCapable(true);
  settings.setDisableSupernodeMode(false);
  settings.setMaxShieldedClientConnections(LEAF_CONNECTIONS);
  settings.setKeepAlive(KEEP_ALIVE);
  ActivityCallback callback=new ActivityCallbackStub();
  FileManager files=new FileManagerStub();
  TestMessageRouter router=new TestMessageRouter(callback,files);
  RouterService rs=new RouterService(callback,router,files,new DummyAuthenticator());
  rs.initialize();
  rs.clearHostCatcher();
  try {
    rs.setKeepAlive(6);
  }
 catch (  BadConnectionSettingException e) {
    e.printStackTrace();
    Assert.that(false);
  }
  testFetchI(rs,router);
  cleanup(rs);
  testFetchII(rs,router);
  cleanup(rs);
  testAcceptI(rs,router,host,port);
  cleanup(rs);
  testAcceptII(rs,router,host,port);
  cleanup(rs);
  testAcceptIII(rs,router,host,port);
}","public static void main(String args[]){
  String host=""String_Node_Str"";
  int port=6346;
  System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  SettingsManager settings=SettingsManager.instance();
  settings.setPort(6346);
  settings.setDirectories(new File[0]);
  settings.setUseQuickConnect(false);
  settings.setQuickConnectHosts(new String[0]);
  settings.setConnectOnStartup(false);
  settings.setEverSupernodeCapable(true);
  settings.setDisableSupernodeMode(false);
  settings.setForceSupernodeMode(false);
  settings.setMaxShieldedClientConnections(LEAF_CONNECTIONS);
  settings.setKeepAlive(KEEP_ALIVE);
  ActivityCallback callback=new ActivityCallbackStub();
  FileManager files=new FileManagerStub();
  TestMessageRouter router=new TestMessageRouter(callback,files);
  RouterService rs=new RouterService(callback,router,files,new DummyAuthenticator());
  rs.initialize();
  rs.clearHostCatcher();
  try {
    rs.setKeepAlive(6);
  }
 catch (  BadConnectionSettingException e) {
    e.printStackTrace();
    Assert.that(false);
  }
  System.out.println(""String_Node_Str"");
  testGuidanceI(rs);
  cleanup(rs);
  testGuidanceII(rs);
  cleanup(rs);
  testGuidanceIII(rs);
  cleanup(rs);
  testFetchI(rs,router);
  cleanup(rs);
  testFetchII(rs,router);
  cleanup(rs);
  testAcceptI(rs,router,host,port);
  cleanup(rs);
  testAcceptII(rs,router,host,port);
  cleanup(rs);
  testAcceptIII(rs,router,host,port);
}",0.927416321925536
4907,"/** 
 * @return an XML string that will be re-created as this document when it is re-assembled in another machine. this xml string contains the filename identifier too (as an attribute).
 * @exception SchemaNotFoundException DO NOT CALL THIS METHOD unlessyou know that getSchemaURI() returns a valid xml schema.  Set it  yourself with setSchemaURI().
 */
public String getXMLStringWithIdentifier() throws SchemaNotFoundException {
  String ret=constructXML(getOrderedNameValueList(),schemaUri);
  int index=ret.indexOf(""String_Node_Str"");
  if (index < 0)   return ret;
  index=ret.indexOf(""String_Node_Str"",++index);
  index=ret.indexOf(""String_Node_Str"",++index);
  String first=ret.substring(0,index);
  String last=ret.substring(index);
  String middle=""String_Node_Str"" + identifier + ""String_Node_Str"";
  ret=first + middle + last;
  return ret;
}","/** 
 * @return an XML string that will be re-created as this document when it is re-assembled in another machine. this xml string contains the filename identifier too (as an attribute).
 * @exception SchemaNotFoundException DO NOT CALL THIS METHOD unlessyou know that getSchemaURI() returns a valid xml schema.  Set it  yourself with setSchemaURI().
 */
public String getXMLStringWithIdentifier() throws SchemaNotFoundException {
  String ret=getXMLString();
  int index=ret.indexOf(""String_Node_Str"");
  if (index < 0)   return ret;
  index=ret.indexOf(""String_Node_Str"",++index);
  index=ret.indexOf(""String_Node_Str"",++index);
  String first=ret.substring(0,index);
  String last=ret.substring(index);
  String middle=""String_Node_Str"" + identifier + ""String_Node_Str"";
  ret=first + middle + last;
  return ret;
}",0.9682824655894674
4908,"/** 
 * finds the structure of the document by looking at the names of  the keys in the NameValue List and creates an XML string. <p> The name value list must have the correct ordering.  <p> The values are converted into the correect encoding as per the  XML specifications. So the caller of this method need not  pre-encode the special XML characters into the values. 
 */
public static String constructXML(List namValList,String uri){
  uri=LimeXMLUtils.encodeXML(uri);
  int size=namValList.size();
  String first=""String_Node_Str"";
  String last=""String_Node_Str"";
  String prevString=""String_Node_Str"";
  ArrayList tagsToClose=new ArrayList();
  boolean prevAtt=false;
  boolean rootAtts;
  if (namValList.size() == 0)   return ""String_Node_Str"";
  NameValue nv=(NameValue)namValList.get(0);
  String n=nv.getName();
  boolean end=n.endsWith(XMLStringUtils.DELIMITER);
  StringTokenizer tok=new StringTokenizer(n,XMLStringUtils.DELIMITER);
  int c=tok.countTokens();
  if (end && c == 2)   rootAtts=true;
 else   rootAtts=false;
  for (int i=0; i < size; i++) {
    NameValue namevalue=(NameValue)namValList.get(i);
    String currString=namevalue.getName();
    String value=LimeXMLUtils.encodeXML((String)namevalue.getValue());
    List currFields=XMLStringUtils.split(currString);
    int commonCount=0;
    List prevFields=null;
    boolean attribute=false;
    if (currString.endsWith(XMLStringUtils.DELIMITER))     attribute=true;
    if (prevAtt && !attribute)     first=first + ""String_Node_Str"";
    if (i > 0) {
      prevFields=XMLStringUtils.split(prevString);
      commonCount=getCommonCount(currFields,prevFields);
    }
    int z=currFields.size();
    int numPending=tagsToClose.size();
    if (commonCount < numPending) {
      int closeCount=numPending - commonCount;
      int currClose=numPending - 1;
      for (int k=0; k < closeCount; k++) {
        String closeStr=(String)tagsToClose.remove(currClose);
        currClose--;
        last=last + ""String_Node_Str"" + closeStr+ ""String_Node_Str"";
      }
    }
    if (!last.equals(""String_Node_Str"")) {
      first=first + last;
      last=""String_Node_Str"";
    }
    for (int j=commonCount; j < z - 1; j++) {
      String str=(String)currFields.get(j);
      first=first + ""String_Node_Str"" + str;
      if (i == 0 && j == 0 && !rootAtts) {
        first=first + ""String_Node_Str"" + uri+ ""String_Node_Str"";
      }
 else       if (i == 0 && j == 0 && rootAtts) {
        first=first + ""String_Node_Str"" + uri+ ""String_Node_Str"";
      }
      if ((!attribute) && (j > 0 || i > 0))       first=first + ""String_Node_Str"";
      tagsToClose.add(str);
    }
    String curr=(String)currFields.get(z - 1);
    if (!attribute)     first=first + ""String_Node_Str"" + curr+ ""String_Node_Str""+ value+ ""String_Node_Str""+ curr+ ""String_Node_Str"";
 else {
      first=first + ""String_Node_Str"" + curr+ ""String_Node_Str""+ value+ ""String_Node_Str"";
      if (i == size - 1)       first=first + ""String_Node_Str"";
    }
    prevString=currString;
    prevAtt=attribute;
  }
  int stillPending=tagsToClose.size();
  for (int l=stillPending - 1; l >= 0; l--) {
    String tag=(String)tagsToClose.remove(l);
    first=first + ""String_Node_Str"" + tag+ ""String_Node_Str"";
  }
  first=""String_Node_Str"" + first;
  return first;
}","/** 
 * finds the structure of the document by looking at the names of  the keys in the NameValue List and creates an XML string. <p> The name value list must have the correct ordering.  <p> The values are converted into the correect encoding as per the  XML specifications. So the caller of this method need not  pre-encode the special XML characters into the values. 
 */
public static String constructXML(List namValList,String uri){
  uri=LimeXMLUtils.encodeXML(uri);
  int size=namValList.size();
  String first=""String_Node_Str"";
  String last=""String_Node_Str"";
  String prevString=""String_Node_Str"";
  ArrayList tagsToClose=new ArrayList();
  boolean prevAtt=false;
  boolean rootAtts;
  if (namValList.size() == 0)   return ""String_Node_Str"";
  NameValue nv=(NameValue)namValList.get(0);
  String n=nv.getName();
  boolean end=n.endsWith(XMLStringUtils.DELIMITER);
  StringTokenizer tok=new StringTokenizer(n,XMLStringUtils.DELIMITER);
  int c=tok.countTokens();
  if (end && c == 2)   rootAtts=true;
 else   rootAtts=false;
  for (int i=0; i < size; i++) {
    NameValue namevalue=(NameValue)namValList.get(i);
    String currString=namevalue.getName();
    String value=LimeXMLUtils.encodeXML((String)namevalue.getValue());
    List currFields=XMLStringUtils.split(currString);
    int commonCount=0;
    List prevFields=null;
    boolean attribute=false;
    if (currString.endsWith(XMLStringUtils.DELIMITER))     attribute=true;
    if (prevAtt && !attribute)     first=first + ""String_Node_Str"";
    if (i > 0) {
      prevFields=XMLStringUtils.split(prevString);
      commonCount=getCommonCount(currFields,prevFields);
    }
    int z=currFields.size();
    int numPending=tagsToClose.size();
    if (commonCount < numPending) {
      int closeCount=numPending - commonCount;
      int currClose=numPending - 1;
      for (int k=0; k < closeCount; k++) {
        String closeStr=(String)tagsToClose.remove(currClose);
        currClose--;
        last=last + ""String_Node_Str"" + closeStr+ ""String_Node_Str"";
      }
    }
    if (!last.equals(""String_Node_Str"")) {
      first=first + last;
      last=""String_Node_Str"";
    }
    for (int j=commonCount; j < z - 1; j++) {
      String str=(String)currFields.get(j);
      first=first + ""String_Node_Str"" + str;
      if (i == 0 && j == 0 && !rootAtts) {
        first=first + ""String_Node_Str"" + uri+ ""String_Node_Str"";
      }
 else       if (i == 0 && j == 0 && rootAtts) {
        first=first + ""String_Node_Str"" + uri+ ""String_Node_Str"";
      }
      if ((!attribute) && (j > 0 || i > 0))       first=first + ""String_Node_Str"";
      tagsToClose.add(str);
    }
    String curr=(String)currFields.get(z - 1);
    if (!attribute)     first=first + ""String_Node_Str"" + curr+ ""String_Node_Str""+ value+ ""String_Node_Str""+ curr+ ""String_Node_Str"";
 else {
      first=first + ""String_Node_Str"" + curr+ ""String_Node_Str""+ value+ ""String_Node_Str"";
      if (i == size - 1)       first=first + ""String_Node_Str"";
    }
    prevString=currString;
    prevAtt=attribute;
  }
  int stillPending=tagsToClose.size();
  for (int l=stillPending - 1; l >= 0; l--) {
    String tag=(String)tagsToClose.remove(l);
    first=first + ""String_Node_Str"" + tag+ ""String_Node_Str"";
  }
  first=XML_HEADER + first;
  return first;
}",0.9958885335769758
4909,"/** 
 * There are two possible places for important document information  may be stored.  1. it may be in the root element. In which case the root variable should be set as true. In this case all the important doc info will be remembered, and any non-doc info present as attributes will be put into the hashmap <p> The other possible place is at the (only) child of the root element. If this is the node that is being passed. then root variable should be set to false. In this case. Just the doc info is grabbed. The non-doc info of a non-doc Node is not even looked at in this method. <p>  For this method to be effective, keep the following points in mind. The doc info mey be either in the root alone or in both the root and the only child of root. If it is only in root - call this method on  root, and create map on root. <p> If the doc-info is spread out b/w the root and the child. First call this method with root, then call it with child, and then  call createMap wht root. This will ensure no loss of data
 */
private void grabDocInfo(Node docElement,boolean root) throws SchemaNotFoundException {
  List attributes=LimeXMLUtils.getAttributes(docElement.getAttributes());
  int size=attributes.size();
  for (int i=0; i < size; i++) {
    Node att=(Node)attributes.get(i);
    String attName=att.getNodeName();
    String lowerAttName=attName.toLowerCase();
    if (lowerAttName.indexOf(""String_Node_Str"") >= 0)     schemaUri=att.getNodeValue();
 else     if (lowerAttName.indexOf(""String_Node_Str"") >= 0) {
      identifier=att.getNodeValue();
      Element e=(Element)docElement;
      e.removeAttribute(attName);
    }
 else     if (lowerAttName.indexOf(""String_Node_Str"") >= 0)     action=att.getNodeValue();
 else     if (lowerAttName.indexOf(""String_Node_Str"") >= 0) {
      Element e=(Element)docElement;
      e.removeAttribute(attName);
    }
 else {
      if (root) {
        String canonicalizedAttName=docElement.getNodeName() + XMLStringUtils.DELIMITER + att.getNodeName()+ XMLStringUtils.DELIMITER;
        fieldToValue.put(canonicalizedAttName.trim(),att.getNodeValue().trim());
      }
    }
  }
  if (schemaUri == null)   throw new SchemaNotFoundException();
}","/** 
 * There are two possible places for important document information  may be stored.  1. it may be in the root element. In which case the root variable should be set as true. In this case all the important doc info will be remembered, and any non-doc info present as attributes will be put into the hashmap <p> The other possible place is at the (only) child of the root element. If this is the node that is being passed. then root variable should be set to false. In this case. Just the doc info is grabbed. The non-doc info of a non-doc Node is not even looked at in this method. <p>  For this method to be effective, keep the following points in mind. The doc info mey be either in the root alone or in both the root and the only child of root. If it is only in root - call this method on  root, and create map on root. <p> If the doc-info is spread out b/w the root and the child. First call this method with root, then call it with child, and then  call createMap wht root. This will ensure no loss of data
 */
private void grabDocInfo(Node docElement,boolean root) throws SchemaNotFoundException {
  List attributes=LimeXMLUtils.getAttributes(docElement.getAttributes());
  int size=attributes.size();
  for (int i=0; i < size; i++) {
    Node att=(Node)attributes.get(i);
    String attName=att.getNodeName();
    String lowerAttName=attName.toLowerCase();
    if (lowerAttName.indexOf(""String_Node_Str"") >= 0)     schemaUri=att.getNodeValue();
 else     if (lowerAttName.indexOf(XML_ID_ATTRIBUTE_STRING) >= 0) {
      identifier=att.getNodeValue();
      Element e=(Element)docElement;
      e.removeAttribute(attName);
    }
 else     if (lowerAttName.indexOf(""String_Node_Str"") >= 0)     action=att.getNodeValue();
 else     if (lowerAttName.indexOf(""String_Node_Str"") >= 0) {
      Element e=(Element)docElement;
      e.removeAttribute(attName);
    }
 else {
      if (root) {
        String canonicalizedAttName=docElement.getNodeName() + XMLStringUtils.DELIMITER + att.getNodeName()+ XMLStringUtils.DELIMITER;
        fieldToValue.put(canonicalizedAttName.trim(),att.getNodeValue().trim());
      }
    }
  }
  if (schemaUri == null)   throw new SchemaNotFoundException();
}",0.9922374429223744
4910,"/** 
 * @return an XML string that will be re-created as this document when it is re-assembled in another machine. 
 * @exception SchemaNotFoundException DO NOT CALL THIS METHOD unlessyou know that getSchemaURI() returns a valid xml schema.  Set it  yourself with setSchemaURI().
 */
public String getXMLString() throws SchemaNotFoundException {
  String ret=constructXML(getOrderedNameValueList(),schemaUri);
  return ret;
}","/** 
 * @return an XML string that will be re-created as this document when it is re-assembled in another machine. 
 * @exception SchemaNotFoundException DO NOT CALL THIS METHOD unlessyou know that getSchemaURI() returns a valid xml schema.  Set it  yourself with setSchemaURI().
 */
public String getXMLString() throws SchemaNotFoundException {
  if (xmlString == null) {
    xmlString=constructXML(getOrderedNameValueList(),schemaUri);
  }
  return xmlString;
}",0.9121621621621622
4911,"private static void aggregateResponse(HashMap uriToString,LimeXMLDocument doc,int index){
  if (doc == null)   return;
  String uri=doc.getSchemaURI();
  String currString=(String)uriToString.get(uri);
  if (currString == null || currString == ""String_Node_Str"") {
    String str=null;
    try {
      str=doc.getXMLString();
    }
 catch (    Exception e) {
      return;
    }
    if (str == null || str.equals(""String_Node_Str""))     return;
    str=str.substring(0,str.lastIndexOf(""String_Node_Str""));
    int p=str.indexOf(""String_Node_Str"");
    p=str.indexOf(""String_Node_Str"",p + 1);
    p=str.indexOf(""String_Node_Str"",p + 1);
    String first=str.substring(0,p);
    String last=str.substring(p);
    StringBuffer strB=new StringBuffer(first.length() + 15 + last.length());
    strB.append(first);
    strB.append(""String_Node_Str"");
    strB.append(""String_Node_Str"" + index);
    strB.append(""String_Node_Str"");
    strB.append(last);
    uriToString.put(uri,strB.toString());
  }
 else {
    String str=null;
    try {
      str=doc.getXMLString();
    }
 catch (    Exception e) {
      return;
    }
    int begin=str.indexOf(""String_Node_Str"");
    begin=str.indexOf(""String_Node_Str"",begin + 1);
    begin=str.indexOf(""String_Node_Str"",begin + 1);
    int end=str.lastIndexOf(""String_Node_Str"");
    str=str.substring(begin,end);
    int p=str.indexOf(""String_Node_Str"");
    String first=str.substring(0,p);
    String last=str.substring(p);
    StringBuffer strB=new StringBuffer(currString);
    strB.append(first);
    strB.append(""String_Node_Str"");
    strB.append(""String_Node_Str"" + index);
    strB.append(""String_Node_Str"");
    strB.append(last);
    uriToString.put(uri,strB.toString());
  }
}","private static void aggregateResponse(HashMap uriToString,LimeXMLDocument doc,int index){
  if (doc == null)   return;
  String uri=doc.getSchemaURI();
  String currString=(String)uriToString.get(uri);
  if (currString == null || currString == ""String_Node_Str"") {
    String str=null;
    try {
      str=doc.getXMLString();
    }
 catch (    Exception e) {
      return;
    }
    if (str == null || str.equals(""String_Node_Str""))     return;
    str=str.substring(0,str.lastIndexOf(""String_Node_Str""));
    int p=str.indexOf(""String_Node_Str"");
    p=str.indexOf(""String_Node_Str"",p + 1);
    p=str.indexOf(""String_Node_Str"",p + 1);
    int q=str.indexOf(""String_Node_Str"",p + 1);
    int k=str.lastIndexOf(""String_Node_Str"",q - 1);
    if (k != -1 && p < k && k < q)     if (str.substring(k + 1,q).trim().equals(""String_Node_Str""))     p=k;
 else     p=q;
 else     p=q;
    String first=str.substring(0,p);
    String last=str.substring(p);
    StringBuffer strB=new StringBuffer(first.length() + 15 + last.length());
    strB.append(first);
    strB.append(""String_Node_Str"");
    strB.append(""String_Node_Str"" + index);
    strB.append(""String_Node_Str"");
    strB.append(last);
    uriToString.put(uri,strB.toString());
  }
 else {
    String str=null;
    try {
      str=doc.getXMLString();
    }
 catch (    Exception e) {
      return;
    }
    int begin=str.indexOf(""String_Node_Str"");
    begin=str.indexOf(""String_Node_Str"",begin + 1);
    begin=str.indexOf(""String_Node_Str"",begin + 1);
    int end=str.lastIndexOf(""String_Node_Str"");
    str=str.substring(begin,end);
    int p=str.indexOf(""String_Node_Str"");
    int q=str.lastIndexOf(""String_Node_Str"",p - 1);
    if (q != -1 && q < p)     if (str.substring(q + 1,p).trim().equals(""String_Node_Str""))     p=q;
    String first=str.substring(0,p);
    String last=str.substring(p);
    StringBuffer strB=new StringBuffer(currString);
    strB.append(first);
    strB.append(""String_Node_Str"");
    strB.append(""String_Node_Str"" + index);
    strB.append(""String_Node_Str"");
    strB.append(last);
    uriToString.put(uri,strB.toString());
  }
}",0.8980443285528031
4912,"/** 
 * Returns the address of the foreign host this is connected to.
 * @requires this is initialized.
 */
public InetAddress getInetAddress(){
  return _socket.getInetAddress();
}","/** 
 * Returns the address of the foreign host this is connected to.
 * @exception IllegalStateException this is not initialized
 */
public InetAddress getInetAddress() throws IllegalStateException {
  try {
    return _socket.getInetAddress();
  }
 catch (  NullPointerException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
}",0.6212121212121212
4913,"/** 
 * Returns the port this is connected to locally.
 * @requires this is initialized.
 */
public int getLocalPort(){
  return _socket.getLocalPort();
}","/** 
 * Returns the port this is connected to locally.
 * @exception IllegalStateException this is not initialized
 */
public int getLocalPort() throws IllegalStateException {
  try {
    return _socket.getLocalPort();
  }
 catch (  NullPointerException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
}",0.5780590717299579
4914,"/** 
 * Returns the local address of this.
 * @requires this is initialized.
 */
public InetAddress getLocalAddress(){
  return _socket.getLocalAddress();
}","/** 
 * Returns the local address of this.
 * @exception IllegalStateException this is not initialized
 */
public InetAddress getLocalAddress() throws IllegalStateException {
  try {
    return _socket.getLocalAddress();
  }
 catch (  NullPointerException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
}",0.5815899581589958
4915,"/** 
 * Returns the port of the foreign host this is connected to.
 * @requires this is initialized.
 */
public int getPort(){
  return _socket.getPort();
}","/** 
 * Returns the port of the foreign host this is connected to.
 * @exception IllegalStateException this is not initialized
 */
public int getPort() throws IllegalStateException {
  try {
    return _socket.getPort();
  }
 catch (  NullPointerException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
}",0.5815899581589958
4916,"/** 
 * An unsynchronized version of remove, meant to be used when the monitor is already held.  This version does not kick off ConnectionFetchers; only the externally exposed version of remove does that.
 */
private void removeInternal(ManagedConnection c){
  boolean removed=false;
  if (!c.isSupernodeClientConnection()) {
    int i=_initializedConnections.indexOf(c);
    if (i != -1) {
      removed=true;
      List newConnections=new ArrayList();
      newConnections.addAll(_initializedConnections);
      newConnections.remove(c);
      _initializedConnections=newConnections;
    }
  }
 else {
    int i=_initializedClientConnections.indexOf(c);
    if (i != -1) {
      removed=true;
      List newConnections=new ArrayList();
      newConnections.addAll(_initializedClientConnections);
      newConnections.remove(c);
      _initializedClientConnections=newConnections;
    }
  }
  if (removed) {
    Set newEndpoints=new HashSet();
    newEndpoints.addAll(_endpoints);
    newEndpoints.remove(new Endpoint(c.getInetAddress().getHostAddress(),c.getPort()));
    _endpoints=newEndpoints;
  }
  int i=_connections.indexOf(c);
  if (i != -1) {
    List newConnections=new ArrayList(_connections);
    newConnections.remove(c);
    _connections=newConnections;
  }
  c.close();
  _router.removeConnection(c);
  _callback.connectionClosed(c);
}","/** 
 * An unsynchronized version of remove, meant to be used when the monitor is already held.  This version does not kick off ConnectionFetchers; only the externally exposed version of remove does that.
 */
private void removeInternal(ManagedConnection c){
  boolean removed=false;
  if (!c.isSupernodeClientConnection()) {
    int i=_initializedConnections.indexOf(c);
    if (i != -1) {
      removed=true;
      List newConnections=new ArrayList();
      newConnections.addAll(_initializedConnections);
      newConnections.remove(c);
      _initializedConnections=newConnections;
    }
  }
 else {
    int i=_initializedClientConnections.indexOf(c);
    if (i != -1) {
      removed=true;
      List newConnections=new ArrayList();
      newConnections.addAll(_initializedClientConnections);
      newConnections.remove(c);
      _initializedClientConnections=newConnections;
    }
  }
  int i=_connections.indexOf(c);
  if (i != -1) {
    List newConnections=new ArrayList(_connections);
    newConnections.remove(c);
    _connections=newConnections;
  }
  c.close();
  _router.removeConnection(c);
  _callback.connectionClosed(c);
}",0.9152950622240064
4917,"/** 
 * Marks a connection fully initialized, but only if that connection wasn't removed from the list of open connections during its initialization. Should only be called from a thread that has this' monitor.
 */
private void connectionInitialized(ManagedConnection c){
  if (_connections.contains(c)) {
    if (!c.isSupernodeClientConnection()) {
      List newConnections=new ArrayList(_initializedConnections);
      newConnections.add(c);
      _initializedConnections=newConnections;
    }
 else {
      List newConnections=new ArrayList(_initializedClientConnections);
      newConnections.add(c);
      _initializedClientConnections=newConnections;
    }
    Set newEndpoints=new HashSet(_endpoints);
    newEndpoints.add(new Endpoint(c.getInetAddress().getHostAddress(),c.getPort()));
    _endpoints=newEndpoints;
  }
}","/** 
 * Marks a connection fully initialized, but only if that connection wasn't removed from the list of open connections during its initialization. Should only be called from a thread that has this' monitor.
 */
private void connectionInitialized(ManagedConnection c){
  if (_connections.contains(c)) {
    if (!c.isSupernodeClientConnection()) {
      List newConnections=new ArrayList(_initializedConnections);
      newConnections.add(c);
      _initializedConnections=newConnections;
    }
 else {
      List newConnections=new ArrayList(_initializedClientConnections);
      newConnections.add(c);
      _initializedClientConnections=newConnections;
    }
  }
}",0.893048128342246
4918,"/** 
 * Adds the passed endpoint to the set of hosts maintained. The endpoint  may not get added due to various reasons (including it might be our address itself, we migt be connected to it etc.). Also adding this endpoint may lead to the removal of some other endpoint from the cache.
 * @param e Endpoint to be added
 * @return true iff e was actually added
 */
private boolean add(Endpoint e){
  if (manager.isConnected(e))   return false;
  if (isMe(e.getHostname(),e.getPort()))   return false;
  try {
    if (isRouter(e.getHostBytes()))     return false;
  }
 catch (  UnknownHostException uhe) {
    return false;
  }
  boolean ret=false;
  boolean notifyGUI=false;
synchronized (this) {
    if (!(set.contains(e))) {
      ret=true;
      set.add(e);
      Object ejected=queue.insert(e,e.getWeight());
      if (ejected != null)       set.remove(ejected);
      if (ejected == null)       notifyGUI=true;
      this.notify();
    }
  }
synchronized (gotGoodPongLock) {
    gotGoodPong=true;
    gotGoodPongLock.notify();
  }
  if (alwaysNotifyKnownHost) {
    callback.knownHost(e);
  }
 else {
    if (notifyGUI)     callback.knownHost(e);
  }
  return ret;
}","/** 
 * Adds the passed endpoint to the set of hosts maintained. The endpoint  may not get added due to various reasons (including it might be our address itself, we migt be connected to it etc.). Also adding this endpoint may lead to the removal of some other endpoint from the cache.
 * @param e Endpoint to be added
 * @return true iff e was actually added
 */
private boolean add(Endpoint e){
  if (isMe(e.getHostname(),e.getPort()))   return false;
  try {
    if (isRouter(e.getHostBytes()))     return false;
  }
 catch (  UnknownHostException uhe) {
    return false;
  }
  boolean ret=false;
  boolean notifyGUI=false;
synchronized (this) {
    if (!(set.contains(e))) {
      ret=true;
      set.add(e);
      Object ejected=queue.insert(e,e.getWeight());
      if (ejected != null)       set.remove(ejected);
      if (ejected == null)       notifyGUI=true;
      this.notify();
    }
  }
synchronized (gotGoodPongLock) {
    gotGoodPong=true;
    gotGoodPongLock.notify();
  }
  if (alwaysNotifyKnownHost) {
    callback.knownHost(e);
  }
 else {
    if (notifyGUI)     callback.knownHost(e);
  }
  return ret;
}",0.979947689625109
4919,"private static void testAcceptI(RouterService rs,TestMessageRouter router,String host,int port){
  System.out.println(""String_Node_Str"");
  for (int i=0; i < 100; i++)   router.addHost(""String_Node_Str"" + i,6340,true);
  Connection c=testLimit(host,port,LEAF,LEAF_CONNECTIONS,REJECT_503);
  testPong(c,true);
  testLimit(host,port,OLD_06,ConnectionManager.DESIRED_OLD_CONNECTIONS,REJECT_503);
  testPong(c,true);
  testLimit(host,port,ULTRAPEER,KEEP_ALIVE - ConnectionManager.DESIRED_OLD_CONNECTIONS,REJECT_503);
  testPong(c,false);
}","private static void testAcceptI(TestRouterService rs,TestMessageRouter router,String host,int port){
  System.out.println(""String_Node_Str"");
  Assert.that(!rs.getConnectionManager().isConnected(new Endpoint(""String_Node_Str"",6346)));
  for (int i=0; i < 100; i++)   router.addHost(""String_Node_Str"" + i,6340,true);
  Connection c=testLimit(host,port,LEAF,LEAF_CONNECTIONS,REJECT_503);
  Assert.that(rs.getConnectionManager().isConnected(new Endpoint(""String_Node_Str"",17)));
  Assert.that(!rs.getConnectionManager().isConnected(new Endpoint(""String_Node_Str"",6346)));
  testPong(c,true);
  testLimit(host,port,OLD_06,ConnectionManager.DESIRED_OLD_CONNECTIONS,REJECT_503);
  testPong(c,true);
  testLimit(host,port,ULTRAPEER,KEEP_ALIVE - ConnectionManager.DESIRED_OLD_CONNECTIONS,REJECT_503);
  testPong(c,false);
}",0.7925925925925926
4920,"public static void main(String args[]){
  String host=""String_Node_Str"";
  int port=6346;
  System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  SettingsManager settings=SettingsManager.instance();
  settings.setPort(6346);
  settings.setDirectories(new File[0]);
  settings.setUseQuickConnect(false);
  settings.setQuickConnectHosts(new String[0]);
  settings.setConnectOnStartup(false);
  settings.setEverSupernodeCapable(true);
  settings.setDisableSupernodeMode(false);
  settings.setForceSupernodeMode(false);
  settings.setMaxShieldedClientConnections(LEAF_CONNECTIONS);
  settings.setKeepAlive(KEEP_ALIVE);
  ActivityCallback callback=new ActivityCallbackStub();
  FileManager files=new FileManagerStub();
  TestMessageRouter router=new TestMessageRouter(callback,files);
  RouterService rs=new RouterService(callback,router,files,new DummyAuthenticator());
  rs.initialize();
  rs.clearHostCatcher();
  try {
    rs.setKeepAlive(6);
  }
 catch (  BadConnectionSettingException e) {
    e.printStackTrace();
    Assert.that(false);
  }
  System.out.println(""String_Node_Str"");
  testGuidanceI(rs);
  cleanup(rs);
  testGuidanceII(rs);
  cleanup(rs);
  testGuidanceIII(rs);
  cleanup(rs);
  testFetchI(rs,router);
  cleanup(rs);
  testFetchII(rs,router);
  cleanup(rs);
  testAcceptI(rs,router,host,port);
  cleanup(rs);
  testAcceptII(rs,router,host,port);
  cleanup(rs);
  testAcceptIII(rs,router,host,port);
}","public static void main(String args[]){
  String host=""String_Node_Str"";
  int port=6346;
  System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  SettingsManager settings=SettingsManager.instance();
  settings.setPort(6346);
  settings.setDirectories(new File[0]);
  settings.setUseQuickConnect(false);
  settings.setQuickConnectHosts(new String[0]);
  settings.setConnectOnStartup(false);
  settings.setEverSupernodeCapable(true);
  settings.setDisableSupernodeMode(false);
  settings.setForceSupernodeMode(false);
  settings.setMaxShieldedClientConnections(LEAF_CONNECTIONS);
  settings.setKeepAlive(KEEP_ALIVE);
  ActivityCallback callback=new ActivityCallbackStub();
  FileManager files=new FileManagerStub();
  TestMessageRouter router=new TestMessageRouter(callback,files);
  TestRouterService rs=new TestRouterService(callback,router,files,new DummyAuthenticator());
  rs.initialize();
  rs.clearHostCatcher();
  try {
    rs.setKeepAlive(6);
  }
 catch (  BadConnectionSettingException e) {
    e.printStackTrace();
    Assert.that(false);
  }
  System.out.println(""String_Node_Str"");
  testGuidanceI(rs);
  cleanup(rs);
  testGuidanceII(rs);
  cleanup(rs);
  testGuidanceIII(rs);
  cleanup(rs);
  testFetchI(rs,router);
  cleanup(rs);
  testFetchII(rs,router);
  cleanup(rs);
  testAcceptI(rs,router,host,port);
  cleanup(rs);
  testAcceptII(rs,router,host,port);
  cleanup(rs);
  testAcceptIII(rs,router,host,port);
}",0.9972027972027973
4921,"private static void testAcceptII(RouterService rs,TestMessageRouter router,String host,int port){
  System.out.println(""String_Node_Str"");
  for (int i=0; i < 100; i++)   router.addHost(""String_Node_Str"" + i,6340,true);
  Connection c=testLimit(host,port,ULTRAPEER,KEEP_ALIVE,REJECT_SILENT);
  Assert.that(ConnectionHandshakeHeaders.isFalse(c.getProperty(ConnectionHandshakeHeaders.X_SUPERNODE_NEEDED)));
  testPong(c,true);
  testLimit(host,port,OLD_06,0,REJECT_503);
  testPong(c,true);
  testLimit(host,port,OLD_04,0,REJECT_SILENT);
  testPong(c,true);
  c=testLimit(host,port,LEAF,LEAF_CONNECTIONS,REJECT_503);
  testPong(c,false);
}","private static void testAcceptII(TestRouterService rs,TestMessageRouter router,String host,int port){
  System.out.println(""String_Node_Str"");
  for (int i=0; i < 100; i++)   router.addHost(""String_Node_Str"" + i,6340,true);
  Assert.that(!rs.getConnectionManager().isConnected(new Endpoint(""String_Node_Str"",17)));
  Connection c=testLimit(host,port,ULTRAPEER,KEEP_ALIVE,REJECT_SILENT);
  Assert.that(rs.getConnectionManager().isConnected(new Endpoint(""String_Node_Str"",17)));
  Assert.that(ConnectionHandshakeHeaders.isFalse(c.getProperty(ConnectionHandshakeHeaders.X_SUPERNODE_NEEDED)));
  testPong(c,true);
  testLimit(host,port,OLD_06,0,REJECT_503);
  testPong(c,true);
  testLimit(host,port,OLD_04,0,REJECT_SILENT);
  testPong(c,true);
  c=testLimit(host,port,LEAF,LEAF_CONNECTIONS,REJECT_503);
  testPong(c,false);
}",0.8732008224811515
4922,"public static void main(String args[]){
  String host=""String_Node_Str"";
  int port=6346;
  System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  SettingsManager settings=SettingsManager.instance();
  settings.setPort(6346);
  settings.setDirectories(new File[0]);
  settings.setUseQuickConnect(false);
  settings.setQuickConnectHosts(new String[0]);
  settings.setConnectOnStartup(false);
  settings.setEverSupernodeCapable(true);
  settings.setDisableSupernodeMode(false);
  settings.setMaxShieldedClientConnections(LEAF_CONNECTIONS);
  ActivityCallback callback=new ActivityCallbackStub();
  FileManager files=new FileManagerStub();
  TestMessageRouter router=new TestMessageRouter(callback,files);
  RouterService rs=new RouterService(callback,router,files,new DummyAuthenticator());
  rs.initialize();
  rs.clearHostCatcher();
  try {
    rs.setKeepAlive(6);
  }
 catch (  BadConnectionSettingException e) {
    e.printStackTrace();
    Assert.that(false);
  }
  testFetchI(rs,router);
  cleanup(rs);
  testFetchII(rs,router);
  cleanup(rs);
  testAcceptI(rs,router,host,port);
  cleanup(rs);
  testAcceptII(rs,router,host,port);
  cleanup(rs);
  testAcceptIII(rs,router,host,port);
}","public static void main(String args[]){
  String host=""String_Node_Str"";
  int port=6346;
  System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  SettingsManager settings=SettingsManager.instance();
  settings.setPort(6346);
  settings.setDirectories(new File[0]);
  settings.setUseQuickConnect(false);
  settings.setQuickConnectHosts(new String[0]);
  settings.setConnectOnStartup(false);
  settings.setEverSupernodeCapable(true);
  settings.setDisableSupernodeMode(false);
  settings.setMaxShieldedClientConnections(LEAF_CONNECTIONS);
  settings.setKeepAlive(KEEP_ALIVE);
  ActivityCallback callback=new ActivityCallbackStub();
  FileManager files=new FileManagerStub();
  TestMessageRouter router=new TestMessageRouter(callback,files);
  RouterService rs=new RouterService(callback,router,files,new DummyAuthenticator());
  rs.initialize();
  rs.clearHostCatcher();
  try {
    rs.setKeepAlive(6);
  }
 catch (  BadConnectionSettingException e) {
    e.printStackTrace();
    Assert.that(false);
  }
  testFetchI(rs,router);
  cleanup(rs);
  testFetchII(rs,router);
  cleanup(rs);
  testAcceptI(rs,router,host,port);
  cleanup(rs);
  testAcceptII(rs,router,host,port);
  cleanup(rs);
  testAcceptIII(rs,router,host,port);
}",0.984767393989296
4923,"/** 
 * Checks that HOST:PORT will accept LIMIT connections of the given type, returning the last successful one, or null if none.
 * @param host the host to connect to
 * @param port the port to conenct to
 * @param type the type of connection to establish: LEAF, OLD_04, OLD_06,or ULTRAPEER
 * @param limit the expected number of connections
 * @param rejectType what sort of rejection to expect when over the limit:REJECT_503 (during handshaking) or REJECT_SILENT (during messaging)
 */
private static Connection testLimit(String host,int port,int type,int limit,int rejectType){
  String description=null;
  if (type == OLD_04)   description=""String_Node_Str"";
 else   if (type == OLD_06)   description=""String_Node_Str"";
 else   if (type == LEAF)   description=""String_Node_Str"";
 else   if (type == ULTRAPEER)   description=""String_Node_Str"";
 else   Assert.that(false,""String_Node_Str"" + type);
  System.out.println(""String_Node_Str"" + limit + ""String_Node_Str""+ description+ ""String_Node_Str"");
  Connection ret=null;
  for (int i=0; i < limit; i++) {
    try {
      ret=connect(host,port,type);
    }
 catch (    IOException e) {
      Assert.that(false,""String_Node_Str"" + i + ""String_Node_Str"");
    }
    buffer.add(ret);
  }
  try {
    Connection tmp=connect(host,port,type);
    Assert.that(false,""String_Node_Str"");
  }
 catch (  NoGnutellaOkException e) {
    Assert.that(rejectType == REJECT_503 && e.getCode() == HandshakeResponse.SLOTS_FULL,""String_Node_Str"" + e.getCode());
  }
catch (  IOException e) {
    Assert.that(rejectType == REJECT_SILENT,""String_Node_Str"" + e);
  }
  return ret;
}","/** 
 * Checks that HOST:PORT will accept LIMIT connections of the given type, returning the last successful one, or null if none.
 * @param host the host to connect to
 * @param port the port to conenct to
 * @param type the type of connection to establish: LEAF, OLD_04, OLD_06,or ULTRAPEER
 * @param limit the expected number of connections
 * @param rejectType what sort of rejection to expect when over the limit:REJECT_503 (during handshaking) or REJECT_SILENT (during messaging)
 */
private static Connection testLimit(String host,int port,int type,int limit,int rejectType){
  String description=null;
  if (type == OLD_04)   description=""String_Node_Str"";
 else   if (type == OLD_06)   description=""String_Node_Str"";
 else   if (type == LEAF)   description=""String_Node_Str"";
 else   if (type == ULTRAPEER)   description=""String_Node_Str"";
 else   Assert.that(false,""String_Node_Str"" + type);
  System.out.println(""String_Node_Str"" + limit + ""String_Node_Str""+ description+ ""String_Node_Str"");
  Connection ret=null;
  for (int i=0; i < limit; i++) {
    try {
      ret=connect(host,port,type);
    }
 catch (    IOException e) {
      e.printStackTrace();
      if (e instanceof NoGnutellaOkException) {
        System.out.println(""String_Node_Str"" + ((NoGnutellaOkException)e).getCode());
      }
      Assert.that(false,""String_Node_Str"" + i + ""String_Node_Str"");
    }
    buffer.add(ret);
  }
  try {
    Connection tmp=connect(host,port,type);
    Assert.that(false,""String_Node_Str"");
  }
 catch (  NoGnutellaOkException e) {
    Assert.that(rejectType == REJECT_503 && e.getCode() == HandshakeResponse.SLOTS_FULL,""String_Node_Str"" + e.getCode());
  }
catch (  IOException e) {
    Assert.that(rejectType == REJECT_SILENT,""String_Node_Str"" + e);
  }
  return ret;
}",0.950220913107511
4924,"protected HandshakeResponse respondUnauthenticated(HandshakeResponse response,boolean outgoing) throws IOException {
  if (!outgoing) {
    Properties ret=new SupernodeProperties(_router,getRemoteIP());
    ret.put(ConnectionHandshakeHeaders.X_SUPERNODE_NEEDED,(new Boolean(_manager.supernodeNeeded())).toString());
    ret.put(ConnectionHandshakeHeaders.X_MY_ADDRESS,_manager.getSelfAddress().getHostname() + ""String_Node_Str"" + _manager.getSelfAddress().getPort());
    addHostAddresses(ret,_manager);
    Properties props=response.getHeaders();
    String isUltrapeer=props.getProperty(ConnectionHandshakeHeaders.X_SUPERNODE);
    if ((isUltrapeer == null && !_manager.hasAvailableIncoming(false,false)) || (!_manager.hasAvailableIncoming(true,true) && !_manager.hasAvailableIncoming(true,false))) {
      return new HandshakeResponse(HandshakeResponse.SLOTS_FULL,HandshakeResponse.SLOTS_FULL_MESSAGE,ret);
    }
 else {
      return new HandshakeResponse(ret);
    }
  }
 else {
    Properties ret=new Properties();
    String neededS=response.getHeaders().getProperty(ConnectionHandshakeHeaders.X_SUPERNODE_NEEDED);
    if (neededS != null && !Boolean.valueOf(neededS).booleanValue() && _manager.allowClientMode()) {
      ret.put(ConnectionHandshakeHeaders.X_SUPERNODE,""String_Node_Str"");
    }
    return new HandshakeResponse(ret);
  }
}","protected HandshakeResponse respondUnauthenticated(HandshakeResponse response,boolean outgoing) throws IOException {
  if (!outgoing) {
    Properties ret=new SupernodeProperties(_router,getRemoteIP());
    ret.put(ConnectionHandshakeHeaders.X_SUPERNODE_NEEDED,(new Boolean(_manager.supernodeNeeded())).toString());
    ret.put(ConnectionHandshakeHeaders.X_MY_ADDRESS,_manager.getSelfAddress().getHostname() + ""String_Node_Str"" + _manager.getSelfAddress().getPort());
    addHostAddresses(ret,_manager);
    Properties props=response.getHeaders();
    String isUltrapeer=props.getProperty(ConnectionHandshakeHeaders.X_SUPERNODE);
    if (reject(isUltrapeer)) {
      return new HandshakeResponse(HandshakeResponse.SLOTS_FULL,HandshakeResponse.SLOTS_FULL_MESSAGE,ret);
    }
 else {
      return new HandshakeResponse(ret);
    }
  }
 else {
    Properties ret=new Properties();
    String neededS=response.getHeaders().getProperty(ConnectionHandshakeHeaders.X_SUPERNODE_NEEDED);
    if (neededS != null && !Boolean.valueOf(neededS).booleanValue() && _manager.allowClientMode()) {
      ret.put(ConnectionHandshakeHeaders.X_SUPERNODE,""String_Node_Str"");
    }
    return new HandshakeResponse(ret);
  }
}",0.9395604395604396
4925,"/** 
 * Sees how many connections we can make of the given type, returning the last successful one, or null if none.
 */
private static Connection testLimit(String host,int port,int type){
  String description=null;
  if (type == OLD)   description=""String_Node_Str"";
 else   if (type == LEAF)   description=""String_Node_Str"";
 else   if (type == ULTRAPEER)   description=""String_Node_Str"";
 else   Assert.that(false,""String_Node_Str"" + type);
  Connection ret=null;
  int i=0;
  while (i < MAX_CONNECTIONS) {
    Connection tmp=connect(host,port,type);
    if (tmp == null)     break;
    ret=tmp;
    buffer.add(ret);
    i++;
  }
  Assert.that(i < MAX_CONNECTIONS,""String_Node_Str"" + description + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ description+ ""String_Node_Str"");
  return ret;
}","/** 
 * Checks that HOST:PORT will accept LIMIT connections of the given type, returning the last successful one, or null if none.
 * @param host the host to connect to
 * @param port the port to conenct to
 * @param type the type of connection to establish: LEAF, OLD_04, OLD_06,or ULTRAPEER
 * @param limit the expected number of connections
 * @param rejectType what sort of rejection to expect when over the limit:REJECT_503 (during handshaking) or REJECT_SILENT (during messaging)
 */
private static Connection testLimit(String host,int port,int type,int limit,int rejectType){
  String description=null;
  if (type == OLD_04)   description=""String_Node_Str"";
 else   if (type == OLD_06)   description=""String_Node_Str"";
 else   if (type == LEAF)   description=""String_Node_Str"";
 else   if (type == ULTRAPEER)   description=""String_Node_Str"";
 else   Assert.that(false,""String_Node_Str"" + type);
  System.out.println(""String_Node_Str"" + limit + ""String_Node_Str""+ description+ ""String_Node_Str"");
  Connection ret=null;
  for (int i=0; i < limit; i++) {
    try {
      ret=connect(host,port,type);
    }
 catch (    IOException e) {
      Assert.that(false,""String_Node_Str"" + i + ""String_Node_Str"");
    }
    buffer.add(ret);
  }
  try {
    Connection tmp=connect(host,port,type);
    Assert.that(false,""String_Node_Str"");
  }
 catch (  NoGnutellaOkException e) {
    Assert.that(rejectType == REJECT_503 && e.getCode() == HandshakeResponse.SLOTS_FULL,""String_Node_Str"" + e.getCode());
  }
catch (  IOException e) {
    Assert.that(rejectType == REJECT_SILENT,""String_Node_Str"" + e);
  }
  return ret;
}",0.1529026982829108
4926,"public void connectionInitializing(Connection c){
}","public void connectionInitializing(Connection c){
  if (AcceptLimitTest.DEBUG)   System.out.println(""String_Node_Str"" + str(c));
}",0.56353591160221
4927,"public void connectionInitialized(Connection c){
  System.out.println(""String_Node_Str"" + str(c));
}","public void connectionInitialized(Connection c){
}",0.6666666666666666
4928,"public static void main(String args[]){
  String host=""String_Node_Str"";
  int port=6346;
  SettingsManager settings=SettingsManager.instance();
  settings.setPort(6346);
  settings.setQuickConnectHosts(new String[0]);
  settings.setConnectOnStartup(true);
  settings.setConnectOnStartup(false);
  settings.setEverSupernodeCapable(true);
  settings.setDisableSupernodeMode(true);
  settings.setMaxShieldedClientConnections(25);
  RouterService rs=new RouterService(new DebugActivityCallback(),new MessageRouterStub(),new FileManagerStub(),new DummyAuthenticator());
  rs.initialize();
  rs.clearHostCatcher();
  try {
    rs.setKeepAlive(6);
  }
 catch (  BadConnectionSettingException e) {
    Assert.that(false);
  }
  Connection c=testLimit(host,port,LEAF);
  testPong(c,true);
  testLimit(host,port,OLD);
  testPong(c,true);
  testLimit(host,port,ULTRAPEER);
  testPong(c,false);
}","public static void main(String args[]){
  String host=""String_Node_Str"";
  int port=6346;
  System.out.println(""String_Node_Str"");
  SettingsManager settings=SettingsManager.instance();
  settings.setPort(6346);
  settings.setQuickConnectHosts(new String[0]);
  settings.setConnectOnStartup(false);
  settings.setEverSupernodeCapable(true);
  settings.setDisableSupernodeMode(false);
  settings.setMaxShieldedClientConnections(LEAF_CONNECTIONS);
  ActivityCallback callback=new ActivityCallbackStub();
  FileManager files=new FileManagerStub();
  RouterService rs=new RouterService(callback,new MetaEnabledMessageRouter(callback,files),files,new DummyAuthenticator());
  rs.initialize();
  rs.clearHostCatcher();
  try {
    rs.setKeepAlive(6);
  }
 catch (  BadConnectionSettingException e) {
    Assert.that(false);
  }
  Connection c=null;
  System.out.println(""String_Node_Str"");
  c=testLimit(host,port,LEAF,LEAF_CONNECTIONS,REJECT_503);
  testPong(c,true);
  testLimit(host,port,OLD_06,KEEP_ALIVE,REJECT_503);
  testPong(c,true);
  testLimit(host,port,ULTRAPEER,KEEP_ALIVE - ConnectionManager.DESIRED_OLD_CONNECTIONS,REJECT_503);
  testPong(c,false);
  cleanup(rs);
  System.out.println(""String_Node_Str"");
  c=testLimit(host,port,ULTRAPEER,KEEP_ALIVE,REJECT_SILENT);
  testPong(c,true);
  testLimit(host,port,OLD_06,0,REJECT_503);
  testPong(c,true);
  testLimit(host,port,OLD_04,0,REJECT_SILENT);
  testPong(c,true);
  c=testLimit(host,port,LEAF,LEAF_CONNECTIONS,REJECT_503);
  testPong(c,false);
}",0.4985361773316604
4929,"public void connectionClosed(Connection c){
  System.out.println(""String_Node_Str"" + str(c));
}","public void connectionClosed(Connection c){
  if (AcceptLimitTest.DEBUG)   System.out.println(""String_Node_Str"" + str(c));
}",0.867579908675799
4930,"/** 
 * Returns a connection of the given type to host:port,  or null if it failed.
 * @param type one of t
 */
private static Connection connect(String host,int port,int type){
  Connection ret=null;
  if (type == OLD)   ret=new Connection(host,port);
 else   if (type == LEAF)   ret=new Connection(host,port,new LeafProperties(),new EmptyResponder(),false);
 else   if (type == ULTRAPEER)   ret=new Connection(host,port,new UltrapeerProperties(),new EmptyResponder(),false);
 else   Assert.that(false,""String_Node_Str"" + type);
  try {
    ret.initialize();
    ret.send(new PingRequest((byte)7));
    ret.flush();
    Message m=ret.receive();
    return ret;
  }
 catch (  IOException e) {
    return null;
  }
catch (  BadPacketException e) {
    return null;
  }
}","/** 
 * Returns a connection of the given type to host:port,  or null if it failed.
 * @param type one of t
 */
private static Connection connect(String host,int port,int type) throws IOException {
  Connection ret=null;
  if (type == OLD_04)   ret=new Connection(host,port);
 else   if (type == OLD_06)   ret=new Connection(host,port,new Properties(),new EmptyResponder(),false);
 else   if (type == LEAF)   ret=new Connection(host,port,new LeafProperties(),new EmptyResponder(),false);
 else   if (type == ULTRAPEER)   ret=new Connection(host,port,new UltrapeerProperties(),new EmptyResponder(),false);
 else   Assert.that(false,""String_Node_Str"" + type);
  ret.initialize();
  try {
    ret.send(new PingRequest((byte)7));
    ret.flush();
    Message m=ret.receive();
  }
 catch (  BadPacketException e) {
    throw new IOException(""String_Node_Str"");
  }
  return ret;
}",0.8017031630170316
4931,"/** 
 * @param a human readable description of this media type,i.e., ""Hypertext Documents""
 * @param extensions a list of all file extensions of thistype.  Must be all lowercase.  If null, this matches any file.
 */
public MediaType(String description,String[] extensions){
  this.description=description;
  this.extensions=extensions;
}","/** 
 * @param schema a MIME compliant non-localizable identifier,that matches file categories (and XSD schema names).
 * @param descriptionKey a media identifier that can be usedto retreive a localizable descriptive text.
 * @param extensions a list of all file extensions of thistype.  Must be all lowercase.  If null, this matches any file.
 */
public MediaType(String schema,String description,String[] extensions){
  this.schema=schema;
  this.description=description;
  this.extensions=extensions;
}",0.6152019002375297
4932,"/** 
 * Returns this' human-readable description
 */
public String toString(){
  return description;
}","/** 
 * Returns this' media-type (a MIME content-type category) (previously returned a description key)
 */
public String toString(){
  return schema;
}",0.6771653543307087
4933,"/** 
 * Returns an array of default media types. 
 */
private static MediaType[] getTypes(){
  MediaType any=new MediaType(ANY_TYPE,null);
  MediaType text=new MediaType(DOCUMENTS,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  MediaType programs=new MediaType(PROGRAMS,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  MediaType audio=new MediaType(AUDIO,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  MediaType video=new MediaType(VIDEO,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  MediaType images=new MediaType(IMAGES,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  return new MediaType[]{any,text,programs,audio,video,images};
}","/** 
 * Returns an array of default media types. 
 */
private static MediaType[] getTypes(){
  MediaType any=new MediaType(SCHEMA_ANY_TYPE,ANY_TYPE,null);
  MediaType text=new MediaType(SCHEMA_DOCUMENTS,DOCUMENTS,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  MediaType programs=new MediaType(SCHEMA_PROGRAMS,PROGRAMS,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  MediaType audio=new MediaType(SCHEMA_AUDIO,AUDIO,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  MediaType video=new MediaType(SCHEMA_VIDEO,VIDEO,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  MediaType images=new MediaType(SCHEMA_IMAGES,IMAGES,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  return new MediaType[]{any,text,programs,audio,video,images};
}",0.8192842354333038
4934,"public static MediaType[] getDefaultMediaTypes(){
  if (allMediaTypes == null)   allMediaTypes=getTypes();
  return allMediaTypes;
}","public static final MediaType[] getDefaultMediaTypes(){
  if (allMediaTypes == null)   allMediaTypes=getTypes();
  return allMediaTypes;
}",0.9777777777777776
4935,"/** 
 * Reads the downloaders serialized in DOWNLOAD_SNAPSHOT_FILE and adds them to this, queued.  The queued downloads will restart immediately if slots are available.  Returns false iff the file could not be read for any reason.  THIS METHOD SHOULD BE CALLED BEFORE ANY GUI ACTION. 
 */
public synchronized boolean readSnapshot(){
  List buf=null;
  try {
    ObjectInputStream in=new ObjectInputStream(new FileInputStream(SettingsManager.instance().getDownloadSnapshotFile()));
    buf=(List)in.readObject();
    incompleteFileManager=(IncompleteFileManager)in.readObject();
  }
 catch (  IOException e) {
    return false;
  }
catch (  ClassCastException e) {
    return false;
  }
catch (  ClassNotFoundException e) {
    return false;
  }
  if (incompleteFileManager.purge())   writeSnapshot();
  try {
    for (Iterator iter=buf.iterator(); iter.hasNext(); ) {
      ManagedDownloader downloader=(ManagedDownloader)iter.next();
      waiting.add(downloader);
      downloader.initialize(this,this.fileManager);
      callback.addDownload(downloader);
    }
    return true;
  }
 catch (  ClassCastException e) {
    return false;
  }
}","/** 
 * Reads the downloaders serialized in DOWNLOAD_SNAPSHOT_FILE and adds them to this, queued.  The queued downloads will restart immediately if slots are available.  Returns false iff the file could not be read for any reason.  THIS METHOD SHOULD BE CALLED BEFORE ANY GUI ACTION. 
 */
synchronized boolean readSnapshot(){
  List buf=null;
  try {
    ObjectInputStream in=new ObjectInputStream(new FileInputStream(SettingsManager.instance().getDownloadSnapshotFile()));
    buf=(List)in.readObject();
    incompleteFileManager=(IncompleteFileManager)in.readObject();
  }
 catch (  IOException e) {
    return false;
  }
catch (  ClassCastException e) {
    return false;
  }
catch (  ClassNotFoundException e) {
    return false;
  }
  if (incompleteFileManager.purge())   writeSnapshot();
  try {
    for (Iterator iter=buf.iterator(); iter.hasNext(); ) {
      ManagedDownloader downloader=(ManagedDownloader)iter.next();
      waiting.add(downloader);
      downloader.initialize(this,this.fileManager);
      callback.addDownload(downloader);
    }
    return true;
  }
 catch (  ClassCastException e) {
    return false;
  }
}",0.9969257795344753
4936,"/** 
 * Writes a snapshot of all downloaders in this and all incomplete files to the file named DOWNLOAD_SNAPSHOT_FILE.  It is safe to call this method at any time for checkpointing purposes.  Returns true iff the file was successfully written. 
 */
public synchronized boolean writeSnapshot(){
  List buf=new ArrayList();
  buf.addAll(active);
  buf.addAll(waiting);
  for (Iterator iter=buf.iterator(); iter.hasNext(); ) {
    ManagedDownloader downloader=(ManagedDownloader)iter.next();
    downloader.updateIncompleteFileManager();
  }
  try {
    ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(SettingsManager.instance().getDownloadSnapshotFile()));
    out.writeObject(buf);
synchronized (incompleteFileManager) {
      out.writeObject(incompleteFileManager);
    }
    out.flush();
    out.close();
    return true;
  }
 catch (  IOException e) {
    return false;
  }
}","/** 
 * Writes a snapshot of all downloaders in this and all incomplete files to the file named DOWNLOAD_SNAPSHOT_FILE.  It is safe to call this method at any time for checkpointing purposes.  Returns true iff the file was successfully written. 
 */
synchronized boolean writeSnapshot(){
  List buf=new ArrayList();
  buf.addAll(active);
  buf.addAll(waiting);
  for (Iterator iter=buf.iterator(); iter.hasNext(); ) {
    ManagedDownloader downloader=(ManagedDownloader)iter.next();
    downloader.updateIncompleteFileManager();
  }
  try {
    ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(SettingsManager.instance().getDownloadSnapshotFile()));
    out.writeObject(buf);
synchronized (incompleteFileManager) {
      out.writeObject(incompleteFileManager);
    }
    out.flush();
    out.close();
    return true;
  }
 catch (  IOException e) {
    return false;
  }
}",0.996082820369334
4937,"/** 
 * Initializes this manager. <b>This method must be called before any other methods are used.</b> 
 * @param callback the UI callback to notify of download changes
 * @param router the message router to use for sending push requests
 * @param acceptor used to get my IP address and port for pushes
 * @param fileManager used to check if files exist
 * @param backend provides the schedule(..) method for checkpointing downloads.dat
 */
public void initialize(ActivityCallback callback,MessageRouter router,Acceptor acceptor,FileManager fileManager,RouterService backend){
  this.callback=callback;
  this.router=router;
  this.acceptor=acceptor;
  this.fileManager=fileManager;
  Runnable checkpointer=new Runnable(){
    public void run(){
      if (downloadsInProgress() > 0)       writeSnapshot();
    }
  }
;
  backend.schedule(checkpointer,0,SNAPSHOT_CHECKPOINT_TIME);
}","/** 
 * Initializes this manager. <b>This method must be called before any other methods are used.</b> 
 * @param callback the UI callback to notify of download changes
 * @param router the message router to use for sending push requests
 * @param acceptor used to get my IP address and port for pushes
 * @param fileManager used to check if files exist
 */
public void initialize(ActivityCallback callback,MessageRouter router,Acceptor acceptor,FileManager fileManager){
  this.callback=callback;
  this.router=router;
  this.acceptor=acceptor;
  this.fileManager=fileManager;
}",0.7936943111720356
4938,"/** 
 * Kicks off expensive backend tasks (like file loading) that should only be done after GUI is loaded. 
 */
public void postGuiInit(){
  fileManager.initialize(callback);
  downloader.readSnapshot();
}","/** 
 * Kicks off expensive backend tasks (like file loading) that should only be done after GUI is loaded. 
 */
public void postGuiInit(){
  fileManager.initialize(callback);
  downloader.postGuiInit(this);
}",0.9349397590361446
4939,"/** 
 * Initializes the key backend components.  Some tasks are postponed until postGuiInit().
 */
public void initialize(){
  SettingsManager settings=SettingsManager.instance();
  int port=settings.getPort();
  this.acceptor=new Acceptor(port,callback);
  this.manager=createConnectionManager();
  this.catcher=createHostCatcher();
  this.downloader=new DownloadManager();
  this.uploadManager=new UploadManager();
  this.chatManager=ChatManager.instance();
  this.catcher.initialize(acceptor,manager,SettingsManager.instance().getHostList());
  this.router.initialize(acceptor,manager,catcher,uploadManager);
  this.manager.initialize(router,catcher);
  this.uploadManager.initialize(callback,router,acceptor,fileManager);
  this.acceptor.initialize(manager,router,downloader,uploadManager);
  this.chatManager.setActivityCallback(callback);
  this.downloader.initialize(callback,router,acceptor,fileManager,this);
  SupernodeAssigner sa=new SupernodeAssigner(uploadManager,downloader,manager);
  sa.start(this);
  if (settings.getConnectOnStartup()) {
    int outgoing=settings.getKeepAlive();
    if (outgoing > 0)     connect();
  }
}","/** 
 * Initializes the key backend components.  Some tasks are postponed until postGuiInit().
 */
public void initialize(){
  SettingsManager settings=SettingsManager.instance();
  int port=settings.getPort();
  this.acceptor=new Acceptor(port,callback);
  this.manager=createConnectionManager();
  this.catcher=createHostCatcher();
  this.downloader=new DownloadManager();
  this.uploadManager=new UploadManager();
  this.chatManager=ChatManager.instance();
  this.catcher.initialize(acceptor,manager,SettingsManager.instance().getHostList());
  this.router.initialize(acceptor,manager,catcher,uploadManager);
  this.manager.initialize(router,catcher);
  this.uploadManager.initialize(callback,router,acceptor,fileManager);
  this.acceptor.initialize(manager,router,downloader,uploadManager);
  this.chatManager.setActivityCallback(callback);
  this.downloader.initialize(callback,router,acceptor,fileManager);
  SupernodeAssigner sa=new SupernodeAssigner(uploadManager,downloader,manager);
  sa.start(this);
  if (settings.getConnectOnStartup()) {
    int outgoing=settings.getKeepAlive();
    if (outgoing > 0)     connect();
  }
}",0.9978021978021978
4940,"/** 
 * Returns true iff file is ""too old"". 
 */
private static final boolean isOld(File file){
  long lastModified=file.lastModified();
  int days=SettingsManager.instance().getIncompletePurgeTime();
  long purgeTime=System.currentTimeMillis() - days * 24 * 60* 60* 1000;
  return lastModified < purgeTime;
}","/** 
 * Returns true iff file is ""too old"". 
 */
private static final boolean isOld(File file){
  long lastModified=file.lastModified();
  long days=SettingsManager.instance().getIncompletePurgeTime();
  long purgeTime=System.currentTimeMillis() - days * 24l * 60l* 60l* 1000l;
  return lastModified < purgeTime;
}",0.9823434991974318
4941,"public boolean writeID3DataToDisk(String fileName){
  File f=null;
  RandomAccessFile file=null;
  try {
    f=new File(fileName);
    file=new RandomAccessFile(f,""String_Node_Str"");
  }
 catch (  IOException e) {
    return false;
  }
  long length=0;
  try {
    length=file.length();
    if (length < 128)     return true;
    file.seek(length - 128);
  }
 catch (  IOException ee) {
    return true;
  }
  byte[] buffer=new byte[30];
  String tag=""String_Node_Str"";
  try {
    file.readFully(buffer,0,3);
    tag=new String(buffer,0,3);
  }
 catch (  Exception e) {
    e.printStackTrace();
    return true;
  }
  if (!tag.equals(""String_Node_Str"")) {
    try {
      byte[] tagBytes=""String_Node_Str"".getBytes();
      file.seek(length - 128);
      file.write(tagBytes,0,3);
    }
 catch (    Exception eee) {
      return false;
    }
  }
  debug(""String_Node_Str"");
  boolean b=toFile(title_,30,file,buffer);
  b=(b && toFile(artist_,30,file,buffer));
  b=(b && toFile(album_,30,file,buffer));
  b=(b && toFile(year_,4,file,buffer));
  b=(b && toFile(comment_,28,file,buffer));
  try {
    file.write(0);
    byte trackByte;
    if (track_ == null || track_.equals(""String_Node_Str""))     trackByte=(byte)0;
 else     trackByte=Byte.parseByte(track_);
    file.write(trackByte);
    byte genreByte=getGenreByte();
    file.write(genreByte);
    file.close();
  }
 catch (  IOException e) {
    b=false;
  }
  return b;
}","public int writeID3DataToDisk(String fileName){
  File f=null;
  RandomAccessFile file=null;
  try {
    f=new File(fileName);
    file=new RandomAccessFile(f,""String_Node_Str"");
  }
 catch (  IOException e) {
    return LimeXMLReplyCollection.FILE_DEFECTIVE;
  }
  long length=0;
  try {
    length=file.length();
    if (length < 128)     return LimeXMLReplyCollection.FILE_DEFECTIVE;
    file.seek(length - 128);
  }
 catch (  IOException ee) {
    return LimeXMLReplyCollection.RW_ERROR;
  }
  byte[] buffer=new byte[30];
  String tag=""String_Node_Str"";
  try {
    file.readFully(buffer,0,3);
    tag=new String(buffer,0,3);
  }
 catch (  Exception e) {
    return LimeXMLReplyCollection.RW_ERROR;
  }
  if (!tag.equals(""String_Node_Str"")) {
    try {
      byte[] tagBytes=""String_Node_Str"".getBytes();
      file.seek(length - 128);
      file.write(tagBytes,0,3);
    }
 catch (    Exception eee) {
      return LimeXMLReplyCollection.BAD_ID3;
    }
  }
  debug(""String_Node_Str"");
  boolean b;
  b=toFile(title_,30,file,buffer);
  if (!b)   return LimeXMLReplyCollection.FAILED_TITLE;
  b=toFile(artist_,30,file,buffer);
  if (!b)   return LimeXMLReplyCollection.FAILED_ARTIST;
  b=toFile(album_,30,file,buffer);
  if (!b)   return LimeXMLReplyCollection.FAILED_ALBUM;
  b=toFile(year_,4,file,buffer);
  if (!b)   return LimeXMLReplyCollection.FAILED_YEAR;
  b=toFile(comment_,28,file,buffer);
  if (!b)   return LimeXMLReplyCollection.FAILED_COMMENT;
  byte trackByte=(byte)-1;
  try {
    if (track_ == null || track_.equals(""String_Node_Str""))     trackByte=(byte)0;
 else     trackByte=Byte.parseByte(track_);
  }
 catch (  NumberFormatException nfe) {
    return LimeXMLReplyCollection.FAILED_TRACK;
  }
  try {
    file.write(0);
    file.write(trackByte);
  }
 catch (  IOException e) {
    return LimeXMLReplyCollection.RW_ERROR;
  }
  try {
    byte genreByte=getGenreByte();
    file.write(genreByte);
  }
 catch (  Exception e) {
    return LimeXMLReplyCollection.FAILED_GENRE;
  }
  try {
    file.close();
  }
 catch (  IOException ioe) {
    return LimeXMLReplyCollection.RW_ERROR;
  }
  return LimeXMLReplyCollection.NORMAL;
}",0.6778429728974574
4942,"public void replaceDoc(Object hash,LimeXMLDocument newDoc){
synchronized (mainMapLock) {
    mainMap.put(hash,newDoc);
  }
  replyDocs=null;
}","/** 
 * @return the older document, which is being replaced. Can be null.
 */
public LimeXMLDocument replaceDoc(Object hash,LimeXMLDocument newDoc){
  LimeXMLDocument oldDoc=null;
synchronized (mainMapLock) {
    oldDoc=(LimeXMLDocument)mainMap.get(hash);
    mainMap.put(hash,newDoc);
  }
  replyDocs=null;
  return oldDoc;
}",0.5641025641025641
4943,"public boolean mp3ToDisk(String mp3FileName){
  boolean mp3=LimeXMLUtils.isMP3File(mp3FileName);
  boolean wrote=false;
  boolean wrote2=false;
  toDisk(mp3FileName);
  if (this.editor != null) {
    wrote2=this.editor.writeID3DataToDisk(mp3FileName);
    File file=new File(mp3FileName);
    String newHash=null;
    try {
      newHash=new String(LimeXMLUtils.hashFile(file));
    }
 catch (    Exception e) {
      return false;
    }
synchronized (mainMapLock) {
      Object mainValue=mainMap.remove(changedHash);
      mainMap.put(newHash,mainValue);
    }
    metaFileManager.writeToMap(file,newHash,mp3);
    metaFileManager.handleChangedHash(changedHash,newHash,this);
    Object outValue=outMap.remove(changedHash);
    outMap.put(newHash,outValue);
  }
 else   wrote2=true;
  wrote=write();
  this.outMap=null;
  this.changedHash=null;
  this.editor=null;
  return (wrote && wrote2);
}","public int mp3ToDisk(String mp3FileName){
  boolean mp3=LimeXMLUtils.isMP3File(mp3FileName);
  boolean wrote=false;
  int mp3WriteState=-1;
  toDisk(mp3FileName);
  if (this.editor != null) {
    mp3WriteState=this.editor.writeID3DataToDisk(mp3FileName);
    if (mp3WriteState != NORMAL)     return mp3WriteState;
    File file=new File(mp3FileName);
    String newHash=null;
    try {
      newHash=new String(LimeXMLUtils.hashFile(file));
    }
 catch (    Exception e) {
      return HASH_FAILED;
    }
synchronized (mainMapLock) {
      Object mainValue=mainMap.remove(changedHash);
      mainMap.put(newHash,mainValue);
    }
    metaFileManager.writeToMap(file,newHash,mp3);
    metaFileManager.handleChangedHash(changedHash,newHash,this);
    Object outValue=outMap.remove(changedHash);
    outMap.put(newHash,outValue);
  }
  wrote=write();
  this.outMap=null;
  this.changedHash=null;
  this.editor=null;
  if (!wrote) {
    System.out.println(""String_Node_Str"");
    return RW_ERROR;
  }
  return mp3WriteState;
}",0.8160500260552371
4944,"/** 
 * Returns the directory where all user settings should be stored.  This is where all application data should be stored.  If the directory does does not already exist, this attempts to create the directory, although this is not guaranteed to succeed.
 * @return the <tt>File</tt> instance denoting the user's home directory for the application, or <tt>null</tt> if that directory  does not exist
 */
public static File getUserSettingsDir(){
  File settingsDir=null;
  if (CommonUtils.isWindows()) {
    settingsDir=CommonUtils.getCurrentDirectory();
  }
 else   if (CommonUtils.isMacOSX()) {
    File userPrefsDir;
    try {
      short userDomainCode=-32763;
      userPrefsDir=MRJFileUtils.findFolder(userDomainCode,new MRJOSType(""String_Node_Str""));
      settingsDir=new File(userPrefsDir,""String_Node_Str"");
    }
 catch (    FileNotFoundException e) {
    }
  }
 else {
    settingsDir=new File(CommonUtils.getUserHomeDir(),""String_Node_Str"");
  }
  if (settingsDir == null) {
    settingsDir=new File(CommonUtils.getUserHomeDir(),""String_Node_Str"");
  }
  if (!settingsDir.isDirectory()) {
    settingsDir.mkdirs();
  }
  return settingsDir;
}","/** 
 * Returns the directory where all user settings should be stored.  This is where all application data should be stored.  If the directory does does not already exist, this attempts to create the directory, although this is not guaranteed to succeed.
 * @return the <tt>File</tt> instance denoting the user's home directory for the application, or <tt>null</tt> if that directory  does not exist
 */
public static File getUserSettingsDir(){
  File settingsDir=null;
  if (CommonUtils.isWindows()) {
    settingsDir=CommonUtils.getCurrentDirectory();
  }
 else   if (CommonUtils.isMacOSX()) {
    File userPrefsDir;
    try {
      short userDomainCode=-32763;
      userPrefsDir=MRJFileUtils.findFolder(userDomainCode,new MRJOSType(""String_Node_Str""));
      settingsDir=new File(userPrefsDir,""String_Node_Str"");
    }
 catch (    FileNotFoundException e) {
    }
catch (    NoSuchMethodError e) {
      settingsDir=CommonUtils.getCurrentDirectory();
    }
  }
 else {
    settingsDir=new File(CommonUtils.getUserHomeDir(),""String_Node_Str"");
  }
  if (settingsDir == null) {
    settingsDir=new File(CommonUtils.getUserHomeDir(),""String_Node_Str"");
  }
  if (!settingsDir.isDirectory()) {
    settingsDir.mkdirs();
  }
  return settingsDir;
}",0.961298377028714
4945,"/** 
 * See note on serialization at top of file  <p> Note that we are serializing a new BandwidthImpl to the stream.  This is for compatibility reasons, so the new version of the code  will run with an older download.dat file.     
 */
private synchronized void writeObject(ObjectOutputStream stream) throws IOException {
  stream.writeObject(allFiles);
synchronized (incompleteFileManager) {
    stream.writeObject(incompleteFileManager);
  }
  stream.writeObject(new BandwidthTrackerImpl());
}","/** 
 * See note on serialization at top of file  <p> Note that we are serializing a new BandwidthImpl to the stream.  This is for compatibility reasons, so the new version of the code  will run with an older download.dat file.     
 */
private synchronized void writeObject(ObjectOutputStream stream) throws IOException {
  stream.writeObject(allFiles);
synchronized (incompleteFileManager) {
    stream.writeObject(incompleteFileManager);
  }
  stream.writeObject(null);
}",0.9711340206185568
4946,"/** 
 * Waits for a timer task appropriate for execution.  Returns null if none is yet ready; call waitForTask again in this case.  
 * @exception InterruptedException this was interrupted while waiting
 */
private SimpleTimerTask waitForTask() throws InterruptedException {
synchronized (_queue) {
    if (_queue.isEmpty()) {
      _queue.wait();
      return null;
    }
 else {
      SimpleTimerTask task=(SimpleTimerTask)_queue.extractMax();
      long time=task.timeUntilExecution();
      if (time > 0) {
        _queue.wait(time);
        return null;
      }
 else {
        return task;
      }
    }
  }
}","/** 
 * Waits for and removes timer task appropriate for execution.  Returns null if none is yet ready; call waitForTask again in this case.
 * @exception InterruptedException this was interrupted while waiting
 */
private SimpleTimerTask waitForTask() throws InterruptedException {
synchronized (_queue) {
    if (_queue.isEmpty()) {
      _queue.wait();
      return null;
    }
 else {
      SimpleTimerTask task=(SimpleTimerTask)_queue.getMax();
      long time=task.timeUntilExecution();
      if (time > 0) {
        _queue.wait(time);
        return null;
      }
 else {
        SimpleTimerTask task2=(SimpleTimerTask)_queue.extractMax();
        Assert.that(task2 == task,""String_Node_Str"");
        return task;
      }
    }
  }
}",0.8952802359882006
4947,"/** 
 * Schedules the given task for fixed-delay execution after the given delay, repeating every period.
 * @param task the task to run repeatedly
 * @param delay the initial delay, in milliseconds
 * @param period the delay between executions, in milliseconds
 * @exception IllegalStateException this is cancelled
 * @see java.util.Timer#schedule(java.util.TimerTask,long,long)
 */
public void schedule(Runnable task,long delay,long period) throws IllegalStateException {
  if (_isCancelled)   throw new IllegalStateException(""String_Node_Str"");
  long now=System.currentTimeMillis();
  SimpleTimerTask ttask=new SimpleTimerTask(task,period,now + delay);
synchronized (_queue) {
    Object discarded=_queue.insert(ttask);
    Assert.that(discarded == null,""String_Node_Str"");
    _queue.notify();
  }
}","/** 
 * Schedules the given task for fixed-delay execution after the given delay, repeating every period.
 * @param task the task to run repeatedly
 * @param delay the initial delay, in milliseconds
 * @param period the delay between executions, in milliseconds
 * @exception IllegalStateException this is cancelled
 * @exception IllegalArgumentException delay or period negative
 * @see java.util.Timer#schedule(java.util.TimerTask,long,long)
 */
public void schedule(Runnable task,long delay,long period) throws IllegalStateException {
  if (_isCancelled)   throw new IllegalStateException(""String_Node_Str"");
  if (delay < 0)   throw new IllegalArgumentException(""String_Node_Str"" + delay);
  if (period < 0)   throw new IllegalArgumentException(""String_Node_Str"" + period);
  long now=System.currentTimeMillis();
  SimpleTimerTask ttask=new SimpleTimerTask(task,period,now + delay,_callback);
synchronized (_queue) {
    Object discarded=_queue.insert(ttask);
    Assert.that(discarded == null,""String_Node_Str"");
    _queue.notify();
  }
}",0.8701298701298701
4948,"/** 
 * Returns the time in milliseconds to wait until this should be run. Returns a non-positive value if this should be run immediately.
 */
public long timeUntilExecution(){
  return System.currentTimeMillis() - _nextTime;
}","/** 
 * Returns the time in milliseconds to wait until this should be run. Returns a non-positive value if this should be run immediately.
 */
public long timeUntilExecution(){
  return _nextTime - System.currentTimeMillis();
}",0.947136563876652
4949,"/** 
 * Calls _task.run(), then updates _nextTime.  Catches any exceptions while running task.  
 */
public void runAndReschedule(){
  try {
    _task.run();
  }
 catch (  Exception e) {
  }
  _nextTime=System.currentTimeMillis() + _period;
}","/** 
 * Calls _task.run(), then updates _nextTime.  Catches any exceptions while running task.  
 */
public void runAndReschedule(){
  try {
    _task.run();
  }
 catch (  Exception e) {
    if (_callback != null)     _callback.error(e);
  }
  _nextTime=System.currentTimeMillis() + _period;
}",0.9046728971962616
4950,"/** 
 * Creates a new active SimpleTimer.
 * @param isDaemon true if this' thread should be a daemon.
 */
public SimpleTimer(boolean isDaemon){
  _runner=new TimerRunnerThread(isDaemon);
  _runner.start();
}","/** 
 * Creates a new active SimpleTimer with a callback for internal errors.
 * @param isDaemon true if this' thread should be a daemon.
 * @param callback if non-null, calls callback.error(..) if any scheduledtasks throws an uncaught exception
 */
public SimpleTimer(boolean isDaemon,ActivityCallback callback){
  _runner=new TimerRunnerThread(isDaemon);
  _runner.start();
  _callback=callback;
}",0.6831683168316832
4951,"SimpleTimerTask(Runnable task,long period,long nextTime){
  this._task=task;
  this._period=period;
  this._nextTime=nextTime;
}","SimpleTimerTask(Runnable task,long period,long nextTime,ActivityCallback callback){
  this._task=task;
  this._period=period;
  this._nextTime=nextTime;
  this._callback=callback;
}",0.8284789644012945
4952,"/** 
 * While the connection is not closed, sends all data delay. 
 */
public void run(){
  while (isOpen()) {
    repOk();
    try {
      waitForQueued();
    }
 catch (    InterruptedException e) {
      System.err.println(""String_Node_Str"");
      System.err.println(""String_Node_Str"");
      return;
    }
    try {
      sendQueued();
    }
 catch (    IOException e) {
      _manager.remove(ManagedConnection.this);
    }
    repOk();
  }
}","/** 
 * While the connection is not closed, sends all data delay. 
 */
public void run(){
  while (true) {
    repOk();
    try {
      waitForQueued();
      sendQueued();
    }
 catch (    IOException e) {
      if (_manager != null)       _manager.remove(ManagedConnection.this);
      _runnerDied=true;
      return;
    }
    repOk();
  }
}",0.6944444444444444
4953,"/** 
 * Wait until the queue is (probably) non-empty. 
 */
private final void waitForQueued() throws InterruptedException {
  if (isInterrupted()) {
    throw new InterruptedException();
  }
synchronized (_outputQueueLock) {
    while (_queued == 0) {
      _outputQueueLock.wait();
    }
  }
}","/** 
 * Wait until the queue is (probably) non-empty or closed. 
 * @exception IOException this was closed while waiting
 */
private final void waitForQueued() throws IOException {
synchronized (_outputQueueLock) {
    while (isOpen() && _queued == 0) {
      try {
        _outputQueueLock.wait();
      }
 catch (      InterruptedException e) {
        Assert.that(false,""String_Node_Str"");
      }
    }
  }
  if (!isOpen())   throw new IOException();
}",0.4133333333333333
4954,"/** 
 * Override of receive to do MessageRouter stats and to properly shut down the connection on IOException
 */
public Message receive(int timeout) throws IOException, BadPacketException, InterruptedIOException {
  Message m=null;
  try {
    m=super.receive(timeout);
    _bytesReceived+=m.getTotalLength();
  }
 catch (  IOException e) {
    _manager.remove(this);
    throw e;
  }
  _numMessagesReceived++;
  _router.countMessage();
  return m;
}","/** 
 * Override of receive to do MessageRouter stats and to properly shut down the connection on IOException
 */
public Message receive(int timeout) throws IOException, BadPacketException, InterruptedIOException {
  Message m=null;
  try {
    m=super.receive(timeout);
    _bytesReceived+=m.getTotalLength();
  }
 catch (  IOException e) {
    if (_manager != null)     _manager.remove(this);
    throw e;
  }
  _numMessagesReceived++;
  _router.countMessage();
  return m;
}",0.9719827586206896
4955,"public void initialize() throws IOException, NoGnutellaOkException, BadHandshakeException {
  super.initialize();
  _outputRunnerThread=new OutputRunner();
}","public void initialize() throws IOException, NoGnutellaOkException, BadHandshakeException {
  super.initialize();
  new OutputRunner();
}",0.9319727891156464
4956,"private static boolean download(String file,String header,String expResp) throws IOException {
  Socket s=new Socket(address,port);
  BufferedReader in=new BufferedReader(new InputStreamReader(s.getInputStream()));
  BufferedWriter out=new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  String ret=downloadInternal(file,header,out,in);
  in.close();
  out.close();
  s.close();
  return ret.equals(expResp);
}","private static boolean download(String file,String header,String expResp,String expHeader) throws IOException {
  Socket s=new Socket(address,port);
  BufferedReader in=new BufferedReader(new InputStreamReader(s.getInputStream()));
  BufferedWriter out=new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  String ret=downloadInternal(file,header,out,in,expHeader);
  in.close();
  out.close();
  s.close();
  return ret.equals(expResp);
}",0.9692132269099202
4957,"/** 
 * Sends a get request to out, reads the response from in, and returns the content.  Doesn't close in or out.
 */
private static String downloadInternal(String file,String header,BufferedWriter out,BufferedReader in) throws IOException {
  out.write(""String_Node_Str"" + index + ""String_Node_Str""+ file+ ""String_Node_Str"");
  if (header != null)   out.write(header + ""String_Node_Str"");
  out.write(""String_Node_Str"");
  out.flush();
  while (!in.readLine().equals(""String_Node_Str"")) {
  }
  StringBuffer buf=new StringBuffer();
  while (true) {
    int c=in.read();
    if (c < 0)     break;
    buf.append((char)c);
  }
  return buf.toString();
}","/** 
 * Sends a get request to out, reads the response from in, and returns the content.  Doesn't close in or out.
 * @param requiredHeader a header to look for, or null if we don't care
 */
private static String downloadInternal(String file,String header,BufferedWriter out,BufferedReader in,String requiredHeader) throws IOException {
  out.write(""String_Node_Str"" + index + ""String_Node_Str""+ file+ ""String_Node_Str"");
  if (header != null)   out.write(header + ""String_Node_Str"");
  out.write(""String_Node_Str"");
  out.flush();
  boolean foundHeader=false;
  while (true) {
    String line=in.readLine();
    if (line.equals(""String_Node_Str""))     break;
    if (requiredHeader != null)     if (canonicalizeHeader(line).equals(canonicalizeHeader(requiredHeader)))     foundHeader=true;
  }
  if (requiredHeader != null)   Assert.that(foundHeader,""String_Node_Str"");
  StringBuffer buf=new StringBuffer();
  while (true) {
    int c=in.read();
    if (c < 0)     break;
    buf.append((char)c);
  }
  return buf.toString();
}",0.7538644470868014
4958,"public static void main(String args[]){
  try {
    address=args[0];
    port=Integer.parseInt(args[1]);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str""+ address+ ""String_Node_Str""+ file+ ""String_Node_Str""+ index+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ callbackPort+ ""String_Node_Str"");
  try {
    boolean passed;
    passed=downloadPush(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush1(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush1(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    Assert.that(URLDecoder.decode(encodedFile).equals(file),""String_Node_Str"" + URLDecoder.decode(encodedFile));
    passed=download(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"" + ""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    Assert.that(URLDecoder.decode(encodedFile).equals(file),""String_Node_Str"" + URLDecoder.decode(encodedFile));
    passed=download1(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=pipelineDownloadNormal(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=pipelineDownloadPush(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
  }
 catch (  IOException e) {
    e.printStackTrace();
    Assert.that(false,""String_Node_Str"");
  }
catch (  BadPacketException e) {
    e.printStackTrace();
    Assert.that(false,""String_Node_Str"");
  }
}","public static void main(String args[]){
  try {
    address=args[0];
    port=Integer.parseInt(args[1]);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str""+ address+ ""String_Node_Str""+ file+ ""String_Node_Str""+ index+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ callbackPort+ ""String_Node_Str"");
  try {
    boolean passed;
    passed=downloadPush(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush1(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush1(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    Assert.that(URLDecoder.decode(encodedFile).equals(file),""String_Node_Str"" + URLDecoder.decode(encodedFile));
    passed=download(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"" + ""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    Assert.that(URLDecoder.decode(encodedFile).equals(file),""String_Node_Str"" + URLDecoder.decode(encodedFile));
    passed=download1(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=pipelineDownloadNormal(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=pipelineDownloadPush(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
  }
 catch (  IOException e) {
    e.printStackTrace();
    Assert.that(false,""String_Node_Str"");
  }
catch (  BadPacketException e) {
    e.printStackTrace();
    Assert.that(false,""String_Node_Str"");
  }
}",0.9946284691136974
4959,"/** 
 * writes the appropriate header information to the socket
 */
private void writeHeader() throws IOException {
  String str;
  str=""String_Node_Str"";
  _ostream.write(str.getBytes());
  str=""String_Node_Str"" + CommonUtils.getVendor() + ""String_Node_Str"";
  _ostream.write(str.getBytes());
  String type=getMimeType();
  str=""String_Node_Str"" + type + ""String_Node_Str"";
  _ostream.write(str.getBytes());
  str=""String_Node_Str"" + (_uploadEnd - _uploadBegin) + ""String_Node_Str"";
  _ostream.write(str.getBytes());
  if (_uploadBegin != 0) {
    str=""String_Node_Str"" + _uploadBegin + ""String_Node_Str""+ (_fileSize - 1)+ ""String_Node_Str""+ _fileSize+ ""String_Node_Str"";
    _ostream.write(str.getBytes());
  }
  str=""String_Node_Str"";
  _ostream.write(str.getBytes());
}","/** 
 * writes the appropriate header information to the socket
 */
private void writeHeader() throws IOException {
  String str;
  str=""String_Node_Str"";
  _ostream.write(str.getBytes());
  str=""String_Node_Str"" + CommonUtils.getVendor() + ""String_Node_Str"";
  _ostream.write(str.getBytes());
  String type=getMimeType();
  str=""String_Node_Str"" + type + ""String_Node_Str"";
  _ostream.write(str.getBytes());
  str=""String_Node_Str"" + (_uploadEnd - _uploadBegin) + ""String_Node_Str"";
  _ostream.write(str.getBytes());
  if (_uploadBegin != 0) {
    str=""String_Node_Str"" + _uploadBegin + ""String_Node_Str""+ (_uploadEnd - 1)+ ""String_Node_Str""+ _fileSize+ ""String_Node_Str"";
    _ostream.write(str.getBytes());
  }
  str=""String_Node_Str"";
  _ostream.write(str.getBytes());
}",0.9541047188106012
4960,"/** 
 * Returns the directory where all user settings should be stored.  This is where all application data should be stored.  If the directory does does not already exist, this attempts to create the directory, although this is not guaranteed to succeed.
 * @return the <tt>File</tt> instance denoting the user's home directory for the application, or <tt>null</tt> if that directory  does not exist
 */
public static File getUserSettingsDir(){
  if (this.isWindows()) {
    return this.getCurrentDirectory();
  }
  final File HOME_DIR=new File(getUserHomeDir(),""String_Node_Str"");
  if (!HOME_DIR.isDirectory()) {
    HOME_DIR.mkdirs();
  }
  return HOME_DIR;
}","/** 
 * Returns the directory where all user settings should be stored.  This is where all application data should be stored.  If the directory does does not already exist, this attempts to create the directory, although this is not guaranteed to succeed.
 * @return the <tt>File</tt> instance denoting the user's home directory for the application, or <tt>null</tt> if that directory  does not exist
 */
public static File getUserSettingsDir(){
  if (isWindows()) {
    return getCurrentDirectory();
  }
  final File HOME_DIR=new File(getUserHomeDir(),""String_Node_Str"");
  if (!HOME_DIR.isDirectory()) {
    HOME_DIR.mkdirs();
  }
  return HOME_DIR;
}",0.9924012158054712
4961,"private void readHeaders() throws IOException {
  if (_byteReader == null)   throw new ReaderIsNullException();
  String str=_byteReader.readLine();
  if (str == null || str.equals(""String_Node_Str""))   return;
  int code=parseHTTPCode(str);
  if ((code < 200) || (code > 300)) {
    if (code == 404)     throw new com.limegroup.gnutella.downloader.FileNotFoundException();
 else     if (code == 410)     throw new com.limegroup.gnutella.downloader.NotSharingException();
 else     if (code == 503)     throw new TryAgainLaterException();
 else     throw new IOException();
  }
  while (true) {
    str=_byteReader.readLine();
    if (str == null || str.equals(""String_Node_Str""))     break;
    if (str.toUpperCase().startsWith(""String_Node_Str"")) {
      int startOffset=parseContentRangeStart(str);
      if (startOffset != _initialReadingPoint)       throw new IOException(""String_Node_Str"");
    }
  }
}","private void readHeaders() throws IOException {
  if (_byteReader == null)   throw new ReaderIsNullException();
  String str=_byteReader.readLine();
  if (str == null || str.equals(""String_Node_Str""))   return;
  int code=parseHTTPCode(str);
  if ((code < 200) || (code >= 300)) {
    if (code == 404)     throw new com.limegroup.gnutella.downloader.FileNotFoundException();
 else     if (code == 410)     throw new com.limegroup.gnutella.downloader.NotSharingException();
 else     if (code == 503)     throw new TryAgainLaterException();
 else     throw new IOException();
  }
  while (true) {
    str=_byteReader.readLine();
    if (str == null || str.equals(""String_Node_Str""))     break;
    if (str.toUpperCase().startsWith(""String_Node_Str"")) {
      int startOffset=parseContentRangeStart(str);
      if (startOffset != _initialReadingPoint)       throw new IOException(""String_Node_Str"");
    }
  }
}",0.999449642267474
4962,"/** 
 * Canonicalizes a file name - gets rid of articles, etc...
 * @param map Adds the canonicalized elements to this map.
 */
private final void canonicalize(String fileName,Map map){
  StringTokenizer st=new StringTokenizer(fileName,FileManager.DELIMETERS);
  while (st.hasMoreTokens()) {
    final String currToken=st.nextToken().toLowerCase();
    if (wordSet.contains(currToken))     continue;
    try {
      Double.parseDouble(currToken);
      continue;
    }
 catch (    NumberFormatException ignored) {
    }
{
      Integer occurrences=(Integer)map.get(currToken);
      if (occurrences == null)       occurrences=new Integer(1);
 else       occurrences=new Integer(occurrences.intValue() + 1);
      map.put(currToken,occurrences);
    }
  }
}","/** 
 * Canonicalizes a file name - gets rid of articles, etc...
 * @param map Adds the canonicalized elements to this map.
 */
private final void canonicalize(String fileName,Map map){
  StringTokenizer st=new StringTokenizer(fileName,FileManager.DELIMETERS);
  while (st.hasMoreTokens()) {
    final String currToken=st.nextToken().toLowerCase();
    if (wordSet.contains(currToken))     continue;
    try {
      Double d=new Double(currToken);
      continue;
    }
 catch (    NumberFormatException ignored) {
    }
{
      Integer occurrences=(Integer)map.get(currToken);
      if (occurrences == null)       occurrences=new Integer(1);
 else       occurrences=new Integer(occurrences.intValue() + 1);
      map.put(currToken,occurrences);
    }
  }
}",0.991407799074686
4963,"private void handlePatch(PatchTableMessage m) throws BadPacketException {
  if (sequenceSize != -1 && sequenceSize != m.getSequenceSize())   throw new BadPacketException(""String_Node_Str"" + m.getSequenceSize() + ""String_Node_Str""+ sequenceSize);
  if (sequenceNumber != -1 && sequenceNumber + 1 != m.getSequenceNumber())   throw new BadPacketException(""String_Node_Str"" + m.getSequenceNumber() + ""String_Node_Str""+ sequenceNumber);
  byte[] data=m.getData();
  if (m.getCompressor() == PatchTableMessage.COMPRESSOR_DEFLATE) {
    try {
      if (m.getSequenceNumber() == 1)       uncompressor=new Inflater();
      Assert.that(uncompressor != null,""String_Node_Str"");
      data=uncompress(data);
    }
 catch (    IOException e) {
      throw new BadPacketException(""String_Node_Str"" + e);
    }
  }
 else   if (m.getCompressor() != PatchTableMessage.COMPRESSOR_NONE) {
    throw new BadPacketException(""String_Node_Str"");
  }
  if (m.getEntryBits() == 4)   data=unhalve(data);
 else   if (m.getEntryBits() != 8)   throw new BadPacketException(""String_Node_Str"");
  for (int i=0; i < data.length; i++) {
    try {
      boolean wasInfinity=(table[nextPatch] >= infinity);
      table[nextPatch]+=data[i];
      boolean isInfinity=(table[nextPatch] >= infinity);
      if (wasInfinity && !isInfinity)       entries++;
 else       if (!wasInfinity && isInfinity)       entries--;
    }
 catch (    IndexOutOfBoundsException e) {
      throw new BadPacketException(""String_Node_Str"" + nextPatch + ""String_Node_Str""+ data.length+ ""String_Node_Str"");
    }
    nextPatch++;
  }
  if (m.getSequenceNumber() != m.getSequenceSize()) {
    this.sequenceNumber=m.getSequenceNumber();
  }
 else {
    this.sequenceNumber=-1;
    this.sequenceSize=-1;
    this.nextPatch=0;
  }
}","private void handlePatch(PatchTableMessage m) throws BadPacketException {
  if (sequenceSize != -1 && sequenceSize != m.getSequenceSize())   throw new BadPacketException(""String_Node_Str"" + m.getSequenceSize() + ""String_Node_Str""+ sequenceSize);
  if (sequenceNumber == -1 ? m.getSequenceNumber() != 1 : sequenceNumber + 1 != m.getSequenceNumber())   throw new BadPacketException(""String_Node_Str"" + m.getSequenceNumber() + ""String_Node_Str""+ sequenceNumber);
  byte[] data=m.getData();
  if (m.getCompressor() == PatchTableMessage.COMPRESSOR_DEFLATE) {
    try {
      if (m.getSequenceNumber() == 1)       uncompressor=new Inflater();
      Assert.that(uncompressor != null,""String_Node_Str"" + m.getSequenceNumber());
      data=uncompress(data);
    }
 catch (    IOException e) {
      throw new BadPacketException(""String_Node_Str"" + e);
    }
  }
 else   if (m.getCompressor() != PatchTableMessage.COMPRESSOR_NONE) {
    throw new BadPacketException(""String_Node_Str"");
  }
  if (m.getEntryBits() == 4)   data=unhalve(data);
 else   if (m.getEntryBits() != 8)   throw new BadPacketException(""String_Node_Str"");
  for (int i=0; i < data.length; i++) {
    try {
      boolean wasInfinity=(table[nextPatch] >= infinity);
      table[nextPatch]+=data[i];
      boolean isInfinity=(table[nextPatch] >= infinity);
      if (wasInfinity && !isInfinity)       entries++;
 else       if (!wasInfinity && isInfinity)       entries--;
    }
 catch (    IndexOutOfBoundsException e) {
      throw new BadPacketException(""String_Node_Str"" + nextPatch + ""String_Node_Str""+ data.length+ ""String_Node_Str"");
    }
    nextPatch++;
  }
  this.sequenceSize=m.getSequenceSize();
  if (m.getSequenceNumber() != m.getSequenceSize()) {
    this.sequenceNumber=m.getSequenceNumber();
  }
 else {
    this.sequenceNumber=-1;
    this.sequenceSize=-1;
    this.nextPatch=0;
  }
}",0.9727197575089556
4964,"/** 
 * Accepts a new upload, creating a new <tt>HTTPUploader</tt> if it successfully parses the HTTP 'get' header.
 * @param socket the <tt>Socket</tt> that will be used for the new upload
 */
public void acceptUpload(Socket socket){
  HTTPUploader uploader;
  GETLine line;
  try {
synchronized (this) {
      _activeUploads++;
    }
    while (true) {
      try {
        line=parseGET(socket);
      }
 catch (      IOException e) {
        return;
      }
      uploader=new HTTPUploader(line._file,socket,line._index,this,_fileManager);
      doSingleUpload(uploader,socket.getInetAddress().getHostAddress(),line._index);
      if (!line.isHTTP11() || uploader.getCloseConnection())       return;
      try {
        int oldTimeout=socket.getSoTimeout();
        socket.setSoTimeout(SettingsManager.instance().getPersistentHTTPConnectionTimeout());
        String word=IOUtils.readWord(socket.getInputStream(),3);
        socket.setSoTimeout(oldTimeout);
        if (!word.equalsIgnoreCase(""String_Node_Str""))         return;
      }
 catch (      IOException ioe) {
        return;
      }
    }
  }
  finally {
synchronized (this) {
      _activeUploads--;
    }
    close(socket);
  }
}","/** 
 * Accepts a new upload, creating a new <tt>HTTPUploader</tt> if it successfully parses the HTTP 'get' header.  BLOCKING.
 * @param socket the <tt>Socket</tt> that will be used for the new upload
 */
public void acceptUpload(Socket socket){
  HTTPUploader uploader;
  GETLine line;
  try {
synchronized (this) {
      _activeUploads++;
    }
    while (true) {
      try {
        line=parseGET(socket);
      }
 catch (      IOException e) {
        return;
      }
      uploader=new HTTPUploader(line._file,socket,line._index,this,_fileManager);
      doSingleUpload(uploader,socket.getInetAddress().getHostAddress(),line._index);
      if (!line.isHTTP11() || uploader.getCloseConnection())       return;
      try {
        int oldTimeout=socket.getSoTimeout();
        socket.setSoTimeout(SettingsManager.instance().getPersistentHTTPConnectionTimeout());
        String word=IOUtils.readWord(socket.getInputStream(),3);
        socket.setSoTimeout(oldTimeout);
        if (!word.equalsIgnoreCase(""String_Node_Str""))         return;
      }
 catch (      IOException ioe) {
        return;
      }
    }
  }
  finally {
synchronized (this) {
      _activeUploads--;
    }
    close(socket);
  }
}",0.9954185755935028
4965,"/** 
 * Accepts a new push upload, creating a new <tt>HTTPUploader</tt>.
 * @param file the fully qualified pathname of the file to upload
 * @param host the ip address of the host to upload to
 * @param port the port over which the transfer will occur
 * @param index the index of the file in <tt>FileManager</tt>
 * @param guid the unique identifying client guid of the uploading client
 */
public synchronized void acceptPushUpload(String file,String host,int port,int index,String guid){
synchronized (this) {
    _activeUploads++;
  }
  clearFailedPushes();
  Uploader uploader=null;
  try {
    uploader=new HTTPUploader(file,host,port,index,guid,this,_fileManager);
    if ((!testAttemptedPush(host,index)) || (!testFailedPush(host,index)))     return;
    insertAttemptedPush(host,index);
    doSingleUpload(uploader,host,index);
  }
  finally {
synchronized (this) {
      _activeUploads--;
    }
    if (uploader != null)     uploader.stop();
  }
}","/** 
 * Accepts a new push upload, creating a new <tt>HTTPUploader</tt>. NON-BLOCKING: creates a new thread to transfer the file.
 * @param file the fully qualified pathname of the file to upload
 * @param host the ip address of the host to upload to
 * @param port the port over which the transfer will occur
 * @param index the index of the file in <tt>FileManager</tt>
 * @param guid the unique identifying client guid of the uploading client
 */
public synchronized void acceptPushUpload(final String file,final String host,final int port,final int index,final String guid){
  final Uploader uploader=new HTTPUploader(file,host,port,index,guid,this,_fileManager);
  clearFailedPushes();
  if ((!testAttemptingPush(host,index)) || (!testFailedPush(host,index)))   return;
  insertAttemptingPush(host,index);
  Thread runner=new Thread(){
    public void run(){
      try {
synchronized (UploadManager.this) {
          _activeUploads++;
        }
        doSingleUpload(uploader,host,index);
      }
  finally {
synchronized (UploadManager.this) {
          _activeUploads--;
        }
        uploader.stop();
      }
    }
  }
;
  runner.start();
}",0.7740407389862625
4966,"private void doSingleUpload(Uploader uploader,String host,int index){
  long startTime=-1;
  try {
    insertAndTest(uploader,host);
    uploader.connect();
    startTime=System.currentTimeMillis();
    uploader.start();
    if (uploader.getState() == Uploader.COMPLETE)     _hadSuccesfulUpload=true;
  }
 catch (  IOException e) {
synchronized (UploadManager.this) {
      insertFailedPush(host,index);
    }
  }
 finally {
    long finishTime=System.currentTimeMillis();
synchronized (UploadManager.this) {
      if (startTime > 0)       reportUploadSpeed(finishTime - startTime,uploader.amountUploaded());
      removeFromMapAndList(uploader,host);
      removeAttemptedPush(host,index);
      _callback.removeUpload(uploader);
    }
  }
}","private void doSingleUpload(Uploader uploader,String host,int index){
  long startTime=-1;
  try {
    insertAndTest(uploader,host);
    uploader.connect();
    startTime=System.currentTimeMillis();
    uploader.start();
    if (uploader.getState() == Uploader.COMPLETE)     _hadSuccesfulUpload=true;
  }
 catch (  IOException e) {
synchronized (UploadManager.this) {
      insertFailedPush(host,index);
    }
  }
 finally {
    long finishTime=System.currentTimeMillis();
synchronized (UploadManager.this) {
      if (startTime > 0)       reportUploadSpeed(finishTime - startTime,uploader.amountUploaded());
      removeFromMapAndList(uploader,host);
      removeAttemptingPush(host,index);
      _callback.removeUpload(uploader);
    }
  }
}",0.9966329966329966
4967,"/** 
 * Adds the given location to this.  This will terminate after downloading rfd or any of the other locations in this.  This may swarm some file from rfd and other locations.
 * @param rfd a new download candidate.  Typically rfd will be similar orsame to some entry in this, but that is not required.  
 */
public synchronized void addDownload(RemoteFileDesc rfd){
  for (int i=0; i < allFiles.length; i++) {
    if (rfd.equals(allFiles[i]))     return;
  }
  buckets.add(rfd);
  RemoteFileDesc[] newAllFiles=new RemoteFileDesc[allFiles.length + 1];
  System.arraycopy(allFiles,0,newAllFiles,0,allFiles.length);
  newAllFiles[newAllFiles.length - 1]=rfd;
  allFiles=newAllFiles;
  if ((state == Downloader.WAITING_FOR_RETRY) || (state == Downloader.WAITING_FOR_RESULTS))   reqLock.release();
 else   this.notify();
}","/** 
 * Adds the given location to this.  This will terminate after downloading rfd or any of the other locations in this.  This may swarm some file from rfd and other locations.
 * @param rfd a new download candidate.  Typically rfd will be similar orsame to some entry in this, but that is not required.  
 */
public synchronized void addDownload(RemoteFileDesc rfd){
  for (int i=0; i < allFiles.length; i++) {
    if (rfd.equals(allFiles[i]))     return;
  }
  if (buckets != null)   buckets.add(rfd);
  RemoteFileDesc[] newAllFiles=new RemoteFileDesc[allFiles.length + 1];
  System.arraycopy(allFiles,0,newAllFiles,0,allFiles.length);
  newAllFiles[newAllFiles.length - 1]=rfd;
  allFiles=newAllFiles;
  if ((state == Downloader.WAITING_FOR_RETRY) || (state == Downloader.WAITING_FOR_RESULTS))   reqLock.release();
 else   this.notify();
}",0.986186186186186
4968,"/** 
 * Increments the count of uploads in progress for host. If uploader has exceeded its limits, places it in LIMIT_REACHED state. Notifies callback of this.
 * @requires this' monitor is held
 * @modifies _uploadsInProgress, uploader, _callback 
 */
private void insertAndTest(Uploader uploader,String host){
  insertIntoMapAndList(uploader,host);
  if ((!testPerHostLimit(host)) || (!testTotalUploadLimit()))   uploader.setState(Uploader.LIMIT_REACHED);
  _callback.addUpload(uploader);
}","/** 
 * Increments the count of uploads in progress for host. If uploader has exceeded its limits, places it in LIMIT_REACHED state. Notifies callback of this.
 * @modifies _uploadsInProgress, uploader, _callback 
 */
private synchronized void insertAndTest(Uploader uploader,String host){
  insertIntoMapAndList(uploader,host);
  if ((!testPerHostLimit(host)) || (!testTotalUploadLimit()))   uploader.setState(Uploader.LIMIT_REACHED);
  _callback.addUpload(uploader);
}",0.95010395010395
4969,"/** 
 * Downloads file (stored in slot index) from address:port, returning the content as a string. If header!=null, includes it as a request header. Do not include new line or carriage return in header.  Throws IOException if there is a problem, without cleaning up. 
 */
private static String download(String file,String header) throws IOException {
  Socket s=new Socket(address,port);
  BufferedReader in=new BufferedReader(new InputStreamReader(s.getInputStream()));
  BufferedWriter out=new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  String ret=downloadInternal(file,header,out,in);
  in.close();
  out.close();
  s.close();
  return ret;
}","private static boolean download(String file,String header,String expResp) throws IOException {
  Socket s=new Socket(address,port);
  BufferedReader in=new BufferedReader(new InputStreamReader(s.getInputStream()));
  BufferedWriter out=new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  String ret=downloadInternal(file,header,out,in);
  in.close();
  out.close();
  s.close();
  return ret.equals(expResp);
}",0.615948670944088
4970,"private static void test(String testName,boolean passed,String output){
  System.out.println((passed ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + testName);
  if (!passed)   System.out.println(""String_Node_Str"" + output + ""String_Node_Str"");
}","private static void test(String testName,boolean passed){
  System.out.println((passed ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + testName);
  if (!passed)   System.out.println(""String_Node_Str"");
}",0.9102296450939458
4971,"public static void main(String args[]){
  try {
    address=args[0];
    port=Integer.parseInt(args[1]);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str""+ address+ ""String_Node_Str""+ file+ ""String_Node_Str""+ index+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ callbackPort+ ""String_Node_Str"");
  try {
    String output;
    output=downloadPush(file,null);
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
    output=downloadPush(encodedFile,null);
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
    output=downloadPush(file,""String_Node_Str"");
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
    output=download(file,null);
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
    output=download(file,""String_Node_Str"");
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
    output=download(file,""String_Node_Str"");
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
    output=download(file,""String_Node_Str"");
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
    output=download(file,""String_Node_Str"");
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
    output=download(file,""String_Node_Str"");
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
    output=download(file,""String_Node_Str"");
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
    Assert.that(URLDecoder.decode(encodedFile).equals(file),""String_Node_Str"" + URLDecoder.decode(encodedFile));
    output=download(encodedFile,null);
    test(""String_Node_Str"",output.equals(""String_Node_Str""),output);
  }
 catch (  IOException e) {
    e.printStackTrace();
    Assert.that(false,""String_Node_Str"");
  }
catch (  BadPacketException e) {
    e.printStackTrace();
    Assert.that(false,""String_Node_Str"");
  }
}","public static void main(String args[]){
  try {
    address=args[0];
    port=Integer.parseInt(args[1]);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str""+ address+ ""String_Node_Str""+ file+ ""String_Node_Str""+ index+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ callbackPort+ ""String_Node_Str"");
  try {
    boolean passed;
    passed=downloadPush(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=downloadPush(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    Assert.that(URLDecoder.decode(encodedFile).equals(file),""String_Node_Str"" + URLDecoder.decode(encodedFile));
    passed=download(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"" + ""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    passed=download1(file,""String_Node_Str"",""String_Node_Str"");
    test(""String_Node_Str"",passed);
    Assert.that(URLDecoder.decode(encodedFile).equals(file),""String_Node_Str"" + URLDecoder.decode(encodedFile));
    passed=download1(encodedFile,null,""String_Node_Str"");
    test(""String_Node_Str"",passed);
  }
 catch (  IOException e) {
    e.printStackTrace();
    Assert.that(false,""String_Node_Str"");
  }
catch (  BadPacketException e) {
    e.printStackTrace();
    Assert.that(false,""String_Node_Str"");
  }
}",0.4463682432432432
4972,"private static String downloadPush(String file,String header) throws IOException, BadPacketException {
  Connection c=new Connection(address,port);
  c.initialize();
  QueryRequest query=new QueryRequest((byte)5,0,""String_Node_Str"");
  c.send(query);
  c.flush();
  QueryReply reply=null;
  while (true) {
    Message m=c.receive(2000);
    if (m instanceof QueryReply) {
      reply=(QueryReply)m;
      break;
    }
  }
  PushRequest push=new PushRequest(GUID.makeGuid(),(byte)5,reply.getClientGUID(),0,new byte[]{(byte)127,(byte)0,(byte)0,(byte)1},callbackPort);
  ServerSocket ss=new ServerSocket(callbackPort);
  c.send(push);
  c.flush();
  Socket s=ss.accept();
  BufferedReader in=new BufferedReader(new InputStreamReader(s.getInputStream()));
  BufferedWriter out=new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  in.readLine();
  in.readLine();
  String ret=downloadInternal(file,header,out,in);
  c.close();
  s.close();
  ss.close();
  return ret;
}","private static boolean downloadPush(String file,String header,String expResp) throws IOException, BadPacketException {
  Connection c=new Connection(address,port);
  c.initialize();
  QueryRequest query=new QueryRequest((byte)5,0,""String_Node_Str"");
  c.send(query);
  c.flush();
  QueryReply reply=null;
  while (true) {
    Message m=c.receive(2000);
    if (m instanceof QueryReply) {
      reply=(QueryReply)m;
      break;
    }
  }
  PushRequest push=new PushRequest(GUID.makeGuid(),(byte)5,reply.getClientGUID(),0,new byte[]{(byte)127,(byte)0,(byte)0,(byte)1},callbackPort);
  ServerSocket ss=new ServerSocket(callbackPort);
  c.send(push);
  c.flush();
  Socket s=ss.accept();
  BufferedReader in=new BufferedReader(new InputStreamReader(s.getInputStream()));
  BufferedWriter out=new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
  in.readLine();
  in.readLine();
  String retStr=downloadInternal(file,header,out,in);
  c.close();
  s.close();
  ss.close();
  return retStr.equals(expResp);
}",0.950852557673019
4973,"/** 
 * Increments the count of uploads in progress for host. If uploader has exceeded its limits, places it in LIMIT_REACHED state and returns false.  Otherwise returns true. Notifies callback of this.
 * @modifies _uploadsInProgress, uploader, _callback 
 */
private synchronized boolean insertAndTest(HTTPUploader uploader,String host){
  insertIntoMapAndList(uploader,host);
  if ((!testPerHostLimit(host)) || (!testTotalUploadLimit())) {
    uploader.setState(Uploader.LIMIT_REACHED);
    return false;
  }
  _callback.addUpload(uploader);
  return true;
}","/** 
 * Increments the count of uploads in progress for host. If uploader has exceeded its limits, places it in LIMIT_REACHED state and returns false.  Otherwise returns true. Notifies callback of this.
 * @modifies _uploadsInProgress, uploader, _callback 
 */
private synchronized boolean insertAndTest(HTTPUploader uploader,String host){
  insertIntoMapAndList(uploader,host);
  if ((!testPerHostLimit(host)) || (!testTotalUploadLimit())) {
    uploader.setState(Uploader.LIMIT_REACHED);
    return false;
  }
  return true;
}",0.9494949494949496
4974,"/** 
 * Does some book-keeping and makes the downloader, start the download
 * @param uploader This method assumes that uploader is connected.
 */
private void doSingleUpload(HTTPUploader uploader,String host,int index){
  long startTime=-1;
  boolean accepted=insertAndTest(uploader,host);
synchronized (this) {
    if (accepted)     _activeUploads++;
  }
  startTime=System.currentTimeMillis();
  uploader.start();
  if (uploader.getState() == Uploader.COMPLETE)   _hadSuccesfulUpload=true;
  long finishTime=System.currentTimeMillis();
synchronized (UploadManager.this) {
    if (startTime > 0)     reportUploadSpeed(finishTime - startTime,uploader.amountUploaded());
    removeFromMapAndList(uploader,host);
    removeAttemptingPush(host,index);
    if (accepted)     _activeUploads--;
    _callback.removeUpload(uploader);
  }
}","/** 
 * Does some book-keeping and makes the downloader, start the download
 * @param uploader This method assumes that uploader is connected.
 */
private void doSingleUpload(HTTPUploader uploader,String host,int index){
  long startTime=-1;
  boolean accepted=insertAndTest(uploader,host);
  _callback.addUpload(uploader);
synchronized (this) {
    if (accepted)     _activeUploads++;
  }
  startTime=System.currentTimeMillis();
  uploader.start();
  if (uploader.getState() == Uploader.COMPLETE)   _hadSuccesfulUpload=true;
  long finishTime=System.currentTimeMillis();
synchronized (UploadManager.this) {
    if (startTime > 0)     reportUploadSpeed(finishTime - startTime,uploader.amountUploaded());
    removeFromMapAndList(uploader,host);
    removeAttemptingPush(host,index);
    if (accepted)     _activeUploads--;
    _callback.removeUpload(uploader);
  }
}",0.9805768098881696
4975,"/** 
 * @return the bytes for a new GUID flagged to be a requery made by LW. 
 */
public static byte[] makeGuidRequery(){
  byte[] ret=makeGuid();
  tagGuid(ret,0,9,13);
  return ret;
}","/** 
 * @return the bytes for a new GUID flagged to be a requery made by LW. 
 */
public static byte[] makeGuidRequery(){
  byte[] ret=makeGuid();
  tagGuid(ret,0,2,13);
  return ret;
}",0.9945945945945946
4976,"/** 
 * Returns true if this is a specially marked LimeWire Requery GUID. This does NOT mean that it's a new GUID as well; the caller will probably want to check that. 
 */
public static boolean isLimeRequeryGUID(byte[] bytes){
  return checkMatching(bytes,0,9,13);
}","/** 
 * Returns true if this is a specially marked LimeWire Requery GUID. This does NOT mean that it's a new GUID as well; the caller will probably want to check that. 
 * @param isOld true if the caller is interested in LW 2.2.0-2.2.3requery GUIDs, false if the caller is interested 2.2.4+ GUIDs.
 */
public static boolean isLimeRequeryGUID(byte[] bytes,boolean isOld){
  if (isOld)   return checkMatching(bytes,0,9,13);
 else   return checkMatching(bytes,0,2,13);
}",0.7275204359673024
4977,"/** 
 * Actually does the download, finding duplicate files, trying all locations, resuming, waiting, and retrying as necessary.  Also takes care of moving file from incomplete directory to save directory and adding file to the library.  Called from dloadManagerThread.  
 */
private void tryAllDownloads(){
  int numRequeries=0;
  long nextRequeryTime=0;
synchronized (this) {
    buckets=new RemoteFileDescGrouper(allFiles,incompleteFileManager);
  }
  while (true) {
    try {
      setState(QUEUED);
      manager.waitForSlot(this);
      boolean waitForRetry=false;
      try {
        for (Iterator iter=buckets.buckets(); iter.hasNext(); ) {
          List bucket=(List)iter.next();
          if (bucket.size() <= 0)           continue;
synchronized (this) {
            RemoteFileDesc rfd=(RemoteFileDesc)bucket.get(0);
            currentFileName=rfd.getFileName();
            currentFileSize=rfd.getSize();
          }
          int status=tryAllDownloads2(bucket);
          if (status == COMPLETE) {
            setState(COMPLETE);
            manager.remove(this,true);
            return;
          }
 else           if (status == COULDNT_MOVE_TO_LIBRARY) {
            setState(COULDNT_MOVE_TO_LIBRARY);
            manager.remove(this,false);
            return;
          }
 else           if (status == WAITING_FOR_RETRY) {
            waitForRetry=true;
          }
 else {
            Assert.that(status == GAVE_UP,""String_Node_Str"" + status);
          }
        }
      }
 catch (      InterruptedException e) {
        if (!stopped)         ManagedDownloader.this.manager.internalError(e);
      }
      manager.yieldSlot(this);
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
      final long currTime=System.currentTimeMillis();
      if ((currTime >= nextRequeryTime) && (numRequeries++ < REQUERY_ATTEMPTS)) {
        manager.sendQuery(allFiles);
        nextRequeryTime=currTime + (getMinutesToWaitForRequery(numRequeries) * 60 * 1000);
      }
      if (waitForRetry) {
synchronized (this) {
          retriesWaiting=0;
          for (Iterator iter=buckets.buckets(); iter.hasNext(); ) {
            List bucket=(List)iter.next();
            retriesWaiting+=bucket.size();
          }
        }
        long time=calculateWaitTime();
        setState(WAITING_FOR_RETRY,time);
        reqLock.lock(time);
      }
 else {
        if (numRequeries <= REQUERY_ATTEMPTS) {
          final long waitTime=nextRequeryTime - System.currentTimeMillis();
          if (waitTime > 0) {
            setState(WAITING_FOR_RESULTS,waitTime);
            reqLock.lock(waitTime);
          }
        }
 else {
          setState(GAVE_UP);
          manager.remove(this,false);
          return;
        }
      }
    }
 catch (    InterruptedException e) {
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
    }
  }
}","/** 
 * Actually does the download, finding duplicate files, trying all locations, resuming, waiting, and retrying as necessary.  Also takes care of moving file from incomplete directory to save directory and adding file to the library.  Called from dloadManagerThread.  
 */
private void tryAllDownloads(){
  int numRequeries=0;
  long nextRequeryTime=System.currentTimeMillis() + getMinutesToWaitForRequery(numRequeries) * 60 * 1000;
synchronized (this) {
    buckets=new RemoteFileDescGrouper(allFiles,incompleteFileManager);
  }
  while (true) {
    try {
      setState(QUEUED);
      manager.waitForSlot(this);
      boolean waitForRetry=false;
      try {
        for (Iterator iter=buckets.buckets(); iter.hasNext(); ) {
          List bucket=(List)iter.next();
          if (bucket.size() <= 0)           continue;
synchronized (this) {
            RemoteFileDesc rfd=(RemoteFileDesc)bucket.get(0);
            currentFileName=rfd.getFileName();
            currentFileSize=rfd.getSize();
          }
          int status=tryAllDownloads2(bucket);
          if (status == COMPLETE) {
            setState(COMPLETE);
            manager.remove(this,true);
            return;
          }
 else           if (status == COULDNT_MOVE_TO_LIBRARY) {
            setState(COULDNT_MOVE_TO_LIBRARY);
            manager.remove(this,false);
            return;
          }
 else           if (status == WAITING_FOR_RETRY) {
            waitForRetry=true;
          }
 else {
            Assert.that(status == GAVE_UP,""String_Node_Str"" + status);
          }
        }
      }
 catch (      InterruptedException e) {
        if (!stopped)         ManagedDownloader.this.manager.internalError(e);
      }
      manager.yieldSlot(this);
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
      final long currTime=System.currentTimeMillis();
      if ((currTime >= nextRequeryTime) && (numRequeries < REQUERY_ATTEMPTS)) {
        manager.sendQuery(allFiles);
        numRequeries++;
        nextRequeryTime=currTime + (getMinutesToWaitForRequery(numRequeries) * 60 * 1000);
      }
      if (waitForRetry) {
synchronized (this) {
          retriesWaiting=0;
          for (Iterator iter=buckets.buckets(); iter.hasNext(); ) {
            List bucket=(List)iter.next();
            retriesWaiting+=bucket.size();
          }
        }
        long time=calculateWaitTime();
        setState(WAITING_FOR_RETRY,time);
        reqLock.lock(time);
      }
 else {
        if (numRequeries <= REQUERY_ATTEMPTS) {
          final long waitTime=nextRequeryTime - System.currentTimeMillis();
          if (waitTime > 0) {
            setState(WAITING_FOR_RESULTS,waitTime);
            reqLock.lock(waitTime);
          }
        }
 else {
          setState(GAVE_UP);
          manager.remove(this,false);
          return;
        }
      }
    }
 catch (    InterruptedException e) {
      if (stopped) {
        setState(ABORTED);
        manager.remove(this,false);
        return;
      }
    }
  }
}",0.9823274424808268
4978,"/** 
 * @return the number of minutes to wait for your next requery....
 */
private int getMinutesToWaitForRequery(int numCalls){
switch (numCalls) {
case 1:
    return 2;
case 2:
  return 15;
case 3:
return 60;
case 4:
return 120;
default :
return 180;
}
}","/** 
 * Returns the time to wait between the n'th and n+1'th automatic requery, where n=requeries.  Hence getMinutesToWaitForRequery(0) is the time to wait before the first requery.  getMinutesToWaitForRequery(1) is the time to wait after that before requerying again.
 * @param requeriesthe number of requeries sent, which must be non-negative
 * @return minutes to wait
 */
private int getMinutesToWaitForRequery(int requeries){
switch (requeries) {
case 0:
    return 2;
case 1:
  return 15;
case 2:
return 60;
case 3:
return 120;
default :
return 180;
}
}",0.4705882352941176
4979,"/** 
 * Accepts a new push upload, creating a new <tt>HTTPUploader</tt>.
 * @param file the fully qualified pathname of the file to upload
 * @param host the ip address of the host to upload to
 * @param port the port over which the transfer will occur
 * @param index the index of the file in <tt>FileManager</tt>
 * @param guid the unique identifying client guid of the uploading client
 */
public synchronized void acceptPushUpload(String file,String host,int port,int index,String guid){
  clearFailedPushes();
  Uploader uploader=null;
  try {
    uploader=new HTTPUploader(file,host,port,index,guid,this,_fileManager);
    if ((!testAttemptedPush(host,index)) || (!testFailedPush(host,index)))     return;
    insertAndTest(uploader,host);
    insertAttemptedPush(host,index);
    doSingleUpload(uploader,host,index);
  }
  finally {
    if (uploader != null)     uploader.stop();
  }
}","/** 
 * Accepts a new push upload, creating a new <tt>HTTPUploader</tt>.
 * @param file the fully qualified pathname of the file to upload
 * @param host the ip address of the host to upload to
 * @param port the port over which the transfer will occur
 * @param index the index of the file in <tt>FileManager</tt>
 * @param guid the unique identifying client guid of the uploading client
 */
public synchronized void acceptPushUpload(String file,String host,int port,int index,String guid){
synchronized (this) {
    _activeUploads++;
  }
  clearFailedPushes();
  Uploader uploader=null;
  try {
    uploader=new HTTPUploader(file,host,port,index,guid,this,_fileManager);
    if ((!testAttemptedPush(host,index)) || (!testFailedPush(host,index)))     return;
    insertAttemptedPush(host,index);
    doSingleUpload(uploader,host,index);
  }
  finally {
synchronized (this) {
      _activeUploads--;
    }
    if (uploader != null)     uploader.stop();
  }
}",0.8756756756756757
4980,"private boolean doSingleUpload(Uploader uploader,String host,int index){
  long startTime=-1;
  try {
    insertAndTest(uploader,host);
    uploader.connect();
    startTime=System.currentTimeMillis();
    uploader.start();
    if (uploader.getState() == Uploader.COMPLETE)     _hadSuccesfulUpload=true;
  }
 catch (  IOException e) {
synchronized (UploadManager.this) {
      insertFailedPush(host,index);
    }
  }
 finally {
    long finishTime=System.currentTimeMillis();
synchronized (UploadManager.this) {
      if (startTime > 0)       reportUploadSpeed(finishTime - startTime,uploader.amountUploaded());
      removeFromMapAndList(uploader,host);
      removeAttemptedPush(host,index);
      _callback.removeUpload(uploader);
    }
  }
  return false;
}","private void doSingleUpload(Uploader uploader,String host,int index){
  long startTime=-1;
  try {
    insertAndTest(uploader,host);
    uploader.connect();
    startTime=System.currentTimeMillis();
    uploader.start();
    if (uploader.getState() == Uploader.COMPLETE)     _hadSuccesfulUpload=true;
  }
 catch (  IOException e) {
synchronized (UploadManager.this) {
      insertFailedPush(host,index);
    }
  }
 finally {
    long finishTime=System.currentTimeMillis();
synchronized (UploadManager.this) {
      if (startTime > 0)       reportUploadSpeed(finishTime - startTime,uploader.amountUploaded());
      removeFromMapAndList(uploader,host);
      removeAttemptedPush(host,index);
      _callback.removeUpload(uploader);
    }
  }
}",0.9820359281437124
4981,"/** 
 * Gets a list of keywords from all the documents in this collection. <p> delegates to the individual documents and collates the list
 */
protected List getKeyWords(){
  List retList=new ArrayList();
  Iterator docs;
synchronized (mainMapLock) {
    docs=mainMap.values().iterator();
  }
  while (docs.hasNext()) {
    LimeXMLDocument d=(LimeXMLDocument)docs.next();
    retList.addAll(d.getKeyWords());
  }
  return retList;
}","/** 
 * Gets a list of keywords from all the documents in this collection. <p> delegates to the individual documents and collates the list
 */
protected List getKeyWords(){
  List retList=new ArrayList();
  Iterator docs;
synchronized (mainMapLock) {
    docs=mainMap.values().iterator();
    while (docs.hasNext()) {
      LimeXMLDocument d=(LimeXMLDocument)docs.next();
      retList.addAll(d.getKeyWords());
    }
  }
  return retList;
}",0.9495412844036696
4982,"/** 
 * This class implements a succesful upload version of the doUpload method.  It prepares a file, writes the appropriate header, then sends the file.
 */
public void doUpload(HTTPUploader uploader) throws IOException {
  try {
    _uploader=uploader;
    _uploader.setState(_uploader.UPLOADING);
    _ostream=_uploader.getOutputStream();
    _index=_uploader.getIndex();
    _filename=_uploader.getFileName();
    _fileSize=_uploader.getFileSize();
    _fis=_uploader.getInputStream();
    _amountRead=_uploader.amountUploaded();
    _uploadBegin=_uploader.getUploadBegin();
    _uploadEnd=_uploader.getUploadEnd();
    if (_fileSize < _uploadBegin)     return;
    if (_uploadEnd <= 0 || _uploadEnd <= _uploadBegin || _uploadEnd > _fileSize)     _uploadEnd=_fileSize;
    writeHeader();
    int c=-1;
    int available=0;
    byte[] buf=new byte[1024];
    long a=_fis.skip(_uploadBegin);
    _amountRead+=a;
    _uploader.setAmountUploaded(_amountRead);
    SettingsManager manager=SettingsManager.instance();
    int speed=manager.getUploadSpeed();
    if (speed == 100) {
      while (true) {
        c=_fis.read(buf);
        if (c == -1)         break;
        if (c > (_uploadEnd - _amountRead))         c=_uploadEnd - _amountRead;
        try {
          _ostream.write(buf,0,c);
        }
 catch (        java.net.SocketException e) {
          throw new IOException();
        }
        _amountRead+=c;
        _uploader.setAmountUploaded(_amountRead);
        if (_amountRead >= _uploadEnd)         break;
      }
    }
 else {
      while (true) {
        int max=_uploader.getManager().calculateBandwidth();
        int burstSize=max * CYCLE_TIME;
        int burstSent=0;
        long start=System.currentTimeMillis();
        while (burstSent < burstSize) {
          c=_fis.read(buf);
          if (c == -1)           return;
          if (c > (_uploadEnd - _amountRead))           c=_uploadEnd - _amountRead;
          try {
            _ostream.write(buf,0,c);
          }
 catch (          java.net.SocketException e) {
            throw new IOException();
          }
          _amountRead+=c;
          _uploader.setAmountUploaded(_amountRead);
          burstSent+=c;
          if (_amountRead >= _uploadEnd)           break;
        }
        long stop=System.currentTimeMillis();
        int elapsed=(int)(stop - start);
        int sleepTime=CYCLE_TIME - elapsed;
        if (sleepTime > 0) {
          try {
            Thread.currentThread().sleep(sleepTime);
          }
 catch (          InterruptedException e) {
            throw new IOException();
          }
        }
      }
    }
  }
 catch (  IOException ioe) {
    _closeConnection=true;
    throw ioe;
  }
  _uploader.setState(_uploader.COMPLETE);
}","/** 
 * This class implements a succesful upload version of the doUpload method.  It prepares a file, writes the appropriate header, then sends the file.
 */
public void doUpload(HTTPUploader uploader) throws IOException {
  try {
    _uploader=uploader;
    _uploader.setState(_uploader.UPLOADING);
    _ostream=_uploader.getOutputStream();
    _index=_uploader.getIndex();
    _filename=_uploader.getFileName();
    _fileSize=_uploader.getFileSize();
    _fis=_uploader.getInputStream();
    _amountRead=_uploader.amountUploaded();
    _uploadBegin=_uploader.getUploadBegin();
    _uploadEnd=_uploader.getUploadEnd();
    if (_fileSize < _uploadBegin)     throw new IOException(""String_Node_Str"");
    if (_uploadEnd <= 0 || _uploadEnd <= _uploadBegin || _uploadEnd > _fileSize)     _uploadEnd=_fileSize;
    writeHeader();
    int c=-1;
    byte[] buf=new byte[1024];
    long a=_fis.skip(_uploadBegin);
    _amountRead+=a;
    _uploader.setAmountUploaded(_amountRead);
    SettingsManager manager=SettingsManager.instance();
    int speed=manager.getUploadSpeed();
    if (speed == 100) {
      uploadUnthrottled();
    }
 else {
      uploadThrottled();
    }
  }
 catch (  IOException ioe) {
    _closeConnection=true;
    throw ioe;
  }
  _uploader.setState(_uploader.COMPLETE);
}",0.5961777115909656
4983,"private void addAudioMetadata(Response[] responses){
  if (responses == null)   return;
  String audioURI=""String_Node_Str"";
  SchemaReplyCollectionMapper map=SchemaReplyCollectionMapper.instance();
  LimeXMLReplyCollection coll=map.getReplyCollection(audioURI);
  if (coll == null)   return;
  int z=responses.length;
  for (int i=0; i < z; i++) {
    FileDesc f=get((int)responses[i].getIndex());
    File file=new File(f._path);
    String hash=readFromMap(file,true);
    LimeXMLDocument doc=coll.getDocForHash(hash);
    if (doc == null)     continue;
    String XMLString=""String_Node_Str"";
    try {
      XMLString=doc.getXMLString();
    }
 catch (    Exception e) {
      e.printStackTrace();
      continue;
    }
    if (XMLString != null && !XMLString.equals(""String_Node_Str"")) {
      responses[i].setMetadata(XMLString);
    }
  }
}","private void addAudioMetadata(Response[] responses){
  if (responses == null)   return;
  String audioURI=""String_Node_Str"";
  SchemaReplyCollectionMapper map=SchemaReplyCollectionMapper.instance();
  LimeXMLReplyCollection coll=map.getReplyCollection(audioURI);
  if (coll == null)   return;
  int z=responses.length;
  for (int i=0; i < z; i++) {
    FileDesc f=get((int)responses[i].getIndex());
    File file=new File(f._path);
    String hash=readFromMap(file,true);
    if (hash == null)     hash=readFromMap(file,false);
    LimeXMLDocument doc=coll.getDocForHash(hash);
    if (doc == null)     continue;
    String XMLString=""String_Node_Str"";
    try {
      XMLString=doc.getXMLString();
    }
 catch (    Exception e) {
      e.printStackTrace();
      continue;
    }
    if (XMLString != null && !XMLString.equals(""String_Node_Str"")) {
      responses[i].setMetadata(XMLString);
    }
  }
}",0.9680365296803652
4984,"/** 
 * This class implements a succesful upload version of the doUpload method.  It prepares a file, writes the appropriate header, then sends the file.
 */
public void doUpload(HTTPUploader uploader) throws IOException {
  try {
    _uploader=uploader;
    _uploader.setState(_uploader.UPLOADING);
    _ostream=_uploader.getOutputStream();
    _index=_uploader.getIndex();
    _filename=_uploader.getFileName();
    _fileSize=_uploader.getFileSize();
    _fis=_uploader.getInputStream();
    _amountRead=_uploader.amountUploaded();
    _uploadBegin=_uploader.getUploadBegin();
    _uploadEnd=_uploader.getUploadEnd();
    if (_fileSize < _uploadBegin)     return;
    if (_uploadEnd <= 0 || _uploadEnd <= _uploadBegin || _uploadEnd > _fileSize)     _uploadEnd=_fileSize;
    writeHeader();
    int c=-1;
    int available=0;
    byte[] buf=new byte[1024];
    long a=_fis.skip(_uploadBegin);
    _amountRead+=a;
    _uploader.setAmountUploaded(_amountRead);
    SettingsManager manager=SettingsManager.instance();
    int speed=manager.getUploadSpeed();
    if (speed == 100) {
      while (true) {
        c=_fis.read(buf);
        if (c == -1)         break;
        if (c > (_uploadEnd - _amountRead))         c=_uploadEnd - _amountRead;
        try {
          _ostream.write(buf,0,c);
        }
 catch (        java.net.SocketException e) {
          throw new IOException();
        }
        _amountRead+=c;
        _uploader.setAmountUploaded(_amountRead);
        if (_amountRead >= _uploadEnd)         break;
      }
    }
 else {
      while (true) {
        int max=_uploader.getManager().calculateBandwidth();
        int burstSize=max * CYCLE_TIME;
        int burstSent=0;
        long start=System.currentTimeMillis();
        while (burstSent < burstSize) {
          c=_fis.read(buf);
          if (c == -1)           return;
          if (c > (_uploadEnd - _amountRead))           c=_uploadEnd - _amountRead;
          try {
            _ostream.write(buf,0,c);
          }
 catch (          java.net.SocketException e) {
            throw new IOException();
          }
          _amountRead+=c;
          _uploader.setAmountUploaded(_amountRead);
          burstSent+=c;
          if (_amountRead >= _uploadEnd)           break;
        }
        long stop=System.currentTimeMillis();
        int elapsed=(int)(stop - start);
        int sleepTime=CYCLE_TIME - elapsed;
        if (sleepTime > 0) {
          try {
            Thread.currentThread().sleep(sleepTime);
          }
 catch (          InterruptedException e) {
            throw new IOException();
          }
        }
      }
    }
  }
 catch (  IOException ioe) {
    _closeConnection=true;
    throw ioe;
  }
}","/** 
 * This class implements a succesful upload version of the doUpload method.  It prepares a file, writes the appropriate header, then sends the file.
 */
public void doUpload(HTTPUploader uploader) throws IOException {
  try {
    _uploader=uploader;
    _uploader.setState(_uploader.UPLOADING);
    _ostream=_uploader.getOutputStream();
    _index=_uploader.getIndex();
    _filename=_uploader.getFileName();
    _fileSize=_uploader.getFileSize();
    _fis=_uploader.getInputStream();
    _amountRead=_uploader.amountUploaded();
    _uploadBegin=_uploader.getUploadBegin();
    _uploadEnd=_uploader.getUploadEnd();
    if (_fileSize < _uploadBegin)     return;
    if (_uploadEnd <= 0 || _uploadEnd <= _uploadBegin || _uploadEnd > _fileSize)     _uploadEnd=_fileSize;
    writeHeader();
    int c=-1;
    int available=0;
    byte[] buf=new byte[1024];
    long a=_fis.skip(_uploadBegin);
    _amountRead+=a;
    _uploader.setAmountUploaded(_amountRead);
    SettingsManager manager=SettingsManager.instance();
    int speed=manager.getUploadSpeed();
    if (speed == 100) {
      while (true) {
        c=_fis.read(buf);
        if (c == -1)         break;
        if (c > (_uploadEnd - _amountRead))         c=_uploadEnd - _amountRead;
        try {
          _ostream.write(buf,0,c);
        }
 catch (        java.net.SocketException e) {
          throw new IOException();
        }
        _amountRead+=c;
        _uploader.setAmountUploaded(_amountRead);
        if (_amountRead >= _uploadEnd)         break;
      }
    }
 else {
      while (true) {
        int max=_uploader.getManager().calculateBandwidth();
        int burstSize=max * CYCLE_TIME;
        int burstSent=0;
        long start=System.currentTimeMillis();
        while (burstSent < burstSize) {
          c=_fis.read(buf);
          if (c == -1)           return;
          if (c > (_uploadEnd - _amountRead))           c=_uploadEnd - _amountRead;
          try {
            _ostream.write(buf,0,c);
          }
 catch (          java.net.SocketException e) {
            throw new IOException();
          }
          _amountRead+=c;
          _uploader.setAmountUploaded(_amountRead);
          burstSent+=c;
          if (_amountRead >= _uploadEnd)           break;
        }
        long stop=System.currentTimeMillis();
        int elapsed=(int)(stop - start);
        int sleepTime=CYCLE_TIME - elapsed;
        if (sleepTime > 0) {
          try {
            Thread.currentThread().sleep(sleepTime);
          }
 catch (          InterruptedException e) {
            throw new IOException();
          }
        }
      }
    }
  }
 catch (  IOException ioe) {
    _closeConnection=true;
    throw ioe;
  }
  _uploader.setState(_uploader.COMPLETE);
}",0.9922822491730982
4985,"/** 
 * Tries one round of downloading of the given files.  Downloads from all locations until all locations fail or some locations succeed.  Moves incomplete file to the library on success.
 * @param files a list of files to pick from, all of which MUST be""identical"" instances of RemoteFileDesc.  Unreachable locations are removed from files.
 * @return COMPLETE if a file was successfully downloadedCOULDNT_MOVE_TO_LIBRARY the download completed but the temporary file couldn't be moved to the library WAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try.
 * @exception InterruptedException if the user stop()'ed this download. (Calls to resume() do not result in InterruptedException.)
 */
private int tryAllDownloads2(final List files) throws InterruptedException {
  if (files.size() == 0)   return GAVE_UP;
  RemoteFileDesc rfd=(RemoteFileDesc)files.get(0);
  int fileSize=rfd.getSize();
  String filename=rfd.getFileName();
  File incompleteFile=incompleteFileManager.getFile(rfd);
  File sharedDir;
  File completeFile;
  try {
    sharedDir=SettingsManager.instance().getSaveDirectory();
    completeFile=new File(sharedDir,filename);
    String sharedPath=sharedDir.getCanonicalPath();
    String completeFileParentPath=new File(completeFile.getParent()).getCanonicalPath();
    if (!sharedPath.equals(completeFileParentPath))     throw new InvalidPathException();
  }
 catch (  IOException e) {
    return COULDNT_MOVE_TO_LIBRARY;
  }
  int status=tryAllDownloads3(files);
  if (status != COMPLETE)   return status;
  completeFile.delete();
  if (!incompleteFile.renameTo(completeFile))   if (!CommonUtils.copy(incompleteFile,completeFile))   return COULDNT_MOVE_TO_LIBRARY;
  fileManager.addFileIfShared(completeFile,getXMLDocuments());
  return COMPLETE;
}","/** 
 * Tries one round of downloading of the given files.  Downloads from all locations until all locations fail or some locations succeed.  Moves incomplete file to the library on success.
 * @param files a list of files to pick from, all of which MUST be""identical"" instances of RemoteFileDesc.  Unreachable locations are removed from files.
 * @return COMPLETE if a file was successfully downloadedCOULDNT_MOVE_TO_LIBRARY the download completed but the temporary file couldn't be moved to the library WAITING_FOR_RETRY if no file was downloaded, but it makes sense  to try again later because some hosts reported busy. The caller should usually wait before retrying. GAVE_UP the download attempt failed, and there are  no more locations to try.
 * @exception InterruptedException if the user stop()'ed this download. (Calls to resume() do not result in InterruptedException.)
 */
private int tryAllDownloads2(final List files) throws InterruptedException {
  if (files.size() == 0)   return GAVE_UP;
  RemoteFileDesc rfd=(RemoteFileDesc)files.get(0);
  int fileSize=rfd.getSize();
  String filename=rfd.getFileName();
  File incompleteFile=incompleteFileManager.getFile(rfd);
  File sharedDir;
  File completeFile;
  try {
    sharedDir=SettingsManager.instance().getSaveDirectory();
    completeFile=new File(sharedDir,filename);
    String sharedPath=sharedDir.getCanonicalPath();
    String completeFileParentPath=new File(completeFile.getParent()).getCanonicalPath();
    if (!sharedPath.equals(completeFileParentPath))     throw new InvalidPathException();
  }
 catch (  IOException e) {
    return COULDNT_MOVE_TO_LIBRARY;
  }
  int status=tryAllDownloads3(files);
  if (status != COMPLETE)   return status;
  completeFile.delete();
  if (!incompleteFile.renameTo(completeFile))   if (!CommonUtils.copy(incompleteFile,completeFile))   return COULDNT_MOVE_TO_LIBRARY;
  if (fileExists(completeFile))   fileManager.removeFileIfShared(completeFile);
  fileManager.addFileIfShared(completeFile,getXMLDocuments());
  return COMPLETE;
}",0.98
4986,"/** 
 * Indicates that we are a client node, and have received supernode connection. Executing this method will lead to dropping all the  connections except the one to the supernode. 
 * @param supernodeConnection The connectionto the supernode that wewanna preserve
 */
private synchronized void gotShieldedClientSupernodeConnection(ManagedConnection supernodeConnection){
  deactivateUltraFastConnectShutdown();
  setKeepAlive(0);
  Iterator iterator=_connections.iterator();
  while (iterator.hasNext()) {
    ManagedConnection connection=(ManagedConnection)iterator.next();
    if (!connection.equals(supernodeConnection))     remove(connection);
  }
}","/** 
 * Indicates that we are a client node, and have received supernode connection. Executing this method will lead to dropping all the  connections except the one to the supernode. 
 * @param supernodeConnection The connectionto the supernode that wewanna preserve
 */
private synchronized void gotShieldedClientSupernodeConnection(ManagedConnection supernodeConnection){
  deactivateUltraFastConnectShutdown();
  setKeepAlive(Math.min(1,_keepAlive));
  Iterator iterator=_connections.iterator();
  while (iterator.hasNext()) {
    ManagedConnection connection=(ManagedConnection)iterator.next();
    if (!connection.equals(supernodeConnection))     remove(connection);
  }
}",0.9827456864216054
4987,"/** 
 * Indicates that the node is in the client node, and has now lost its only connection to the supernode
 */
private synchronized void lostShieldedClientSupernodeConnection(){
  if (_connections.size() == 0) {
    setKeepAlive(SettingsManager.instance().getKeepAlive());
  }
}","/** 
 * Indicates that the node is in the client node, and has now lost its only connection to the supernode
 */
private synchronized void lostShieldedClientSupernodeConnection(){
  if (_connections.size() == 0 && _keepAlive > 0) {
    setKeepAlive(SettingsManager.instance().getKeepAlive());
  }
}",0.9688581314878892
4988,"/** 
 * Reset how many connections you want and start kicking more off if required.  This IS synchronized because we don't want threads adding or removing connections while this is deciding whether to add more threads.  Ignores request if a shielded leaf node.
 */
public synchronized void setKeepAlive(int newKeep){
  if (hasClientSupernodeConnection())   return;
  _keepAlive=newKeep;
  adjustConnectionFetchers();
}","/** 
 * Reset how many connections you want and start kicking more off if required.  This IS synchronized because we don't want threads adding or removing connections while this is deciding whether to add more threads.  Ignores request if a shielded leaf node and newKeep>1 (sic).
 */
public synchronized void setKeepAlive(int newKeep){
  if (newKeep > 1 && hasClientSupernodeConnection())   return;
  _keepAlive=newKeep;
  adjustConnectionFetchers();
}",0.9598163030998852
4989,"/** 
 * Broadcasts the query request to all initialized connections that are not the receivingConnection, setting up the routing to the designated QueryReplyHandler.  This is called from the default handleQueryRequest and the default broadcastQueryRequest(QueryRequest) If different (smarter) broadcasting functionality is desired, override as desired.  If you do, note that receivingConnection may be null (for requests originating here).
 */
protected void broadcastQueryRequest(QueryRequest queryRequest,ManagedConnection receivingConnection,ConnectionManager manager){
  List list=_manager.getInitializedConnections2();
  for (int i=0; i < list.size(); i++) {
    ManagedConnection c=(ManagedConnection)list.get(i);
    c.send(queryRequest);
  }
  list=_manager.getInitializedClientConnections2();
  for (int i=0; i < list.size(); i++) {
    ManagedConnection c=(ManagedConnection)list.get(i);
    if (c != receivingConnection) {
      ManagedConnectionQueryInfo qi=c.getQueryRouteState();
      if (qi == null || qi.lastReceived == null)       return;
 else       if (qi.lastReceived.contains(queryRequest)) {
        c.send(queryRequest);
      }
    }
  }
}","/** 
 * Broadcasts the query request to all initialized connections that are not the receivingConnection, setting up the routing to the designated QueryReplyHandler.  This is called from the default handleQueryRequest and the default broadcastQueryRequest(QueryRequest) If different (smarter) broadcasting functionality is desired, override as desired.  If you do, note that receivingConnection may be null (for requests originating here).
 */
protected void broadcastQueryRequest(QueryRequest queryRequest,ManagedConnection receivingConnection,ConnectionManager manager){
  List list=_manager.getInitializedConnections2();
  for (int i=0; i < list.size(); i++) {
    ManagedConnection c=(ManagedConnection)list.get(i);
    if (c != receivingConnection) {
      c.send(queryRequest);
    }
  }
  list=_manager.getInitializedClientConnections2();
  for (int i=0; i < list.size(); i++) {
    ManagedConnection c=(ManagedConnection)list.get(i);
    if (c != receivingConnection) {
      ManagedConnectionQueryInfo qi=c.getQueryRouteState();
      if (qi == null || qi.lastReceived == null)       return;
 else       if (qi.lastReceived.contains(queryRequest)) {
        c.send(queryRequest);
      }
    }
  }
}",0.981450252951096
4990,"/** 
 * Sets EVER_SUPERNODE_CAPABLE to true if this has the necessary requirements for becoming a supernode if needed, based on  the node's bandwidth, operating system, firewalled status,  uptime, etc.  Does not modify the property if the capabilities are not met.  If the user has disabled supernode support,  sets EVER_SUPERNODE_CAPABLE to false.
 */
public void setSupernodeCapable(){
  if (SETTINGS.getDisableSupernodeMode()) {
    SETTINGS.setEverSupernodeCapable(false);
    return;
  }
  boolean isSupernodeCapable=(((_maxUpstreamBytesPerSec >= MINIMUM_REQUIRED_UPSTREAM_BYTES_PER_SECOND) || (_maxDownstreamBytesPerSec >= MINIMUM_REQUIRED_DOWNSTREAM_BYTES_PER_SECOND)) && (AVERAGE_UPTIME >= MINIMUM_AVERAGE_UPTIME) && (_currentUptime >= MINIMUM_CURRENT_UPTIME)&& (SETTINGS.getEverAcceptedIncoming())&& (SUPERNODE_OS));
  if (isSupernodeCapable)   SETTINGS.setEverSupernodeCapable(true);
}","/** 
 * Sets EVER_SUPERNODE_CAPABLE to true if this has the necessary requirements for becoming a supernode if needed, based on  the node's bandwidth, operating system, firewalled status,  uptime, etc.  Does not modify the property if the capabilities are not met.  If the user has disabled supernode support,  sets EVER_SUPERNODE_CAPABLE to false.
 */
public void setSupernodeCapable(){
  if (SETTINGS.getDisableSupernodeMode()) {
    SETTINGS.setEverSupernodeCapable(false);
    return;
  }
  boolean isSupernodeCapable=(_maxUpstreamBytesPerSec >= MINIMUM_REQUIRED_UPSTREAM_KBYTES_PER_SECOND || _maxDownstreamBytesPerSec >= MINIMUM_REQUIRED_DOWNSTREAM_KBYTES_PER_SECOND) && (SETTINGS.getAverageUptime() >= MINIMUM_AVERAGE_UPTIME || _currentUptime >= MINIMUM_CURRENT_UPTIME) && SETTINGS.getEverAcceptedIncoming()&& SUPERNODE_OS;
  if (isSupernodeCapable)   SETTINGS.setEverSupernodeCapable(true);
}",0.8138238573021181
4991,"/** 
 * Returns whether or not this operating system is considered capable of meeting the requirements of a supernode.
 * @return <tt>true</tt> if this os meets supernode requirements,<tt>false</tt> otherwise
 */
public static boolean isSupernodeOS(){
  if (!_isWindows98 && !_isWindows95 && !_isMacClassic) {
    return false;
  }
  return true;
}","/** 
 * Returns whether or not this operating system is considered capable of meeting the requirements of a supernode.
 * @return <tt>true</tt> if this os meets supernode requirements,<tt>false</tt> otherwise
 */
public static boolean isSupernodeOS(){
  if (_isWindows98 || _isWindows95 || _isMacClassic) {
    return false;
  }
  return true;
}",0.9783549783549784
4992,"/** 
 * Blocks until we get a good pong. Throws InterruptedException if interrupted while waiting. 
 */
private void connectUntilPong() throws InterruptedException {
  gotGoodPong=false;
  while (!gotGoodPong) {
    String[] hosts=settings.getQuickConnectHosts();
    for (int i=0; i < hosts.length; i++) {
      Endpoint e;
      try {
        e=new Endpoint(hosts[i]);
      }
 catch (      IllegalArgumentException exc) {
        continue;
      }
      try {
        manager.createRouterConnection(e.getHostname(),e.getPort());
      }
 catch (      IOException exc) {
        continue;
      }
synchronized (gotGoodPongLock) {
        if (!gotGoodPong) {
          gotGoodPongLock.wait(CONNECT_TIME);
        }
      }
    }
    if (stale) {
synchronized (staleLock) {
        stale=false;
        staleLock.notifyAll();
      }
    }
    if (!gotGoodPong)     Thread.sleep(RETRY_TIME);
  }
}","/** 
 * Blocks until we get a good pong. Throws InterruptedException if interrupted while waiting. 
 */
private void connectUntilPong() throws InterruptedException {
  gotGoodPong=false;
  while (!gotGoodPong) {
    String[] hosts=settings.getQuickConnectHosts();
    for (int i=0; i < hosts.length && !gotGoodPong; i++) {
      Endpoint e;
      try {
        e=new Endpoint(hosts[i]);
      }
 catch (      IllegalArgumentException exc) {
        continue;
      }
      try {
        manager.createRouterConnection(e.getHostname(),e.getPort());
      }
 catch (      IOException exc) {
        continue;
      }
synchronized (gotGoodPongLock) {
        if (!gotGoodPong) {
          gotGoodPongLock.wait(CONNECT_TIME);
        }
      }
    }
    if (stale) {
synchronized (staleLock) {
        stale=false;
        staleLock.notifyAll();
      }
    }
    if (!gotGoodPong)     Thread.sleep(RETRY_TIME);
  }
}",0.9911602209944752
4993,"public void doDownload() throws IOException {
  _fos=new RandomAccessFile(_incompleteFile,""String_Node_Str"");
  _fos.seek(_initialReadingPoint);
  int c=-1;
  byte[] buf=new byte[1024];
  while (true) {
    if (_amountRead >= _amountToRead)     break;
    c=_byteReader.read(buf);
    if (c == -1)     break;
    _fos.write(buf,0,c);
    _amountRead+=c;
  }
  _byteReader.close();
  _fos.close();
  if (_amountRead != _amountToRead) {
    throw new FileIncompleteException();
  }
}","public void doDownload() throws IOException {
  _fos=new RandomAccessFile(_incompleteFile,""String_Node_Str"");
  _fos.seek(_initialReadingPoint);
  int c=-1;
  byte[] buf=new byte[BUF_LENGTH];
  while (true) {
    if (_amountRead >= _amountToRead)     break;
    int left=_amountToRead - _amountRead;
    c=_byteReader.read(buf,0,Math.min(BUF_LENGTH,left));
    if (c == -1)     break;
    _fos.write(buf,0,c);
    _amountRead+=c;
  }
  _byteReader.close();
  _fos.close();
  if (_amountRead != _amountToRead) {
    throw new FileIncompleteException();
  }
}",0.8246628131021194
4994,"/** 
 * Sets the shared directories.  This method filters out any duplicate or invalid directories in the string. Note, however, that it does not currently filter out listing subdirectories that have parent directories also in the string. 
 * @param dirs an array of <tt>File</tt> instances denotingthe abstract pathnames of the shared directories
 */
public void setDirectories(final File[] dirArray){
  HashMap directories=new HashMap();
  for (int i=0; i < dirArray.length; i++) {
    directories.put(dirArray[i],""String_Node_Str"");
  }
  Set fileSet=directories.keySet();
  Object[] prunedFiles=fileSet.toArray();
  StringBuffer sb=new StringBuffer();
  for (int z=0; z < prunedFiles.length; z++) {
    if (prunedFiles[z] != null) {
      sb.append(prunedFiles[z]);
      sb.append(';');
    }
  }
  _directories=new File[prunedFiles.length];
  for (int r=0; r < prunedFiles.length; r++) {
    _directories[r]=(File)prunedFiles[r];
  }
  PROPS.put(DIRECTORIES,sb.toString());
}","/** 
 * Sets the shared directories.  This method filters out any duplicate or invalid directories in the string. Note, however, that it does not currently filter out listing subdirectories that have parent directories also in the string. 
 * @param dirs an array of <tt>File</tt> instances denotingthe abstract pathnames of the shared directories
 */
public void setDirectories(final File[] dirArray){
  HashMap directories=new HashMap();
  for (int i=0; i < dirArray.length; i++) {
    if (dirArray[i].isDirectory())     directories.put(dirArray[i],""String_Node_Str"");
  }
  Set fileSet=directories.keySet();
  Object[] prunedFiles=fileSet.toArray();
  StringBuffer sb=new StringBuffer();
  for (int z=0; z < prunedFiles.length; z++) {
    if (prunedFiles[z] != null) {
      sb.append(prunedFiles[z]);
      sb.append(';');
    }
  }
  _directories=new File[prunedFiles.length];
  for (int r=0; r < prunedFiles.length; r++) {
    _directories[r]=(File)prunedFiles[r];
  }
  PROPS.put(DIRECTORIES,sb.toString());
}",0.9824737105658488
4995,"/** 
 * Initializes the key backend components.  Some tasks are postponed until postGuiInit().
 */
public void initialize(){
  SettingsManager settings=SettingsManager.instance();
  int port=settings.getPort();
  this.acceptor=new Acceptor(port,callback);
  this.manager=new ConnectionManager(callback);
  this.catcher=new HostCatcher(callback);
  this.downloader=new DownloadManager();
  this.uploadManager=new UploadManager();
  this.catcher.initialize(acceptor,manager,SettingsManager.instance().getHostList());
  this.router.initialize(acceptor,manager,catcher,uploadManager);
  this.manager.initialize(router,catcher);
  this.uploadManager.initialize(callback,router,acceptor,fileManager);
  this.acceptor.initialize(manager,router,downloader,uploadManager);
  this.catcher.connectToRouter();
  this.downloader.initialize(callback,router,acceptor,fileManager);
  Thread supernodeThread=new Thread(new SupernodeAssigner(uploadManager,downloader));
  supernodeThread.setDaemon(true);
  supernodeThread.start();
  int outgoing=settings.getKeepAlive();
  if (outgoing > 0)   connect();
}","/** 
 * Initializes the key backend components.  Some tasks are postponed until postGuiInit().
 */
public void initialize(){
  SettingsManager settings=SettingsManager.instance();
  int port=settings.getPort();
  this.acceptor=new Acceptor(port,callback);
  this.manager=new ConnectionManager(callback);
  this.catcher=new HostCatcher(callback);
  this.downloader=new DownloadManager();
  this.uploadManager=new UploadManager();
  this.chatManager=ChatManager.instance();
  this.catcher.initialize(acceptor,manager,SettingsManager.instance().getHostList());
  this.router.initialize(acceptor,manager,catcher,uploadManager);
  this.manager.initialize(router,catcher);
  this.uploadManager.initialize(callback,router,acceptor,fileManager);
  this.acceptor.initialize(manager,router,downloader,uploadManager);
  this.chatManager.setActivityCallback(callback);
  this.catcher.connectToRouter();
  this.downloader.initialize(callback,router,acceptor,fileManager);
  Thread supernodeThread=new Thread(new SupernodeAssigner(uploadManager,downloader));
  supernodeThread.setDaemon(true);
  supernodeThread.start();
  int outgoing=settings.getKeepAlive();
  if (outgoing > 0)   connect();
}",0.9590127809607756
4996,"/** 
 * Overloaded constructor that picks up data from between the  nulls That data is then made into a nice xml string that can  be converted into a LimeXMLDocument
 */
public Response(String betweenNulls,long index,long size,String name){
  Assert.that((index & 0xFFFFFFFF00000000l) == 0,""String_Node_Str"");
  Assert.that((size & 0xFFFFFFFF00000000l) == 0,""String_Node_Str"");
  String length=""String_Node_Str"";
  String bitrate=""String_Node_Str"";
  StringTokenizer tok=new StringTokenizer(betweenNulls);
  String first=tok.nextToken();
  String second=tok.nextToken();
  boolean bearShare1=false;
  boolean bearShare2=false;
  boolean gnotella=false;
  if (second.startsWith(""String_Node_Str""))   bearShare1=true;
 else   if (first.endsWith(""String_Node_Str""))   bearShare2=true;
  if (bearShare1) {
    bitrate=first;
  }
 else   if (bearShare2) {
    int j=first.indexOf(""String_Node_Str"");
    bitrate=first.substring(0,j);
  }
  if (bearShare1 || bearShare2) {
    while (tok.hasMoreTokens())     length=tok.nextToken();
  }
 else   if (betweenNulls.endsWith(""String_Node_Str"")) {
    gnotella=true;
    length=first;
    int i=second.indexOf(""String_Node_Str"");
    bitrate=second.substring(0,i);
  }
  if (bearShare1 || bearShare2 || gnotella) {
    this.metadata=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str""+ bitrate+ ""String_Node_Str""+ length+ ""String_Node_Str""+ ""String_Node_Str"";
    this.metaBytes=metadata.getBytes();
    this.index=index;
  }
  this.size=size;
  this.name=name;
  this.nameBytes=name.getBytes();
}","/** 
 * Overloaded constructor that picks up data from between the  nulls That data is then made into a nice xml string that can  be converted into a LimeXMLDocument
 */
public Response(String betweenNulls,long index,long size,String name){
  Assert.that((index & 0xFFFFFFFF00000000l) == 0,""String_Node_Str"");
  Assert.that((size & 0xFFFFFFFF00000000l) == 0,""String_Node_Str"");
  String length=""String_Node_Str"";
  String bitrate=""String_Node_Str"";
  String first=""String_Node_Str"";
  String second=""String_Node_Str"";
  StringTokenizer tok=new StringTokenizer(betweenNulls);
  try {
    first=tok.nextToken();
    second=tok.nextToken();
  }
 catch (  Exception e) {
    first=""String_Node_Str"";
    second=""String_Node_Str"";
    betweenNulls=""String_Node_Str"";
  }
  boolean bearShare1=false;
  boolean bearShare2=false;
  boolean gnotella=false;
  if (second.startsWith(""String_Node_Str""))   bearShare1=true;
 else   if (first.endsWith(""String_Node_Str""))   bearShare2=true;
  if (bearShare1) {
    bitrate=first;
  }
 else   if (bearShare2) {
    int j=first.indexOf(""String_Node_Str"");
    bitrate=first.substring(0,j);
  }
  if (bearShare1 || bearShare2) {
    while (tok.hasMoreTokens())     length=tok.nextToken();
  }
 else   if (betweenNulls.endsWith(""String_Node_Str"")) {
    gnotella=true;
    length=first;
    int i=second.indexOf(""String_Node_Str"");
    bitrate=second.substring(0,i);
  }
  if (bearShare1 || bearShare2 || gnotella) {
    this.metadata=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str""+ bitrate+ ""String_Node_Str""+ length+ ""String_Node_Str""+ ""String_Node_Str"";
    this.metaBytes=metadata.getBytes();
    this.index=index;
  }
  this.size=size;
  this.name=name;
  this.nameBytes=name.getBytes();
}",0.9342934293429342
4997,"/** 
 * Sends the HTTP GET along the given socket. 
 * @requires this initialized except for _byteReader, _fos
 * @modifies this._byteReader, network 
 */
private void connect() throws IOException {
  InputStream istream=null;
  try {
    istream=_socket.getInputStream();
  }
 catch (  Exception e) {
    throw new IOException();
  }
  _byteReader=new ByteReader(istream);
  OutputStream os=_socket.getOutputStream();
  OutputStreamWriter osw=new OutputStreamWriter(os);
  BufferedWriter out=new BufferedWriter(osw);
  String startRange=java.lang.String.valueOf(_initialReadingPoint);
  out.write(""String_Node_Str"" + _index + ""String_Node_Str""+ _filename+ ""String_Node_Str"");
  out.write(""String_Node_Str"" + CommonUtils.getVendor() + ""String_Node_Str"");
  out.write(""String_Node_Str"" + startRange + ""String_Node_Str"");
  SettingsManager sm=SettingsManager.instance();
  if (sm.getChatEnabled()) {
    int port;
    if (sm.getForceIPAddress())     port=sm.getForcedPort();
 else     port=sm.getPort();
    out.write(""String_Node_Str"" + _host + ""String_Node_Str""+ port+ ""String_Node_Str"");
    ;
  }
  out.write(""String_Node_Str"");
  out.flush();
}","/** 
 * Sends the HTTP GET along the given socket. 
 * @requires this initialized except for _byteReader, _fos
 * @modifies this._byteReader, network 
 */
private void connect() throws IOException {
  InputStream istream=null;
  try {
    istream=_socket.getInputStream();
  }
 catch (  Exception e) {
    throw new IOException();
  }
  _byteReader=new ByteReader(istream);
  OutputStream os=_socket.getOutputStream();
  OutputStreamWriter osw=new OutputStreamWriter(os);
  BufferedWriter out=new BufferedWriter(osw);
  String startRange=java.lang.String.valueOf(_initialReadingPoint);
  out.write(""String_Node_Str"" + _index + ""String_Node_Str""+ _filename+ ""String_Node_Str"");
  out.write(""String_Node_Str"" + CommonUtils.getVendor() + ""String_Node_Str"");
  out.write(""String_Node_Str"" + startRange + ""String_Node_Str"");
  SettingsManager sm=SettingsManager.instance();
  if (sm.getChatEnabled()) {
    int port;
    String host;
    if (sm.getForceIPAddress()) {
      port=sm.getForcedPort();
      host=sm.getForcedIPAddressString();
    }
 else {
      port=sm.getPort();
      host=_socket.getLocalAddress().getHostAddress();
    }
    out.write(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str"");
  }
  out.write(""String_Node_Str"");
  out.flush();
}",0.9417596034696406
4998,"public byte[] getForcedIPAddress(){
  return _forcedIPAddress;
}","/** 
 * Returns the forced IP address as an array of bytes. 
 */
public byte[] getForcedIPAddress(){
  return _forcedIPAddress;
}",0.6632124352331606
4999,"public void setForcedIPAddressString(String address){
  _forcedIPAddressString=address;
  _props.put(FORCED_IP_ADDRESS_STRING,address);
}","/** 
 * Sets the force IP address to the given address. If address is in symbolic form, blocks while  resolving it.
 * @param address an IP address in dotted quad (e.g., 1.2.3.4)or symbolic form (e.g., sparky.limewire.com)
 * @exception IllegalArgumentException address wasn'tin a valid format.
 */
public void setForcedIPAddressString(String address) throws IllegalArgumentException {
  try {
    InetAddress ia=InetAddress.getByName(address);
    _forcedIPAddress=ia.getAddress();
    _props.put(FORCED_IP_ADDRESS_STRING,address);
  }
 catch (  UnknownHostException e) {
    throw new IllegalArgumentException();
  }
}",0.3276089828269485
5000,"/** 
 * Load in the default values.  Any properties written to the real properties file will overwrite these. 
 */
private void loadDefaults(){
  setAllowBrowser(DEFAULT_ALLOW_BROWSER);
  setMaxTTL(DEFAULT_MAX_TTL);
  setSoftMaxTTL(DEFAULT_SOFT_MAX_TTL);
  setTTL(DEFAULT_TTL);
  setMaxLength(DEFAULT_MAX_LENGTH);
  setTimeout(DEFAULT_TIMEOUT);
  setKeepAlive(DEFAULT_KEEP_ALIVE);
  setPort(DEFAULT_PORT);
  setConnectionSpeed(DEFAULT_SPEED);
  setUploadSpeed(DEFAULT_UPLOAD_SPEED);
  setSearchLimit(DEFAULT_SEARCH_LIMIT);
  setClientID((new GUID(Message.makeGuid())).toHexString());
  setMaxIncomingConnections(DEFAULT_MAX_INCOMING_CONNECTION);
  setBannedIps(DEFAULT_BANNED_IPS);
  setBannedWords(DEFAULT_BANNED_WORDS);
  setFilterAdult(DEFAULT_FILTER_ADULT);
  setFilterDuplicates(DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(DEFAULT_FILTER_VBS);
  setFilterHtml(DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setExtensions(DEFAULT_EXTENSIONS);
  setBannedIps(DEFAULT_BANNED_IPS);
  setBannedWords(DEFAULT_BANNED_WORDS);
  setFilterAdult(DEFAULT_FILTER_ADULT);
  setFilterDuplicates(DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(DEFAULT_FILTER_VBS);
  setFilterHtml(DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setFilterBearShareQueries(DEFAULT_FILTER_BEARSHARE_QUERIES);
  setUseQuickConnect(DEFAULT_USE_QUICK_CONNECT);
  setQuickConnectHosts(DEFAULT_QUICK_CONNECT_HOSTS);
  setParallelSearchMax(DEFAULT_PARALLEL_SEARCH);
  setClearCompletedUpload(DEFAULT_CLEAR_UPLOAD);
  setClearCompletedDownload(DEFAULT_CLEAR_DOWNLOAD);
  setMaxSimDownload(DEFAULT_MAX_SIM_DOWNLOAD);
  setPromptExeDownload(DEFAULT_PROMPT_EXE_DOWNLOAD);
  setMaxUploads(DEFAULT_MAX_UPLOADS);
  setSearchAnimationTime(DEFAULT_SEARCH_ANIMATION_TIME);
  setConnectString(DEFAULT_CONNECT_STRING);
  setConnectOkString(DEFAULT_CONNECT_OK_STRING);
  setCheckAgain(DEFAULT_CHECK_AGAIN);
  setBasicInfoForQuery(DEFAULT_BASIC_INFO_FOR_QUERY);
  setAdvancedInfoForQuery(DEFAULT_ADVANCED_INFO_FOR_QUERY);
  setForceIPAddress(DEFAULT_FORCE_IP_ADDRESS);
  setForcedIPAddress(DEFAULT_FORCED_IP_ADDRESS);
  setForcedIPAddressString(DEFAULT_FORCED_IP_ADDRESS_STRING);
  setForcedPort(DEFAULT_FORCED_PORT);
  setFreeloaderFiles(DEFAULT_FREELOADER_FILES);
  setFreeloaderAllowed(DEFAULT_FREELOADER_ALLOWED);
  setUploadsPerPerson(DEFAULT_UPLOADS_PER_PERSON);
  setAverageUptime(DEFAULT_AVERAGE_UPTIME);
  setTotalUptime(DEFAULT_TOTAL_UPTIME);
  setSessions(DEFAULT_SESSIONS);
  setServantType(DEFAULT_SERVANT_TYPE);
  setInstalled(DEFAULT_INSTALLED);
  setRunOnce(DEFAULT_RUN_ONCE);
  setShowTrayDialog(DEFAULT_SHOW_TRAY_DIALOG);
  setMinimizeToTray(DEFAULT_MINIMIZE_TO_TRAY);
  setShowCloseDialog(DEFAULT_SHOW_CLOSE_DIALOG);
  setClassPath(DEFAULT_CLASSPATH);
  setMainClass(DEFAULT_MAIN_CLASS);
  setAppWidth(DEFAULT_APP_WIDTH);
  setAppHeight(DEFAULT_APP_HEIGHT);
  setChatEnabled(DEFAULT_CHAT_ENABLED);
  setLanguage(DEFAULT_LANGUAGE);
  setCountry(DEFAULT_COUNTRY);
  setMinimumSearchQuality(DEFAULT_MINIMUM_SEARCH_QUALITY);
  setMinimumSearchSpeed(DEFAULT_MINIMUM_SEARCH_SPEED);
  set17SearchMessageShown(DEFAULT_SEARCH_FILTER_MESSAGE_SHOWN);
}","/** 
 * Load in the default values.  Any properties written to the real properties file will overwrite these. 
 */
private void loadDefaults(){
  setAllowBrowser(DEFAULT_ALLOW_BROWSER);
  setMaxTTL(DEFAULT_MAX_TTL);
  setSoftMaxTTL(DEFAULT_SOFT_MAX_TTL);
  setTTL(DEFAULT_TTL);
  setMaxLength(DEFAULT_MAX_LENGTH);
  setTimeout(DEFAULT_TIMEOUT);
  setKeepAlive(DEFAULT_KEEP_ALIVE);
  setPort(DEFAULT_PORT);
  setConnectionSpeed(DEFAULT_SPEED);
  setUploadSpeed(DEFAULT_UPLOAD_SPEED);
  setSearchLimit(DEFAULT_SEARCH_LIMIT);
  setClientID((new GUID(Message.makeGuid())).toHexString());
  setMaxIncomingConnections(DEFAULT_MAX_INCOMING_CONNECTION);
  setBannedIps(DEFAULT_BANNED_IPS);
  setBannedWords(DEFAULT_BANNED_WORDS);
  setFilterAdult(DEFAULT_FILTER_ADULT);
  setFilterDuplicates(DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(DEFAULT_FILTER_VBS);
  setFilterHtml(DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setExtensions(DEFAULT_EXTENSIONS);
  setBannedIps(DEFAULT_BANNED_IPS);
  setBannedWords(DEFAULT_BANNED_WORDS);
  setFilterAdult(DEFAULT_FILTER_ADULT);
  setFilterDuplicates(DEFAULT_FILTER_DUPLICATES);
  setFilterVbs(DEFAULT_FILTER_VBS);
  setFilterHtml(DEFAULT_FILTER_HTML);
  setFilterGreedyQueries(DEFAULT_FILTER_GREEDY_QUERIES);
  setFilterBearShareQueries(DEFAULT_FILTER_BEARSHARE_QUERIES);
  setUseQuickConnect(DEFAULT_USE_QUICK_CONNECT);
  setQuickConnectHosts(DEFAULT_QUICK_CONNECT_HOSTS);
  setParallelSearchMax(DEFAULT_PARALLEL_SEARCH);
  setClearCompletedUpload(DEFAULT_CLEAR_UPLOAD);
  setClearCompletedDownload(DEFAULT_CLEAR_DOWNLOAD);
  setMaxSimDownload(DEFAULT_MAX_SIM_DOWNLOAD);
  setPromptExeDownload(DEFAULT_PROMPT_EXE_DOWNLOAD);
  setMaxUploads(DEFAULT_MAX_UPLOADS);
  setSearchAnimationTime(DEFAULT_SEARCH_ANIMATION_TIME);
  setConnectString(DEFAULT_CONNECT_STRING);
  setConnectOkString(DEFAULT_CONNECT_OK_STRING);
  setCheckAgain(DEFAULT_CHECK_AGAIN);
  setBasicInfoForQuery(DEFAULT_BASIC_INFO_FOR_QUERY);
  setAdvancedInfoForQuery(DEFAULT_ADVANCED_INFO_FOR_QUERY);
  setForceIPAddress(DEFAULT_FORCE_IP_ADDRESS);
  setForcedIPAddressString(DEFAULT_FORCED_IP_ADDRESS_STRING);
  setForcedPort(DEFAULT_FORCED_PORT);
  setFreeloaderFiles(DEFAULT_FREELOADER_FILES);
  setFreeloaderAllowed(DEFAULT_FREELOADER_ALLOWED);
  setUploadsPerPerson(DEFAULT_UPLOADS_PER_PERSON);
  setAverageUptime(DEFAULT_AVERAGE_UPTIME);
  setTotalUptime(DEFAULT_TOTAL_UPTIME);
  setSessions(DEFAULT_SESSIONS);
  setServantType(DEFAULT_SERVANT_TYPE);
  setInstalled(DEFAULT_INSTALLED);
  setRunOnce(DEFAULT_RUN_ONCE);
  setShowTrayDialog(DEFAULT_SHOW_TRAY_DIALOG);
  setMinimizeToTray(DEFAULT_MINIMIZE_TO_TRAY);
  setShowCloseDialog(DEFAULT_SHOW_CLOSE_DIALOG);
  setClassPath(DEFAULT_CLASSPATH);
  setMainClass(DEFAULT_MAIN_CLASS);
  setAppWidth(DEFAULT_APP_WIDTH);
  setAppHeight(DEFAULT_APP_HEIGHT);
  setChatEnabled(DEFAULT_CHAT_ENABLED);
  setLanguage(DEFAULT_LANGUAGE);
  setCountry(DEFAULT_COUNTRY);
  setMinimumSearchQuality(DEFAULT_MINIMUM_SEARCH_QUALITY);
  setMinimumSearchSpeed(DEFAULT_MINIMUM_SEARCH_SPEED);
  set17SearchMessageShown(DEFAULT_SEARCH_FILTER_MESSAGE_SHOWN);
}",0.9922135706340378
