record_number,buggy_code,fixed_code,code_similarity
8001,"private void showAbout(){
  if (sidebar != null) {
    openSidebar();
    if (about == null) {
      about=SimpleContentFragment.newInstance(FILE_ABOUT);
    }
    getFragmentManager().beginTransaction().addToBackStack(null).replace(R.id.sidebar,about).commit();
  }
 else {
    Intent i=new Intent(this,SimpleContentActivity.class);
    i.putExtra(SimpleContentActivity.EXTRA_FILE,FILE_ABOUT);
    startActivity(i);
  }
}","private void showAbout(){
  if (sidebar != null) {
    openSidebar();
    if (about == null) {
      about=SimpleContentFragment.newInstance(FILE_ABOUT);
    }
    getFragmentManager().beginTransaction().addToBackStack(null).replace(R.id.sidebar,about,ABOUT).commit();
  }
 else {
    Intent i=new Intent(this,SimpleContentActivity.class);
    i.putExtra(SimpleContentActivity.EXTRA_FILE,FILE_ABOUT);
    startActivity(i);
  }
}",0.9929411764705882
8002,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  ModelFragment mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
  if (mfrag == null) {
    getFragmentManager().beginTransaction().add(new ModelFragment(),MODEL).commit();
  }
 else   if (mfrag.getBook() != null) {
    setupPager(mfrag.getBook());
  }
  getActionBar().setHomeButtonEnabled(true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  getActionBar().setHomeButtonEnabled(true);
}",0.6430446194225722
8003,"@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
}","@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (adapter == null) {
    ModelFragment mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
    if (mfrag == null) {
      getFragmentManager().beginTransaction().add(new ModelFragment(),MODEL).commit();
    }
 else     if (mfrag.getBook() != null) {
      setupPager(mfrag.getBook());
    }
  }
}",0.3762376237623762
8004,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
  if (mfrag == null) {
    mfrag=new ModelFragment();
    getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
  }
 else   if (mfrag.getBook() != null) {
    setupPager(mfrag.getBook());
  }
  getActionBar().setHomeButtonEnabled(true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  getActionBar().setHomeButtonEnabled(true);
}",0.6405228758169934
8005,"@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}","@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (adapter == null) {
    mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
    if (mfrag == null) {
      mfrag=new ModelFragment();
      getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
    }
 else     if (mfrag.getBook() != null) {
      setupPager(mfrag.getBook());
    }
  }
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}",0.574468085106383
8006,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
  if (mfrag == null) {
    mfrag=new ModelFragment();
    getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
  }
 else   if (mfrag.getBook() != null) {
    setupPager(mfrag.getBook());
  }
  getActionBar().setHomeButtonEnabled(true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  getActionBar().setHomeButtonEnabled(true);
}",0.6405228758169934
8007,"@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}","@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (adapter == null) {
    mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
    if (mfrag == null) {
      mfrag=new ModelFragment();
      getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
    }
 else     if (mfrag.getBook() != null) {
      setupPager(mfrag.getBook());
    }
  }
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}",0.574468085106383
8008,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
  if (mfrag == null) {
    mfrag=new ModelFragment();
    getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
  }
 else   if (mfrag.getBook() != null) {
    setupPager(mfrag.getBook());
  }
  getActionBar().setHomeButtonEnabled(true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  getActionBar().setHomeButtonEnabled(true);
}",0.6405228758169934
8009,"@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}","@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (adapter == null) {
    mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
    if (mfrag == null) {
      mfrag=new ModelFragment();
      getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
    }
 else     if (mfrag.getBook() != null) {
      setupPager(mfrag.getBook());
    }
  }
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}",0.574468085106383
8010,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
  if (mfrag == null) {
    mfrag=new ModelFragment();
    getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
  }
 else   if (mfrag.getBook() != null) {
    setupPager(mfrag.getBook());
  }
  getActionBar().setHomeButtonEnabled(true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  getActionBar().setHomeButtonEnabled(true);
}",0.6405228758169934
8011,"@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}","@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (adapter == null) {
    mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
    if (mfrag == null) {
      mfrag=new ModelFragment();
      getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
    }
 else     if (mfrag.getBook() != null) {
      setupPager(mfrag.getBook());
    }
  }
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}",0.574468085106383
8012,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
  if (mfrag == null) {
    mfrag=new ModelFragment();
    getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
  }
 else   if (mfrag.getBook() != null) {
    setupPager(mfrag.getBook());
  }
  getActionBar().setHomeButtonEnabled(true);
  UpdateReceiver.scheduleAlarm(this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  getActionBar().setHomeButtonEnabled(true);
  UpdateReceiver.scheduleAlarm(this);
}",0.4851367419738406
8013,"@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}","@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (adapter == null) {
    mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
    if (mfrag == null) {
      mfrag=new ModelFragment();
      getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
    }
 else     if (mfrag.getBook() != null) {
      setupPager(mfrag.getBook());
    }
  }
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}",0.574468085106383
8014,"public void onEvent(BookUpdatedEvent event){
  NotificationCompat.Builder builder=new NotificationCompat.Builder(this);
  Intent toLaunch=new Intent(this,EmPubLiteActivity.class);
  PendingIntent pi=PendingIntent.getActivity(this,0,toLaunch,0);
  builder.setAutoCancel(true).setContentIntent(pi).setContentTitle(getString(R.string.update_complete)).setContentText(getString(R.string.update_desc)).setSmallIcon(android.R.drawable.stat_sys_download_done).setTicker(getString(R.string.update_complete));
  NotificationManager mgr=((NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE));
  mgr.notify(NOTIFY_ID,builder.build());
}","public void onEvent(NoSubscriberEvent event){
  NotificationCompat.Builder builder=new NotificationCompat.Builder(this);
  Intent toLaunch=new Intent(this,EmPubLiteActivity.class);
  PendingIntent pi=PendingIntent.getActivity(this,0,toLaunch,0);
  builder.setAutoCancel(true).setContentIntent(pi).setContentTitle(getString(R.string.update_complete)).setContentText(getString(R.string.update_desc)).setSmallIcon(android.R.drawable.stat_sys_download_done).setTicker(getString(R.string.update_complete));
  NotificationManager mgr=((NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE));
  mgr.notify(NOTIFY_ID,builder.build());
}",0.9820452771272444
8015,"@Override protected void doWakefulWork(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this,0);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}","@Override protected void doWakefulWork(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}",0.99812382739212
8016,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
  if (mfrag == null) {
    mfrag=new ModelFragment();
    getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
  }
 else   if (mfrag.getBook() != null) {
    setupPager(mfrag.getBook());
  }
  getActionBar().setHomeButtonEnabled(true);
  UpdateReceiver.scheduleAlarm(this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  getActionBar().setHomeButtonEnabled(true);
  UpdateReceiver.scheduleAlarm(this);
}",0.4851367419738406
8017,"@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}","@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (adapter == null) {
    mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
    if (mfrag == null) {
      mfrag=new ModelFragment();
      getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
    }
 else     if (mfrag.getBook() != null) {
      setupPager(mfrag.getBook());
    }
  }
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}",0.574468085106383
8018,"@Override public void onAttach(Activity host){
  super.onAttach(host);
  EventBus.getDefault().register(this,1);
  if (contents == null) {
    new LoadThread(host).start();
  }
}","@Override public void onAttach(Activity host){
  super.onAttach(host);
  EventBus.getDefault().register(this);
  if (contents == null) {
    new LoadThread(host).start();
  }
}",0.9943502824858758
8019,"public void onEvent(BookUpdatedEvent event){
  if (getActivity() != null) {
    new LoadThread(getActivity()).start();
    EventBus.getDefault().cancelEventDelivery(event);
  }
}","public void onEvent(BookUpdatedEvent event){
  if (getActivity() != null) {
    new LoadThread(getActivity()).start();
  }
}",0.8211920529801324
8020,"public void onEvent(BookUpdatedEvent event){
  NotificationCompat.Builder builder=new NotificationCompat.Builder(this);
  Intent toLaunch=new Intent(this,EmPubLiteActivity.class);
  PendingIntent pi=PendingIntent.getActivity(this,0,toLaunch,0);
  builder.setAutoCancel(true).setContentIntent(pi).setContentTitle(getString(R.string.update_complete)).setContentText(getString(R.string.update_desc)).setSmallIcon(android.R.drawable.stat_sys_download_done).setTicker(getString(R.string.update_complete));
  NotificationManager mgr=((NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE));
  mgr.notify(NOTIFY_ID,builder.build());
}","public void onEvent(NoSubscriberEvent event){
  NotificationCompat.Builder builder=new NotificationCompat.Builder(this);
  Intent toLaunch=new Intent(this,EmPubLiteActivity.class);
  PendingIntent pi=PendingIntent.getActivity(this,0,toLaunch,0);
  builder.setAutoCancel(true).setContentIntent(pi).setContentTitle(getString(R.string.update_complete)).setContentText(getString(R.string.update_desc)).setSmallIcon(android.R.drawable.stat_sys_download_done).setTicker(getString(R.string.update_complete));
  NotificationManager mgr=((NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE));
  mgr.notify(NOTIFY_ID,builder.build());
}",0.9820452771272444
8021,"@Override protected void doWakefulWork(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this,0);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}","@Override protected void doWakefulWork(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}",0.99812382739212
8022,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  sidebar=findViewById(R.id.sidebar);
  divider=findViewById(R.id.divider);
  getFragmentManager().addOnBackStackChangedListener(this);
  mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
  if (mfrag == null) {
    mfrag=new ModelFragment();
    getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
  }
 else   if (mfrag.getBook() != null) {
    setupPager(mfrag.getBook());
  }
  help=(SimpleContentFragment)getFragmentManager().findFragmentByTag(HELP);
  about=(SimpleContentFragment)getFragmentManager().findFragmentByTag(ABOUT);
  getActionBar().setHomeButtonEnabled(true);
  UpdateReceiver.scheduleAlarm(this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setupStrictMode();
  setContentView(R.layout.main);
  pager=(ViewPager)findViewById(R.id.pager);
  sidebar=findViewById(R.id.sidebar);
  divider=findViewById(R.id.divider);
  getFragmentManager().addOnBackStackChangedListener(this);
  help=(SimpleContentFragment)getFragmentManager().findFragmentByTag(HELP);
  about=(SimpleContentFragment)getFragmentManager().findFragmentByTag(ABOUT);
  getActionBar().setHomeButtonEnabled(true);
  UpdateReceiver.scheduleAlarm(this);
}",0.8064743138634765
8023,"@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}","@Override public void onResume(){
  super.onResume();
  EventBus.getDefault().register(this);
  if (adapter == null) {
    mfrag=(ModelFragment)getFragmentManager().findFragmentByTag(MODEL);
    if (mfrag == null) {
      mfrag=new ModelFragment();
      getFragmentManager().beginTransaction().add(mfrag,MODEL).commit();
    }
 else     if (mfrag.getBook() != null) {
      setupPager(mfrag.getBook());
    }
  }
  if (mfrag.getPrefs() != null) {
    pager.setKeepScreenOn(mfrag.getPrefs().getBoolean(PREF_KEEP_SCREEN_ON,false));
  }
}",0.574468085106383
8024,"@Override public void onAttach(Activity host){
  super.onAttach(host);
  EventBus.getDefault().register(this,1);
  if (contents == null) {
    new LoadThread(host).start();
  }
}","@Override public void onAttach(Activity host){
  super.onAttach(host);
  EventBus.getDefault().register(this);
  if (contents == null) {
    new LoadThread(host).start();
  }
}",0.9943502824858758
8025,"public void onEvent(BookUpdatedEvent event){
  if (getActivity() != null) {
    new LoadThread(getActivity()).start();
    EventBus.getDefault().cancelEventDelivery(event);
  }
}","public void onEvent(BookUpdatedEvent event){
  if (getActivity() != null) {
    new LoadThread(getActivity()).start();
  }
}",0.8211920529801324
8026,"@Override protected Void doInBackground(ContentValues... values){
  db.getWritableDatabase().insert(DatabaseHelper.TABLE,DatabaseHelper.TITLE,values[0]);
  constantsCursor=doQuery();
  constantsCursor.getCount();
  return (null);
}","@Override protected Cursor doInBackground(ContentValues... values){
  db.getWritableDatabase().insert(DatabaseHelper.TABLE,DatabaseHelper.TITLE,values[0]);
  return (doQuery());
}",0.824390243902439
8027,"private Cursor doQuery(){
  String query=String.format(""String_Node_Str"",DatabaseHelper.TITLE,DatabaseHelper.VALUE,DatabaseHelper.TABLE,DatabaseHelper.TITLE);
  return (db.getReadableDatabase().rawQuery(query,null));
}","protected Cursor doQuery(){
  Cursor result=db.getReadableDatabase().query(DatabaseHelper.TABLE,new String[]{""String_Node_Str"",DatabaseHelper.TITLE,DatabaseHelper.VALUE},null,null,null,null,DatabaseHelper.TITLE);
  result.getCount();
  return (result);
}",0.4025423728813559
8028,"@Override public void onPostExecute(Void arg0){
  ((CursorAdapter)getListAdapter()).changeCursor(constantsCursor);
}","@Override public void onPostExecute(Cursor result){
  ((CursorAdapter)getListAdapter()).changeCursor(result);
}",0.8546255506607929
8029,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  db=new DatabaseHelper(getActivity());
  new LoadCursorTask().execute();
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  SimpleCursorAdapter adapter=new SimpleCursorAdapter(getActivity(),R.layout.row,current,new String[]{DatabaseHelper.TITLE,DatabaseHelper.VALUE},new int[]{R.id.title,R.id.value},0);
  setListAdapter(adapter);
  if (current == null) {
    db=new DatabaseHelper(getActivity());
    new LoadCursorTask().execute();
  }
}",0.6194968553459119
8030,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.add:
    add();
  return (true);
}
return (super.onOptionsItemSelected(item));
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  if (item.getItemId() == R.id.add) {
    add();
    return (true);
  }
  return (super.onOptionsItemSelected(item));
}",0.9256198347107438
8031,"@Override protected void onHandleIntent(Intent intent){
  String url=getUpdateUrl();
  if (url != null) {
    try {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().post(new BookUpdatedEvent());
    }
 catch (    Exception e) {
      Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
    }
  }
}","@Override protected void onHandleIntent(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().post(new BookUpdatedEvent());
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}",0.9595505617977528
8032,"@Override protected void doWakefulWork(Intent intent){
  String url=getUpdateUrl();
  if (url != null) {
    try {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().post(new BookUpdatedEvent());
    }
 catch (    Exception e) {
      Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
    }
  }
}","@Override protected void doWakefulWork(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().post(new BookUpdatedEvent());
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}",0.9594594594594594
8033,"@Override protected void doWakefulWork(Intent intent){
  String url=getUpdateUrl();
  if (url != null) {
    try {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this,0);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
 catch (    Exception e) {
      Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
    }
  }
}","@Override protected void doWakefulWork(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this,0);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}",0.9664179104477612
8034,"@Override protected void doWakefulWork(Intent intent){
  String url=getUpdateUrl();
  if (url != null) {
    try {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this,0);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
 catch (    Exception e) {
      Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
    }
  }
}","@Override protected void doWakefulWork(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this,0);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}",0.9664179104477612
8035,"@Override protected void onHandleIntent(Intent intent){
  String url=getUpdateUrl();
  if (url != null) {
    try {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().post(new BookUpdatedEvent());
    }
 catch (    Exception e) {
      Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
    }
  }
}","@Override protected void onHandleIntent(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().post(new BookUpdatedEvent());
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}",0.9595505617977528
8036,"@Override protected void doWakefulWork(Intent intent){
  String url=getUpdateUrl();
  if (url != null) {
    try {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().post(new BookUpdatedEvent());
    }
 catch (    Exception e) {
      Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
    }
  }
}","@Override protected void doWakefulWork(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().post(new BookUpdatedEvent());
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}",0.9594594594594594
8037,"@Override protected void doWakefulWork(Intent intent){
  String url=getUpdateUrl();
  if (url != null) {
    try {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this,0);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
 catch (    Exception e) {
      Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
    }
  }
}","@Override protected void doWakefulWork(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this,0);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}",0.9664179104477612
8038,"@Override protected void doWakefulWork(Intent intent){
  String url=getUpdateUrl();
  if (url != null) {
    try {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this,0);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
 catch (    Exception e) {
      Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
    }
  }
}","@Override protected void doWakefulWork(Intent intent){
  try {
    String url=getUpdateUrl();
    if (url != null) {
      File book=download(url);
      File updateDir=new File(getFilesDir(),UPDATE_BASEDIR);
      updateDir.mkdirs();
      unzip(book,updateDir);
      book.delete();
      EventBus.getDefault().register(this,0);
      EventBus.getDefault().post(new BookUpdatedEvent());
      EventBus.getDefault().unregister(this);
    }
  }
 catch (  Exception e) {
    Log.e(getClass().getSimpleName(),""String_Node_Str"",e);
  }
}",0.9664179104477612
8039,"@Override public void onAttach(Activity host){
  super.onAttach(host);
  router=MediaRouter.getInstance(host);
  router.addProvider(new DemoRouteProvider(getActivity()));
}","@Override public void onAttach(Activity host){
  super.onAttach(host);
  router=MediaRouter.getInstance(host);
  provider=new DemoRouteProvider(getActivity());
  router.addProvider(provider);
}",0.8767123287671232
8040,"@Override public void run(){
  super.run();
  client.release();
  client=null;
  getActivity().supportInvalidateOptionsMenu();
  logToTranscript(getActivity().getString(R.string.session_ended));
}","@Override public void run(){
  super.run();
  client.release();
  client=null;
  if (getActivity() != null) {
    getActivity().supportInvalidateOptionsMenu();
    logToTranscript(getActivity().getString(R.string.session_ended));
  }
}",0.9095127610208816
8041,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setRetainInstance(true);
  if (model == null) {
    model=new ArrayList<String>();
    new AddStringTask().execute();
  }
  adapter=new ArrayAdapter<String>(getActivity(),android.R.layout.simple_list_item_1,model);
  getListView().setScrollbarFadingEnabled(false);
  setListAdapter(adapter);
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  setRetainInstance(true);
  if (model == null) {
    model=new ArrayList<String>();
    task=new AddStringTask();
    task.execute();
  }
  adapter=new ArrayAdapter<String>(getActivity(),android.R.layout.simple_list_item_1,model);
  getListView().setScrollbarFadingEnabled(false);
  setListAdapter(adapter);
}",0.9820359281437124
8042,"@Override protected Void doInBackground(Void... unused){
  for (  String item : items) {
    publishProgress(item);
    SystemClock.sleep(400);
  }
  return (null);
}","@Override protected Void doInBackground(Void... unused){
  for (  String item : items) {
    if (!isCancelled()) {
      publishProgress(item);
      SystemClock.sleep(400);
    }
  }
  return (null);
}",0.9021739130434784
8043,"@Override protected void onPostExecute(Void unused){
  Toast.makeText(getActivity(),R.string.done,Toast.LENGTH_SHORT).show();
}","@Override protected void onPostExecute(Void unused){
  if (!isCancelled()) {
    Toast.makeText(getActivity(),R.string.done,Toast.LENGTH_SHORT).show();
  }
  task=null;
}",0.8552188552188552
8044,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  if (getFragmentManager().findFragmentById(R.id.content) == null) {
    showLorem();
  }
  getFragmentManager().addOnBackStackChangedListener(this);
  drawer=(ListView)findViewById(R.id.drawer);
  drawer.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
  String[] rows=getResources().getStringArray(R.array.drawer_rows);
  drawer.setAdapter(new ArrayAdapter<String>(this,R.layout.drawer_row,rows));
  if (savedInstanceState == null) {
    drawer.setItemChecked(0,true);
  }
  drawer.setOnItemClickListener(this);
  drawerLayout=(DrawerLayout)findViewById(R.id.drawer_layout);
  toggle=new ActionBarDrawerToggle(this,drawerLayout,R.drawable.ic_drawer,R.string.drawer_open,R.string.drawer_close);
  drawerLayout.setDrawerListener(toggle);
  getActionBar().setDisplayHomeAsUpEnabled(true);
  getActionBar().setHomeButtonEnabled(true);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  drawer=(ListView)findViewById(R.id.drawer);
  drawer.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
  String[] rows=getResources().getStringArray(R.array.drawer_rows);
  drawer.setAdapter(new ArrayAdapter<String>(this,R.layout.drawer_row,rows));
  drawer.setOnItemClickListener(this);
  drawerLayout=(DrawerLayout)findViewById(R.id.drawer_layout);
  toggle=new ActionBarDrawerToggle(this,drawerLayout,R.drawable.ic_drawer,R.string.drawer_open,R.string.drawer_close);
  drawerLayout.setDrawerListener(toggle);
  getActionBar().setDisplayHomeAsUpEnabled(true);
  getActionBar().setHomeButtonEnabled(true);
  getFragmentManager().addOnBackStackChangedListener(this);
  if (getFragmentManager().findFragmentById(R.id.content) == null) {
    showLorem();
  }
}",0.7991430101767542
8045,"@Override public void wordClicked(){
  int toClear=drawer.getCheckedItemPosition();
  if (toClear >= 0) {
    drawer.setItemChecked(toClear,false);
  }
  if (stuff == null) {
    stuff=new StuffFragment();
  }
  getFragmentManager().beginTransaction().replace(R.id.content,stuff).addToBackStack(null).commit();
}","@Override public void wordClicked(){
  if (stuff == null) {
    stuff=new StuffFragment();
  }
  getFragmentManager().beginTransaction().replace(R.id.content,stuff).addToBackStack(null).commit();
  drawer.post(onNavChange);
}",0.1787709497206704
8046,"private void showLorem(){
  if (lorem == null) {
    lorem=new LoremFragment();
  }
  if (!lorem.isVisible()) {
    getFragmentManager().popBackStack();
    getFragmentManager().beginTransaction().replace(R.id.content,lorem).commit();
  }
}","private void showLorem(){
  if (lorem == null) {
    lorem=new LoremFragment();
  }
  if (!lorem.isVisible()) {
    getFragmentManager().popBackStack();
    getFragmentManager().beginTransaction().replace(R.id.content,lorem).commit();
    drawer.post(onNavChange);
  }
}",0.9411764705882352
8047,"private void showContent(){
  if (content == null) {
    content=new ContentFragment();
  }
  if (!content.isVisible()) {
    getFragmentManager().popBackStack();
    getFragmentManager().beginTransaction().replace(R.id.content,content).commit();
  }
}","private void showContent(){
  if (content == null) {
    content=new ContentFragment();
  }
  if (!content.isVisible()) {
    getFragmentManager().popBackStack();
    getFragmentManager().beginTransaction().replace(R.id.content,content).commit();
    drawer.post(onNavChange);
  }
}",0.9438202247191012
8048,"@Override public void onBackStackChanged(){
  if (lorem.isVisible()) {
    drawer.setItemChecked(0,true);
  }
 else   if (content != null && content.isVisible()) {
    drawer.setItemChecked(1,true);
  }
}","@Override public void onBackStackChanged(){
  drawer.post(onNavChange);
}",0.447653429602888
8049,"@Override public void onSaveInstanceState(Bundle state){
  super.onSaveInstanceState(state);
  state.putCharSequence(STATE_QUERY,sv.getQuery());
  state.putStringArrayList(STATE_MODEL,words);
}","@Override public void onSaveInstanceState(Bundle state){
  super.onSaveInstanceState(state);
  if (!sv.isIconified()) {
    state.putCharSequence(STATE_QUERY,sv.getQuery());
  }
  state.putStringArrayList(STATE_MODEL,words);
}",0.9212410501193318
8050,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.passphrase_setup);
  SQLiteDatabase.loadLibs(this);
  dbState=DatabaseHelper.getDatabaseState(AuthActivity.this);
  passphrase=(EditText)findViewById(R.id.passphrase);
  confirm=(EditText)findViewById(R.id.confirm);
  passphrase.addTextChangedListener(this);
  confirm.addTextChangedListener(this);
  if (dbState == State.ENCRYPTED) {
    confirm.setVisibility(View.GONE);
  }
  CompoundButton cb=(CompoundButton)findViewById(R.id.show_passphrase);
  cb.setOnCheckedChangeListener(this);
  ok=findViewById(R.id.ok);
  ok.setOnClickListener(this);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.passphrase_setup);
  SQLiteDatabase.loadLibs(this);
  if (DatabaseHelper.getDatabase() != null) {
    startActivity(new Intent(this,MainActivity.class));
    finish();
  }
  dbState=DatabaseHelper.getDatabaseState(AuthActivity.this);
  passphrase=(EditText)findViewById(R.id.passphrase);
  confirm=(EditText)findViewById(R.id.confirm);
  passphrase.addTextChangedListener(this);
  confirm.addTextChangedListener(this);
  if (dbState == State.ENCRYPTED) {
    confirm.setVisibility(View.GONE);
  }
  CompoundButton cb=(CompoundButton)findViewById(R.id.show_passphrase);
  cb.setOnCheckedChangeListener(this);
  ok=findViewById(R.id.ok);
  ok.setOnClickListener(this);
}",0.9179206566347468
8051,"@Override protected void onRestoreInstanceState(Bundle state){
  String contactUri=state.getString(""String_Node_Str"");
  if (contactUri != null) {
    contact=Uri.parse(contactUri);
    viewButton.setEnabled(true);
  }
}","@Override protected void onRestoreInstanceState(Bundle state){
  super.onRestoreInstanceState(state);
  String contactUri=state.getString(""String_Node_Str"");
  if (contactUri != null) {
    contact=Uri.parse(contactUri);
    viewButton.setEnabled(true);
  }
}",0.918580375782881
8052,"public void save(View v){
  Intent shortcut=new Intent(Intent.ACTION_SEND);
  TextView addr=(TextView)findViewById(R.id.addr);
  TextView subject=(TextView)findViewById(R.id.subject);
  TextView body=(TextView)findViewById(R.id.body);
  TextView name=(TextView)findViewById(R.id.name);
  if (!TextUtils.isEmpty(addr.getText())) {
    shortcut.putExtra(Intent.EXTRA_EMAIL,addr.getText().toString());
  }
  if (!TextUtils.isEmpty(subject.getText())) {
    shortcut.putExtra(Intent.EXTRA_SUBJECT,subject.getText().toString());
  }
  if (!TextUtils.isEmpty(body.getText())) {
    shortcut.putExtra(Intent.EXTRA_TEXT,body.getText().toString());
  }
  shortcut.setType(""String_Node_Str"");
  Intent result=new Intent();
  result.putExtra(Intent.EXTRA_SHORTCUT_INTENT,shortcut);
  result.putExtra(Intent.EXTRA_SHORTCUT_NAME,name.getText().toString());
  result.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE,Intent.ShortcutIconResource.fromContext(this,R.drawable.icon));
  setResult(RESULT_OK,result);
  finish();
}","public void save(View v){
  Intent shortcut=new Intent(Intent.ACTION_SEND);
  TextView addr=(TextView)findViewById(R.id.addr);
  TextView subject=(TextView)findViewById(R.id.subject);
  TextView body=(TextView)findViewById(R.id.body);
  TextView name=(TextView)findViewById(R.id.name);
  if (!TextUtils.isEmpty(addr.getText())) {
    shortcut.putExtra(Intent.EXTRA_EMAIL,new String[]{addr.getText().toString()});
  }
  if (!TextUtils.isEmpty(subject.getText())) {
    shortcut.putExtra(Intent.EXTRA_SUBJECT,subject.getText().toString());
  }
  if (!TextUtils.isEmpty(body.getText())) {
    shortcut.putExtra(Intent.EXTRA_TEXT,body.getText().toString());
  }
  shortcut.setType(""String_Node_Str"");
  Intent result=new Intent();
  result.putExtra(Intent.EXTRA_SHORTCUT_INTENT,shortcut);
  result.putExtra(Intent.EXTRA_SHORTCUT_NAME,name.getText().toString());
  result.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE,Intent.ShortcutIconResource.fromContext(this,R.drawable.icon));
  setResult(RESULT_OK,result);
  finish();
}",0.9684106614017768
8053,"private File getTarget(){
  File root=null;
  if (external.isChecked()) {
    root=getActivity().getExternalFilesDir(null);
  }
 else {
    root=getActivity().getFilesDir();
  }
  return (new File(root,FILENAME));
}","private File getTarget(){
  File root=null;
  if (external != null && external.isChecked()) {
    root=getActivity().getExternalFilesDir(null);
  }
 else {
    root=getActivity().getFilesDir();
  }
  return (new File(root,FILENAME));
}",0.9555555555555556
8054,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  root=(ThreePaneLayout)findViewById(R.id.root);
  if (getFragmentManager().findFragmentById(R.id.left) == null) {
    getFragmentManager().beginTransaction().add(R.id.left,SimpleListFragment.newInstance(items)).commit();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  root=(ThreePaneLayout)findViewById(R.id.root);
  if (getFragmentManager().findFragmentById(R.id.left) == null) {
    getFragmentManager().beginTransaction().add(R.id.left,SimpleListFragment.newInstance(items)).commit();
  }
  middleFragment=(SimpleListFragment)getFragmentManager().findFragmentById(R.id.middle);
}",0.8915956151035322
8055,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  root=(ThreePaneLayout)findViewById(R.id.root);
  if (getSupportFragmentManager().findFragmentById(R.id.left) == null) {
    getSupportFragmentManager().beginTransaction().add(R.id.left,SimpleListFragment.newInstance(items)).commit();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  root=(ThreePaneLayout)findViewById(R.id.root);
  if (getSupportFragmentManager().findFragmentById(R.id.left) == null) {
    getSupportFragmentManager().beginTransaction().add(R.id.left,SimpleListFragment.newInstance(items)).commit();
  }
  middleFragment=(SimpleListFragment)getSupportFragmentManager().findFragmentById(R.id.middle);
}",0.8878504672897196
8056,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  root=findViewById(android.R.id.content);
}",0.8617363344051447
8057,"@Override public void onResume(){
  super.onResume();
  root=findViewById(android.R.id.content);
  everyFiveSeconds.run();
}","@Override public void onResume(){
  super.onResume();
  everyFiveSeconds.run();
}",0.7902439024390244
8058,"void onListItemClick(SimpleListFragment fragment,int position){
  if (fragment == middleFragment) {
    ((Button)root.getRightView()).setText(middleContents.get(position));
    root.hideLeft();
    isLeftShowing=false;
  }
 else {
    middleContents=new ArrayList<String>();
    for (int i=0; i < 20; i++) {
      middleContents.add(items[position] + ""String_Node_Str"" + i);
    }
    if (getFragmentManager().findFragmentById(R.id.middle) == null) {
      middleFragment=SimpleListFragment.newInstance(middleContents);
      getFragmentManager().beginTransaction().add(R.id.middle,middleFragment).commit();
    }
 else {
      middleFragment.setContents(middleContents);
    }
  }
}","void onListItemClick(SimpleListFragment fragment,int position){
  if (fragment == middleFragment) {
    ((Button)root.getRightView()).setText(middleContents.get(position));
    if (isLeftShowing) {
      root.hideLeft();
      isLeftShowing=false;
    }
  }
 else {
    middleContents=new ArrayList<String>();
    for (int i=0; i < 20; i++) {
      middleContents.add(items[position] + ""String_Node_Str"" + i);
    }
    if (getFragmentManager().findFragmentById(R.id.middle) == null) {
      middleFragment=SimpleListFragment.newInstance(middleContents);
      getFragmentManager().beginTransaction().add(R.id.middle,middleFragment).commit();
    }
 else {
      middleFragment.setContents(middleContents);
    }
  }
}",0.9450392576730906
8059,"void onListItemClick(SimpleListFragment fragment,int position){
  if (fragment == middleFragment) {
    ((Button)root.getRightView()).setText(middleContents.get(position));
    root.hideLeft();
    isLeftShowing=false;
  }
 else {
    middleContents=new ArrayList<String>();
    for (int i=0; i < 20; i++) {
      middleContents.add(items[position] + ""String_Node_Str"" + i);
    }
    if (getSupportFragmentManager().findFragmentById(R.id.middle) == null) {
      middleFragment=SimpleListFragment.newInstance(middleContents);
      getSupportFragmentManager().beginTransaction().add(R.id.middle,middleFragment).commit();
    }
 else {
      middleFragment.setContents(middleContents);
    }
  }
}","void onListItemClick(SimpleListFragment fragment,int position){
  if (fragment == middleFragment) {
    ((Button)root.getRightView()).setText(middleContents.get(position));
    if (isLeftShowing) {
      root.hideLeft();
      isLeftShowing=false;
    }
  }
 else {
    middleContents=new ArrayList<String>();
    for (int i=0; i < 20; i++) {
      middleContents.add(items[position] + ""String_Node_Str"" + i);
    }
    if (getSupportFragmentManager().findFragmentById(R.id.middle) == null) {
      middleFragment=SimpleListFragment.newInstance(middleContents);
      getSupportFragmentManager().beginTransaction().add(R.id.middle,middleFragment).commit();
    }
 else {
      middleFragment.setContents(middleContents);
    }
  }
}",0.9685094471658502
8060,"@Override public void onReceive(Context ctxt,Intent i){
  File update=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),DownloadCheckService.UPDATE_FILENAME);
  if (update.exists()) {
    ctxt.startService(new Intent(ctxt,DownloadInstallService.class));
  }
}","@Override public void onReceive(Context ctxt,Intent i){
  File update=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),DownloadCheckService.UPDATE_FILENAME);
  if (update.exists()) {
    WakefulIntentService.sendWakefulWork(ctxt,DownloadInstallService.class);
  }
}",0.7820299500831946
8061,"@Override public void onReceive(Context ctxt,Intent i){
  File update=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),DownloadCheckService.UPDATE_FILENAME);
  if (update.exists()) {
    ctxt.startService(new Intent(ctxt,DownloadInstallService.class));
  }
}","@Override public void onReceive(Context ctxt,Intent i){
  File update=new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),DownloadCheckService.UPDATE_FILENAME);
  if (update.exists()) {
    WakefulIntentService.sendWakefulWork(ctxt,DownloadInstallService.class);
  }
}",0.7820299500831946
8062,"@Override public void onCountrySelected(Country c){
  String url=getString(c.url);
  if (details != null) {
    details.loadUrl(url);
  }
 else {
    Intent i=new Intent(this,DetailsActivity.class);
    i.putExtra(DetailsActivity.EXTRA_URL,url);
    startActivity(i);
  }
}","@Override public void onCountrySelected(Country c){
  String url=getString(c.url);
  if (details != null && details.isVisible()) {
    details.loadUrl(url);
  }
 else {
    Intent i=new Intent(this,DetailsActivity.class);
    i.putExtra(DetailsActivity.EXTRA_URL,url);
    startActivity(i);
  }
}",0.9595782073813708
8063,"@Override public void onResume(){
  super.onResume();
  if (details != null) {
    countries.enablePersistentSelection();
  }
}","@Override public void onResume(){
  super.onResume();
  countries.setPersistentSelection(details != null && details.isVisible());
}",0.7054263565891473
8064,"@Override public void onTabUnselected(android.app.ActionBar.Tab tab,android.app.FragmentTransaction ft){
  mTabListener.onTabUnselected(this,ft != null ? getActiveTransaction() : null);
}","@Override public void onTabUnselected(android.app.ActionBar.Tab tab,android.app.FragmentTransaction ft){
  mTabListener.onTabUnselected(this,ft != null ? getActiveTransaction() : null);
  commitActiveTransaction();
}",0.9280397022332506
8065,"@Override public void onDestroyActionMode(ActionMode mode){
  mWrapped.onDestroyActionMode(mode);
  mChoiceActionMode=null;
  clearChoices();
  updateOnScreenCheckedViews();
  setLongClickable(true);
}","@SuppressLint(""String_Node_Str"") @Override public void onDestroyActionMode(ActionMode mode){
  mWrapped.onDestroyActionMode(mode);
  mChoiceActionMode=null;
  clearChoices();
  updateOnScreenCheckedViews();
  setLongClickable(true);
}",0.9241379310344828
8066,"@SuppressLint(""String_Node_Str"") public GridView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  if (context instanceof Activity) {
    setActivity((Activity)context);
  }
  if (HoloEverywhere.DISABLE_OVERSCROLL_EFFECT && VERSION.SDK_INT >= 9) {
    setOverScrollMode(OVER_SCROLL_NEVER);
  }
  mOnItemLongClickListenerWrapper=new OnItemLongClickListenerWrapper();
  super.setOnItemLongClickListener(mOnItemLongClickListenerWrapper);
  setLongClickable(false);
  if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
    super.setFastScrollAlwaysVisible(false);
  }
  super.setFastScrollEnabled(false);
  super.setChoiceMode(CHOICE_MODE_NONE);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.AbsListView,defStyle,R.style.Holo_ListView);
  setFastScrollEnabled(a.getBoolean(R.styleable.AbsListView_android_fastScrollEnabled,false));
  setFastScrollAlwaysVisible(a.getBoolean(R.styleable.AbsListView_android_fastScrollAlwaysVisible,false));
  setChoiceMode(a.getInt(R.styleable.AbsListView_android_choiceMode,CHOICE_MODE_NONE));
  a.recycle();
}","@SuppressLint(""String_Node_Str"") public GridView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  if (context instanceof Activity) {
    setActivity((Activity)context);
  }
  if (HoloEverywhere.DISABLE_OVERSCROLL_EFFECT && VERSION.SDK_INT >= 9) {
    setOverScrollMode(OVER_SCROLL_NEVER);
  }
  mOnItemLongClickListenerWrapper=new OnItemLongClickListenerWrapper();
  super.setOnItemLongClickListener(mOnItemLongClickListenerWrapper);
  setLongClickable(false);
  if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
    super.setFastScrollAlwaysVisible(false);
    super.setChoiceMode(CHOICE_MODE_NONE);
  }
  super.setFastScrollEnabled(false);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.AbsListView,defStyle,R.style.Holo_ListView);
  setFastScrollEnabled(a.getBoolean(R.styleable.AbsListView_android_fastScrollEnabled,false));
  setFastScrollAlwaysVisible(a.getBoolean(R.styleable.AbsListView_android_fastScrollAlwaysVisible,false));
  setChoiceMode(a.getInt(R.styleable.AbsListView_android_choiceMode,CHOICE_MODE_NONE));
  a.recycle();
}",0.9615384615384616
8067,"@SuppressWarnings(""String_Node_Str"") public static final <T extends DialogFragment>T findInstance(Activity activity,Class<T> clazz,boolean makeIfNeed){
  if (activity == null || clazz == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  FragmentManager ft=activity.getSupportFragmentManager();
  T fragment;
  final String tag=makeTag(clazz);
  try {
    fragment=(T)ft.findFragmentByTag(tag);
    if (fragment == null && makeIfNeed) {
      fragment=Fragment.instantiate(clazz);
      ft.putFragment(fragment.getArguments(),tag,fragment);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return fragment;
}","@SuppressWarnings(""String_Node_Str"") public static final <T extends DialogFragment>T findInstance(FragmentManager fm,Class<T> clazz,boolean makeIfNeed){
  T fragment;
  final String tag=makeTag(clazz);
  try {
    fragment=(T)fm.findFragmentByTag(tag);
    if (fragment == null && makeIfNeed) {
      fragment=Fragment.instantiate(clazz);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  return fragment;
}",0.3321492007104796
8068,"@Override public void onCreate(Bundle savedInstanceState){
  mEventManager.fire(new OnCreateEvent(savedInstanceState));
}","@Override public void onCreate(Bundle savedInstanceState){
  RoboGuice.getInjector(getFragment().getActivity()).injectMembersWithoutViews(getFragment());
}",0.5797101449275363
8069,"protected void onInit(Holo config,Bundle savedInstanceState){
  if (mWasInited) {
    return;
  }
  mWasInited=true;
  if (config == null) {
    config=createConfig(savedInstanceState);
  }
  if (config == null) {
    config=Holo.defaultConfig();
  }
  if (!config.ignoreApplicationInstanceCheck && !(getApplication() instanceof Application)) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (config.addFactoryToInflater) {
    getLayoutInflater().setFactory(this);
  }
  if (this instanceof Activity) {
    Activity activity=(Activity)this;
    if (config.requireRoboguice) {
      activity.requireAddon(Activity.ADDON_ROBOGUICE);
    }
    if (config.requireSlidingMenu) {
      activity.requireAddon(Activity.ADDON_SLIDING_MENU);
    }
    if (config.requireSherlock) {
      activity.requireSherlock();
    }
    final SparseIntArray windowFeatures=config.windowFeatures;
    if (windowFeatures != null) {
      for (int i=0; i < windowFeatures.size(); i++) {
        if (windowFeatures.valueAt(i) > 0) {
          requestWindowFeature((long)windowFeatures.keyAt(i));
        }
      }
    }
    boolean forceThemeApply=isForceThemeApply();
    if (config.forceThemeApply) {
      setForceThemeApply(forceThemeApply=true);
    }
    if (mLastThemeResourceId == 0) {
      forceThemeApply=true;
    }
    ThemeManager.applyTheme(activity,forceThemeApply);
    if (!config.ignoreThemeCheck && ThemeManager.getThemeType(this) == ThemeManager.INVALID) {
      throw new HoloThemeException(activity);
    }
  }
  onPostInit(config,savedInstanceState);
}","protected void onInit(Holo config,Bundle savedInstanceState){
  if (mWasInited) {
    return;
  }
  mWasInited=true;
  if (config == null) {
    config=createConfig(savedInstanceState);
  }
  if (config == null) {
    config=Holo.defaultConfig();
  }
  onPreInit(config,savedInstanceState);
  if (!config.ignoreApplicationInstanceCheck && !(getApplication() instanceof Application)) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  if (config.addFactoryToInflater) {
    getLayoutInflater().setFactory(this);
  }
  if (this instanceof Activity) {
    Activity activity=(Activity)this;
    if (config.requireRoboguice) {
      activity.requireAddon(Activity.ADDON_ROBOGUICE);
    }
    if (config.requireSlidingMenu) {
      activity.requireAddon(Activity.ADDON_SLIDING_MENU);
    }
    if (config.requireSherlock) {
      activity.requireSherlock();
    }
    final SparseIntArray windowFeatures=config.windowFeatures;
    if (windowFeatures != null) {
      for (int i=0; i < windowFeatures.size(); i++) {
        if (windowFeatures.valueAt(i) > 0) {
          requestWindowFeature((long)windowFeatures.keyAt(i));
        }
      }
    }
    boolean forceThemeApply=isForceThemeApply();
    if (config.forceThemeApply) {
      setForceThemeApply(forceThemeApply=true);
    }
    if (mLastThemeResourceId == 0) {
      forceThemeApply=true;
    }
    ThemeManager.applyTheme(activity,forceThemeApply);
    if (!config.ignoreThemeCheck && ThemeManager.getThemeType(this) == ThemeManager.INVALID) {
      throw new HoloThemeException(activity);
    }
  }
  onPostInit(config,savedInstanceState);
}",0.9877300613496932
8070,"@Override public void setFactory(Factory factory){
  if (factorySet) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  addFactory(factory);
  factorySet=true;
}","@Override public void setFactory(Factory factory){
  if (factorySet) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  addFactory(factory,0);
  factorySet=true;
}",0.9942857142857144
8071,"@Override public View prepareDecorView(View v){
  v=FontLoader.apply(v);
  if (!getConfig().isDisableContextMenu() && v != null) {
    v=new ContextMenuDecorView(this,v,this);
  }
  return v;
}","@Override public View prepareDecorView(View v){
  return ContextMenuDecorView.prepareDecorView(this,v,this,0);
}",0.5967213114754099
8072,"@Override public void setContentView(View view,LayoutParams params){
  super.setContentView(FontLoader.apply(view),params);
}","@Override public void setContentView(View view,LayoutParams params){
  super.setContentView(prepareDecorView(view),params);
}",0.888
8073,"@Override public void addContentView(View view,LayoutParams params){
  super.addContentView(FontLoader.apply(view),params);
}","@Override public void addContentView(View view,LayoutParams params){
  super.addContentView(prepareDecorView(view),params);
}",0.888
8074,"protected View prepareDecorView(View v){
  v=FontLoader.apply(v);
  if (!mBase.getConfig().isDisableContextMenu() && v != null) {
    v=new ContextMenuDecorView(getSupportActivity(),v,this);
    v.setId(INTERNAL_DECOR_VIEW_ID);
  }
  return v;
}","protected View prepareDecorView(View v){
  return ContextMenuDecorView.prepareDecorView(getSupportActivity(),v,this,INTERNAL_DECOR_VIEW_ID);
}",0.6304909560723514
8075,"public final void reset(){
  this.lineBufferIdx=0;
}","public final void reset(){
  this.lineBufferIdx=0;
  this.readCR=false;
}",0.832
8076,"public String readLine(ByteBuffer buffer) throws LineTooLargeException {
  byte b;
  boolean more=true;
  while (buffer.hasRemaining() && more) {
    b=buffer.get();
    if (b == CR) {
      if (buffer.hasRemaining() && buffer.get() == LF) {
        more=false;
      }
    }
 else     if (b == LF) {
      more=false;
    }
 else {
      if (lineBufferIdx == maxLine - 2) {
        throw new LineTooLargeException(""String_Node_Str"" + maxLine);
      }
      if (lineBufferIdx == lineBuffer.length) {
        lineBuffer=Arrays.copyOf(lineBuffer,lineBuffer.length * 2);
      }
      lineBuffer[lineBufferIdx]=b;
      ++lineBufferIdx;
    }
  }
  String line=null;
  if (!more) {
    line=new String(lineBuffer,0,lineBufferIdx);
    lineBufferIdx=0;
  }
  return line;
}","public String readLine(ByteBuffer buffer) throws LineTooLargeException, ProtocolException {
  byte b;
  boolean more=true;
  while (buffer.hasRemaining() && more) {
    b=buffer.get();
    if (readCR && b != LF) {
      throw new ProtocolException(""String_Node_Str"" + b);
    }
    if (b == CR) {
      readCR=true;
    }
 else     if (b == LF) {
      more=false;
    }
 else {
      if (lineBufferIdx == maxLine - 2) {
        throw new LineTooLargeException(""String_Node_Str"" + maxLine);
      }
      if (lineBufferIdx == lineBuffer.length) {
        lineBuffer=Arrays.copyOf(lineBuffer,lineBuffer.length * 2);
      }
      lineBuffer[lineBufferIdx]=b;
      ++lineBufferIdx;
    }
  }
  String line=null;
  if (!more) {
    line=new String(lineBuffer,0,lineBufferIdx);
    reset();
  }
  return line;
}",0.8694550063371356
8077,"private void readHeaders(ByteBuffer buffer) throws LineTooLargeException, AbortException {
  String line=lineReader.readLine(buffer);
  while (line != null && !line.isEmpty()) {
    HttpUtils.splitAndAddHeader(line,headers);
    line=lineReader.readLine(buffer);
  }
  if (line == null)   return;
  listener.onHeadersReceived(headers);
  if (method == HttpMethod.HEAD) {
    state=ALL_READ;
    return;
  }
  String te=HttpUtils.getStringValue(headers,TRANSFER_ENCODING);
  if (CHUNKED.equals(te)) {
    state=READ_CHUNK_SIZE;
  }
 else {
    String cl=HttpUtils.getStringValue(headers,CONTENT_LENGTH);
    if (cl != null) {
      readRemaining=Integer.parseInt(cl);
      if (readRemaining == 0) {
        state=ALL_READ;
      }
 else {
        state=READ_FIXED_LENGTH_CONTENT;
      }
    }
 else     if (emptyBodyExpected) {
      state=ALL_READ;
    }
 else {
      state=READ_VARIABLE_LENGTH_CONTENT;
      readRemaining=Integer.MAX_VALUE;
    }
  }
}","private void readHeaders(ByteBuffer buffer) throws LineTooLargeException, AbortException, ProtocolException {
  String line=lineReader.readLine(buffer);
  while (line != null && !line.isEmpty()) {
    HttpUtils.splitAndAddHeader(line,headers);
    line=lineReader.readLine(buffer);
  }
  if (line == null)   return;
  listener.onHeadersReceived(headers);
  if (method == HttpMethod.HEAD) {
    state=ALL_READ;
    return;
  }
  String te=HttpUtils.getStringValue(headers,TRANSFER_ENCODING);
  if (CHUNKED.equals(te)) {
    state=READ_CHUNK_SIZE;
  }
 else {
    String cl=HttpUtils.getStringValue(headers,CONTENT_LENGTH);
    if (cl != null) {
      readRemaining=Integer.parseInt(cl);
      if (readRemaining == 0) {
        state=ALL_READ;
      }
 else {
        state=READ_FIXED_LENGTH_CONTENT;
      }
    }
 else     if (emptyBodyExpected) {
      state=ALL_READ;
    }
 else {
      state=READ_VARIABLE_LENGTH_CONTENT;
      readRemaining=Integer.MAX_VALUE;
    }
  }
}",0.9901707190894982
8078,"void readEmptyLine(ByteBuffer buffer){
  byte b=buffer.get();
  if (b == CR && buffer.hasRemaining()) {
    buffer.get();
  }
}","private void readEmptyLine(ByteBuffer buffer,State nextState) throws ProtocolException, LineTooLargeException {
  String line=lineReader.readLine(buffer);
  if (line != null) {
    if (line.isEmpty()) {
      state=nextState;
    }
 else {
      throw new ProtocolException(""String_Node_Str"" + line);
    }
  }
}",0.2687927107061503
8079,"public State decode(ByteBuffer buffer) throws LineTooLargeException, ProtocolException, AbortException {
  String line;
  while (buffer.hasRemaining() && state != State.ALL_READ) {
switch (state) {
case READ_INITIAL:
      if ((line=lineReader.readLine(buffer)) != null) {
        parseInitialLine(line);
      }
    break;
case READ_HEADER:
  readHeaders(buffer);
break;
case READ_CHUNK_SIZE:
line=lineReader.readLine(buffer);
if (line != null && !line.isEmpty()) {
readRemaining=getChunkSize(line);
if (readRemaining == 0) {
state=READ_CHUNK_FOOTER;
}
 else {
state=READ_CHUNKED_CONTENT;
}
}
break;
case READ_FIXED_LENGTH_CONTENT:
readBody(buffer,ALL_READ);
break;
case READ_CHUNKED_CONTENT:
readBody(buffer,READ_CHUNK_DELIMITER);
break;
case READ_CHUNK_FOOTER:
readEmptyLine(buffer);
state=ALL_READ;
break;
case READ_CHUNK_DELIMITER:
readEmptyLine(buffer);
state=READ_CHUNK_SIZE;
break;
case READ_VARIABLE_LENGTH_CONTENT:
readBody(buffer,null);
break;
}
}
return state;
}","public State decode(ByteBuffer buffer) throws LineTooLargeException, ProtocolException, AbortException {
  String line;
  while (buffer.hasRemaining() && state != State.ALL_READ) {
switch (state) {
case READ_INITIAL:
      if ((line=lineReader.readLine(buffer)) != null) {
        parseInitialLine(line);
      }
    break;
case READ_HEADER:
  readHeaders(buffer);
break;
case READ_CHUNK_SIZE:
line=lineReader.readLine(buffer);
if (line != null && !line.isEmpty()) {
readRemaining=getChunkSize(line);
if (readRemaining == 0) {
state=READ_CHUNK_FOOTER;
}
 else {
state=READ_CHUNKED_CONTENT;
}
}
break;
case READ_FIXED_LENGTH_CONTENT:
readBody(buffer,ALL_READ);
break;
case READ_CHUNKED_CONTENT:
readBody(buffer,READ_CHUNK_DELIMITER);
break;
case READ_CHUNK_FOOTER:
readEmptyLine(buffer,ALL_READ);
break;
case READ_CHUNK_DELIMITER:
readEmptyLine(buffer,READ_CHUNK_SIZE);
break;
case READ_VARIABLE_LENGTH_CONTENT:
readBody(buffer,null);
break;
}
}
return state;
}",0.9803516028955532
8080,"private void doRead(SelectionKey key,long now){
  Request req=(Request)key.attachment();
  SocketChannel ch=(SocketChannel)key.channel();
  int read=0;
  try {
    buffer.clear();
    if (req instanceof HttpsRequest) {
      HttpsRequest httpsReq=(HttpsRequest)req;
      if (httpsReq.handshaken) {
        read=httpsReq.unwrapRead(buffer);
      }
 else {
        read=httpsReq.doHandshake(buffer);
      }
    }
 else {
      read=ch.read(buffer);
    }
  }
 catch (  IOException e) {
    if (!cleanAndRetryIfBroken(key,req)) {
      req.finish(e);
    }
  }
catch (  Exception e) {
    req.finish(e);
  }
  if (read == -1) {
    if (!cleanAndRetryIfBroken(key,req)) {
      req.finish();
    }
  }
 else   if (read > 0) {
    req.onProgress(now);
    buffer.flip();
    try {
      if (req.decoder.decode(buffer) == ALL_READ) {
        req.finish();
        if (req.cfg.keepAlive > 0) {
          keepalives.offer(new PersistentConn(now + req.cfg.keepAlive,req.addr,key));
        }
 else {
          closeQuietly(key);
        }
      }
    }
 catch (    HTTPException e) {
      closeQuietly(key);
      req.finish(e);
    }
catch (    Exception e) {
      closeQuietly(key);
      req.finish(e);
      errorLogger.log(""String_Node_Str"",e);
      eventLogger.log(eventNames.clientImpossible);
    }
  }
}","private void doRead(SelectionKey key,long now){
  Request req=(Request)key.attachment();
  SocketChannel ch=(SocketChannel)key.channel();
  int read=0;
  try {
    buffer.clear();
    if (req instanceof HttpsRequest) {
      HttpsRequest httpsReq=(HttpsRequest)req;
      if (httpsReq.handshaken) {
        read=httpsReq.unwrapRead(buffer);
      }
 else {
        read=httpsReq.doHandshake(buffer);
      }
    }
 else {
      read=ch.read(buffer);
    }
  }
 catch (  IOException e) {
    if (!cleanAndRetryIfBroken(key,req)) {
      req.finish(e);
    }
  }
catch (  Exception e) {
    req.finish(e);
  }
  if (read == -1) {
    if (!cleanAndRetryIfBroken(key,req)) {
      req.finish();
    }
  }
 else   if (read > 0) {
    req.onProgress(now);
    buffer.flip();
    try {
      State oldState=req.decoder.state;
      if (req.decoder.decode(buffer) == ALL_READ) {
        req.finish();
        if (req.cfg.keepAlive > 0) {
          if (oldState != ALL_READ) {
            keepalives.offer(new PersistentConn(now + req.cfg.keepAlive,req.addr,key));
          }
        }
 else {
          closeQuietly(key);
        }
      }
    }
 catch (    HTTPException e) {
      closeQuietly(key);
      req.finish(e);
    }
catch (    Exception e) {
      closeQuietly(key);
      req.finish(e);
      errorLogger.log(""String_Node_Str"",e);
      eventLogger.log(eventNames.clientImpossible);
    }
  }
}",0.9660516605166052
8081,"private void decodeWs(WsAtta atta,SelectionKey key){
  try {
    do {
      Frame frame=atta.decoder.decode(buffer);
      if (frame instanceof TextFrame || frame instanceof BinaryFrame) {
        handler.handle(atta.channel,frame);
        atta.decoder.reset();
      }
 else       if (frame instanceof PingFrame) {
        atta.decoder.reset();
        tryWrite(key,WsEncode(WSDecoder.OPCODE_PONG,frame.data));
      }
 else       if (frame instanceof PongFrame) {
        atta.decoder.reset();
      }
 else       if (frame instanceof CloseFrame) {
        handler.clientClose(atta.channel,((CloseFrame)frame).getStatus());
        atta.keepalive=false;
        atta.decoder.reset();
        tryWrite(key,WsEncode(WSDecoder.OPCODE_CLOSE,frame.data));
      }
    }
 while (buffer.hasRemaining());
  }
 catch (  ProtocolException e) {
    System.err.printf(""String_Node_Str"",new Date(),THREAD_NAME,e.getMessage());
    closeKey(key,CLOSE_MESG_BIG);
  }
}","private void decodeWs(WsAtta atta,SelectionKey key){
  try {
    do {
      Frame frame=atta.decoder.decode(buffer);
      if (frame instanceof TextFrame || frame instanceof BinaryFrame) {
        handler.handle(atta.channel,frame);
        atta.decoder.reset();
      }
 else       if (frame instanceof PingFrame) {
        atta.decoder.reset();
        tryWrite(key,WsEncode(WSDecoder.OPCODE_PONG,frame.data));
      }
 else       if (frame instanceof PongFrame) {
        atta.decoder.reset();
      }
 else       if (frame instanceof CloseFrame) {
        boolean closed=atta.channel.isClosed();
        handler.clientClose(atta.channel,((CloseFrame)frame).getStatus());
        atta.keepalive=false;
        atta.decoder.reset();
        if (!closed) {
          tryWrite(key,WsEncode(WSDecoder.OPCODE_CLOSE,frame.data));
        }
      }
    }
 while (buffer.hasRemaining());
  }
 catch (  ProtocolException e) {
    System.err.printf(""String_Node_Str"",new Date(),THREAD_NAME,e.getMessage());
    closeKey(key,CLOSE_MESG_BIG);
  }
}",0.9403508771929824
8082,"public static void splitAndAddHeader(String sb,Map<String,Object> headers){
  final int length=sb.length();
  int nameStart;
  int nameEnd;
  int colonEnd;
  int valueStart;
  int valueEnd;
  nameStart=findNonWhitespace(sb,0);
  for (nameEnd=nameStart; nameEnd < length; nameEnd++) {
    char ch=sb.charAt(nameEnd);
    if (ch == ':' || Character.isWhitespace(ch)) {
      break;
    }
  }
  for (colonEnd=nameEnd; colonEnd < length; colonEnd++) {
    if (sb.charAt(colonEnd) == ':') {
      colonEnd++;
      break;
    }
  }
  valueStart=findNonWhitespace(sb,colonEnd);
  valueEnd=findEndOfString(sb);
  String key=sb.substring(nameStart,nameEnd);
  if (valueStart > valueEnd) {
  }
 else {
    String value=sb.substring(valueStart,valueEnd);
    key=key.toLowerCase();
    Object v=headers.get(key);
    if (v == null) {
      headers.put(key,value);
    }
 else {
      if (v instanceof String) {
        headers.put(key,PersistentList.create(Arrays.asList((String)v,value)));
      }
 else {
        headers.put(key,((ISeq)v).cons(value));
      }
    }
  }
}","public static void splitAndAddHeader(String sb,Map<String,Object> headers){
  final int length=sb.length();
  int nameStart;
  int nameEnd;
  int colonEnd;
  int valueStart;
  int valueEnd;
  nameStart=findNonWhitespace(sb,0);
  for (nameEnd=nameStart; nameEnd < length; nameEnd++) {
    char ch=sb.charAt(nameEnd);
    if (ch == ':' || Character.isWhitespace(ch)) {
      break;
    }
  }
  for (colonEnd=nameEnd; colonEnd < length; colonEnd++) {
    if (sb.charAt(colonEnd) == ':') {
      colonEnd++;
      break;
    }
  }
  valueStart=findNonWhitespace(sb,colonEnd);
  valueEnd=findEndOfString(sb,valueStart);
  String key=sb.substring(nameStart,nameEnd);
  if (valueStart > valueEnd) {
  }
 else {
    String value=sb.substring(valueStart,valueEnd);
    key=key.toLowerCase();
    Object v=headers.get(key);
    if (v == null) {
      headers.put(key,value);
    }
 else {
      if (v instanceof String) {
        headers.put(key,PersistentList.create(Arrays.asList((String)v,value)));
      }
 else {
        headers.put(key,((ISeq)v).cons(value));
      }
    }
  }
}",0.9948574100046752
8083,"public static int findEndOfString(String sb){
  int result;
  for (result=sb.length(); result > 0; result--) {
    if (!isWhitespace(sb.charAt(result - 1))) {
      break;
    }
  }
  return result;
}","public static int findEndOfString(String sb,int offset){
  int result;
  for (result=sb.length(); result > offset; result--) {
    if (!isWhitespace(sb.charAt(result - 1))) {
      break;
    }
  }
  return result;
}",0.9567307692307692
8084,"private void parseInitialLine(String sb) throws ProtocolException, AbortException {
  int aStart;
  int aEnd;
  int bStart;
  int bEnd;
  int cStart;
  int cEnd;
  aStart=findNonWhitespace(sb,0);
  aEnd=findWhitespace(sb,aStart);
  bStart=findNonWhitespace(sb,aEnd);
  bEnd=findWhitespace(sb,bStart);
  cStart=findNonWhitespace(sb,bEnd);
  cEnd=findEndOfString(sb);
  if ((cStart < cEnd) || (cStart == cEnd && bStart < bEnd)) {
    try {
      int status=Integer.parseInt(sb.substring(bStart,bEnd));
      emptyBodyExpected=status / 100 == 1 || status == 204 || status == 304;
      HttpStatus s=HttpStatus.valueOf(status);
      HttpVersion version=HTTP_1_1;
      if (""String_Node_Str"".equals(sb.substring(aStart,aEnd))) {
        version=HTTP_1_0;
      }
      listener.onInitialLineReceived(version,s);
      state=READ_HEADER;
    }
 catch (    NumberFormatException e) {
      throw new ProtocolException(""String_Node_Str"" + sb);
    }
  }
 else {
    throw new ProtocolException(""String_Node_Str"" + sb);
  }
}","private void parseInitialLine(String sb) throws ProtocolException, AbortException {
  int aStart;
  int aEnd;
  int bStart;
  int bEnd;
  int cStart;
  int cEnd;
  aStart=findNonWhitespace(sb,0);
  aEnd=findWhitespace(sb,aStart);
  bStart=findNonWhitespace(sb,aEnd);
  bEnd=findWhitespace(sb,bStart);
  cStart=findNonWhitespace(sb,bEnd);
  cEnd=findEndOfString(sb,cStart);
  if ((cStart < cEnd) || (cStart == cEnd && bStart < bEnd)) {
    try {
      int status=Integer.parseInt(sb.substring(bStart,bEnd));
      emptyBodyExpected=status / 100 == 1 || status == 204 || status == 304;
      HttpStatus s=HttpStatus.valueOf(status);
      HttpVersion version=HTTP_1_1;
      if (""String_Node_Str"".equals(sb.substring(aStart,aEnd))) {
        version=HTTP_1_0;
      }
      listener.onInitialLineReceived(version,s);
      state=READ_HEADER;
    }
 catch (    NumberFormatException e) {
      throw new ProtocolException(""String_Node_Str"" + sb);
    }
  }
 else {
    throw new ProtocolException(""String_Node_Str"" + sb);
  }
}",0.9965703086722196
8085,"private void createRequest(String sb) throws ProtocolException {
  int aStart;
  int aEnd;
  int bStart;
  int bEnd;
  int cStart;
  int cEnd;
  aStart=findNonWhitespace(sb,0);
  aEnd=findWhitespace(sb,aStart);
  bStart=findNonWhitespace(sb,aEnd);
  bEnd=findWhitespace(sb,bStart);
  cStart=findNonWhitespace(sb,bEnd);
  cEnd=findEndOfString(sb);
  if (cStart < cEnd) {
    try {
      HttpMethod method=HttpMethod.valueOf(sb.substring(aStart,aEnd).toUpperCase());
      HttpVersion version=HTTP_1_1;
      if (""String_Node_Str"".equals(sb.substring(cStart,cEnd))) {
        version=HTTP_1_0;
      }
      request=new HttpRequest(method,sb.substring(bStart,bEnd),version);
    }
 catch (    Exception e) {
      throw new ProtocolException(""String_Node_Str"");
    }
  }
 else {
    throw new ProtocolException(""String_Node_Str"");
  }
}","private void createRequest(String sb) throws ProtocolException {
  int aStart;
  int aEnd;
  int bStart;
  int bEnd;
  int cStart;
  int cEnd;
  aStart=findNonWhitespace(sb,0);
  aEnd=findWhitespace(sb,aStart);
  bStart=findNonWhitespace(sb,aEnd);
  bEnd=findWhitespace(sb,bStart);
  cStart=findNonWhitespace(sb,bEnd);
  cEnd=findEndOfString(sb,cStart);
  if (cStart < cEnd) {
    try {
      HttpMethod method=HttpMethod.valueOf(sb.substring(aStart,aEnd).toUpperCase());
      HttpVersion version=HTTP_1_1;
      if (""String_Node_Str"".equals(sb.substring(cStart,cEnd))) {
        version=HTTP_1_0;
      }
      request=new HttpRequest(method,sb.substring(bStart,bEnd),version);
    }
 catch (    Exception e) {
      throw new ProtocolException(""String_Node_Str"");
    }
  }
 else {
    throw new ProtocolException(""String_Node_Str"");
  }
}",0.9958258795468098
8086,"private void doRead(SelectionKey key,long now){
  Request req=(Request)key.attachment();
  SocketChannel ch=(SocketChannel)key.channel();
  int read=0;
  boolean https=req instanceof HttpsRequest;
  try {
    if (https && !((HttpsRequest)req).handshaken) {
      buffer.clear();
      read=((HttpsRequest)req).doHandshake(buffer);
      return;
    }
 else     if (https) {
      buffer.clear();
      read=((HttpsRequest)req).unwrapRead(buffer);
    }
 else {
      buffer.clear();
      read=ch.read(buffer);
    }
  }
 catch (  IOException e) {
    if (!cleanAndRetryIfBroken(key,req)) {
      req.finish(e);
    }
  }
  if (read == -1) {
    if (!cleanAndRetryIfBroken(key,req)) {
      req.finish();
    }
  }
 else   if (read > 0) {
    req.onProgress(now);
    buffer.flip();
    try {
      if (req.decoder.decode(buffer) == ALL_READ) {
        req.finish();
        if (req.cfg.keepAlive > 0)         keepalives.offer(new PersistentConn(now + req.cfg.keepAlive,req.addr,key));
      }
    }
 catch (    HTTPException e) {
      closeQuietly(key);
      req.finish(e);
    }
catch (    Exception e) {
      closeQuietly(key);
      req.finish(e);
      HttpUtils.printError(""String_Node_Str"",e);
    }
  }
}","private void doRead(SelectionKey key,long now){
  Request req=(Request)key.attachment();
  SocketChannel ch=(SocketChannel)key.channel();
  int read=0;
  boolean https=req instanceof HttpsRequest;
  try {
    if (https && !((HttpsRequest)req).handshaken) {
      buffer.clear();
      read=((HttpsRequest)req).doHandshake(buffer);
      return;
    }
 else     if (https) {
      buffer.clear();
      read=((HttpsRequest)req).unwrapRead(buffer);
    }
 else {
      buffer.clear();
      read=ch.read(buffer);
    }
  }
 catch (  IOException e) {
    if (!cleanAndRetryIfBroken(key,req)) {
      req.finish(e);
    }
  }
catch (  Exception e) {
    req.finish(e);
  }
  if (read == -1) {
    if (!cleanAndRetryIfBroken(key,req)) {
      req.finish();
    }
  }
 else   if (read > 0) {
    req.onProgress(now);
    buffer.flip();
    try {
      if (req.decoder.decode(buffer) == ALL_READ) {
        req.finish();
        if (req.cfg.keepAlive > 0)         keepalives.offer(new PersistentConn(now + req.cfg.keepAlive,req.addr,key));
      }
    }
 catch (    HTTPException e) {
      closeQuietly(key);
      req.finish(e);
    }
catch (    Exception e) {
      closeQuietly(key);
      req.finish(e);
      HttpUtils.printError(""String_Node_Str"",e);
    }
  }
}",0.9810254339927332
8087,"/** 
 * tricky part <p/> http-kit think all connections are keep-alived (since some say it is, but actually is not). but, some are not, http-kit pick them out **after the fact** 1. the connection is resued 2. no data received
 */
private boolean cleanAndRetryIfBroken(SelectionKey key,Request req){
  closeQuietly(key);
  keepalives.remove(key);
  if (req.isReuseConn && req.decoder.state == READ_INITIAL) {
    for (    ByteBuffer b : req.request) {
      b.position(0);
    }
    req.isReuseConn=false;
    requests.remove(req);
    pending.offer(req);
    selector.wakeup();
    return true;
  }
  return false;
}","/** 
 * http-kit think all connections are keep-alived (since some say it is, but actually is not). but, some are not, http-kit pick them out after the fact <ol> <li>The connection is reused</li> <li>No data received</li> </ol>
 */
private boolean cleanAndRetryIfBroken(SelectionKey key,Request req){
  closeQuietly(key);
  keepalives.remove(key);
  if (req.isReuseConn && req.decoder.state == READ_INITIAL) {
    for (    ByteBuffer b : req.request) {
      b.position(0);
    }
    req.isReuseConn=false;
    requests.remove(req);
    pending.offer(req);
    selector.wakeup();
    return true;
  }
  return false;
}",0.6628849270664505
8088,"private void doWrite(SelectionKey key){
  Request req=(Request)key.attachment();
  SocketChannel ch=(SocketChannel)key.channel();
  boolean https=req instanceof HttpsRequest;
  try {
    if (https && !((HttpsRequest)req).handshaken) {
      buffer.clear();
      int b=((HttpsRequest)req).doHandshake(buffer);
    }
 else     if (https) {
      ((HttpsRequest)req).writeWrapped();
    }
 else {
      ByteBuffer[] request=req.request;
      ch.write(request);
      if (!request[request.length - 1].hasRemaining()) {
        key.interestOps(OP_READ);
      }
    }
  }
 catch (  IOException e) {
    if (!cleanAndRetryIfBroken(key,req)) {
      req.finish(e);
    }
  }
}","private void doWrite(SelectionKey key){
  Request req=(Request)key.attachment();
  SocketChannel ch=(SocketChannel)key.channel();
  boolean https=req instanceof HttpsRequest;
  try {
    if (https && !((HttpsRequest)req).handshaken) {
      buffer.clear();
      int b=((HttpsRequest)req).doHandshake(buffer);
    }
 else     if (https) {
      ((HttpsRequest)req).writeWrappedRequest();
    }
 else {
      ByteBuffer[] request=req.request;
      ch.write(request);
      if (!request[request.length - 1].hasRemaining()) {
        key.interestOps(OP_READ);
      }
    }
  }
 catch (  IOException e) {
    if (!cleanAndRetryIfBroken(key,req)) {
      req.finish(e);
    }
  }
}",0.994810971089696
8089,"final int unwrapRead(ByteBuffer peerAppData) throws IOException {
  int read=((SocketChannel)key.channel()).read(peerNetData);
  if (read > 0) {
    peerNetData.flip();
    read=0;
    SSLEngineResult res;
    while ((res=engine.unwrap(peerNetData,peerAppData)).getStatus() == Status.OK) {
      read+=res.bytesProduced();
      if (!peerNetData.hasRemaining())       break;
    }
    peerNetData.compact();
switch (res.getStatus()) {
case OK:
case BUFFER_UNDERFLOW:
      return read;
case CLOSED:
    return read > 0 ? read : -1;
case BUFFER_OVERFLOW:
  System.out.println(""String_Node_Str"");
return -1;
}
}
return read;
}","final int unwrapRead(ByteBuffer peerAppData) throws IOException {
  int read=((SocketChannel)key.channel()).read(peerNetData), unwrapped=0;
  if (read > 0) {
    peerNetData.flip();
    SSLEngineResult res;
    while ((res=engine.unwrap(peerNetData,peerAppData)).getStatus() == Status.OK) {
      unwrapped+=res.bytesProduced();
      if (!peerNetData.hasRemaining())       break;
    }
    peerNetData.compact();
switch (res.getStatus()) {
case OK:
case BUFFER_UNDERFLOW:
      return unwrapped;
case CLOSED:
    System.out.println(""String_Node_Str"" + unwrapped);
  return unwrapped > 0 ? unwrapped : -1;
case BUFFER_OVERFLOW:
System.out.println(""String_Node_Str"");
return -1;
}
return unwrapped;
}
 else {
return read;
}
}",0.8189910979228486
8090,"public void recycle(Request old) throws SSLException {
  super.recycle(old);
  this.engine=((HttpsRequest)old).engine;
  this.handshaken=true;
  wrap();
}","public void recycle(Request old) throws SSLException {
  super.recycle(old);
  this.engine=((HttpsRequest)old).engine;
  this.handshaken=true;
  wrapRequest();
}",0.9777777777777776
8091,"final int doHandshake(ByteBuffer peerAppData) throws IOException {
  SSLEngineResult.HandshakeStatus hs=engine.getHandshakeStatus();
  while (!handshaken) {
switch (hs) {
case NEED_TASK:
      Runnable runnable;
    while ((runnable=engine.getDelegatedTask()) != null) {
      runnable.run();
      log(""String_Node_Str"",runnable,engine.getHandshakeStatus());
    }
  break;
case NEED_UNWRAP:
int read=((SocketChannel)key.channel()).read(peerNetData);
log(""String_Node_Str"",read,""String_Node_Str"");
if (read < 0) {
log(""String_Node_Str"");
return -1;
}
 else {
peerNetData.flip();
SSLEngineResult res=engine.unwrap(peerNetData,peerAppData);
peerNetData.compact();
log(""String_Node_Str"",res);
switch (res.getStatus()) {
case BUFFER_OVERFLOW:
System.out.println(""String_Node_Str"");
break;
case CLOSED:
return -1;
case BUFFER_UNDERFLOW:
log(""String_Node_Str"");
return 0;
}
}
break;
case NEED_WRAP:
SSLEngineResult res=engine.wrap(EMPTY_BUFFER,myNetData);
log(""String_Node_Str"",res);
myNetData.flip();
((SocketChannel)key.channel()).write(myNetData);
if (myNetData.hasRemaining()) {
}
 else {
myNetData.clear();
if (res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_WRAP) key.interestOps(SelectionKey.OP_READ);
}
break;
}
hs=engine.getHandshakeStatus();
handshaken=hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING || hs == SSLEngineResult.HandshakeStatus.FINISHED;
log(""String_Node_Str"",hs,handshaken);
if (handshaken) {
wrap();
writeWrapped();
}
}
return 0;
}","final int doHandshake(ByteBuffer peerAppData) throws IOException {
  SSLEngineResult.HandshakeStatus hs=engine.getHandshakeStatus();
  while (!handshaken) {
switch (hs) {
case NEED_TASK:
      Runnable runnable;
    while ((runnable=engine.getDelegatedTask()) != null) {
      runnable.run();
      log(""String_Node_Str"",runnable,engine.getHandshakeStatus());
    }
  break;
case NEED_UNWRAP:
int read=((SocketChannel)key.channel()).read(peerNetData);
log(""String_Node_Str"",read,""String_Node_Str"");
if (read < 0) {
log(""String_Node_Str"");
return -1;
}
 else {
peerNetData.flip();
SSLEngineResult res=engine.unwrap(peerNetData,peerAppData);
peerNetData.compact();
log(""String_Node_Str"",res);
switch (res.getStatus()) {
case BUFFER_OVERFLOW:
System.out.println(""String_Node_Str"");
break;
case CLOSED:
return -1;
case BUFFER_UNDERFLOW:
log(""String_Node_Str"");
return 0;
}
}
break;
case NEED_WRAP:
SSLEngineResult res=engine.wrap(EMPTY_BUFFER,myNetData);
log(""String_Node_Str"",res);
myNetData.flip();
((SocketChannel)key.channel()).write(myNetData);
if (myNetData.hasRemaining()) {
}
 else {
myNetData.clear();
if (res.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NEED_WRAP) key.interestOps(SelectionKey.OP_READ);
}
break;
}
hs=engine.getHandshakeStatus();
handshaken=hs == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING || hs == SSLEngineResult.HandshakeStatus.FINISHED;
log(""String_Node_Str"",hs,handshaken);
if (handshaken) {
wrapRequest();
writeWrappedRequest();
}
}
return 0;
}",0.99527665317139
8092,"public static void main(String[] args) throws IOException, InterruptedException {
  HttpClient client=new HttpClient();
  String[] urls=new String[]{""String_Node_Str"",""String_Node_Str""};
  ExecutorService pool=Executors.newCachedThreadPool();
  for (  String url : urls) {
    final CountDownLatch cd=new CountDownLatch(1);
    HttpRequestConfig cfg=new HttpRequestConfig(HttpMethod.GET,10000,-1,SslContextFactory.getClientContext().createSSLEngine());
    client.exec(url,new TreeMap<String,Object>(),null,cfg,new RespListener(new IResponseHandler(){
      public void onSuccess(      int status,      Map<String,String> headers,      Object body){
        int length=body instanceof String ? ((String)body).length() : ((BytesInputStream)body).available();
        logger.info(""String_Node_Str"",status,headers,length);
        cd.countDown();
      }
      public void onThrowable(      Throwable t){
        logger.error(""String_Node_Str"",t);
        cd.countDown();
      }
    }
,IFilter.ACCEPT_ALL,pool));
    cd.await();
  }
}","public static void main(String[] args) throws IOException, InterruptedException {
  HttpClient client=new HttpClient();
  String[] urls=new String[]{""String_Node_Str"",""String_Node_Str""};
  ExecutorService pool=Executors.newCachedThreadPool();
  for (  String url : urls) {
    final CountDownLatch cd=new CountDownLatch(1);
    SSLEngine engine=SslContextFactory.getClientContext().createSSLEngine();
    engine=null;
    HttpRequestConfig cfg=new HttpRequestConfig(HttpMethod.GET,10000,-1,engine);
    client.exec(url,new TreeMap<String,Object>(),null,cfg,new RespListener(new IResponseHandler(){
      public void onSuccess(      int status,      Map<String,String> headers,      Object body){
        int length=body instanceof String ? ((String)body).length() : ((BytesInputStream)body).available();
        logger.info(""String_Node_Str"",status,headers,length);
        cd.countDown();
      }
      public void onThrowable(      Throwable t){
        logger.error(""String_Node_Str"",t);
        cd.countDown();
      }
    }
,IFilter.ACCEPT_ALL,pool));
    cd.await();
  }
}",0.9270142180094788
8093,"private void readHeaders(ByteBuffer buffer) throws LineTooLargeException, RequestTooLargeException {
  String line=readLine(buffer);
  while (line != null && !line.isEmpty()) {
    splitAndAddHeader(line);
    line=readLine(buffer);
  }
  if (line == null) {
    return;
  }
  request.setHeaders(headers);
  String te=headers.get(TRANSFER_ENCODING);
  if (CHUNKED.equals(te)) {
    state=READ_CHUNK_SIZE;
  }
 else {
    String cl=headers.get(CONTENT_LENGTH);
    if (cl != null) {
      try {
        readRemaining=Integer.parseInt(cl);
        throwIfBodyIsTooLarge(readRemaining);
        content=new byte[readRemaining];
        state=READ_FIXED_LENGTH_CONTENT;
      }
 catch (      NumberFormatException e) {
        state=PROTOCOL_ERROR;
      }
    }
    state=ALL_READ;
  }
}","private void readHeaders(ByteBuffer buffer) throws LineTooLargeException, RequestTooLargeException {
  String line=readLine(buffer);
  while (line != null && !line.isEmpty()) {
    splitAndAddHeader(line);
    line=readLine(buffer);
  }
  if (line == null) {
    return;
  }
  request.setHeaders(headers);
  String te=headers.get(TRANSFER_ENCODING);
  if (CHUNKED.equals(te)) {
    state=READ_CHUNK_SIZE;
  }
 else {
    String cl=headers.get(CONTENT_LENGTH);
    if (cl != null) {
      try {
        readRemaining=Integer.parseInt(cl);
        throwIfBodyIsTooLarge(readRemaining);
        content=new byte[readRemaining];
        state=READ_FIXED_LENGTH_CONTENT;
      }
 catch (      NumberFormatException e) {
        state=PROTOCOL_ERROR;
      }
    }
 else {
      state=ALL_READ;
    }
  }
}",0.98989898989899
8094,"public String getContentType(){
  return null;
}","public String getContentType(){
  return headers.get(CONTENT_TYPE);
}",0.7521367521367521
8095,"/** 
 * Configure subscribers.
 * @param listeners
 */
public void setSubscribers(Map<MetaqTopic,? extends DefaultMessageListener<?>> subscribers){
  this.subscribers=subscribers;
}","/** 
 * Configure subscribers.
 * @param listeners
 */
@SuppressWarnings(""String_Node_Str"") public void setSubscribers(Map subscribers){
  this.subscribers=subscribers;
}",0.7578347578347578
8096,"/** 
 * �����Ƿ���Ҫ���������Ĵ���
 * @param request
 * @param it
 * @param listener
 * @param partition
 * @return
 */
private boolean processReceiveMessage(final FetchRequest request,final MessageIterator it,final MessageListener listener,final ConsumerMessageFilter filter,final Partition partition,final String group){
  int count=0;
  List<Long> inTransactionMsgIds=new ArrayList<Long>();
  while (it.hasNext()) {
    final int prevOffset=it.getOffset();
    try {
      final Message msg=it.next();
      if (this.isProcessed(msg)) {
        continue;
      }
      MessageAccessor.setPartition(msg,partition);
      boolean accept=this.isAcceptable(request,filter,group,msg);
      if (accept) {
        currentTopicRegInfo.set(request.getTopicPartitionRegInfo().clone(it));
        try {
          listener.recieveMessages(msg);
        }
  finally {
          currentTopicRegInfo.remove();
        }
      }
      if (MessageAccessor.isRollbackOnly(msg)) {
        it.setOffset(prevOffset);
        break;
      }
      if (partition.isAutoAck()) {
        count++;
        this.markProcessed(msg.getId());
      }
 else {
        if (partition.isAcked()) {
          count++;
          for (          Long msgId : inTransactionMsgIds) {
            this.markProcessed(msgId);
          }
          this.markProcessed(msg.getId());
          break;
        }
 else         if (partition.isRollback()) {
          break;
        }
 else {
          inTransactionMsgIds.add(msg.getId());
          count++;
        }
      }
    }
 catch (    InterruptedException e) {
      it.setOffset(prevOffset);
      log.error(""String_Node_Str"" + request.getTopic() + ""String_Node_Str""+ request.getPartition(),e);
      break;
    }
catch (    final InvalidMessageException e) {
      MetaStatLog.addStat(null,StatConstants.INVALID_MSG_STAT,request.getTopic());
      this.getOffsetAddRequest(request,e);
      return true;
    }
catch (    final Throwable e) {
      it.setOffset(prevOffset);
      log.error(""String_Node_Str"" + request.getTopic() + ""String_Node_Str""+ request.getPartition(),e);
      break;
    }
  }
  MetaStatLog.addStatValue2(null,StatConstants.GET_MSG_COUNT_STAT,request.getTopic(),count);
  return false;
}","/** 
 * �����Ƿ���Ҫ���������Ĵ���
 * @param request
 * @param it
 * @param listener
 * @param partition
 * @return
 */
private boolean processReceiveMessage(final FetchRequest request,final MessageIterator it,final MessageListener listener,final ConsumerMessageFilter filter,final Partition partition,final String group){
  int count=0;
  List<Long> inTransactionMsgIds=new ArrayList<Long>();
  while (it.hasNext()) {
    final int prevOffset=it.getOffset();
    try {
      final Message msg=it.next();
      if (this.isProcessed(msg.getId(),group)) {
        continue;
      }
      MessageAccessor.setPartition(msg,partition);
      boolean accept=this.isAcceptable(request,filter,group,msg);
      if (accept) {
        currentTopicRegInfo.set(request.getTopicPartitionRegInfo().clone(it));
        try {
          listener.recieveMessages(msg);
        }
  finally {
          currentTopicRegInfo.remove();
        }
      }
      if (MessageAccessor.isRollbackOnly(msg)) {
        it.setOffset(prevOffset);
        break;
      }
      if (partition.isAutoAck()) {
        count++;
        this.markProcessed(msg.getId(),group);
      }
 else {
        if (partition.isAcked()) {
          count++;
          for (          Long msgId : inTransactionMsgIds) {
            this.markProcessed(msgId,group);
          }
          this.markProcessed(msg.getId(),group);
          break;
        }
 else         if (partition.isRollback()) {
          break;
        }
 else {
          inTransactionMsgIds.add(msg.getId());
          count++;
        }
      }
    }
 catch (    InterruptedException e) {
      it.setOffset(prevOffset);
      log.error(""String_Node_Str"" + request.getTopic() + ""String_Node_Str""+ request.getPartition(),e);
      break;
    }
catch (    final InvalidMessageException e) {
      MetaStatLog.addStat(null,StatConstants.INVALID_MSG_STAT,request.getTopic());
      this.getOffsetAddRequest(request,e);
      return true;
    }
catch (    final Throwable e) {
      it.setOffset(prevOffset);
      log.error(""String_Node_Str"" + request.getTopic() + ""String_Node_Str""+ request.getPartition(),e);
      break;
    }
  }
  MetaStatLog.addStatValue2(null,StatConstants.GET_MSG_COUNT_STAT,request.getTopic(),count);
  return false;
}",0.9928571428571428
8097,"private void markProcessed(final Long msgId){
  SimpleFetchManager.this.messageIdCache.put(msgId,PROCESSED);
}","private void markProcessed(final Long msgId,String group){
  SimpleFetchManager.this.messageIdCache.put(this.cacheKey(msgId,group),PROCESSED);
}",0.8661417322834646
8098,"private boolean isProcessed(final Message msg){
  return SimpleFetchManager.this.messageIdCache.get(msg.getId()) != null;
}","private boolean isProcessed(final Long id,String group){
  return SimpleFetchManager.this.messageIdCache.get(this.cacheKey(id,group)) != null;
}",0.8014981273408239
8099,"protected MessageConsumer getMessageConsumer(MetaqTopic topic) throws MetaClientException {
  if (this.shareConsumer) {
    if (this.sharedConsumer == null) {
      if (this.defaultTopic == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
synchronized (this) {
        if (this.sharedConsumer == null) {
          this.sharedConsumer=this.messageSessionFactory.createConsumer(this.defaultTopic.getConsumerConfig());
          if (!StringUtils.isBlank(this.defaultTopic.getTopic())) {
            this.sharedConsumer.subscribe(this.defaultTopic.getTopic(),this.defaultTopic.getMaxBufferSize(),this.defaultMessageListener);
          }
          this.consumers.add(this.sharedConsumer);
        }
      }
    }
    return this.sharedConsumer;
  }
 else {
    if (this.defaultMessageListener != null || this.defaultTopic != null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    MessageConsumer consumer=this.messageSessionFactory.createConsumer(topic.getConsumerConfig());
    this.consumers.add(consumer);
    return consumer;
  }
}","protected MessageConsumer getMessageConsumer(MetaqTopic topic) throws MetaClientException {
  MessageConsumer consumer=this.getMessageConsumer0(topic);
  if (this.rejectConsumptionHandler != null) {
    consumer.setRejectConsumptionHandler(this.rejectConsumptionHandler);
  }
  return consumer;
}",0.193033381712627
8100,"public LocalOffsetStorage(final String filePath) throws IOException {
  final File file=new File(filePath);
  if (file.exists()) {
    this.loadGroupInfo(file);
  }
 else {
    file.createNewFile();
  }
  this.channel=new RandomAccessFile(file,""String_Node_Str"").getChannel();
}","public LocalOffsetStorage(final String filePath) throws IOException {
  this.filePath=filePath;
  final File file=new File(filePath);
  if (file.exists()) {
    this.loadGroupInfo(file);
  }
 else {
    file.createNewFile();
  }
}",0.8031496062992126
8101,"@Override public void commitOffset(final String group,final Collection<TopicPartitionRegInfo> infoList){
  if (infoList == null || infoList.isEmpty()) {
    return;
  }
  this.groupInfoMap.put(group,(List<TopicPartitionRegInfo>)infoList);
  try {
    final String json=JSONUtils.serializeObject(this.groupInfoMap);
    this.channel.position(0);
    final ByteBuffer buf=ByteBuffer.wrap(json.getBytes());
    while (buf.hasRemaining()) {
      this.channel.write(buf);
    }
    this.channel.truncate(this.channel.position());
  }
 catch (  final Exception e) {
    log.error(""String_Node_Str"",e);
  }
}","@Override public void commitOffset(final String group,final Collection<TopicPartitionRegInfo> infoList){
  if (infoList == null || infoList.isEmpty()) {
    return;
  }
  this.groupInfoMap.put(group,(List<TopicPartitionRegInfo>)infoList);
  FileOutputStream out=null;
  FileChannel channel=null;
  try {
    final String json=JSONUtils.serializeObject(this.groupInfoMap);
    File tmpFile=new File(this.filePath + ""String_Node_Str"" + this.counter.incrementAndGet());
    out=new FileOutputStream(tmpFile);
    channel=out.getChannel();
    final ByteBuffer buf=ByteBuffer.wrap(json.getBytes());
    while (buf.hasRemaining()) {
      channel.write(buf);
    }
    this.close(channel);
    this.close(out);
synchronized (this) {
      if (!tmpFile.renameTo(new File(this.filePath))) {
        throw new IOException(""String_Node_Str"" + this.filePath);
      }
    }
  }
 catch (  final Exception e) {
    log.error(""String_Node_Str"",e);
  }
 finally {
    if (channel != null && channel.isOpen()) {
      this.close(channel);
    }
    this.close(out);
  }
}",0.594692400482509
8102,"@Override public void close(){
  this.close(this.channel);
}","@Override public void close(){
}",0.6956521739130435
8103,"public MetaMessageSessionFactory(final MetaClientConfig metaClientConfig) throws MetaClientException {
  super();
  this.checkConfig(metaClientConfig);
  this.metaClientConfig=metaClientConfig;
  final ClientConfig clientConfig=new ClientConfig();
  clientConfig.setTcpNoDelay(TCP_NO_DELAY);
  clientConfig.setMaxReconnectTimes(MAX_RECONNECT_TIMES);
  clientConfig.setWireFormatType(new MetamorphosisWireFormatType());
  clientConfig.setMaxScheduleWrittenBytes(MAX_SCHEDULE_WRITTEN_BYTES);
  try {
    this.remotingClient=new RemotingClientWrapper(RemotingFactory.connect(clientConfig));
  }
 catch (  final NotifyRemotingException e) {
    throw new NetworkException(""String_Node_Str"",e);
  }
  if (this.metaClientConfig.getServerUrl() != null) {
    this.connectServer(this.metaClientConfig);
  }
 else {
    this.initZooKeeper();
  }
  this.producerZooKeeper=new ProducerZooKeeper(this.metaZookeeper,this.remotingClient,this.zkClient,metaClientConfig);
  this.sessionIdGenerator=new IdGenerator();
  this.consumerZooKeeper=this.initConsumerZooKeeper(this.remotingClient,this.zkClient,this.zkConfig);
  this.zkClientChangedListeners.add(this.producerZooKeeper);
  this.zkClientChangedListeners.add(this.consumerZooKeeper);
  this.subscribeInfoManager=new SubscribeInfoManager();
  this.recoverManager=new RecoverStorageManager(this.metaClientConfig,this.subscribeInfoManager);
  this.shutdownHook=new Thread(){
    @Override public void run(){
      try {
        MetaMessageSessionFactory.this.isHutdownHookCalled=true;
        MetaMessageSessionFactory.this.shutdown();
      }
 catch (      final MetaClientException e) {
        log.error(""String_Node_Str"",e);
      }
    }
  }
;
  Runtime.getRuntime().addShutdownHook(this.shutdownHook);
}","public MetaMessageSessionFactory(final MetaClientConfig metaClientConfig) throws MetaClientException {
  super();
  try {
    this.checkConfig(metaClientConfig);
    this.metaClientConfig=metaClientConfig;
    final ClientConfig clientConfig=new ClientConfig();
    clientConfig.setTcpNoDelay(TCP_NO_DELAY);
    clientConfig.setMaxReconnectTimes(MAX_RECONNECT_TIMES);
    clientConfig.setWireFormatType(new MetamorphosisWireFormatType());
    clientConfig.setMaxScheduleWrittenBytes(MAX_SCHEDULE_WRITTEN_BYTES);
    try {
      this.remotingClient=new RemotingClientWrapper(RemotingFactory.connect(clientConfig));
    }
 catch (    final NotifyRemotingException e) {
      throw new NetworkException(""String_Node_Str"",e);
    }
    if (this.metaClientConfig.getServerUrl() != null) {
      this.connectServer(this.metaClientConfig);
    }
 else {
      this.initZooKeeper();
    }
    this.producerZooKeeper=new ProducerZooKeeper(this.metaZookeeper,this.remotingClient,this.zkClient,metaClientConfig);
    this.sessionIdGenerator=new IdGenerator();
    this.consumerZooKeeper=this.initConsumerZooKeeper(this.remotingClient,this.zkClient,this.zkConfig);
    this.zkClientChangedListeners.add(this.producerZooKeeper);
    this.zkClientChangedListeners.add(this.consumerZooKeeper);
    this.subscribeInfoManager=new SubscribeInfoManager();
    this.recoverManager=new RecoverStorageManager(this.metaClientConfig,this.subscribeInfoManager);
    this.shutdownHook=new Thread(){
      @Override public void run(){
        try {
          MetaMessageSessionFactory.this.isHutdownHookCalled=true;
          MetaMessageSessionFactory.this.shutdown();
        }
 catch (        final MetaClientException e) {
          log.error(""String_Node_Str"",e);
        }
      }
    }
;
    Runtime.getRuntime().addShutdownHook(this.shutdownHook);
  }
 catch (  MetaClientException e) {
    this.shutdown();
    throw e;
  }
catch (  Exception e) {
    this.shutdown();
    throw new MetaClientException(""String_Node_Str"",e);
  }
}",0.9297498669505057
8104,"@Override public void shutdown() throws MetaClientException {
  if (this.shutdown) {
    return;
  }
  this.shutdown=true;
  this.recoverManager.shutdown();
  for (  final Shutdownable child : this.children) {
    child.shutdown();
  }
  try {
    this.remotingClient.stop();
  }
 catch (  final NotifyRemotingException e) {
    throw new NetworkException(""String_Node_Str"",e);
  }
  if (this.zkClient != null) {
    this.zkClient.close();
  }
  if (!this.isHutdownHookCalled) {
    Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
  }
}","@Override public synchronized void shutdown() throws MetaClientException {
  if (this.shutdown) {
    return;
  }
  this.shutdown=true;
  if (this.recoverManager != null) {
    this.recoverManager.shutdown();
  }
  for (  final Shutdownable child : this.children) {
    if (child != null) {
      child.shutdown();
    }
  }
  try {
    if (this.remotingClient != null) {
      this.remotingClient.stop();
    }
  }
 catch (  final NotifyRemotingException e) {
    throw new NetworkException(""String_Node_Str"",e);
  }
  if (this.zkClient != null) {
    this.zkClient.close();
  }
  if (!this.isHutdownHookCalled && this.shutdownHook != null) {
    Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
  }
}",0.8691514670896114
8105,"protected String getConsumerUUID(final ConsumerConfig consumerConfig) throws Exception {
  String consumerUUID=null;
  if (consumerConfig.getConsumerId() != null) {
    consumerUUID=consumerConfig.getConsumerId();
  }
 else {
    consumerUUID=RemotingUtils.getLocalHost() + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str""+ this.counter.incrementAndGet();
  }
  return consumerUUID;
}","protected String getConsumerUUID(final ConsumerConfig consumerConfig) throws Exception {
  String consumerUUID=null;
  if (consumerConfig.getConsumerId() != null) {
    consumerUUID=consumerConfig.getConsumerId();
  }
 else {
    consumerUUID=RemotingUtils.getLocalHost() + ""String_Node_Str"" + this.getPid()+ ""String_Node_Str""+ System.currentTimeMillis()+ ""String_Node_Str""+ this.counter.incrementAndGet();
  }
  return consumerUUID;
}",0.9593301435406698
8106,"public MetaqMessage(Message rawMessage,T body){
  super();
  this.rawMessage=rawMessage;
  this.body=body;
}","public MetaqMessage(Message rawMessage,T body){
  super();
  if (rawMessage == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.rawMessage=rawMessage;
  this.body=body;
}",0.7035830618892508
8107,"protected String getConsumerUUID(final ConsumerConfig consumerConfig) throws Exception {
  String consumerUUID=null;
  if (consumerConfig.getConsumerId() != null) {
    consumerUUID=consumerConfig.getConsumerId();
  }
 else {
    consumerUUID=RemotingUtils.getLocalAddress() + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str""+ this.counter.incrementAndGet();
  }
  return consumerUUID;
}","protected String getConsumerUUID(final ConsumerConfig consumerConfig) throws Exception {
  String consumerUUID=null;
  if (consumerConfig.getConsumerId() != null) {
    consumerUUID=consumerConfig.getConsumerId();
  }
 else {
    consumerUUID=RemotingUtils.getLocalHost() + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str""+ this.counter.incrementAndGet();
  }
  return consumerUUID;
}",0.986335403726708
8108,"static ConsumerConfig updateGroupForBroadcast(final ConsumerConfig consumerConfig){
  try {
    consumerConfig.setGroup(consumerConfig.getGroup() + ""String_Node_Str"" + RemotingUtils.getLocalAddress().replaceAll(""String_Node_Str"",""String_Node_Str""));
    return consumerConfig;
  }
 catch (  final Exception e) {
    throw new InvalidConsumerConfigException(""String_Node_Str"",e);
  }
}","static ConsumerConfig updateGroupForBroadcast(final ConsumerConfig consumerConfig){
  try {
    consumerConfig.setGroup(consumerConfig.getGroup() + ""String_Node_Str"" + RemotingUtils.getLocalHost().replaceAll(""String_Node_Str"",""String_Node_Str""));
    return consumerConfig;
  }
 catch (  final Exception e) {
    throw new InvalidConsumerConfigException(""String_Node_Str"",e);
  }
}",0.9856209150326798
8109,"/** 
 * Construct an IdGenerator
 */
public IdGenerator(){
  try {
    this.seed=RemotingUtils.getLocalAddress() + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str"";
    this.length=this.seed.length() + (""String_Node_Str"" + Long.MAX_VALUE).length();
  }
 catch (  final Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Construct an IdGenerator
 */
public IdGenerator(){
  try {
    this.seed=RemotingUtils.getLocalHost() + ""String_Node_Str"" + System.currentTimeMillis()+ ""String_Node_Str"";
    this.length=this.seed.length() + (""String_Node_Str"" + Long.MAX_VALUE).length();
  }
 catch (  final Exception e) {
    throw new RuntimeException(e);
  }
}",0.98379970544919
8110,"public String getBrokerHostName() throws Exception {
  final String hostName=this.config.getHostName() == null ? RemotingUtils.getLocalAddress() : this.config.getHostName();
  return hostName;
}","public String getBrokerHostName() throws Exception {
  final String hostName=this.config.getHostName() == null ? RemotingUtils.getLocalHost() : this.config.getHostName();
  return hostName;
}",0.9766233766233766
8111,"@Test public void testRegisterBrokerInZk_slave() throws Exception {
  String path=""String_Node_Str"";
  this.createSlaveBrokerZooKeeper();
  assertFalse(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),path));
  this.slaveBrokerZooKeeper.registerBrokerInZk();
  assertTrue(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),path));
  assertEquals(""String_Node_Str"" + RemotingUtils.getLocalAddress() + ""String_Node_Str"",ZkUtils.readData(this.slaveBrokerZooKeeper.getZkClient(),path));
  try {
    this.slaveBrokerZooKeeper.registerBrokerInZk();
    fail();
  }
 catch (  ZkNodeExistsException e) {
  }
}","@Test public void testRegisterBrokerInZk_slave() throws Exception {
  String path=""String_Node_Str"";
  this.createSlaveBrokerZooKeeper();
  assertFalse(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),path));
  this.slaveBrokerZooKeeper.registerBrokerInZk();
  assertTrue(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),path));
  assertEquals(""String_Node_Str"" + RemotingUtils.getLocalHost() + ""String_Node_Str"",ZkUtils.readData(this.slaveBrokerZooKeeper.getZkClient(),path));
  try {
    this.slaveBrokerZooKeeper.registerBrokerInZk();
    fail();
  }
 catch (  ZkNodeExistsException e) {
  }
}",0.9910931174089068
8112,"@Test public void testSlaveClose_masterNotClose() throws Exception {
  String masterBrokerPath=""String_Node_Str"";
  String masterTopicPath=""String_Node_Str"";
  String slaveBrokerPath=""String_Node_Str"";
  String slaveTopicPath=""String_Node_Str"";
  this.testRegisterBrokerInZk_master();
  this.testRegisterTopicInZk();
  this.testRegisterBrokerInZk_slave();
  this.testRegisterTopicInZk_slave();
  this.slaveBrokerZooKeeper.close(true);
  this.slaveBrokerZooKeeper=null;
  assertFalse(ZkUtils.pathExists(this.brokerZooKeeper.getZkClient(),slaveBrokerPath));
  assertFalse(ZkUtils.pathExists(this.brokerZooKeeper.getZkClient(),slaveTopicPath));
  assertTrue(ZkUtils.pathExists(this.brokerZooKeeper.getZkClient(),masterBrokerPath));
  assertEquals(""String_Node_Str"" + RemotingUtils.getLocalAddress() + ""String_Node_Str"",ZkUtils.readData(this.brokerZooKeeper.getZkClient(),masterBrokerPath));
  assertTrue(ZkUtils.pathExists(this.brokerZooKeeper.getZkClient(),masterTopicPath));
  assertEquals(""String_Node_Str"",ZkUtils.readData(this.brokerZooKeeper.getZkClient(),masterTopicPath));
}","@Test public void testSlaveClose_masterNotClose() throws Exception {
  String masterBrokerPath=""String_Node_Str"";
  String masterTopicPath=""String_Node_Str"";
  String slaveBrokerPath=""String_Node_Str"";
  String slaveTopicPath=""String_Node_Str"";
  this.testRegisterBrokerInZk_master();
  this.testRegisterTopicInZk();
  this.testRegisterBrokerInZk_slave();
  this.testRegisterTopicInZk_slave();
  this.slaveBrokerZooKeeper.close(true);
  this.slaveBrokerZooKeeper=null;
  assertFalse(ZkUtils.pathExists(this.brokerZooKeeper.getZkClient(),slaveBrokerPath));
  assertFalse(ZkUtils.pathExists(this.brokerZooKeeper.getZkClient(),slaveTopicPath));
  assertTrue(ZkUtils.pathExists(this.brokerZooKeeper.getZkClient(),masterBrokerPath));
  assertEquals(""String_Node_Str"" + RemotingUtils.getLocalHost() + ""String_Node_Str"",ZkUtils.readData(this.brokerZooKeeper.getZkClient(),masterBrokerPath));
  assertTrue(ZkUtils.pathExists(this.brokerZooKeeper.getZkClient(),masterTopicPath));
  assertEquals(""String_Node_Str"",ZkUtils.readData(this.brokerZooKeeper.getZkClient(),masterTopicPath));
}",0.9948955916473318
8113,"@Test public void testRegisterBrokerInZk_master() throws Exception {
  String path=""String_Node_Str"";
  assertFalse(ZkUtils.pathExists(this.client,path));
  this.brokerZooKeeper.registerBrokerInZk();
  assertTrue(ZkUtils.pathExists(this.client,path));
  assertEquals(""String_Node_Str"" + RemotingUtils.getLocalAddress() + ""String_Node_Str"",ZkUtils.readData(this.client,path));
  try {
    this.brokerZooKeeper.registerBrokerInZk();
    fail();
  }
 catch (  ZkNodeExistsException e) {
  }
}","@Test public void testRegisterBrokerInZk_master() throws Exception {
  String path=""String_Node_Str"";
  assertFalse(ZkUtils.pathExists(this.client,path));
  this.brokerZooKeeper.registerBrokerInZk();
  assertTrue(ZkUtils.pathExists(this.client,path));
  assertEquals(""String_Node_Str"" + RemotingUtils.getLocalHost() + ""String_Node_Str"",ZkUtils.readData(this.client,path));
  try {
    this.brokerZooKeeper.registerBrokerInZk();
    fail();
  }
 catch (  ZkNodeExistsException e) {
  }
}",0.9887179487179488
8114,"@Test public void testMasterClose_slaveNotClose() throws Exception {
  String masterBrokerPath=""String_Node_Str"";
  String masterTopicPath=""String_Node_Str"";
  String slaveBrokerPath=""String_Node_Str"";
  String slaveTopicPath=""String_Node_Str"";
  this.testRegisterBrokerInZk_master();
  this.testRegisterTopicInZk();
  this.testRegisterBrokerInZk_slave();
  this.testRegisterTopicInZk_slave();
  this.brokerZooKeeper.close(true);
  this.brokerZooKeeper=null;
  assertFalse(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),masterBrokerPath));
  assertFalse(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),masterTopicPath));
  assertTrue(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),slaveBrokerPath));
  assertEquals(""String_Node_Str"" + RemotingUtils.getLocalAddress() + ""String_Node_Str"",ZkUtils.readData(this.slaveBrokerZooKeeper.getZkClient(),slaveBrokerPath));
  assertTrue(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),slaveTopicPath));
  assertEquals(""String_Node_Str"",ZkUtils.readData(this.slaveBrokerZooKeeper.getZkClient(),slaveTopicPath));
}","@Test public void testMasterClose_slaveNotClose() throws Exception {
  String masterBrokerPath=""String_Node_Str"";
  String masterTopicPath=""String_Node_Str"";
  String slaveBrokerPath=""String_Node_Str"";
  String slaveTopicPath=""String_Node_Str"";
  this.testRegisterBrokerInZk_master();
  this.testRegisterTopicInZk();
  this.testRegisterBrokerInZk_slave();
  this.testRegisterTopicInZk_slave();
  this.brokerZooKeeper.close(true);
  this.brokerZooKeeper=null;
  assertFalse(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),masterBrokerPath));
  assertFalse(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),masterTopicPath));
  assertTrue(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),slaveBrokerPath));
  assertEquals(""String_Node_Str"" + RemotingUtils.getLocalHost() + ""String_Node_Str"",ZkUtils.readData(this.slaveBrokerZooKeeper.getZkClient(),slaveBrokerPath));
  assertTrue(ZkUtils.pathExists(this.slaveBrokerZooKeeper.getZkClient(),slaveTopicPath));
  assertEquals(""String_Node_Str"",ZkUtils.readData(this.slaveBrokerZooKeeper.getZkClient(),slaveTopicPath));
}",0.9949794614331356
8115,"private void setUpMeta(final String topic,final Integer maxSize) throws MetaClientException {
  this.sessionFactory=new MetaMessageSessionFactory(this.metaClientConfig);
  this.messageConsumer=this.sessionFactory.createConsumer(this.consumerConfig);
  this.messageConsumer.subscribe(topic,maxSize,new MessageListener(){
    public void recieveMessages(    final Message message){
      final MetaMessageWrapper wrapper=new MetaMessageWrapper(message);
      MetaSpout.this.id2wrapperMap.put(message.getId(),wrapper);
      MetaSpout.this.messageQueue.offer(wrapper);
      try {
        wrapper.latch.await();
      }
 catch (      final InterruptedException e) {
        Thread.currentThread().interrupt();
      }
      if (!wrapper.success) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
    public Executor getExecutor(){
      return null;
    }
  }
).completeSubscribe();
}","private void setUpMeta(final String topic,final Integer maxSize) throws MetaClientException {
  this.sessionFactory=new MetaMessageSessionFactory(this.metaClientConfig);
  this.messageConsumer=this.sessionFactory.createConsumer(this.consumerConfig);
  this.messageConsumer.subscribe(topic,maxSize,new MessageListener(){
    @Override public void recieveMessages(    final Message message){
      final MetaMessageWrapper wrapper=new MetaMessageWrapper(message);
      MetaSpout.this.id2wrapperMap.put(message.getId(),wrapper);
      MetaSpout.this.messageQueue.offer(wrapper);
      try {
        wrapper.latch.await();
      }
 catch (      final InterruptedException e) {
        Thread.currentThread().interrupt();
      }
      if (!wrapper.success) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
    @Override public Executor getExecutor(){
      return null;
    }
  }
).completeSubscribe();
}",0.9890470974808324
8116,"public void fail(final Object msgId){
  if (msgId instanceof Long) {
    final long id=(Long)msgId;
    final MetaMessageWrapper wrapper=this.id2wrapperMap.remove(id);
    if (wrapper == null) {
      log.warn(String.format(""String_Node_Str"",msgId.getClass().getName(),msgId));
      return;
    }
    wrapper.success=false;
    wrapper.latch.countDown();
  }
 else {
    log.warn(String.format(""String_Node_Str"",msgId.getClass().getName(),msgId));
  }
}","@Override public void fail(final Object msgId){
  if (msgId instanceof Long) {
    final long id=(Long)msgId;
    final MetaMessageWrapper wrapper=this.id2wrapperMap.remove(id);
    if (wrapper == null) {
      log.warn(String.format(""String_Node_Str"",msgId.getClass().getName(),msgId));
      return;
    }
    wrapper.success=false;
    wrapper.latch.countDown();
  }
 else {
    log.warn(String.format(""String_Node_Str"",msgId.getClass().getName(),msgId));
  }
}",0.989106753812636
8117,"public void declareOutputFields(final OutputFieldsDeclarer declarer){
  declarer.declare(this.scheme.getOutputFields());
}","@Override public void declareOutputFields(final OutputFieldsDeclarer declarer){
  declarer.declare(this.scheme.getOutputFields());
}",0.9606299212598424
8118,"public void recieveMessages(final Message message){
  final MetaMessageWrapper wrapper=new MetaMessageWrapper(message);
  MetaSpout.this.id2wrapperMap.put(message.getId(),wrapper);
  MetaSpout.this.messageQueue.offer(wrapper);
  try {
    wrapper.latch.await();
  }
 catch (  final InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  if (!wrapper.success) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","@Override public void recieveMessages(final Message message){
  final MetaMessageWrapper wrapper=new MetaMessageWrapper(message);
  MetaSpout.this.id2wrapperMap.put(message.getId(),wrapper);
  MetaSpout.this.messageQueue.offer(wrapper);
  try {
    wrapper.latch.await();
  }
 catch (  final InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  if (!wrapper.success) {
    throw new RuntimeException(""String_Node_Str"");
  }
}",0.9886104783599088
8119,"public void nextTuple(){
  if (this.messageConsumer != null) {
    try {
      final MetaMessageWrapper wrapper=this.messageQueue.poll(WAIT_FOR_NEXT_MESSAGE,TimeUnit.MILLISECONDS);
      if (wrapper == null) {
        return;
      }
      final Message message=wrapper.message;
      this.collector.emit(this.scheme.deserialize(message.getData()),message.getId());
    }
 catch (    final InterruptedException e) {
    }
  }
}","@Override public void nextTuple(){
  if (this.messageConsumer != null) {
    try {
      final MetaMessageWrapper wrapper=this.messageQueue.poll(WAIT_FOR_NEXT_MESSAGE,TimeUnit.MILLISECONDS);
      if (wrapper == null) {
        return;
      }
      final Message message=wrapper.message;
      this.collector.emit(this.scheme.deserialize(message.getData()),message.getId());
    }
 catch (    final InterruptedException e) {
    }
  }
}",0.988425925925926
8120,"public void ack(final Object msgId){
  if (msgId instanceof Long) {
    final long id=(Long)msgId;
    final MetaMessageWrapper wrapper=this.id2wrapperMap.remove(id);
    if (wrapper == null) {
      log.warn(String.format(""String_Node_Str"",msgId.getClass().getName(),msgId));
      return;
    }
    wrapper.success=true;
    wrapper.latch.countDown();
  }
 else {
    log.warn(String.format(""String_Node_Str"",msgId.getClass().getName(),msgId));
  }
}","@Override public void ack(final Object msgId){
  if (msgId instanceof Long) {
    final long id=(Long)msgId;
    final MetaMessageWrapper wrapper=this.id2wrapperMap.remove(id);
    if (wrapper == null) {
      log.warn(String.format(""String_Node_Str"",msgId.getClass().getName(),msgId));
      return;
    }
    wrapper.success=true;
    wrapper.latch.countDown();
  }
 else {
    log.warn(String.format(""String_Node_Str"",msgId.getClass().getName(),msgId));
  }
}",0.9890590809628008
8121,"public Executor getExecutor(){
  return null;
}","@Override public Executor getExecutor(){
  return null;
}",0.903846153846154
8122,"public void close(){
  try {
    this.messageConsumer.shutdown();
  }
 catch (  final MetaClientException e) {
    log.error(""String_Node_Str"",e);
  }
  try {
    this.sessionFactory.shutdown();
  }
 catch (  final MetaClientException e) {
    log.error(""String_Node_Str"",e);
  }
}","@Override public void close(){
  try {
    this.messageConsumer.shutdown();
  }
 catch (  final MetaClientException e) {
    log.error(""String_Node_Str"",e);
  }
  try {
    this.sessionFactory.shutdown();
  }
 catch (  final MetaClientException e) {
    log.error(""String_Node_Str"",e);
  }
}",0.9825174825174824
8123,"public void open(final Map conf,final TopologyContext context,final SpoutOutputCollector collector){
  final String topic=(String)conf.get(TOPIC);
  if (topic == null) {
    throw new IllegalArgumentException(TOPIC + ""String_Node_Str"");
  }
  Integer maxSize=(Integer)conf.get(FETCH_MAX_SIZE);
  if (maxSize == null) {
    log.warn(""String_Node_Str"");
    maxSize=DEFAULT_MAX_SIZE;
  }
  this.id2wrapperMap=new ConcurrentHashMap<Long,MetaMessageWrapper>();
  this.messageQueue=new LinkedTransferQueue<MetaMessageWrapper>();
  try {
    this.collector=collector;
    this.setUpMeta(topic,maxSize);
  }
 catch (  final MetaClientException e) {
    log.error(""String_Node_Str"",e);
  }
}","@Override public void open(final Map conf,final TopologyContext context,final SpoutOutputCollector collector){
  final String topic=(String)conf.get(TOPIC);
  if (topic == null) {
    throw new IllegalArgumentException(TOPIC + ""String_Node_Str"");
  }
  Integer maxSize=(Integer)conf.get(FETCH_MAX_SIZE);
  if (maxSize == null) {
    log.warn(""String_Node_Str"");
    maxSize=DEFAULT_MAX_SIZE;
  }
  this.id2wrapperMap=new ConcurrentHashMap<Long,MetaMessageWrapper>();
  this.messageQueue=new LinkedTransferQueue<MetaMessageWrapper>();
  try {
    this.collector=collector;
    this.setUpMeta(topic,maxSize);
  }
 catch (  final MetaClientException e) {
    log.error(""String_Node_Str"",e);
  }
}",0.9927325581395348
8124,"public void start() throws IOException, InterruptedException {
  File snapFile=new File(this.snapDir).getAbsoluteFile();
  File logFile=new File(this.logDir).getAbsoluteFile();
  ZooKeeperServer server=new ZooKeeperServer(snapFile,logFile,this.tickTime);
  this.standaloneServerFactory=NIOServerCnxnFactory.createFactory(new InetSocketAddress(this.port),this.maxConnections);
  this.standaloneServerFactory.startup(server);
  logger.info(""String_Node_Str"" + this.port);
}","public void start() throws IOException, InterruptedException {
  File snapFile=new File(this.snapDir).getAbsoluteFile();
  if (!snapFile.exists()) {
    snapFile.mkdirs();
  }
  File logFile=new File(this.logDir).getAbsoluteFile();
  if (!logFile.exists()) {
    logFile.mkdirs();
  }
  ZooKeeperServer server=new ZooKeeperServer(snapFile,logFile,this.tickTime);
  this.standaloneServerFactory=NIOServerCnxnFactory.createFactory(new InetSocketAddress(this.port),this.maxConnections);
  this.standaloneServerFactory.startup(server);
  logger.info(""String_Node_Str"" + this.port);
}",0.8971428571428571
8125,"public String getStatsInfo(final String item){
  final StringBuilder sb=new StringBuilder(1024);
  sb.append(""String_Node_Str"");
  if (StringUtils.isBlank(item)) {
    this.appendSystemStatsInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendTopicsInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendOffsetInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendRealTime(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendHelp(sb);
  }
 else {
    this.appendTopic(item,sb);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public String getStatsInfo(final String item){
  final StringBuilder sb=new StringBuilder(1024);
  sb.append(""String_Node_Str"");
  if (StringUtils.isBlank(item)) {
    this.appendSystemStatsInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendTopicsInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendOffsetInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendRealTime(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendHelp(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.realTimeStat.resetStat();
    this.append(sb,""String_Node_Str"",""String_Node_Str"");
  }
 else {
    this.appendTopic(item,sb);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.8885672937771346
8126,"/** 
 * ����topic��messageѡ�����
 * @param topic
 * @param message
 * @return ѡ�еķ���
 */
public Partition selectPartition(final String topic,final Message message,final PartitionSelector partitionSelector) throws MetaClientException {
  if (this.metaClientConfig.getServerUrl() != null) {
    return Partition.RandomPartiton;
  }
  final BrokerConnectionListener brokerConnectionListener=this.getBrokerConnectionListener(topic);
  if (brokerConnectionListener != null) {
    final BrokersInfo brokersInfo=brokerConnectionListener.brokersInfo;
    return partitionSelector.getPartition(topic,brokersInfo.oldTopicPartitionMap.get(topic),message);
  }
 else {
    return this.selectDefaultPartition(topic,message,partitionSelector,null);
  }
}","/** 
 * ����topic��messageѡ�����
 * @param topic
 * @param message
 * @return ѡ�еķ���
 */
public Partition selectPartition(final String topic,final Message message,final PartitionSelector partitionSelector) throws MetaClientException {
  try {
    message.setReadOnly(true);
    if (this.metaClientConfig.getServerUrl() != null) {
      return Partition.RandomPartiton;
    }
    final BrokerConnectionListener brokerConnectionListener=this.getBrokerConnectionListener(topic);
    if (brokerConnectionListener != null) {
      final BrokersInfo brokersInfo=brokerConnectionListener.brokersInfo;
      return partitionSelector.getPartition(topic,brokersInfo.oldTopicPartitionMap.get(topic),message);
    }
 else {
      return this.selectDefaultPartition(topic,message,partitionSelector,null);
    }
  }
  finally {
    message.setReadOnly(false);
  }
}",0.9303201506591338
8127,"/** 
 * ������Ϣpayload
 * @param data
 */
public void setData(final byte[] data){
  this.data=data;
}","/** 
 * Set the message's payload
 * @param data
 */
public void setData(final byte[] data){
  this.checkState();
  this.data=data;
}",0.8034188034188035
8128,"/** 
 * ��Ϣ�Ƿ�������
 * @return
 */
public boolean hasAttribute(){
  return this.attribute != null;
}","/** 
 * Returns whether the message has an attribute.
 * @return
 */
public boolean hasAttribute(){
  return this.attribute != null;
}",0.7574468085106383
8129,"/** 
 * ������ϢId��ֻ���ڷ��ͳɹ��󷵻ص�id����Ч�����򷵻�0
 * @return
 */
public long getId(){
  return this.id;
}","/** 
 * Returns the message's id.If it was sent success,the message id would be returned by broker,otherwise is zero.
 * @return
 */
public long getId(){
  return this.id;
}",0.4765342960288808
8130,"/** 
 * ������Ϣtopic
 * @return
 */
public String getTopic(){
  return this.topic;
}","/** 
 * Returns message's topic
 * @return
 */
public String getTopic(){
  return this.topic;
}",0.8603351955307262
8131,"/** 
 * ������Ϣtopic
 * @param topic
 */
public void setTopic(final String topic){
  this.topic=topic;
}","/** 
 * Set message's topic,if you want to send it,you must publish it at first with MessageProducer.
 * @see com.taobao.metamorphosis.client.producer.MessageProducer#publish(String)
 * @param topic
 */
public void setTopic(final String topic){
  this.checkState();
  this.topic=topic;
}",0.4705882352941176
8132,"/** 
 * ������Ϣ���ԣ���Ϣ���ԷǱ��룬����Ϊ�ַ���
 * @param attribute
 */
public void setAttribute(final String attribute){
  this.attribute=attribute;
}","/** 
 * Set message's attribute
 * @param attribute
 */
public void setAttribute(final String attribute){
  this.checkState();
  this.attribute=attribute;
}",0.7441860465116279
8133,"void setPartition(final Partition partition){
  this.partition=partition;
}","void setPartition(final Partition partition){
  this.checkState();
  this.partition=partition;
}",0.8771929824561403
8134,"/** 
 * ���ͳɹ��󣬷�����Ϣ���ڵķ���������ʧ����Ϊnull
 * @return
 */
public Partition getPartition(){
  return this.partition;
}","/** 
 * Returns message's partition in broker,if it was sent fail,it would be null.
 * @return
 */
public Partition getPartition(){
  return this.partition;
}",0.6236559139784946
8135,"/** 
 * ������Ϣ����
 * @return
 */
public String getAttribute(){
  return this.attribute;
}","/** 
 * Returns the message's attribute,may be null.
 * @return
 */
public String getAttribute(){
  return this.attribute;
}",0.7441860465116279
8136,"/** 
 * �˷����Ѿ����������Ƿ���false�����ų�δ��ĳ���汾���Ƴ��˷������벻Ҫ��ʹ�á�
 * @return
 */
@Deprecated public boolean isOrdered(){
  return false;
}","/** 
 * Returns whether the message is in order,it is deprecated and will be removed in future version.
 * @return
 */
@Deprecated public boolean isOrdered(){
  return false;
}",0.5203761755485894
8137,"/** 
 * ������Ϣpayload
 * @return
 */
public byte[] getData(){
  return this.data;
}","/** 
 * Returns message's payload
 * @return
 */
public byte[] getData(){
  return this.data;
}",0.8603351955307262
8138,"public SamsaCommandProcessor(final MessageStoreManager storeManager,final ExecutorsManager executorsManager,final StatsManager statsManager,final RemotingServer remotingServer,final MetaConfig metaConfig,final IdWorker idWorker,final BrokerZooKeeper brokerZooKeeper,final RemotingClient remotingClient,final String slave,final int callbackThreadCount) throws NotifyRemotingException, InterruptedException {
  super(storeManager,executorsManager,statsManager,remotingServer,metaConfig,idWorker,brokerZooKeeper);
  this.slaveUrl=MetamorphosisWireFormatType.SCHEME + ""String_Node_Str"" + slave;
  this.remotingClient=remotingClient;
  this.callBackExecutor=new ThreadPoolExecutor(callbackThreadCount,callbackThreadCount,60,TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(10000),new ThreadPoolExecutor.CallerRunsPolicy());
  log.info(""String_Node_Str"" + this.slaveUrl);
  this.remotingClient.connect(this.slaveUrl);
  try {
    this.remotingClient.awaitReadyInterrupt(this.slaveUrl);
  }
 catch (  final NotifyRemotingException e) {
    log.error(""String_Node_Str"" + this.slaveUrl + ""String_Node_Str"",e);
  }
}","public SamsaCommandProcessor(final MessageStoreManager storeManager,final ExecutorsManager executorsManager,final StatsManager statsManager,final RemotingServer remotingServer,final MetaConfig metaConfig,final IdWorker idWorker,final BrokerZooKeeper brokerZooKeeper,final RemotingClient remotingClient,final String slave,final int callbackThreadCount) throws NotifyRemotingException, InterruptedException {
  super(storeManager,executorsManager,statsManager,remotingServer,metaConfig,idWorker,brokerZooKeeper);
  this.slaveUrl=MetamorphosisWireFormatType.SCHEME + ""String_Node_Str"" + slave;
  this.remotingClient=remotingClient;
  this.callBackExecutor=new ThreadPoolExecutor(callbackThreadCount,callbackThreadCount,60,TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(10000),new ThreadPoolExecutor.CallerRunsPolicy());
  this.sentSlaveFailureCounter=new AtomicInteger(0);
  log.info(""String_Node_Str"" + this.slaveUrl);
  this.remotingClient.addConnectionLifeCycleListener(new SlaveConnectionLifeCycleListener());
  this.remotingClient.connect(this.slaveUrl);
  try {
    this.remotingClient.awaitReadyInterrupt(this.slaveUrl);
  }
 catch (  final NotifyRemotingException e) {
    log.error(""String_Node_Str"" + this.slaveUrl + ""String_Node_Str"",e);
  }
}",0.9241846675137654
8139,"@Override public void onResponse(final ResponseCommand responseCommand,final Connection conn){
  if (responseCommand.getResponseStatus() == ResponseStatus.NO_ERROR) {
synchronized (this) {
      this.slaveSuccess=true;
    }
  }
  this.tryComplete();
}","@Override public void onResponse(final ResponseCommand responseCommand,final Connection conn){
  if (responseCommand.getResponseStatus() == ResponseStatus.NO_ERROR) {
    SamsaCommandProcessor.this.sentSlaveFailureCounter.set(0);
synchronized (this) {
      this.slaveSuccess=true;
    }
  }
 else {
    SamsaCommandProcessor.this.whenSentSlaveFailed();
  }
  this.tryComplete();
}",0.7962085308056872
8140,"public SamsaCommandProcessor(final MessageStoreManager storeManager,final ExecutorsManager executorsManager,final StatsManager statsManager,final RemotingServer remotingServer,final MetaConfig metaConfig,final IdWorker idWorker,final BrokerZooKeeper brokerZooKeeper,final RemotingClient remotingClient,final String slave,final int callbackThreadCount) throws NotifyRemotingException, InterruptedException {
  super(storeManager,executorsManager,statsManager,remotingServer,metaConfig,idWorker,brokerZooKeeper);
  this.slaveUrl=MetamorphosisWireFormatType.SCHEME + ""String_Node_Str"" + slave;
  this.remotingClient=remotingClient;
  this.callBackExecutor=new ThreadPoolExecutor(callbackThreadCount,callbackThreadCount,60,TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(10000),new ThreadPoolExecutor.CallerRunsPolicy());
  this.sentSlaveFailureCounter=new AtomicInteger(0);
  log.info(""String_Node_Str"" + this.slaveUrl);
  this.remotingClient.addConnectionLifeCycleListener(new SlaveConnectionLifeCycleListener());
  this.remotingClient.connect(this.slaveUrl);
  try {
    this.remotingClient.awaitReadyInterrupt(this.slaveUrl);
  }
 catch (  final NotifyRemotingException e) {
    log.error(""String_Node_Str"" + this.slaveUrl + ""String_Node_Str"",e);
  }
}","public SamsaCommandProcessor(final MessageStoreManager storeManager,final ExecutorsManager executorsManager,final StatsManager statsManager,final RemotingServer remotingServer,final MetaConfig metaConfig,final IdWorker idWorker,final BrokerZooKeeper brokerZooKeeper,final RemotingClient remotingClient,final String slave,final int callbackThreadCount) throws NotifyRemotingException, InterruptedException {
  super(storeManager,executorsManager,statsManager,remotingServer,metaConfig,idWorker,brokerZooKeeper);
  this.slaveUrl=MetamorphosisWireFormatType.SCHEME + ""String_Node_Str"" + slave;
  this.remotingClient=remotingClient;
  this.callBackExecutor=new ThreadPoolExecutor(callbackThreadCount,callbackThreadCount,60,TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(10000),new ThreadPoolExecutor.CallerRunsPolicy());
  log.info(""String_Node_Str"" + this.slaveUrl);
  this.remotingClient.connect(this.slaveUrl);
  try {
    this.remotingClient.awaitReadyInterrupt(this.slaveUrl);
  }
 catch (  final NotifyRemotingException e) {
    log.error(""String_Node_Str"" + this.slaveUrl + ""String_Node_Str"",e);
  }
}",0.7395171537484116
8141,"@Override public void onResponse(final ResponseCommand responseCommand,final Connection conn){
  if (responseCommand.getResponseStatus() == ResponseStatus.NO_ERROR) {
    SamsaCommandProcessor.this.sentSlaveFailureCounter.set(0);
synchronized (this) {
      this.slaveSuccess=true;
    }
  }
 else {
    SamsaCommandProcessor.this.whenSentSlaveFailed();
  }
  this.tryComplete();
}","@Override public void onResponse(final ResponseCommand responseCommand,final Connection conn){
  if (responseCommand.getResponseStatus() == ResponseStatus.NO_ERROR) {
synchronized (this) {
      this.slaveSuccess=true;
    }
  }
  this.tryComplete();
}",0.5497630331753555
8142,"private void makeTopicsPatSet(){
  final Set<Pattern> set=new HashSet<Pattern>();
  for (  final String topic : this.metaConfig.getStatTopicSet()) {
    set.add(Pattern.compile(topic.replaceAll(""String_Node_Str"",""String_Node_Str"")));
  }
  this.legalTopicPatSet=set;
}","private void makeTopicsPatSet(){
  final Set<Pattern> set=new HashSet<Pattern>();
  for (  final TopicConfig topicConfig : this.metaConfig.getTopicConfigMap().values()) {
    if (topicConfig.isStat()) {
      set.add(Pattern.compile(topicConfig.getTopic().replaceAll(""String_Node_Str"",""String_Node_Str"")));
    }
  }
  this.legalTopicPatSet=set;
}",0.7934959349593496
8143,"public StatsManager(final MetaConfig metaConfig,final MessageStoreManager messageStoreManager,final RemotingServer remotingServer){
  super();
  MetaStatLog.startRealTimeStat=this.startRealTimeStat;
  this.metaConfig=metaConfig;
  this.messageStoreManager=messageStoreManager;
  this.remotingServer=remotingServer;
  this.cmdPut=new AtomicLong(0);
  this.cmdGet=new AtomicLong(0);
  this.cmdOffset=new AtomicLong(0);
  this.getMiss=new AtomicLong(0);
  this.getFailed=new AtomicLong(0);
  this.putFailed=new AtomicLong(0);
  this.txBegin=new AtomicLong(0);
  this.txXABegin=new AtomicLong(0);
  this.txRollback=new AtomicLong(0);
  this.txCommit=new AtomicLong(0);
  this.realTimeStat=new RealTimeStat();
  this.legalTopicPatSet=new HashSet<Pattern>();
  this.metaConfig.addPropertyChangeListener(""String_Node_Str"",new PropertyChangeListener(){
    @Override public void propertyChange(    final PropertyChangeEvent evt){
      StatsManager.this.makeTopicsPatSet();
    }
  }
);
  this.metaConfig.addPropertyChangeListener(""String_Node_Str"",new PropertyChangeListener(){
    @Override public void propertyChange(    final PropertyChangeEvent evt){
      log.info(""String_Node_Str"" + StatsManager.this.metaConfig.getStatTopicSet());
      StatsManager.this.makeTopicsPatSet();
    }
  }
);
  this.makeTopicsPatSet();
}","public StatsManager(final MetaConfig metaConfig,final MessageStoreManager messageStoreManager,final RemotingServer remotingServer){
  super();
  MetaStatLog.startRealTimeStat=this.startRealTimeStat;
  this.metaConfig=metaConfig;
  this.messageStoreManager=messageStoreManager;
  this.remotingServer=remotingServer;
  this.cmdPut=new AtomicLong(0);
  this.cmdGet=new AtomicLong(0);
  this.cmdOffset=new AtomicLong(0);
  this.getMiss=new AtomicLong(0);
  this.getFailed=new AtomicLong(0);
  this.putFailed=new AtomicLong(0);
  this.txBegin=new AtomicLong(0);
  this.txXABegin=new AtomicLong(0);
  this.txRollback=new AtomicLong(0);
  this.txCommit=new AtomicLong(0);
  this.realTimeStat=new RealTimeStat();
  this.legalTopicPatSet=new HashSet<Pattern>();
  this.metaConfig.addPropertyChangeListener(""String_Node_Str"",new PropertyChangeListener(){
    @Override public void propertyChange(    final PropertyChangeEvent evt){
      StatsManager.this.makeTopicsPatSet();
    }
  }
);
  this.metaConfig.addPropertyChangeListener(""String_Node_Str"",new PropertyChangeListener(){
    @Override public void propertyChange(    final PropertyChangeEvent evt){
      StatsManager.this.makeTopicsPatSet();
    }
  }
);
  this.makeTopicsPatSet();
}",0.944313725490196
8144,"@Override public void propertyChange(final PropertyChangeEvent evt){
  log.info(""String_Node_Str"" + StatsManager.this.metaConfig.getStatTopicSet());
  StatsManager.this.makeTopicsPatSet();
}","@Override public void propertyChange(final PropertyChangeEvent evt){
  StatsManager.this.makeTopicsPatSet();
}",0.7333333333333333
8145,"private void populateZookeeperConfig(final Ini conf){
  final Section zkConf=conf.get(""String_Node_Str"");
  if (StringUtils.isNotBlank(zkConf.get(""String_Node_Str""))) {
    this.diamondZKDataId=zkConf.get(""String_Node_Str"");
  }
  if (StringUtils.isNotBlank(zkConf.get(""String_Node_Str""))) {
    this.diamondZKGroup=zkConf.get(""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkConnect=zkConf.get(""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkSessionTimeoutMs=this.getInt(zkConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkConnectionTimeoutMs=this.getInt(zkConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkSyncTimeMs=this.getInt(zkConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkEnable=this.getBoolean(zkConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkRoot=zkConf.get(""String_Node_Str"");
  }
}","private void populateZookeeperConfig(final Ini conf){
  final Section zkConf=conf.get(""String_Node_Str"");
  Set<String> configKeySet=zkConf.keySet();
  Set<String> validKeySet=new ZKConfig().getFieldSet();
  validKeySet.addAll(this.getFieldSet());
  this.checkConfigKeys(configKeySet,validKeySet);
  if (StringUtils.isNotBlank(zkConf.get(""String_Node_Str""))) {
    this.diamondZKDataId=zkConf.get(""String_Node_Str"");
  }
  if (StringUtils.isNotBlank(zkConf.get(""String_Node_Str""))) {
    this.diamondZKGroup=zkConf.get(""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkConnect=zkConf.get(""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkSessionTimeoutMs=this.getInt(zkConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkConnectionTimeoutMs=this.getInt(zkConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkSyncTimeMs=this.getInt(zkConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkEnable=this.getBoolean(zkConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(zkConf.get(""String_Node_Str""))) {
    this.newZkConfigIfNull();
    this.zkConfig.zkRoot=zkConf.get(""String_Node_Str"");
  }
}",0.9327731092436976
8146,"public TopicConfig getTopicConfig(final String topic){
  final TopicConfig topicConfig=this.topicConfigMap.get(topic);
  return topicConfig != null ? topicConfig : new TopicConfig(topic,this);
}","public TopicConfig getTopicConfig(final String topic){
  TopicConfig topicConfig=this.topicConfigMap.get(topic);
  if (topicConfig == null) {
    topicConfig=new TopicConfig(topic,this);
    TopicConfig old=this.topicConfigMap.putIfAbsent(topic,topicConfig);
    if (old != null) {
      topicConfig=old;
    }
  }
  return topicConfig;
}",0.5112781954887218
8147,"private void populateTopicsConfig(final Ini conf){
  final Set<String> set=conf.keySet();
  final Set<String> newStatTopics=new TreeSet<String>();
  final List<String> newTopics=new ArrayList<String>();
  final Map<String,TopicConfig> newTopicConfigMap=new CopyOnWriteMap<String,TopicConfig>();
  for (  final String name : set) {
    if (name != null && name.startsWith(""String_Node_Str"")) {
      final Section section=conf.get(name);
      final String topic=name.substring(""String_Node_Str"".length());
      final TopicConfig topicConfig=new TopicConfig(topic,this);
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setNumPartitions(this.getInt(section,""String_Node_Str""));
      }
      boolean stat=false;
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        stat=Boolean.valueOf(section.get(""String_Node_Str""));
        if (stat) {
          newStatTopics.add(topic);
        }
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setDeletePolicy(section.get(""String_Node_Str""));
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setDeleteWhen(section.get(""String_Node_Str""));
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setDataPath(section.get(""String_Node_Str""));
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setUnflushInterval(this.getInt(section,""String_Node_Str""));
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setUnflushThreshold(this.getInt(section,""String_Node_Str""));
      }
      if (!StringUtils.isBlank(section.get(""String_Node_Str""))) {
        topicConfig.setAcceptSubscribe(this.getBoolean(section,""String_Node_Str""));
      }
      if (!StringUtils.isBlank(section.get(""String_Node_Str""))) {
        topicConfig.setAcceptPublish(this.getBoolean(section,""String_Node_Str""));
      }
      newTopicConfigMap.put(topic,topicConfig);
      newTopics.add(topic);
    }
  }
  Collections.sort(newTopics);
  if (!newStatTopics.equals(this.statTopicSet)) {
    this.statTopicSet=newStatTopics;
    this.propertyChangeSupport.firePropertyChange(""String_Node_Str"",null,null);
  }
  if (!newTopicConfigMap.equals(this.topicConfigMap)) {
    this.topics=newTopics;
    this.topicConfigMap=newTopicConfigMap;
    this.propertyChangeSupport.firePropertyChange(""String_Node_Str"",null,null);
  }
  this.propertyChangeSupport.firePropertyChange(""String_Node_Str"",null,null);
}","private void populateTopicsConfig(final Ini conf){
  final Set<String> set=conf.keySet();
  final List<String> newTopics=new ArrayList<String>();
  final ConcurrentHashMap<String,TopicConfig> newTopicConfigMap=new ConcurrentHashMap<String,TopicConfig>();
  for (  final String name : set) {
    if (name != null && name.startsWith(""String_Node_Str"")) {
      final Section section=conf.get(name);
      final String topic=name.substring(""String_Node_Str"".length());
      final TopicConfig topicConfig=new TopicConfig(topic,this);
      Set<String> validKeySet=topicConfig.getFieldSet();
      Set<String> configKeySet=section.keySet();
      this.checkConfigKeys(configKeySet,validKeySet);
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setNumPartitions(this.getInt(section,""String_Node_Str""));
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setStat(Boolean.valueOf(section.get(""String_Node_Str"")));
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setDeletePolicy(section.get(""String_Node_Str""));
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setDeleteWhen(section.get(""String_Node_Str""));
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setDataPath(section.get(""String_Node_Str""));
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setUnflushInterval(this.getInt(section,""String_Node_Str""));
      }
      if (StringUtils.isNotBlank(section.get(""String_Node_Str""))) {
        topicConfig.setUnflushThreshold(this.getInt(section,""String_Node_Str""));
      }
      if (!StringUtils.isBlank(section.get(""String_Node_Str""))) {
        topicConfig.setAcceptSubscribe(this.getBoolean(section,""String_Node_Str""));
      }
      if (!StringUtils.isBlank(section.get(""String_Node_Str""))) {
        topicConfig.setAcceptPublish(this.getBoolean(section,""String_Node_Str""));
      }
      newTopicConfigMap.put(topic,topicConfig);
      newTopics.add(topic);
    }
  }
  Collections.sort(newTopics);
  if (!newTopicConfigMap.equals(this.topicConfigMap)) {
    this.topics=newTopics;
    this.topicConfigMap=newTopicConfigMap;
    this.propertyChangeSupport.firePropertyChange(""String_Node_Str"",null,null);
    this.propertyChangeSupport.firePropertyChange(""String_Node_Str"",null,null);
  }
  this.propertyChangeSupport.firePropertyChange(""String_Node_Str"",null,null);
}",0.8161434977578476
8148,"private void populateSystemConf(final Ini conf){
  final Section sysConf=conf.get(""String_Node_Str"");
  this.brokerId=this.getInt(sysConf,""String_Node_Str"");
  this.serverPort=this.getInt(sysConf,""String_Node_Str"",8123);
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.setDataPath(sysConf.get(""String_Node_Str""));
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.dataLogPath=sysConf.get(""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.hostName=sysConf.get(""String_Node_Str"");
  }
  this.numPartitions=this.getInt(sysConf,""String_Node_Str"");
  this.unflushThreshold=this.getInt(sysConf,""String_Node_Str"");
  this.unflushInterval=this.getInt(sysConf,""String_Node_Str"");
  this.maxSegmentSize=this.getInt(sysConf,""String_Node_Str"");
  this.maxTransferSize=this.getInt(sysConf,""String_Node_Str"");
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.getProcessThreadCount=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.putProcessThreadCount=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.deletePolicy=sysConf.get(""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.deleteWhen=sysConf.get(""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.quartzThreadCount=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.maxCheckpoints=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.checkpointInterval=this.getLong(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.maxTxTimeoutTimerCapacity=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.flushTxLogAtCommit=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.maxTxTimeoutInSeconds=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.acceptSubscribe=this.getBoolean(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.acceptPublish=this.getBoolean(sysConf,""String_Node_Str"");
  }
}","private void populateSystemConf(final Ini conf){
  final Section sysConf=conf.get(""String_Node_Str"");
  Set<String> configKeySet=sysConf.keySet();
  Set<String> validKeySet=this.getFieldSet();
  this.checkConfigKeys(configKeySet,validKeySet);
  this.brokerId=this.getInt(sysConf,""String_Node_Str"");
  this.serverPort=this.getInt(sysConf,""String_Node_Str"",8123);
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.setDataPath(sysConf.get(""String_Node_Str""));
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.dataLogPath=sysConf.get(""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.hostName=sysConf.get(""String_Node_Str"");
  }
  this.numPartitions=this.getInt(sysConf,""String_Node_Str"");
  this.unflushThreshold=this.getInt(sysConf,""String_Node_Str"");
  this.unflushInterval=this.getInt(sysConf,""String_Node_Str"");
  this.maxSegmentSize=this.getInt(sysConf,""String_Node_Str"");
  this.maxTransferSize=this.getInt(sysConf,""String_Node_Str"");
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.getProcessThreadCount=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.putProcessThreadCount=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.deletePolicy=sysConf.get(""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.deleteWhen=sysConf.get(""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.quartzThreadCount=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.maxCheckpoints=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.checkpointInterval=this.getLong(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.maxTxTimeoutTimerCapacity=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.flushTxLogAtCommit=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.maxTxTimeoutInSeconds=this.getInt(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.acceptSubscribe=this.getBoolean(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.acceptPublish=this.getBoolean(sysConf,""String_Node_Str"");
  }
  if (!StringUtils.isBlank(sysConf.get(""String_Node_Str""))) {
    this.stat=this.getBoolean(sysConf,""String_Node_Str"");
  }
}",0.9492822966507176
8149,"@Override public String toString(){
  return ""String_Node_Str"" + this.brokerId + ""String_Node_Str""+ this.dataPath+ ""String_Node_Str""+ this.serverPort+ ""String_Node_Str""+ this.hostName+ ""String_Node_Str""+ this.numPartitions+ ""String_Node_Str""+ this.unflushThreshold+ ""String_Node_Str""+ this.unflushInterval+ ""String_Node_Str""+ this.maxSegmentSize+ ""String_Node_Str""+ this.maxTransferSize+ ""String_Node_Str""+ this.topics+ ""String_Node_Str""+ this.slaveConfig+ ""String_Node_Str""+ this.getProcessThreadCount+ ""String_Node_Str""+ this.putProcessThreadCount+ ""String_Node_Str""+ this.zkConfig+ ""String_Node_Str""+ this.diamondZKDataId+ ""String_Node_Str""+ this.diamondZKGroup+ ""String_Node_Str""+ this.deletePolicy+ ""String_Node_Str""+ this.topicConfigMap+ ""String_Node_Str""+ this.propertyChangeSupport+ ""String_Node_Str""+ this.statTopicSet+ ""String_Node_Str""+ this.lastModified+ ""String_Node_Str""+ this.path+ ""String_Node_Str""+ this.maxCheckpoints+ ""String_Node_Str""+ this.checkpointInterval+ ""String_Node_Str""+ this.maxTxTimeoutTimerCapacity+ ""String_Node_Str""+ this.flushTxLogAtCommit+ ""String_Node_Str""+ this.maxTxTimeoutInSeconds+ ""String_Node_Str""+ this.dataLogPath+ ""String_Node_Str""+ this.deleteWhen+ ""String_Node_Str""+ this.quartzThreadCount+ ""String_Node_Str""+ this.configFileChecksum+ ""String_Node_Str""+ this.acceptPublish+ ""String_Node_Str""+ this.acceptSubscribe+ ""String_Node_Str""+ this.closedPartitionMap+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + this.brokerId + ""String_Node_Str""+ this.dataPath+ ""String_Node_Str""+ this.serverPort+ ""String_Node_Str""+ this.hostName+ ""String_Node_Str""+ this.numPartitions+ ""String_Node_Str""+ this.unflushThreshold+ ""String_Node_Str""+ this.unflushInterval+ ""String_Node_Str""+ this.maxSegmentSize+ ""String_Node_Str""+ this.maxTransferSize+ ""String_Node_Str""+ this.topics+ ""String_Node_Str""+ this.slaveConfig+ ""String_Node_Str""+ this.getProcessThreadCount+ ""String_Node_Str""+ this.putProcessThreadCount+ ""String_Node_Str""+ this.zkConfig+ ""String_Node_Str""+ this.diamondZKDataId+ ""String_Node_Str""+ this.diamondZKGroup+ ""String_Node_Str""+ this.deletePolicy+ ""String_Node_Str""+ this.topicConfigMap+ ""String_Node_Str""+ this.propertyChangeSupport+ ""String_Node_Str""+ this.stat+ ""String_Node_Str""+ this.lastModified+ ""String_Node_Str""+ this.path+ ""String_Node_Str""+ this.maxCheckpoints+ ""String_Node_Str""+ this.checkpointInterval+ ""String_Node_Str""+ this.maxTxTimeoutTimerCapacity+ ""String_Node_Str""+ this.flushTxLogAtCommit+ ""String_Node_Str""+ this.maxTxTimeoutInSeconds+ ""String_Node_Str""+ this.dataLogPath+ ""String_Node_Str""+ this.deleteWhen+ ""String_Node_Str""+ this.quartzThreadCount+ ""String_Node_Str""+ this.configFileChecksum+ ""String_Node_Str""+ this.acceptPublish+ ""String_Node_Str""+ this.acceptSubscribe+ ""String_Node_Str""+ this.closedPartitionMap+ ""String_Node_Str"";
}",0.9971890372452564
8150,"public MessageStore(final String topic,final int partition,final MetaConfig metaConfig,final DeletePolicy deletePolicy,final long offsetIfCreate) throws IOException {
  this.metaConfig=metaConfig;
  this.topic=topic;
  final TopicConfig topicConfig=this.metaConfig.getTopicConfig(this.topic);
  String dataPath=metaConfig.getDataPath();
  if (topicConfig != null) {
    dataPath=topicConfig.getDataPath();
  }
  final File parentDir=new File(dataPath);
  this.checkDir(parentDir);
  this.partitionDir=new File(dataPath + File.separator + topic+ ""String_Node_Str""+ partition);
  this.checkDir(this.partitionDir);
  this.partition=partition;
  this.unflushed=new AtomicInteger(0);
  this.lastFlushTime=new AtomicLong(SystemTimer.currentTimeMillis());
  this.unflushThreshold=topicConfig.getUnflushThreshold();
  this.deletePolicy=deletePolicy;
  this.checkDir(this.partitionDir);
  this.loadSegments(offsetIfCreate);
  if (this.unflushThreshold <= 0) {
    this.start();
  }
}","public MessageStore(final String topic,final int partition,final MetaConfig metaConfig,final DeletePolicy deletePolicy,final long offsetIfCreate) throws IOException {
  this.metaConfig=metaConfig;
  this.topic=topic;
  final TopicConfig topicConfig=this.metaConfig.getTopicConfig(this.topic);
  String dataPath=metaConfig.getDataPath();
  if (topicConfig != null) {
    dataPath=topicConfig.getDataPath();
  }
  final File parentDir=new File(dataPath);
  this.checkDir(parentDir);
  this.partitionDir=new File(dataPath + File.separator + topic+ ""String_Node_Str""+ partition);
  this.checkDir(this.partitionDir);
  this.partition=partition;
  this.unflushed=new AtomicInteger(0);
  this.lastFlushTime=new AtomicLong(SystemTimer.currentTimeMillis());
  this.unflushThreshold=topicConfig.getUnflushThreshold();
  this.deletePolicy=deletePolicy;
  this.checkDir(this.partitionDir);
  this.loadSegments(offsetIfCreate);
}",0.9693121693121692
8151,"private void appendBuffer(final ByteBuffer buffer,final AppendCallback cb){
  if (this.unflushThreshold <= 0) {
    this.bufferQueue.offer(new WriteRequest(buffer,cb));
  }
 else {
    final int remainning=buffer.remaining();
    this.writeLock.lock();
    try {
      final Segment cur=this.segments.last();
      final long offset=cur.start + cur.fileMessageSet.append(buffer);
      this.mayBeFlush(1);
      this.mayBeRoll();
      if (cb != null) {
        cb.appendComplete(new Location(offset,remainning));
      }
    }
 catch (    final IOException e) {
      log.error(""String_Node_Str"",e);
      if (cb != null) {
        cb.appendComplete(Location.InvalidLocaltion);
      }
    }
 finally {
      this.writeLock.unlock();
    }
  }
}","private void appendBuffer(final ByteBuffer buffer,final AppendCallback cb){
  final int remainning=buffer.remaining();
  this.writeLock.lock();
  try {
    final Segment cur=this.segments.last();
    final long offset=cur.start + cur.fileMessageSet.append(buffer);
    if (this.useGroupCommit()) {
      long lastFlushPos=cur.fileMessageSet.highWaterMark();
      Location location=new Location(offset,remainning);
      WriteRequest writeRequest=new WriteRequest(cb,location);
      writeRequest.location=location;
      this.toFlush.offer(writeRequest);
      if (!this.writeLock.hasQueuedThreads() || cur.fileMessageSet.getSizeInBytes() > lastFlushPos + this.MAX_BATCH_SIZE) {
        this.flush0();
        this.notifyCallbacks();
        this.toFlush.clear();
        this.mayBeRoll();
      }
    }
 else {
      this.mayBeFlush(1);
      this.mayBeRoll();
      if (cb != null) {
        cb.appendComplete(new Location(offset,remainning));
      }
    }
  }
 catch (  final IOException e) {
    log.error(""String_Node_Str"",e);
    if (cb != null) {
      cb.appendComplete(Location.InvalidLocaltion);
    }
  }
 finally {
    this.writeLock.unlock();
  }
}",0.6233630172865374
8152,"public Segment(final long start,final File file,final boolean mutable){
  super();
  this.start=start;
  this.file=file;
  log.warn(""String_Node_Str"" + this.file.getAbsolutePath());
  try {
    final FileChannel channel=new RandomAccessFile(this.file,""String_Node_Str"").getChannel();
    this.fileMessageSet=new FileMessageSet(channel,0,channel.size(),mutable);
  }
 catch (  final IOException e) {
    log.error(""String_Node_Str"",e);
  }
}","public Segment(final long start,final File file,final boolean mutable){
  super();
  this.start=start;
  this.file=file;
  log.info(""String_Node_Str"" + this.file.getAbsolutePath());
  try {
    final FileChannel channel=new RandomAccessFile(this.file,""String_Node_Str"").getChannel();
    this.fileMessageSet=new FileMessageSet(channel,0,channel.size(),mutable);
  }
 catch (  final IOException e) {
    log.error(""String_Node_Str"",e);
  }
}",0.990909090909091
8153,"private void flush0() throws IOException {
  if (this.unflushThreshold <= 0) {
    return;
  }
  this.segments.last().fileMessageSet.flush();
  this.unflushed.set(0);
  this.lastFlushTime.set(SystemTimer.currentTimeMillis());
}","private void flush0() throws IOException {
  this.segments.last().fileMessageSet.flush();
  this.unflushed.set(0);
  this.lastFlushTime.set(SystemTimer.currentTimeMillis());
}",0.8706467661691543
8154,"@Override public void close() throws IOException {
  for (  final Segment segment : this.segments.view()) {
    segment.fileMessageSet.close();
  }
  this.interrupt();
  try {
    this.join(5000);
  }
 catch (  final InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}","@Override public void close() throws IOException {
  for (  final Segment segment : this.segments.view()) {
    segment.fileMessageSet.close();
  }
  this.writeLock.lock();
  try {
    this.notifyCallbacks();
    this.toFlush.clear();
  }
  finally {
    this.writeLock.unlock();
  }
}",0.5933682373472949
8155,"public WriteRequest(final ByteBuffer buf,final AppendCallback cb){
  super();
  this.buf=buf;
  this.cb=cb;
}","public WriteRequest(final AppendCallback cb,Location location){
  super();
  this.cb=cb;
  this.location=location;
}",0.7288888888888889
8156,"private void parseStatsValues(InetSocketAddress sockAddr,Map<InetSocketAddress,StatsResult> rt,String group,String body) throws URISyntaxException {
  String[] lines=body.split(""String_Node_Str"");
  Map<String,String> values=new HashMap<String,String>();
  for (  String line : lines) {
    String[] tmp=line.split(""String_Node_Str"");
    if (tmp.length >= 2) {
      values.put(tmp[0],tmp[1]);
    }
  }
  rt.put(sockAddr,new StatsResult(values));
}","private void parseStatsValues(InetSocketAddress sockAddr,Map<InetSocketAddress,StatsResult> rt,String group,String body) throws URISyntaxException {
  String[] lines=body.split(""String_Node_Str"");
  Map<String,String> values=new HashMap<String,String>();
  for (  String line : lines) {
    int index=line.indexOf(""String_Node_Str"");
    if (index > 0) {
      String key=line.substring(0,index);
      String value=line.substring(index + 1);
      values.put(key,value);
    }
 else {
      values.put(line,""String_Node_Str"");
    }
  }
  rt.put(sockAddr,new StatsResult(values));
}",0.7879961277831559
8157,"public String getStatsInfo(final String item){
  final StringBuilder sb=new StringBuilder(1024);
  sb.append(""String_Node_Str"");
  if (StringUtils.isBlank(item)) {
    this.appendSystemStatsInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendTopicsInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendOffsetInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendRealTime(sb);
  }
 else {
    this.appendTopic(item,sb);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public String getStatsInfo(final String item){
  final StringBuilder sb=new StringBuilder(1024);
  sb.append(""String_Node_Str"");
  if (StringUtils.isBlank(item)) {
    this.appendSystemStatsInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendTopicsInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendOffsetInfo(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendRealTime(sb);
  }
 else   if (""String_Node_Str"".equals(item)) {
    this.appendHelp(sb);
  }
 else {
    this.appendTopic(item,sb);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.9356223175965666
8158,"ZKLoadRebalanceListener getBrokerConnectionListener(final FetchManager fetchManager){
  final FutureTask<ZKLoadRebalanceListener> task=this.consumerLoadBalanceListeners.get(fetchManager);
  if (task != null) {
    try {
      return task.get();
    }
 catch (    final Exception e) {
      log.error(""String_Node_Str"",e);
      return null;
    }
  }
 else {
    return null;
  }
}","public ZKLoadRebalanceListener getBrokerConnectionListener(final FetchManager fetchManager){
  final FutureTask<ZKLoadRebalanceListener> task=this.consumerLoadBalanceListeners.get(fetchManager);
  if (task != null) {
    try {
      return task.get();
    }
 catch (    final Exception e) {
      log.error(""String_Node_Str"",e);
      return null;
    }
  }
 else {
    return null;
  }
}",0.9908972691807544
8159,"@Override public void stopFetchRunner() throws InterruptedException {
  this.shutdown=true;
  if (this.fetchRunners != null) {
    for (    final Thread thread : this.fetchRunners) {
      if (thread != null) {
        thread.interrupt();
        try {
          thread.join(5000);
        }
 catch (        final InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
    }
  }
  if (this.requestQueue != null) {
    while (this.requestQueue.size() != this.fetchRequestCount) {
      Thread.sleep(50);
    }
  }
}","@Override public void stopFetchRunner() throws InterruptedException {
  this.shutdown=true;
  if (this.fetchRunners != null) {
    for (    final Thread thread : this.fetchRunners) {
      if (thread != null) {
        thread.interrupt();
        try {
          thread.join(5000);
        }
 catch (        final InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
    }
  }
  if (this.requestQueue != null) {
    while (this.requestQueue.size() != this.fetchRequestCount) {
      Thread.sleep(50);
    }
  }
  this.fetchRequestCount=0;
}",0.9733570159857904
8160,"FetchManager getFetchManager(){
  return this.fetchManager;
}","public FetchManager getFetchManager(){
  return this.fetchManager;
}",0.9457364341085271
8161,"void syncedUpdateBrokersInfo() throws NotifyRemotingException, InterruptedException {
  this.lock.lock();
  try {
    final Map<Integer,String> newBrokerStringMap=ProducerZooKeeper.this.metaZookeeper.getMasterBrokersByTopic(this.topic);
    final List<String> topics=new ArrayList<String>(1);
    topics.add(this.topic);
    final Map<String,List<Partition>> newTopicPartitionMap=ProducerZooKeeper.this.metaZookeeper.getPartitionsForTopicsFromMaster(topics);
    log.warn(""String_Node_Str"" + this.topic + ""String_Node_Str""+ newTopicPartitionMap);
    for (    final Map.Entry<Integer,String> oldEntry : this.brokersInfo.oldBrokerStringMap.entrySet()) {
      final Integer oldBrokerId=oldEntry.getKey();
      final String oldBrokerString=oldEntry.getValue();
      final String newBrokerString=newBrokerStringMap.get(oldBrokerId);
      if (newBrokerStringMap.containsKey(oldBrokerId)) {
        if (!newBrokerString.equals(oldBrokerString)) {
          ProducerZooKeeper.this.remotingClient.close(oldBrokerString,false);
          ProducerZooKeeper.this.remotingClient.connect(newBrokerString);
          ProducerZooKeeper.this.remotingClient.awaitReadyInterrupt(newBrokerString);
          log.warn(""String_Node_Str"" + oldBrokerString + ""String_Node_Str""+ newBrokerString);
        }
 else {
        }
      }
 else {
        ProducerZooKeeper.this.remotingClient.close(oldBrokerString,false);
        log.warn(""String_Node_Str"" + oldBrokerString);
      }
    }
    for (    final Map.Entry<Integer,String> newEntry : newBrokerStringMap.entrySet()) {
      final Integer newBrokerId=newEntry.getKey();
      final String newBrokerString=newEntry.getValue();
      if (!this.brokersInfo.oldBrokerStringMap.containsKey(newBrokerId)) {
        ProducerZooKeeper.this.remotingClient.connect(newBrokerString);
        ProducerZooKeeper.this.remotingClient.awaitReadyInterrupt(newBrokerString);
        log.warn(""String_Node_Str"" + newBrokerString);
      }
    }
    this.brokersInfo=new BrokersInfo(newBrokerStringMap,newTopicPartitionMap);
    log.warn(""String_Node_Str"" + this.topic);
  }
  finally {
    this.lock.unlock();
  }
}","void syncedUpdateBrokersInfo() throws NotifyRemotingException, InterruptedException {
  this.lock.lock();
  try {
    final Map<Integer,String> newBrokerStringMap=ProducerZooKeeper.this.metaZookeeper.getMasterBrokersByTopic(this.topic);
    final List<String> topics=new ArrayList<String>(1);
    topics.add(this.topic);
    final Map<String,List<Partition>> newTopicPartitionMap=ProducerZooKeeper.this.metaZookeeper.getPartitionsForTopicsFromMaster(topics);
    log.warn(""String_Node_Str"" + this.topic + ""String_Node_Str""+ newTopicPartitionMap);
    for (    final Map.Entry<Integer,String> newEntry : newBrokerStringMap.entrySet()) {
      final Integer newBrokerId=newEntry.getKey();
      final String newBrokerString=newEntry.getValue();
      if (!this.brokersInfo.oldBrokerStringMap.containsKey(newBrokerId)) {
        ProducerZooKeeper.this.remotingClient.connect(newBrokerString);
        ProducerZooKeeper.this.remotingClient.awaitReadyInterrupt(newBrokerString);
        log.warn(""String_Node_Str"" + newBrokerString);
      }
    }
    this.brokersInfo=new BrokersInfo(newBrokerStringMap,newTopicPartitionMap);
    for (    final Map.Entry<Integer,String> oldEntry : this.brokersInfo.oldBrokerStringMap.entrySet()) {
      final Integer oldBrokerId=oldEntry.getKey();
      final String oldBrokerString=oldEntry.getValue();
      final String newBrokerString=newBrokerStringMap.get(oldBrokerId);
      if (newBrokerStringMap.containsKey(oldBrokerId)) {
        if (!newBrokerString.equals(oldBrokerString)) {
          log.warn(""String_Node_Str"" + oldBrokerString + ""String_Node_Str""+ newBrokerString);
          ProducerZooKeeper.this.remotingClient.connect(newBrokerString);
          ProducerZooKeeper.this.remotingClient.awaitReadyInterrupt(newBrokerString);
          ProducerZooKeeper.this.remotingClient.close(oldBrokerString,false);
        }
 else {
        }
      }
 else {
        ProducerZooKeeper.this.remotingClient.close(oldBrokerString,false);
        log.warn(""String_Node_Str"" + oldBrokerString);
      }
    }
    log.warn(""String_Node_Str"" + this.topic);
  }
  finally {
    this.lock.unlock();
  }
}",0.6064727954971857
8162,"private SendResult send0(final Message message,final byte[] encodedData,final long timeout,final TimeUnit unit) throws InterruptedException, MetaClientException {
  try {
    final String topic=message.getTopic();
    Partition partition=null;
    String serverUrl=null;
    if (this.isInTransaction()) {
      final LastSentInfo info=this.lastSentInfo.get();
      if (info != null) {
        serverUrl=info.serverUrl;
        partition=this.producerZooKeeper.selectPartition(topic,message,this.partitionSelector,serverUrl);
        if (partition == null) {
          throw new MetaClientException(""String_Node_Str"" + serverUrl + ""String_Node_Str""+ topic+ ""String_Node_Str"");
        }
      }
    }
    if (partition == null) {
      partition=this.selectPartition(message);
    }
    if (partition == null) {
      throw new MetaClientException(""String_Node_Str"" + topic + ""String_Node_Str"");
    }
    if (serverUrl == null) {
      serverUrl=this.producerZooKeeper.selectBroker(topic,partition);
    }
    if (serverUrl == null) {
      throw new MetaClientException(""String_Node_Str"" + topic + ""String_Node_Str""+ partition+ ""String_Node_Str"");
    }
    if (this.isInTransaction() && this.lastSentInfo.get() == null) {
      this.beforeSendMessageFirstTime(serverUrl);
    }
    final int flag=MessageFlagUtils.getFlag(message);
    final PutCommand putCommand=new PutCommand(topic,partition.getPartition(),encodedData,this.getTransactionId(),flag,OpaqueGenerator.getNextOpaque());
    final BooleanCommand resp=this.invokeToGroup(serverUrl,partition,putCommand,message,timeout,unit);
    return this.genSendResult(message,partition,serverUrl,resp);
  }
 catch (  final TimeoutException e) {
    throw new MetaOpeartionTimeoutException(""String_Node_Str"" + TimeUnit.MILLISECONDS.convert(timeout,unit) + ""String_Node_Str"");
  }
catch (  final InterruptedException e) {
    throw e;
  }
catch (  final Exception e) {
    throw new MetaClientException(""String_Node_Str"",e);
  }
}","private SendResult send0(final Message message,final byte[] encodedData,final long timeout,final TimeUnit unit) throws InterruptedException, MetaClientException {
  try {
    final String topic=message.getTopic();
    Partition partition=null;
    String serverUrl=null;
    if (this.isInTransaction()) {
      final LastSentInfo info=this.lastSentInfo.get();
      if (info != null) {
        serverUrl=info.serverUrl;
        partition=this.producerZooKeeper.selectPartition(topic,message,this.partitionSelector,serverUrl);
        if (partition == null) {
          throw new MetaClientException(""String_Node_Str"" + serverUrl + ""String_Node_Str""+ topic+ ""String_Node_Str"");
        }
      }
    }
    if (partition == null) {
      partition=this.selectPartition(message);
    }
    if (partition == null) {
      throw new MetaClientException(""String_Node_Str"" + topic + ""String_Node_Str"");
    }
    if (serverUrl == null) {
      serverUrl=this.producerZooKeeper.selectBroker(topic,partition);
    }
    if (serverUrl == null) {
      throw new MetaClientException(""String_Node_Str"" + topic + ""String_Node_Str""+ partition+ ""String_Node_Str"");
    }
    if (this.isInTransaction() && this.lastSentInfo.get() == null) {
      this.beforeSendMessageFirstTime(serverUrl);
    }
    final int flag=MessageFlagUtils.getFlag(message);
    final PutCommand putCommand=new PutCommand(topic,partition.getPartition(),encodedData,this.getTransactionId(),flag,CheckSum.crc32(encodedData),OpaqueGenerator.getNextOpaque());
    final BooleanCommand resp=this.invokeToGroup(serverUrl,partition,putCommand,message,timeout,unit);
    return this.genSendResult(message,partition,serverUrl,resp);
  }
 catch (  final TimeoutException e) {
    throw new MetaOpeartionTimeoutException(""String_Node_Str"" + TimeUnit.MILLISECONDS.convert(timeout,unit) + ""String_Node_Str"");
  }
catch (  final InterruptedException e) {
    throw e;
  }
catch (  final Exception e) {
    throw new MetaClientException(""String_Node_Str"",e);
  }
}",0.9929824561403509
8163,"@Test public void testSendOrderedMessage() throws Exception {
  final String topic=""String_Node_Str"";
  final byte[] data=""String_Node_Str"".getBytes();
  final Message message=new Message(topic,data);
  final String url=""String_Node_Str"";
  final Partition partition=new Partition(""String_Node_Str"");
  EasyMock.expect(this.producerZooKeeper.selectPartition(topic,message,this.partitionSelector)).andReturn(partition).times(2);
  EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
  EasyMock.expect(this.localMessageStorageManager.getMessageCount(topic,partition)).andReturn(0);
  OpaqueGenerator.resetOpaque();
  final int flag=MessageFlagUtils.getFlag(null);
  EasyMock.expect(this.remotingClient.invokeToGroup(url,new PutCommand(topic,partition.getPartition(),data,null,flag,Integer.MIN_VALUE),3000,TimeUnit.MILLISECONDS)).andReturn(new BooleanCommand(Integer.MIN_VALUE,200,""String_Node_Str""));
  this.mocksControl.replay();
  assertEquals(0,message.getId());
  final SendResult sendResult=this.producer.sendMessage(message);
  this.mocksControl.verify();
  assertTrue(sendResult.isSuccess());
  assertEquals(1024,sendResult.getOffset());
  assertEquals(1,sendResult.getPartition().getPartition());
  assertEquals(0,sendResult.getPartition().getBrokerId());
  assertEquals(1111,message.getId());
}","@Test public void testSendOrderedMessage() throws Exception {
  final String topic=""String_Node_Str"";
  final byte[] data=""String_Node_Str"".getBytes();
  final Message message=new Message(topic,data);
  final String url=""String_Node_Str"";
  final Partition partition=new Partition(""String_Node_Str"");
  EasyMock.expect(this.producerZooKeeper.selectPartition(topic,message,this.partitionSelector)).andReturn(partition).times(2);
  EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
  EasyMock.expect(this.localMessageStorageManager.getMessageCount(topic,partition)).andReturn(0);
  OpaqueGenerator.resetOpaque();
  final int flag=MessageFlagUtils.getFlag(null);
  EasyMock.expect(this.remotingClient.invokeToGroup(url,new PutCommand(topic,partition.getPartition(),data,null,flag,CheckSum.crc32(data),Integer.MIN_VALUE),3000,TimeUnit.MILLISECONDS)).andReturn(new BooleanCommand(Integer.MIN_VALUE,200,""String_Node_Str""));
  this.mocksControl.replay();
  assertEquals(0,message.getId());
  final SendResult sendResult=this.producer.sendMessage(message);
  this.mocksControl.verify();
  assertTrue(sendResult.isSuccess());
  assertEquals(1024,sendResult.getOffset());
  assertEquals(1,sendResult.getPartition().getPartition());
  assertEquals(0,sendResult.getPartition().getBrokerId());
  assertEquals(1111,message.getId());
}",0.992196209587514
8164,"@Test public void testSendOrderedMessageServerError() throws Exception {
  final String topic=""String_Node_Str"";
  final byte[] data=""String_Node_Str"".getBytes();
  final Message message=new Message(topic,data);
  final String url=""String_Node_Str"";
  final Partition partition=new Partition(""String_Node_Str"");
  EasyMock.expect(this.producerZooKeeper.selectPartition(topic,message,this.partitionSelector)).andReturn(partition);
  EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
  OpaqueGenerator.resetOpaque();
  final int flag=MessageFlagUtils.getFlag(null);
  EasyMock.expect(this.remotingClient.invokeToGroup(url,new PutCommand(topic,partition.getPartition(),data,null,flag,Integer.MIN_VALUE),3000,TimeUnit.MILLISECONDS)).andReturn(new BooleanCommand(Integer.MIN_VALUE,500,""String_Node_Str""));
  this.mocksControl.replay();
  assertEquals(0,message.getId());
  final SendResult sendResult=this.producer.sendMessage(message);
  this.mocksControl.verify();
  assertFalse(sendResult.isSuccess());
  assertEquals(-1,sendResult.getOffset());
  assertNull(sendResult.getPartition());
  assertEquals(""String_Node_Str"",sendResult.getErrorMessage());
}","@Test public void testSendOrderedMessageServerError() throws Exception {
  final String topic=""String_Node_Str"";
  final byte[] data=""String_Node_Str"".getBytes();
  final Message message=new Message(topic,data);
  final String url=""String_Node_Str"";
  final Partition partition=new Partition(""String_Node_Str"");
  EasyMock.expect(this.producerZooKeeper.selectPartition(topic,message,this.partitionSelector)).andReturn(partition);
  EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
  OpaqueGenerator.resetOpaque();
  final int flag=MessageFlagUtils.getFlag(null);
  EasyMock.expect(this.remotingClient.invokeToGroup(url,new PutCommand(topic,partition.getPartition(),data,null,flag,CheckSum.crc32(data),Integer.MIN_VALUE),3000,TimeUnit.MILLISECONDS)).andReturn(new BooleanCommand(Integer.MIN_VALUE,500,""String_Node_Str""));
  this.mocksControl.replay();
  assertEquals(0,message.getId());
  final SendResult sendResult=this.producer.sendMessage(message);
  this.mocksControl.verify();
  assertFalse(sendResult.isSuccess());
  assertEquals(-1,sendResult.getOffset());
  assertNull(sendResult.getPartition());
  assertEquals(""String_Node_Str"",sendResult.getErrorMessage());
}",0.9912244045131634
8165,"@Test public void testSendMessageInterrupted() throws Exception {
  boolean interrupted=false;
  try {
    final String topic=""String_Node_Str"";
    final byte[] data=""String_Node_Str"".getBytes();
    final Message message=new Message(topic,data);
    final String url=""String_Node_Str"";
    final Partition partition=new Partition(""String_Node_Str"");
    EasyMock.expect(this.producerZooKeeper.selectPartition(topic,message,this.partitionSelector)).andReturn(partition);
    EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
    OpaqueGenerator.resetOpaque();
    final int flag=MessageFlagUtils.getFlag(null);
    EasyMock.expect(this.remotingClient.invokeToGroup(url,new PutCommand(topic,partition.getPartition(),data,null,flag,Integer.MIN_VALUE),3000,TimeUnit.MILLISECONDS)).andThrow(new InterruptedException());
    this.mocksControl.replay();
    this.producer.sendMessage(message);
  }
 catch (  final InterruptedException e) {
    interrupted=true;
  }
  this.mocksControl.verify();
  assertTrue(interrupted);
}","@Test public void testSendMessageInterrupted() throws Exception {
  boolean interrupted=false;
  try {
    final String topic=""String_Node_Str"";
    final byte[] data=""String_Node_Str"".getBytes();
    final Message message=new Message(topic,data);
    final String url=""String_Node_Str"";
    final Partition partition=new Partition(""String_Node_Str"");
    EasyMock.expect(this.producerZooKeeper.selectPartition(topic,message,this.partitionSelector)).andReturn(partition);
    EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
    OpaqueGenerator.resetOpaque();
    final int flag=MessageFlagUtils.getFlag(null);
    EasyMock.expect(this.remotingClient.invokeToGroup(url,new PutCommand(topic,partition.getPartition(),data,null,flag,CheckSum.crc32(data),Integer.MIN_VALUE),3000,TimeUnit.MILLISECONDS)).andThrow(new InterruptedException());
    this.mocksControl.replay();
    this.producer.sendMessage(message);
  }
 catch (  final InterruptedException e) {
    interrupted=true;
  }
  this.mocksControl.verify();
  assertTrue(interrupted);
}",0.990145471609573
8166,"protected Map<String,List<String>> getPartitionStringsForTopics(final Map<String,String> myConsumerPerTopicMap){
  return ConsumerZooKeeper.this.metaZookeeper.getPartitionStringsForTopics(myConsumerPerTopicMap.keySet());
}","protected Map<String,List<String>> getPartitionStringsForTopics(final Map<String,String> myConsumerPerTopicMap){
  return ConsumerZooKeeper.this.metaZookeeper.getPartitionStringsForSubTopics(myConsumerPerTopicMap.keySet());
}",0.9932885906040269
8167,"/** 
 * ȡ��ע��consumer
 * @param fetchManager
 */
public void unRegisterConsumer(final FetchManager fetchManager){
  try {
    final FutureTask<ZKLoadRebalanceListener> futureTask=this.consumerLoadBalanceListeners.remove(fetchManager);
    if (futureTask != null) {
      final ZKLoadRebalanceListener listener=futureTask.get();
      if (listener != null) {
        listener.commitOffsets();
        this.zkClient.unsubscribeStateChanges(new ZKSessionExpireListenner(listener));
        final ZKGroupDirs dirs=this.metaZookeeper.new ZKGroupDirs(listener.consumerConfig.getGroup());
        this.zkClient.unsubscribeChildChanges(dirs.consumerRegistryDir,listener);
        log.info(""String_Node_Str"" + dirs.consumerRegistryDir);
        for (        final String topic : listener.topicSubcriberRegistry.keySet()) {
          final String partitionPath=this.metaZookeeper.brokerTopicsPath + ""String_Node_Str"" + topic;
          this.zkClient.unsubscribeChildChanges(partitionPath,listener);
          log.info(""String_Node_Str"" + partitionPath);
        }
        listener.releaseAllPartitionOwnership();
        ZkUtils.deletePath(this.zkClient,listener.dirs.consumerRegistryDir + ""String_Node_Str"" + listener.consumerIdString);
      }
    }
  }
 catch (  final InterruptedException e) {
    Thread.interrupted();
    log.error(""String_Node_Str"",e);
  }
catch (  final Exception e) {
    log.error(""String_Node_Str"",e);
  }
}","/** 
 * ȡ��ע��consumer
 * @param fetchManager
 */
public void unRegisterConsumer(final FetchManager fetchManager){
  try {
    final FutureTask<ZKLoadRebalanceListener> futureTask=this.consumerLoadBalanceListeners.remove(fetchManager);
    if (futureTask != null) {
      final ZKLoadRebalanceListener listener=futureTask.get();
      if (listener != null) {
        listener.commitOffsets();
        this.zkClient.unsubscribeStateChanges(new ZKSessionExpireListenner(listener));
        final ZKGroupDirs dirs=this.metaZookeeper.new ZKGroupDirs(listener.consumerConfig.getGroup());
        this.zkClient.unsubscribeChildChanges(dirs.consumerRegistryDir,listener);
        log.info(""String_Node_Str"" + dirs.consumerRegistryDir);
        for (        final String topic : listener.topicSubcriberRegistry.keySet()) {
          final String partitionPath=this.metaZookeeper.brokerTopicsSubPath + ""String_Node_Str"" + topic;
          this.zkClient.unsubscribeChildChanges(partitionPath,listener);
          log.info(""String_Node_Str"" + partitionPath);
        }
        listener.releaseAllPartitionOwnership();
        ZkUtils.deletePath(this.zkClient,listener.dirs.consumerRegistryDir + ""String_Node_Str"" + listener.consumerIdString);
      }
    }
  }
 catch (  final InterruptedException e) {
    Thread.interrupted();
    log.error(""String_Node_Str"",e);
  }
catch (  final Exception e) {
    log.error(""String_Node_Str"",e);
  }
}",0.9989492119089316
8168,"protected ZKLoadRebalanceListener registerConsumerInternal(final ZKLoadRebalanceListener loadBalanceListener) throws UnknownHostException, InterruptedException, Exception {
  final ZKGroupDirs dirs=this.metaZookeeper.new ZKGroupDirs(loadBalanceListener.consumerConfig.getGroup());
  final String topicString=this.getTopicsString(loadBalanceListener.topicSubcriberRegistry);
  if (this.zkClient == null) {
    loadBalanceListener.fetchManager.stopFetchRunner();
    loadBalanceListener.fetchManager.resetFetchState();
    for (    final String topic : loadBalanceListener.topicSubcriberRegistry.keySet()) {
      final SubscriberInfo subInfo=loadBalanceListener.topicSubcriberRegistry.get(topic);
      ConcurrentHashMap<Partition,TopicPartitionRegInfo> topicPartRegInfoMap=loadBalanceListener.topicRegistry.get(topic);
      if (topicPartRegInfoMap == null) {
        topicPartRegInfoMap=new ConcurrentHashMap<Partition,TopicPartitionRegInfo>();
        loadBalanceListener.topicRegistry.put(topic,topicPartRegInfoMap);
      }
      final Partition partition=new Partition(loadBalanceListener.consumerConfig.getPartition());
      final long offset=loadBalanceListener.consumerConfig.getOffset();
      final TopicPartitionRegInfo regInfo=new TopicPartitionRegInfo(topic,partition,offset);
      topicPartRegInfoMap.put(partition,regInfo);
      loadBalanceListener.fetchManager.addFetchRequest(new FetchRequest(new Broker(0,loadBalanceListener.consumerConfig.getServerUrl()),0L,regInfo,subInfo.getMaxSize()));
    }
    loadBalanceListener.fetchManager.startFetchRunner();
  }
 else {
    ZkUtils.createEphemeralPathExpectConflict(this.zkClient,dirs.consumerRegistryDir + ""String_Node_Str"" + loadBalanceListener.consumerIdString,topicString);
    this.zkClient.subscribeChildChanges(dirs.consumerRegistryDir,loadBalanceListener);
    for (    final String topic : loadBalanceListener.topicSubcriberRegistry.keySet()) {
      final String partitionPath=this.metaZookeeper.brokerTopicsPath + ""String_Node_Str"" + topic;
      ZkUtils.makeSurePersistentPathExists(this.zkClient,partitionPath);
      this.zkClient.subscribeChildChanges(partitionPath,loadBalanceListener);
    }
    this.zkClient.subscribeStateChanges(new ZKSessionExpireListenner(loadBalanceListener));
    loadBalanceListener.syncedRebalance();
  }
  return loadBalanceListener;
}","protected ZKLoadRebalanceListener registerConsumerInternal(final ZKLoadRebalanceListener loadBalanceListener) throws UnknownHostException, InterruptedException, Exception {
  final ZKGroupDirs dirs=this.metaZookeeper.new ZKGroupDirs(loadBalanceListener.consumerConfig.getGroup());
  final String topicString=this.getTopicsString(loadBalanceListener.topicSubcriberRegistry);
  if (this.zkClient == null) {
    loadBalanceListener.fetchManager.stopFetchRunner();
    loadBalanceListener.fetchManager.resetFetchState();
    for (    final String topic : loadBalanceListener.topicSubcriberRegistry.keySet()) {
      final SubscriberInfo subInfo=loadBalanceListener.topicSubcriberRegistry.get(topic);
      ConcurrentHashMap<Partition,TopicPartitionRegInfo> topicPartRegInfoMap=loadBalanceListener.topicRegistry.get(topic);
      if (topicPartRegInfoMap == null) {
        topicPartRegInfoMap=new ConcurrentHashMap<Partition,TopicPartitionRegInfo>();
        loadBalanceListener.topicRegistry.put(topic,topicPartRegInfoMap);
      }
      final Partition partition=new Partition(loadBalanceListener.consumerConfig.getPartition());
      final long offset=loadBalanceListener.consumerConfig.getOffset();
      final TopicPartitionRegInfo regInfo=new TopicPartitionRegInfo(topic,partition,offset);
      topicPartRegInfoMap.put(partition,regInfo);
      loadBalanceListener.fetchManager.addFetchRequest(new FetchRequest(new Broker(0,loadBalanceListener.consumerConfig.getServerUrl()),0L,regInfo,subInfo.getMaxSize()));
    }
    loadBalanceListener.fetchManager.startFetchRunner();
  }
 else {
    ZkUtils.createEphemeralPathExpectConflict(this.zkClient,dirs.consumerRegistryDir + ""String_Node_Str"" + loadBalanceListener.consumerIdString,topicString);
    this.zkClient.subscribeChildChanges(dirs.consumerRegistryDir,loadBalanceListener);
    for (    final String topic : loadBalanceListener.topicSubcriberRegistry.keySet()) {
      final String partitionPath=this.metaZookeeper.brokerTopicsSubPath + ""String_Node_Str"" + topic;
      ZkUtils.makeSurePersistentPathExists(this.zkClient,partitionPath);
      this.zkClient.subscribeChildChanges(partitionPath,loadBalanceListener);
    }
    this.zkClient.subscribeStateChanges(new ZKSessionExpireListenner(loadBalanceListener));
    loadBalanceListener.syncedRebalance();
  }
  return loadBalanceListener;
}",0.9993610223642172
8169,"@Override public synchronized void shutdown() throws MetaClientException {
  if (this.fetchManager.isShutdown()) {
    return;
  }
  try {
    this.fetchManager.stopFetchRunner();
    this.consumerZooKeeper.unRegisterConsumer(this.fetchManager);
  }
 catch (  final InterruptedException e) {
    Thread.currentThread().interrupt();
  }
 finally {
    this.scheduledExecutorService.shutdownNow();
    this.offsetStorage.close();
    this.subscribeInfoManager.removeGroup(this.consumerConfig.getGroup());
    this.messageSessionFactory.removeChild(this);
  }
}","@Override public synchronized void shutdown() throws MetaClientException {
  if (this.fetchManager.isShutdown()) {
    return;
  }
  try {
    this.fetchManager.stopFetchRunner();
    this.consumerZooKeeper.unRegisterConsumer(this.fetchManager);
    for (    String topic : this.publishedTopics) {
      this.producerZooKeeper.unPublishTopic(topic,this);
    }
  }
 catch (  final InterruptedException e) {
    Thread.currentThread().interrupt();
  }
 finally {
    this.scheduledExecutorService.shutdownNow();
    this.offsetStorage.close();
    this.subscribeInfoManager.removeGroup(this.consumerConfig.getGroup());
    this.messageSessionFactory.removeChild(this);
  }
}",0.9065800162469536
8170,"/** 
 * ����Ĭ��topic������
 * @param topic
 */
public synchronized void setDefaultTopic(final String topic){
  if (this.defaultTopic != null && !this.defaultTopic.equals(topic)) {
    throw new IllegalStateException(""String_Node_Str"" + this.defaultTopic);
  }
  this.defaultTopic=topic;
  this.publishTopic(topic);
}","/** 
 * ����Ĭ��topic������
 * @param topic
 */
public synchronized void setDefaultTopic(final String topic,Object ref){
  if (this.defaultTopic != null && !this.defaultTopic.equals(topic)) {
    throw new IllegalStateException(""String_Node_Str"" + this.defaultTopic);
  }
  this.defaultTopic=topic;
  this.publishTopic(topic,ref);
}",0.9768160741885626
8171,"private void publishTopicInternal(final String topic,final BrokerConnectionListener listener) throws Exception, NotifyRemotingException, InterruptedException {
  final String partitionPath=this.metaZookeeper.brokerTopicsPath + ""String_Node_Str"" + topic;
  ZkUtils.makeSurePersistentPathExists(ProducerZooKeeper.this.zkClient,partitionPath);
  ProducerZooKeeper.this.zkClient.subscribeChildChanges(partitionPath,listener);
  listener.syncedUpdateBrokersInfo();
}","private void publishTopicInternal(final String topic,final BrokerConnectionListener listener) throws Exception, NotifyRemotingException, InterruptedException {
  final String partitionPath=this.metaZookeeper.brokerTopicsPubPath + ""String_Node_Str"" + topic;
  ZkUtils.makeSurePersistentPathExists(ProducerZooKeeper.this.zkClient,partitionPath);
  ProducerZooKeeper.this.zkClient.subscribeChildChanges(partitionPath,listener);
  listener.syncedUpdateBrokersInfo();
}",0.9967567567567568
8172,"public void publishTopic(final String topic){
  if (this.topicConnectionListeners.get(topic) != null) {
    return;
  }
  final FutureTask<BrokerConnectionListener> task=new FutureTask<BrokerConnectionListener>(new Callable<BrokerConnectionListener>(){
    @Override public BrokerConnectionListener call() throws Exception {
      final BrokerConnectionListener listener=new BrokerConnectionListener(topic);
      if (ProducerZooKeeper.this.zkClient != null) {
        ProducerZooKeeper.this.publishTopicInternal(topic,listener);
      }
      return listener;
    }
  }
);
  final FutureTask<BrokerConnectionListener> existsTask=this.topicConnectionListeners.putIfAbsent(topic,task);
  if (existsTask == null) {
    task.run();
  }
}","public void publishTopic(final String topic,final Object ref){
  if (this.topicConnectionListeners.get(topic) != null) {
    this.addRef(topic,ref);
    return;
  }
  final FutureTask<BrokerConnectionListener> task=new FutureTask<BrokerConnectionListener>(new Callable<BrokerConnectionListener>(){
    @Override public BrokerConnectionListener call() throws Exception {
      final BrokerConnectionListener listener=new BrokerConnectionListener(topic);
      if (ProducerZooKeeper.this.zkClient != null) {
        ProducerZooKeeper.this.publishTopicInternal(topic,listener);
      }
      listener.references.add(ref);
      return listener;
    }
  }
);
  final FutureTask<BrokerConnectionListener> existsTask=this.topicConnectionListeners.putIfAbsent(topic,task);
  if (existsTask == null) {
    task.run();
  }
 else {
    this.addRef(topic,ref);
  }
}",0.9238514789175584
8173,"@Override public BrokerConnectionListener call() throws Exception {
  final BrokerConnectionListener listener=new BrokerConnectionListener(topic);
  if (ProducerZooKeeper.this.zkClient != null) {
    ProducerZooKeeper.this.publishTopicInternal(topic,listener);
  }
  return listener;
}","@Override public BrokerConnectionListener call() throws Exception {
  final BrokerConnectionListener listener=new BrokerConnectionListener(topic);
  if (ProducerZooKeeper.this.zkClient != null) {
    ProducerZooKeeper.this.publishTopicInternal(topic,listener);
  }
  listener.references.add(ref);
  return listener;
}",0.8970099667774086
8174,"@Override public void setDefaultTopic(final String topic){
  this.producerZooKeeper.setDefaultTopic(topic);
}","@Override public void setDefaultTopic(final String topic){
  if (!this.publishedTopics.contains(topic)) {
    this.producerZooKeeper.setDefaultTopic(topic,this);
    this.publishedTopics.add(topic);
  }
}",0.6964856230031949
8175,"@Override public void publish(final String topic){
  this.checkState();
  this.checkTopic(topic);
  this.producerZooKeeper.publishTopic(topic);
}","@Override public void publish(final String topic){
  this.checkState();
  this.checkTopic(topic);
  if (!this.publishedTopics.contains(topic)) {
    this.producerZooKeeper.publishTopic(topic,this);
    this.publishedTopics.add(topic);
  }
}",0.7376623376623377
8176,"@Override public synchronized void shutdown() throws MetaClientException {
  if (this.shutdown) {
    return;
  }
  this.shutdown=true;
  this.messageSessionFactory.removeChild(this);
}","@Override public synchronized void shutdown() throws MetaClientException {
  if (this.shutdown) {
    return;
  }
  for (  String topic : this.publishedTopics) {
    this.producerZooKeeper.unPublishTopic(topic,this);
  }
  this.shutdown=true;
  this.publishedTopics.clear();
  this.messageSessionFactory.removeChild(this);
}",0.7269155206286837
8177,"@Test public void testGet() throws Exception {
  final String topic=""String_Node_Str"";
  final int maxSize=1024;
  final Partition partition=new Partition(""String_Node_Str"");
  final long offset=12;
  final byte[] data=""String_Node_Str"".getBytes();
  final String url=""String_Node_Str"";
  final MessageIterator messageIterator=new MessageIterator(topic,data);
  this.producerZooKeeper.publishTopic(topic);
  EasyMock.expectLastCall();
  EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
  EasyMock.expect(this.remotingClient.invokeToGroup(url,new GetCommand(topic,this.consumerConfig.getGroup(),partition.getPartition(),offset,maxSize,Integer.MIN_VALUE),10000,TimeUnit.MILLISECONDS)).andReturn(new DataCommand(data,Integer.MIN_VALUE));
  this.mocksControl.replay();
  OpaqueGenerator.resetOpaque();
  assertEquals(messageIterator,this.consumer.get(topic,partition,offset,maxSize));
  this.mocksControl.verify();
}","@Test public void testGet() throws Exception {
  final String topic=""String_Node_Str"";
  final int maxSize=1024;
  final Partition partition=new Partition(""String_Node_Str"");
  final long offset=12;
  final byte[] data=""String_Node_Str"".getBytes();
  final String url=""String_Node_Str"";
  final MessageIterator messageIterator=new MessageIterator(topic,data);
  this.producerZooKeeper.publishTopic(topic,this.consumer);
  EasyMock.expectLastCall();
  EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
  EasyMock.expect(this.remotingClient.invokeToGroup(url,new GetCommand(topic,this.consumerConfig.getGroup(),partition.getPartition(),offset,maxSize,Integer.MIN_VALUE),10000,TimeUnit.MILLISECONDS)).andReturn(new DataCommand(data,Integer.MIN_VALUE));
  this.mocksControl.replay();
  OpaqueGenerator.resetOpaque();
  assertEquals(messageIterator,this.consumer.get(topic,partition,offset,maxSize));
  this.mocksControl.verify();
}",0.9926778242677824
8178,"@Test public void testGetNotFound() throws Exception {
  final String topic=""String_Node_Str"";
  final int maxSize=1024;
  final Partition partition=new Partition(""String_Node_Str"");
  final long offset=12;
  final String url=""String_Node_Str"";
  this.producerZooKeeper.publishTopic(topic);
  EasyMock.expectLastCall();
  EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
  EasyMock.expect(this.remotingClient.invokeToGroup(url,new GetCommand(topic,this.consumerConfig.getGroup(),partition.getPartition(),offset,maxSize,Integer.MIN_VALUE),10000,TimeUnit.MILLISECONDS)).andReturn(new BooleanCommand(Integer.MIN_VALUE,404,""String_Node_Str""));
  this.mocksControl.replay();
  OpaqueGenerator.resetOpaque();
  assertNull(this.consumer.get(topic,partition,offset,maxSize));
  this.mocksControl.verify();
}","@Test public void testGetNotFound() throws Exception {
  final String topic=""String_Node_Str"";
  final int maxSize=1024;
  final Partition partition=new Partition(""String_Node_Str"");
  final long offset=12;
  final String url=""String_Node_Str"";
  this.producerZooKeeper.publishTopic(topic,this.consumer);
  EasyMock.expectLastCall();
  EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
  EasyMock.expect(this.remotingClient.invokeToGroup(url,new GetCommand(topic,this.consumerConfig.getGroup(),partition.getPartition(),offset,maxSize,Integer.MIN_VALUE),10000,TimeUnit.MILLISECONDS)).andReturn(new BooleanCommand(Integer.MIN_VALUE,404,""String_Node_Str""));
  this.mocksControl.replay();
  OpaqueGenerator.resetOpaque();
  assertNull(this.consumer.get(topic,partition,offset,maxSize));
  this.mocksControl.verify();
}",0.9916963226571768
8179,"@Test public void testGetFailed() throws Exception {
  final String topic=""String_Node_Str"";
  final int maxSize=1024;
  final Partition partition=new Partition(""String_Node_Str"");
  final long offset=12;
  final byte[] data=""String_Node_Str"".getBytes();
  final String url=""String_Node_Str"";
  final MessageIterator messageIterator=new MessageIterator(topic,data);
  this.producerZooKeeper.publishTopic(topic);
  EasyMock.expectLastCall();
  EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
  EasyMock.expect(this.remotingClient.invokeToGroup(url,new GetCommand(topic,this.consumerConfig.getGroup(),partition.getPartition(),offset,maxSize,Integer.MIN_VALUE),10000,TimeUnit.MILLISECONDS)).andReturn(new BooleanCommand(Integer.MIN_VALUE,500,""String_Node_Str""));
  this.mocksControl.replay();
  try {
    OpaqueGenerator.resetOpaque();
    assertEquals(messageIterator,this.consumer.get(topic,partition,offset,maxSize));
    fail();
  }
 catch (  final MetaClientException e) {
  }
  this.mocksControl.verify();
}","@Test public void testGetFailed() throws Exception {
  final String topic=""String_Node_Str"";
  final int maxSize=1024;
  final Partition partition=new Partition(""String_Node_Str"");
  final long offset=12;
  final byte[] data=""String_Node_Str"".getBytes();
  final String url=""String_Node_Str"";
  final MessageIterator messageIterator=new MessageIterator(topic,data);
  this.producerZooKeeper.publishTopic(topic,this.consumer);
  EasyMock.expectLastCall();
  EasyMock.expect(this.producerZooKeeper.selectBroker(topic,partition)).andReturn(url);
  EasyMock.expect(this.remotingClient.invokeToGroup(url,new GetCommand(topic,this.consumerConfig.getGroup(),partition.getPartition(),offset,maxSize,Integer.MIN_VALUE),10000,TimeUnit.MILLISECONDS)).andReturn(new BooleanCommand(Integer.MIN_VALUE,500,""String_Node_Str""));
  this.mocksControl.replay();
  try {
    OpaqueGenerator.resetOpaque();
    assertEquals(messageIterator,this.consumer.get(topic,partition,offset,maxSize));
    fail();
  }
 catch (  final MetaClientException e) {
  }
  this.mocksControl.verify();
}",0.9933649289099526
8180,"private Map<InetSocketAddress,StatsResult> getStats0(InetSocketAddress target,String item) throws InterruptedException {
  Set<String> groups=remotingClient.getGroupSet();
  if (groups == null || groups.size() <= 1) {
    return Collections.emptyMap();
  }
  Map<InetSocketAddress,StatsResult> rt=new HashMap<InetSocketAddress,StatsResult>();
  try {
    for (    String group : groups) {
      if (!group.equals(Constants.DEFAULT_GROUP)) {
        URI uri=new URI(group);
        InetSocketAddress sockAddr=new InetSocketAddress(uri.getHost(),uri.getPort());
        if (target == null || target.equals(sockAddr)) {
          BooleanCommand resp=(BooleanCommand)remotingClient.invokeToGroup(group,new StatsCommand(OpaqueGenerator.getNextOpaque(),item),STATS_OPTIMEOUT,TimeUnit.MILLISECONDS);
          if (resp.getResponseStatus() == ResponseStatus.NO_ERROR) {
            String body=resp.getErrorMsg();
            if (body != null) {
              parseStatsValues(sockAddr,rt,group,body);
            }
          }
        }
      }
    }
    return rt;
  }
 catch (  InterruptedException e) {
    throw e;
  }
catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}","private Map<InetSocketAddress,StatsResult> getStats0(InetSocketAddress target,String item) throws InterruptedException {
  Set<String> groups=this.remotingClient.getGroupSet();
  if (groups == null || groups.size() <= 1) {
    return Collections.emptyMap();
  }
  Map<InetSocketAddress,StatsResult> rt=new HashMap<InetSocketAddress,StatsResult>();
  try {
    for (    String group : groups) {
      if (!group.equals(Constants.DEFAULT_GROUP)) {
        URI uri=new URI(group);
        InetSocketAddress sockAddr=new InetSocketAddress(uri.getHost(),uri.getPort());
        if (target == null || target.equals(sockAddr)) {
          BooleanCommand resp=(BooleanCommand)this.remotingClient.invokeToGroup(group,new StatsCommand(OpaqueGenerator.getNextOpaque(),item),STATS_OPTIMEOUT,TimeUnit.MILLISECONDS);
          if (resp.getResponseStatus() == ResponseStatus.NO_ERROR) {
            String body=resp.getErrorMsg();
            if (body != null) {
              this.parseStatsValues(sockAddr,rt,group,body);
            }
          }
        }
      }
    }
    return rt;
  }
 catch (  InterruptedException e) {
    throw e;
  }
catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}",0.9938042131350682
8181,"/** 
 * ���������ߺ�zk����������
 * @return
 */
public ProducerZooKeeper getProducerZooKeeper(){
  return producerZooKeeper;
}","/** 
 * ���������ߺ�zk����������
 * @return
 */
public ProducerZooKeeper getProducerZooKeeper(){
  return this.producerZooKeeper;
}",0.9803921568627452
8182,"@Override @Deprecated public MessageProducer createProducer(final PartitionSelector partitionSelector,final boolean ordered){
  if (partitionSelector == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return this.addChild(new SimpleMessageProducer(this,remotingClient,partitionSelector,producerZooKeeper,sessionIdGenerator.generateId()));
}","@Override @Deprecated public MessageProducer createProducer(final PartitionSelector partitionSelector,final boolean ordered){
  if (partitionSelector == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return this.addChild(new SimpleMessageProducer(this,this.remotingClient,partitionSelector,this.producerZooKeeper,this.sessionIdGenerator.generateId()));
}",0.9798657718120806
8183,"/** 
 * ɾ���ӻỰ
 * @param < T >
 * @param child
 */
public <T extends Shutdownable>void removeChild(final T child){
  children.remove(child);
}","/** 
 * ɾ���ӻỰ
 * @param < T >
 * @param child
 */
public <T extends Shutdownable>void removeChild(final T child){
  this.children.remove(child);
}",0.9826989619377162
8184,"@Override public void run(){
  try {
    isHutdownHookCalled=true;
    MetaMessageSessionFactory.this.shutdown();
  }
 catch (  final MetaClientException e) {
    log.error(""String_Node_Str"",e);
  }
}","@Override public void run(){
  try {
    MetaMessageSessionFactory.this.isHutdownHookCalled=true;
    MetaMessageSessionFactory.this.shutdown();
  }
 catch (  final MetaClientException e) {
    log.error(""String_Node_Str"",e);
  }
}",0.9280742459396752
8185,"private synchronized MessageConsumer createConsumer0(final ConsumerConfig consumerConfig,final OffsetStorage offsetStorage,final RecoverManager recoverManager0){
  if (consumerConfig.getServerUrl() == null) {
    consumerConfig.setServerUrl(metaClientConfig.getServerUrl());
  }
  if (offsetStorage == null) {
    throw new InvalidOffsetStorageException(""String_Node_Str"");
  }
  if (!recoverManager0.isStarted()) {
    recoverManager0.start(metaClientConfig);
  }
  checkConsumerConfig(consumerConfig);
  return this.addChild(new SimpleMessageConsumer(this,remotingClient,consumerConfig,consumerZooKeeper,producerZooKeeper,subscribeInfoManager,recoverManager0,offsetStorage,createLoadBalanceStrategy(consumerConfig)));
}","private synchronized MessageConsumer createConsumer0(final ConsumerConfig consumerConfig,final OffsetStorage offsetStorage,final RecoverManager recoverManager0){
  if (consumerConfig.getServerUrl() == null) {
    consumerConfig.setServerUrl(this.metaClientConfig.getServerUrl());
  }
  if (offsetStorage == null) {
    throw new InvalidOffsetStorageException(""String_Node_Str"");
  }
  if (!recoverManager0.isStarted()) {
    recoverManager0.start(this.metaClientConfig);
  }
  this.checkConsumerConfig(consumerConfig);
  return this.addChild(new SimpleMessageConsumer(this,this.remotingClient,consumerConfig,this.consumerZooKeeper,this.producerZooKeeper,this.subscribeInfoManager,recoverManager0,offsetStorage,this.createLoadBalanceStrategy(consumerConfig)));
}",0.9325236167341432
8186,"private void initZooKeeper() throws MetaClientException {
  zkConfig=null;
  if (metaClientConfig.getZkConfig() != null) {
    zkConfig=metaClientConfig.getZkConfig();
  }
 else {
    zkConfig=loadZkConfigFromDiamond();
  }
  if (zkConfig != null) {
    zkClient=new ZkClient(zkConfig.zkConnect,zkConfig.zkSessionTimeoutMs,zkConfig.zkConnectionTimeoutMs,new ZkUtils.StringSerializer());
    metaZookeeper=new MetaZookeeper(zkClient,zkConfig.zkRoot);
  }
 else {
    throw new MetaClientException(""String_Node_Str"");
  }
}","private void initZooKeeper() throws MetaClientException {
  this.zkConfig=null;
  if (this.metaClientConfig.getZkConfig() != null) {
    this.zkConfig=this.metaClientConfig.getZkConfig();
  }
 else {
    this.zkConfig=this.loadZkConfigFromDiamond();
  }
  if (this.zkConfig != null) {
    this.zkClient=new ZkClient(this.zkConfig.zkConnect,this.zkConfig.zkSessionTimeoutMs,this.zkConfig.zkConnectionTimeoutMs,new ZkUtils.StringSerializer());
    this.metaZookeeper=new MetaZookeeper(this.zkClient,this.zkConfig.zkRoot);
  }
 else {
    throw new MetaClientException(""String_Node_Str"");
  }
}",0.9046762589928058
8187,"private void connectServer(final MetaClientConfig metaClientConfig) throws NetworkException {
  try {
    remotingClient.connect(metaClientConfig.getServerUrl());
    remotingClient.awaitReadyInterrupt(metaClientConfig.getServerUrl());
  }
 catch (  final NotifyRemotingException e) {
    throw new NetworkException(""String_Node_Str"" + metaClientConfig.getServerUrl() + ""String_Node_Str"",e);
  }
catch (  final InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}","private void connectServer(final MetaClientConfig metaClientConfig) throws NetworkException {
  try {
    this.remotingClient.connect(metaClientConfig.getServerUrl());
    this.remotingClient.awaitReadyInterrupt(metaClientConfig.getServerUrl());
  }
 catch (  final NotifyRemotingException e) {
    throw new NetworkException(""String_Node_Str"" + metaClientConfig.getServerUrl() + ""String_Node_Str"",e);
  }
catch (  final InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}",0.9897330595482546
8188,"/** 
 * ���������ߺ�zk����������
 * @return
 */
public ConsumerZooKeeper getConsumerZooKeeper(){
  return consumerZooKeeper;
}","/** 
 * ���������ߺ�zk����������
 * @return
 */
public ConsumerZooKeeper getConsumerZooKeeper(){
  return this.consumerZooKeeper;
}",0.9803921568627452
8189,"/** 
 * ����ͨѶ�ͻ���
 * @return
 */
public RemotingClientWrapper getRemotingClient(){
  return remotingClient;
}","/** 
 * ����ͨѶ�ͻ���
 * @return
 */
public RemotingClientWrapper getRemotingClient(){
  return this.remotingClient;
}",0.9779735682819384
8190,"/** 
 * ���ض��Ĺ�ϵ������
 * @return
 */
public SubscribeInfoManager getSubscribeInfoManager(){
  return subscribeInfoManager;
}","/** 
 * ���ض��Ĺ�ϵ������
 * @return
 */
public SubscribeInfoManager getSubscribeInfoManager(){
  return this.subscribeInfoManager;
}",0.980544747081712
8191,"/** 
 * ���ر��ػָ���Ϣ������
 * @return
 */
public RecoverManager getRecoverStorageManager(){
  return recoverManager;
}","/** 
 * ���ر��ػָ���Ϣ������
 * @return
 */
public RecoverManager getRecoverStorageManager(){
  return this.recoverManager;
}",0.979253112033195
8192,"/** 
 * ���ش˹��������������Ӷ����������ߡ������ߵ�
 * @return
 */
public CopyOnWriteArrayList<Shutdownable> getChildren(){
  return children;
}","/** 
 * ���ش˹��������������Ӷ����������ߡ������ߵ�
 * @return
 */
public CopyOnWriteArrayList<Shutdownable> getChildren(){
  return this.children;
}",0.9824561403508772
8193,"protected ConsumerZooKeeper initConsumerZooKeeper(final RemotingClientWrapper remotingClientWrapper,final ZkClient zkClient2,final ZKConfig config){
  return new ConsumerZooKeeper(metaZookeeper,remotingClient,zkClient,zkConfig);
}","protected ConsumerZooKeeper initConsumerZooKeeper(final RemotingClientWrapper remotingClientWrapper,final ZkClient zkClient2,final ZKConfig config){
  return new ConsumerZooKeeper(this.metaZookeeper,this.remotingClient,this.zkClient,this.zkConfig);
}",0.8375
8194,"/** 
 * ���ؿͻ�������
 * @return
 */
public MetaClientConfig getMetaClientConfig(){
  return metaClientConfig;
}","/** 
 * ���ؿͻ�������
 * @return
 */
public MetaClientConfig getMetaClientConfig(){
  return this.metaClientConfig;
}",0.9779735682819384
8195,"public MetaMessageSessionFactory(final MetaClientConfig metaClientConfig) throws MetaClientException {
  super();
  checkConfig(metaClientConfig);
  this.metaClientConfig=metaClientConfig;
  final ClientConfig clientConfig=new ClientConfig();
  clientConfig.setTcpNoDelay(false);
  clientConfig.setWireFormatType(new MetamorphosisWireFormatType());
  clientConfig.setMaxScheduleWrittenBytes(Runtime.getRuntime().maxMemory() / 3);
  try {
    remotingClient=new RemotingClientWrapper(RemotingFactory.connect(clientConfig));
  }
 catch (  final NotifyRemotingException e) {
    throw new NetworkException(""String_Node_Str"",e);
  }
  if (this.metaClientConfig.getServerUrl() != null) {
    connectServer(this.metaClientConfig);
  }
 else {
    initZooKeeper();
  }
  producerZooKeeper=new ProducerZooKeeper(metaZookeeper,remotingClient,zkClient,metaClientConfig);
  sessionIdGenerator=new IdGenerator();
  consumerZooKeeper=initConsumerZooKeeper(remotingClient,zkClient,zkConfig);
  zkClientChangedListeners.add(producerZooKeeper);
  zkClientChangedListeners.add(consumerZooKeeper);
  subscribeInfoManager=new SubscribeInfoManager();
  recoverManager=new RecoverStorageManager(this.metaClientConfig,subscribeInfoManager);
  shutdownHook=new Thread(){
    @Override public void run(){
      try {
        isHutdownHookCalled=true;
        MetaMessageSessionFactory.this.shutdown();
      }
 catch (      final MetaClientException e) {
        log.error(""String_Node_Str"",e);
      }
    }
  }
;
  Runtime.getRuntime().addShutdownHook(shutdownHook);
}","public MetaMessageSessionFactory(final MetaClientConfig metaClientConfig) throws MetaClientException {
  super();
  this.checkConfig(metaClientConfig);
  this.metaClientConfig=metaClientConfig;
  final ClientConfig clientConfig=new ClientConfig();
  clientConfig.setTcpNoDelay(false);
  clientConfig.setWireFormatType(new MetamorphosisWireFormatType());
  clientConfig.setMaxScheduleWrittenBytes(Runtime.getRuntime().maxMemory() / 3);
  try {
    this.remotingClient=new RemotingClientWrapper(RemotingFactory.connect(clientConfig));
  }
 catch (  final NotifyRemotingException e) {
    throw new NetworkException(""String_Node_Str"",e);
  }
  if (this.metaClientConfig.getServerUrl() != null) {
    this.connectServer(this.metaClientConfig);
  }
 else {
    this.initZooKeeper();
  }
  this.producerZooKeeper=new ProducerZooKeeper(this.metaZookeeper,this.remotingClient,this.zkClient,metaClientConfig);
  this.sessionIdGenerator=new IdGenerator();
  this.consumerZooKeeper=this.initConsumerZooKeeper(this.remotingClient,this.zkClient,this.zkConfig);
  this.zkClientChangedListeners.add(this.producerZooKeeper);
  this.zkClientChangedListeners.add(this.consumerZooKeeper);
  this.subscribeInfoManager=new SubscribeInfoManager();
  this.recoverManager=new RecoverStorageManager(this.metaClientConfig,this.subscribeInfoManager);
  this.shutdownHook=new Thread(){
    @Override public void run(){
      try {
        MetaMessageSessionFactory.this.isHutdownHookCalled=true;
        MetaMessageSessionFactory.this.shutdown();
      }
 catch (      final MetaClientException e) {
        log.error(""String_Node_Str"",e);
      }
    }
  }
;
  Runtime.getRuntime().addShutdownHook(this.shutdownHook);
}",0.95491043854231
8196,"protected <T extends Shutdownable>T addChild(final T child){
  children.add(child);
  return child;
}","protected <T extends Shutdownable>T addChild(final T child){
  this.children.add(child);
  return child;
}",0.9758454106280192
8197,"@Override public void shutdown() throws MetaClientException {
  if (shutdown) {
    return;
  }
  shutdown=true;
  recoverManager.shutdown();
  for (  final Shutdownable child : children) {
    child.shutdown();
  }
  try {
    remotingClient.stop();
  }
 catch (  final NotifyRemotingException e) {
    throw new NetworkException(""String_Node_Str"",e);
  }
  if (zkClient != null) {
    zkClient.close();
  }
  if (!isHutdownHookCalled) {
    Runtime.getRuntime().removeShutdownHook(shutdownHook);
  }
}","@Override public void shutdown() throws MetaClientException {
  if (this.shutdown) {
    return;
  }
  this.shutdown=true;
  this.recoverManager.shutdown();
  for (  final Shutdownable child : this.children) {
    child.shutdown();
  }
  try {
    this.remotingClient.stop();
  }
 catch (  final NotifyRemotingException e) {
    throw new NetworkException(""String_Node_Str"",e);
  }
  if (this.zkClient != null) {
    this.zkClient.close();
  }
  if (!this.isHutdownHookCalled) {
    Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
  }
}",0.9000951474785919
8198,"@Override public StatsResult getStats(InetSocketAddress target) throws InterruptedException {
  return this.getStats(null,null);
}","@Override public StatsResult getStats(InetSocketAddress target) throws InterruptedException {
  return this.getStats(target,null);
}",0.9618320610687024
8199,"private Map<InetSocketAddress,StatsResult> getStats0(InetSocketAddress target,String item) throws InterruptedException {
  Set<String> groups=remotingClient.getGroupSet();
  if (groups == null || groups.size() <= 1) {
    return Collections.emptyMap();
  }
  Map<InetSocketAddress,StatsResult> rt=new HashMap<InetSocketAddress,StatsResult>();
  try {
    for (    String group : groups) {
      if (!group.equals(Constants.DEFAULT_GROUP)) {
        URI uri=new URI(group);
        InetSocketAddress sockAddr=new InetSocketAddress(uri.getHost(),uri.getPort());
        if (target == null || target.equals(sockAddr)) {
          BooleanCommand resp=(BooleanCommand)remotingClient.invokeToGroup(group,new StatsCommand(OpaqueGenerator.getNextOpaque(),item));
          if (resp.getResponseStatus() == ResponseStatus.NO_ERROR) {
            String body=resp.getErrorMsg();
            if (body != null) {
              parseStatsValues(sockAddr,rt,group,body);
            }
          }
        }
      }
    }
    return rt;
  }
 catch (  InterruptedException e) {
    throw e;
  }
catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}","private Map<InetSocketAddress,StatsResult> getStats0(InetSocketAddress target,String item) throws InterruptedException {
  Set<String> groups=remotingClient.getGroupSet();
  if (groups == null || groups.size() <= 1) {
    return Collections.emptyMap();
  }
  Map<InetSocketAddress,StatsResult> rt=new HashMap<InetSocketAddress,StatsResult>();
  try {
    for (    String group : groups) {
      if (!group.equals(Constants.DEFAULT_GROUP)) {
        URI uri=new URI(group);
        InetSocketAddress sockAddr=new InetSocketAddress(uri.getHost(),uri.getPort());
        if (target == null || target.equals(sockAddr)) {
          BooleanCommand resp=(BooleanCommand)remotingClient.invokeToGroup(group,new StatsCommand(OpaqueGenerator.getNextOpaque(),item),STATS_OPTIMEOUT,TimeUnit.MILLISECONDS);
          if (resp.getResponseStatus() == ResponseStatus.NO_ERROR) {
            String body=resp.getErrorMsg();
            if (body != null) {
              parseStatsValues(sockAddr,rt,group,body);
            }
          }
        }
      }
    }
    return rt;
  }
 catch (  InterruptedException e) {
    throw e;
  }
catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"",e);
  }
}",0.9839527027027029
8200,"@Test(expected=InvalidConsumerConfigException.class) public void testCreateConsumer_NoGroup() throws Exception {
  final ConsumerConfig consumerConfig=new ConsumerConfig();
  final MessageConsumer messageConsumer=this.messageSessionFactory.createConsumer(consumerConfig);
}","@Test(expected=InvalidConsumerConfigException.class) public void testCreateConsumer_NoGroup() throws Exception {
  final ConsumerConfig consumerConfig=new ConsumerConfig();
  final MessageConsumer messageConsumer=messageSessionFactory.createConsumer(consumerConfig);
}",0.9907578558225508
8201,"@Test public void testCreateProducer() throws Exception {
  final MessageProducer producer=this.messageSessionFactory.createProducer();
  assertNotNull(producer);
  assertTrue(producer.getPartitionSelector() instanceof RoundRobinPartitionSelector);
  assertFalse(producer.isOrdered());
  assertTrue(this.messageSessionFactory.getChildren().contains(producer));
  producer.shutdown();
  assertFalse(this.messageSessionFactory.getChildren().contains(producer));
}","@Test public void testCreateProducer() throws Exception {
  final MessageProducer producer=messageSessionFactory.createProducer();
  assertNotNull(producer);
  assertTrue(producer.getPartitionSelector() instanceof RoundRobinPartitionSelector);
  assertFalse(producer.isOrdered());
  assertTrue(messageSessionFactory.getChildren().contains(producer));
  producer.shutdown();
  assertFalse(messageSessionFactory.getChildren().contains(producer));
}",0.9834619625137816
8202,"@Test(expected=InvalidConsumerConfigException.class) public void testCreateConsumer_InvalidThreadCount() throws Exception {
  final ConsumerConfig consumerConfig=new ConsumerConfig();
  consumerConfig.setGroup(""String_Node_Str"");
  consumerConfig.setFetchRunnerCount(0);
  final MessageConsumer messageConsumer=this.messageSessionFactory.createConsumer(consumerConfig);
}","@Test(expected=InvalidConsumerConfigException.class) public void testCreateConsumer_InvalidThreadCount() throws Exception {
  final ConsumerConfig consumerConfig=new ConsumerConfig();
  consumerConfig.setGroup(""String_Node_Str"");
  consumerConfig.setFetchRunnerCount(0);
  final MessageConsumer messageConsumer=messageSessionFactory.createConsumer(consumerConfig);
}",0.9932157394843962
8203,"@Test(expected=IllegalArgumentException.class) public void testCreateConsumer_InvalidFetchTimeout() throws Exception {
  final ConsumerConfig consumerConfig=new ConsumerConfig();
  consumerConfig.setGroup(""String_Node_Str"");
  consumerConfig.setFetchTimeoutInMills(0);
  final MessageConsumer messageConsumer=this.messageSessionFactory.createConsumer(consumerConfig);
}","@Test(expected=IllegalArgumentException.class) public void testCreateConsumer_InvalidFetchTimeout() throws Exception {
  final ConsumerConfig consumerConfig=new ConsumerConfig();
  consumerConfig.setGroup(""String_Node_Str"");
  consumerConfig.setFetchTimeoutInMills(0);
  final MessageConsumer messageConsumer=messageSessionFactory.createConsumer(consumerConfig);
}",0.9931787175989086
8204,"@Ignore public void testCreateProducerOrdered() throws Exception {
  final MessageProducer producer=this.messageSessionFactory.createProducer(true);
  assertNotNull(producer);
  assertTrue(producer.getPartitionSelector() instanceof RoundRobinPartitionSelector);
  assertTrue(producer.isOrdered());
  assertTrue(this.messageSessionFactory.getChildren().contains(producer));
  producer.shutdown();
  assertFalse(this.messageSessionFactory.getChildren().contains(producer));
}","@Ignore public void testCreateProducerOrdered() throws Exception {
  final MessageProducer producer=messageSessionFactory.createProducer(true);
  assertNotNull(producer);
  assertTrue(producer.getPartitionSelector() instanceof RoundRobinPartitionSelector);
  assertTrue(producer.isOrdered());
  assertTrue(messageSessionFactory.getChildren().contains(producer));
  producer.shutdown();
  assertFalse(messageSessionFactory.getChildren().contains(producer));
}",0.9838882921589688
8205,"@Before public void setUp() throws Exception {
  final MetaClientConfig metaClientConfig=new MetaClientConfig();
  metaClientConfig.setDiamondZKDataId(""String_Node_Str"");
  this.messageSessionFactory=new MetaMessageSessionFactory(metaClientConfig);
}","@Before public void setUp() throws Exception {
  final MetaClientConfig metaClientConfig=new MetaClientConfig();
  metaClientConfig.setDiamondZKDataId(""String_Node_Str"");
  messageSessionFactory=new MetaMessageSessionFactory(metaClientConfig);
}",0.98989898989899
8206,"@Test public void testCreateConsumer() throws Exception {
  final ConsumerConfig consumerConfig=new ConsumerConfig();
  consumerConfig.setGroup(""String_Node_Str"");
  final MessageConsumer messageConsumer=this.messageSessionFactory.createConsumer(consumerConfig);
  assertNotNull(messageConsumer);
  assertTrue(this.messageSessionFactory.getChildren().contains(messageConsumer));
  messageConsumer.shutdown();
  assertFalse(this.messageSessionFactory.getChildren().contains(messageConsumer));
}","@Test public void testCreateConsumer() throws Exception {
  final ConsumerConfig consumerConfig=new ConsumerConfig();
  consumerConfig.setGroup(""String_Node_Str"");
  final MessageConsumer messageConsumer=messageSessionFactory.createConsumer(consumerConfig);
  assertNotNull(messageConsumer);
  assertTrue(messageSessionFactory.getChildren().contains(messageConsumer));
  messageConsumer.shutdown();
  assertFalse(messageSessionFactory.getChildren().contains(messageConsumer));
}",0.5499485066941298
8207,"@Test(expected=IllegalArgumentException.class) public void testCreateConsumer_InvalidCommitOffsetsInterval() throws Exception {
  final ConsumerConfig consumerConfig=new ConsumerConfig();
  consumerConfig.setGroup(""String_Node_Str"");
  consumerConfig.setCommitOffsetPeriodInMills(-1);
  final MessageConsumer messageConsumer=this.messageSessionFactory.createConsumer(consumerConfig);
}","@Test(expected=IllegalArgumentException.class) public void testCreateConsumer_InvalidCommitOffsetsInterval() throws Exception {
  final ConsumerConfig consumerConfig=new ConsumerConfig();
  consumerConfig.setGroup(""String_Node_Str"");
  consumerConfig.setCommitOffsetPeriodInMills(-1);
  final MessageConsumer messageConsumer=messageSessionFactory.createConsumer(consumerConfig);
}",0.9934640522875816
8208,"@After public void tearDown() throws Exception {
  this.messageSessionFactory.shutdown();
}","@After public void tearDown() throws Exception {
  messageSessionFactory.shutdown();
}",0.9717514124293786
8209,"private void onUpgrade(SupportSQLiteDatabase db,Context context,int oldVersion,int newVersion){
  Timber.d(""String_Node_Str"" + oldVersion + ""String_Node_Str""+ newVersion);
switch (oldVersion) {
case 1:
    try {
      db.execSQL(""String_Node_Str"");
    }
 catch (    Exception e) {
    }
case 2:
  try {
    db.execSQL(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
case 3:
case 4:
try {
  db.execSQL(""String_Node_Str"");
}
 catch (Exception e) {
}
case 5:
case 6:
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
case 7:
try {
db.execSQL(ApiAppsModel.CREATE_TABLE);
}
 catch (Exception e) {
}
case 8:
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
case 9:
case 10:
case 11:
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
case 12:
case 13:
db.execSQL(""String_Node_Str"" + KeysColumns.RANK + ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + UserPacketsColumns.RANK + ""String_Node_Str""+ UserPacketsColumns.USER_ID+ ""String_Node_Str""+ UserPacketsColumns.MASTER_KEY_ID+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + CertsColumns.VERIFIED + ""String_Node_Str""+ CertsColumns.MASTER_KEY_ID+ ""String_Node_Str"");
case 14:
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
case 15:
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
case 16:
case 17:
case 18:
db.execSQL(""String_Node_Str"");
case 19:
db.execSQL(""String_Node_Str"");
case 20:
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
case 21:
try {
db.execSQL(""String_Node_Str"");
}
 catch (SQLiteException e) {
}
case 22:
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
case 23:
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
case 24:
{
try {
db.beginTransaction();
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"");
db.setTransactionSuccessful();
}
  finally {
db.endTransaction();
}
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
}
case 25:
{
try {
migrateSecretKeysFromDbToLocalStorage(db,context);
}
 catch (IOException e) {
throw new IllegalStateException(""String_Node_Str"");
}
}
case 26:
migrateUpdatedKeysToKeyMetadataTable(db);
case 27:
renameApiAutocryptPeersTable(db);
case 28:
db.execSQL(""String_Node_Str"");
case 29:
recreateUnifiedKeyView(db);
}
}","private void onUpgrade(SupportSQLiteDatabase db,Context context,int oldVersion,int newVersion){
  Timber.d(""String_Node_Str"" + oldVersion + ""String_Node_Str""+ newVersion);
switch (oldVersion) {
case 1:
    try {
      db.execSQL(""String_Node_Str"");
    }
 catch (    Exception e) {
    }
case 2:
  try {
    db.execSQL(""String_Node_Str"");
  }
 catch (  Exception e) {
  }
case 3:
case 4:
try {
  db.execSQL(""String_Node_Str"");
}
 catch (Exception e) {
}
case 5:
case 6:
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
case 7:
try {
db.execSQL(ApiAppsModel.CREATE_TABLE);
}
 catch (Exception e) {
}
case 8:
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
case 9:
case 10:
case 11:
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
case 12:
case 13:
db.execSQL(""String_Node_Str"" + KeysColumns.RANK + ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + UserPacketsColumns.RANK + ""String_Node_Str""+ UserPacketsColumns.USER_ID+ ""String_Node_Str""+ UserPacketsColumns.MASTER_KEY_ID+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + CertsColumns.VERIFIED + ""String_Node_Str""+ CertsColumns.MASTER_KEY_ID+ ""String_Node_Str"");
case 14:
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
case 15:
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
case 16:
case 17:
case 18:
db.execSQL(""String_Node_Str"");
case 19:
db.execSQL(""String_Node_Str"");
case 20:
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
case 21:
try {
db.execSQL(""String_Node_Str"");
}
 catch (SQLiteException e) {
}
case 22:
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
case 23:
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
case 24:
{
try {
db.beginTransaction();
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
db.execSQL(""String_Node_Str"");
db.setTransactionSuccessful();
}
  finally {
db.endTransaction();
}
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
db.execSQL(""String_Node_Str"");
}
case 25:
{
try {
migrateSecretKeysFromDbToLocalStorage(db,context);
}
 catch (IOException e) {
throw new IllegalStateException(""String_Node_Str"");
}
}
case 26:
migrateUpdatedKeysToKeyMetadataTable(db);
case 27:
renameApiAutocryptPeersTable(db);
case 28:
db.execSQL(""String_Node_Str"");
case 29:
recreateUnifiedKeyView(db);
case 30:
fixKeyExpiries(db);
}
}",0.996172627689059
8210,"private List<AutocryptPeer> getAutocryptPeers(String packageName,String... autocryptId){
  ArrayList<AutocryptPeer> result=new ArrayList<>(autocryptId.length);
  SqlDelightQuery query=AutocryptPeer.FACTORY.selectByIdentifiers(packageName,autocryptId);
  try (Cursor cursor=getReadableDb().query(query)){
    if (cursor.moveToNext()) {
      AutocryptPeer autocryptPeer=AutocryptPeer.PEER_MAPPER.map(cursor);
      result.add(autocryptPeer);
    }
  }
   return result;
}","private List<AutocryptPeer> getAutocryptPeers(String packageName,String... autocryptId){
  SqlDelightQuery query=AutocryptPeer.FACTORY.selectByIdentifiers(packageName,autocryptId);
  return mapAllRows(query,AutocryptPeer.PEER_MAPPER);
}",0.6175637393767706
8211,"public List<AutocryptKeyStatus> getAutocryptKeyStatus(String packageName,String[] autocryptIds){
  ArrayList<AutocryptKeyStatus> result=new ArrayList<>(autocryptIds.length);
  SqlDelightQuery query=AutocryptPeer.FACTORY.selectAutocryptKeyStatus(packageName,autocryptIds,System.currentTimeMillis());
  try (Cursor cursor=getReadableDb().query(query)){
    if (cursor.moveToNext()) {
      AutocryptKeyStatus autocryptPeer=AutocryptPeer.KEY_STATUS_MAPPER.map(cursor);
      result.add(autocryptPeer);
    }
  }
   return result;
}","public List<AutocryptKeyStatus> getAutocryptKeyStatus(String packageName,String[] autocryptIds){
  SqlDelightQuery query=AutocryptPeer.FACTORY.selectAutocryptKeyStatus(packageName,autocryptIds);
  return mapAllRows(query,AutocryptPeer.KEY_STATUS_MAPPER);
}",0.6096938775510204
8212,"@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  if (Pref.KEY_SERVERS.equals(key)) {
    Timber.d(""String_Node_Str"",key);
    String keyServers=sharedPreferences.getString(Pref.KEY_SERVERS,Defaults.KEY_SERVERS);
    String current=keyServers.substring(keyServers.indexOf(','));
    String coarseGranularityKeyserver;
    if (current.contains(""String_Node_Str"")) {
      coarseGranularityKeyserver=""String_Node_Str"";
    }
 else     if (current.contains(""String_Node_Str"")) {
      coarseGranularityKeyserver=""String_Node_Str"";
    }
 else     if (current.contains(""String_Node_Str"")) {
      coarseGranularityKeyserver=""String_Node_Str"";
    }
 else {
      coarseGranularityKeyserver=""String_Node_Str"";
    }
    TrackHelper.track().interaction(""String_Node_Str"" + Pref.KEY_SERVERS,coarseGranularityKeyserver).with(piwikTracker);
    return;
  }
  if (Pref.THEME.equals(key)) {
    String value=sharedPreferences.getString(key,""String_Node_Str"");
    TrackHelper.track().interaction(""String_Node_Str"" + key,value).with(piwikTracker);
    return;
  }
  if (Pref.ANALYTICS_PREFS.contains(key)) {
    Timber.d(""String_Node_Str"",key);
    if (!sharedPreferences.contains(key)) {
      TrackHelper.track().interaction(""String_Node_Str"" + key,""String_Node_Str"").with(piwikTracker);
      return;
    }
    boolean value=sharedPreferences.getBoolean(key,false);
    TrackHelper.track().interaction(""String_Node_Str"" + key,value ? ""String_Node_Str"" : ""String_Node_Str"").with(piwikTracker);
  }
}","@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  if (piwikTracker == null) {
    return;
  }
  if (Pref.KEY_SERVERS.equals(key)) {
    Timber.d(""String_Node_Str"",key);
    String keyServers=sharedPreferences.getString(Pref.KEY_SERVERS,Defaults.KEY_SERVERS);
    String current=keyServers.substring(keyServers.indexOf(','));
    String coarseGranularityKeyserver;
    if (current.contains(""String_Node_Str"")) {
      coarseGranularityKeyserver=""String_Node_Str"";
    }
 else     if (current.contains(""String_Node_Str"")) {
      coarseGranularityKeyserver=""String_Node_Str"";
    }
 else     if (current.contains(""String_Node_Str"")) {
      coarseGranularityKeyserver=""String_Node_Str"";
    }
 else {
      coarseGranularityKeyserver=""String_Node_Str"";
    }
    TrackHelper.track().interaction(""String_Node_Str"" + Pref.KEY_SERVERS,coarseGranularityKeyserver).with(piwikTracker);
    return;
  }
  if (Pref.THEME.equals(key)) {
    String value=sharedPreferences.getString(Pref.THEME,""String_Node_Str"");
    TrackHelper.track().interaction(""String_Node_Str"" + Pref.THEME,value).with(piwikTracker);
    return;
  }
  if (Pref.ANALYTICS_PREFS.contains(key)) {
    Timber.d(""String_Node_Str"",key);
    if (!sharedPreferences.contains(key)) {
      TrackHelper.track().interaction(""String_Node_Str"" + key,""String_Node_Str"").with(piwikTracker);
      return;
    }
    boolean value=sharedPreferences.getBoolean(key,false);
    TrackHelper.track().interaction(""String_Node_Str"" + key,value ? ""String_Node_Str"" : ""String_Node_Str"").with(piwikTracker);
  }
}",0.9770408163265306
8213,"private Intent getAuthenticationPublicKey(Intent data,boolean asSshKey){
  long masterKeyId=getKeyId(data);
  if (masterKeyId != Constants.key.none) {
    try {
      if (asSshKey) {
        return getSSHPublicKey(masterKeyId);
      }
 else {
        return getX509PublicKey(masterKeyId);
      }
    }
 catch (    KeyRepository.NotFoundException e) {
      return createExceptionErrorResult(SshAuthenticationApiError.NO_SUCH_KEY,""String_Node_Str"",e);
    }
catch (    PgpKeyNotFoundException e) {
      return createExceptionErrorResult(SshAuthenticationApiError.NO_AUTH_KEY,""String_Node_Str"",e);
    }
catch (    NoSuchAlgorithmException e) {
      return createExceptionErrorResult(SshAuthenticationApi.RESULT_CODE_ERROR,""String_Node_Str"",e);
    }
  }
 else {
    return createErrorResult(SshAuthenticationApiError.NO_KEY_ID,""String_Node_Str"");
  }
}","private Intent getAuthenticationPublicKey(Intent data,boolean asSshKey){
  long masterKeyId=getKeyId(data);
  if (masterKeyId != Constants.key.none) {
    try {
      if (asSshKey) {
        return getSSHPublicKey(masterKeyId);
      }
 else {
        return getX509PublicKey(masterKeyId);
      }
    }
 catch (    KeyRepository.NotFoundException e) {
      return createExceptionErrorResult(SshAuthenticationApiError.NO_SUCH_KEY,""String_Node_Str"",e);
    }
catch (    PgpKeyNotFoundException e) {
      return createExceptionErrorResult(SshAuthenticationApiError.NO_AUTH_KEY,""String_Node_Str"",e);
    }
catch (    NoSuchAlgorithmException e) {
      return createExceptionErrorResult(SshAuthenticationApiError.INVALID_ALGORITHM,""String_Node_Str"",e);
    }
  }
 else {
    return createErrorResult(SshAuthenticationApiError.NO_KEY_ID,""String_Node_Str"");
  }
}",0.9819241982507289
8214,"private Intent getAuthenticationPublicKey(Intent data,boolean asSshKey){
  long masterKeyId=getKeyId(data);
  if (masterKeyId != Constants.key.none) {
    try {
      if (asSshKey) {
        return getSSHPublicKey(masterKeyId);
      }
 else {
        return getX509PublicKey(masterKeyId);
      }
    }
 catch (    KeyRepository.NotFoundException e) {
      return createExceptionErrorResult(SshAuthenticationApiError.NO_SUCH_KEY,""String_Node_Str"",e);
    }
catch (    PgpKeyNotFoundException e) {
      return createExceptionErrorResult(SshAuthenticationApiError.NO_AUTH_KEY,""String_Node_Str"",e);
    }
catch (    NoSuchAlgorithmException e) {
      return createExceptionErrorResult(SshAuthenticationApi.RESULT_CODE_ERROR,""String_Node_Str"",e);
    }
  }
 else {
    return createErrorResult(SshAuthenticationApiError.NO_KEY_ID,""String_Node_Str"");
  }
}","private Intent getAuthenticationPublicKey(Intent data,boolean asSshKey){
  long masterKeyId=getKeyId(data);
  if (masterKeyId != Constants.key.none) {
    try {
      if (asSshKey) {
        return getSSHPublicKey(masterKeyId);
      }
 else {
        return getX509PublicKey(masterKeyId);
      }
    }
 catch (    KeyRepository.NotFoundException e) {
      return createExceptionErrorResult(SshAuthenticationApiError.NO_SUCH_KEY,""String_Node_Str"",e);
    }
catch (    PgpKeyNotFoundException e) {
      return createExceptionErrorResult(SshAuthenticationApiError.NO_AUTH_KEY,""String_Node_Str"",e);
    }
catch (    NoSuchAlgorithmException e) {
      return createExceptionErrorResult(SshAuthenticationApiError.INVALID_ALGORITHM,""String_Node_Str"",e);
    }
  }
 else {
    return createErrorResult(SshAuthenticationApiError.NO_KEY_ID,""String_Node_Str"");
  }
}",0.9819241982507289
8215,"public static IteratorWithIOThrow<UncachedKeyRing> fromStream(final InputStream stream){
  return new IteratorWithIOThrow<UncachedKeyRing>(){
    UncachedKeyRing mNext=null;
    PGPObjectFactory mObjectFactory=null;
    private void cacheNext() throws IOException {
      if (mNext != null) {
        return;
      }
      try {
        while (stream.available() > 0) {
          if (mObjectFactory == null) {
            InputStream in=PGPUtil.getDecoderStream(stream);
            mObjectFactory=new PGPObjectFactory(in,new JcaKeyFingerprintCalculator());
          }
          Object obj;
          while ((obj=mObjectFactory.nextObject()) != null) {
            Log.d(Constants.TAG,""String_Node_Str"" + obj.getClass());
            if (!(obj instanceof PGPKeyRing)) {
              Log.i(Constants.TAG,""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
              continue;
            }
            mNext=new UncachedKeyRing((PGPKeyRing)obj);
            return;
          }
          mObjectFactory=null;
        }
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        throw new IOException(e);
      }
    }
    @Override public boolean hasNext() throws IOException {
      cacheNext();
      return mNext != null;
    }
    @Override public UncachedKeyRing next() throws IOException {
      try {
        cacheNext();
        return mNext;
      }
  finally {
        mNext=null;
      }
    }
  }
;
}","public static IteratorWithIOThrow<UncachedKeyRing> fromStream(InputStream rawStream){
  final InputStream stream=rawStream.markSupported() ? rawStream : new BufferedInputStream(rawStream);
  return new IteratorWithIOThrow<UncachedKeyRing>(){
    UncachedKeyRing mNext=null;
    PGPObjectFactory mObjectFactory=null;
    private void cacheNext() throws IOException {
      if (mNext != null) {
        return;
      }
      try {
        while (true) {
          if (mObjectFactory == null) {
            stream.mark(1);
            if (stream.read() == -1) {
              break;
            }
            stream.reset();
            InputStream in=PGPUtil.getDecoderStream(stream);
            mObjectFactory=new PGPObjectFactory(in,new JcaKeyFingerprintCalculator());
          }
          Object obj;
          while ((obj=mObjectFactory.nextObject()) != null) {
            Log.d(Constants.TAG,""String_Node_Str"" + obj.getClass());
            if (!(obj instanceof PGPKeyRing)) {
              Log.i(Constants.TAG,""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
              continue;
            }
            mNext=new UncachedKeyRing((PGPKeyRing)obj);
            return;
          }
          mObjectFactory=null;
        }
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        throw new IOException(e);
      }
    }
    @Override public boolean hasNext() throws IOException {
      cacheNext();
      return mNext != null;
    }
    @Override public UncachedKeyRing next() throws IOException {
      try {
        cacheNext();
        return mNext;
      }
  finally {
        mNext=null;
      }
    }
  }
;
}",0.9158576051779936
8216,"private void cacheNext() throws IOException {
  if (mNext != null) {
    return;
  }
  try {
    while (stream.available() > 0) {
      if (mObjectFactory == null) {
        InputStream in=PGPUtil.getDecoderStream(stream);
        mObjectFactory=new PGPObjectFactory(in,new JcaKeyFingerprintCalculator());
      }
      Object obj;
      while ((obj=mObjectFactory.nextObject()) != null) {
        Log.d(Constants.TAG,""String_Node_Str"" + obj.getClass());
        if (!(obj instanceof PGPKeyRing)) {
          Log.i(Constants.TAG,""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
          continue;
        }
        mNext=new UncachedKeyRing((PGPKeyRing)obj);
        return;
      }
      mObjectFactory=null;
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IOException(e);
  }
}","private void cacheNext() throws IOException {
  if (mNext != null) {
    return;
  }
  try {
    while (true) {
      if (mObjectFactory == null) {
        stream.mark(1);
        if (stream.read() == -1) {
          break;
        }
        stream.reset();
        InputStream in=PGPUtil.getDecoderStream(stream);
        mObjectFactory=new PGPObjectFactory(in,new JcaKeyFingerprintCalculator());
      }
      Object obj;
      while ((obj=mObjectFactory.nextObject()) != null) {
        Log.d(Constants.TAG,""String_Node_Str"" + obj.getClass());
        if (!(obj instanceof PGPKeyRing)) {
          Log.i(Constants.TAG,""String_Node_Str"" + obj.getClass().getName() + ""String_Node_Str"");
          continue;
        }
        mNext=new UncachedKeyRing((PGPKeyRing)obj);
        return;
      }
      mObjectFactory=null;
    }
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    throw new IOException(e);
  }
}",0.9214780600461894
8217,"@Override protected void onActivityResult(@RequestType int requestCode,int resultCode,Intent data){
  if (mImportOpHelper.handleActivityResult(requestCode,resultCode,data)) {
    return;
  }
  if (mEditOpHelper != null) {
    mEditOpHelper.handleActivityResult(requestCode,resultCode,data);
  }
  if (resultCode != Activity.RESULT_OK) {
    super.onActivityResult(requestCode,resultCode,data);
    return;
  }
switch (requestCode) {
case REQUEST_QR_FINGERPRINT:
{
      if (data.hasExtra(OperationResult.EXTRA_RESULT)) {
        OperationResult result=data.getParcelableExtra(OperationResult.EXTRA_RESULT);
        result.createNotify(this).show();
        return;
      }
      String fp=data.getStringExtra(ImportKeysProxyActivity.EXTRA_FINGERPRINT);
      if (fp == null) {
        Notify.create(this,R.string.error_scan_fp,Notify.LENGTH_LONG,Style.ERROR).show();
        return;
      }
      if (mFingerprintString.equalsIgnoreCase(fp)) {
        certifyImmediate();
      }
 else {
        Notify.create(this,R.string.error_scan_match,Notify.LENGTH_LONG,Style.ERROR).show();
      }
      return;
    }
case REQUEST_BACKUP:
{
    startBackupActivity();
    return;
  }
case REQUEST_DELETE:
{
  setResult(RESULT_OK,data);
  finish();
  return;
}
case REQUEST_CERTIFY:
{
if (data.hasExtra(OperationResult.EXTRA_RESULT)) {
  OperationResult result=data.getParcelableExtra(OperationResult.EXTRA_RESULT);
  result.createNotify(this).show();
}
return;
}
}
super.onActivityResult(requestCode,resultCode,data);
}","@Override protected void onActivityResult(@RequestType int requestCode,int resultCode,Intent data){
  if (mImportOpHelper.handleActivityResult(requestCode,resultCode,data)) {
    return;
  }
  if (mEditOpHelper != null) {
    mEditOpHelper.handleActivityResult(requestCode,resultCode,data);
  }
  if (resultCode != Activity.RESULT_OK) {
    super.onActivityResult(requestCode,resultCode,data);
    return;
  }
switch (requestCode) {
case REQUEST_QR_FINGERPRINT:
{
      if (data.hasExtra(OperationResult.EXTRA_RESULT)) {
        OperationResult result=data.getParcelableExtra(OperationResult.EXTRA_RESULT);
        result.createNotify(this).show();
        return;
      }
      byte[] fingerprint=data.getByteArrayExtra(ImportKeysProxyActivity.EXTRA_FINGERPRINT);
      if (fingerprint == null) {
        Notify.create(this,R.string.error_scan_fp,Notify.LENGTH_LONG,Style.ERROR).show();
        return;
      }
      if (Arrays.equals(mFingerprint,fingerprint)) {
        certifyImmediate();
      }
 else {
        Notify.create(this,R.string.error_scan_match,Notify.LENGTH_LONG,Style.ERROR).show();
      }
      return;
    }
case REQUEST_BACKUP:
{
    startBackupActivity();
    return;
  }
case REQUEST_DELETE:
{
  setResult(RESULT_OK,data);
  finish();
  return;
}
case REQUEST_CERTIFY:
{
if (data.hasExtra(OperationResult.EXTRA_RESULT)) {
  OperationResult result=data.getParcelableExtra(OperationResult.EXTRA_RESULT);
  result.createNotify(this).show();
}
return;
}
}
super.onActivityResult(requestCode,resultCode,data);
}",0.9694179546201908
8218,"@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
switch (loader.getId()) {
case LOADER_ID_UNIFIED:
{
      if (data.getCount() == 0) {
        return;
      }
      if (data.moveToFirst()) {
        String name=data.getString(INDEX_NAME);
        mCollapsingToolbarLayout.setTitle(name != null ? name : getString(R.string.user_id_no_name));
        mMasterKeyId=data.getLong(INDEX_MASTER_KEY_ID);
        mFingerprint=data.getBlob(INDEX_FINGERPRINT);
        mFingerprintString=KeyFormattingUtils.convertFingerprintToHex(mFingerprint);
        mIsSecret=data.getInt(INDEX_HAS_ANY_SECRET) != 0;
        mHasEncrypt=data.getInt(INDEX_HAS_ENCRYPT) != 0;
        mIsRevoked=data.getInt(INDEX_IS_REVOKED) > 0;
        mIsExpired=data.getInt(INDEX_IS_EXPIRED) != 0;
        mIsSecure=data.getInt(INDEX_IS_SECURE) == 1;
        mIsVerified=data.getInt(INDEX_VERIFIED) > 0;
        showMainFragment();
        if (mShowSecurityTokenAfterCreation && getIntent().hasExtra(EXTRA_SECURITY_TOKEN_AID)) {
          mShowSecurityTokenAfterCreation=false;
          Intent intent=getIntent();
          byte[] tokenFingerprints=intent.getByteArrayExtra(EXTRA_SECURITY_TOKEN_FINGERPRINTS);
          String tokenUserId=intent.getStringExtra(EXTRA_SECURITY_TOKEN_USER_ID);
          byte[] tokenAid=intent.getByteArrayExtra(EXTRA_SECURITY_TOKEN_AID);
          double tokenVersion=intent.getDoubleExtra(EXTRA_SECURITY_TOKEN_VERSION,2.0);
          showSecurityTokenFragment(tokenFingerprints,tokenUserId,tokenAid,tokenVersion);
        }
        if (!mRotate.hasStarted() && !mRotateSpin.hasStarted()) {
          supportInvalidateOptionsMenu();
        }
        AsyncTask<Long,Void,Bitmap> photoTask=new AsyncTask<Long,Void,Bitmap>(){
          protected Bitmap doInBackground(          Long... mMasterKeyId){
            return new ContactHelper(ViewKeyActivity.this).loadPhotoByMasterKeyId(mMasterKeyId[0],true);
          }
          protected void onPostExecute(          Bitmap photo){
            if (photo == null) {
              return;
            }
            mPhoto.setImageBitmap(photo);
            mPhoto.setColorFilter(getResources().getColor(R.color.toolbar_photo_tint),PorterDuff.Mode.SRC_ATOP);
            mPhotoLayout.setVisibility(View.VISIBLE);
          }
        }
;
        boolean showStatusText=mIsSecure && !mIsExpired && !mIsRevoked;
        if (showStatusText) {
          mStatusText.setVisibility(View.VISIBLE);
          if (mIsSecret) {
            mStatusText.setText(R.string.view_key_my_key);
          }
 else           if (mIsVerified) {
            mStatusText.setText(R.string.view_key_verified);
          }
 else {
            mStatusText.setText(R.string.view_key_unverified);
          }
        }
 else {
          mStatusText.setVisibility(View.GONE);
        }
        int color;
        if (mIsRevoked) {
          mStatusImage.setVisibility(View.VISIBLE);
          KeyFormattingUtils.setStatusImage(this,mStatusImage,mStatusText,State.REVOKED,R.color.icons,true);
          color=getResources().getColor(R.color.key_flag_red);
          mActionEncryptFile.setVisibility(View.INVISIBLE);
          mActionEncryptText.setVisibility(View.INVISIBLE);
          hideFab();
          mQrCodeLayout.setVisibility(View.GONE);
        }
 else         if (!mIsSecure) {
          mStatusImage.setVisibility(View.VISIBLE);
          KeyFormattingUtils.setStatusImage(this,mStatusImage,mStatusText,State.INSECURE,R.color.icons,true);
          color=getResources().getColor(R.color.key_flag_red);
          mActionEncryptFile.setVisibility(View.INVISIBLE);
          mActionEncryptText.setVisibility(View.INVISIBLE);
          hideFab();
          mQrCodeLayout.setVisibility(View.GONE);
        }
 else         if (mIsExpired) {
          mStatusImage.setVisibility(View.VISIBLE);
          KeyFormattingUtils.setStatusImage(this,mStatusImage,mStatusText,State.EXPIRED,R.color.icons,true);
          color=getResources().getColor(R.color.key_flag_red);
          mActionEncryptFile.setVisibility(View.INVISIBLE);
          mActionEncryptText.setVisibility(View.INVISIBLE);
          hideFab();
          mQrCodeLayout.setVisibility(View.GONE);
        }
 else         if (mIsSecret) {
          mStatusImage.setVisibility(View.GONE);
          color=getResources().getColor(R.color.key_flag_green);
          if (!mFingerprintString.equals(mQrCodeLoaded)) {
            loadQrCode(mFingerprintString);
          }
          photoTask.execute(mMasterKeyId);
          mQrCodeLayout.setVisibility(View.VISIBLE);
          RelativeLayout.LayoutParams statusParams=(RelativeLayout.LayoutParams)mStatusText.getLayoutParams();
          statusParams.setMargins(FormattingUtils.dpToPx(this,48),0,0,0);
          if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
            statusParams.setMarginEnd(0);
          }
          statusParams.addRule(RelativeLayout.LEFT_OF,R.id.view_key_qr_code_layout);
          mStatusText.setLayoutParams(statusParams);
          mActionEncryptFile.setVisibility(View.VISIBLE);
          mActionEncryptText.setVisibility(View.VISIBLE);
          showFab();
          mFab.setImageDrawable(getResources().getDrawable(R.drawable.ic_repeat_white_24dp));
        }
 else {
          mActionEncryptFile.setVisibility(View.VISIBLE);
          mActionEncryptText.setVisibility(View.VISIBLE);
          mQrCodeLayout.setVisibility(View.GONE);
          if (mIsVerified) {
            mStatusText.setText(R.string.view_key_verified);
            mStatusImage.setVisibility(View.VISIBLE);
            KeyFormattingUtils.setStatusImage(this,mStatusImage,mStatusText,State.VERIFIED,R.color.icons,true);
            color=getResources().getColor(R.color.key_flag_green);
            photoTask.execute(mMasterKeyId);
            hideFab();
          }
 else {
            mStatusText.setText(R.string.view_key_unverified);
            mStatusImage.setVisibility(View.VISIBLE);
            KeyFormattingUtils.setStatusImage(this,mStatusImage,mStatusText,State.UNVERIFIED,R.color.icons,true);
            color=getResources().getColor(R.color.key_flag_orange);
            showFab();
          }
        }
        if (mPreviousColor == 0 || mPreviousColor == color) {
          mAppBarLayout.setBackgroundColor(color);
          mCollapsingToolbarLayout.setContentScrimColor(color);
          mCollapsingToolbarLayout.setStatusBarScrimColor(getStatusBarBackgroundColor(color));
          mPreviousColor=color;
        }
 else {
          ObjectAnimator colorFade=ObjectAnimator.ofObject(mAppBarLayout,""String_Node_Str"",new ArgbEvaluator(),mPreviousColor,color);
          mCollapsingToolbarLayout.setContentScrimColor(color);
          mCollapsingToolbarLayout.setStatusBarScrimColor(getStatusBarBackgroundColor(color));
          colorFade.setDuration(1200);
          colorFade.start();
          mPreviousColor=color;
        }
        mStatusImage.setAlpha(80);
        break;
      }
    }
}
}","@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
switch (loader.getId()) {
case LOADER_ID_UNIFIED:
{
      if (data.getCount() == 0) {
        return;
      }
      if (data.moveToFirst()) {
        String name=data.getString(INDEX_NAME);
        mCollapsingToolbarLayout.setTitle(name != null ? name : getString(R.string.user_id_no_name));
        mMasterKeyId=data.getLong(INDEX_MASTER_KEY_ID);
        mFingerprint=data.getBlob(INDEX_FINGERPRINT);
        mIsSecret=data.getInt(INDEX_HAS_ANY_SECRET) != 0;
        mHasEncrypt=data.getInt(INDEX_HAS_ENCRYPT) != 0;
        mIsRevoked=data.getInt(INDEX_IS_REVOKED) > 0;
        mIsExpired=data.getInt(INDEX_IS_EXPIRED) != 0;
        mIsSecure=data.getInt(INDEX_IS_SECURE) == 1;
        mIsVerified=data.getInt(INDEX_VERIFIED) > 0;
        showMainFragment();
        if (mShowSecurityTokenAfterCreation && getIntent().hasExtra(EXTRA_SECURITY_TOKEN_AID)) {
          mShowSecurityTokenAfterCreation=false;
          Intent intent=getIntent();
          byte[] tokenFingerprints=intent.getByteArrayExtra(EXTRA_SECURITY_TOKEN_FINGERPRINTS);
          String tokenUserId=intent.getStringExtra(EXTRA_SECURITY_TOKEN_USER_ID);
          byte[] tokenAid=intent.getByteArrayExtra(EXTRA_SECURITY_TOKEN_AID);
          double tokenVersion=intent.getDoubleExtra(EXTRA_SECURITY_TOKEN_VERSION,2.0);
          showSecurityTokenFragment(tokenFingerprints,tokenUserId,tokenAid,tokenVersion);
        }
        if (!mRotate.hasStarted() && !mRotateSpin.hasStarted()) {
          supportInvalidateOptionsMenu();
        }
        AsyncTask<Long,Void,Bitmap> photoTask=new AsyncTask<Long,Void,Bitmap>(){
          protected Bitmap doInBackground(          Long... mMasterKeyId){
            return new ContactHelper(ViewKeyActivity.this).loadPhotoByMasterKeyId(mMasterKeyId[0],true);
          }
          protected void onPostExecute(          Bitmap photo){
            if (photo == null) {
              return;
            }
            mPhoto.setImageBitmap(photo);
            mPhoto.setColorFilter(getResources().getColor(R.color.toolbar_photo_tint),PorterDuff.Mode.SRC_ATOP);
            mPhotoLayout.setVisibility(View.VISIBLE);
          }
        }
;
        boolean showStatusText=mIsSecure && !mIsExpired && !mIsRevoked;
        if (showStatusText) {
          mStatusText.setVisibility(View.VISIBLE);
          if (mIsSecret) {
            mStatusText.setText(R.string.view_key_my_key);
          }
 else           if (mIsVerified) {
            mStatusText.setText(R.string.view_key_verified);
          }
 else {
            mStatusText.setText(R.string.view_key_unverified);
          }
        }
 else {
          mStatusText.setVisibility(View.GONE);
        }
        int color;
        if (mIsRevoked) {
          mStatusImage.setVisibility(View.VISIBLE);
          KeyFormattingUtils.setStatusImage(this,mStatusImage,mStatusText,State.REVOKED,R.color.icons,true);
          color=getResources().getColor(R.color.key_flag_red);
          mActionEncryptFile.setVisibility(View.INVISIBLE);
          mActionEncryptText.setVisibility(View.INVISIBLE);
          hideFab();
          mQrCodeLayout.setVisibility(View.GONE);
        }
 else         if (!mIsSecure) {
          mStatusImage.setVisibility(View.VISIBLE);
          KeyFormattingUtils.setStatusImage(this,mStatusImage,mStatusText,State.INSECURE,R.color.icons,true);
          color=getResources().getColor(R.color.key_flag_red);
          mActionEncryptFile.setVisibility(View.INVISIBLE);
          mActionEncryptText.setVisibility(View.INVISIBLE);
          hideFab();
          mQrCodeLayout.setVisibility(View.GONE);
        }
 else         if (mIsExpired) {
          mStatusImage.setVisibility(View.VISIBLE);
          KeyFormattingUtils.setStatusImage(this,mStatusImage,mStatusText,State.EXPIRED,R.color.icons,true);
          color=getResources().getColor(R.color.key_flag_red);
          mActionEncryptFile.setVisibility(View.INVISIBLE);
          mActionEncryptText.setVisibility(View.INVISIBLE);
          hideFab();
          mQrCodeLayout.setVisibility(View.GONE);
        }
 else         if (mIsSecret) {
          mStatusImage.setVisibility(View.GONE);
          color=getResources().getColor(R.color.key_flag_green);
          if (!Arrays.equals(mFingerprint,mQrCodeLoaded)) {
            loadQrCode(mFingerprint);
          }
          photoTask.execute(mMasterKeyId);
          mQrCodeLayout.setVisibility(View.VISIBLE);
          RelativeLayout.LayoutParams statusParams=(RelativeLayout.LayoutParams)mStatusText.getLayoutParams();
          statusParams.setMargins(FormattingUtils.dpToPx(this,48),0,0,0);
          if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
            statusParams.setMarginEnd(0);
          }
          statusParams.addRule(RelativeLayout.LEFT_OF,R.id.view_key_qr_code_layout);
          mStatusText.setLayoutParams(statusParams);
          mActionEncryptFile.setVisibility(View.VISIBLE);
          mActionEncryptText.setVisibility(View.VISIBLE);
          showFab();
          mFab.setImageDrawable(getResources().getDrawable(R.drawable.ic_repeat_white_24dp));
        }
 else {
          mActionEncryptFile.setVisibility(View.VISIBLE);
          mActionEncryptText.setVisibility(View.VISIBLE);
          mQrCodeLayout.setVisibility(View.GONE);
          if (mIsVerified) {
            mStatusText.setText(R.string.view_key_verified);
            mStatusImage.setVisibility(View.VISIBLE);
            KeyFormattingUtils.setStatusImage(this,mStatusImage,mStatusText,State.VERIFIED,R.color.icons,true);
            color=getResources().getColor(R.color.key_flag_green);
            photoTask.execute(mMasterKeyId);
            hideFab();
          }
 else {
            mStatusText.setText(R.string.view_key_unverified);
            mStatusImage.setVisibility(View.VISIBLE);
            KeyFormattingUtils.setStatusImage(this,mStatusImage,mStatusText,State.UNVERIFIED,R.color.icons,true);
            color=getResources().getColor(R.color.key_flag_orange);
            showFab();
          }
        }
        if (mPreviousColor == 0 || mPreviousColor == color) {
          mAppBarLayout.setBackgroundColor(color);
          mCollapsingToolbarLayout.setContentScrimColor(color);
          mCollapsingToolbarLayout.setStatusBarScrimColor(getStatusBarBackgroundColor(color));
          mPreviousColor=color;
        }
 else {
          ObjectAnimator colorFade=ObjectAnimator.ofObject(mAppBarLayout,""String_Node_Str"",new ArgbEvaluator(),mPreviousColor,color);
          mCollapsingToolbarLayout.setContentScrimColor(color);
          mCollapsingToolbarLayout.setStatusBarScrimColor(getStatusBarBackgroundColor(color));
          colorFade.setDuration(1200);
          colorFade.start();
          mPreviousColor=color;
        }
        mStatusImage.setAlpha(80);
        break;
      }
    }
}
}",0.9913569576490924
8219,"@Override protected void onSecurityTokenPostExecute(){
  long tokenId=KeyFormattingUtils.getKeyIdFromFingerprint(mSecurityTokenFingerprints);
  try {
    CachedPublicKeyRing ring=mKeyRepository.getCachedPublicKeyRing(KeyRings.buildUnifiedKeyRingsFindBySubkeyUri(tokenId));
    byte[] candidateFp=ring.getFingerprint();
    if (KeyFormattingUtils.convertFingerprintToHex(candidateFp).equals(mFingerprintString)) {
      showSecurityTokenFragment(mSecurityTokenFingerprints,mSecurityTokenUserId,mSecurityTokenAid,mSecurityTokenVersion);
      return;
    }
    final long masterKeyId=KeyFormattingUtils.getKeyIdFromFingerprint(candidateFp);
    Notify.create(this,R.string.snack_security_token_other,Notify.LENGTH_LONG,Style.WARN,new ActionListener(){
      @Override public void onAction(){
        Intent intent=new Intent(ViewKeyActivity.this,ViewKeyActivity.class);
        intent.setData(KeyRings.buildGenericKeyRingUri(masterKeyId));
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_AID,mSecurityTokenAid);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_VERSION,mSecurityTokenVersion);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_USER_ID,mSecurityTokenUserId);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_FINGERPRINTS,mSecurityTokenFingerprints);
        startActivity(intent);
        finish();
      }
    }
,R.string.snack_security_token_view).show();
  }
 catch (  PgpKeyNotFoundException e) {
    Notify.create(this,R.string.snack_security_token_other,Notify.LENGTH_LONG,Style.WARN,new ActionListener(){
      @Override public void onAction(){
        Intent intent=new Intent(ViewKeyActivity.this,CreateKeyActivity.class);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_AID,mSecurityTokenAid);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_VERSION,mSecurityTokenVersion);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_USER_ID,mSecurityTokenUserId);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_FINGERPRINTS,mSecurityTokenFingerprints);
        startActivity(intent);
        finish();
      }
    }
,R.string.snack_security_token_import).show();
  }
}","@Override protected void onSecurityTokenPostExecute(){
  long tokenId=KeyFormattingUtils.getKeyIdFromFingerprint(mSecurityTokenFingerprints);
  try {
    CachedPublicKeyRing ring=mKeyRepository.getCachedPublicKeyRing(KeyRings.buildUnifiedKeyRingsFindBySubkeyUri(tokenId));
    byte[] candidateFp=ring.getFingerprint();
    if (Arrays.equals(candidateFp,mFingerprint)) {
      showSecurityTokenFragment(mSecurityTokenFingerprints,mSecurityTokenUserId,mSecurityTokenAid,mSecurityTokenVersion);
      return;
    }
    final long masterKeyId=KeyFormattingUtils.getKeyIdFromFingerprint(candidateFp);
    Notify.create(this,R.string.snack_security_token_other,Notify.LENGTH_LONG,Style.WARN,new ActionListener(){
      @Override public void onAction(){
        Intent intent=new Intent(ViewKeyActivity.this,ViewKeyActivity.class);
        intent.setData(KeyRings.buildGenericKeyRingUri(masterKeyId));
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_AID,mSecurityTokenAid);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_VERSION,mSecurityTokenVersion);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_USER_ID,mSecurityTokenUserId);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_FINGERPRINTS,mSecurityTokenFingerprints);
        startActivity(intent);
        finish();
      }
    }
,R.string.snack_security_token_view).show();
  }
 catch (  PgpKeyNotFoundException e) {
    Notify.create(this,R.string.snack_security_token_other,Notify.LENGTH_LONG,Style.WARN,new ActionListener(){
      @Override public void onAction(){
        Intent intent=new Intent(ViewKeyActivity.this,CreateKeyActivity.class);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_AID,mSecurityTokenAid);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_VERSION,mSecurityTokenVersion);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_USER_ID,mSecurityTokenUserId);
        intent.putExtra(ViewKeyActivity.EXTRA_SECURITY_TOKEN_FINGERPRINTS,mSecurityTokenFingerprints);
        startActivity(intent);
        finish();
      }
    }
,R.string.snack_security_token_import).show();
  }
}",0.9780041676313962
8220,"/** 
 * Load QR Code asynchronously and with a fade in animation
 */
private void loadQrCode(final String fingerprint){
  AsyncTask<Void,Void,Bitmap> loadTask=new AsyncTask<Void,Void,Bitmap>(){
    protected Bitmap doInBackground(    Void... unused){
      Uri uri=new Uri.Builder().scheme(Constants.FINGERPRINT_SCHEME).opaquePart(fingerprint).build();
      return QrCodeUtils.getQRCodeBitmap(uri,0);
    }
    protected void onPostExecute(    Bitmap qrCode){
      mQrCodeLoaded=fingerprint;
      Bitmap scaled=Bitmap.createScaledBitmap(qrCode,mQrCode.getHeight(),mQrCode.getHeight(),false);
      mQrCode.setImageBitmap(scaled);
      AlphaAnimation anim=new AlphaAnimation(0.0f,1.0f);
      anim.setDuration(200);
      mQrCode.startAnimation(anim);
    }
  }
;
  loadTask.execute();
}","/** 
 * Load QR Code asynchronously and with a fade in animation
 */
private void loadQrCode(final byte[] fingerprint){
  AsyncTask<Void,Void,Bitmap> loadTask=new AsyncTask<Void,Void,Bitmap>(){
    protected Bitmap doInBackground(    Void... unused){
      String fingerprintStr=KeyFormattingUtils.convertFingerprintToHex(fingerprint);
      Uri uri=new Uri.Builder().scheme(Constants.FINGERPRINT_SCHEME).opaquePart(fingerprintStr).build();
      return QrCodeUtils.getQRCodeBitmap(uri,0);
    }
    protected void onPostExecute(    Bitmap qrCode){
      mQrCodeLoaded=fingerprint;
      Bitmap scaled=Bitmap.createScaledBitmap(qrCode,mQrCode.getHeight(),mQrCode.getHeight(),false);
      mQrCode.setImageBitmap(scaled);
      AlphaAnimation anim=new AlphaAnimation(0.0f,1.0f);
      anim.setDuration(200);
      mQrCode.startAnimation(anim);
    }
  }
;
  loadTask.execute();
}",0.9400479616306956
8221,"@Override public void onGlobalLayout(){
  Bitmap scaled=Bitmap.createScaledBitmap(qrCode,vQrCodeImage.getWidth(),vQrCodeImage.getWidth(),false);
  vQrCodeImage.setImageBitmap(scaled);
}","@Override public void onGlobalLayout(){
  int viewSize=vQrCodeImage.getWidth();
  if (viewSize == 0) {
    return;
  }
  Bitmap scaled=Bitmap.createScaledBitmap(qrCode,viewSize,viewSize,false);
  vQrCodeImage.setImageBitmap(scaled);
}",0.5775656324582339
8222,"@Override public void setQrImage(final Bitmap qrCode){
  vQrCodeImage.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      Bitmap scaled=Bitmap.createScaledBitmap(qrCode,vQrCodeImage.getWidth(),vQrCodeImage.getWidth(),false);
      vQrCodeImage.setImageBitmap(scaled);
    }
  }
);
  vQrCodeImage.requestLayout();
}","@Override public void setQrImage(final Bitmap qrCode){
  vQrCodeImage.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      int viewSize=vQrCodeImage.getWidth();
      if (viewSize == 0) {
        return;
      }
      Bitmap scaled=Bitmap.createScaledBitmap(qrCode,viewSize,viewSize,false);
      vQrCodeImage.setImageBitmap(scaled);
    }
  }
);
  vQrCodeImage.requestLayout();
}",0.8189349112426035
8223,"private void parseExtendedCaps(byte[] v){
  mHasSM=(v[0] & MASK_SM) != 0;
  mHasKeyImport=(v[0] & MASK_KEY_IMPORT) != 0;
  mAttriburesChangable=(v[0] & MASK_ATTRIBUTES_CHANGABLE) != 0;
  mSMAESKeySize=(v[1] == 1) ? 16 : 32;
  mMaxCmdLen=(v[6] << 8) + v[7];
  mMaxRspLen=(v[8] << 8) + v[9];
}","private void parseExtendedCaps(byte[] v){
  mHasSM=(v[0] & MASK_SM) != 0;
  mHasKeyImport=(v[0] & MASK_KEY_IMPORT) != 0;
  mAttriburesChangable=(v[0] & MASK_ATTRIBUTES_CHANGABLE) != 0;
  mSMAESKeySize=0;
switch (v[1]) {
case 1:
    mSMAESKeySize=16;
  break;
case 2:
mSMAESKeySize=32;
break;
}
mMaxCmdLen=(v[6] << 8) + v[7];
mMaxRspLen=(v[8] << 8) + v[9];
}",0.8580246913580247
8224,"/** 
 * Connect to device and select pgp applet
 * @throws IOException
 */
public void connectToDevice(final Context ctx) throws IOException {
  mCardCapabilities=new CardCapabilities();
  mTransport.connect();
  CommandAPDU select=new CommandAPDU(0x00,0xA4,0x04,0x00,Hex.decode(""String_Node_Str""));
  ResponseAPDU response=communicate(select);
  if (response.getSW() != APDU_SW_SUCCESS) {
    throw new CardException(""String_Node_Str"",response.getSW());
  }
  mOpenPgpCapabilities=new OpenPgpCapabilities(getData(0x00,0x6E));
  mCardCapabilities=new CardCapabilities(mOpenPgpCapabilities.getHistoricalBytes());
  mPw1ValidatedForSignature=false;
  mPw1ValidatedForDecrypt=false;
  mPw3Validated=false;
  if (mOpenPgpCapabilities.isHasSM()) {
    try {
      SCP11bSecureMessaging.establish(this,ctx);
    }
 catch (    SecureMessagingException e) {
      mSecureMessaging=null;
      Log.e(Constants.TAG,""String_Node_Str"",e);
    }
  }
}","/** 
 * Connect to device and select pgp applet
 * @throws IOException
 */
public void connectToDevice(final Context ctx) throws IOException {
  mCardCapabilities=new CardCapabilities();
  mTransport.connect();
  CommandAPDU select=new CommandAPDU(0x00,0xA4,0x04,0x00,Hex.decode(""String_Node_Str""));
  ResponseAPDU response=communicate(select);
  if (response.getSW() != APDU_SW_SUCCESS) {
    throw new CardException(""String_Node_Str"",response.getSW());
  }
  mOpenPgpCapabilities=new OpenPgpCapabilities(getData(0x00,0x6E));
  mCardCapabilities=new CardCapabilities(mOpenPgpCapabilities.getHistoricalBytes());
  mPw1ValidatedForSignature=false;
  mPw1ValidatedForDecrypt=false;
  mPw3Validated=false;
  if (mOpenPgpCapabilities.isHasAESSM()) {
    try {
      SCP11bSecureMessaging.establish(this,ctx);
    }
 catch (    SecureMessagingException e) {
      mSecureMessaging=null;
      Log.e(Constants.TAG,""String_Node_Str"",e);
    }
  }
}",0.9984034060670568
8225,"private Intent encryptAndSignImpl(Intent data,InputStream inputStream,OutputStream outputStream,boolean sign){
  try {
    boolean asciiArmor=data.getBooleanExtra(OpenPgpApi.EXTRA_REQUEST_ASCII_ARMOR,true);
    String originalFilename=data.getStringExtra(OpenPgpApi.EXTRA_ORIGINAL_FILENAME);
    if (originalFilename == null) {
      originalFilename=""String_Node_Str"";
    }
    boolean enableCompression=data.getBooleanExtra(OpenPgpApi.EXTRA_ENABLE_COMPRESSION,true);
    int compressionId;
    if (enableCompression) {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT;
    }
 else {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.UNCOMPRESSED;
    }
    PgpSignEncryptData pgpData=new PgpSignEncryptData();
    pgpData.setEnableAsciiArmorOutput(asciiArmor).setVersionHeader(null).setCompressionAlgorithm(compressionId);
    if (sign) {
      Intent signKeyIdIntent=getSignKeyMasterId(data);
      if (signKeyIdIntent.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR) != OpenPgpApi.RESULT_CODE_SUCCESS) {
        return signKeyIdIntent;
      }
      long signKeyId=signKeyIdIntent.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,Constants.key.none);
      if (signKeyId == Constants.key.none) {
        throw new Exception(""String_Node_Str"");
      }
      long signSubKeyId=mKeyRepository.getCachedPublicKeyRing(signKeyId).getSecretSignId();
      pgpData.setSignatureMasterKeyId(signKeyId).setSignatureSubKeyId(signSubKeyId).setAdditionalEncryptId(signKeyId);
    }
    KeyIdResult keyIdResult=mKeyIdExtractor.returnKeyIdsFromIntent(data,false,mApiPermissionHelper.getCurrentCallingPackage());
    boolean isDryRun=data.getBooleanExtra(OpenPgpApi.EXTRA_DRY_RUN,false);
    boolean isOpportunistic=data.getBooleanExtra(OpenPgpApi.EXTRA_OPPORTUNISTIC_ENCRYPTION,false);
    KeyIdResultStatus keyIdResultStatus=keyIdResult.getStatus();
    if (isDryRun) {
      return getDryRunStatusResult(keyIdResult);
    }
    if (keyIdResult.hasKeySelectionPendingIntent()) {
      if ((keyIdResultStatus == KeyIdResultStatus.MISSING || keyIdResultStatus == KeyIdResultStatus.NO_KEYS || keyIdResultStatus == KeyIdResultStatus.NO_KEYS_ERROR) && isOpportunistic) {
        return createErrorResultIntent(OpenPgpError.OPPORTUNISTIC_MISSING_KEYS,""String_Node_Str"");
      }
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      result.putExtra(OpenPgpApi.RESULT_INTENT,keyIdResult.getKeySelectionPendingIntent());
      return result;
    }
    pgpData.setEncryptionMasterKeyIds(keyIdResult.getKeyIds());
    PgpSignEncryptInputParcel pseInput=new PgpSignEncryptInputParcel(pgpData);
    pseInput.setAllowedKeyIds(getAllowedKeyIds());
    CryptoInputParcel inputParcel=CryptoInputParcelCacheService.getCryptoInputParcel(this,data);
    if (inputParcel == null) {
      inputParcel=new CryptoInputParcel(new Date());
    }
    if (data.hasExtra(OpenPgpApi.EXTRA_PASSPHRASE)) {
      inputParcel.mPassphrase=new Passphrase(data.getCharArrayExtra(OpenPgpApi.EXTRA_PASSPHRASE));
    }
    long inputLength=inputStream.available();
    InputData inputData=new InputData(inputStream,inputLength,originalFilename);
    PgpSignEncryptOperation op=new PgpSignEncryptOperation(this,mKeyRepository,null);
    PgpSignEncryptResult pgpResult=op.execute(pseInput,inputParcel,inputData,outputStream);
    if (pgpResult.isPending()) {
      RequiredInputParcel requiredInput=pgpResult.getRequiredInputParcel();
      PendingIntent pIntent=mApiPendingIntentFactory.requiredInputPi(data,requiredInput,pgpResult.mCryptoInputParcel);
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_INTENT,pIntent);
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      return result;
    }
 else     if (pgpResult.success()) {
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
      return result;
    }
 else {
      LogEntryParcel errorMsg=pgpResult.getLog().getLast();
      throw new Exception(getString(errorMsg.mType.getMsgId()));
    }
  }
 catch (  Exception e) {
    Log.d(Constants.TAG,""String_Node_Str"",e);
    return createErrorResultIntent(OpenPgpError.GENERIC_ERROR,e.getMessage());
  }
}","private Intent encryptAndSignImpl(Intent data,InputStream inputStream,OutputStream outputStream,boolean sign){
  try {
    boolean asciiArmor=data.getBooleanExtra(OpenPgpApi.EXTRA_REQUEST_ASCII_ARMOR,true);
    String originalFilename=data.getStringExtra(OpenPgpApi.EXTRA_ORIGINAL_FILENAME);
    if (originalFilename == null) {
      originalFilename=""String_Node_Str"";
    }
    boolean enableCompression=data.getBooleanExtra(OpenPgpApi.EXTRA_ENABLE_COMPRESSION,true);
    int compressionId;
    if (enableCompression) {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT;
    }
 else {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.UNCOMPRESSED;
    }
    PgpSignEncryptData pgpData=new PgpSignEncryptData();
    pgpData.setEnableAsciiArmorOutput(asciiArmor).setVersionHeader(null).setCompressionAlgorithm(compressionId);
    if (sign) {
      Intent signKeyIdIntent=getSignKeyMasterId(data);
      if (signKeyIdIntent.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR) == OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED) {
        return signKeyIdIntent;
      }
      long signKeyId=signKeyIdIntent.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,Constants.key.none);
      if (signKeyId == Constants.key.none) {
        throw new Exception(""String_Node_Str"");
      }
      long signSubKeyId=mKeyRepository.getCachedPublicKeyRing(signKeyId).getSecretSignId();
      pgpData.setSignatureMasterKeyId(signKeyId).setSignatureSubKeyId(signSubKeyId).setAdditionalEncryptId(signKeyId);
    }
    KeyIdResult keyIdResult=mKeyIdExtractor.returnKeyIdsFromIntent(data,false,mApiPermissionHelper.getCurrentCallingPackage());
    boolean isDryRun=data.getBooleanExtra(OpenPgpApi.EXTRA_DRY_RUN,false);
    boolean isOpportunistic=data.getBooleanExtra(OpenPgpApi.EXTRA_OPPORTUNISTIC_ENCRYPTION,false);
    KeyIdResultStatus keyIdResultStatus=keyIdResult.getStatus();
    if (isDryRun) {
      return getDryRunStatusResult(keyIdResult);
    }
    if (keyIdResult.hasKeySelectionPendingIntent()) {
      if ((keyIdResultStatus == KeyIdResultStatus.MISSING || keyIdResultStatus == KeyIdResultStatus.NO_KEYS || keyIdResultStatus == KeyIdResultStatus.NO_KEYS_ERROR) && isOpportunistic) {
        return createErrorResultIntent(OpenPgpError.OPPORTUNISTIC_MISSING_KEYS,""String_Node_Str"");
      }
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      result.putExtra(OpenPgpApi.RESULT_INTENT,keyIdResult.getKeySelectionPendingIntent());
      return result;
    }
    pgpData.setEncryptionMasterKeyIds(keyIdResult.getKeyIds());
    PgpSignEncryptInputParcel pseInput=new PgpSignEncryptInputParcel(pgpData);
    pseInput.setAllowedKeyIds(getAllowedKeyIds());
    CryptoInputParcel inputParcel=CryptoInputParcelCacheService.getCryptoInputParcel(this,data);
    if (inputParcel == null) {
      inputParcel=new CryptoInputParcel(new Date());
    }
    if (data.hasExtra(OpenPgpApi.EXTRA_PASSPHRASE)) {
      inputParcel.mPassphrase=new Passphrase(data.getCharArrayExtra(OpenPgpApi.EXTRA_PASSPHRASE));
    }
    long inputLength=inputStream.available();
    InputData inputData=new InputData(inputStream,inputLength,originalFilename);
    PgpSignEncryptOperation op=new PgpSignEncryptOperation(this,mKeyRepository,null);
    PgpSignEncryptResult pgpResult=op.execute(pseInput,inputParcel,inputData,outputStream);
    if (pgpResult.isPending()) {
      RequiredInputParcel requiredInput=pgpResult.getRequiredInputParcel();
      PendingIntent pIntent=mApiPendingIntentFactory.requiredInputPi(data,requiredInput,pgpResult.mCryptoInputParcel);
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_INTENT,pIntent);
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      return result;
    }
 else     if (pgpResult.success()) {
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
      return result;
    }
 else {
      LogEntryParcel errorMsg=pgpResult.getLog().getLast();
      throw new Exception(getString(errorMsg.mType.getMsgId()));
    }
  }
 catch (  Exception e) {
    Log.d(Constants.TAG,""String_Node_Str"",e);
    return createErrorResultIntent(OpenPgpError.GENERIC_ERROR,e.getMessage());
  }
}",0.9965604219215776
8226,"@Override public ImportKeyResult call(){
  if (checkCancelled()) {
    return null;
  }
  ArrayList<ParcelableKeyRing> list=new ArrayList<>();
  list.add(keyListIterator.next());
  ProgressScaler ignoreProgressable=new ProgressScaler();
  return serialKeyRingImport(list.iterator(),1,keyServer,ignoreProgressable,proxy,skipSave);
}","@Override public ImportKeyResult call(){
  if (checkCancelled()) {
    return null;
  }
  ArrayList<ParcelableKeyRing> list=new ArrayList<>();
  list.add(pkRing);
  ProgressScaler ignoreProgressable=new ProgressScaler();
  return serialKeyRingImport(list.iterator(),1,keyServer,ignoreProgressable,proxy,skipSave);
}",0.959752321981424
8227,"@NonNull private ImportKeyResult multiThreadedKeyImport(ArrayList<ParcelableKeyRing> keyList,final ParcelableHkpKeyserver keyServer,final ParcelableProxy proxy,final boolean skipSave){
  Log.d(Constants.TAG,""String_Node_Str"");
  final Iterator<ParcelableKeyRing> keyListIterator=keyList.iterator();
  final int totKeys=keyList.size();
  ExecutorService importExecutor=new ThreadPoolExecutor(0,MAX_THREADS,30L,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
  ExecutorCompletionService<ImportKeyResult> importCompletionService=new ExecutorCompletionService<>(importExecutor);
  while (keyListIterator.hasNext()) {
    Callable<ImportKeyResult> importOperationCallable=new Callable<ImportKeyResult>(){
      @Override public ImportKeyResult call(){
        if (checkCancelled()) {
          return null;
        }
        ArrayList<ParcelableKeyRing> list=new ArrayList<>();
        list.add(keyListIterator.next());
        ProgressScaler ignoreProgressable=new ProgressScaler();
        return serialKeyRingImport(list.iterator(),1,keyServer,ignoreProgressable,proxy,skipSave);
      }
    }
;
    importCompletionService.submit(importOperationCallable);
  }
  KeyImportAccumulator accumulator=new KeyImportAccumulator(totKeys,mProgressable);
  while (!accumulator.isImportFinished()) {
    try {
      accumulator.accumulateKeyImport(importCompletionService.take().get());
    }
 catch (    InterruptedException|ExecutionException e) {
      Log.e(Constants.TAG,""String_Node_Str"" + ""String_Node_Str"",e);
      if (e instanceof ExecutionException) {
        throw new RuntimeException();
      }
    }
  }
  return accumulator.getConsolidatedResult();
}","@NonNull private ImportKeyResult multiThreadedKeyImport(ArrayList<ParcelableKeyRing> keyList,final ParcelableHkpKeyserver keyServer,final ParcelableProxy proxy,final boolean skipSave){
  Log.d(Constants.TAG,""String_Node_Str"");
  final Iterator<ParcelableKeyRing> keyListIterator=keyList.iterator();
  final int totKeys=keyList.size();
  ExecutorService importExecutor=new ThreadPoolExecutor(0,MAX_THREADS,30L,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>());
  ExecutorCompletionService<ImportKeyResult> importCompletionService=new ExecutorCompletionService<>(importExecutor);
  while (keyListIterator.hasNext()) {
    final ParcelableKeyRing pkRing=keyListIterator.next();
    Callable<ImportKeyResult> importOperationCallable=new Callable<ImportKeyResult>(){
      @Override public ImportKeyResult call(){
        if (checkCancelled()) {
          return null;
        }
        ArrayList<ParcelableKeyRing> list=new ArrayList<>();
        list.add(pkRing);
        ProgressScaler ignoreProgressable=new ProgressScaler();
        return serialKeyRingImport(list.iterator(),1,keyServer,ignoreProgressable,proxy,skipSave);
      }
    }
;
    importCompletionService.submit(importOperationCallable);
  }
  KeyImportAccumulator accumulator=new KeyImportAccumulator(totKeys,mProgressable);
  while (!accumulator.isImportFinished()) {
    try {
      accumulator.accumulateKeyImport(importCompletionService.take().get());
    }
 catch (    InterruptedException|ExecutionException e) {
      Log.e(Constants.TAG,""String_Node_Str"" + ""String_Node_Str"",e);
      if (e instanceof ExecutionException) {
        throw new RuntimeException();
      }
    }
  }
  return accumulator.getConsolidatedResult();
}",0.974724947963128
8228,"private Intent encryptAndSignImpl(Intent data,InputStream inputStream,OutputStream outputStream,boolean sign){
  try {
    boolean asciiArmor=data.getBooleanExtra(OpenPgpApi.EXTRA_REQUEST_ASCII_ARMOR,true);
    String originalFilename=data.getStringExtra(OpenPgpApi.EXTRA_ORIGINAL_FILENAME);
    if (originalFilename == null) {
      originalFilename=""String_Node_Str"";
    }
    boolean enableCompression=data.getBooleanExtra(OpenPgpApi.EXTRA_ENABLE_COMPRESSION,true);
    int compressionId;
    if (enableCompression) {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT;
    }
 else {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.UNCOMPRESSED;
    }
    long[] keyIds;
{
      HashSet<Long> encryptKeyIds=new HashSet<>();
      if (data.hasExtra(OpenPgpApi.EXTRA_USER_IDS)) {
        String[] userIds=data.getStringArrayExtra(OpenPgpApi.EXTRA_USER_IDS);
        boolean isOpportunistic=data.getBooleanExtra(OpenPgpApi.EXTRA_OPPORTUNISTIC_ENCRYPTION,false);
        KeyIdResult result=returnKeyIdsFromEmails(data,userIds,isOpportunistic);
        if (result.mResultIntent != null) {
          return result.mResultIntent;
        }
        encryptKeyIds.addAll(result.mKeyIds);
      }
      if (data.hasExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
        for (        long keyId : data.getLongArrayExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
          encryptKeyIds.add(keyId);
        }
      }
      keyIds=getUnboxedLongArray(encryptKeyIds);
    }
    long inputLength=inputStream.available();
    InputData inputData=new InputData(inputStream,inputLength,originalFilename);
    PgpSignEncryptData pgpData=new PgpSignEncryptData();
    pgpData.setEnableAsciiArmorOutput(asciiArmor).setVersionHeader(null).setCompressionAlgorithm(compressionId).setSymmetricEncryptionAlgorithm(PgpSecurityConstants.OpenKeychainSymmetricKeyAlgorithmTags.USE_DEFAULT).setEncryptionMasterKeyIds(keyIds);
    if (sign) {
      Intent signKeyIdIntent=getSignKeyMasterId(data);
      if (signKeyIdIntent.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR) == OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED) {
        return signKeyIdIntent;
      }
      long signKeyId=signKeyIdIntent.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,Constants.key.none);
      if (signKeyId == Constants.key.none) {
        throw new Exception(""String_Node_Str"");
      }
 else {
        pgpData.setSignatureMasterKeyId(signKeyId);
        try {
          long signSubKeyId=mProviderHelper.getCachedPublicKeyRing(pgpData.getSignatureMasterKeyId()).getSecretSignId();
          pgpData.setSignatureSubKeyId(signSubKeyId);
        }
 catch (        PgpKeyNotFoundException e) {
          throw new Exception(""String_Node_Str"",e);
        }
      }
      pgpData.setSignatureHashAlgorithm(PgpSecurityConstants.OpenKeychainHashAlgorithmTags.USE_DEFAULT).setAdditionalEncryptId(signKeyId);
    }
    if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) < 7) {
      String accName=data.getStringExtra(OpenPgpApi.EXTRA_ACCOUNT_NAME);
      if (TextUtils.isEmpty(accName)) {
        accName=""String_Node_Str"";
      }
      final AccountSettings accSettings=mApiPermissionHelper.getAccSettings(accName);
      if (accSettings == null || (accSettings.getKeyId() == Constants.key.none)) {
        return mApiPermissionHelper.getCreateAccountIntent(data,accName);
      }
      pgpData.setAdditionalEncryptId(accSettings.getKeyId());
    }
    PgpSignEncryptInputParcel pseInput=new PgpSignEncryptInputParcel(pgpData);
    CryptoInputParcel inputParcel=CryptoInputParcelCacheService.getCryptoInputParcel(this,data);
    if (inputParcel == null) {
      inputParcel=new CryptoInputParcel(new Date());
    }
    if (data.hasExtra(OpenPgpApi.EXTRA_PASSPHRASE)) {
      inputParcel.mPassphrase=new Passphrase(data.getCharArrayExtra(OpenPgpApi.EXTRA_PASSPHRASE));
    }
    PgpSignEncryptOperation op=new PgpSignEncryptOperation(this,mProviderHelper,null);
    PgpSignEncryptResult pgpResult=op.execute(pseInput,inputParcel,inputData,outputStream);
    if (pgpResult.isPending()) {
      ApiPendingIntentFactory piFactory=new ApiPendingIntentFactory(getBaseContext());
      RequiredInputParcel requiredInput=pgpResult.getRequiredInputParcel();
      PendingIntent pIntent=piFactory.requiredInputPi(data,requiredInput,pgpResult.mCryptoInputParcel);
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_INTENT,pIntent);
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      return result;
    }
 else     if (pgpResult.success()) {
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
      return result;
    }
 else {
      LogEntryParcel errorMsg=pgpResult.getLog().getLast();
      throw new Exception(getString(errorMsg.mType.getMsgId()));
    }
  }
 catch (  Exception e) {
    Log.d(Constants.TAG,""String_Node_Str"",e);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.GENERIC_ERROR,e.getMessage()));
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
    return result;
  }
}","private Intent encryptAndSignImpl(Intent data,InputStream inputStream,OutputStream outputStream,boolean sign){
  try {
    boolean asciiArmor=data.getBooleanExtra(OpenPgpApi.EXTRA_REQUEST_ASCII_ARMOR,true);
    String originalFilename=data.getStringExtra(OpenPgpApi.EXTRA_ORIGINAL_FILENAME);
    if (originalFilename == null) {
      originalFilename=""String_Node_Str"";
    }
    boolean enableCompression=data.getBooleanExtra(OpenPgpApi.EXTRA_ENABLE_COMPRESSION,true);
    int compressionId;
    if (enableCompression) {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT;
    }
 else {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.UNCOMPRESSED;
    }
    long[] keyIds;
{
      HashSet<Long> encryptKeyIds=new HashSet<>();
      boolean hasKeysFromSelectPubkeyActivity=data.hasExtra(OpenPgpApi.EXTRA_KEY_IDS_SELECTED);
      if (hasKeysFromSelectPubkeyActivity) {
        for (        long keyId : data.getLongArrayExtra(OpenPgpApi.EXTRA_KEY_IDS_SELECTED)) {
          encryptKeyIds.add(keyId);
        }
      }
 else       if (data.hasExtra(OpenPgpApi.EXTRA_USER_IDS)) {
        String[] userIds=data.getStringArrayExtra(OpenPgpApi.EXTRA_USER_IDS);
        boolean isOpportunistic=data.getBooleanExtra(OpenPgpApi.EXTRA_OPPORTUNISTIC_ENCRYPTION,false);
        KeyIdResult result=returnKeyIdsFromEmails(data,userIds,isOpportunistic);
        if (result.mResultIntent != null) {
          return result.mResultIntent;
        }
        encryptKeyIds.addAll(result.mKeyIds);
      }
      if (data.hasExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
        for (        long keyId : data.getLongArrayExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
          encryptKeyIds.add(keyId);
        }
      }
      keyIds=getUnboxedLongArray(encryptKeyIds);
    }
    long inputLength=inputStream.available();
    InputData inputData=new InputData(inputStream,inputLength,originalFilename);
    PgpSignEncryptData pgpData=new PgpSignEncryptData();
    pgpData.setEnableAsciiArmorOutput(asciiArmor).setVersionHeader(null).setCompressionAlgorithm(compressionId).setSymmetricEncryptionAlgorithm(PgpSecurityConstants.OpenKeychainSymmetricKeyAlgorithmTags.USE_DEFAULT).setEncryptionMasterKeyIds(keyIds);
    if (sign) {
      Intent signKeyIdIntent=getSignKeyMasterId(data);
      if (signKeyIdIntent.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR) == OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED) {
        return signKeyIdIntent;
      }
      long signKeyId=signKeyIdIntent.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,Constants.key.none);
      if (signKeyId == Constants.key.none) {
        throw new Exception(""String_Node_Str"");
      }
 else {
        pgpData.setSignatureMasterKeyId(signKeyId);
        try {
          long signSubKeyId=mProviderHelper.getCachedPublicKeyRing(pgpData.getSignatureMasterKeyId()).getSecretSignId();
          pgpData.setSignatureSubKeyId(signSubKeyId);
        }
 catch (        PgpKeyNotFoundException e) {
          throw new Exception(""String_Node_Str"",e);
        }
      }
      pgpData.setSignatureHashAlgorithm(PgpSecurityConstants.OpenKeychainHashAlgorithmTags.USE_DEFAULT).setAdditionalEncryptId(signKeyId);
    }
    if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) < 7) {
      String accName=data.getStringExtra(OpenPgpApi.EXTRA_ACCOUNT_NAME);
      if (TextUtils.isEmpty(accName)) {
        accName=""String_Node_Str"";
      }
      final AccountSettings accSettings=mApiPermissionHelper.getAccSettings(accName);
      if (accSettings == null || (accSettings.getKeyId() == Constants.key.none)) {
        return mApiPermissionHelper.getCreateAccountIntent(data,accName);
      }
      pgpData.setAdditionalEncryptId(accSettings.getKeyId());
    }
    PgpSignEncryptInputParcel pseInput=new PgpSignEncryptInputParcel(pgpData);
    CryptoInputParcel inputParcel=CryptoInputParcelCacheService.getCryptoInputParcel(this,data);
    if (inputParcel == null) {
      inputParcel=new CryptoInputParcel(new Date());
    }
    if (data.hasExtra(OpenPgpApi.EXTRA_PASSPHRASE)) {
      inputParcel.mPassphrase=new Passphrase(data.getCharArrayExtra(OpenPgpApi.EXTRA_PASSPHRASE));
    }
    PgpSignEncryptOperation op=new PgpSignEncryptOperation(this,mProviderHelper,null);
    PgpSignEncryptResult pgpResult=op.execute(pseInput,inputParcel,inputData,outputStream);
    if (pgpResult.isPending()) {
      ApiPendingIntentFactory piFactory=new ApiPendingIntentFactory(getBaseContext());
      RequiredInputParcel requiredInput=pgpResult.getRequiredInputParcel();
      PendingIntent pIntent=piFactory.requiredInputPi(data,requiredInput,pgpResult.mCryptoInputParcel);
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_INTENT,pIntent);
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      return result;
    }
 else     if (pgpResult.success()) {
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
      return result;
    }
 else {
      LogEntryParcel errorMsg=pgpResult.getLog().getLast();
      throw new Exception(getString(errorMsg.mType.getMsgId()));
    }
  }
 catch (  Exception e) {
    Log.d(Constants.TAG,""String_Node_Str"",e);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.GENERIC_ERROR,e.getMessage()));
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
    return result;
  }
}",0.9723467862481316
8229,"private KeyIdResult returnKeyIdsFromEmails(Intent data,String[] encryptionUserIds,boolean isOpportunistic){
  boolean noUserIdsCheck=(encryptionUserIds == null || encryptionUserIds.length == 0);
  boolean missingUserIdsCheck=false;
  boolean duplicateUserIdsCheck=false;
  HashSet<Long> keyIds=new HashSet<>();
  ArrayList<String> missingEmails=new ArrayList<>();
  ArrayList<String> duplicateEmails=new ArrayList<>();
  if (!noUserIdsCheck) {
    for (    String rawUserId : encryptionUserIds) {
      OpenPgpUtils.UserId userId=KeyRing.splitUserId(rawUserId);
      String email=userId.email != null ? userId.email : rawUserId;
      Uri uri=KeyRings.buildUnifiedKeyRingsFindByEmailUri(email);
      Cursor cursor=getContentResolver().query(uri,KEY_SEARCH_PROJECTION,KEY_SEARCH_WHERE,null,null);
      try {
        if (cursor != null && cursor.moveToFirst()) {
          long id=cursor.getLong(cursor.getColumnIndex(KeyRings.MASTER_KEY_ID));
          keyIds.add(id);
        }
 else {
          missingUserIdsCheck=true;
          missingEmails.add(email);
          Log.d(Constants.TAG,""String_Node_Str"");
        }
        if (cursor != null && cursor.moveToNext()) {
          duplicateUserIdsCheck=true;
          duplicateEmails.add(email);
          long id=cursor.getLong(cursor.getColumnIndex(KeyRings.MASTER_KEY_ID));
          keyIds.add(id);
          Log.d(Constants.TAG,""String_Node_Str"");
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
  }
  if (isOpportunistic && (noUserIdsCheck || missingUserIdsCheck)) {
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.OPPORTUNISTIC_MISSING_KEYS,""String_Node_Str""));
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
    return new KeyIdResult(result);
  }
  if (noUserIdsCheck || missingUserIdsCheck || duplicateUserIdsCheck) {
    long[] keyIdsArray=getUnboxedLongArray(keyIds);
    ApiPendingIntentFactory piFactory=new ApiPendingIntentFactory(getBaseContext());
    PendingIntent pi=piFactory.createSelectPublicKeyPendingIntent(data,keyIdsArray,missingEmails,duplicateEmails,noUserIdsCheck);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_INTENT,pi);
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
    return new KeyIdResult(result);
  }
  if (keyIds.isEmpty()) {
    Log.e(Constants.TAG,""String_Node_Str"");
  }
  return new KeyIdResult(keyIds);
}","private KeyIdResult returnKeyIdsFromEmails(Intent data,String[] encryptionUserIds,boolean isOpportunistic){
  boolean hasUserIds=(encryptionUserIds != null && encryptionUserIds.length > 0);
  HashSet<Long> keyIds=new HashSet<>();
  ArrayList<String> missingEmails=new ArrayList<>();
  ArrayList<String> duplicateEmails=new ArrayList<>();
  if (hasUserIds) {
    for (    String rawUserId : encryptionUserIds) {
      OpenPgpUtils.UserId userId=KeyRing.splitUserId(rawUserId);
      String email=userId.email != null ? userId.email : rawUserId;
      Uri uri=KeyRings.buildUnifiedKeyRingsFindByEmailUri(email);
      Cursor cursor=getContentResolver().query(uri,KEY_SEARCH_PROJECTION,KEY_SEARCH_WHERE,null,null);
      try {
        if (cursor != null && cursor.moveToFirst()) {
          long id=cursor.getLong(cursor.getColumnIndex(KeyRings.MASTER_KEY_ID));
          keyIds.add(id);
        }
 else {
          missingEmails.add(email);
          Log.d(Constants.TAG,""String_Node_Str"");
        }
        if (cursor != null && cursor.moveToNext()) {
          duplicateEmails.add(email);
          long id=cursor.getLong(cursor.getColumnIndex(KeyRings.MASTER_KEY_ID));
          keyIds.add(id);
          Log.d(Constants.TAG,""String_Node_Str"");
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
  }
  boolean hasMissingUserIds=!missingEmails.isEmpty();
  boolean hasDuplicateUserIds=!duplicateEmails.isEmpty();
  if (isOpportunistic && (!hasUserIds || hasMissingUserIds)) {
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.OPPORTUNISTIC_MISSING_KEYS,""String_Node_Str""));
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
    return new KeyIdResult(result);
  }
  if (!hasUserIds || hasMissingUserIds || hasDuplicateUserIds) {
    long[] keyIdsArray=getUnboxedLongArray(keyIds);
    ApiPendingIntentFactory piFactory=new ApiPendingIntentFactory(getBaseContext());
    PendingIntent pi=piFactory.createSelectPublicKeyPendingIntent(data,keyIdsArray,missingEmails,duplicateEmails,hasUserIds);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_INTENT,pi);
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
    return new KeyIdResult(result);
  }
  if (keyIds.isEmpty()) {
    throw new AssertionError(""String_Node_Str"");
  }
  return new KeyIdResult(keyIds);
}",0.8906281356612482
8230,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  final Bundle extras=getIntent().getExtras();
  long[] selectedMasterKeyIds=getIntent().getLongArrayExtra(EXTRA_SELECTED_MASTER_KEY_IDS);
  boolean noUserIdsCheck=getIntent().getBooleanExtra(EXTRA_NO_USER_IDS_CHECK,true);
  ArrayList<String> missingEmails=getIntent().getStringArrayListExtra(EXTRA_MISSING_EMAILS);
  ArrayList<String> duplicateEmails=getIntent().getStringArrayListExtra(EXTRA_DUPLICATE_EMAILS);
  SpannableStringBuilder ssb=new SpannableStringBuilder();
  final SpannableString textIntro=new SpannableString(noUserIdsCheck ? getString(R.string.api_select_pub_keys_text_no_user_ids) : getString(R.string.api_select_pub_keys_text));
  textIntro.setSpan(new StyleSpan(Typeface.BOLD),0,textIntro.length(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
  ssb.append(textIntro);
  if (missingEmails != null && missingEmails.size() > 0) {
    ssb.append(""String_Node_Str"");
    ssb.append(getString(R.string.api_select_pub_keys_missing_text));
    ssb.append(""String_Node_Str"");
    for (    String emails : missingEmails) {
      SpannableString ss=new SpannableString(emails + ""String_Node_Str"");
      ss.setSpan(new BulletSpan(15,Color.BLACK),0,ss.length(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
      ssb.append(ss);
    }
  }
  if (duplicateEmails != null && duplicateEmails.size() > 0) {
    ssb.append(""String_Node_Str"");
    ssb.append(getString(R.string.api_select_pub_keys_dublicates_text));
    ssb.append(""String_Node_Str"");
    for (    String email : duplicateEmails) {
      SpannableString ss=new SpannableString(email + ""String_Node_Str"");
      ss.setSpan(new BulletSpan(15,Color.BLACK),0,ss.length(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
      ssb.append(ss);
    }
  }
  setFullScreenDialogDoneClose(R.string.btn_okay,new View.OnClickListener(){
    @Override public void onClick(    View v){
      Intent resultData=extras.getParcelable(EXTRA_DATA);
      resultData.putExtra(OpenPgpApi.EXTRA_KEY_IDS,mSelectFragment.getSelectedMasterKeyIds());
      RemoteSelectPubKeyActivity.this.setResult(RESULT_OK,resultData);
      RemoteSelectPubKeyActivity.this.finish();
    }
  }
,new View.OnClickListener(){
    @Override public void onClick(    View v){
      RemoteSelectPubKeyActivity.this.setResult(RESULT_CANCELED);
      RemoteSelectPubKeyActivity.this.finish();
    }
  }
);
  TextView textView=(TextView)findViewById(R.id.api_select_pub_keys_text);
  textView.setText(ssb,TextView.BufferType.SPANNABLE);
  if (findViewById(R.id.api_select_pub_keys_fragment_container) != null) {
    if (savedInstanceState != null) {
      return;
    }
    mSelectFragment=SelectPublicKeyFragment.newInstance(selectedMasterKeyIds);
    getSupportFragmentManager().beginTransaction().add(R.id.api_select_pub_keys_fragment_container,mSelectFragment).commit();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  final Bundle extras=getIntent().getExtras();
  long[] selectedMasterKeyIds=getIntent().getLongArrayExtra(EXTRA_SELECTED_MASTER_KEY_IDS);
  boolean noUserIdsCheck=getIntent().getBooleanExtra(EXTRA_NO_USER_IDS_CHECK,true);
  ArrayList<String> missingEmails=getIntent().getStringArrayListExtra(EXTRA_MISSING_EMAILS);
  ArrayList<String> duplicateEmails=getIntent().getStringArrayListExtra(EXTRA_DUPLICATE_EMAILS);
  SpannableStringBuilder ssb=new SpannableStringBuilder();
  final SpannableString textIntro=new SpannableString(noUserIdsCheck ? getString(R.string.api_select_pub_keys_text_no_user_ids) : getString(R.string.api_select_pub_keys_text));
  textIntro.setSpan(new StyleSpan(Typeface.BOLD),0,textIntro.length(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
  ssb.append(textIntro);
  if (missingEmails != null && missingEmails.size() > 0) {
    ssb.append(""String_Node_Str"");
    ssb.append(getString(R.string.api_select_pub_keys_missing_text));
    ssb.append(""String_Node_Str"");
    for (    String emails : missingEmails) {
      SpannableString ss=new SpannableString(emails + ""String_Node_Str"");
      ss.setSpan(new BulletSpan(15,Color.BLACK),0,ss.length(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
      ssb.append(ss);
    }
  }
  if (duplicateEmails != null && duplicateEmails.size() > 0) {
    ssb.append(""String_Node_Str"");
    ssb.append(getString(R.string.api_select_pub_keys_dublicates_text));
    ssb.append(""String_Node_Str"");
    for (    String email : duplicateEmails) {
      SpannableString ss=new SpannableString(email + ""String_Node_Str"");
      ss.setSpan(new BulletSpan(15,Color.BLACK),0,ss.length(),Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
      ssb.append(ss);
    }
  }
  setFullScreenDialogDoneClose(R.string.btn_okay,new View.OnClickListener(){
    @Override public void onClick(    View v){
      Intent resultData=extras.getParcelable(EXTRA_DATA);
      resultData.putExtra(OpenPgpApi.EXTRA_KEY_IDS_SELECTED,mSelectFragment.getSelectedMasterKeyIds());
      RemoteSelectPubKeyActivity.this.setResult(RESULT_OK,resultData);
      RemoteSelectPubKeyActivity.this.finish();
    }
  }
,new View.OnClickListener(){
    @Override public void onClick(    View v){
      RemoteSelectPubKeyActivity.this.setResult(RESULT_CANCELED);
      RemoteSelectPubKeyActivity.this.finish();
    }
  }
);
  TextView textView=(TextView)findViewById(R.id.api_select_pub_keys_text);
  textView.setText(ssb,TextView.BufferType.SPANNABLE);
  if (findViewById(R.id.api_select_pub_keys_fragment_container) != null) {
    if (savedInstanceState != null) {
      return;
    }
    mSelectFragment=SelectPublicKeyFragment.newInstance(selectedMasterKeyIds);
    getSupportFragmentManager().beginTransaction().add(R.id.api_select_pub_keys_fragment_container,mSelectFragment).commit();
  }
}",0.998434510349626
8231,"@Override public boolean onActionItemClicked(ActionMode mode,MenuItem item){
switch (item.getItemId()) {
case R.id.menu_key_list_multi_encrypt:
{
      long[] keyIds=getAdapter().getSelectedMasterKeyIds();
      Intent intent=new Intent(getActivity(),EncryptFilesActivity.class);
      intent.setAction(EncryptFilesActivity.ACTION_ENCRYPT_DATA);
      intent.putExtra(EncryptFilesActivity.EXTRA_ENCRYPTION_KEY_IDS,keyIds);
      startActivityForResult(intent,REQUEST_ACTION);
      mode.finish();
      break;
    }
case R.id.menu_key_list_multi_delete:
{
    long[] keyIds=getAdapter().getSelectedMasterKeyIds();
    boolean hasSecret=getAdapter().isAnySecretKeySelected();
    System.out.println(Arrays.toString(keyIds));
    System.out.println(hasSecret);
    Intent intent=new Intent(getActivity(),DeleteKeyDialogActivity.class);
    intent.putExtra(DeleteKeyDialogActivity.EXTRA_DELETE_MASTER_KEY_IDS,keyIds);
    intent.putExtra(DeleteKeyDialogActivity.EXTRA_HAS_SECRET,hasSecret);
    if (hasSecret) {
      intent.putExtra(DeleteKeyDialogActivity.EXTRA_KEYSERVER,Preferences.getPreferences(getActivity()).getPreferredKeyserver());
    }
    startActivityForResult(intent,REQUEST_DELETE);
    break;
  }
}
return false;
}","@Override public boolean onActionItemClicked(ActionMode mode,MenuItem item){
switch (item.getItemId()) {
case R.id.menu_key_list_multi_encrypt:
{
      long[] keyIds=getAdapter().getSelectedMasterKeyIds();
      Intent intent=new Intent(getActivity(),EncryptFilesActivity.class);
      intent.setAction(EncryptFilesActivity.ACTION_ENCRYPT_DATA);
      intent.putExtra(EncryptFilesActivity.EXTRA_ENCRYPTION_KEY_IDS,keyIds);
      startActivityForResult(intent,REQUEST_ACTION);
      mode.finish();
      break;
    }
case R.id.menu_key_list_multi_delete:
{
    long[] keyIds=getAdapter().getSelectedMasterKeyIds();
    boolean hasSecret=getAdapter().isAnySecretKeySelected();
    Intent intent=new Intent(getActivity(),DeleteKeyDialogActivity.class);
    intent.putExtra(DeleteKeyDialogActivity.EXTRA_DELETE_MASTER_KEY_IDS,keyIds);
    intent.putExtra(DeleteKeyDialogActivity.EXTRA_HAS_SECRET,hasSecret);
    if (hasSecret) {
      intent.putExtra(DeleteKeyDialogActivity.EXTRA_KEYSERVER,Preferences.getPreferences(getActivity()).getPreferredKeyserver());
    }
    startActivityForResult(intent,REQUEST_DELETE);
    break;
  }
}
return false;
}",0.9645868465430016
8232,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mTextColor=FormattingUtils.getColorFromAttr(getActivity(),R.attr.colorText);
  setHasOptionsMenu(true);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setHasOptionsMenu(true);
}",0.7598784194528876
8233,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  Intent intent=getActivity().getIntent();
  if (intent == null) {
    getActivity().finish();
    return;
  }
  if (savedInstanceState != null) {
    mResult=savedInstanceState.getParcelable(EXTRA_RESULT);
  }
 else {
    mResult=intent.getParcelableExtra(EXTRA_RESULT);
  }
  if (mResult == null) {
    getActivity().finish();
    return;
  }
  mAdapter=new LogAdapter(getActivity(),mResult.getLog());
  setListAdapter(mAdapter);
  getListView().setOnItemClickListener(this);
  getListView().setFastScrollEnabled(true);
  getListView().setDividerHeight(0);
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  Intent intent=getActivity().getIntent();
  if (intent == null) {
    getActivity().finish();
    return;
  }
  if (savedInstanceState != null) {
    mResult=savedInstanceState.getParcelable(EXTRA_RESULT);
  }
 else {
    mResult=intent.getParcelableExtra(EXTRA_RESULT);
  }
  if (mResult == null) {
    getActivity().finish();
    return;
  }
  NestedLogAdapter adapter=new NestedLogAdapter(getContext(),mResult.getLog());
  adapter.setListener(this);
  setAdapter(adapter);
  setLayoutManager(new LayoutManager(getContext()));
}",0.7630582891748675
8234,"private void shareLog(){
  Activity activity=getActivity();
  if (activity == null) {
    return;
  }
  String log=mResult.getLog().getPrintableOperationLog(getResources(),0);
  if (mLogTempFile == null) {
    mLogTempFile=TemporaryFileProvider.createFile(getActivity(),""String_Node_Str"",""String_Node_Str"");
    try {
      OutputStream outputStream=activity.getContentResolver().openOutputStream(mLogTempFile);
      outputStream.write(log.getBytes());
    }
 catch (    IOException e) {
      Notify.create(activity,R.string.error_log_share_internal,Style.ERROR).show();
      return;
    }
  }
  ShareLogDialogFragment shareLogDialog=ShareLogDialogFragment.newInstance(mLogTempFile);
  shareLogDialog.show(getActivity().getSupportFragmentManager(),""String_Node_Str"");
}","private void shareLog(){
  Activity activity=getActivity();
  if (activity == null) {
    return;
  }
  String log=mResult.getLog().getPrintableOperationLog(getResources(),0);
  if (mLogTempFile == null) {
    mLogTempFile=TemporaryFileProvider.createFile(getActivity(),""String_Node_Str"",""String_Node_Str"");
    try {
      OutputStream outputStream=activity.getContentResolver().openOutputStream(mLogTempFile);
      outputStream.write(log.getBytes());
    }
 catch (    IOException|NullPointerException e) {
      Notify.create(activity,R.string.error_log_share_internal,Style.ERROR).show();
      return;
    }
  }
  ShareLogDialogFragment shareLogDialog=ShareLogDialogFragment.newInstance(mLogTempFile);
  shareLogDialog.show(getActivity().getSupportFragmentManager(),""String_Node_Str"");
}",0.9865814696485624
8235,"/** 
 * Recommended constructor.
 * @param c The cursor from which to get the data.
 * @param context The context
 * @param flags Flags used to determine the behavior of the adapter
 * @see #FLAG_REGISTER_CONTENT_OBSERVER
 */
public CursorAdapter(Context context,C c,int flags){
  init(context,c,flags);
}","/** 
 * Recommended constructor.
 * @param c The cursor from which to get the data.
 * @param context The context
 * @param flags Flags used to determine the behavior of the adapter
 * @see #FLAG_REGISTER_CONTENT_OBSERVER
 */
public CursorAdapter(Context context,C c,int flags){
  setHasStableIds(true);
  init(context,c,flags);
}",0.9007874015748032
8236,"public SectionCursorAdapter(Context context,C cursor,int flags,Comparator<T> comparator){
  super(context,cursor,flags);
  setHasStableIds(false);
  setSectionComparator(comparator);
}","public SectionCursorAdapter(Context context,C cursor,int flags,Comparator<T> comparator){
  super(context,cursor,flags);
  setSectionComparator(comparator);
}",0.9239766081871345
8237,"@SuppressWarnings(""String_Node_Str"") private void ensureList(){
  if (listView != null)   return;
  View root=getView();
  if (root == null)   throw new IllegalStateException(""String_Node_Str"");
  if (root instanceof RecyclerView) {
    listView=(RecyclerView)root;
  }
 else {
    emptyView=root.findViewById(INTERNAL_EMPTY_VIEW_ID);
    if (emptyView != null) {
      emptyView.setVisibility(View.GONE);
    }
    progressContainer=root.findViewById(INTERNAL_PROGRESS_CONTAINER_ID);
    listContainer=root.findViewById(INTERNAL_LIST_CONTAINER_ID);
    View rawListView=root.findViewById(INTERNAL_LIST_VIEW_ID);
    if (!(rawListView instanceof RecyclerView)) {
      if (rawListView == null) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
      }
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
    }
    listView=(RecyclerView)rawListView;
  }
  if (layoutManager != null) {
    RecyclerView.LayoutManager manager=layoutManager;
    this.layoutManager=null;
    setLayoutManager(manager);
  }
  listShown=true;
  listView.setHasFixedSize(isFixedSize());
  listView.addOnScrollListener(scrollListener);
  if (this.adapter != null) {
    A adapter=this.adapter;
    this.adapter=null;
    setAdapter(adapter);
  }
 else {
    if (progressContainer != null) {
      setListShown(false,false);
    }
  }
  handler.post(requestFocus);
}","@SuppressWarnings(""String_Node_Str"") private void ensureList(){
  if (listView != null) {
    return;
  }
  View root=getView();
  if (root == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (root instanceof RecyclerView) {
    listView=(RecyclerView)root;
  }
 else {
    emptyView=root.findViewById(INTERNAL_EMPTY_VIEW_ID);
    if (emptyView != null) {
      emptyView.setVisibility(View.GONE);
    }
    progressContainer=root.findViewById(INTERNAL_PROGRESS_CONTAINER_ID);
    listContainer=root.findViewById(INTERNAL_LIST_CONTAINER_ID);
    View rawListView=root.findViewById(INTERNAL_LIST_VIEW_ID);
    if (!(rawListView instanceof RecyclerView)) {
      if (rawListView == null) {
        throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
      }
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
    }
    listView=(RecyclerView)rawListView;
  }
  if (layoutManager != null) {
    RecyclerView.LayoutManager manager=layoutManager;
    this.layoutManager=null;
    setLayoutManager(manager);
  }
  listShown=true;
  listView.setHasFixedSize(isFixedSize());
  listView.addOnScrollListener(scrollListener);
  if (this.adapter != null) {
    A adapter=this.adapter;
    this.adapter=null;
    setAdapter(adapter);
  }
 else {
    if (progressContainer != null) {
      setListShown(false,false);
    }
  }
  handler.post(requestFocus);
}",0.9570508231925556
8238,"public static void importKeysFromResource(Context context,String name) throws Exception {
  IteratorWithIOThrow<UncachedKeyRing> stream=UncachedKeyRing.fromStream(getInstrumentation().getContext().getAssets().open(name));
  ProviderHelper helper=new ProviderHelper(context);
  while (stream.hasNext()) {
    UncachedKeyRing ring=stream.next();
    if (ring.isSecret()) {
      helper.saveSecretKeyRing(ring,new ProgressScaler());
    }
 else {
      helper.savePublicKeyRing(ring,new ProgressScaler());
    }
  }
}","public static void importKeysFromResource(Context context,String name) throws Exception {
  IteratorWithIOThrow<UncachedKeyRing> stream=UncachedKeyRing.fromStream(getInstrumentation().getContext().getAssets().open(name));
  ProviderHelper helper=new ProviderHelper(context);
  while (stream.hasNext()) {
    UncachedKeyRing ring=stream.next();
    if (ring.isSecret()) {
      helper.saveSecretKeyRing(ring,new ProgressScaler());
    }
 else {
      helper.savePublicKeyRing(ring);
    }
  }
}",0.9791459781529296
8239,"@Test public void test01Edit() throws Exception {
  Activity activity=mActivity.getActivity();
  new KeychainDatabase(activity).clearDatabase();
  importKeysFromResource(activity,""String_Node_Str"");
  onData(withKeyItemId(0x9D604D2F310716A3L)).inAdapterView(allOf(isAssignableFrom(AdapterView.class),isDescendantOfA(ViewMatchers.withId(R.id.key_list_list)))).perform(click());
  onView(withId(R.id.menu_key_view_edit)).perform(click());
  onView(withText(R.string.btn_save)).perform(click());
  checkSnackbar(Style.ERROR,R.string.msg_mf_error_noop);
}","@Test public void test01Edit() throws Exception {
  Activity activity=mActivity.getActivity();
  new KeychainDatabase(activity).clearDatabase();
  importKeysFromResource(activity,""String_Node_Str"");
  onData(withKeyItemId(0x9D604D2F310716A3L)).inAdapterView(allOf(isAssignableFrom(AdapterView.class),isDescendantOfA(ViewMatchers.withId(R.id.key_list_list)))).perform(click());
  onView(withId(R.id.view_key_card_user_ids_edit)).perform(click());
  onView(withText(R.string.btn_save)).perform(click());
  checkSnackbar(Style.ERROR,R.string.msg_mf_error_noop);
}",0.9702970297029704
8240,"private void handleSecurityTokenError(IOException e){
  if (e instanceof TagLostException) {
    onSecurityTokenError(getString(R.string.security_token_error_tag_lost));
    return;
  }
  if (e instanceof IsoDepNotSupportedException) {
    onSecurityTokenError(getString(R.string.security_token_error_iso_dep_not_supported));
    return;
  }
  short status;
  if (e instanceof CardException) {
    status=((CardException)e).getResponseCode();
  }
 else {
    status=-1;
  }
  if ((status & (short)0xFFF0) == 0x63C0) {
    int tries=status & 0x000F;
    onSecurityTokenPinError(getResources().getQuantityString(R.plurals.security_token_error_pin,tries,tries));
    return;
  }
switch (status) {
case 0x6A80:
{
      onSecurityTokenError(getString(R.string.security_token_error_bad_data));
      break;
    }
case 0x6883:
{
    onSecurityTokenError(getString(R.string.security_token_error_chaining_error));
    break;
  }
case 0x6B00:
{
  onSecurityTokenError(getString(R.string.security_token_error_header,""String_Node_Str""));
  break;
}
case 0x6D00:
{
onSecurityTokenError(getString(R.string.security_token_error_header,""String_Node_Str""));
break;
}
case 0x6E00:
{
onSecurityTokenError(getString(R.string.security_token_error_header,""String_Node_Str""));
break;
}
case 0x6285:
{
onSecurityTokenError(getString(R.string.security_token_error_terminated));
break;
}
case 0x6700:
{
onSecurityTokenPinError(getString(R.string.security_token_error_wrong_length));
break;
}
case 0x6982:
{
onSecurityTokenError(getString(R.string.security_token_error_security_not_satisfied));
break;
}
case 0x6983:
{
onSecurityTokenError(getString(R.string.security_token_error_authentication_blocked));
break;
}
case 0x6985:
{
onSecurityTokenError(getString(R.string.security_token_error_conditions_not_satisfied));
break;
}
case 0x6A88:
case 0x6A83:
{
onSecurityTokenError(getString(R.string.security_token_error_data_not_found));
break;
}
case 0x6F00:
{
onSecurityTokenError(getString(R.string.security_token_error_unknown));
break;
}
case 0x6A82:
{
if (mSecurityTokenHelper.isFidesmoToken()) {
if (isAndroidAppInstalled(FIDESMO_APP_PACKAGE)) {
promptFidesmoPgpInstall();
}
 else {
promptFidesmoAppInstall();
}
}
 else {
onSecurityTokenError(getString(R.string.security_token_error_pgp_app_not_installed));
}
break;
}
default :
{
onSecurityTokenError(getString(R.string.security_token_error,e.getMessage()));
break;
}
}
}","private void handleSecurityTokenError(IOException e){
  if (e instanceof TagLostException) {
    onSecurityTokenError(getString(R.string.security_token_error_tag_lost));
    return;
  }
  if (e instanceof IsoDepNotSupportedException) {
    onSecurityTokenError(getString(R.string.security_token_error_iso_dep_not_supported));
    return;
  }
  short status;
  if (e instanceof CardException) {
    status=((CardException)e).getResponseCode();
  }
 else {
    status=-1;
  }
  if ((status & (short)0xFFF0) == 0x63C0) {
    int tries=status & 0x000F;
    onSecurityTokenPinError(getResources().getQuantityString(R.plurals.security_token_error_pin,tries,tries));
    return;
  }
switch (status) {
case 0x6982:
{
      onSecurityTokenPinError(getString(R.string.security_token_error_security_not_satisfied));
      break;
    }
case 0x6285:
{
    onSecurityTokenError(getString(R.string.security_token_error_terminated));
    break;
  }
case 0x6700:
{
  onSecurityTokenPinError(getString(R.string.security_token_error_wrong_length));
  break;
}
case 0x6A80:
{
onSecurityTokenPinError(getString(R.string.security_token_error_bad_data));
break;
}
case 0x6983:
{
onSecurityTokenError(getString(R.string.security_token_error_authentication_blocked));
break;
}
case 0x6985:
{
onSecurityTokenError(getString(R.string.security_token_error_conditions_not_satisfied));
break;
}
case 0x6A88:
case 0x6A83:
{
onSecurityTokenError(getString(R.string.security_token_error_data_not_found));
break;
}
case 0x6F00:
{
onSecurityTokenError(getString(R.string.security_token_error_unknown));
break;
}
case 0x6A82:
{
if (mSecurityTokenHelper.isFidesmoToken()) {
if (isAndroidAppInstalled(FIDESMO_APP_PACKAGE)) {
promptFidesmoPgpInstall();
}
 else {
promptFidesmoAppInstall();
}
}
 else {
onSecurityTokenError(getString(R.string.security_token_error_pgp_app_not_installed));
}
break;
}
case 0x6883:
{
onSecurityTokenError(getString(R.string.security_token_error_chaining_error));
break;
}
case 0x6B00:
{
onSecurityTokenError(getString(R.string.security_token_error_header,""String_Node_Str""));
break;
}
case 0x6D00:
{
onSecurityTokenError(getString(R.string.security_token_error_header,""String_Node_Str""));
break;
}
case 0x6E00:
{
onSecurityTokenError(getString(R.string.security_token_error_header,""String_Node_Str""));
break;
}
default :
{
onSecurityTokenError(getString(R.string.security_token_error,e.getMessage()));
break;
}
}
}",0.5466278101582015
8241,"/** 
 * Check if device is was connected to and still is connected
 * @return true if device is connected
 */
@Override public boolean isConnected(){
  return mConnection != null && mUsbManager.getDeviceList().containsValue(mUsbDevice);
}","/** 
 * Check if device is was connected to and still is connected
 * @return true if device is connected
 */
@Override public boolean isConnected(){
  return mConnection != null && mUsbManager.getDeviceList().containsValue(mUsbDevice) && mConnection.getSerial() != null;
}",0.9315068493150684
8242,"/** 
 * Connect to OTG device
 * @throws IOException
 */
@Override public void connect() throws IOException {
  mCounter=0;
  mUsbInterface=getSmartCardInterface(mUsbDevice);
  if (mUsbInterface == null) {
    throw new UsbTransportException(""String_Node_Str"");
  }
  final Pair<UsbEndpoint,UsbEndpoint> ioEndpoints=getIoEndpoints(mUsbInterface);
  mBulkIn=ioEndpoints.first;
  mBulkOut=ioEndpoints.second;
  if (mBulkIn == null || mBulkOut == null) {
    throw new UsbTransportException(""String_Node_Str"");
  }
  mConnection=mUsbManager.openDevice(mUsbDevice);
  if (mConnection == null) {
    throw new UsbTransportException(""String_Node_Str"");
  }
  if (!mConnection.claimInterface(mUsbInterface,true)) {
    throw new UsbTransportException(""String_Node_Str"");
  }
  iccPowerSet(true);
  Log.d(Constants.TAG,""String_Node_Str"");
}","/** 
 * Connect to OTG device
 * @throws IOException
 */
@Override public void connect() throws IOException {
  mCounter=0;
  mUsbInterface=getSmartCardInterface(mUsbDevice);
  if (mUsbInterface == null) {
    throw new UsbTransportException(""String_Node_Str"");
  }
  final Pair<UsbEndpoint,UsbEndpoint> ioEndpoints=getIoEndpoints(mUsbInterface);
  mBulkIn=ioEndpoints.first;
  mBulkOut=ioEndpoints.second;
  if (mBulkIn == null || mBulkOut == null) {
    throw new UsbTransportException(""String_Node_Str"");
  }
  mConnection=mUsbManager.openDevice(mUsbDevice);
  if (mConnection == null) {
    throw new UsbTransportException(""String_Node_Str"");
  }
  if (!mConnection.claimInterface(mUsbInterface,true)) {
    throw new UsbTransportException(""String_Node_Str"");
  }
  setIccPower(true);
  Log.d(Constants.TAG,""String_Node_Str"");
}",0.9951923076923076
8243,"public void usbDeviceDiscovered(final UsbTransport transport){
  if (!mTagHandlingEnabled)   return;
  securityTokenDiscovered(transport);
}","public void usbDeviceDiscovered(final UsbDevice usbDevice){
  if (!mTagHandlingEnabled)   return;
  UsbManager usbManager=(UsbManager)getSystemService(Context.USB_SERVICE);
  securityTokenDiscovered(new UsbTransport(usbDevice,usbManager));
}",0.6299212598425197
8244,"protected void handleSmartcard(Transport transport) throws IOException {
  if (!(mSecurityTokenHelper.isConnected() && mSecurityTokenHelper.getTransport().equals(transport))) {
    mSecurityTokenHelper.setTransport(transport);
    mSecurityTokenHelper.connectToDevice();
  }
  doSecurityTokenInBackground();
}","protected void handleSmartcard(Transport transport) throws IOException {
  if (!(mSecurityTokenHelper.isPersistentConnectionAllowed() && mSecurityTokenHelper.isConnected() && mSecurityTokenHelper.getTransport().equals(transport))) {
    mSecurityTokenHelper.setTransport(transport);
    mSecurityTokenHelper.connectToDevice();
  }
  doSecurityTokenInBackground();
}",0.9169139465875372
8245,"/** 
 * Run smartcard routines if last used token is connected and supports persistent connections
 */
protected void checkDeviceConnection(){
  mUsbDispatcher.rescanDevices();
}","/** 
 * Run smartcard routines if last used token is connected and supports persistent connections
 */
public void checkDeviceConnection(){
  mUsbDispatcher.rescanDevices();
}",0.9688385269121812
8246,void usbDeviceDiscovered(UsbTransport usbTransport);,void usbDeviceDiscovered(UsbDevice usbDevice);,0.6938775510204082
8247,"public void onStart(){
  final IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(UsbEventReceiverActivity.ACTION_USB_PERMISSION);
  intentFilter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);
  mActivity.registerReceiver(mUsbReceiver,intentFilter);
}","public void onStart(){
  final IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(UsbEventReceiverActivity.ACTION_USB_PERMISSION);
  mActivity.registerReceiver(mUsbReceiver,intentFilter);
}",0.865424430641822
8248,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
switch (action) {
case UsbEventReceiverActivity.ACTION_USB_PERMISSION:
{
      UsbDevice usbDevice=intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
      boolean permission=intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED,false);
      if (permission) {
        Log.d(Constants.TAG,""String_Node_Str"" + usbDevice.getDeviceName());
        mLastUsedUsbTransport=new UsbTransport(usbDevice,mUsbManager);
        mListener.usbDeviceDiscovered(mLastUsedUsbTransport);
      }
      break;
    }
case UsbManager.ACTION_USB_DEVICE_DETACHED:
{
    UsbDevice usbDevice=intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
    if (mLastUsedUsbTransport != null && mLastUsedUsbTransport.getUsbDevice().equals(usbDevice)) {
      mLastUsedUsbTransport.release();
      mLastUsedUsbTransport=null;
    }
    break;
  }
}
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
switch (action) {
case UsbEventReceiverActivity.ACTION_USB_PERMISSION:
{
      android.hardware.usb.UsbDevice usbDevice=intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
      boolean permission=intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED,false);
      if (permission) {
        Log.d(Constants.TAG,""String_Node_Str"" + usbDevice.getDeviceName());
        mListener.usbDeviceDiscovered(usbDevice);
      }
      break;
    }
}
}",0.6880546075085324
8249,"/** 
 * Rescans devices and triggers   {@link OnDiscoveredUsbDeviceListener}
 */
public void rescanDevices(){
  for (  UsbDevice device : mUsbManager.getDeviceList().values()) {
    if (mUsbManager.hasPermission(device)) {
      if (mListener != null) {
        mListener.usbDeviceDiscovered(new UsbTransport(device,mUsbManager));
      }
      break;
    }
  }
}","/** 
 * Rescans devices and triggers   {@link OnDiscoveredUsbDeviceListener}
 */
public void rescanDevices(){
  for (  UsbDevice device : mUsbManager.getDeviceList().values()) {
    if (mUsbManager.hasPermission(device)) {
      if (mListener != null) {
        mListener.usbDeviceDiscovered(device);
      }
      break;
    }
  }
}",0.9396551724137931
8250,"PgpSignEncryptInputParcel(Parcel source){
  ClassLoader loader=getClass().getClassLoader();
  mVersionHeader=source.readString();
  mEnableAsciiArmorOutput=source.readInt() == 1;
  mCompressionAlgorithm=source.readInt();
  mEncryptionMasterKeyIds=source.createLongArray();
  mSymmetricPassphrase=source.readParcelable(loader);
  mSymmetricEncryptionAlgorithm=source.readInt();
  mSignatureMasterKeyId=source.readLong();
  mSignatureSubKeyId=source.readInt() == 1 ? source.readLong() : null;
  mSignatureHashAlgorithm=source.readInt();
  mAdditionalEncryptId=source.readLong();
  mFailOnMissingEncryptionKeyIds=source.readInt() == 1;
  mCharset=source.readString();
  mCleartextSignature=source.readInt() == 1;
  mDetachedSignature=source.readInt() == 1;
  mHiddenRecipients=source.readInt() == 1;
  mIntegrityProtected=source.readInt() == 1;
  mAddBackupHeader=source.readInt() == 1;
}","PgpSignEncryptInputParcel(Parcel source){
  ClassLoader loader=getClass().getClassLoader();
  mVersionHeader=source.readString();
  mEnableAsciiArmorOutput=source.readInt() == 1;
  mCompressionAlgorithm=source.readInt();
  mEncryptionMasterKeyIds=source.createLongArray();
  mSymmetricPassphrase=source.readParcelable(loader);
  mSymmetricEncryptionAlgorithm=source.readInt();
  mSignatureMasterKeyId=source.readLong();
  mSignatureSubKeyId=source.readInt() == 1 ? source.readLong() : null;
  mSignatureHashAlgorithm=source.readInt();
  mAdditionalEncryptId=source.readLong();
  mCharset=source.readString();
  mCleartextSignature=source.readInt() == 1;
  mDetachedSignature=source.readInt() == 1;
  mHiddenRecipients=source.readInt() == 1;
  mIntegrityProtected=source.readInt() == 1;
  mAddBackupHeader=source.readInt() == 1;
}",0.9673278879813302
8251,"@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeString(mVersionHeader);
  dest.writeInt(mEnableAsciiArmorOutput ? 1 : 0);
  dest.writeInt(mCompressionAlgorithm);
  dest.writeLongArray(mEncryptionMasterKeyIds);
  dest.writeParcelable(mSymmetricPassphrase,0);
  dest.writeInt(mSymmetricEncryptionAlgorithm);
  dest.writeLong(mSignatureMasterKeyId);
  if (mSignatureSubKeyId != null) {
    dest.writeInt(1);
    dest.writeLong(mSignatureSubKeyId);
  }
 else {
    dest.writeInt(0);
  }
  dest.writeInt(mSignatureHashAlgorithm);
  dest.writeLong(mAdditionalEncryptId);
  dest.writeInt(mFailOnMissingEncryptionKeyIds ? 1 : 0);
  dest.writeString(mCharset);
  dest.writeInt(mCleartextSignature ? 1 : 0);
  dest.writeInt(mDetachedSignature ? 1 : 0);
  dest.writeInt(mHiddenRecipients ? 1 : 0);
  dest.writeInt(mIntegrityProtected ? 1 : 0);
  dest.writeInt(mAddBackupHeader ? 1 : 0);
}","@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeString(mVersionHeader);
  dest.writeInt(mEnableAsciiArmorOutput ? 1 : 0);
  dest.writeInt(mCompressionAlgorithm);
  dest.writeLongArray(mEncryptionMasterKeyIds);
  dest.writeParcelable(mSymmetricPassphrase,0);
  dest.writeInt(mSymmetricEncryptionAlgorithm);
  dest.writeLong(mSignatureMasterKeyId);
  if (mSignatureSubKeyId != null) {
    dest.writeInt(1);
    dest.writeLong(mSignatureSubKeyId);
  }
 else {
    dest.writeInt(0);
  }
  dest.writeInt(mSignatureHashAlgorithm);
  dest.writeLong(mAdditionalEncryptId);
  dest.writeString(mCharset);
  dest.writeInt(mCleartextSignature ? 1 : 0);
  dest.writeInt(mDetachedSignature ? 1 : 0);
  dest.writeInt(mHiddenRecipients ? 1 : 0);
  dest.writeInt(mIntegrityProtected ? 1 : 0);
  dest.writeInt(mAddBackupHeader ? 1 : 0);
}",0.9673352435530086
8252,"/** 
 * Signs and/or encrypts data based on parameters of class
 */
public PgpSignEncryptResult execute(PgpSignEncryptInputParcel input,CryptoInputParcel cryptoInput,InputData inputData,OutputStream outputStream){
  int indent=0;
  OperationLog log=new OperationLog();
  log.add(LogType.MSG_PSE,indent);
  indent+=1;
  boolean enableSignature=input.getSignatureMasterKeyId() != Constants.key.none;
  boolean enableEncryption=((input.getEncryptionMasterKeyIds() != null && input.getEncryptionMasterKeyIds().length > 0) || input.getSymmetricPassphrase() != null);
  boolean enableCompression=(input.getCompressionAlgorithm() != CompressionAlgorithmTags.UNCOMPRESSED);
  Log.d(Constants.TAG,""String_Node_Str"" + enableSignature + ""String_Node_Str""+ enableEncryption+ ""String_Node_Str""+ enableCompression+ ""String_Node_Str""+ input.isEnableAsciiArmorOutput()+ ""String_Node_Str""+ input.isHiddenRecipients());
  if (enableEncryption && input.getAdditionalEncryptId() != Constants.key.none) {
    input.setEncryptionMasterKeyIds(Arrays.copyOf(input.getEncryptionMasterKeyIds(),input.getEncryptionMasterKeyIds().length + 1));
    input.getEncryptionMasterKeyIds()[input.getEncryptionMasterKeyIds().length - 1]=input.getAdditionalEncryptId();
  }
  ArmoredOutputStream armorOut=null;
  OutputStream out;
  if (input.isEnableAsciiArmorOutput()) {
    armorOut=new ArmoredOutputStream(new BufferedOutputStream(outputStream,1 << 16));
    if (input.getVersionHeader() != null) {
      armorOut.setHeader(""String_Node_Str"",input.getVersionHeader());
    }
    if (input.getCharset() != null) {
      armorOut.setHeader(""String_Node_Str"",input.getCharset());
    }
    if (input.isAddBackupHeader()) {
      armorOut.setHeader(""String_Node_Str"",""String_Node_Str"");
    }
    out=armorOut;
  }
 else {
    out=outputStream;
  }
  CanonicalizedSecretKey signingKey=null;
  if (enableSignature) {
    updateProgress(R.string.progress_extracting_signature_key,0,100);
    try {
      long signingMasterKeyId=input.getSignatureMasterKeyId();
      long signingSubKeyId=input.getSignatureSubKeyId();
{
        CanonicalizedSecretKeyRing signingKeyRing=mProviderHelper.getCanonicalizedSecretKeyRing(signingMasterKeyId);
        signingKey=signingKeyRing.getSecretKey(input.getSignatureSubKeyId());
      }
      if (!signingKey.canSign()) {
        log.add(LogType.MSG_PSE_ERROR_KEY_SIGN,indent);
        return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
      }
switch (mProviderHelper.getCachedPublicKeyRing(signingMasterKeyId).getSecretKeyType(signingSubKeyId)) {
case DIVERT_TO_CARD:
case PASSPHRASE_EMPTY:
{
          if (!signingKey.unlock(new Passphrase())) {
            throw new AssertionError(""String_Node_Str"" + ""String_Node_Str"");
          }
          break;
        }
case PIN:
case PATTERN:
case PASSPHRASE:
{
        Passphrase localPassphrase=cryptoInput.getPassphrase();
        if (localPassphrase == null) {
          try {
            localPassphrase=getCachedPassphrase(signingMasterKeyId,signingKey.getKeyId());
          }
 catch (          PassphraseCacheInterface.NoSecretKeyException ignored) {
          }
        }
        if (localPassphrase == null) {
          log.add(LogType.MSG_PSE_PENDING_PASSPHRASE,indent + 1);
          return new PgpSignEncryptResult(log,RequiredInputParcel.createRequiredSignPassphrase(signingMasterKeyId,signingKey.getKeyId(),cryptoInput.getSignatureTime()),cryptoInput);
        }
        if (!signingKey.unlock(localPassphrase)) {
          log.add(LogType.MSG_PSE_ERROR_BAD_PASSPHRASE,indent);
          return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
        }
        break;
      }
case GNU_DUMMY:
{
      log.add(LogType.MSG_PSE_ERROR_UNLOCK,indent);
      return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
    }
default :
{
    throw new AssertionError(""String_Node_Str"");
  }
}
}
 catch (ProviderHelper.NotFoundException e) {
log.add(LogType.MSG_PSE_ERROR_SIGN_KEY,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
catch (PgpGeneralException e) {
log.add(LogType.MSG_PSE_ERROR_UNLOCK,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
int requestedAlgorithm=input.getSignatureHashAlgorithm();
if (requestedAlgorithm == PgpSecurityConstants.OpenKeychainHashAlgorithmTags.USE_DEFAULT) {
input.setSignatureHashAlgorithm(PgpSecurityConstants.DEFAULT_HASH_ALGORITHM);
}
}
updateProgress(R.string.progress_preparing_streams,2,100);
PGPEncryptedDataGenerator cPk=null;
if (enableEncryption) {
int algo=input.getSymmetricEncryptionAlgorithm();
if (algo == PgpSecurityConstants.OpenKeychainSymmetricKeyAlgorithmTags.USE_DEFAULT) {
algo=PgpSecurityConstants.DEFAULT_SYMMETRIC_ALGORITHM;
}
JcePGPDataEncryptorBuilder encryptorBuilder=new JcePGPDataEncryptorBuilder(algo).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).setWithIntegrityPacket(input.isIntegrityProtected());
cPk=new PGPEncryptedDataGenerator(encryptorBuilder);
if (input.getSymmetricPassphrase() != null) {
log.add(LogType.MSG_PSE_SYMMETRIC,indent);
JcePBEKeyEncryptionMethodGenerator symmetricEncryptionGenerator=new JcePBEKeyEncryptionMethodGenerator(input.getSymmetricPassphrase().getCharArray());
cPk.addMethod(symmetricEncryptionGenerator);
}
 else {
log.add(LogType.MSG_PSE_ASYMMETRIC,indent);
for (long id : input.getEncryptionMasterKeyIds()) {
try {
  CanonicalizedPublicKeyRing keyRing=mProviderHelper.getCanonicalizedPublicKeyRing(KeyRings.buildUnifiedKeyRingUri(id));
  Set<Long> encryptSubKeyIds=keyRing.getEncryptIds();
  for (  Long subKeyId : encryptSubKeyIds) {
    CanonicalizedPublicKey key=keyRing.getPublicKey(subKeyId);
    cPk.addMethod(key.getPubKeyEncryptionGenerator(input.isHiddenRecipients()));
    log.add(LogType.MSG_PSE_KEY_OK,indent + 1,KeyFormattingUtils.convertKeyIdToHex(subKeyId));
  }
  if (encryptSubKeyIds.isEmpty()) {
    log.add(LogType.MSG_PSE_KEY_WARN,indent + 1,KeyFormattingUtils.convertKeyIdToHex(id));
    if (input.isFailOnMissingEncryptionKeyIds()) {
      return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
    }
  }
}
 catch (ProviderHelper.NotFoundException e) {
  log.add(LogType.MSG_PSE_KEY_UNKNOWN,indent + 1,KeyFormattingUtils.convertKeyIdToHex(id));
  if (input.isFailOnMissingEncryptionKeyIds()) {
    return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
  }
}
}
}
}
PGPSignatureGenerator signatureGenerator=null;
if (enableSignature) {
updateProgress(R.string.progress_preparing_signature,4,100);
try {
boolean cleartext=input.isCleartextSignature() && input.isEnableAsciiArmorOutput() && !enableEncryption;
signatureGenerator=signingKey.getDataSignatureGenerator(input.getSignatureHashAlgorithm(),cleartext,cryptoInput.getCryptoData(),cryptoInput.getSignatureTime());
}
 catch (PgpGeneralException e) {
log.add(LogType.MSG_PSE_ERROR_NFC,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
}
ProgressScaler progressScaler=new ProgressScaler(mProgressable,8,95,100);
PGPCompressedDataGenerator compressGen=null;
OutputStream pOut;
OutputStream encryptionOut=null;
BCPGOutputStream bcpgOut;
ByteArrayOutputStream detachedByteOut=null;
ArmoredOutputStream detachedArmorOut=null;
BCPGOutputStream detachedBcpgOut=null;
long opTime, startTime=System.currentTimeMillis();
try {
if (enableEncryption) {
updateProgress(R.string.progress_encrypting,8,100);
log.add(enableSignature ? LogType.MSG_PSE_SIGCRYPTING : LogType.MSG_PSE_ENCRYPTING,indent);
indent+=1;
encryptionOut=cPk.open(out,new byte[1 << 16]);
if (enableCompression) {
log.add(LogType.MSG_PSE_COMPRESSING,indent);
int algo=input.getCompressionAlgorithm();
if (algo == PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT) {
  algo=PgpSecurityConstants.DEFAULT_COMPRESSION_ALGORITHM;
}
compressGen=new PGPCompressedDataGenerator(algo);
bcpgOut=new BCPGOutputStream(compressGen.open(encryptionOut));
}
 else {
bcpgOut=new BCPGOutputStream(encryptionOut);
}
if (enableSignature) {
signatureGenerator.generateOnePassVersion(false).encode(bcpgOut);
}
PGPLiteralDataGenerator literalGen=new PGPLiteralDataGenerator();
char literalDataFormatTag;
if (input.isCleartextSignature()) {
literalDataFormatTag=PGPLiteralData.UTF8;
}
 else {
literalDataFormatTag=PGPLiteralData.BINARY;
}
pOut=literalGen.open(bcpgOut,literalDataFormatTag,inputData.getOriginalFilename(),new Date(),new byte[1 << 16]);
long alreadyWritten=0;
int length;
byte[] buffer=new byte[1 << 16];
InputStream in=new BufferedInputStream(inputData.getInputStream());
while ((length=in.read(buffer)) > 0) {
pOut.write(buffer,0,length);
if (enableSignature) {
  signatureGenerator.update(buffer,0,length);
}
alreadyWritten+=length;
if (inputData.getSize() > 0) {
  long progress=100 * alreadyWritten / inputData.getSize();
  progressScaler.setProgress((int)progress,100);
}
}
literalGen.close();
indent-=1;
}
 else if (enableSignature && input.isCleartextSignature() && input.isEnableAsciiArmorOutput()) {
updateProgress(R.string.progress_signing,8,100);
log.add(LogType.MSG_PSE_SIGNING_CLEARTEXT,indent);
armorOut.beginClearText(input.getSignatureHashAlgorithm());
InputStream in=new BufferedInputStream(inputData.getInputStream());
final BufferedReader reader=new BufferedReader(new InputStreamReader(in));
processLine(reader.readLine(),armorOut,signatureGenerator);
while (true) {
String line=reader.readLine();
if (line == null) {
  armorOut.write(NEW_LINE);
  break;
}
armorOut.write(NEW_LINE);
signatureGenerator.update(NEW_LINE);
processLine(line,armorOut,signatureGenerator);
}
armorOut.endClearText();
pOut=new BCPGOutputStream(armorOut);
}
 else if (enableSignature && input.isDetachedSignature()) {
updateProgress(R.string.progress_signing,8,100);
log.add(LogType.MSG_PSE_SIGNING_DETACHED,indent);
InputStream in=new BufferedInputStream(inputData.getInputStream());
detachedByteOut=new ByteArrayOutputStream();
OutputStream detachedOut=detachedByteOut;
if (input.isEnableAsciiArmorOutput()) {
detachedArmorOut=new ArmoredOutputStream(new BufferedOutputStream(detachedOut,1 << 16));
if (input.getVersionHeader() != null) {
  detachedArmorOut.setHeader(""String_Node_Str"",input.getVersionHeader());
}
detachedOut=detachedArmorOut;
}
detachedBcpgOut=new BCPGOutputStream(detachedOut);
long alreadyWritten=0;
int length;
byte[] buffer=new byte[1 << 16];
while ((length=in.read(buffer)) > 0) {
signatureGenerator.update(buffer,0,length);
alreadyWritten+=length;
if (inputData.getSize() > 0) {
  long progress=100 * alreadyWritten / inputData.getSize();
  progressScaler.setProgress((int)progress,100);
}
}
pOut=null;
}
 else if (enableSignature && !input.isCleartextSignature() && !input.isDetachedSignature()) {
updateProgress(R.string.progress_signing,8,100);
log.add(LogType.MSG_PSE_SIGNING,indent);
InputStream in=new BufferedInputStream(inputData.getInputStream());
if (enableCompression) {
int algo=input.getCompressionAlgorithm();
if (algo == PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT) {
  algo=PgpSecurityConstants.DEFAULT_COMPRESSION_ALGORITHM;
}
compressGen=new PGPCompressedDataGenerator(algo);
bcpgOut=new BCPGOutputStream(compressGen.open(out));
}
 else {
bcpgOut=new BCPGOutputStream(out);
}
signatureGenerator.generateOnePassVersion(false).encode(bcpgOut);
PGPLiteralDataGenerator literalGen=new PGPLiteralDataGenerator();
pOut=literalGen.open(bcpgOut,PGPLiteralData.BINARY,inputData.getOriginalFilename(),new Date(),new byte[1 << 16]);
long alreadyWritten=0;
int length;
byte[] buffer=new byte[1 << 16];
while ((length=in.read(buffer)) > 0) {
pOut.write(buffer,0,length);
signatureGenerator.update(buffer,0,length);
alreadyWritten+=length;
if (inputData.getSize() > 0) {
  long progress=100 * alreadyWritten / inputData.getSize();
  progressScaler.setProgress((int)progress,100);
}
}
literalGen.close();
}
 else {
throw new AssertionError(""String_Node_Str"");
}
if (enableSignature) {
updateProgress(R.string.progress_generating_signature,95,100);
try {
if (detachedBcpgOut != null) {
  signatureGenerator.generate().encode(detachedBcpgOut);
}
 else {
  signatureGenerator.generate().encode(pOut);
}
}
 catch (NfcSyncPGPContentSignerBuilder.NfcInteractionNeeded e) {
log.add(LogType.MSG_PSE_PENDING_NFC,indent);
return new PgpSignEncryptResult(log,RequiredInputParcel.createNfcSignOperation(signingKey.getRing().getMasterKeyId(),signingKey.getKeyId(),e.hashToSign,e.hashAlgo,cryptoInput.getSignatureTime()),cryptoInput);
}
}
opTime=System.currentTimeMillis() - startTime;
Log.d(Constants.TAG,""String_Node_Str"" + String.format(""String_Node_Str"",opTime / 1000.0) + ""String_Node_Str"");
if (encryptionOut != null) {
if (compressGen != null) {
compressGen.close();
}
encryptionOut.close();
}
if (armorOut != null) {
armorOut.close();
}
if (detachedArmorOut != null) {
detachedArmorOut.close();
}
if (detachedByteOut != null) {
detachedByteOut.close();
}
if (out != null) {
out.close();
}
if (outputStream != null) {
outputStream.close();
}
}
 catch (SignatureException e) {
log.add(LogType.MSG_PSE_ERROR_SIG,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
catch (PGPException e) {
log.add(LogType.MSG_PSE_ERROR_PGP,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
catch (IOException e) {
log.add(LogType.MSG_PSE_ERROR_IO,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
updateProgress(R.string.progress_done,100,100);
log.add(LogType.MSG_PSE_OK,indent);
PgpSignEncryptResult result=new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_OK,log);
result.mOperationTime=opTime;
if (detachedByteOut != null) {
try {
detachedByteOut.flush();
detachedByteOut.close();
}
 catch (IOException e) {
}
result.setDetachedSignature(detachedByteOut.toByteArray());
try {
String digestName=PGPUtil.getDigestName(input.getSignatureHashAlgorithm());
result.setMicAlgDigestName(""String_Node_Str"" + digestName.toLowerCase());
}
 catch (PGPException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
}
}
return result;
}","/** 
 * Signs and/or encrypts data based on parameters of class
 */
public PgpSignEncryptResult execute(PgpSignEncryptInputParcel input,CryptoInputParcel cryptoInput,InputData inputData,OutputStream outputStream){
  int indent=0;
  OperationLog log=new OperationLog();
  log.add(LogType.MSG_PSE,indent);
  indent+=1;
  boolean enableSignature=input.getSignatureMasterKeyId() != Constants.key.none;
  boolean enableEncryption=((input.getEncryptionMasterKeyIds() != null && input.getEncryptionMasterKeyIds().length > 0) || input.getSymmetricPassphrase() != null);
  boolean enableCompression=(input.getCompressionAlgorithm() != CompressionAlgorithmTags.UNCOMPRESSED);
  Log.d(Constants.TAG,""String_Node_Str"" + enableSignature + ""String_Node_Str""+ enableEncryption+ ""String_Node_Str""+ enableCompression+ ""String_Node_Str""+ input.isEnableAsciiArmorOutput()+ ""String_Node_Str""+ input.isHiddenRecipients());
  if (enableEncryption && input.getAdditionalEncryptId() != Constants.key.none) {
    input.setEncryptionMasterKeyIds(Arrays.copyOf(input.getEncryptionMasterKeyIds(),input.getEncryptionMasterKeyIds().length + 1));
    input.getEncryptionMasterKeyIds()[input.getEncryptionMasterKeyIds().length - 1]=input.getAdditionalEncryptId();
  }
  ArmoredOutputStream armorOut=null;
  OutputStream out;
  if (input.isEnableAsciiArmorOutput()) {
    armorOut=new ArmoredOutputStream(new BufferedOutputStream(outputStream,1 << 16));
    if (input.getVersionHeader() != null) {
      armorOut.setHeader(""String_Node_Str"",input.getVersionHeader());
    }
    if (input.getCharset() != null) {
      armorOut.setHeader(""String_Node_Str"",input.getCharset());
    }
    if (input.isAddBackupHeader()) {
      armorOut.setHeader(""String_Node_Str"",""String_Node_Str"");
    }
    out=armorOut;
  }
 else {
    out=outputStream;
  }
  CanonicalizedSecretKey signingKey=null;
  if (enableSignature) {
    updateProgress(R.string.progress_extracting_signature_key,0,100);
    try {
      long signingMasterKeyId=input.getSignatureMasterKeyId();
      long signingSubKeyId=input.getSignatureSubKeyId();
      CanonicalizedSecretKeyRing signingKeyRing=mProviderHelper.getCanonicalizedSecretKeyRing(signingMasterKeyId);
      signingKey=signingKeyRing.getSecretKey(input.getSignatureSubKeyId());
      if (signingKeyRing.isExpired() || signingKeyRing.isRevoked() || signingKey.isExpired()|| signingKey.isRevoked()) {
        log.add(LogType.MSG_PSE_ERROR_REVOKED_OR_EXPIRED,indent);
        return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
      }
      if (!signingKey.canSign()) {
        log.add(LogType.MSG_PSE_ERROR_KEY_SIGN,indent);
        return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
      }
switch (mProviderHelper.getCachedPublicKeyRing(signingMasterKeyId).getSecretKeyType(signingSubKeyId)) {
case DIVERT_TO_CARD:
case PASSPHRASE_EMPTY:
{
          if (!signingKey.unlock(new Passphrase())) {
            throw new AssertionError(""String_Node_Str"" + ""String_Node_Str"");
          }
          break;
        }
case PIN:
case PATTERN:
case PASSPHRASE:
{
        Passphrase localPassphrase=cryptoInput.getPassphrase();
        if (localPassphrase == null) {
          try {
            localPassphrase=getCachedPassphrase(signingMasterKeyId,signingKey.getKeyId());
          }
 catch (          PassphraseCacheInterface.NoSecretKeyException ignored) {
          }
        }
        if (localPassphrase == null) {
          log.add(LogType.MSG_PSE_PENDING_PASSPHRASE,indent + 1);
          return new PgpSignEncryptResult(log,RequiredInputParcel.createRequiredSignPassphrase(signingMasterKeyId,signingKey.getKeyId(),cryptoInput.getSignatureTime()),cryptoInput);
        }
        if (!signingKey.unlock(localPassphrase)) {
          log.add(LogType.MSG_PSE_ERROR_BAD_PASSPHRASE,indent);
          return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
        }
        break;
      }
case GNU_DUMMY:
{
      log.add(LogType.MSG_PSE_ERROR_UNLOCK,indent);
      return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
    }
default :
{
    throw new AssertionError(""String_Node_Str"");
  }
}
}
 catch (ProviderHelper.NotFoundException e) {
log.add(LogType.MSG_PSE_ERROR_SIGN_KEY,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
catch (PgpGeneralException e) {
log.add(LogType.MSG_PSE_ERROR_UNLOCK,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
int requestedAlgorithm=input.getSignatureHashAlgorithm();
if (requestedAlgorithm == PgpSecurityConstants.OpenKeychainHashAlgorithmTags.USE_DEFAULT) {
input.setSignatureHashAlgorithm(PgpSecurityConstants.DEFAULT_HASH_ALGORITHM);
}
}
updateProgress(R.string.progress_preparing_streams,2,100);
PGPEncryptedDataGenerator cPk=null;
if (enableEncryption) {
int algo=input.getSymmetricEncryptionAlgorithm();
if (algo == PgpSecurityConstants.OpenKeychainSymmetricKeyAlgorithmTags.USE_DEFAULT) {
algo=PgpSecurityConstants.DEFAULT_SYMMETRIC_ALGORITHM;
}
JcePGPDataEncryptorBuilder encryptorBuilder=new JcePGPDataEncryptorBuilder(algo).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).setWithIntegrityPacket(input.isIntegrityProtected());
cPk=new PGPEncryptedDataGenerator(encryptorBuilder);
if (input.getSymmetricPassphrase() != null) {
log.add(LogType.MSG_PSE_SYMMETRIC,indent);
JcePBEKeyEncryptionMethodGenerator symmetricEncryptionGenerator=new JcePBEKeyEncryptionMethodGenerator(input.getSymmetricPassphrase().getCharArray());
cPk.addMethod(symmetricEncryptionGenerator);
}
 else {
log.add(LogType.MSG_PSE_ASYMMETRIC,indent);
for (long id : input.getEncryptionMasterKeyIds()) {
try {
  CanonicalizedPublicKeyRing keyRing=mProviderHelper.getCanonicalizedPublicKeyRing(KeyRings.buildUnifiedKeyRingUri(id));
  Set<Long> encryptSubKeyIds=keyRing.getEncryptIds();
  for (  Long subKeyId : encryptSubKeyIds) {
    CanonicalizedPublicKey key=keyRing.getPublicKey(subKeyId);
    cPk.addMethod(key.getPubKeyEncryptionGenerator(input.isHiddenRecipients()));
    log.add(LogType.MSG_PSE_KEY_OK,indent + 1,KeyFormattingUtils.convertKeyIdToHex(subKeyId));
  }
  if (encryptSubKeyIds.isEmpty()) {
    log.add(LogType.MSG_PSE_KEY_WARN,indent + 1,KeyFormattingUtils.convertKeyIdToHex(id));
    return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
  }
  if (keyRing.isExpired() || keyRing.isRevoked()) {
    log.add(LogType.MSG_PSE_ERROR_REVOKED_OR_EXPIRED,indent);
    return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
  }
}
 catch (ProviderHelper.NotFoundException e) {
  log.add(LogType.MSG_PSE_KEY_UNKNOWN,indent + 1,KeyFormattingUtils.convertKeyIdToHex(id));
  return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
}
}
}
PGPSignatureGenerator signatureGenerator=null;
if (enableSignature) {
updateProgress(R.string.progress_preparing_signature,4,100);
try {
boolean cleartext=input.isCleartextSignature() && input.isEnableAsciiArmorOutput() && !enableEncryption;
signatureGenerator=signingKey.getDataSignatureGenerator(input.getSignatureHashAlgorithm(),cleartext,cryptoInput.getCryptoData(),cryptoInput.getSignatureTime());
}
 catch (PgpGeneralException e) {
log.add(LogType.MSG_PSE_ERROR_NFC,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
}
ProgressScaler progressScaler=new ProgressScaler(mProgressable,8,95,100);
PGPCompressedDataGenerator compressGen=null;
OutputStream pOut;
OutputStream encryptionOut=null;
BCPGOutputStream bcpgOut;
ByteArrayOutputStream detachedByteOut=null;
ArmoredOutputStream detachedArmorOut=null;
BCPGOutputStream detachedBcpgOut=null;
long opTime, startTime=System.currentTimeMillis();
try {
if (enableEncryption) {
updateProgress(R.string.progress_encrypting,8,100);
log.add(enableSignature ? LogType.MSG_PSE_SIGCRYPTING : LogType.MSG_PSE_ENCRYPTING,indent);
indent+=1;
encryptionOut=cPk.open(out,new byte[1 << 16]);
if (enableCompression) {
log.add(LogType.MSG_PSE_COMPRESSING,indent);
int algo=input.getCompressionAlgorithm();
if (algo == PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT) {
  algo=PgpSecurityConstants.DEFAULT_COMPRESSION_ALGORITHM;
}
compressGen=new PGPCompressedDataGenerator(algo);
bcpgOut=new BCPGOutputStream(compressGen.open(encryptionOut));
}
 else {
bcpgOut=new BCPGOutputStream(encryptionOut);
}
if (enableSignature) {
signatureGenerator.generateOnePassVersion(false).encode(bcpgOut);
}
PGPLiteralDataGenerator literalGen=new PGPLiteralDataGenerator();
char literalDataFormatTag;
if (input.isCleartextSignature()) {
literalDataFormatTag=PGPLiteralData.UTF8;
}
 else {
literalDataFormatTag=PGPLiteralData.BINARY;
}
pOut=literalGen.open(bcpgOut,literalDataFormatTag,inputData.getOriginalFilename(),new Date(),new byte[1 << 16]);
long alreadyWritten=0;
int length;
byte[] buffer=new byte[1 << 16];
InputStream in=new BufferedInputStream(inputData.getInputStream());
while ((length=in.read(buffer)) > 0) {
pOut.write(buffer,0,length);
if (enableSignature) {
  signatureGenerator.update(buffer,0,length);
}
alreadyWritten+=length;
if (inputData.getSize() > 0) {
  long progress=100 * alreadyWritten / inputData.getSize();
  progressScaler.setProgress((int)progress,100);
}
}
literalGen.close();
indent-=1;
}
 else if (enableSignature && input.isCleartextSignature() && input.isEnableAsciiArmorOutput()) {
updateProgress(R.string.progress_signing,8,100);
log.add(LogType.MSG_PSE_SIGNING_CLEARTEXT,indent);
armorOut.beginClearText(input.getSignatureHashAlgorithm());
InputStream in=new BufferedInputStream(inputData.getInputStream());
final BufferedReader reader=new BufferedReader(new InputStreamReader(in));
processLine(reader.readLine(),armorOut,signatureGenerator);
while (true) {
String line=reader.readLine();
if (line == null) {
  armorOut.write(NEW_LINE);
  break;
}
armorOut.write(NEW_LINE);
signatureGenerator.update(NEW_LINE);
processLine(line,armorOut,signatureGenerator);
}
armorOut.endClearText();
pOut=new BCPGOutputStream(armorOut);
}
 else if (enableSignature && input.isDetachedSignature()) {
updateProgress(R.string.progress_signing,8,100);
log.add(LogType.MSG_PSE_SIGNING_DETACHED,indent);
InputStream in=new BufferedInputStream(inputData.getInputStream());
detachedByteOut=new ByteArrayOutputStream();
OutputStream detachedOut=detachedByteOut;
if (input.isEnableAsciiArmorOutput()) {
detachedArmorOut=new ArmoredOutputStream(new BufferedOutputStream(detachedOut,1 << 16));
if (input.getVersionHeader() != null) {
  detachedArmorOut.setHeader(""String_Node_Str"",input.getVersionHeader());
}
detachedOut=detachedArmorOut;
}
detachedBcpgOut=new BCPGOutputStream(detachedOut);
long alreadyWritten=0;
int length;
byte[] buffer=new byte[1 << 16];
while ((length=in.read(buffer)) > 0) {
signatureGenerator.update(buffer,0,length);
alreadyWritten+=length;
if (inputData.getSize() > 0) {
  long progress=100 * alreadyWritten / inputData.getSize();
  progressScaler.setProgress((int)progress,100);
}
}
pOut=null;
}
 else if (enableSignature && !input.isCleartextSignature() && !input.isDetachedSignature()) {
updateProgress(R.string.progress_signing,8,100);
log.add(LogType.MSG_PSE_SIGNING,indent);
InputStream in=new BufferedInputStream(inputData.getInputStream());
if (enableCompression) {
int algo=input.getCompressionAlgorithm();
if (algo == PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT) {
  algo=PgpSecurityConstants.DEFAULT_COMPRESSION_ALGORITHM;
}
compressGen=new PGPCompressedDataGenerator(algo);
bcpgOut=new BCPGOutputStream(compressGen.open(out));
}
 else {
bcpgOut=new BCPGOutputStream(out);
}
signatureGenerator.generateOnePassVersion(false).encode(bcpgOut);
PGPLiteralDataGenerator literalGen=new PGPLiteralDataGenerator();
pOut=literalGen.open(bcpgOut,PGPLiteralData.BINARY,inputData.getOriginalFilename(),new Date(),new byte[1 << 16]);
long alreadyWritten=0;
int length;
byte[] buffer=new byte[1 << 16];
while ((length=in.read(buffer)) > 0) {
pOut.write(buffer,0,length);
signatureGenerator.update(buffer,0,length);
alreadyWritten+=length;
if (inputData.getSize() > 0) {
  long progress=100 * alreadyWritten / inputData.getSize();
  progressScaler.setProgress((int)progress,100);
}
}
literalGen.close();
}
 else {
throw new AssertionError(""String_Node_Str"");
}
if (enableSignature) {
updateProgress(R.string.progress_generating_signature,95,100);
try {
if (detachedBcpgOut != null) {
  signatureGenerator.generate().encode(detachedBcpgOut);
}
 else {
  signatureGenerator.generate().encode(pOut);
}
}
 catch (NfcSyncPGPContentSignerBuilder.NfcInteractionNeeded e) {
log.add(LogType.MSG_PSE_PENDING_NFC,indent);
return new PgpSignEncryptResult(log,RequiredInputParcel.createNfcSignOperation(signingKey.getRing().getMasterKeyId(),signingKey.getKeyId(),e.hashToSign,e.hashAlgo,cryptoInput.getSignatureTime()),cryptoInput);
}
}
opTime=System.currentTimeMillis() - startTime;
Log.d(Constants.TAG,""String_Node_Str"" + String.format(""String_Node_Str"",opTime / 1000.0) + ""String_Node_Str"");
if (encryptionOut != null) {
if (compressGen != null) {
compressGen.close();
}
encryptionOut.close();
}
if (armorOut != null) {
armorOut.close();
}
if (detachedArmorOut != null) {
detachedArmorOut.close();
}
if (detachedByteOut != null) {
detachedByteOut.close();
}
if (out != null) {
out.close();
}
if (outputStream != null) {
outputStream.close();
}
}
 catch (SignatureException e) {
log.add(LogType.MSG_PSE_ERROR_SIG,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
catch (PGPException e) {
log.add(LogType.MSG_PSE_ERROR_PGP,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
catch (IOException e) {
log.add(LogType.MSG_PSE_ERROR_IO,indent);
return new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_ERROR,log);
}
updateProgress(R.string.progress_done,100,100);
log.add(LogType.MSG_PSE_OK,indent);
PgpSignEncryptResult result=new PgpSignEncryptResult(PgpSignEncryptResult.RESULT_OK,log);
result.mOperationTime=opTime;
if (detachedByteOut != null) {
try {
detachedByteOut.flush();
detachedByteOut.close();
}
 catch (IOException e) {
}
result.setDetachedSignature(detachedByteOut.toByteArray());
try {
String digestName=PGPUtil.getDigestName(input.getSignatureHashAlgorithm());
result.setMicAlgDigestName(""String_Node_Str"" + digestName.toLowerCase());
}
 catch (PGPException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
}
}
return result;
}",0.979826074710418
8253,"private Intent encryptAndSignImpl(Intent data,InputStream inputStream,OutputStream outputStream,boolean sign){
  try {
    boolean asciiArmor=data.getBooleanExtra(OpenPgpApi.EXTRA_REQUEST_ASCII_ARMOR,true);
    String originalFilename=data.getStringExtra(OpenPgpApi.EXTRA_ORIGINAL_FILENAME);
    if (originalFilename == null) {
      originalFilename=""String_Node_Str"";
    }
    boolean enableCompression=data.getBooleanExtra(OpenPgpApi.EXTRA_ENABLE_COMPRESSION,true);
    int compressionId;
    if (enableCompression) {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT;
    }
 else {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.UNCOMPRESSED;
    }
    long[] keyIds;
{
      HashSet<Long> encryptKeyIds=new HashSet<>();
      if (data.hasExtra(OpenPgpApi.EXTRA_USER_IDS)) {
        String[] userIds=data.getStringArrayExtra(OpenPgpApi.EXTRA_USER_IDS);
        boolean isOpportunistic=data.getBooleanExtra(OpenPgpApi.EXTRA_OPPORTUNISTIC_ENCRYPTION,false);
        KeyIdResult result=returnKeyIdsFromEmails(data,userIds,isOpportunistic);
        if (result.mResultIntent != null) {
          return result.mResultIntent;
        }
        encryptKeyIds.addAll(result.mKeyIds);
      }
      if (data.hasExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
        for (        long keyId : data.getLongArrayExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
          encryptKeyIds.add(keyId);
        }
      }
      keyIds=getUnboxedLongArray(encryptKeyIds);
    }
    long inputLength=inputStream.available();
    InputData inputData=new InputData(inputStream,inputLength,originalFilename);
    PgpSignEncryptInputParcel pseInput=new PgpSignEncryptInputParcel();
    pseInput.setEnableAsciiArmorOutput(asciiArmor).setVersionHeader(null).setCompressionAlgorithm(compressionId).setSymmetricEncryptionAlgorithm(PgpSecurityConstants.OpenKeychainSymmetricKeyAlgorithmTags.USE_DEFAULT).setEncryptionMasterKeyIds(keyIds).setFailOnMissingEncryptionKeyIds(true);
    if (sign) {
      Intent signKeyIdIntent=getSignKeyMasterId(data);
      if (signKeyIdIntent.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR) == OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED) {
        return signKeyIdIntent;
      }
      long signKeyId=signKeyIdIntent.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,Constants.key.none);
      if (signKeyId == Constants.key.none) {
        throw new Exception(""String_Node_Str"");
      }
 else {
        pseInput.setSignatureMasterKeyId(signKeyId);
        try {
          long signSubKeyId=mProviderHelper.getCachedPublicKeyRing(pseInput.getSignatureMasterKeyId()).getSecretSignId();
          pseInput.setSignatureSubKeyId(signSubKeyId);
        }
 catch (        PgpKeyNotFoundException e) {
          throw new Exception(""String_Node_Str"",e);
        }
      }
      pseInput.setSignatureHashAlgorithm(PgpSecurityConstants.OpenKeychainHashAlgorithmTags.USE_DEFAULT).setAdditionalEncryptId(signKeyId);
    }
    if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) < 7) {
      String accName=data.getStringExtra(OpenPgpApi.EXTRA_ACCOUNT_NAME);
      if (TextUtils.isEmpty(accName)) {
        accName=""String_Node_Str"";
      }
      final AccountSettings accSettings=mApiPermissionHelper.getAccSettings(accName);
      if (accSettings == null || (accSettings.getKeyId() == Constants.key.none)) {
        return mApiPermissionHelper.getCreateAccountIntent(data,accName);
      }
      pseInput.setAdditionalEncryptId(accSettings.getKeyId());
    }
    CryptoInputParcel inputParcel=CryptoInputParcelCacheService.getCryptoInputParcel(this,data);
    if (inputParcel == null) {
      inputParcel=new CryptoInputParcel(new Date());
    }
    if (data.hasExtra(OpenPgpApi.EXTRA_PASSPHRASE)) {
      inputParcel.mPassphrase=new Passphrase(data.getCharArrayExtra(OpenPgpApi.EXTRA_PASSPHRASE));
    }
    PgpSignEncryptOperation op=new PgpSignEncryptOperation(this,mProviderHelper,null);
    PgpSignEncryptResult pgpResult=op.execute(pseInput,inputParcel,inputData,outputStream);
    if (pgpResult.isPending()) {
      ApiPendingIntentFactory piFactory=new ApiPendingIntentFactory(getBaseContext());
      RequiredInputParcel requiredInput=pgpResult.getRequiredInputParcel();
      PendingIntent pIntent=piFactory.requiredInputPi(data,requiredInput,pgpResult.mCryptoInputParcel);
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_INTENT,pIntent);
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      return result;
    }
 else     if (pgpResult.success()) {
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
      return result;
    }
 else {
      LogEntryParcel errorMsg=pgpResult.getLog().getLast();
      throw new Exception(getString(errorMsg.mType.getMsgId()));
    }
  }
 catch (  Exception e) {
    Log.d(Constants.TAG,""String_Node_Str"",e);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.GENERIC_ERROR,e.getMessage()));
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
    return result;
  }
}","private Intent encryptAndSignImpl(Intent data,InputStream inputStream,OutputStream outputStream,boolean sign){
  try {
    boolean asciiArmor=data.getBooleanExtra(OpenPgpApi.EXTRA_REQUEST_ASCII_ARMOR,true);
    String originalFilename=data.getStringExtra(OpenPgpApi.EXTRA_ORIGINAL_FILENAME);
    if (originalFilename == null) {
      originalFilename=""String_Node_Str"";
    }
    boolean enableCompression=data.getBooleanExtra(OpenPgpApi.EXTRA_ENABLE_COMPRESSION,true);
    int compressionId;
    if (enableCompression) {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT;
    }
 else {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.UNCOMPRESSED;
    }
    long[] keyIds;
{
      HashSet<Long> encryptKeyIds=new HashSet<>();
      if (data.hasExtra(OpenPgpApi.EXTRA_USER_IDS)) {
        String[] userIds=data.getStringArrayExtra(OpenPgpApi.EXTRA_USER_IDS);
        boolean isOpportunistic=data.getBooleanExtra(OpenPgpApi.EXTRA_OPPORTUNISTIC_ENCRYPTION,false);
        KeyIdResult result=returnKeyIdsFromEmails(data,userIds,isOpportunistic);
        if (result.mResultIntent != null) {
          return result.mResultIntent;
        }
        encryptKeyIds.addAll(result.mKeyIds);
      }
      if (data.hasExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
        for (        long keyId : data.getLongArrayExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
          encryptKeyIds.add(keyId);
        }
      }
      keyIds=getUnboxedLongArray(encryptKeyIds);
    }
    long inputLength=inputStream.available();
    InputData inputData=new InputData(inputStream,inputLength,originalFilename);
    PgpSignEncryptInputParcel pseInput=new PgpSignEncryptInputParcel();
    pseInput.setEnableAsciiArmorOutput(asciiArmor).setVersionHeader(null).setCompressionAlgorithm(compressionId).setSymmetricEncryptionAlgorithm(PgpSecurityConstants.OpenKeychainSymmetricKeyAlgorithmTags.USE_DEFAULT).setEncryptionMasterKeyIds(keyIds);
    if (sign) {
      Intent signKeyIdIntent=getSignKeyMasterId(data);
      if (signKeyIdIntent.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR) == OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED) {
        return signKeyIdIntent;
      }
      long signKeyId=signKeyIdIntent.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,Constants.key.none);
      if (signKeyId == Constants.key.none) {
        throw new Exception(""String_Node_Str"");
      }
 else {
        pseInput.setSignatureMasterKeyId(signKeyId);
        try {
          long signSubKeyId=mProviderHelper.getCachedPublicKeyRing(pseInput.getSignatureMasterKeyId()).getSecretSignId();
          pseInput.setSignatureSubKeyId(signSubKeyId);
        }
 catch (        PgpKeyNotFoundException e) {
          throw new Exception(""String_Node_Str"",e);
        }
      }
      pseInput.setSignatureHashAlgorithm(PgpSecurityConstants.OpenKeychainHashAlgorithmTags.USE_DEFAULT).setAdditionalEncryptId(signKeyId);
    }
    if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) < 7) {
      String accName=data.getStringExtra(OpenPgpApi.EXTRA_ACCOUNT_NAME);
      if (TextUtils.isEmpty(accName)) {
        accName=""String_Node_Str"";
      }
      final AccountSettings accSettings=mApiPermissionHelper.getAccSettings(accName);
      if (accSettings == null || (accSettings.getKeyId() == Constants.key.none)) {
        return mApiPermissionHelper.getCreateAccountIntent(data,accName);
      }
      pseInput.setAdditionalEncryptId(accSettings.getKeyId());
    }
    CryptoInputParcel inputParcel=CryptoInputParcelCacheService.getCryptoInputParcel(this,data);
    if (inputParcel == null) {
      inputParcel=new CryptoInputParcel(new Date());
    }
    if (data.hasExtra(OpenPgpApi.EXTRA_PASSPHRASE)) {
      inputParcel.mPassphrase=new Passphrase(data.getCharArrayExtra(OpenPgpApi.EXTRA_PASSPHRASE));
    }
    PgpSignEncryptOperation op=new PgpSignEncryptOperation(this,mProviderHelper,null);
    PgpSignEncryptResult pgpResult=op.execute(pseInput,inputParcel,inputData,outputStream);
    if (pgpResult.isPending()) {
      ApiPendingIntentFactory piFactory=new ApiPendingIntentFactory(getBaseContext());
      RequiredInputParcel requiredInput=pgpResult.getRequiredInputParcel();
      PendingIntent pIntent=piFactory.requiredInputPi(data,requiredInput,pgpResult.mCryptoInputParcel);
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_INTENT,pIntent);
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      return result;
    }
 else     if (pgpResult.success()) {
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
      return result;
    }
 else {
      LogEntryParcel errorMsg=pgpResult.getLog().getLast();
      throw new Exception(getString(errorMsg.mType.getMsgId()));
    }
  }
 catch (  Exception e) {
    Log.d(Constants.TAG,""String_Node_Str"",e);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.GENERIC_ERROR,e.getMessage()));
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
    return result;
  }
}",0.996224954021876
8254,"public KeyItem(CanonicalizedPublicKeyRing ring){
  CanonicalizedPublicKey key=ring.getPublicKey();
  String userId=key.getPrimaryUserIdWithFallback();
  mUserId=KeyRing.splitUserId(userId);
  mUserIdFull=userId;
  mKeyId=ring.getMasterKeyId();
  mHasDuplicate=false;
  mCreation=key.getCreationTime();
  mFingerprint=KeyFormattingUtils.convertFingerprintToHex(ring.getFingerprint());
  mIsRevoked=key.isRevoked();
  mIsExpired=key.isExpired();
  mIsSecret=false;
  mIsVerified=false;
}","public KeyItem(CanonicalizedPublicKeyRing ring){
  CanonicalizedPublicKey key=ring.getPublicKey();
  String userId=key.getPrimaryUserIdWithFallback();
  mUserId=KeyRing.splitUserId(userId);
  mUserIdFull=userId;
  mKeyId=ring.getMasterKeyId();
  mHasDuplicate=false;
  mHasEncrypt=key.getKeyRing().getEncryptIds().size() > 0;
  mCreation=key.getCreationTime();
  mFingerprint=KeyFormattingUtils.convertFingerprintToHex(ring.getFingerprint());
  mIsRevoked=key.isRevoked();
  mIsExpired=key.isExpired();
  mIsSecret=false;
  mIsVerified=false;
}",0.9426627793974732
8255,"@Override protected View getViewForObject(KeyItem keyItem){
  LayoutInflater l=LayoutInflater.from(getContext());
  View view=l.inflate(R.layout.recipient_box_entry,null);
  ((TextView)view.findViewById(android.R.id.text1)).setText(keyItem.getReadableName());
  return view;
}","@Override protected View getViewForObject(KeyItem keyItem){
  LayoutInflater l=LayoutInflater.from(getContext());
  View view=l.inflate(R.layout.recipient_box_entry,null);
  ((TextView)view.findViewById(android.R.id.text1)).setText(keyItem.getReadableName());
  if (keyItem.mIsRevoked || !keyItem.mHasEncrypt || keyItem.mIsExpired) {
    ((TextView)view.findViewById(android.R.id.text1)).setTextColor(Color.RED);
  }
  return view;
}",0.7785613540197461
8256,"public ArrayList<CertifyActionsParcel.CertifyAction> getSelectedCertifyActions(){
  return mUserIdsAdapter.getSelectedCertifyActions();
}","public ArrayList<CertifyActionsParcel.CertifyAction> getSelectedCertifyActions(){
  if (!checkboxVisibility) {
    throw new AssertionError(""String_Node_Str"");
  }
  return mUserIdsAdapter.getSelectedCertifyActions();
}",0.7696629213483146
8257,"@Override public void onActivityCreated(@Nullable Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  mPubMasterKeyIds=getActivity().getIntent().getLongArrayExtra(EXTRA_KEY_IDS);
  if (mPubMasterKeyIds == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    getActivity().finish();
    return;
  }
  ArrayList<Boolean> checkedStates=null;
  if (savedInstanceState != null) {
    checkedStates=(ArrayList<Boolean>)savedInstanceState.getSerializable(ARG_CHECK_STATES);
  }
  mUserIdsAdapter=new MultiUserIdsAdapter(getActivity(),null,0,checkedStates);
  mUserIds.setAdapter(mUserIdsAdapter);
  mUserIds.setDividerHeight(0);
  getLoaderManager().initLoader(0,null,this);
}","@Override public void onActivityCreated(@Nullable Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  mPubMasterKeyIds=getActivity().getIntent().getLongArrayExtra(EXTRA_KEY_IDS);
  if (mPubMasterKeyIds == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    getActivity().finish();
    return;
  }
  ArrayList<Boolean> checkedStates=null;
  if (savedInstanceState != null) {
    checkedStates=(ArrayList<Boolean>)savedInstanceState.getSerializable(ARG_CHECK_STATES);
  }
  mUserIdsAdapter=new MultiUserIdsAdapter(getActivity(),null,0,checkedStates,checkboxVisibility);
  mUserIds.setAdapter(mUserIdsAdapter);
  mUserIds.setDividerHeight(0);
  getLoaderManager().initLoader(0,null,this);
}",0.9865534324133052
8258,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mUploadButton=findViewById(R.id.upload_key_action_upload);
  mKeyServerSpinner=(Spinner)findViewById(R.id.upload_key_keyserver);
  ArrayAdapter<String> adapter=new ArrayAdapter<>(this,android.R.layout.simple_spinner_item,Preferences.getPreferences(this).getKeyServers());
  adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  mKeyServerSpinner.setAdapter(adapter);
  if (adapter.getCount() > 0) {
    mKeyServerSpinner.setSelection(0);
  }
 else {
    mUploadButton.setEnabled(false);
  }
  mUploadButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      uploadKey();
    }
  }
);
  mDataUri=getIntent().getData();
  if (mDataUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
  try {
    mMasterKeyId=new ProviderHelper(this).getCachedPublicKeyRing(KeyRings.buildUnifiedKeyRingUri(mDataUri)).getMasterKeyId();
  }
 catch (  PgpKeyNotFoundException e) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mUploadButton=findViewById(R.id.upload_key_action_upload);
  mKeyServerSpinner=(Spinner)findViewById(R.id.upload_key_keyserver);
  MultiUserIdsFragment mMultiUserIdsFragment=(MultiUserIdsFragment)getSupportFragmentManager().findFragmentById(R.id.multi_user_ids_fragment);
  mMultiUserIdsFragment.setCheckboxVisibility(false);
  ArrayAdapter<String> adapter=new ArrayAdapter<>(this,android.R.layout.simple_spinner_item,Preferences.getPreferences(this).getKeyServers());
  adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  mKeyServerSpinner.setAdapter(adapter);
  if (adapter.getCount() > 0) {
    mKeyServerSpinner.setSelection(0);
  }
 else {
    mUploadButton.setEnabled(false);
  }
  mUploadButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      uploadKey();
    }
  }
);
  mDataUri=getIntent().getData();
  if (mDataUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
}",0.7994628469113697
8259,"@Override public UploadKeyringParcel createOperationInput(){
  return new UploadKeyringParcel(mKeyserver,mMasterKeyId);
}","@Override public UploadKeyringParcel createOperationInput(){
  long[] masterKeyIds=getIntent().getLongArrayExtra(MultiUserIdsFragment.EXTRA_KEY_IDS);
  return new UploadKeyringParcel(mKeyserver,masterKeyIds[0]);
}",0.6586826347305389
8260,"private void uploadToKeyserver(){
  Intent uploadIntent=new Intent(getActivity(),UploadKeyActivity.class);
  uploadIntent.setData(mDataUri);
  startActivityForResult(uploadIntent,0);
}","private void uploadToKeyserver(){
  long keyId;
  try {
    keyId=new ProviderHelper(getActivity()).getCachedPublicKeyRing(mDataUri).extractOrGetMasterKeyId();
  }
 catch (  PgpKeyNotFoundException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    Notify.create(getActivity(),""String_Node_Str"",Style.ERROR).show();
    return;
  }
  Intent uploadIntent=new Intent(getActivity(),UploadKeyActivity.class);
  uploadIntent.setData(mDataUri);
  uploadIntent.putExtra(MultiUserIdsFragment.EXTRA_KEY_IDS,new long[]{keyId});
  startActivityForResult(uploadIntent,0);
}",0.2162883845126836
8261,"@Override public void bindView(View view,Context context,Cursor cursor){
  TextView vHeaderId=(TextView)view.findViewById(R.id.user_id_header);
  TextView vName=(TextView)view.findViewById(R.id.user_id_item_name);
  TextView vAddresses=(TextView)view.findViewById(R.id.user_id_item_addresses);
  byte[] data=cursor.getBlob(1);
  int isHeader=cursor.getInt(2);
  Parcel p=Parcel.obtain();
  p.unmarshall(data,0,data.length);
  p.setDataPosition(0);
  ArrayList<String> uids=p.createStringArrayList();
  p.recycle();
{
    String userId=uids.get(0);
    KeyRing.UserId splitUserId=KeyRing.splitUserId(userId);
    if (splitUserId.name != null) {
      vName.setText(splitUserId.name);
    }
 else {
      vName.setText(R.string.user_id_no_name);
    }
    if (isHeader == 1) {
      vHeaderId.setVisibility(View.VISIBLE);
      String message;
      if (splitUserId.name != null) {
        message=mContext.getString(R.string.section_uids_to_certify) + splitUserId.name;
      }
 else {
        message=mContext.getString(R.string.section_uids_to_certify) + context.getString(R.string.user_id_no_name);
      }
      vHeaderId.setText(message);
    }
 else {
      vHeaderId.setVisibility(View.GONE);
    }
  }
  StringBuilder lines=new StringBuilder();
  for (  String uid : uids) {
    KeyRing.UserId splitUserId=KeyRing.splitUserId(uid);
    if (splitUserId.email == null) {
      continue;
    }
    lines.append(splitUserId.email);
    if (splitUserId.comment != null) {
      lines.append(""String_Node_Str"").append(splitUserId.comment).append(""String_Node_Str"");
    }
    lines.append('\n');
  }
  if (lines.length() > 0) {
    lines.setLength(lines.length() - 1);
    vAddresses.setVisibility(View.VISIBLE);
    vAddresses.setText(lines);
  }
 else {
    vAddresses.setVisibility(View.GONE);
  }
  final CheckBox vCheckBox=(CheckBox)view.findViewById(R.id.user_id_item_check_box);
  final int position=cursor.getPosition();
  vCheckBox.setOnCheckedChangeListener(null);
  vCheckBox.setChecked(mCheckStates.get(position));
  vCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton compoundButton,    boolean b){
      mCheckStates.set(position,b);
    }
  }
);
  vCheckBox.setClickable(false);
  View vUidBody=view.findViewById(R.id.user_id_body);
  vUidBody.setClickable(true);
  vUidBody.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      vCheckBox.toggle();
    }
  }
);
}","@Override public void bindView(View view,Context context,Cursor cursor){
  TextView vHeaderId=(TextView)view.findViewById(R.id.user_id_header);
  TextView vName=(TextView)view.findViewById(R.id.user_id_item_name);
  TextView vAddresses=(TextView)view.findViewById(R.id.user_id_item_addresses);
  byte[] data=cursor.getBlob(1);
  int isHeader=cursor.getInt(2);
  Parcel p=Parcel.obtain();
  p.unmarshall(data,0,data.length);
  p.setDataPosition(0);
  ArrayList<String> uids=p.createStringArrayList();
  p.recycle();
{
    String userId=uids.get(0);
    KeyRing.UserId splitUserId=KeyRing.splitUserId(userId);
    if (splitUserId.name != null) {
      vName.setText(splitUserId.name);
    }
 else {
      vName.setText(R.string.user_id_no_name);
    }
    if (isHeader == 1) {
      vHeaderId.setVisibility(View.VISIBLE);
      String message;
      if (splitUserId.name != null) {
        message=mContext.getString(R.string.section_uids_to_certify) + splitUserId.name;
      }
 else {
        message=mContext.getString(R.string.section_uids_to_certify) + context.getString(R.string.user_id_no_name);
      }
      vHeaderId.setText(message);
    }
 else {
      vHeaderId.setVisibility(View.GONE);
    }
  }
  StringBuilder lines=new StringBuilder();
  for (  String uid : uids) {
    KeyRing.UserId splitUserId=KeyRing.splitUserId(uid);
    if (splitUserId.email == null) {
      continue;
    }
    lines.append(splitUserId.email);
    if (splitUserId.comment != null) {
      lines.append(""String_Node_Str"").append(splitUserId.comment).append(""String_Node_Str"");
    }
    lines.append('\n');
  }
  if (lines.length() > 0) {
    lines.setLength(lines.length() - 1);
    vAddresses.setVisibility(View.VISIBLE);
    vAddresses.setText(lines);
  }
 else {
    vAddresses.setVisibility(View.GONE);
  }
  final CheckBox vCheckBox=(CheckBox)view.findViewById(R.id.user_id_item_check_box);
  final int position=cursor.getPosition();
  vCheckBox.setOnCheckedChangeListener(null);
  vCheckBox.setChecked(mCheckStates.get(position));
  vCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton compoundButton,    boolean b){
      mCheckStates.set(position,b);
    }
  }
);
  vCheckBox.setClickable(false);
  vCheckBox.setVisibility(checkboxVisibility ? View.VISIBLE : View.GONE);
  View vUidBody=view.findViewById(R.id.user_id_body);
  vUidBody.setClickable(true);
  vUidBody.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      vCheckBox.toggle();
    }
  }
);
}",0.9854901960784314
8262,"public MultiUserIdsAdapter(Context context,Cursor c,int flags,ArrayList<Boolean> preselectStates){
  super(context,c,flags);
  mInflater=LayoutInflater.from(context);
  mCheckStates=preselectStates == null ? new ArrayList<Boolean>() : preselectStates;
}","public MultiUserIdsAdapter(Context context,Cursor c,int flags,ArrayList<Boolean> preselectStates,boolean checkboxVisibility){
  this(context,c,flags,preselectStates);
  this.checkboxVisibility=checkboxVisibility;
}",0.556745182012848
8263,"@Override boolean isItemEnabled(Cursor cursor){
  if (cursor.getPosition() == 0) {
    return true;
  }
  if (cursor.getInt(KeyAdapter.INDEX_IS_REVOKED) != 0) {
    return false;
  }
  if (cursor.getInt(KeyAdapter.INDEX_IS_EXPIRED) != 0) {
    return false;
  }
  if (cursor.isNull(mIndexHasCertify)) {
    return false;
  }
  return true;
}","@Override boolean isItemEnabled(Cursor cursor){
  if (cursor.getInt(KeyAdapter.INDEX_IS_REVOKED) != 0) {
    return false;
  }
  if (cursor.getInt(KeyAdapter.INDEX_IS_EXPIRED) != 0) {
    return false;
  }
  if (cursor.isNull(mIndexHasCertify)) {
    return false;
  }
  return true;
}",0.9105431309904152
8264,"@Override boolean isItemEnabled(Cursor cursor){
  if (cursor.getPosition() == 0) {
    return true;
  }
  if (cursor.getInt(KeyAdapter.INDEX_IS_REVOKED) != 0) {
    return false;
  }
  if (cursor.getInt(KeyAdapter.INDEX_IS_EXPIRED) != 0) {
    return false;
  }
  if (cursor.isNull(mIndexHasSign)) {
    return false;
  }
  return true;
}","@Override boolean isItemEnabled(Cursor cursor){
  if (cursor.getInt(KeyAdapter.INDEX_IS_REVOKED) != 0) {
    return false;
  }
  if (cursor.getInt(KeyAdapter.INDEX_IS_EXPIRED) != 0) {
    return false;
  }
  if (cursor.isNull(mIndexHasSign)) {
    return false;
  }
  return true;
}",0.9096774193548388
8265,"private Intent encryptAndSignImpl(Intent data,InputStream inputStream,OutputStream outputStream,boolean sign){
  try {
    boolean asciiArmor=data.getBooleanExtra(OpenPgpApi.EXTRA_REQUEST_ASCII_ARMOR,true);
    String originalFilename=data.getStringExtra(OpenPgpApi.EXTRA_ORIGINAL_FILENAME);
    if (originalFilename == null) {
      originalFilename=""String_Node_Str"";
    }
    boolean enableCompression=data.getBooleanExtra(OpenPgpApi.EXTRA_ENABLE_COMPRESSION,true);
    int compressionId;
    if (enableCompression) {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT;
    }
 else {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.UNCOMPRESSED;
    }
    long[] keyIds;
{
      HashSet<Long> encryptKeyIds=new HashSet<>();
      if (data.hasExtra(OpenPgpApi.EXTRA_USER_IDS)) {
        String[] userIds=data.getStringArrayExtra(OpenPgpApi.EXTRA_USER_IDS);
        data.removeExtra(OpenPgpApi.EXTRA_USER_IDS);
        KeyIdResult result=returnKeyIdsFromEmails(data,userIds);
        if (result.mRequiredUserInteraction != null) {
          return result.mRequiredUserInteraction;
        }
        encryptKeyIds.addAll(result.mKeyIds);
      }
      if (data.hasExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
        for (        long keyId : data.getLongArrayExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
          encryptKeyIds.add(keyId);
        }
      }
      keyIds=getUnboxedLongArray(encryptKeyIds);
    }
    long inputLength=inputStream.available();
    InputData inputData=new InputData(inputStream,inputLength,originalFilename);
    PgpSignEncryptInputParcel pseInput=new PgpSignEncryptInputParcel();
    pseInput.setEnableAsciiArmorOutput(asciiArmor).setVersionHeader(null).setCompressionAlgorithm(compressionId).setSymmetricEncryptionAlgorithm(PgpSecurityConstants.OpenKeychainSymmetricKeyAlgorithmTags.USE_DEFAULT).setEncryptionMasterKeyIds(keyIds).setFailOnMissingEncryptionKeyIds(true);
    if (sign) {
      Intent signKeyIdIntent=getSignKeyMasterId(data);
      if (signKeyIdIntent.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR) == OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED) {
        return signKeyIdIntent;
      }
      long signKeyId=signKeyIdIntent.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,Constants.key.none);
      if (signKeyId == Constants.key.none) {
        throw new Exception(""String_Node_Str"");
      }
 else {
        pseInput.setSignatureMasterKeyId(signKeyId);
        try {
          long signSubKeyId=mProviderHelper.getCachedPublicKeyRing(pseInput.getSignatureMasterKeyId()).getSecretSignId();
          pseInput.setSignatureSubKeyId(signSubKeyId);
        }
 catch (        PgpKeyNotFoundException e) {
          throw new Exception(""String_Node_Str"",e);
        }
      }
      pseInput.setSignatureHashAlgorithm(PgpSecurityConstants.OpenKeychainHashAlgorithmTags.USE_DEFAULT).setAdditionalEncryptId(signKeyId);
    }
    if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) < 7) {
      String accName=data.getStringExtra(OpenPgpApi.EXTRA_ACCOUNT_NAME);
      if (TextUtils.isEmpty(accName)) {
        accName=""String_Node_Str"";
      }
      final AccountSettings accSettings=mApiPermissionHelper.getAccSettings(accName);
      if (accSettings == null || (accSettings.getKeyId() == Constants.key.none)) {
        return mApiPermissionHelper.getCreateAccountIntent(data,accName);
      }
      pseInput.setAdditionalEncryptId(accSettings.getKeyId());
    }
    CryptoInputParcel inputParcel=CryptoInputParcelCacheService.getCryptoInputParcel(this,data);
    if (inputParcel == null) {
      inputParcel=new CryptoInputParcel(new Date());
    }
    if (data.hasExtra(OpenPgpApi.EXTRA_PASSPHRASE)) {
      inputParcel.mPassphrase=new Passphrase(data.getCharArrayExtra(OpenPgpApi.EXTRA_PASSPHRASE));
    }
    PgpSignEncryptOperation op=new PgpSignEncryptOperation(this,mProviderHelper,null);
    PgpSignEncryptResult pgpResult=op.execute(pseInput,inputParcel,inputData,outputStream);
    if (pgpResult.isPending()) {
      ApiPendingIntentFactory piFactory=new ApiPendingIntentFactory(getBaseContext());
      RequiredInputParcel requiredInput=pgpResult.getRequiredInputParcel();
      PendingIntent pIntent=piFactory.requiredInputPi(data,requiredInput,pgpResult.mCryptoInputParcel);
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_INTENT,pIntent);
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      return result;
    }
 else     if (pgpResult.success()) {
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
      return result;
    }
 else {
      LogEntryParcel errorMsg=pgpResult.getLog().getLast();
      throw new Exception(getString(errorMsg.mType.getMsgId()));
    }
  }
 catch (  Exception e) {
    Log.d(Constants.TAG,""String_Node_Str"",e);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.GENERIC_ERROR,e.getMessage()));
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
    return result;
  }
}","private Intent encryptAndSignImpl(Intent data,InputStream inputStream,OutputStream outputStream,boolean sign){
  try {
    boolean asciiArmor=data.getBooleanExtra(OpenPgpApi.EXTRA_REQUEST_ASCII_ARMOR,true);
    String originalFilename=data.getStringExtra(OpenPgpApi.EXTRA_ORIGINAL_FILENAME);
    if (originalFilename == null) {
      originalFilename=""String_Node_Str"";
    }
    boolean enableCompression=data.getBooleanExtra(OpenPgpApi.EXTRA_ENABLE_COMPRESSION,true);
    int compressionId;
    if (enableCompression) {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.USE_DEFAULT;
    }
 else {
      compressionId=PgpSecurityConstants.OpenKeychainCompressionAlgorithmTags.UNCOMPRESSED;
    }
    long[] keyIds;
{
      HashSet<Long> encryptKeyIds=new HashSet<>();
      if (data.hasExtra(OpenPgpApi.EXTRA_USER_IDS)) {
        String[] userIds=data.getStringArrayExtra(OpenPgpApi.EXTRA_USER_IDS);
        KeyIdResult result=returnKeyIdsFromEmails(data,userIds);
        if (result.mRequiredUserInteraction != null) {
          return result.mRequiredUserInteraction;
        }
        encryptKeyIds.addAll(result.mKeyIds);
      }
      if (data.hasExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
        for (        long keyId : data.getLongArrayExtra(OpenPgpApi.EXTRA_KEY_IDS)) {
          encryptKeyIds.add(keyId);
        }
      }
      keyIds=getUnboxedLongArray(encryptKeyIds);
    }
    long inputLength=inputStream.available();
    InputData inputData=new InputData(inputStream,inputLength,originalFilename);
    PgpSignEncryptInputParcel pseInput=new PgpSignEncryptInputParcel();
    pseInput.setEnableAsciiArmorOutput(asciiArmor).setVersionHeader(null).setCompressionAlgorithm(compressionId).setSymmetricEncryptionAlgorithm(PgpSecurityConstants.OpenKeychainSymmetricKeyAlgorithmTags.USE_DEFAULT).setEncryptionMasterKeyIds(keyIds).setFailOnMissingEncryptionKeyIds(true);
    if (sign) {
      Intent signKeyIdIntent=getSignKeyMasterId(data);
      if (signKeyIdIntent.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR) == OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED) {
        return signKeyIdIntent;
      }
      long signKeyId=signKeyIdIntent.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,Constants.key.none);
      if (signKeyId == Constants.key.none) {
        throw new Exception(""String_Node_Str"");
      }
 else {
        pseInput.setSignatureMasterKeyId(signKeyId);
        try {
          long signSubKeyId=mProviderHelper.getCachedPublicKeyRing(pseInput.getSignatureMasterKeyId()).getSecretSignId();
          pseInput.setSignatureSubKeyId(signSubKeyId);
        }
 catch (        PgpKeyNotFoundException e) {
          throw new Exception(""String_Node_Str"",e);
        }
      }
      pseInput.setSignatureHashAlgorithm(PgpSecurityConstants.OpenKeychainHashAlgorithmTags.USE_DEFAULT).setAdditionalEncryptId(signKeyId);
    }
    if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) < 7) {
      String accName=data.getStringExtra(OpenPgpApi.EXTRA_ACCOUNT_NAME);
      if (TextUtils.isEmpty(accName)) {
        accName=""String_Node_Str"";
      }
      final AccountSettings accSettings=mApiPermissionHelper.getAccSettings(accName);
      if (accSettings == null || (accSettings.getKeyId() == Constants.key.none)) {
        return mApiPermissionHelper.getCreateAccountIntent(data,accName);
      }
      pseInput.setAdditionalEncryptId(accSettings.getKeyId());
    }
    CryptoInputParcel inputParcel=CryptoInputParcelCacheService.getCryptoInputParcel(this,data);
    if (inputParcel == null) {
      inputParcel=new CryptoInputParcel(new Date());
    }
    if (data.hasExtra(OpenPgpApi.EXTRA_PASSPHRASE)) {
      inputParcel.mPassphrase=new Passphrase(data.getCharArrayExtra(OpenPgpApi.EXTRA_PASSPHRASE));
    }
    PgpSignEncryptOperation op=new PgpSignEncryptOperation(this,mProviderHelper,null);
    PgpSignEncryptResult pgpResult=op.execute(pseInput,inputParcel,inputData,outputStream);
    if (pgpResult.isPending()) {
      ApiPendingIntentFactory piFactory=new ApiPendingIntentFactory(getBaseContext());
      RequiredInputParcel requiredInput=pgpResult.getRequiredInputParcel();
      PendingIntent pIntent=piFactory.requiredInputPi(data,requiredInput,pgpResult.mCryptoInputParcel);
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_INTENT,pIntent);
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      return result;
    }
 else     if (pgpResult.success()) {
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
      return result;
    }
 else {
      LogEntryParcel errorMsg=pgpResult.getLog().getLast();
      throw new Exception(getString(errorMsg.mType.getMsgId()));
    }
  }
 catch (  Exception e) {
    Log.d(Constants.TAG,""String_Node_Str"",e);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.GENERIC_ERROR,e.getMessage()));
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
    return result;
  }
}",0.9948186528497408
8266,"@Override protected void onCreate(Bundle savedInstanceState){
  initTheme();
  super.onCreate(savedInstanceState);
  initLayout();
  initToolbar();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  initTheme();
  initLayout();
  initToolbar();
}",0.8993288590604027
8267,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setFullScreenDialogClose(Activity.RESULT_CANCELED,true);
  findViewById(R.id.import_import).setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      importSelectedKeys();
    }
  }
);
  if (getIntent().hasExtra(EXTRA_PENDING_INTENT_DATA)) {
    mPendingIntentData=getIntent().getParcelableExtra(EXTRA_PENDING_INTENT_DATA);
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mFreshIntent=true;
  setFullScreenDialogClose(Activity.RESULT_CANCELED,true);
  findViewById(R.id.import_import).setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      importSelectedKeys();
    }
  }
);
  if (getIntent().hasExtra(EXTRA_PENDING_INTENT_DATA)) {
    mPendingIntentData=getIntent().getParcelableExtra(EXTRA_PENDING_INTENT_DATA);
  }
}",0.9780564263322884
8268,"protected void handleActions(Intent intent){
  String action=intent.getAction();
  Bundle extras=intent.getExtras();
  Uri dataUri=intent.getData();
  String scheme=intent.getScheme();
  if (extras == null) {
    extras=new Bundle();
  }
  if (Intent.ACTION_VIEW.equals(action)) {
    if (FacebookKeyserver.isFacebookHost(dataUri)) {
      action=ACTION_IMPORT_KEY_FROM_FACEBOOK;
    }
 else     if (""String_Node_Str"".equals(scheme) || ""String_Node_Str"".equals(scheme)) {
      action=ACTION_SEARCH_KEYSERVER_FROM_URL;
    }
 else {
      action=ACTION_IMPORT_KEY;
    }
  }
  if (action == null) {
    action=""String_Node_Str"";
  }
switch (action) {
case ACTION_IMPORT_KEY:
{
      if (dataUri != null) {
        startListFragment(null,dataUri,null,null);
      }
 else       if (extras.containsKey(EXTRA_KEY_BYTES)) {
        byte[] importData=extras.getByteArray(EXTRA_KEY_BYTES);
        startListFragment(importData,null,null,null);
      }
 else {
        startTopFileFragment();
        startListFragment(null,null,null,null);
      }
      break;
    }
case ACTION_IMPORT_KEY_FROM_KEYSERVER:
case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE:
case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT:
{
    if (extras.containsKey(EXTRA_QUERY) || extras.containsKey(EXTRA_KEY_ID)) {
      String query=null;
      if (extras.containsKey(EXTRA_QUERY)) {
        query=extras.getString(EXTRA_QUERY);
      }
 else       if (extras.containsKey(EXTRA_KEY_ID)) {
        long keyId=extras.getLong(EXTRA_KEY_ID,0);
        if (keyId != 0) {
          query=KeyFormattingUtils.convertKeyIdToHex(keyId);
        }
      }
      if (query != null && query.length() > 0) {
        startTopCloudFragment(query,false,null);
        startListFragment(null,null,query,null);
      }
 else {
        Log.e(Constants.TAG,""String_Node_Str"");
        return;
      }
    }
 else     if (extras.containsKey(EXTRA_FINGERPRINT)) {
      String fingerprint=extras.getString(EXTRA_FINGERPRINT);
      if (isFingerprintValid(fingerprint)) {
        String query=""String_Node_Str"" + fingerprint;
        startTopCloudFragment(query,true,null);
        startListFragment(null,null,query,null);
      }
    }
 else {
      Log.e(Constants.TAG,""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
    break;
  }
case ACTION_IMPORT_KEY_FROM_FACEBOOK:
{
  String fbUsername=FacebookKeyserver.getUsernameFromUri(dataUri);
  Preferences.CloudSearchPrefs cloudSearchPrefs=new Preferences.CloudSearchPrefs(false,true,true,null);
  startTopCloudFragment(fbUsername,false,cloudSearchPrefs);
  startListFragment(null,null,fbUsername,cloudSearchPrefs);
  break;
}
case ACTION_SEARCH_KEYSERVER_FROM_URL:
{
String query=dataUri.getQueryParameter(""String_Node_Str"");
if (query == null) {
  Notify.create(this,R.string.import_url_warn_no_search_parameter,Notify.LENGTH_INDEFINITE,Notify.Style.WARN).show();
}
Preferences.CloudSearchPrefs cloudSearchPrefs=new Preferences.CloudSearchPrefs(true,true,true,dataUri.getAuthority());
startTopCloudFragment(query,false,cloudSearchPrefs);
startListFragment(null,null,query,cloudSearchPrefs);
break;
}
case ACTION_IMPORT_KEY_FROM_FILE:
case ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN:
{
startTopFileFragment();
startListFragment(null,null,null,null);
break;
}
default :
{
startTopCloudFragment(null,false,null);
startListFragment(null,null,null,null);
break;
}
}
}","protected void handleActions(@NonNull Intent intent){
  String action=intent.getAction();
  Bundle extras=intent.getExtras();
  Uri dataUri=intent.getData();
  String scheme=intent.getScheme();
  if (extras == null) {
    extras=new Bundle();
  }
  if (Intent.ACTION_VIEW.equals(action)) {
    if (FacebookKeyserver.isFacebookHost(dataUri)) {
      action=ACTION_IMPORT_KEY_FROM_FACEBOOK;
    }
 else     if (""String_Node_Str"".equals(scheme) || ""String_Node_Str"".equals(scheme)) {
      action=ACTION_SEARCH_KEYSERVER_FROM_URL;
    }
 else {
      action=ACTION_IMPORT_KEY;
    }
  }
  if (action == null) {
    action=""String_Node_Str"";
  }
switch (action) {
case ACTION_IMPORT_KEY:
{
      if (dataUri != null) {
        startListFragment(null,dataUri,null,null);
      }
 else       if (extras.containsKey(EXTRA_KEY_BYTES)) {
        byte[] importData=extras.getByteArray(EXTRA_KEY_BYTES);
        startListFragment(importData,null,null,null);
      }
 else {
        startTopFileFragment();
        startListFragment(null,null,null,null);
      }
      break;
    }
case ACTION_IMPORT_KEY_FROM_KEYSERVER:
case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE:
case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT:
{
    if (extras.containsKey(EXTRA_QUERY) || extras.containsKey(EXTRA_KEY_ID)) {
      String query=null;
      if (extras.containsKey(EXTRA_QUERY)) {
        query=extras.getString(EXTRA_QUERY);
      }
 else       if (extras.containsKey(EXTRA_KEY_ID)) {
        long keyId=extras.getLong(EXTRA_KEY_ID,0);
        if (keyId != 0) {
          query=KeyFormattingUtils.convertKeyIdToHex(keyId);
        }
      }
      if (query != null && query.length() > 0) {
        startTopCloudFragment(query,false,null);
        startListFragment(null,null,query,null);
      }
 else {
        Log.e(Constants.TAG,""String_Node_Str"");
        return;
      }
    }
 else     if (extras.containsKey(EXTRA_FINGERPRINT)) {
      String fingerprint=extras.getString(EXTRA_FINGERPRINT);
      if (isFingerprintValid(fingerprint)) {
        String query=""String_Node_Str"" + fingerprint;
        startTopCloudFragment(query,true,null);
        startListFragment(null,null,query,null);
      }
    }
 else {
      Log.e(Constants.TAG,""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
    break;
  }
case ACTION_IMPORT_KEY_FROM_FACEBOOK:
{
  String fbUsername=FacebookKeyserver.getUsernameFromUri(dataUri);
  Preferences.CloudSearchPrefs cloudSearchPrefs=new Preferences.CloudSearchPrefs(false,true,true,null);
  startTopCloudFragment(fbUsername,false,cloudSearchPrefs);
  startListFragment(null,null,fbUsername,cloudSearchPrefs);
  break;
}
case ACTION_SEARCH_KEYSERVER_FROM_URL:
{
String query=dataUri.getQueryParameter(""String_Node_Str"");
if (query == null) {
  Notify.create(this,R.string.import_url_warn_no_search_parameter,Notify.LENGTH_INDEFINITE,Notify.Style.WARN).show();
}
Preferences.CloudSearchPrefs cloudSearchPrefs=new Preferences.CloudSearchPrefs(true,true,true,dataUri.getAuthority());
startTopCloudFragment(query,false,cloudSearchPrefs);
startListFragment(null,null,query,cloudSearchPrefs);
break;
}
case ACTION_IMPORT_KEY_FROM_FILE:
case ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN:
{
startTopFileFragment();
startListFragment(null,null,null,null);
break;
}
default :
{
startTopCloudFragment(null,false,null);
startListFragment(null,null,null,null);
break;
}
}
}",0.9986711944485456
8269,"@Override public void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  setIntent(intent);
}","@Override public void onNewIntent(Intent intent){
  super.onNewIntent(intent);
  setIntent(intent);
  mFreshIntent=true;
}",0.905829596412556
8270,"@Override protected void onResumeFragments(){
  super.onResumeFragments();
  handleActions(getIntent());
}","@Override protected void onResumeFragments(){
  super.onResumeFragments();
  if (mFreshIntent) {
    handleActions(getIntent());
    mFreshIntent=false;
  }
}",0.803030303030303
8271,"/** 
 * returns an indented String of an entire OperationLog
 * @param indent padding to add at the start of all log entries, made for use with SubLogs
 * @return printable, indented version of passed operationLog
 */
public String getPrintableOperationLog(Resources resources,int indent){
  StringBuilder log=new StringBuilder();
  for (  LogEntryParcel entry : this) {
    log.append(entry.getPrintableLogEntry(resources,indent)).append(""String_Node_Str"");
  }
  return log.toString().substring(0,log.length() - 1);
}","/** 
 * returns an indented String of an entire OperationLog
 * @param indent padding to add at the start of all log entries, made for use with SubLogs
 * @return printable, indented version of passed operationLog
 */
public String getPrintableOperationLog(Resources resources,int indent){
  StringBuilder log=new StringBuilder();
  for (  LogEntryParcel entry : this) {
    log.append(entry.getPrintableLogEntry(resources,indent)).append(""String_Node_Str"");
  }
  if (log.length() >= 1) {
    return log.toString().substring(0,log.length() - 1);
  }
 else {
    return log.toString();
  }
}",0.9351351351351352
8272,"private Intent getSignKeyIdImpl(Intent data){
  String preferredUserId=data.getStringExtra(OpenPgpApi.EXTRA_USER_ID);
  Intent intent=new Intent(getBaseContext(),SelectSignKeyIdActivity.class);
  String currentPkg=getCurrentCallingPackage();
  intent.setData(KeychainContract.ApiApps.buildByPackageNameUri(currentPkg));
  intent.putExtra(SelectSignKeyIdActivity.EXTRA_USER_ID,preferredUserId);
  intent.putExtra(SelectSignKeyIdActivity.EXTRA_DATA,data);
  PendingIntent pi=PendingIntent.getActivity(getBaseContext(),0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  Intent result=new Intent();
  result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
  result.putExtra(OpenPgpApi.RESULT_INTENT,pi);
  return result;
}","private Intent getSignKeyIdImpl(Intent data){
  if (data.hasExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID)) {
    long signKeyId=data.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,Constants.key.none);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,signKeyId);
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
    return result;
  }
 else {
    String preferredUserId=data.getStringExtra(OpenPgpApi.EXTRA_USER_ID);
    Intent intent=new Intent(getBaseContext(),SelectSignKeyIdActivity.class);
    String currentPkg=getCurrentCallingPackage();
    intent.setData(KeychainContract.ApiApps.buildByPackageNameUri(currentPkg));
    intent.putExtra(SelectSignKeyIdActivity.EXTRA_USER_ID,preferredUserId);
    intent.putExtra(SelectSignKeyIdActivity.EXTRA_DATA,data);
    PendingIntent pi=PendingIntent.getActivity(getBaseContext(),0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
    result.putExtra(OpenPgpApi.RESULT_INTENT,pi);
    return result;
  }
}",0.453862660944206
8273,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setFullScreenDialogClose(new View.OnClickListener(){
    @Override public void onClick(    View v){
      setResult(RESULT_CANCELED);
      finish();
    }
  }
);
  mActionCreateKey=(TextView)findViewById(R.id.api_select_sign_key_create_key);
  mActionCreateKey.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      createKey(mPreferredUserId);
    }
  }
);
  mNone=(TextView)findViewById(R.id.api_select_sign_key_none);
  mNone.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mData.putExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,0);
      setResult(Activity.RESULT_OK,mData);
      finish();
    }
  }
);
  Intent intent=getIntent();
  mAppUri=intent.getData();
  mPreferredUserId=intent.getStringExtra(EXTRA_USER_ID);
  mData=intent.getParcelableExtra(EXTRA_DATA);
  if (mAppUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
 else {
    Log.d(Constants.TAG,""String_Node_Str"" + mAppUri);
    startListFragments(savedInstanceState,mAppUri,mData);
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setFullScreenDialogClose(new View.OnClickListener(){
    @Override public void onClick(    View v){
      setResult(RESULT_CANCELED);
      finish();
    }
  }
);
  TextView createKeyButton=(TextView)findViewById(R.id.api_select_sign_key_create_key);
  createKeyButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      createKey(mPreferredUserId);
    }
  }
);
  TextView noneButton=(TextView)findViewById(R.id.api_select_sign_key_none);
  noneButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mData.putExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,0);
      setResult(Activity.RESULT_OK,mData);
      finish();
    }
  }
);
  Intent intent=getIntent();
  Uri appUri=intent.getData();
  mPreferredUserId=intent.getStringExtra(EXTRA_USER_ID);
  mData=intent.getParcelableExtra(EXTRA_DATA);
  if (appUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
 else {
    Log.d(Constants.TAG,""String_Node_Str"" + appUri);
    startListFragments(savedInstanceState,appUri,mData);
  }
}",0.9397489539748954
8274,"private void startListFragments(Bundle savedInstanceState,Uri dataUri,Intent data){
  if (savedInstanceState != null) {
    return;
  }
  mListFragment=SelectSignKeyIdListFragment.newInstance(dataUri,data);
  getSupportFragmentManager().beginTransaction().replace(R.id.api_select_sign_key_list_fragment,mListFragment).commitAllowingStateLoss();
  getSupportFragmentManager().executePendingTransactions();
}","private void startListFragments(Bundle savedInstanceState,Uri dataUri,Intent data){
  if (savedInstanceState != null) {
    return;
  }
  SelectSignKeyIdListFragment listFragment=SelectSignKeyIdListFragment.newInstance(dataUri,data);
  getSupportFragmentManager().beginTransaction().replace(R.id.api_select_sign_key_list_fragment,listFragment).commitAllowingStateLoss();
  getSupportFragmentManager().executePendingTransactions();
}",0.8854415274463007
8275,"/** 
 * Called when the application is starting, before any activity, service, or receiver objects (excluding content providers) have been created.
 */
@Override public void onCreate(){
  super.onCreate();
  Security.insertProviderAt(new BouncyCastleProvider(),1);
  PRNGFixes.apply();
  Log.d(Constants.TAG,""String_Node_Str"");
  if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
    if (!Constants.Path.APP_DIR.exists() && !Constants.Path.APP_DIR.mkdirs()) {
    }
  }
  brandGlowEffect(getApplicationContext(),FormattingUtils.getColorFromAttr(getApplicationContext(),R.attr.colorPrimary));
  setupAccountAsNeeded(this);
  Preferences.getPreferences(this).upgradePreferences();
  TlsHelper.addStaticCA(""String_Node_Str"",getAssets(),""String_Node_Str"");
  TemporaryStorageProvider.cleanUp(this);
  if (!checkConsolidateRecovery()) {
    new KeychainDatabase(this).getReadableDatabase().close();
  }
}","/** 
 * Called when the application is starting, before any activity, service, or receiver objects (excluding content providers) have been created.
 */
@Override public void onCreate(){
  super.onCreate();
  Security.insertProviderAt(new BouncyCastleProvider(),1);
  PRNGFixes.apply();
  Log.d(Constants.TAG,""String_Node_Str"");
  if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
    if (!Constants.Path.APP_DIR.exists() && !Constants.Path.APP_DIR.mkdirs()) {
    }
  }
  brandGlowEffect(getApplicationContext(),FormattingUtils.getColorFromAttr(getApplicationContext(),R.attr.colorPrimary));
  setupAccountAsNeeded(this);
  Preferences.getPreferences(this).upgradePreferences(this);
  TlsHelper.addStaticCA(""String_Node_Str"",getAssets(),""String_Node_Str"");
  TemporaryStorageProvider.cleanUp(this);
  if (!checkConsolidateRecovery()) {
    new KeychainDatabase(this).getReadableDatabase().close();
  }
}",0.9978494623655914
8276,"/** 
 * Add OpenKeychain account to Android to link contacts with keys and keyserver sync
 */
public static void setupAccountAsNeeded(Context context){
  try {
    AccountManager manager=AccountManager.get(context);
    Account[] accounts=manager.getAccountsByType(Constants.ACCOUNT_TYPE);
    if (accounts.length == 0) {
      Account account=new Account(Constants.ACCOUNT_NAME,Constants.ACCOUNT_TYPE);
      if (manager.addAccountExplicitly(account,null,null)) {
        ContentResolver.setIsSyncable(account,ContactsContract.AUTHORITY,1);
        ContentResolver.setSyncAutomatically(account,ContactsContract.AUTHORITY,true);
        ContentResolver.setIsSyncable(account,Constants.PROVIDER_AUTHORITY,1);
        ContentResolver.setSyncAutomatically(account,Constants.PROVIDER_AUTHORITY,true);
        Log.e(""String_Node_Str"",""String_Node_Str"");
        ContentResolver.addPeriodicSync(new Account(Constants.ACCOUNT_NAME,Constants.ACCOUNT_TYPE),Constants.PROVIDER_AUTHORITY,new Bundle(),60);
      }
 else {
        Log.e(Constants.TAG,""String_Node_Str"");
      }
    }
  }
 catch (  SecurityException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    Toast.makeText(context,R.string.reinstall_openkeychain,Toast.LENGTH_LONG).show();
  }
}","/** 
 * Add OpenKeychain account to Android to link contacts with keys and keyserver sync
 */
public static void setupAccountAsNeeded(Context context){
  try {
    AccountManager manager=AccountManager.get(context);
    Account[] accounts=manager.getAccountsByType(Constants.ACCOUNT_TYPE);
    if (accounts.length == 0) {
      Account account=new Account(Constants.ACCOUNT_NAME,Constants.ACCOUNT_TYPE);
      if (manager.addAccountExplicitly(account,null,null)) {
        ContentResolver.setIsSyncable(account,ContactsContract.AUTHORITY,1);
        ContentResolver.setSyncAutomatically(account,ContactsContract.AUTHORITY,true);
        KeyserverSyncAdapterService.enableKeyserverSync(context);
      }
 else {
        Log.e(Constants.TAG,""String_Node_Str"");
      }
    }
  }
 catch (  SecurityException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    Toast.makeText(context,R.string.reinstall_openkeychain,Toast.LENGTH_LONG).show();
  }
}",0.8295350957155879
8277,"@Override public String get(String keyIdHex,Proxy proxy) throws QueryFailedException {
  String request=""String_Node_Str"" + keyIdHex;
  Log.d(Constants.TAG,""String_Node_Str"" + request + ""String_Node_Str""+ proxy);
  String data;
  try {
    data=query(request,proxy);
  }
 catch (  HttpError httpError) {
    Log.e(Constants.TAG,""String_Node_Str"",httpError);
    throw new QueryFailedException(""String_Node_Str"");
  }
  Matcher matcher=PgpHelper.PGP_PUBLIC_KEY.matcher(data);
  if (matcher.find()) {
    return matcher.group(1);
  }
  return null;
}","@Override public String get(String keyIdHex,Proxy proxy) throws QueryFailedException {
  String request=""String_Node_Str"" + keyIdHex;
  Log.d(Constants.TAG,""String_Node_Str"" + request + ""String_Node_Str""+ proxy);
  String data;
  try {
    data=query(request,proxy);
  }
 catch (  HttpError httpError) {
    Log.d(Constants.TAG,""String_Node_Str"",httpError);
    throw new QueryFailedException(""String_Node_Str"");
  }
  Matcher matcher=PgpHelper.PGP_PUBLIC_KEY.matcher(data);
  if (matcher.find()) {
    return matcher.group(1);
  }
  return null;
}",0.998175182481752
8278,"/** 
 * Since the introduction of multithreaded import, we expect calling functions to handle the key sync i,eContactSyncAdapterService.requestSync()
 * @param entries      keys to import
 * @param num          number of keys to import
 * @param keyServerUri contains uri of keyserver to import from, if it is an import from cloud
 * @param progressable Allows multi-threaded import to supply a progressable that ignores theprogress of a single key being imported
 */
@NonNull public ImportKeyResult serialKeyRingImport(Iterator<ParcelableKeyRing> entries,int num,String keyServerUri,Progressable progressable,Proxy proxy){
  if (progressable != null) {
    progressable.setProgress(R.string.progress_importing,0,100);
  }
  OperationLog log=new OperationLog();
  log.add(LogType.MSG_IMPORT,0,num);
  if (entries == null || !entries.hasNext()) {
    return new ImportKeyResult(ImportKeyResult.RESULT_FAIL_NOTHING,log);
  }
  int newKeys=0, updatedKeys=0, badKeys=0, secret=0;
  ArrayList<Long> importedMasterKeyIds=new ArrayList<>();
  boolean cancelled=false;
  int position=0;
  double progSteps=100.0 / num;
  KeybaseKeyserver keybaseServer=null;
  HkpKeyserver keyServer=null;
  while (entries.hasNext()) {
    ParcelableKeyRing entry=entries.next();
    if (checkCancelled()) {
      cancelled=true;
      break;
    }
    try {
      UncachedKeyRing key=null;
      if (entry.mBytes != null) {
        key=UncachedKeyRing.decodeFromData(entry.mBytes);
      }
 else {
        if (keyServerUri != null && (entry.mKeyIdHex != null || entry.mExpectedFingerprint != null)) {
          if (keyServer == null) {
            log.add(LogType.MSG_IMPORT_KEYSERVER,1,keyServerUri);
            keyServer=new HkpKeyserver(keyServerUri);
          }
          try {
            byte[] data;
            if (entry.mExpectedFingerprint != null) {
              log.add(LogType.MSG_IMPORT_FETCH_KEYSERVER,2,""String_Node_Str"" + entry.mExpectedFingerprint.substring(24));
              data=keyServer.get(""String_Node_Str"" + entry.mExpectedFingerprint,proxy).getBytes();
            }
 else {
              log.add(LogType.MSG_IMPORT_FETCH_KEYSERVER,2,entry.mKeyIdHex);
              data=keyServer.get(entry.mKeyIdHex,proxy).getBytes();
            }
            key=UncachedKeyRing.decodeFromData(data);
            if (key != null) {
              log.add(LogType.MSG_IMPORT_FETCH_KEYSERVER_OK,3);
            }
 else {
              log.add(LogType.MSG_IMPORT_FETCH_ERROR_DECODE,3);
            }
          }
 catch (          Keyserver.QueryFailedException e) {
            Log.e(Constants.TAG,""String_Node_Str"",e);
            log.add(LogType.MSG_IMPORT_FETCH_KEYSERVER_ERROR,3,e.getMessage());
          }
        }
        if (entry.mKeybaseName != null) {
          if (keybaseServer == null) {
            keybaseServer=new KeybaseKeyserver();
          }
          try {
            log.add(LogType.MSG_IMPORT_FETCH_KEYBASE,2,entry.mKeybaseName);
            byte[] data=keybaseServer.get(entry.mKeybaseName,proxy).getBytes();
            UncachedKeyRing keybaseKey=UncachedKeyRing.decodeFromData(data);
            if (key != null && keybaseKey != null) {
              log.add(LogType.MSG_IMPORT_MERGE,3);
              keybaseKey=key.merge(keybaseKey,log,4);
              if (keybaseKey != null) {
                key=keybaseKey;
              }
 else {
                log.add(LogType.MSG_IMPORT_MERGE_ERROR,4);
              }
            }
 else             if (keybaseKey != null) {
              key=keybaseKey;
            }
          }
 catch (          Keyserver.QueryFailedException e) {
            Log.e(Constants.TAG,""String_Node_Str"",e);
            log.add(LogType.MSG_IMPORT_FETCH_KEYSERVER_ERROR,3,e.getMessage());
          }
        }
      }
      if (key == null) {
        log.add(LogType.MSG_IMPORT_FETCH_ERROR,2);
        badKeys+=1;
        continue;
      }
      if (entry.mExpectedFingerprint != null) {
        if (!key.containsSubkey(entry.mExpectedFingerprint)) {
          log.add(LogType.MSG_IMPORT_FINGERPRINT_ERROR,2);
          badKeys+=1;
          continue;
        }
 else {
          log.add(LogType.MSG_IMPORT_FINGERPRINT_OK,2);
        }
      }
      if (checkCancelled()) {
        cancelled=true;
        break;
      }
      SaveKeyringResult result;
      mProviderHelper.clearLog();
      if (key.isSecret()) {
        result=mProviderHelper.saveSecretKeyRing(key,new ProgressScaler(progressable,(int)(position * progSteps),(int)((position + 1) * progSteps),100));
      }
 else {
        result=mProviderHelper.savePublicKeyRing(key,new ProgressScaler(progressable,(int)(position * progSteps),(int)((position + 1) * progSteps),100));
      }
      if (!result.success()) {
        badKeys+=1;
      }
 else {
        if (result.updated()) {
          updatedKeys+=1;
          importedMasterKeyIds.add(key.getMasterKeyId());
        }
 else {
          newKeys+=1;
          if (key.isSecret()) {
            secret+=1;
          }
          importedMasterKeyIds.add(key.getMasterKeyId());
        }
        if (entry.mBytes == null) {
          mProviderHelper.renewKeyLastUpdatedTime(key.getMasterKeyId(),GregorianCalendar.getInstance().getTimeInMillis(),TimeUnit.MILLISECONDS);
        }
      }
      log.add(result,2);
    }
 catch (    IOException|PgpGeneralException e) {
      Log.e(Constants.TAG,""String_Node_Str"",e);
      ++badKeys;
    }
    position++;
  }
  if (secret > 0) {
    setPreventCancel();
    ConsolidateResult result=mProviderHelper.consolidateDatabaseStep1(progressable);
    log.add(result,1);
  }
  long[] importedMasterKeyIdsArray=new long[importedMasterKeyIds.size()];
  for (int i=0; i < importedMasterKeyIds.size(); ++i) {
    importedMasterKeyIdsArray[i]=importedMasterKeyIds.get(i);
  }
  int resultType=0;
  if (cancelled) {
    log.add(LogType.MSG_OPERATION_CANCELLED,1);
    resultType|=ImportKeyResult.RESULT_CANCELLED;
  }
  if (badKeys == 0 && newKeys == 0 && updatedKeys == 0) {
    resultType=ImportKeyResult.RESULT_FAIL_NOTHING;
  }
 else {
    if (newKeys > 0) {
      resultType|=ImportKeyResult.RESULT_OK_NEWKEYS;
    }
    if (updatedKeys > 0) {
      resultType|=ImportKeyResult.RESULT_OK_UPDATED;
    }
    if (badKeys > 0) {
      resultType|=ImportKeyResult.RESULT_WITH_ERRORS;
      if (newKeys == 0 && updatedKeys == 0) {
        resultType|=ImportKeyResult.RESULT_ERROR;
      }
    }
    if (log.containsWarnings()) {
      resultType|=ImportKeyResult.RESULT_WARNINGS;
    }
  }
  if ((newKeys > 0 || updatedKeys > 0) && badKeys > 0) {
    log.add(LogType.MSG_IMPORT_PARTIAL,1);
  }
 else   if (newKeys > 0 || updatedKeys > 0) {
    log.add(LogType.MSG_IMPORT_SUCCESS,1);
  }
 else {
    log.add(LogType.MSG_IMPORT_ERROR,1);
  }
  return new ImportKeyResult(resultType,log,newKeys,updatedKeys,badKeys,secret,importedMasterKeyIdsArray);
}","/** 
 * Since the introduction of multithreaded import, we expect calling functions to handle the key sync i,eContactSyncAdapterService.requestSync()
 * @param entries      keys to import
 * @param num          number of keys to import
 * @param keyServerUri contains uri of keyserver to import from, if it is an import from cloud
 * @param progressable Allows multi-threaded import to supply a progressable that ignores theprogress of a single key being imported
 */
@NonNull public ImportKeyResult serialKeyRingImport(Iterator<ParcelableKeyRing> entries,int num,String keyServerUri,Progressable progressable,Proxy proxy){
  if (progressable != null) {
    progressable.setProgress(R.string.progress_importing,0,100);
  }
  OperationLog log=new OperationLog();
  log.add(LogType.MSG_IMPORT,0,num);
  if (entries == null || !entries.hasNext()) {
    return new ImportKeyResult(ImportKeyResult.RESULT_FAIL_NOTHING,log);
  }
  int newKeys=0, updatedKeys=0, badKeys=0, secret=0;
  ArrayList<Long> importedMasterKeyIds=new ArrayList<>();
  boolean cancelled=false;
  int position=0;
  double progSteps=100.0 / num;
  KeybaseKeyserver keybaseServer=null;
  HkpKeyserver keyServer=null;
  while (entries.hasNext()) {
    ParcelableKeyRing entry=entries.next();
    if (checkCancelled()) {
      cancelled=true;
      break;
    }
    try {
      UncachedKeyRing key=null;
      if (entry.mBytes != null) {
        key=UncachedKeyRing.decodeFromData(entry.mBytes);
      }
 else {
        if (keyServerUri != null && (entry.mKeyIdHex != null || entry.mExpectedFingerprint != null)) {
          if (keyServer == null) {
            log.add(LogType.MSG_IMPORT_KEYSERVER,1,keyServerUri);
            keyServer=new HkpKeyserver(keyServerUri);
          }
          try {
            byte[] data;
            if (entry.mExpectedFingerprint != null) {
              log.add(LogType.MSG_IMPORT_FETCH_KEYSERVER,2,""String_Node_Str"" + entry.mExpectedFingerprint.substring(24));
              data=keyServer.get(""String_Node_Str"" + entry.mExpectedFingerprint,proxy).getBytes();
            }
 else {
              log.add(LogType.MSG_IMPORT_FETCH_KEYSERVER,2,entry.mKeyIdHex);
              data=keyServer.get(entry.mKeyIdHex,proxy).getBytes();
            }
            key=UncachedKeyRing.decodeFromData(data);
            if (key != null) {
              log.add(LogType.MSG_IMPORT_FETCH_KEYSERVER_OK,3);
            }
 else {
              log.add(LogType.MSG_IMPORT_FETCH_ERROR_DECODE,3);
            }
          }
 catch (          Keyserver.QueryFailedException e) {
            Log.d(Constants.TAG,""String_Node_Str"",e);
            log.add(LogType.MSG_IMPORT_FETCH_KEYSERVER_ERROR,3,e.getMessage());
          }
        }
        if (entry.mKeybaseName != null) {
          if (keybaseServer == null) {
            keybaseServer=new KeybaseKeyserver();
          }
          try {
            log.add(LogType.MSG_IMPORT_FETCH_KEYBASE,2,entry.mKeybaseName);
            byte[] data=keybaseServer.get(entry.mKeybaseName,proxy).getBytes();
            UncachedKeyRing keybaseKey=UncachedKeyRing.decodeFromData(data);
            if (key != null && keybaseKey != null) {
              log.add(LogType.MSG_IMPORT_MERGE,3);
              keybaseKey=key.merge(keybaseKey,log,4);
              if (keybaseKey != null) {
                key=keybaseKey;
              }
 else {
                log.add(LogType.MSG_IMPORT_MERGE_ERROR,4);
              }
            }
 else             if (keybaseKey != null) {
              key=keybaseKey;
            }
          }
 catch (          Keyserver.QueryFailedException e) {
            Log.e(Constants.TAG,""String_Node_Str"",e);
            log.add(LogType.MSG_IMPORT_FETCH_KEYSERVER_ERROR,3,e.getMessage());
          }
        }
      }
      if (key == null) {
        log.add(LogType.MSG_IMPORT_FETCH_ERROR,2);
        badKeys+=1;
        continue;
      }
      if (entry.mExpectedFingerprint != null) {
        if (!key.containsSubkey(entry.mExpectedFingerprint)) {
          log.add(LogType.MSG_IMPORT_FINGERPRINT_ERROR,2);
          badKeys+=1;
          continue;
        }
 else {
          log.add(LogType.MSG_IMPORT_FINGERPRINT_OK,2);
        }
      }
      if (checkCancelled()) {
        cancelled=true;
        break;
      }
      SaveKeyringResult result;
      mProviderHelper.clearLog();
      if (key.isSecret()) {
        result=mProviderHelper.saveSecretKeyRing(key,new ProgressScaler(progressable,(int)(position * progSteps),(int)((position + 1) * progSteps),100));
      }
 else {
        result=mProviderHelper.savePublicKeyRing(key,new ProgressScaler(progressable,(int)(position * progSteps),(int)((position + 1) * progSteps),100));
      }
      if (!result.success()) {
        badKeys+=1;
      }
 else {
        if (result.updated()) {
          updatedKeys+=1;
          importedMasterKeyIds.add(key.getMasterKeyId());
        }
 else {
          newKeys+=1;
          if (key.isSecret()) {
            secret+=1;
          }
          importedMasterKeyIds.add(key.getMasterKeyId());
        }
        if (entry.mBytes == null) {
          mProviderHelper.renewKeyLastUpdatedTime(key.getMasterKeyId(),GregorianCalendar.getInstance().getTimeInMillis(),TimeUnit.MILLISECONDS);
        }
      }
      log.add(result,2);
    }
 catch (    IOException|PgpGeneralException e) {
      Log.e(Constants.TAG,""String_Node_Str"",e);
      ++badKeys;
    }
    position++;
  }
  if (secret > 0) {
    setPreventCancel();
    ConsolidateResult result=mProviderHelper.consolidateDatabaseStep1(progressable);
    log.add(result,1);
  }
  long[] importedMasterKeyIdsArray=new long[importedMasterKeyIds.size()];
  for (int i=0; i < importedMasterKeyIds.size(); ++i) {
    importedMasterKeyIdsArray[i]=importedMasterKeyIds.get(i);
  }
  int resultType=0;
  if (cancelled) {
    log.add(LogType.MSG_OPERATION_CANCELLED,1);
    resultType|=ImportKeyResult.RESULT_CANCELLED;
  }
  if (badKeys == 0 && newKeys == 0 && updatedKeys == 0) {
    resultType=ImportKeyResult.RESULT_FAIL_NOTHING;
  }
 else {
    if (newKeys > 0) {
      resultType|=ImportKeyResult.RESULT_OK_NEWKEYS;
    }
    if (updatedKeys > 0) {
      resultType|=ImportKeyResult.RESULT_OK_UPDATED;
    }
    if (badKeys > 0) {
      resultType|=ImportKeyResult.RESULT_WITH_ERRORS;
      if (newKeys == 0 && updatedKeys == 0) {
        resultType|=ImportKeyResult.RESULT_ERROR;
      }
    }
    if (log.containsWarnings()) {
      resultType|=ImportKeyResult.RESULT_WARNINGS;
    }
  }
  if ((newKeys > 0 || updatedKeys > 0) && badKeys > 0) {
    log.add(LogType.MSG_IMPORT_PARTIAL,1);
  }
 else   if (newKeys > 0 || updatedKeys > 0) {
    log.add(LogType.MSG_IMPORT_SUCCESS,1);
  }
 else {
    log.add(LogType.MSG_IMPORT_ERROR,1);
  }
  return new ImportKeyResult(resultType,log,newKeys,updatedKeys,badKeys,secret,importedMasterKeyIdsArray);
}",0.999853907962016
8279,"@NonNull @Override public OperationResult execute(RevokeKeyringParcel revokeKeyringParcel,CryptoInputParcel cryptoInputParcel){
  cryptoInputParcel.mCachePassphrase=false;
  long masterKeyId=revokeKeyringParcel.mMasterKeyId;
  OperationResult.OperationLog log=new OperationResult.OperationLog();
  log.add(OperationResult.LogType.MSG_REVOKE,0,KeyFormattingUtils.beautifyKeyId(masterKeyId));
  try {
    Uri secretUri=KeychainContract.KeyRings.buildUnifiedKeyRingUri(masterKeyId);
    CachedPublicKeyRing keyRing=mProviderHelper.getCachedPublicKeyRing(secretUri);
switch (keyRing.getSecretKeyType(masterKeyId)) {
case GNU_DUMMY:
      log.add(OperationResult.LogType.MSG_EK_ERROR_DUMMY,1);
    return new RevokeResult(RevokeResult.RESULT_ERROR,log,masterKeyId);
}
SaveKeyringParcel saveKeyringParcel=new SaveKeyringParcel(masterKeyId,keyRing.getFingerprint());
saveKeyringParcel.setUpdateOptions(revokeKeyringParcel.mUpload,true,revokeKeyringParcel.mKeyserver);
saveKeyringParcel.mRevokeSubKeys.add(masterKeyId);
InputPendingResult revokeAndUploadResult=new EditKeyOperation(mContext,mProviderHelper,mProgressable,mCancelled).execute(saveKeyringParcel,cryptoInputParcel);
if (revokeAndUploadResult.isPending()) {
  return revokeAndUploadResult;
}
log.add(revokeAndUploadResult,1);
if (revokeAndUploadResult.success()) {
  log.add(OperationResult.LogType.MSG_REVOKE_OK,1);
  return new RevokeResult(RevokeResult.RESULT_OK,log,masterKeyId);
}
 else {
  log.add(OperationResult.LogType.MSG_REVOKE_KEY_FAIL,1);
  return new RevokeResult(RevokeResult.RESULT_ERROR,log,masterKeyId);
}
}
 catch (PgpKeyNotFoundException|ProviderHelper.NotFoundException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(OperationResult.LogType.MSG_REVOKE_KEY_FAIL,1);
return new RevokeResult(RevokeResult.RESULT_ERROR,log,masterKeyId);
}
}","@NonNull @Override public OperationResult execute(RevokeKeyringParcel revokeKeyringParcel,CryptoInputParcel cryptoInputParcel){
  cryptoInputParcel.mCachePassphrase=false;
  long masterKeyId=revokeKeyringParcel.mMasterKeyId;
  OperationResult.OperationLog log=new OperationResult.OperationLog();
  log.add(OperationResult.LogType.MSG_REVOKE,0,KeyFormattingUtils.beautifyKeyId(masterKeyId));
  try {
    Uri secretUri=KeychainContract.KeyRings.buildUnifiedKeyRingUri(masterKeyId);
    CachedPublicKeyRing keyRing=mProviderHelper.getCachedPublicKeyRing(secretUri);
switch (keyRing.getSecretKeyType(masterKeyId)) {
case GNU_DUMMY:
      log.add(OperationResult.LogType.MSG_EK_ERROR_DUMMY,1);
    return new RevokeResult(RevokeResult.RESULT_ERROR,log,masterKeyId);
}
SaveKeyringParcel saveKeyringParcel=new SaveKeyringParcel(masterKeyId,keyRing.getFingerprint());
saveKeyringParcel.setUpdateOptions(revokeKeyringParcel.mUpload,true,revokeKeyringParcel.mKeyserver);
saveKeyringParcel.mRevokeSubKeys.add(masterKeyId);
InputPendingResult revokeAndUploadResult=new EditKeyOperation(mContext,mProviderHelper,mProgressable,mCancelled).execute(saveKeyringParcel,cryptoInputParcel);
if (revokeAndUploadResult.isPending()) {
  return revokeAndUploadResult;
}
log.add(revokeAndUploadResult,1);
if (revokeAndUploadResult.success()) {
  log.add(OperationResult.LogType.MSG_REVOKE_OK,1);
  return new RevokeResult(RevokeResult.RESULT_OK,log,masterKeyId);
}
 else {
  log.add(OperationResult.LogType.MSG_REVOKE_ERROR_KEY_FAIL,1);
  return new RevokeResult(RevokeResult.RESULT_ERROR,log,masterKeyId);
}
}
 catch (PgpKeyNotFoundException|ProviderHelper.NotFoundException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(OperationResult.LogType.MSG_REVOKE_ERROR_KEY_FAIL,1);
return new RevokeResult(RevokeResult.RESULT_ERROR,log,masterKeyId);
}
}",0.9967123287671232
8280,"/** 
 * Saves an UncachedKeyRing of the public variant into the db. <p/> This method will not delete all previous data for this masterKeyId from the database prior to inserting. All public data is effectively re-inserted, secret keyrings are left deleted and need to be saved externally to be preserved past the operation.
 */
@SuppressWarnings(""String_Node_Str"") private int saveCanonicalizedPublicKeyRing(CanonicalizedPublicKeyRing keyRing,Progressable progress,boolean selfCertsAreTrusted){
  int result=SaveKeyringResult.SAVED_PUBLIC;
  long masterKeyId=keyRing.getMasterKeyId();
  UncachedPublicKey masterKey=keyRing.getPublicKey();
  ArrayList<ContentProviderOperation> operations;
  try {
    log(LogType.MSG_IP_PREPARE);
    mIndent+=1;
    operations=new ArrayList<>();
    log(LogType.MSG_IP_INSERT_KEYRING);
{
      ContentValues values=new ContentValues();
      values.put(KeyRingData.MASTER_KEY_ID,masterKeyId);
      try {
        values.put(KeyRingData.KEY_RING_DATA,keyRing.getEncoded());
      }
 catch (      IOException e) {
        log(LogType.MSG_IP_ENCODE_FAIL);
        return SaveKeyringResult.RESULT_ERROR;
      }
      Uri uri=KeyRingData.buildPublicKeyRingUri(masterKeyId);
      operations.add(ContentProviderOperation.newInsert(uri).withValues(values).build());
    }
    log(LogType.MSG_IP_INSERT_SUBKEYS);
    progress.setProgress(LogType.MSG_IP_INSERT_SUBKEYS.getMsgId(),40,100);
    mIndent+=1;
{
      Uri uri=Keys.buildKeysUri(masterKeyId);
      int rank=0;
      for (      CanonicalizedPublicKey key : keyRing.publicKeyIterator()) {
        long keyId=key.getKeyId();
        log(keyId == masterKeyId ? LogType.MSG_IP_MASTER : LogType.MSG_IP_SUBKEY,KeyFormattingUtils.convertKeyIdToHex(keyId));
        mIndent+=1;
        ContentValues values=new ContentValues();
        values.put(Keys.MASTER_KEY_ID,masterKeyId);
        values.put(Keys.RANK,rank);
        values.put(Keys.KEY_ID,key.getKeyId());
        values.put(Keys.KEY_SIZE,key.getBitStrength());
        values.put(Keys.KEY_CURVE_OID,key.getCurveOid());
        values.put(Keys.ALGORITHM,key.getAlgorithm());
        values.put(Keys.FINGERPRINT,key.getFingerprint());
        boolean c=key.canCertify(), e=key.canEncrypt(), s=key.canSign(), a=key.canAuthenticate();
        values.put(Keys.CAN_CERTIFY,c);
        values.put(Keys.CAN_ENCRYPT,e);
        values.put(Keys.CAN_SIGN,s);
        values.put(Keys.CAN_AUTHENTICATE,a);
        values.put(Keys.IS_REVOKED,key.isRevoked());
        if (masterKeyId == keyId) {
          if (key.getKeyUsage() == null) {
            log(LogType.MSG_IP_MASTER_FLAGS_UNSPECIFIED);
          }
 else {
            log(LOG_TYPES_FLAG_MASTER[(c ? 1 : 0) + (e ? 2 : 0) + (s ? 4 : 0)+ (a ? 8 : 0)]);
          }
        }
 else {
          if (key.getKeyUsage() == null) {
            log(LogType.MSG_IP_SUBKEY_FLAGS_UNSPECIFIED);
          }
 else {
            log(LOG_TYPES_FLAG_SUBKEY[(c ? 1 : 0) + (e ? 2 : 0) + (s ? 4 : 0)+ (a ? 8 : 0)]);
          }
        }
        Date creation=key.getCreationTime();
        values.put(Keys.CREATION,creation.getTime() / 1000);
        Date expiryDate=key.getExpiryTime();
        if (expiryDate != null) {
          values.put(Keys.EXPIRY,expiryDate.getTime() / 1000);
          if (key.isExpired()) {
            log(keyId == masterKeyId ? LogType.MSG_IP_MASTER_EXPIRED : LogType.MSG_IP_SUBKEY_EXPIRED,expiryDate.toString());
          }
 else {
            log(keyId == masterKeyId ? LogType.MSG_IP_MASTER_EXPIRES : LogType.MSG_IP_SUBKEY_EXPIRES,expiryDate.toString());
          }
        }
        operations.add(ContentProviderOperation.newInsert(uri).withValues(values).build());
        ++rank;
        mIndent-=1;
      }
    }
    mIndent-=1;
    LongSparseArray<CanonicalizedPublicKey> trustedKeys=getTrustedMasterKeys();
    List<UserPacketItem> uids=new ArrayList<>();
    if (trustedKeys.size() == 0) {
      log(LogType.MSG_IP_UID_CLASSIFYING_ZERO);
    }
 else {
      log(LogType.MSG_IP_UID_CLASSIFYING,trustedKeys.size());
    }
    mIndent+=1;
    for (    byte[] rawUserId : masterKey.getUnorderedRawUserIds()) {
      String userId=Utf8Util.fromUTF8ByteArrayReplaceBadEncoding(rawUserId);
      UserPacketItem item=new UserPacketItem();
      uids.add(item);
      item.userId=userId;
      int unknownCerts=0;
      log(LogType.MSG_IP_UID_PROCESSING,userId);
      mIndent+=1;
      for (      WrappedSignature cert : new IterableIterator<>(masterKey.getSignaturesForRawId(rawUserId))) {
        long certId=cert.getKeyId();
        if (certId == masterKeyId) {
          if (!cert.isRevocation()) {
            item.selfCert=cert;
            item.isPrimary=cert.isPrimaryUserId();
          }
 else {
            item.selfRevocation=cert;
            log(LogType.MSG_IP_UID_REVOKED);
          }
          continue;
        }
        if (trustedKeys.indexOfKey(certId) < 0) {
          unknownCerts+=1;
          continue;
        }
        CanonicalizedPublicKey trustedKey=trustedKeys.get(certId);
        try {
          cert.init(trustedKey);
          if (!cert.verifySignature(masterKey,rawUserId)) {
            log(LogType.MSG_IP_UID_CERT_BAD);
            continue;
          }
          log(cert.isRevocation() ? LogType.MSG_IP_UID_CERT_GOOD_REVOKE : LogType.MSG_IP_UID_CERT_GOOD,KeyFormattingUtils.convertKeyIdToHexShort(trustedKey.getKeyId()));
          WrappedSignature prev=item.trustedCerts.get(cert.getKeyId());
          if (prev != null) {
            if (prev.getCreationTime().after(cert.getCreationTime())) {
              log(LogType.MSG_IP_UID_CERT_OLD);
              continue;
            }
            if (!prev.isRevocation() && !prev.isRevokable()) {
              log(LogType.MSG_IP_UID_CERT_NONREVOKE);
              continue;
            }
            log(LogType.MSG_IP_UID_CERT_NEW);
          }
          item.trustedCerts.put(cert.getKeyId(),cert);
        }
 catch (        PgpGeneralException e) {
          log(LogType.MSG_IP_UID_CERT_ERROR,KeyFormattingUtils.convertKeyIdToHex(cert.getKeyId()));
        }
      }
      if (unknownCerts > 0) {
        log(LogType.MSG_IP_UID_CERTS_UNKNOWN,unknownCerts);
      }
      mIndent-=1;
    }
    mIndent-=1;
    ArrayList<WrappedUserAttribute> userAttributes=masterKey.getUnorderedUserAttributes();
    if (!userAttributes.isEmpty()) {
      log(LogType.MSG_IP_UAT_CLASSIFYING);
    }
    mIndent+=1;
    for (    WrappedUserAttribute userAttribute : userAttributes) {
      UserPacketItem item=new UserPacketItem();
      uids.add(item);
      item.type=userAttribute.getType();
      item.attributeData=userAttribute.getEncoded();
      int unknownCerts=0;
switch (item.type) {
case WrappedUserAttribute.UAT_IMAGE:
        log(LogType.MSG_IP_UAT_PROCESSING_IMAGE);
      break;
default :
    log(LogType.MSG_IP_UAT_PROCESSING_UNKNOWN);
  break;
}
mIndent+=1;
for (WrappedSignature cert : new IterableIterator<>(masterKey.getSignaturesForUserAttribute(userAttribute))) {
long certId=cert.getKeyId();
if (certId == masterKeyId) {
  if (!cert.isRevocation()) {
    item.selfCert=cert;
  }
 else {
    item.selfRevocation=cert;
    log(LogType.MSG_IP_UAT_REVOKED);
  }
  continue;
}
if (trustedKeys.indexOfKey(certId) < 0) {
  unknownCerts+=1;
  continue;
}
CanonicalizedPublicKey trustedKey=trustedKeys.get(certId);
try {
  cert.init(trustedKey);
  if (!cert.verifySignature(masterKey,userAttribute)) {
    log(LogType.MSG_IP_UAT_CERT_BAD);
    continue;
  }
  log(cert.isRevocation() ? LogType.MSG_IP_UAT_CERT_GOOD_REVOKE : LogType.MSG_IP_UAT_CERT_GOOD,KeyFormattingUtils.convertKeyIdToHexShort(trustedKey.getKeyId()));
  WrappedSignature prev=item.trustedCerts.get(cert.getKeyId());
  if (prev != null) {
    if (prev.getCreationTime().after(cert.getCreationTime())) {
      log(LogType.MSG_IP_UAT_CERT_OLD);
      continue;
    }
    if (!prev.isRevocation() && !prev.isRevokable()) {
      log(LogType.MSG_IP_UAT_CERT_NONREVOKE);
      continue;
    }
    log(LogType.MSG_IP_UAT_CERT_NEW);
  }
  item.trustedCerts.put(cert.getKeyId(),cert);
}
 catch (PgpGeneralException e) {
  log(LogType.MSG_IP_UAT_CERT_ERROR,KeyFormattingUtils.convertKeyIdToHex(cert.getKeyId()));
}
}
if (unknownCerts > 0) {
log(LogType.MSG_IP_UAT_CERTS_UNKNOWN,unknownCerts);
}
mIndent-=1;
}
mIndent-=1;
progress.setProgress(LogType.MSG_IP_UID_REORDER.getMsgId(),65,100);
log(LogType.MSG_IP_UID_REORDER);
Collections.sort(uids);
for (int userIdRank=0; userIdRank < uids.size(); userIdRank++) {
UserPacketItem item=uids.get(userIdRank);
operations.add(buildUserIdOperations(masterKeyId,item,userIdRank));
if (item.selfRevocation != null) {
operations.add(buildCertOperations(masterKeyId,userIdRank,item.selfRevocation,Certs.VERIFIED_SELF));
continue;
}
if (item.selfCert == null) {
throw new AssertionError(""String_Node_Str"");
}
operations.add(buildCertOperations(masterKeyId,userIdRank,item.selfCert,selfCertsAreTrusted ? Certs.VERIFIED_SECRET : Certs.VERIFIED_SELF));
for (int i=0; i < item.trustedCerts.size(); i++) {
WrappedSignature sig=item.trustedCerts.valueAt(i);
if (sig.isRevocation()) {
  continue;
}
operations.add(buildCertOperations(masterKeyId,userIdRank,sig,Certs.VERIFIED_SECRET));
}
}
}
 catch (IOException e) {
log(LogType.MSG_IP_ERROR_IO_EXC);
Log.e(Constants.TAG,""String_Node_Str"",e);
return SaveKeyringResult.RESULT_ERROR;
}
 finally {
mIndent-=1;
}
final int INDEX_MASTER_KEY_ID=0;
final int INDEX_LAST_UPDATED=1;
Cursor lastUpdatedCursor=mContentResolver.query(UpdatedKeys.CONTENT_URI,new String[]{UpdatedKeys.MASTER_KEY_ID,UpdatedKeys.LAST_UPDATED},UpdatedKeys.MASTER_KEY_ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + masterKeyId},null);
ContentValues lastUpdatedEntry=null;
if (lastUpdatedCursor.moveToNext()) {
lastUpdatedEntry=new ContentValues(2);
lastUpdatedEntry.put(UpdatedKeys.MASTER_KEY_ID,lastUpdatedCursor.getLong(INDEX_MASTER_KEY_ID));
lastUpdatedEntry.put(UpdatedKeys.LAST_UPDATED,lastUpdatedCursor.getLong(INDEX_LAST_UPDATED));
Log.e(""String_Node_Str"",""String_Node_Str"" + lastUpdatedEntry + ""String_Node_Str""+ masterKeyId);
}
lastUpdatedCursor.close();
if (lastUpdatedEntry != null) {
operations.add(ContentProviderOperation.newInsert(UpdatedKeys.CONTENT_URI).withValues(lastUpdatedEntry).build());
}
try {
int deleted=mContentResolver.delete(KeyRingData.buildPublicKeyRingUri(masterKeyId),null,null);
if (deleted > 0) {
log(LogType.MSG_IP_DELETE_OLD_OK);
result|=SaveKeyringResult.UPDATED;
}
 else {
log(LogType.MSG_IP_DELETE_OLD_FAIL);
}
log(LogType.MSG_IP_APPLY_BATCH);
progress.setProgress(LogType.MSG_IP_APPLY_BATCH.getMsgId(),75,100);
mContentResolver.applyBatch(KeychainContract.CONTENT_AUTHORITY,operations);
log(LogType.MSG_IP_SUCCESS);
progress.setProgress(LogType.MSG_IP_SUCCESS.getMsgId(),90,100);
return result;
}
 catch (RemoteException e) {
log(LogType.MSG_IP_ERROR_REMOTE_EX);
Log.e(Constants.TAG,""String_Node_Str"",e);
return SaveKeyringResult.RESULT_ERROR;
}
catch (OperationApplicationException e) {
log(LogType.MSG_IP_ERROR_OP_EXC);
Log.e(Constants.TAG,""String_Node_Str"",e);
return SaveKeyringResult.RESULT_ERROR;
}
}","/** 
 * Saves an UncachedKeyRing of the public variant into the db. <p/> This method will not delete all previous data for this masterKeyId from the database prior to inserting. All public data is effectively re-inserted, secret keyrings are left deleted and need to be saved externally to be preserved past the operation.
 */
@SuppressWarnings(""String_Node_Str"") private int saveCanonicalizedPublicKeyRing(CanonicalizedPublicKeyRing keyRing,Progressable progress,boolean selfCertsAreTrusted){
  int result=SaveKeyringResult.SAVED_PUBLIC;
  long masterKeyId=keyRing.getMasterKeyId();
  UncachedPublicKey masterKey=keyRing.getPublicKey();
  ArrayList<ContentProviderOperation> operations;
  try {
    log(LogType.MSG_IP_PREPARE);
    mIndent+=1;
    operations=new ArrayList<>();
    log(LogType.MSG_IP_INSERT_KEYRING);
{
      ContentValues values=new ContentValues();
      values.put(KeyRingData.MASTER_KEY_ID,masterKeyId);
      try {
        values.put(KeyRingData.KEY_RING_DATA,keyRing.getEncoded());
      }
 catch (      IOException e) {
        log(LogType.MSG_IP_ENCODE_FAIL);
        return SaveKeyringResult.RESULT_ERROR;
      }
      Uri uri=KeyRingData.buildPublicKeyRingUri(masterKeyId);
      operations.add(ContentProviderOperation.newInsert(uri).withValues(values).build());
    }
    log(LogType.MSG_IP_INSERT_SUBKEYS);
    progress.setProgress(LogType.MSG_IP_INSERT_SUBKEYS.getMsgId(),40,100);
    mIndent+=1;
{
      Uri uri=Keys.buildKeysUri(masterKeyId);
      int rank=0;
      for (      CanonicalizedPublicKey key : keyRing.publicKeyIterator()) {
        long keyId=key.getKeyId();
        log(keyId == masterKeyId ? LogType.MSG_IP_MASTER : LogType.MSG_IP_SUBKEY,KeyFormattingUtils.convertKeyIdToHex(keyId));
        mIndent+=1;
        ContentValues values=new ContentValues();
        values.put(Keys.MASTER_KEY_ID,masterKeyId);
        values.put(Keys.RANK,rank);
        values.put(Keys.KEY_ID,key.getKeyId());
        values.put(Keys.KEY_SIZE,key.getBitStrength());
        values.put(Keys.KEY_CURVE_OID,key.getCurveOid());
        values.put(Keys.ALGORITHM,key.getAlgorithm());
        values.put(Keys.FINGERPRINT,key.getFingerprint());
        boolean c=key.canCertify(), e=key.canEncrypt(), s=key.canSign(), a=key.canAuthenticate();
        values.put(Keys.CAN_CERTIFY,c);
        values.put(Keys.CAN_ENCRYPT,e);
        values.put(Keys.CAN_SIGN,s);
        values.put(Keys.CAN_AUTHENTICATE,a);
        values.put(Keys.IS_REVOKED,key.isRevoked());
        if (masterKeyId == keyId) {
          if (key.getKeyUsage() == null) {
            log(LogType.MSG_IP_MASTER_FLAGS_UNSPECIFIED);
          }
 else {
            log(LOG_TYPES_FLAG_MASTER[(c ? 1 : 0) + (e ? 2 : 0) + (s ? 4 : 0)+ (a ? 8 : 0)]);
          }
        }
 else {
          if (key.getKeyUsage() == null) {
            log(LogType.MSG_IP_SUBKEY_FLAGS_UNSPECIFIED);
          }
 else {
            log(LOG_TYPES_FLAG_SUBKEY[(c ? 1 : 0) + (e ? 2 : 0) + (s ? 4 : 0)+ (a ? 8 : 0)]);
          }
        }
        Date creation=key.getCreationTime();
        values.put(Keys.CREATION,creation.getTime() / 1000);
        Date expiryDate=key.getExpiryTime();
        if (expiryDate != null) {
          values.put(Keys.EXPIRY,expiryDate.getTime() / 1000);
          if (key.isExpired()) {
            log(keyId == masterKeyId ? LogType.MSG_IP_MASTER_EXPIRED : LogType.MSG_IP_SUBKEY_EXPIRED,expiryDate.toString());
          }
 else {
            log(keyId == masterKeyId ? LogType.MSG_IP_MASTER_EXPIRES : LogType.MSG_IP_SUBKEY_EXPIRES,expiryDate.toString());
          }
        }
        operations.add(ContentProviderOperation.newInsert(uri).withValues(values).build());
        ++rank;
        mIndent-=1;
      }
    }
    mIndent-=1;
    LongSparseArray<CanonicalizedPublicKey> trustedKeys=getTrustedMasterKeys();
    List<UserPacketItem> uids=new ArrayList<>();
    if (trustedKeys.size() == 0) {
      log(LogType.MSG_IP_UID_CLASSIFYING_ZERO);
    }
 else {
      log(LogType.MSG_IP_UID_CLASSIFYING,trustedKeys.size());
    }
    mIndent+=1;
    for (    byte[] rawUserId : masterKey.getUnorderedRawUserIds()) {
      String userId=Utf8Util.fromUTF8ByteArrayReplaceBadEncoding(rawUserId);
      UserPacketItem item=new UserPacketItem();
      uids.add(item);
      item.userId=userId;
      int unknownCerts=0;
      log(LogType.MSG_IP_UID_PROCESSING,userId);
      mIndent+=1;
      for (      WrappedSignature cert : new IterableIterator<>(masterKey.getSignaturesForRawId(rawUserId))) {
        long certId=cert.getKeyId();
        if (certId == masterKeyId) {
          if (!cert.isRevocation()) {
            item.selfCert=cert;
            item.isPrimary=cert.isPrimaryUserId();
          }
 else {
            item.selfRevocation=cert;
            log(LogType.MSG_IP_UID_REVOKED);
          }
          continue;
        }
        if (trustedKeys.indexOfKey(certId) < 0) {
          unknownCerts+=1;
          continue;
        }
        CanonicalizedPublicKey trustedKey=trustedKeys.get(certId);
        try {
          cert.init(trustedKey);
          if (!cert.verifySignature(masterKey,rawUserId)) {
            log(LogType.MSG_IP_UID_CERT_BAD);
            continue;
          }
          log(cert.isRevocation() ? LogType.MSG_IP_UID_CERT_GOOD_REVOKE : LogType.MSG_IP_UID_CERT_GOOD,KeyFormattingUtils.convertKeyIdToHexShort(trustedKey.getKeyId()));
          WrappedSignature prev=item.trustedCerts.get(cert.getKeyId());
          if (prev != null) {
            if (prev.getCreationTime().after(cert.getCreationTime())) {
              log(LogType.MSG_IP_UID_CERT_OLD);
              continue;
            }
            if (!prev.isRevocation() && !prev.isRevokable()) {
              log(LogType.MSG_IP_UID_CERT_NONREVOKE);
              continue;
            }
            log(LogType.MSG_IP_UID_CERT_NEW);
          }
          item.trustedCerts.put(cert.getKeyId(),cert);
        }
 catch (        PgpGeneralException e) {
          log(LogType.MSG_IP_UID_CERT_ERROR,KeyFormattingUtils.convertKeyIdToHex(cert.getKeyId()));
        }
      }
      if (unknownCerts > 0) {
        log(LogType.MSG_IP_UID_CERTS_UNKNOWN,unknownCerts);
      }
      mIndent-=1;
    }
    mIndent-=1;
    ArrayList<WrappedUserAttribute> userAttributes=masterKey.getUnorderedUserAttributes();
    if (!userAttributes.isEmpty()) {
      log(LogType.MSG_IP_UAT_CLASSIFYING);
    }
    mIndent+=1;
    for (    WrappedUserAttribute userAttribute : userAttributes) {
      UserPacketItem item=new UserPacketItem();
      uids.add(item);
      item.type=userAttribute.getType();
      item.attributeData=userAttribute.getEncoded();
      int unknownCerts=0;
switch (item.type) {
case WrappedUserAttribute.UAT_IMAGE:
        log(LogType.MSG_IP_UAT_PROCESSING_IMAGE);
      break;
default :
    log(LogType.MSG_IP_UAT_PROCESSING_UNKNOWN);
  break;
}
mIndent+=1;
for (WrappedSignature cert : new IterableIterator<>(masterKey.getSignaturesForUserAttribute(userAttribute))) {
long certId=cert.getKeyId();
if (certId == masterKeyId) {
  if (!cert.isRevocation()) {
    item.selfCert=cert;
  }
 else {
    item.selfRevocation=cert;
    log(LogType.MSG_IP_UAT_REVOKED);
  }
  continue;
}
if (trustedKeys.indexOfKey(certId) < 0) {
  unknownCerts+=1;
  continue;
}
CanonicalizedPublicKey trustedKey=trustedKeys.get(certId);
try {
  cert.init(trustedKey);
  if (!cert.verifySignature(masterKey,userAttribute)) {
    log(LogType.MSG_IP_UAT_CERT_BAD);
    continue;
  }
  log(cert.isRevocation() ? LogType.MSG_IP_UAT_CERT_GOOD_REVOKE : LogType.MSG_IP_UAT_CERT_GOOD,KeyFormattingUtils.convertKeyIdToHexShort(trustedKey.getKeyId()));
  WrappedSignature prev=item.trustedCerts.get(cert.getKeyId());
  if (prev != null) {
    if (prev.getCreationTime().after(cert.getCreationTime())) {
      log(LogType.MSG_IP_UAT_CERT_OLD);
      continue;
    }
    if (!prev.isRevocation() && !prev.isRevokable()) {
      log(LogType.MSG_IP_UAT_CERT_NONREVOKE);
      continue;
    }
    log(LogType.MSG_IP_UAT_CERT_NEW);
  }
  item.trustedCerts.put(cert.getKeyId(),cert);
}
 catch (PgpGeneralException e) {
  log(LogType.MSG_IP_UAT_CERT_ERROR,KeyFormattingUtils.convertKeyIdToHex(cert.getKeyId()));
}
}
if (unknownCerts > 0) {
log(LogType.MSG_IP_UAT_CERTS_UNKNOWN,unknownCerts);
}
mIndent-=1;
}
mIndent-=1;
progress.setProgress(LogType.MSG_IP_UID_REORDER.getMsgId(),65,100);
log(LogType.MSG_IP_UID_REORDER);
Collections.sort(uids);
for (int userIdRank=0; userIdRank < uids.size(); userIdRank++) {
UserPacketItem item=uids.get(userIdRank);
operations.add(buildUserIdOperations(masterKeyId,item,userIdRank));
if (item.selfRevocation != null) {
operations.add(buildCertOperations(masterKeyId,userIdRank,item.selfRevocation,Certs.VERIFIED_SELF));
continue;
}
if (item.selfCert == null) {
throw new AssertionError(""String_Node_Str"");
}
operations.add(buildCertOperations(masterKeyId,userIdRank,item.selfCert,selfCertsAreTrusted ? Certs.VERIFIED_SECRET : Certs.VERIFIED_SELF));
for (int i=0; i < item.trustedCerts.size(); i++) {
WrappedSignature sig=item.trustedCerts.valueAt(i);
if (sig.isRevocation()) {
  continue;
}
operations.add(buildCertOperations(masterKeyId,userIdRank,sig,Certs.VERIFIED_SECRET));
}
}
}
 catch (IOException e) {
log(LogType.MSG_IP_ERROR_IO_EXC);
Log.e(Constants.TAG,""String_Node_Str"",e);
return SaveKeyringResult.RESULT_ERROR;
}
 finally {
mIndent-=1;
}
final int INDEX_MASTER_KEY_ID=0;
final int INDEX_LAST_UPDATED=1;
Cursor lastUpdatedCursor=mContentResolver.query(UpdatedKeys.CONTENT_URI,new String[]{UpdatedKeys.MASTER_KEY_ID,UpdatedKeys.LAST_UPDATED},UpdatedKeys.MASTER_KEY_ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + masterKeyId},null);
if (lastUpdatedCursor.moveToNext()) {
ContentValues lastUpdatedEntry=new ContentValues(2);
lastUpdatedEntry.put(UpdatedKeys.MASTER_KEY_ID,lastUpdatedCursor.getLong(INDEX_MASTER_KEY_ID));
lastUpdatedEntry.put(UpdatedKeys.LAST_UPDATED,lastUpdatedCursor.getLong(INDEX_LAST_UPDATED));
operations.add(ContentProviderOperation.newInsert(UpdatedKeys.CONTENT_URI).withValues(lastUpdatedEntry).build());
}
lastUpdatedCursor.close();
try {
int deleted=mContentResolver.delete(KeyRingData.buildPublicKeyRingUri(masterKeyId),null,null);
if (deleted > 0) {
log(LogType.MSG_IP_DELETE_OLD_OK);
result|=SaveKeyringResult.UPDATED;
}
 else {
log(LogType.MSG_IP_DELETE_OLD_FAIL);
}
log(LogType.MSG_IP_APPLY_BATCH);
progress.setProgress(LogType.MSG_IP_APPLY_BATCH.getMsgId(),75,100);
mContentResolver.applyBatch(KeychainContract.CONTENT_AUTHORITY,operations);
log(LogType.MSG_IP_SUCCESS);
progress.setProgress(LogType.MSG_IP_SUCCESS.getMsgId(),90,100);
return result;
}
 catch (RemoteException e) {
log(LogType.MSG_IP_ERROR_REMOTE_EX);
Log.e(Constants.TAG,""String_Node_Str"",e);
return SaveKeyringResult.RESULT_ERROR;
}
catch (OperationApplicationException e) {
log(LogType.MSG_IP_ERROR_OP_EXC);
Log.e(Constants.TAG,""String_Node_Str"",e);
return SaveKeyringResult.RESULT_ERROR;
}
}",0.987099421069426
8281,"/** 
 * will perform a staggered update of user's keys using delays to ensure new Tor circuits, as performed by parcimonie. Relevant issue and method at: https://github.com/open-keychain/open-keychain/issues/1337
 * @return result of the sync
 */
private ImportKeyResult staggeredUpdate(Context context,ArrayList<ParcelableKeyRing> keyList,CryptoInputParcel cryptoInputParcel){
  Log.d(Constants.TAG,""String_Node_Str"");
  final int MAX_CIRCUIT_DIRTINESS=(int)TimeUnit.MINUTES.toSeconds(1);
  final int WEEK_IN_SECONDS=0;
  ImportOperation.KeyImportAccumulator accumulator=new ImportOperation.KeyImportAccumulator(keyList.size(),null);
  for (  ParcelableKeyRing keyRing : keyList) {
    int waitTime;
    int staggeredTime=new Random().nextInt(1 + 2 * (WEEK_IN_SECONDS / keyList.size()));
    if (staggeredTime >= MAX_CIRCUIT_DIRTINESS) {
      waitTime=staggeredTime;
    }
 else {
      waitTime=MAX_CIRCUIT_DIRTINESS + new Random().nextInt(MAX_CIRCUIT_DIRTINESS);
    }
    Log.d(Constants.TAG,""String_Node_Str"" + keyRing.mExpectedFingerprint + ""String_Node_Str""+ waitTime+ ""String_Node_Str"");
    try {
      Thread.sleep(waitTime * 1000);
    }
 catch (    InterruptedException e) {
      Log.e(Constants.TAG,""String_Node_Str"",e);
      continue;
    }
    ArrayList<ParcelableKeyRing> keyWrapper=new ArrayList<>();
    keyWrapper.add(keyRing);
    if (isUpdateCancelled()) {
      return new ImportKeyResult(ImportKeyResult.RESULT_CANCELLED,new OperationResult.OperationLog());
    }
    ImportKeyResult result=new ImportOperation(context,new ProviderHelper(context),null,mCancelled).execute(new ImportKeyringParcel(keyWrapper,Preferences.getPreferences(context).getPreferredKeyserver()),cryptoInputParcel);
    if (result.isPending()) {
      return result;
    }
    accumulator.accumulateKeyImport(result);
  }
  return accumulator.getConsolidatedResult();
}","/** 
 * will perform a staggered update of user's keys using delays to ensure new Tor circuits, as performed by parcimonie. Relevant issue and method at: https://github.com/open-keychain/open-keychain/issues/1337
 * @return result of the sync
 */
private ImportKeyResult staggeredUpdate(Context context,ArrayList<ParcelableKeyRing> keyList,CryptoInputParcel cryptoInputParcel){
  Log.d(Constants.TAG,""String_Node_Str"");
  final int WEEK_IN_SECONDS=0;
  ImportOperation.KeyImportAccumulator accumulator=new ImportOperation.KeyImportAccumulator(keyList.size(),null);
  for (  ParcelableKeyRing keyRing : keyList) {
    int waitTime;
    int staggeredTime=new Random().nextInt(1 + 2 * (WEEK_IN_SECONDS / keyList.size()));
    if (staggeredTime >= ORBOT_CIRCUIT_TIMEOUT) {
      waitTime=staggeredTime;
    }
 else {
      waitTime=ORBOT_CIRCUIT_TIMEOUT + new Random().nextInt(ORBOT_CIRCUIT_TIMEOUT);
    }
    Log.d(Constants.TAG,""String_Node_Str"" + keyRing.mExpectedFingerprint + ""String_Node_Str""+ waitTime+ ""String_Node_Str"");
    try {
      Thread.sleep(waitTime * 1000);
    }
 catch (    InterruptedException e) {
      Log.e(Constants.TAG,""String_Node_Str"",e);
      continue;
    }
    ArrayList<ParcelableKeyRing> keyWrapper=new ArrayList<>();
    keyWrapper.add(keyRing);
    if (isUpdateCancelled()) {
      return new ImportKeyResult(ImportKeyResult.RESULT_CANCELLED,new OperationResult.OperationLog());
    }
    ImportKeyResult result=new ImportOperation(context,new ProviderHelper(context),null,mCancelled).execute(new ImportKeyringParcel(keyWrapper,Preferences.getPreferences(context).getPreferredKeyserver()),cryptoInputParcel);
    if (result.isPending()) {
      return result;
    }
    accumulator.accumulateKeyImport(result);
  }
  return accumulator.getConsolidatedResult();
}",0.962882096069869
8282,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case OrbotRequiredDialogActivity.MESSAGE_ORBOT_STARTED:
{
      Log.e(""String_Node_Str"",""String_Node_Str"");
      asyncKeyUpdate(KeyserverSyncAdapterService.this,new CryptoInputParcel());
      break;
    }
case OrbotRequiredDialogActivity.MESSAGE_ORBOT_IGNORE:
{
    asyncKeyUpdate(KeyserverSyncAdapterService.this,new CryptoInputParcel(ParcelableProxy.getForNoProxy()));
    break;
  }
case OrbotRequiredDialogActivity.MESSAGE_DIALOG_CANCEL:
{
  stopSelf();
  break;
}
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case OrbotRequiredDialogActivity.MESSAGE_ORBOT_STARTED:
{
      asyncKeyUpdate(KeyserverSyncAdapterService.this,new CryptoInputParcel());
      break;
    }
case OrbotRequiredDialogActivity.MESSAGE_ORBOT_IGNORE:
{
    asyncKeyUpdate(KeyserverSyncAdapterService.this,new CryptoInputParcel(ParcelableProxy.getForNoProxy()));
    break;
  }
case OrbotRequiredDialogActivity.MESSAGE_DIALOG_CANCEL:
{
  stopSelf();
  break;
}
}
}",0.9518304431599228
8283,"@Override public int onStartCommand(final Intent intent,int flags,final int startId){
  Log.e(""String_Node_Str"",""String_Node_Str"" + intent.getAction());
switch (intent.getAction()) {
case ACTION_CANCEL:
{
      mCancelled.set(true);
      break;
    }
case ACTION_SYNC_NOW:
{
    ContentResolver.requestSync(new Account(Constants.ACCOUNT_NAME,Constants.ACCOUNT_TYPE),Constants.PROVIDER_AUTHORITY,new Bundle());
    break;
  }
case ACTION_UPDATE_ALL:
{
  asyncKeyUpdate(this,new CryptoInputParcel());
  break;
}
case ACTION_IGNORE_TOR:
{
NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
manager.cancel(Constants.Notification.KEYSERVER_SYNC_FAIL_ORBOT);
asyncKeyUpdate(this,new CryptoInputParcel(ParcelableProxy.getForNoProxy()));
break;
}
case ACTION_START_ORBOT:
{
NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
manager.cancel(Constants.Notification.KEYSERVER_SYNC_FAIL_ORBOT);
Intent startOrbot=new Intent(this,OrbotRequiredDialogActivity.class);
startOrbot.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startOrbot.putExtra(OrbotRequiredDialogActivity.EXTRA_START_ORBOT,true);
Messenger messenger=new Messenger(new Handler(){
@Override public void handleMessage(Message msg){
switch (msg.what) {
case OrbotRequiredDialogActivity.MESSAGE_ORBOT_STARTED:
{
      Log.e(""String_Node_Str"",""String_Node_Str"");
      asyncKeyUpdate(KeyserverSyncAdapterService.this,new CryptoInputParcel());
      break;
    }
case OrbotRequiredDialogActivity.MESSAGE_ORBOT_IGNORE:
{
    asyncKeyUpdate(KeyserverSyncAdapterService.this,new CryptoInputParcel(ParcelableProxy.getForNoProxy()));
    break;
  }
case OrbotRequiredDialogActivity.MESSAGE_DIALOG_CANCEL:
{
  stopSelf();
  break;
}
}
}
}
);
startOrbot.putExtra(OrbotRequiredDialogActivity.EXTRA_MESSENGER,messenger);
startActivity(startOrbot);
break;
}
case ACTION_DISMISS_NOTIFICATION:
{
NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
manager.cancel(Constants.Notification.KEYSERVER_SYNC_FAIL_ORBOT);
stopSelf(startId);
break;
}
}
return START_NOT_STICKY;
}","@Override public int onStartCommand(final Intent intent,int flags,final int startId){
switch (intent.getAction()) {
case ACTION_CANCEL:
{
      mCancelled.set(true);
      break;
    }
case ACTION_SYNC_NOW:
{
    ContentResolver.requestSync(new Account(Constants.ACCOUNT_NAME,Constants.ACCOUNT_TYPE),Constants.PROVIDER_AUTHORITY,new Bundle());
    break;
  }
case ACTION_UPDATE_ALL:
{
  asyncKeyUpdate(this,new CryptoInputParcel());
  break;
}
case ACTION_IGNORE_TOR:
{
NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
manager.cancel(Constants.Notification.KEYSERVER_SYNC_FAIL_ORBOT);
asyncKeyUpdate(this,new CryptoInputParcel(ParcelableProxy.getForNoProxy()));
break;
}
case ACTION_START_ORBOT:
{
NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
manager.cancel(Constants.Notification.KEYSERVER_SYNC_FAIL_ORBOT);
Intent startOrbot=new Intent(this,OrbotRequiredDialogActivity.class);
startOrbot.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startOrbot.putExtra(OrbotRequiredDialogActivity.EXTRA_START_ORBOT,true);
Messenger messenger=new Messenger(new Handler(){
@Override public void handleMessage(Message msg){
switch (msg.what) {
case OrbotRequiredDialogActivity.MESSAGE_ORBOT_STARTED:
{
      asyncKeyUpdate(KeyserverSyncAdapterService.this,new CryptoInputParcel());
      break;
    }
case OrbotRequiredDialogActivity.MESSAGE_ORBOT_IGNORE:
{
    asyncKeyUpdate(KeyserverSyncAdapterService.this,new CryptoInputParcel(ParcelableProxy.getForNoProxy()));
    break;
  }
case OrbotRequiredDialogActivity.MESSAGE_DIALOG_CANCEL:
{
  stopSelf();
  break;
}
}
}
}
);
startOrbot.putExtra(OrbotRequiredDialogActivity.EXTRA_MESSENGER,messenger);
startActivity(startOrbot);
break;
}
case ACTION_DISMISS_NOTIFICATION:
{
NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
manager.cancel(Constants.Notification.KEYSERVER_SYNC_FAIL_ORBOT);
stopSelf(startId);
break;
}
}
return START_NOT_STICKY;
}",0.9715259187150158
8284,"private void asyncKeyUpdate(final Context context,final CryptoInputParcel cryptoInputParcel){
  Log.e(""String_Node_Str"",""String_Node_Str"");
  new Thread(new Runnable(){
    @Override public void run(){
      ImportKeyResult result=updateKeysFromKeyserver(context,cryptoInputParcel);
      handleUpdateResult(result);
    }
  }
).start();
}","private void asyncKeyUpdate(final Context context,final CryptoInputParcel cryptoInputParcel){
  new Thread(new Runnable(){
    @Override public void run(){
      ImportKeyResult result=updateKeysFromKeyserver(context,cryptoInputParcel);
      handleUpdateResult(result);
    }
  }
).start();
}",0.9272151898734176
8285,"private void handleUpdateResult(ImportKeyResult result){
  if (result.isPending()) {
    Log.e(Constants.TAG,""String_Node_Str"" + result.getRequiredInputParcel().mType);
    new OrbotHelper.SilentStartManager(){
      @Override protected void onOrbotStarted(){
        asyncKeyUpdate(KeyserverSyncAdapterService.this,new CryptoInputParcel());
      }
      @Override protected void onSilentStartDisabled(){
        NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
        manager.notify(Constants.Notification.KEYSERVER_SYNC_FAIL_ORBOT,getOrbotNoification(KeyserverSyncAdapterService.this));
      }
    }
.startOrbotAndListen(this,false);
  }
 else   if (isUpdateCancelled()) {
    Log.d(Constants.TAG,""String_Node_Str"");
    postponeSync();
  }
 else {
    Log.d(Constants.TAG,""String_Node_Str"" + result.mUpdatedKeys + ""String_Node_Str""+ result.mBadKeys);
    stopSelf();
  }
}","private void handleUpdateResult(ImportKeyResult result){
  if (result.isPending()) {
    new OrbotHelper.SilentStartManager(){
      @Override protected void onOrbotStarted(){
        asyncKeyUpdate(KeyserverSyncAdapterService.this,new CryptoInputParcel());
      }
      @Override protected void onSilentStartDisabled(){
        NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
        manager.notify(Constants.Notification.KEYSERVER_SYNC_FAIL_ORBOT,getOrbotNoification(KeyserverSyncAdapterService.this));
      }
    }
.startOrbotAndListen(this,false);
  }
 else   if (isUpdateCancelled()) {
    Log.d(Constants.TAG,""String_Node_Str"" + SYNC_POSTPONE_TIME + ""String_Node_Str"");
    postponeSync();
  }
 else {
    Log.d(Constants.TAG,""String_Node_Str"" + result.mUpdatedKeys + ""String_Node_Str""+ result.mBadKeys);
    stopSelf();
  }
}",0.9302844394868934
8286,"/** 
 * 1. Get keys which have been updated recently and therefore do not need to be updated now 2. Get list of all keys and filter out ones that don't need to be updated 3. Return keys to be updated
 * @return list of keys that require update
 */
private ArrayList<ParcelableKeyRing> getKeysToUpdate(Context context){
  final int INDEX_UPDATED_KEYS_MASTER_KEY_ID=0;
  final int INDEX_LAST_UPDATED=1;
  final long TIME_MAX=1;
  final long CURRENT_TIME=GregorianCalendar.getInstance().getTimeInMillis() / 1000;
  Log.e(""String_Node_Str"",""String_Node_Str"" + TIME_MAX + ""String_Node_Str""+ CURRENT_TIME);
  Cursor updatedKeysCursor=context.getContentResolver().query(KeychainContract.UpdatedKeys.CONTENT_URI,new String[]{KeychainContract.UpdatedKeys.MASTER_KEY_ID,KeychainContract.UpdatedKeys.LAST_UPDATED},""String_Node_Str"" + KeychainContract.UpdatedKeys.LAST_UPDATED + ""String_Node_Str""+ TIME_MAX,new String[]{""String_Node_Str"" + CURRENT_TIME},null);
  ArrayList<Long> ignoreMasterKeyIds=new ArrayList<>();
  while (updatedKeysCursor.moveToNext()) {
    long masterKeyId=updatedKeysCursor.getLong(INDEX_UPDATED_KEYS_MASTER_KEY_ID);
    Log.d(Constants.TAG,""String_Node_Str"" + masterKeyId + ""String_Node_Str""+ updatedKeysCursor.getLong(INDEX_LAST_UPDATED)+ ""String_Node_Str"");
    ignoreMasterKeyIds.add(masterKeyId);
  }
  updatedKeysCursor.close();
  final int INDEX_MASTER_KEY_ID=0;
  final int INDEX_FINGERPRINT=1;
  Cursor keyCursor=context.getContentResolver().query(KeychainContract.KeyRings.buildUnifiedKeyRingsUri(),new String[]{KeychainContract.KeyRings.MASTER_KEY_ID,KeychainContract.KeyRings.FINGERPRINT},null,null,null);
  if (keyCursor == null) {
    return new ArrayList<>();
  }
  ArrayList<ParcelableKeyRing> keyList=new ArrayList<>();
  while (keyCursor.moveToNext()) {
    long keyId=keyCursor.getLong(INDEX_MASTER_KEY_ID);
    if (ignoreMasterKeyIds.contains(keyId)) {
      continue;
    }
    String fingerprint=KeyFormattingUtils.convertFingerprintToHex(keyCursor.getBlob(INDEX_FINGERPRINT));
    String hexKeyId=KeyFormattingUtils.convertKeyIdToHex(keyId);
    keyList.add(new ParcelableKeyRing(fingerprint,hexKeyId,null));
  }
  keyCursor.close();
  return keyList;
}","/** 
 * 1. Get keys which have been updated recently and therefore do not need to be updated now 2. Get list of all keys and filter out ones that don't need to be updated 3. Return keys to be updated
 * @return list of keys that require update
 */
private ArrayList<ParcelableKeyRing> getKeysToUpdate(Context context){
  final int INDEX_UPDATED_KEYS_MASTER_KEY_ID=0;
  final int INDEX_LAST_UPDATED=1;
  final long CURRENT_TIME=GregorianCalendar.getInstance().getTimeInMillis() / 1000;
  Cursor updatedKeysCursor=context.getContentResolver().query(KeychainContract.UpdatedKeys.CONTENT_URI,new String[]{KeychainContract.UpdatedKeys.MASTER_KEY_ID,KeychainContract.UpdatedKeys.LAST_UPDATED},""String_Node_Str"" + KeychainContract.UpdatedKeys.LAST_UPDATED + ""String_Node_Str""+ KEY_UPDATE_LIMIT,new String[]{""String_Node_Str"" + CURRENT_TIME},null);
  ArrayList<Long> ignoreMasterKeyIds=new ArrayList<>();
  while (updatedKeysCursor.moveToNext()) {
    long masterKeyId=updatedKeysCursor.getLong(INDEX_UPDATED_KEYS_MASTER_KEY_ID);
    Log.d(Constants.TAG,""String_Node_Str"" + masterKeyId + ""String_Node_Str""+ updatedKeysCursor.getLong(INDEX_LAST_UPDATED)+ ""String_Node_Str"");
    ignoreMasterKeyIds.add(masterKeyId);
  }
  updatedKeysCursor.close();
  final int INDEX_MASTER_KEY_ID=0;
  final int INDEX_FINGERPRINT=1;
  Cursor keyCursor=context.getContentResolver().query(KeychainContract.KeyRings.buildUnifiedKeyRingsUri(),new String[]{KeychainContract.KeyRings.MASTER_KEY_ID,KeychainContract.KeyRings.FINGERPRINT},null,null,null);
  if (keyCursor == null) {
    return new ArrayList<>();
  }
  ArrayList<ParcelableKeyRing> keyList=new ArrayList<>();
  while (keyCursor.moveToNext()) {
    long keyId=keyCursor.getLong(INDEX_MASTER_KEY_ID);
    if (ignoreMasterKeyIds.contains(keyId)) {
      continue;
    }
    Log.d(Constants.TAG,""String_Node_Str"" + keyId + ""String_Node_Str"");
    String fingerprint=KeyFormattingUtils.convertFingerprintToHex(keyCursor.getBlob(INDEX_FINGERPRINT));
    String hexKeyId=KeyFormattingUtils.convertKeyIdToHex(keyId);
    keyList.add(new ParcelableKeyRing(fingerprint,hexKeyId,null));
  }
  keyCursor.close();
  return keyList;
}",0.9520958083832336
8287,"private void postponeSync(){
  AlarmManager alarmManager=(AlarmManager)getSystemService(Context.ALARM_SERVICE);
  Intent serviceIntent=new Intent(this,KeyserverSyncAdapterService.class);
  serviceIntent.setAction(ACTION_SYNC_NOW);
  PendingIntent pi=PendingIntent.getService(this,0,serviceIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + 30 * 1000,pi);
}","private void postponeSync(){
  AlarmManager alarmManager=(AlarmManager)getSystemService(Context.ALARM_SERVICE);
  Intent serviceIntent=new Intent(this,KeyserverSyncAdapterService.class);
  serviceIntent.setAction(ACTION_SYNC_NOW);
  PendingIntent pi=PendingIntent.getService(this,0,serviceIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + SYNC_POSTPONE_TIME,pi);
}",0.9693530079455164
8288,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.help_about_fragment,container,false);
  TextView versionText=(TextView)view.findViewById(R.id.help_about_version);
  versionText.setText(getString(R.string.help_about_version) + ""String_Node_Str"" + getVersion());
  HtmlTextView aboutTextView=(HtmlTextView)view.findViewById(R.id.help_about_text);
  try {
    String html=new Markdown4jProcessor().process(getActivity().getResources().openRawResource(R.raw.help_about));
    aboutTextView.setHtmlFromString(html,new HtmlTextView.LocalImageGetter());
  }
 catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
  }
  aboutTextView.setTextColor(getResources().getColor(android.R.color.black));
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.help_about_fragment,container,false);
  TextView versionText=(TextView)view.findViewById(R.id.help_about_version);
  versionText.setText(getString(R.string.help_about_version) + ""String_Node_Str"" + getVersion());
  HtmlTextView aboutTextView=(HtmlTextView)view.findViewById(R.id.help_about_text);
  try {
    String html=new Markdown4jProcessor().process(getActivity().getResources().openRawResource(R.raw.help_about));
    aboutTextView.setHtmlFromString(html,new HtmlTextView.LocalImageGetter());
  }
 catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
  }
  return view;
}",0.935897435897436
8289,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  int mHtmlFile=getArguments().getInt(ARG_MARKDOWN_RES);
  ScrollView scroller=new ScrollView(getActivity());
  HtmlTextView text=new HtmlTextView(getActivity());
  int padding=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,16,getActivity().getResources().getDisplayMetrics());
  text.setPadding(padding,padding,padding,0);
  scroller.addView(text);
  try {
    String html=new Markdown4jProcessor().process(getActivity().getResources().openRawResource(mHtmlFile));
    text.setHtmlFromString(html,new HtmlTextView.LocalImageGetter());
  }
 catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
  }
  text.setTextColor(getResources().getColor(android.R.color.black));
  return scroller;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  int mHtmlFile=getArguments().getInt(ARG_MARKDOWN_RES);
  ScrollView scroller=new ScrollView(getActivity());
  HtmlTextView text=new HtmlTextView(getActivity());
  int padding=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,16,getActivity().getResources().getDisplayMetrics());
  text.setPadding(padding,padding,padding,0);
  scroller.addView(text);
  try {
    String html=new Markdown4jProcessor().process(getActivity().getResources().openRawResource(mHtmlFile));
    text.setHtmlFromString(html,new HtmlTextView.LocalImageGetter());
  }
 catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
  }
  return scroller;
}",0.9563567362428842
8290,"private static void initializeTheme(final ListPreference mTheme){
  mTheme.setValue(sPreferences.getTheme());
  mTheme.setSummary(mTheme.getEntry());
  mTheme.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener(){
    public boolean onPreferenceChange(    Preference preference,    Object newValue){
      mTheme.setValue((String)newValue);
      mTheme.setSummary(mTheme.getEntry());
      sPreferences.setTheme((String)newValue);
      return false;
    }
  }
);
}","private static void initializeTheme(final ListPreference mTheme){
  mTheme.setValue(sPreferences.getTheme());
  mTheme.setSummary(mTheme.getEntry());
  mTheme.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener(){
    public boolean onPreferenceChange(    Preference preference,    Object newValue){
      mTheme.setValue((String)newValue);
      mTheme.setSummary(mTheme.getEntry());
      sPreferences.setTheme((String)newValue);
      ((SettingsActivity)mTheme.getContext()).recreate();
      return false;
    }
  }
);
}",0.9436893203883496
8291,"@Override protected void onResume(){
  super.onResume();
  if (mThemeChanger.changeTheme()) {
    Intent intent=getIntent();
    finish();
    startActivity(intent);
  }
}","@Override protected void onResume(){
  super.onResume();
  if (mThemeChanger.changeTheme()) {
    Intent intent=getIntent();
    finish();
    overridePendingTransition(0,0);
    startActivity(intent);
    overridePendingTransition(0,0);
  }
}",0.8260869565217391
8292,"@Override protected void onCreate(Bundle savedInstanceState){
  mThemeChanger=new ThemeChanger(this);
  mThemeChanger.changeTheme();
  super.onCreate(savedInstanceState);
  initLayout();
  initToolbar();
}","@Override protected void onCreate(Bundle savedInstanceState){
  initTheme();
  super.onCreate(savedInstanceState);
  initLayout();
  initToolbar();
}",0.8305084745762712
8293,"@Override protected void onResume(){
  super.onResume();
  if (mThemeChanger.changeTheme()) {
    Intent intent=getIntent();
    finish();
    startActivity(intent);
  }
}","@Override protected void onResume(){
  super.onResume();
  if (mThemeChanger.changeTheme()) {
    Intent intent=getIntent();
    finish();
    overridePendingTransition(0,0);
    startActivity(intent);
    overridePendingTransition(0,0);
  }
}",0.8260869565217391
8294,"public ThemeChanger(Context context){
  mContext=context;
  mPreferences=Preferences.getPreferences(mContext);
}","public ThemeChanger(Activity context){
  mContext=context;
  mPreferences=Preferences.getPreferences(mContext);
}",0.9511111111111112
8295,"/** 
 * Apply the theme set in preferences if it isn't equal to mCurrentTheme anymore or mCurrentTheme hasn't been set yet. If a new theme is applied in this method, then return true, so the caller can re-create the activity, if need be.
 */
public boolean changeTheme(){
  String newTheme=mPreferences.getTheme();
  if (mCurrentTheme != null && mCurrentTheme.equals(newTheme)) {
    return false;
  }
  int themeId=R.style.Theme_Keychain_Light;
  if (Constants.Pref.Theme.DARK.equals(newTheme)) {
    themeId=R.style.Theme_Keychain_Dark;
  }
  ContextThemeWrapper w=new ContextThemeWrapper(mContext,themeId);
  mContext.getTheme().setTo(w.getTheme());
  mCurrentTheme=newTheme;
  return true;
}","/** 
 * Apply the theme set in preferences if it isn't equal to mCurrentTheme anymore or mCurrentTheme hasn't been set yet. If a new theme is applied in this method, then return true, so the caller can re-create the activity, if need be.
 */
public boolean changeTheme(){
  String newTheme=mPreferences.getTheme();
  if (mCurrentTheme != null && mCurrentTheme.equals(newTheme)) {
    return false;
  }
  int themeId=mLightResId;
  if (Constants.Pref.Theme.DARK.equals(newTheme)) {
    themeId=mDarkResId;
  }
  ContextThemeWrapper w=new ContextThemeWrapper(mContext,themeId);
  mContext.getTheme().setTo(w.getTheme());
  mCurrentTheme=newTheme;
  return true;
}",0.9469026548672568
8296,"public Showable createNotify(final Activity activity){
  int resultType=getResult();
  String str;
  int duration;
  Style style;
  if ((resultType & OperationResult.RESULT_ERROR) == 0) {
    String untilCancelled;
    duration=Notify.LENGTH_LONG;
    style=Style.OK;
    untilCancelled=""String_Node_Str"";
    if ((resultType & ImportKeyResult.RESULT_CANCELLED) > 0) {
      duration=0;
      style=Style.WARN;
      untilCancelled+=activity.getString(R.string.with_cancelled);
    }
    if (mOk > 0 && mFail > 0) {
      style=Style.WARN;
      duration=0;
      str=activity.getResources().getQuantityString(R.plurals.delete_ok_but_fail_1,mOk,mOk);
      str+=""String_Node_Str"" + activity.getResources().getQuantityString(R.plurals.delete_ok_but_fail_2,mFail,mFail,untilCancelled);
    }
 else     if (mOk > 0) {
      str=activity.getResources().getQuantityString(R.plurals.delete_ok,mOk,mOk,untilCancelled);
    }
 else     if ((resultType & ImportKeyResult.RESULT_CANCELLED) > 0) {
      str=activity.getString(R.string.delete_cancelled);
    }
 else {
      duration=0;
      style=Style.ERROR;
      str=""String_Node_Str"";
    }
  }
 else {
    duration=0;
    style=Style.ERROR;
    if (mFail == 0) {
      str=activity.getString(R.string.delete_nothing);
    }
 else {
      str=activity.getResources().getQuantityString(R.plurals.delete_fail,mFail);
    }
  }
  return Notify.create(activity,str,duration,style,new ActionListener(){
    @Override public void onAction(){
      Intent intent=new Intent(activity,LogDisplayActivity.class);
      intent.putExtra(LogDisplayFragment.EXTRA_RESULT,DeleteResult.this);
      activity.startActivity(intent);
    }
  }
,R.string.snackbar_details);
}","public Showable createNotify(final Activity activity){
  int resultType=getResult();
  String str;
  int duration;
  Style style;
  if ((resultType & OperationResult.RESULT_ERROR) == 0) {
    String untilCancelled;
    duration=Notify.LENGTH_LONG;
    style=Style.OK;
    untilCancelled=""String_Node_Str"";
    if ((resultType & ImportKeyResult.RESULT_CANCELLED) > 0) {
      duration=0;
      style=Style.WARN;
      untilCancelled+=activity.getString(R.string.with_cancelled);
    }
    if (mOk > 0 && mFail > 0) {
      style=Style.WARN;
      duration=0;
      str=activity.getResources().getQuantityString(R.plurals.delete_ok_but_fail_1,mOk,mOk);
      str+=""String_Node_Str"" + activity.getResources().getQuantityString(R.plurals.delete_ok_but_fail_2,mFail,mFail,untilCancelled);
    }
 else     if (mOk > 0) {
      str=activity.getResources().getQuantityString(R.plurals.delete_ok,mOk,mOk,untilCancelled);
    }
 else     if ((resultType & ImportKeyResult.RESULT_CANCELLED) > 0) {
      str=activity.getString(R.string.delete_cancelled);
    }
 else {
      duration=0;
      style=Style.ERROR;
      str=""String_Node_Str"";
    }
  }
 else {
    duration=0;
    style=Style.ERROR;
    if (mLog.getLast().mType == LogType.MSG_DEL_ERROR_MULTI_SECRET) {
      str=activity.getString(R.string.secret_cannot_multiple);
    }
 else     if (mFail == 0) {
      str=activity.getString(R.string.delete_nothing);
    }
 else {
      str=activity.getResources().getQuantityString(R.plurals.delete_fail,mFail);
    }
  }
  return Notify.create(activity,str,duration,style,new ActionListener(){
    @Override public void onAction(){
      Intent intent=new Intent(activity,LogDisplayActivity.class);
      intent.putExtra(LogDisplayFragment.EXTRA_RESULT,DeleteResult.this);
      activity.startActivity(intent);
    }
  }
,R.string.snackbar_details);
}",0.9590973201692524
8297,"private CryptoOperationHelper.Callback<DeleteKeyringParcel,DeleteResult> getDeletionCallback(){
  return new CryptoOperationHelper.Callback<DeleteKeyringParcel,DeleteResult>(){
    @Override public DeleteKeyringParcel createOperationInput(){
      return new DeleteKeyringParcel(mMasterKeyIds,true);
    }
    @Override public void onCryptoOperationSuccess(    DeleteResult result){
      returnResult(result);
    }
    @Override public void onCryptoOperationCancelled(){
      setResult(RESULT_CANCELED);
      finish();
    }
    @Override public void onCryptoOperationError(    DeleteResult result){
      returnResult(result);
    }
    @Override public boolean onCryptoSetProgress(    String msg,    int progress,    int max){
      return false;
    }
  }
;
}","private CryptoOperationHelper.Callback<DeleteKeyringParcel,DeleteResult> getDeletionCallback(){
  return new CryptoOperationHelper.Callback<DeleteKeyringParcel,DeleteResult>(){
    @Override public DeleteKeyringParcel createOperationInput(){
      return new DeleteKeyringParcel(mMasterKeyIds,mHasSecret);
    }
    @Override public void onCryptoOperationSuccess(    DeleteResult result){
      returnResult(result);
    }
    @Override public void onCryptoOperationCancelled(){
      setResult(RESULT_CANCELED);
      finish();
    }
    @Override public void onCryptoOperationError(    DeleteResult result){
      returnResult(result);
    }
    @Override public boolean onCryptoSetProgress(    String msg,    int progress,    int max){
      return false;
    }
  }
;
}",0.9908972691807544
8298,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mDeleteOpHelper=new CryptoOperationHelper<>(1,DeleteKeyDialogActivity.this,getDeletionCallback(),R.string.progress_deleting);
  mRevokeOpHelper=new CryptoOperationHelper<>(2,this,getRevocationCallback(),R.string.progress_revoking_uploading);
  mMasterKeyIds=getIntent().getLongArrayExtra(EXTRA_DELETE_MASTER_KEY_IDS);
  boolean hasSecret=getIntent().getBooleanExtra(EXTRA_HAS_SECRET,false);
  if (mMasterKeyIds.length > 1 && hasSecret) {
    throw new AssertionError(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (mMasterKeyIds.length == 1 && hasSecret) {
    try {
      HashMap<String,Object> data=new ProviderHelper(this).getUnifiedData(mMasterKeyIds[0],new String[]{KeychainContract.KeyRings.USER_ID,KeychainContract.KeyRings.IS_REVOKED},new int[]{ProviderHelper.FIELD_TYPE_STRING,ProviderHelper.FIELD_TYPE_INTEGER});
      String name;
      KeyRing.UserId mainUserId=KeyRing.splitUserId((String)data.get(KeychainContract.KeyRings.USER_ID));
      if (mainUserId.name != null) {
        name=mainUserId.name;
      }
 else {
        name=getString(R.string.user_id_no_name);
      }
      if ((long)data.get(KeychainContract.KeyRings.IS_REVOKED) > 0) {
        showNormalDeleteDialog();
      }
 else {
        showRevokeDeleteDialog(name);
      }
    }
 catch (    ProviderHelper.NotFoundException e) {
      Log.e(Constants.TAG,""String_Node_Str"" + mMasterKeyIds[0],e);
      finish();
    }
  }
 else {
    showNormalDeleteDialog();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mDeleteOpHelper=new CryptoOperationHelper<>(1,DeleteKeyDialogActivity.this,getDeletionCallback(),R.string.progress_deleting);
  mRevokeOpHelper=new CryptoOperationHelper<>(2,this,getRevocationCallback(),R.string.progress_revoking_uploading);
  mMasterKeyIds=getIntent().getLongArrayExtra(EXTRA_DELETE_MASTER_KEY_IDS);
  mHasSecret=getIntent().getBooleanExtra(EXTRA_HAS_SECRET,false);
  if (mMasterKeyIds.length > 1 && mHasSecret) {
    OperationResult.OperationLog log=new OperationResult.OperationLog();
    log.add(OperationResult.LogType.MSG_DEL_ERROR_MULTI_SECRET,0);
    returnResult(new DeleteResult(OperationResult.RESULT_ERROR,log,0,mMasterKeyIds.length));
  }
  if (mMasterKeyIds.length == 1 && mHasSecret) {
    try {
      HashMap<String,Object> data=new ProviderHelper(this).getUnifiedData(mMasterKeyIds[0],new String[]{KeychainContract.KeyRings.USER_ID,KeychainContract.KeyRings.IS_REVOKED},new int[]{ProviderHelper.FIELD_TYPE_STRING,ProviderHelper.FIELD_TYPE_INTEGER});
      String name;
      KeyRing.UserId mainUserId=KeyRing.splitUserId((String)data.get(KeychainContract.KeyRings.USER_ID));
      if (mainUserId.name != null) {
        name=mainUserId.name;
      }
 else {
        name=getString(R.string.user_id_no_name);
      }
      if ((long)data.get(KeychainContract.KeyRings.IS_REVOKED) > 0) {
        showNormalDeleteDialog();
      }
 else {
        showRevokeDeleteDialog(name);
      }
    }
 catch (    ProviderHelper.NotFoundException e) {
      Log.e(Constants.TAG,""String_Node_Str"" + mMasterKeyIds[0],e);
      finish();
    }
  }
 else {
    showNormalDeleteDialog();
  }
}",0.8972707758356332
8299,"@Override public DeleteKeyringParcel createOperationInput(){
  return new DeleteKeyringParcel(mMasterKeyIds,true);
}","@Override public DeleteKeyringParcel createOperationInput(){
  return new DeleteKeyringParcel(mMasterKeyIds,mHasSecret);
}",0.9495798319327732
8300,"private void showNormalDeleteDialog(){
  DeleteKeyDialogFragment deleteKeyDialogFragment=DeleteKeyDialogFragment.newInstance(mMasterKeyIds);
  deleteKeyDialogFragment.show(getSupportFragmentManager(),""String_Node_Str"");
}","private void showNormalDeleteDialog(){
  DeleteKeyDialogFragment deleteKeyDialogFragment=DeleteKeyDialogFragment.newInstance(mMasterKeyIds,mHasSecret);
  deleteKeyDialogFragment.show(getSupportFragmentManager(),""String_Node_Str"");
}",0.9757174392935982
8301,"/** 
 * Show dialog to delete key
 * @param hasSecret must contain whether the list of masterKeyIds contains a secret key or not
 */
public void showDeleteKeyDialog(long[] masterKeyIds,boolean hasSecret){
  if (hasSecret && masterKeyIds.length > 1) {
    Notify.create(getActivity(),R.string.secret_cannot_multiple,Notify.Style.ERROR).show();
    return;
  }
  Intent intent=new Intent(getActivity(),DeleteKeyDialogActivity.class);
  intent.putExtra(DeleteKeyDialogActivity.EXTRA_DELETE_MASTER_KEY_IDS,masterKeyIds);
  intent.putExtra(DeleteKeyDialogActivity.EXTRA_HAS_SECRET,hasSecret);
  if (hasSecret) {
    intent.putExtra(DeleteKeyDialogActivity.EXTRA_KEYSERVER,Preferences.getPreferences(getActivity()).getPreferredKeyserver());
  }
  startActivityForResult(intent,REQUEST_DELETE);
}","/** 
 * Show dialog to delete key
 * @param hasSecret must contain whether the list of masterKeyIds contains a secret key or not
 */
public void showDeleteKeyDialog(long[] masterKeyIds,boolean hasSecret){
  Intent intent=new Intent(getActivity(),DeleteKeyDialogActivity.class);
  intent.putExtra(DeleteKeyDialogActivity.EXTRA_DELETE_MASTER_KEY_IDS,masterKeyIds);
  intent.putExtra(DeleteKeyDialogActivity.EXTRA_HAS_SECRET,hasSecret);
  if (hasSecret) {
    intent.putExtra(DeleteKeyDialogActivity.EXTRA_KEYSERVER,Preferences.getPreferences(getActivity()).getPreferredKeyserver());
  }
  startActivityForResult(intent,REQUEST_DELETE);
}",0.6376404494382022
8302,"private PgpEditKeyResult internal(PGPSecretKeyRing sKR,PGPSecretKey masterSecretKey,int masterKeyFlags,long masterKeyExpiry,CryptoInputParcel cryptoInput,SaveKeyringParcel saveParcel,OperationLog log,int indent){
  NfcSignOperationsBuilder nfcSignOps=new NfcSignOperationsBuilder(cryptoInput.getSignatureTime(),masterSecretKey.getKeyID(),masterSecretKey.getKeyID());
  NfcKeyToCardOperationsBuilder nfcKeyToCardOps=new NfcKeyToCardOperationsBuilder(masterSecretKey.getKeyID());
  progress(R.string.progress_modify,0);
  PGPPublicKey masterPublicKey=masterSecretKey.getPublicKey();
  PGPPrivateKey masterPrivateKey;
  if (isDivertToCard(masterSecretKey)) {
    masterPrivateKey=null;
    log.add(LogType.MSG_MF_DIVERT,indent);
  }
 else {
    progress(R.string.progress_modify_unlock,10);
    log.add(LogType.MSG_MF_UNLOCK,indent);
{
      try {
        PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
        masterPrivateKey=masterSecretKey.extractPrivateKey(keyDecryptor);
      }
 catch (      PGPException e) {
        log.add(LogType.MSG_MF_UNLOCK_ERROR,indent + 1);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
      }
    }
  }
  try {
    if (checkCancelled()) {
      log.add(LogType.MSG_OPERATION_CANCELLED,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
    }
{
      PGPPublicKey modifiedPublicKey=masterPublicKey;
      subProgressPush(15,23);
      for (int i=0; i < saveParcel.mAddUserIds.size(); i++) {
        progress(R.string.progress_modify_adduid,(i - 1) * (100 / saveParcel.mAddUserIds.size()));
        String userId=saveParcel.mAddUserIds.get(i);
        log.add(LogType.MSG_MF_UID_ADD,indent,userId);
        if (""String_Node_Str"".equals(userId)) {
          log.add(LogType.MSG_MF_UID_ERROR_EMPTY,indent + 1);
          return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
        }
        @SuppressWarnings(""String_Node_Str"") Iterator<PGPSignature> it=modifiedPublicKey.getSignaturesForID(userId);
        if (it != null) {
          for (          PGPSignature cert : new IterableIterator<>(it)) {
            if (cert.getKeyID() != masterPublicKey.getKeyID()) {
              log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
              return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
            }
            if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION || cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
              modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,cert);
            }
          }
        }
        boolean isPrimary=saveParcel.mChangePrimaryUserId != null && userId.equals(saveParcel.mChangePrimaryUserId);
        try {
          PGPSignature cert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,isPrimary,masterKeyFlags,masterKeyExpiry);
          modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
        }
 catch (        NfcInteractionNeeded e) {
          nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
        }
      }
      subProgressPop();
      subProgressPush(23,32);
      for (int i=0; i < saveParcel.mAddUserAttribute.size(); i++) {
        progress(R.string.progress_modify_adduat,(i - 1) * (100 / saveParcel.mAddUserAttribute.size()));
        WrappedUserAttribute attribute=saveParcel.mAddUserAttribute.get(i);
switch (attribute.getType()) {
case WrappedUserAttribute.UAT_NONE:
          log.add(LogType.MSG_MF_UAT_ERROR_EMPTY,indent);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
case WrappedUserAttribute.UAT_IMAGE:
      log.add(LogType.MSG_MF_UAT_ADD_IMAGE,indent);
    break;
default :
  log.add(LogType.MSG_MF_UAT_ADD_UNKNOWN,indent);
break;
}
PGPUserAttributeSubpacketVector vector=attribute.getVector();
try {
PGPSignature cert=generateUserAttributeSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,vector,masterKeyFlags,masterKeyExpiry);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,vector,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(32,40);
for (int i=0; i < saveParcel.mRevokeUserIds.size(); i++) {
progress(R.string.progress_modify_revokeuid,(i - 1) * (100 / saveParcel.mRevokeUserIds.size()));
String userId=saveParcel.mRevokeUserIds.get(i);
log.add(LogType.MSG_MF_UID_REVOKE,indent,userId);
boolean exists=false;
for (String uid : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
if (userId.equals(uid)) {
exists=true;
break;
}
}
if (!exists) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_REVOKE,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
try {
PGPSignature cert=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
if (saveParcel.mChangePrimaryUserId != null) {
progress(R.string.progress_modify_primaryuid,40);
boolean ok=false;
log.add(LogType.MSG_MF_UID_PRIMARY,indent,saveParcel.mChangePrimaryUserId);
indent+=1;
for (String userId : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
boolean isRevoked=false;
PGPSignature currentCert=null;
for (PGPSignature cert : new IterableIterator<PGPSignature>(modifiedPublicKey.getSignaturesForID(userId))) {
if (cert.getKeyID() != masterPublicKey.getKeyID()) {
  log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION) {
  isRevoked=true;
  continue;
}
if (cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
  currentCert=cert;
}
}
if (currentCert == null) {
log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (isRevoked) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  log.add(LogType.MSG_MF_ERROR_REVOKED_PRIMARY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
continue;
}
if (currentCert.getHashedSubPackets() != null && currentCert.getHashedSubPackets().isPrimaryUserID()) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  ok=true;
  continue;
}
log.add(LogType.MSG_MF_PRIMARY_REPLACE_OLD,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,false,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
continue;
}
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
log.add(LogType.MSG_MF_PRIMARY_NEW,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,true,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
ok=true;
}
}
indent-=1;
if (!ok) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_PRIMARY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
}
if (modifiedPublicKey != masterPublicKey) {
masterSecretKey=PGPSecretKey.replacePublicKey(masterSecretKey,modifiedPublicKey);
masterPublicKey=modifiedPublicKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
}
}
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
subProgressPush(50,60);
for (int i=0; i < saveParcel.mChangeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeychange,(i - 1) * (100 / saveParcel.mChangeSubKeys.size()));
SaveKeyringParcel.SubkeyChange change=saveParcel.mChangeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_CHANGE,indent,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
PGPSecretKey sKey=sKR.getSecretKey(change.mKeyId);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mDummyStrip) {
sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey());
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
 else if (change.mMoveKeyToCard) {
if (checkSmartCardCompatibility(sKey,log,indent + 1)) {
log.add(LogType.MSG_MF_KEYTOCARD_START,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
nfcKeyToCardOps.addSubkey(change.mKeyId);
}
 else {
return new PgpEditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
}
}
 else if (change.mDummyDivert != null) {
if (change.mDummyDivert.length != 16) {
log.add(LogType.MSG_MF_ERROR_DIVERT_SERIAL,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
log.add(LogType.MSG_MF_KEYTOCARD_FINISH,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId),Hex.toHexString(change.mDummyDivert,8,6));
sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey(),change.mDummyDivert);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
if (!change.mRecertify && (change.mExpiry == null && change.mFlags == null)) {
continue;
}
if (change.mExpiry != null && change.mExpiry != 0 && new Date(change.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mKeyId == masterPublicKey.getKeyID()) {
int flags=change.mFlags == null ? masterKeyFlags : change.mFlags;
long expiry=change.mExpiry == null ? masterKeyExpiry : change.mExpiry;
if ((flags & KeyFlags.CERTIFY_OTHER) != KeyFlags.CERTIFY_OTHER) {
log.add(LogType.MSG_MF_ERROR_NO_CERTIFY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=updateMasterCertificates(masterSecretKey,masterPrivateKey,masterPublicKey,flags,expiry,cryptoInput,nfcSignOps,indent,log);
if (pKey == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
masterSecretKey=PGPSecretKey.replacePublicKey(sKey,pKey);
masterPublicKey=pKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
continue;
}
PGPPublicKey pKey=sKey.getPublicKey();
int flags=change.mFlags == null ? readKeyFlags(pKey) : change.mFlags;
long expiry;
if (change.mExpiry == null) {
long valid=pKey.getValidSeconds();
expiry=valid == 0 ? 0 : pKey.getCreationTime().getTime() / 1000 + pKey.getValidSeconds();
}
 else {
expiry=change.mExpiry;
}
for (PGPSignature sig : new IterableIterator<PGPSignature>(pKey.getSignatures())) {
if ((change.mExpiry == null || change.mExpiry == 0L) && sig.getSignatureType() == PGPSignature.SUBKEY_REVOCATION) {
expiry=0;
}
pKey=PGPPublicKey.removeCertification(pKey,sig);
}
PGPPrivateKey subPrivateKey;
if (!isDivertToCard(sKey)) {
PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
subPrivateKey=sKey.extractPrivateKey(keyDecryptor);
if (subPrivateKey == null) {
log.add(LogType.MSG_MF_ERROR_SUB_STRIPPED,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
}
 else {
subPrivateKey=null;
}
try {
PGPSignature sig=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,getSignatureGenerator(sKey,cryptoInput),subPrivateKey,pKey,flags,expiry);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(60,65);
for (int i=0; i < saveParcel.mRevokeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeyrevoke,(i - 1) * (100 / saveParcel.mRevokeSubKeys.size()));
long revocation=saveParcel.mRevokeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_REVOKE,indent,KeyFormattingUtils.convertKeyIdToHex(revocation));
PGPSecretKey sKey=sKR.getSecretKey(revocation);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(revocation));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=sKey.getPublicKey();
try {
PGPSignature sig=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,pKey);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(70,90);
for (int i=0; i < saveParcel.mAddSubKeys.size(); i++) {
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
progress(R.string.progress_modify_subkeyadd,(i - 1) * (100 / saveParcel.mAddSubKeys.size()));
SaveKeyringParcel.SubkeyAdd add=saveParcel.mAddSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_NEW,indent,KeyFormattingUtils.getAlgorithmInfo(add.mAlgorithm,add.mKeySize,add.mCurve));
if (isDivertToCard(masterSecretKey)) {
log.add(LogType.MSG_MF_ERROR_DIVERT_NEWSUB,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
if (add.mExpiry == null) {
log.add(LogType.MSG_MF_ERROR_NULL_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (add.mExpiry > 0L && new Date(add.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
subProgressPush((i - 1) * (100 / saveParcel.mAddSubKeys.size()),i * (100 / saveParcel.mAddSubKeys.size()));
PGPKeyPair keyPair=createKey(add,cryptoInput.getSignatureTime(),log,indent);
subProgressPop();
if (keyPair == null) {
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=keyPair.getPublicKey();
try {
PGPSignature cert=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,getSignatureGenerator(pKey,cryptoInput,false),keyPair.getPrivateKey(),pKey,add.mFlags,add.mExpiry);
pKey=PGPPublicKey.addSubkeyBindingCertification(pKey,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
PGPSecretKey sKey;
{
PGPDigestCalculator encryptorHashCalc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_ENCRYPTOR_HASH_ALGO);
PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PgpConstants.SECRET_KEY_ENCRYPTOR_SYMMETRIC_ALGO,encryptorHashCalc,PgpConstants.SECRET_KEY_ENCRYPTOR_S2K_COUNT).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_SIGNATURE_CHECKSUM_HASH_ALGO);
sKey=new PGPSecretKey(keyPair.getPrivateKey(),pKey,sha1Calc,false,keyEncryptor);
}
log.add(LogType.MSG_MF_SUBKEY_NEW_ID,indent + 1,KeyFormattingUtils.convertKeyIdToHex(sKey.getKeyID()));
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
subProgressPop();
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
if (saveParcel.mNewUnlock != null) {
progress(R.string.progress_modify_passphrase,90);
log.add(LogType.MSG_MF_PASSPHRASE,indent);
indent+=1;
sKR=applyNewUnlock(sKR,masterPublicKey,masterPrivateKey,cryptoInput.getPassphrase(),saveParcel.mNewUnlock,log,indent);
if (sKR == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
indent-=1;
}
if (saveParcel.mCardPin != null) {
progress(R.string.progress_modify_pin,90);
log.add(LogType.MSG_MF_PIN,indent);
indent+=1;
nfcKeyToCardOps.setPin(saveParcel.mCardPin);
indent-=1;
}
if (saveParcel.mCardAdminPin != null) {
progress(R.string.progress_modify_admin_pin,90);
log.add(LogType.MSG_MF_ADMIN_PIN,indent);
indent+=1;
nfcKeyToCardOps.setAdminPin(saveParcel.mCardAdminPin);
indent-=1;
}
}
 catch (IOException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_ENCODE,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (PGPException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (SignatureException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_SIG,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
progress(R.string.progress_done,100);
if (!nfcSignOps.isEmpty() && !nfcKeyToCardOps.isEmpty()) {
log.add(LogType.MSG_MF_ERROR_CONFLICTING_NFC_COMMANDS,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (!nfcSignOps.isEmpty()) {
log.add(LogType.MSG_MF_REQUIRE_DIVERT,indent);
return new PgpEditKeyResult(log,nfcSignOps.build());
}
if (!nfcKeyToCardOps.isEmpty()) {
log.add(LogType.MSG_MF_REQUIRE_DIVERT,indent);
return new PgpEditKeyResult(log,nfcKeyToCardOps.build());
}
log.add(LogType.MSG_MF_SUCCESS,indent);
return new PgpEditKeyResult(OperationResult.RESULT_OK,log,new UncachedKeyRing(sKR));
}","private PgpEditKeyResult internal(PGPSecretKeyRing sKR,PGPSecretKey masterSecretKey,int masterKeyFlags,long masterKeyExpiry,CryptoInputParcel cryptoInput,SaveKeyringParcel saveParcel,OperationLog log,int indent){
  NfcSignOperationsBuilder nfcSignOps=new NfcSignOperationsBuilder(cryptoInput.getSignatureTime(),masterSecretKey.getKeyID(),masterSecretKey.getKeyID());
  NfcKeyToCardOperationsBuilder nfcKeyToCardOps=new NfcKeyToCardOperationsBuilder(masterSecretKey.getKeyID());
  progress(R.string.progress_modify,0);
  PGPPublicKey masterPublicKey=masterSecretKey.getPublicKey();
  PGPPrivateKey masterPrivateKey;
  if (isDivertToCard(masterSecretKey)) {
    masterPrivateKey=null;
    log.add(LogType.MSG_MF_DIVERT,indent);
  }
 else {
    progress(R.string.progress_modify_unlock,10);
    log.add(LogType.MSG_MF_UNLOCK,indent);
{
      try {
        PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
        masterPrivateKey=masterSecretKey.extractPrivateKey(keyDecryptor);
      }
 catch (      PGPException e) {
        log.add(LogType.MSG_MF_UNLOCK_ERROR,indent + 1);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
      }
    }
  }
  try {
    if (checkCancelled()) {
      log.add(LogType.MSG_OPERATION_CANCELLED,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
    }
{
      PGPPublicKey modifiedPublicKey=masterPublicKey;
      subProgressPush(15,23);
      for (int i=0; i < saveParcel.mAddUserIds.size(); i++) {
        progress(R.string.progress_modify_adduid,(i - 1) * (100 / saveParcel.mAddUserIds.size()));
        String userId=saveParcel.mAddUserIds.get(i);
        log.add(LogType.MSG_MF_UID_ADD,indent,userId);
        if (""String_Node_Str"".equals(userId)) {
          log.add(LogType.MSG_MF_UID_ERROR_EMPTY,indent + 1);
          return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
        }
        @SuppressWarnings(""String_Node_Str"") Iterator<PGPSignature> it=modifiedPublicKey.getSignaturesForID(userId);
        if (it != null) {
          for (          PGPSignature cert : new IterableIterator<>(it)) {
            if (cert.getKeyID() != masterPublicKey.getKeyID()) {
              log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
              return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
            }
            if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION || cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
              modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,cert);
            }
          }
        }
        boolean isPrimary=saveParcel.mChangePrimaryUserId != null && userId.equals(saveParcel.mChangePrimaryUserId);
        try {
          PGPSignature cert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,isPrimary,masterKeyFlags,masterKeyExpiry);
          modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
        }
 catch (        NfcInteractionNeeded e) {
          nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
        }
      }
      subProgressPop();
      subProgressPush(23,32);
      for (int i=0; i < saveParcel.mAddUserAttribute.size(); i++) {
        progress(R.string.progress_modify_adduat,(i - 1) * (100 / saveParcel.mAddUserAttribute.size()));
        WrappedUserAttribute attribute=saveParcel.mAddUserAttribute.get(i);
switch (attribute.getType()) {
case WrappedUserAttribute.UAT_NONE:
          log.add(LogType.MSG_MF_UAT_ERROR_EMPTY,indent);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
case WrappedUserAttribute.UAT_IMAGE:
      log.add(LogType.MSG_MF_UAT_ADD_IMAGE,indent);
    break;
default :
  log.add(LogType.MSG_MF_UAT_ADD_UNKNOWN,indent);
break;
}
PGPUserAttributeSubpacketVector vector=attribute.getVector();
try {
PGPSignature cert=generateUserAttributeSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,vector,masterKeyFlags,masterKeyExpiry);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,vector,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(32,40);
for (int i=0; i < saveParcel.mRevokeUserIds.size(); i++) {
progress(R.string.progress_modify_revokeuid,(i - 1) * (100 / saveParcel.mRevokeUserIds.size()));
String userId=saveParcel.mRevokeUserIds.get(i);
log.add(LogType.MSG_MF_UID_REVOKE,indent,userId);
boolean exists=false;
for (String uid : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
if (userId.equals(uid)) {
exists=true;
break;
}
}
if (!exists) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_REVOKE,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
try {
PGPSignature cert=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
if (saveParcel.mChangePrimaryUserId != null) {
progress(R.string.progress_modify_primaryuid,40);
boolean ok=false;
log.add(LogType.MSG_MF_UID_PRIMARY,indent,saveParcel.mChangePrimaryUserId);
indent+=1;
for (String userId : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
boolean isRevoked=false;
PGPSignature currentCert=null;
for (PGPSignature cert : new IterableIterator<PGPSignature>(modifiedPublicKey.getSignaturesForID(userId))) {
if (cert.getKeyID() != masterPublicKey.getKeyID()) {
  log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION) {
  isRevoked=true;
  continue;
}
if (cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
  currentCert=cert;
}
}
if (currentCert == null) {
log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (isRevoked) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  log.add(LogType.MSG_MF_ERROR_REVOKED_PRIMARY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
continue;
}
if (currentCert.getHashedSubPackets() != null && currentCert.getHashedSubPackets().isPrimaryUserID()) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  ok=true;
  continue;
}
log.add(LogType.MSG_MF_PRIMARY_REPLACE_OLD,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,false,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
continue;
}
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
log.add(LogType.MSG_MF_PRIMARY_NEW,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,true,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
ok=true;
}
}
indent-=1;
if (!ok) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_PRIMARY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
}
if (modifiedPublicKey != masterPublicKey) {
masterSecretKey=PGPSecretKey.replacePublicKey(masterSecretKey,modifiedPublicKey);
masterPublicKey=modifiedPublicKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
}
}
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
subProgressPush(50,60);
for (int i=0; i < saveParcel.mChangeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeychange,(i - 1) * (100 / saveParcel.mChangeSubKeys.size()));
SaveKeyringParcel.SubkeyChange change=saveParcel.mChangeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_CHANGE,indent,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
PGPSecretKey sKey=sKR.getSecretKey(change.mKeyId);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mDummyStrip) {
sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey());
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
 else if (change.mMoveKeyToCard) {
if (checkSmartCardCompatibility(sKey,log,indent + 1)) {
log.add(LogType.MSG_MF_KEYTOCARD_START,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
nfcKeyToCardOps.addSubkey(change.mKeyId);
}
 else {
return new PgpEditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
}
}
 else if (change.mDummyDivert != null) {
if (change.mDummyDivert.length != 16) {
log.add(LogType.MSG_MF_ERROR_DIVERT_SERIAL,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
log.add(LogType.MSG_MF_KEYTOCARD_FINISH,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId),Hex.toHexString(change.mDummyDivert,8,6));
sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey(),change.mDummyDivert);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
if (!change.mRecertify && (change.mExpiry == null && change.mFlags == null)) {
continue;
}
if (change.mExpiry != null && change.mExpiry != 0 && new Date(change.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mKeyId == masterPublicKey.getKeyID()) {
int flags=change.mFlags == null ? masterKeyFlags : change.mFlags;
long expiry=change.mExpiry == null ? masterKeyExpiry : change.mExpiry;
if ((flags & KeyFlags.CERTIFY_OTHER) != KeyFlags.CERTIFY_OTHER) {
log.add(LogType.MSG_MF_ERROR_NO_CERTIFY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=updateMasterCertificates(masterSecretKey,masterPrivateKey,masterPublicKey,flags,expiry,cryptoInput,nfcSignOps,indent,log);
if (pKey == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
masterSecretKey=PGPSecretKey.replacePublicKey(sKey,pKey);
masterPublicKey=pKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
continue;
}
PGPPublicKey pKey=sKey.getPublicKey();
int flags=change.mFlags == null ? readKeyFlags(pKey) : change.mFlags;
long expiry;
if (change.mExpiry == null) {
long valid=pKey.getValidSeconds();
expiry=valid == 0 ? 0 : pKey.getCreationTime().getTime() / 1000 + pKey.getValidSeconds();
}
 else {
expiry=change.mExpiry;
}
for (PGPSignature sig : new IterableIterator<PGPSignature>(pKey.getSignatures())) {
if ((change.mExpiry == null || change.mExpiry == 0L) && sig.getSignatureType() == PGPSignature.SUBKEY_REVOCATION) {
expiry=0;
}
pKey=PGPPublicKey.removeCertification(pKey,sig);
}
PGPPrivateKey subPrivateKey;
if (!isDivertToCard(sKey)) {
PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
subPrivateKey=sKey.extractPrivateKey(keyDecryptor);
if (subPrivateKey == null) {
log.add(LogType.MSG_MF_ERROR_SUB_STRIPPED,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
}
 else {
subPrivateKey=null;
}
try {
PGPSignature sig=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,getSignatureGenerator(sKey,cryptoInput),subPrivateKey,pKey,flags,expiry);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(60,65);
for (int i=0; i < saveParcel.mRevokeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeyrevoke,(i - 1) * (100 / saveParcel.mRevokeSubKeys.size()));
long revocation=saveParcel.mRevokeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_REVOKE,indent,KeyFormattingUtils.convertKeyIdToHex(revocation));
PGPSecretKey sKey=sKR.getSecretKey(revocation);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(revocation));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=sKey.getPublicKey();
try {
PGPSignature sig=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,pKey);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(70,90);
for (int i=0; i < saveParcel.mAddSubKeys.size(); i++) {
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
progress(R.string.progress_modify_subkeyadd,(i - 1) * (100 / saveParcel.mAddSubKeys.size()));
SaveKeyringParcel.SubkeyAdd add=saveParcel.mAddSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_NEW,indent,KeyFormattingUtils.getAlgorithmInfo(add.mAlgorithm,add.mKeySize,add.mCurve));
if (isDivertToCard(masterSecretKey)) {
log.add(LogType.MSG_MF_ERROR_DIVERT_NEWSUB,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (add.mExpiry == null) {
log.add(LogType.MSG_MF_ERROR_NULL_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (add.mExpiry > 0L && new Date(add.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
subProgressPush((i - 1) * (100 / saveParcel.mAddSubKeys.size()),i * (100 / saveParcel.mAddSubKeys.size()));
PGPKeyPair keyPair=createKey(add,cryptoInput.getSignatureTime(),log,indent);
subProgressPop();
if (keyPair == null) {
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=keyPair.getPublicKey();
try {
PGPSignature cert=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,getSignatureGenerator(pKey,cryptoInput,false),keyPair.getPrivateKey(),pKey,add.mFlags,add.mExpiry);
pKey=PGPPublicKey.addSubkeyBindingCertification(pKey,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
PGPSecretKey sKey;
{
PGPDigestCalculator encryptorHashCalc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_ENCRYPTOR_HASH_ALGO);
PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PgpConstants.SECRET_KEY_ENCRYPTOR_SYMMETRIC_ALGO,encryptorHashCalc,PgpConstants.SECRET_KEY_ENCRYPTOR_S2K_COUNT).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_SIGNATURE_CHECKSUM_HASH_ALGO);
sKey=new PGPSecretKey(keyPair.getPrivateKey(),pKey,sha1Calc,false,keyEncryptor);
}
log.add(LogType.MSG_MF_SUBKEY_NEW_ID,indent + 1,KeyFormattingUtils.convertKeyIdToHex(sKey.getKeyID()));
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
subProgressPop();
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
if (saveParcel.mNewUnlock != null) {
progress(R.string.progress_modify_passphrase,90);
log.add(LogType.MSG_MF_PASSPHRASE,indent);
indent+=1;
sKR=applyNewUnlock(sKR,masterPublicKey,masterPrivateKey,cryptoInput.getPassphrase(),saveParcel.mNewUnlock,log,indent);
if (sKR == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
indent-=1;
}
if (saveParcel.mCardPin != null) {
progress(R.string.progress_modify_pin,90);
log.add(LogType.MSG_MF_PIN,indent);
indent+=1;
nfcKeyToCardOps.setPin(saveParcel.mCardPin);
indent-=1;
}
if (saveParcel.mCardAdminPin != null) {
progress(R.string.progress_modify_admin_pin,90);
log.add(LogType.MSG_MF_ADMIN_PIN,indent);
indent+=1;
nfcKeyToCardOps.setAdminPin(saveParcel.mCardAdminPin);
indent-=1;
}
}
 catch (IOException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_ENCODE,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (PGPException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (SignatureException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_SIG,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
progress(R.string.progress_done,100);
if (!nfcSignOps.isEmpty() && !nfcKeyToCardOps.isEmpty()) {
log.add(LogType.MSG_MF_ERROR_CONFLICTING_NFC_COMMANDS,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (!nfcSignOps.isEmpty()) {
log.add(LogType.MSG_MF_REQUIRE_DIVERT,indent);
return new PgpEditKeyResult(log,nfcSignOps.build());
}
if (!nfcKeyToCardOps.isEmpty()) {
log.add(LogType.MSG_MF_REQUIRE_DIVERT,indent);
return new PgpEditKeyResult(log,nfcKeyToCardOps.build());
}
log.add(LogType.MSG_MF_SUCCESS,indent);
return new PgpEditKeyResult(OperationResult.RESULT_OK,log,new UncachedKeyRing(sKR));
}",0.9996285683964768
8303,"/** 
 * This method tries to import data from a provided database. The sole assumptions made on this db are that there is a key_rings table with a key_ring_data, a master_key_id and a type column, the latter of which should be 1 for secret keys and 0 for public keys.
 */
public void checkAndImportApg(Context context){
  boolean hasApgDb=false;
{
    String[] dbs=context.databaseList();
    for (    String db : dbs) {
      if (db.equals(""String_Node_Str"")) {
        hasApgDb=true;
      }
 else       if (db.equals(""String_Node_Str"")) {
        Log.d(Constants.TAG,""String_Node_Str"");
        context.getDatabasePath(""String_Node_Str"").delete();
      }
    }
  }
  if (!hasApgDb) {
    return;
  }
  Log.d(Constants.TAG,""String_Node_Str"");
  SQLiteDatabase db=new SQLiteOpenHelper(context,""String_Node_Str"",null,1){
    @Override public void onCreate(    SQLiteDatabase db){
      throw new AssertionError();
    }
    @Override public void onDowngrade(    SQLiteDatabase db,    int old,    int nu){
    }
    @Override public void onUpgrade(    SQLiteDatabase db,    int old,    int nu){
    }
  }
.getReadableDatabase();
  Cursor cursor=null;
  ProviderHelper providerHelper=new ProviderHelper(context);
  try {
    cursor=db.rawQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",null);
    if (cursor != null) {
      Log.d(Constants.TAG,""String_Node_Str"" + cursor.getCount() + ""String_Node_Str"");
      for (int i=0; i < cursor.getCount(); i++) {
        cursor.moveToPosition(i);
        byte[] data=cursor.getBlob(0);
        try {
          UncachedKeyRing ring=UncachedKeyRing.decodeFromData(data);
          providerHelper.savePublicKeyRing(ring);
        }
 catch (        PgpGeneralException e) {
          Log.e(Constants.TAG,""String_Node_Str"");
        }
      }
    }
    if (cursor != null) {
      cursor.close();
    }
    cursor=db.rawQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",null);
    if (cursor != null) {
      Log.d(Constants.TAG,""String_Node_Str"" + cursor.getCount() + ""String_Node_Str"");
      for (int i=0; i < cursor.getCount(); i++) {
        cursor.moveToPosition(i);
        byte[] data=cursor.getBlob(0);
        try {
          UncachedKeyRing ring=UncachedKeyRing.decodeFromData(data);
          providerHelper.savePublicKeyRing(ring);
        }
 catch (        PgpGeneralException e) {
          Log.e(Constants.TAG,""String_Node_Str"");
        }
      }
    }
  }
 catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
  }
 finally {
    if (cursor != null) {
      cursor.close();
    }
    if (db != null) {
      db.close();
    }
  }
  context.getDatabasePath(""String_Node_Str"").delete();
}","/** 
 * This method tries to import data from a provided database. The sole assumptions made on this db are that there is a key_rings table with a key_ring_data, a master_key_id and a type column, the latter of which should be 1 for secret keys and 0 for public keys.
 */
public void checkAndImportApg(Context context){
  boolean hasApgDb=false;
{
    String[] dbs=context.databaseList();
    for (    String db : dbs) {
      if (""String_Node_Str"".equals(db)) {
        hasApgDb=true;
      }
 else       if (""String_Node_Str"".equals(db)) {
        Log.d(Constants.TAG,""String_Node_Str"");
        context.getDatabasePath(""String_Node_Str"").delete();
      }
    }
  }
  if (!hasApgDb) {
    return;
  }
  Log.d(Constants.TAG,""String_Node_Str"");
  SQLiteDatabase db=new SQLiteOpenHelper(context,""String_Node_Str"",null,1){
    @Override public void onCreate(    SQLiteDatabase db){
      throw new AssertionError();
    }
    @Override public void onDowngrade(    SQLiteDatabase db,    int old,    int nu){
    }
    @Override public void onUpgrade(    SQLiteDatabase db,    int old,    int nu){
    }
  }
.getReadableDatabase();
  Cursor cursor=null;
  ProviderHelper providerHelper=new ProviderHelper(context);
  try {
    cursor=db.rawQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",null);
    if (cursor != null) {
      Log.d(Constants.TAG,""String_Node_Str"" + cursor.getCount() + ""String_Node_Str"");
      for (int i=0; i < cursor.getCount(); i++) {
        cursor.moveToPosition(i);
        byte[] data=cursor.getBlob(0);
        try {
          UncachedKeyRing ring=UncachedKeyRing.decodeFromData(data);
          providerHelper.savePublicKeyRing(ring);
        }
 catch (        PgpGeneralException e) {
          Log.e(Constants.TAG,""String_Node_Str"");
        }
      }
    }
    if (cursor != null) {
      cursor.close();
    }
    cursor=db.rawQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",null);
    if (cursor != null) {
      Log.d(Constants.TAG,""String_Node_Str"" + cursor.getCount() + ""String_Node_Str"");
      for (int i=0; i < cursor.getCount(); i++) {
        cursor.moveToPosition(i);
        byte[] data=cursor.getBlob(0);
        try {
          UncachedKeyRing ring=UncachedKeyRing.decodeFromData(data);
          providerHelper.savePublicKeyRing(ring);
        }
 catch (        PgpGeneralException e) {
          Log.e(Constants.TAG,""String_Node_Str"");
        }
      }
    }
  }
 catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
  }
 finally {
    if (cursor != null) {
      cursor.close();
    }
    if (db != null) {
      db.close();
    }
  }
  context.getDatabasePath(""String_Node_Str"").delete();
}",0.972842261904762
8304,"private void decryptFromClipboard(){
  Activity activity=getActivity();
  if (activity == null) {
    return;
  }
  final CharSequence clipboardText=ClipboardReflection.getClipboardText(activity);
  if (clipboardText == null) {
    Notify.create(activity,R.string.error_clipboard_empty,Style.ERROR);
  }
  Intent clipboardDecrypt=new Intent(getActivity(),DecryptActivity.class);
  clipboardDecrypt.setAction(DecryptActivity.ACTION_DECRYPT_FROM_CLIPBOARD);
  startActivityForResult(clipboardDecrypt,0);
}","private void decryptFromClipboard(){
  Activity activity=getActivity();
  if (activity == null) {
    return;
  }
  final CharSequence clipboardText=ClipboardReflection.getClipboardText(activity);
  if (clipboardText == null || TextUtils.isEmpty(clipboardText)) {
    Notify.create(activity,R.string.error_clipboard_empty,Style.ERROR).show();
    return;
  }
  Intent clipboardDecrypt=new Intent(getActivity(),DecryptActivity.class);
  clipboardDecrypt.setAction(DecryptActivity.ACTION_DECRYPT_FROM_CLIPBOARD);
  startActivityForResult(clipboardDecrypt,0);
}",0.9481621112158342
8305,"public boolean containsSubkey(String expectedFingerprint){
  Iterator<PGPPublicKey> it=mRing.getPublicKeys();
  while (it.hasNext()) {
    if (KeyFormattingUtils.convertFingerprintToHex(it.next().getFingerprint()).equals(expectedFingerprint)) {
      return true;
    }
  }
  return false;
}","public boolean containsSubkey(String expectedFingerprint){
  Iterator<PGPPublicKey> it=mRing.getPublicKeys();
  while (it.hasNext()) {
    if (KeyFormattingUtils.convertFingerprintToHex(it.next().getFingerprint()).equalsIgnoreCase(expectedFingerprint)) {
      return true;
    }
  }
  return false;
}",0.983108108108108
8306,"public void handleNfcError(CardException e){
  Log.e(Constants.TAG,""String_Node_Str"",e);
  short status=e.getResponseCode();
  if ((status & (short)0xFFF0) == 0x63C0) {
    Notify.create(this,getString(R.string.error_pin,status & 0x000F),Style.WARN).show();
    return;
  }
switch (status) {
case 0x6A80:
    throw new AssertionError(""String_Node_Str"");
case 0x6883:
  throw new AssertionError(""String_Node_Str"");
case 0x6B00:
throw new AssertionError(""String_Node_Str"");
case 0x6D00:
throw new AssertionError(""String_Node_Str"");
case 0x6E00:
throw new AssertionError(""String_Node_Str"");
case 0x6285:
{
Notify.create(this,getString(R.string.error_nfc,getString(R.string.error_nfc_terminated)),Style.WARN).show();
break;
}
case 0x6700:
{
Notify.create(this,getString(R.string.error_nfc,getString(R.string.error_nfc_wrong_length)),Style.WARN).show();
break;
}
case 0x6982:
{
Notify.create(this,getString(R.string.error_nfc,getString(R.string.error_nfc_security_not_satisfied)),Style.WARN).show();
break;
}
case 0x6983:
{
Notify.create(this,getString(R.string.error_nfc,getString(R.string.error_nfc_authentication_blocked)),Style.WARN).show();
break;
}
case 0x6985:
{
Notify.create(this,getString(R.string.error_nfc,getString(R.string.error_nfc_conditions_not_satisfied)),Style.WARN).show();
break;
}
case 0x6A88:
case 0x6A83:
{
Notify.create(this,getString(R.string.error_nfc,getString(R.string.error_nfc_data_not_found)),Style.WARN).show();
break;
}
case 0x6F00:
{
Notify.create(this,getString(R.string.error_nfc,getString(R.string.error_nfc_unknown)),Style.WARN).show();
break;
}
default :
Notify.create(this,getString(R.string.error_nfc,e.getMessage()),Style.WARN).show();
}
}","public void handleNfcError(CardException e){
  Log.e(Constants.TAG,""String_Node_Str"",e);
  short status=e.getResponseCode();
  if ((status & (short)0xFFF0) == 0x63C0) {
    Notify.create(this,getString(R.string.error_pin,status & 0x000F),Style.WARN).show();
    return;
  }
switch (status) {
case 0x6A80:
{
      Notify.create(this,getString(R.string.error_nfc_bad_data),Style.WARN).show();
      break;
    }
case 0x6883:
{
    Notify.create(this,getString(R.string.error_nfc_chaining_error),Style.WARN).show();
    break;
  }
case 0x6B00:
{
  Notify.create(this,getString(R.string.error_nfc_header,""String_Node_Str""),Style.WARN).show();
  break;
}
case 0x6D00:
{
Notify.create(this,getString(R.string.error_nfc_header,""String_Node_Str""),Style.WARN).show();
break;
}
case 0x6E00:
{
Notify.create(this,getString(R.string.error_nfc_header,""String_Node_Str""),Style.WARN).show();
break;
}
case 0x6285:
{
Notify.create(this,getString(R.string.error_nfc_terminated),Style.WARN).show();
break;
}
case 0x6700:
{
Notify.create(this,getString(R.string.error_nfc_wrong_length),Style.WARN).show();
break;
}
case 0x6982:
{
Notify.create(this,getString(R.string.error_nfc_security_not_satisfied),Style.WARN).show();
break;
}
case 0x6983:
{
Notify.create(this,getString(R.string.error_nfc_authentication_blocked),Style.WARN).show();
break;
}
case 0x6985:
{
Notify.create(this,getString(R.string.error_nfc_conditions_not_satisfied),Style.WARN).show();
break;
}
case 0x6A88:
case 0x6A83:
{
Notify.create(this,getString(R.string.error_nfc_data_not_found),Style.WARN).show();
break;
}
case 0x6F00:
{
Notify.create(this,getString(R.string.error_nfc_unknown),Style.WARN).show();
break;
}
default :
Notify.create(this,getString(R.string.error_nfc,e.getMessage()),Style.WARN).show();
}
}",0.7123765252760024
8307,"protected void onCryptoOperationError(S result){
  result.createNotify(getActivity()).show(this);
}","protected void onCryptoOperationError(S result){
  result.createNotify(getActivity()).show();
}",0.979381443298969
8308,"private Intent decryptAndVerifyImpl(Intent data,ParcelFileDescriptor inputDescriptor,ParcelFileDescriptor output,boolean decryptMetadataOnly){
  InputStream inputStream=null;
  OutputStream outputStream=null;
  try {
    inputStream=new ParcelFileDescriptor.AutoCloseInputStream(inputDescriptor);
    if (decryptMetadataOnly || output == null) {
      outputStream=null;
    }
 else {
      outputStream=new ParcelFileDescriptor.AutoCloseOutputStream(output);
    }
    String currentPkg=getCurrentCallingPackage();
    HashSet<Long> allowedKeyIds=mProviderHelper.getAllowedKeyIdsForApp(KeychainContract.ApiAllowedKeys.buildBaseUri(currentPkg));
    if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) < 7) {
      allowedKeyIds.addAll(mProviderHelper.getAllKeyIdsForApp(ApiAccounts.buildBaseUri(currentPkg)));
    }
    CryptoInputParcel cryptoInput=CryptoInputParcelCacheService.getCryptoInputParcel(this,data);
    if (cryptoInput == null) {
      cryptoInput=new CryptoInputParcel();
    }
    if (data.hasExtra(OpenPgpApi.EXTRA_PASSPHRASE)) {
      cryptoInput=new CryptoInputParcel(cryptoInput.getSignatureTime(),new Passphrase(data.getCharArrayExtra(OpenPgpApi.EXTRA_PASSPHRASE)));
    }
    byte[] detachedSignature=data.getByteArrayExtra(OpenPgpApi.EXTRA_DETACHED_SIGNATURE);
    PgpDecryptVerify op=new PgpDecryptVerify(this,mProviderHelper,null);
    long inputLength=inputStream.available();
    PgpDecryptVerifyInputParcel input=new PgpDecryptVerifyInputParcel().setAllowSymmetricDecryption(false).setAllowedKeyIds(allowedKeyIds).setDecryptMetadataOnly(decryptMetadataOnly).setDetachedSignature(detachedSignature);
    DecryptVerifyResult pgpResult=op.execute(input,cryptoInput,inputStream,outputStream);
    if (pgpResult.isPending()) {
      RequiredInputParcel requiredInput=pgpResult.getRequiredInputParcel();
      PendingIntent pIntent=getRequiredInputPendingIntent(getBaseContext(),data,requiredInput);
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_INTENT,pIntent);
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      return result;
    }
 else     if (pgpResult.success()) {
      Intent result=new Intent();
      OpenPgpSignatureResult signatureResult=pgpResult.getSignatureResult();
      int resultType=OpenPgpApi.RESULT_TYPE_UNENCRYPTED_UNSIGNED;
      if (signatureResult != null) {
        resultType|=OpenPgpApi.RESULT_TYPE_SIGNED;
        if (!signatureResult.isSignatureOnly()) {
          resultType|=OpenPgpApi.RESULT_TYPE_ENCRYPTED;
        }
        result.putExtra(OpenPgpApi.RESULT_SIGNATURE,signatureResult);
        if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) < 5) {
          if (signatureResult.getStatus() == OpenPgpSignatureResult.SIGNATURE_KEY_REVOKED || signatureResult.getStatus() == OpenPgpSignatureResult.SIGNATURE_KEY_EXPIRED) {
            signatureResult.setStatus(OpenPgpSignatureResult.SIGNATURE_ERROR);
          }
        }
        if (signatureResult.getStatus() == OpenPgpSignatureResult.SIGNATURE_KEY_MISSING) {
          result.putExtra(OpenPgpApi.RESULT_INTENT,getKeyserverPendingIntent(data,signatureResult.getKeyId()));
        }
 else {
          result.putExtra(OpenPgpApi.RESULT_INTENT,getShowKeyPendingIntent(signatureResult.getKeyId()));
        }
      }
 else {
        resultType|=OpenPgpApi.RESULT_TYPE_ENCRYPTED;
      }
      result.putExtra(OpenPgpApi.RESULT_TYPE,resultType);
      if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) >= 4) {
        OpenPgpMetadata metadata=pgpResult.getDecryptMetadata();
        if (metadata != null) {
          result.putExtra(OpenPgpApi.RESULT_METADATA,metadata);
        }
      }
      String charset=pgpResult.getCharset();
      if (charset != null) {
        result.putExtra(OpenPgpApi.RESULT_CHARSET,charset);
      }
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
      return result;
    }
 else {
      if (pgpResult.isKeysDisallowed()) {
        Intent result=new Intent();
        result.putExtra(OpenPgpApi.RESULT_INTENT,getSelectAllowedKeysIntent(data));
        result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
        return result;
      }
      String errorMsg=getString(pgpResult.getLog().getLast().mType.getMsgId());
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.GENERIC_ERROR,errorMsg));
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
      return result;
    }
  }
 catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.GENERIC_ERROR,e.getMessage()));
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
    return result;
  }
 finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      IOException e) {
        Log.e(Constants.TAG,""String_Node_Str"",e);
      }
    }
    if (outputStream != null) {
      try {
        outputStream.close();
      }
 catch (      IOException e) {
        Log.e(Constants.TAG,""String_Node_Str"",e);
      }
    }
  }
}","private Intent decryptAndVerifyImpl(Intent data,ParcelFileDescriptor inputDescriptor,ParcelFileDescriptor output,boolean decryptMetadataOnly){
  InputStream inputStream=null;
  OutputStream outputStream=null;
  try {
    inputStream=new ParcelFileDescriptor.AutoCloseInputStream(inputDescriptor);
    if (decryptMetadataOnly || output == null) {
      outputStream=null;
    }
 else {
      outputStream=new ParcelFileDescriptor.AutoCloseOutputStream(output);
    }
    String currentPkg=getCurrentCallingPackage();
    HashSet<Long> allowedKeyIds=mProviderHelper.getAllowedKeyIdsForApp(KeychainContract.ApiAllowedKeys.buildBaseUri(currentPkg));
    if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) < 7) {
      allowedKeyIds.addAll(mProviderHelper.getAllKeyIdsForApp(ApiAccounts.buildBaseUri(currentPkg)));
    }
    CryptoInputParcel cryptoInput=CryptoInputParcelCacheService.getCryptoInputParcel(this,data);
    if (cryptoInput == null) {
      cryptoInput=new CryptoInputParcel();
    }
    if (data.hasExtra(OpenPgpApi.EXTRA_PASSPHRASE)) {
      cryptoInput=new CryptoInputParcel(cryptoInput.getSignatureTime(),new Passphrase(data.getCharArrayExtra(OpenPgpApi.EXTRA_PASSPHRASE)));
    }
    byte[] detachedSignature=data.getByteArrayExtra(OpenPgpApi.EXTRA_DETACHED_SIGNATURE);
    PgpDecryptVerify op=new PgpDecryptVerify(this,mProviderHelper,null);
    long inputLength=inputStream.available();
    InputData inputData=new InputData(inputStream,inputLength);
    PgpDecryptVerifyInputParcel input=new PgpDecryptVerifyInputParcel().setAllowSymmetricDecryption(false).setAllowedKeyIds(allowedKeyIds).setDecryptMetadataOnly(decryptMetadataOnly).setDetachedSignature(detachedSignature);
    DecryptVerifyResult pgpResult=op.execute(input,cryptoInput,inputData,outputStream);
    if (pgpResult.isPending()) {
      RequiredInputParcel requiredInput=pgpResult.getRequiredInputParcel();
      PendingIntent pIntent=getRequiredInputPendingIntent(getBaseContext(),data,requiredInput);
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_INTENT,pIntent);
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
      return result;
    }
 else     if (pgpResult.success()) {
      Intent result=new Intent();
      OpenPgpSignatureResult signatureResult=pgpResult.getSignatureResult();
      int resultType=OpenPgpApi.RESULT_TYPE_UNENCRYPTED_UNSIGNED;
      if (signatureResult != null) {
        resultType|=OpenPgpApi.RESULT_TYPE_SIGNED;
        if (!signatureResult.isSignatureOnly()) {
          resultType|=OpenPgpApi.RESULT_TYPE_ENCRYPTED;
        }
        result.putExtra(OpenPgpApi.RESULT_SIGNATURE,signatureResult);
        if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) < 5) {
          if (signatureResult.getStatus() == OpenPgpSignatureResult.SIGNATURE_KEY_REVOKED || signatureResult.getStatus() == OpenPgpSignatureResult.SIGNATURE_KEY_EXPIRED) {
            signatureResult.setStatus(OpenPgpSignatureResult.SIGNATURE_ERROR);
          }
        }
        if (signatureResult.getStatus() == OpenPgpSignatureResult.SIGNATURE_KEY_MISSING) {
          result.putExtra(OpenPgpApi.RESULT_INTENT,getKeyserverPendingIntent(data,signatureResult.getKeyId()));
        }
 else {
          result.putExtra(OpenPgpApi.RESULT_INTENT,getShowKeyPendingIntent(signatureResult.getKeyId()));
        }
      }
 else {
        resultType|=OpenPgpApi.RESULT_TYPE_ENCRYPTED;
      }
      result.putExtra(OpenPgpApi.RESULT_TYPE,resultType);
      if (data.getIntExtra(OpenPgpApi.EXTRA_API_VERSION,-1) >= 4) {
        OpenPgpMetadata metadata=pgpResult.getDecryptMetadata();
        if (metadata != null) {
          result.putExtra(OpenPgpApi.RESULT_METADATA,metadata);
        }
      }
      String charset=pgpResult.getCharset();
      if (charset != null) {
        result.putExtra(OpenPgpApi.RESULT_CHARSET,charset);
      }
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_SUCCESS);
      return result;
    }
 else {
      if (pgpResult.isKeysDisallowed()) {
        Intent result=new Intent();
        result.putExtra(OpenPgpApi.RESULT_INTENT,getSelectAllowedKeysIntent(data));
        result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED);
        return result;
      }
      String errorMsg=getString(pgpResult.getLog().getLast().mType.getMsgId());
      Intent result=new Intent();
      result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.GENERIC_ERROR,errorMsg));
      result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
      return result;
    }
  }
 catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    Intent result=new Intent();
    result.putExtra(OpenPgpApi.RESULT_ERROR,new OpenPgpError(OpenPgpError.GENERIC_ERROR,e.getMessage()));
    result.putExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR);
    return result;
  }
 finally {
    if (inputStream != null) {
      try {
        inputStream.close();
      }
 catch (      IOException e) {
        Log.e(Constants.TAG,""String_Node_Str"",e);
      }
    }
    if (outputStream != null) {
      try {
        outputStream.close();
      }
 catch (      IOException e) {
        Log.e(Constants.TAG,""String_Node_Str"",e);
      }
    }
  }
}",0.9929711246200608
8309,"/** 
 * The IntentService calls this method from the default worker thread with the intent that started the service. When this method returns, IntentService stops the service, as appropriate.
 */
@Override protected void onHandleIntent(Intent intent){
  mActionCanceled.set(false);
  Bundle extras=intent.getExtras();
  if (extras == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  if (!(extras.containsKey(EXTRA_MESSENGER) || extras.containsKey(EXTRA_DATA) || (intent.getAction() == null))) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  Uri dataUri=intent.getData();
  mMessenger=(Messenger)extras.get(EXTRA_MESSENGER);
  Bundle data=extras.getBundle(EXTRA_DATA);
  if (data == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  Log.logDebugBundle(data,""String_Node_Str"");
  ProviderHelper providerHelper=new ProviderHelper(this);
  String action=intent.getAction();
switch (action) {
case ACTION_CERTIFY_KEYRING:
{
      CertifyActionsParcel parcel=data.getParcelable(CERTIFY_PARCEL);
      CryptoInputParcel cryptoInput=data.getParcelable(EXTRA_CRYPTO_INPUT);
      String keyServerUri=data.getString(UPLOAD_KEY_SERVER);
      CertifyOperation op=new CertifyOperation(this,providerHelper,this,mActionCanceled);
      CertifyResult result=op.certify(parcel,cryptoInput,keyServerUri);
      sendMessageToHandler(MessageStatus.OKAY,result);
      break;
    }
case ACTION_CONSOLIDATE:
{
    ConsolidateResult result;
    if (data.containsKey(CONSOLIDATE_RECOVERY) && data.getBoolean(CONSOLIDATE_RECOVERY)) {
      result=new ProviderHelper(this).consolidateDatabaseStep2(this);
    }
 else {
      result=new ProviderHelper(this).consolidateDatabaseStep1(this);
    }
    sendMessageToHandler(MessageStatus.OKAY,result);
    break;
  }
case ACTION_DECRYPT_METADATA:
{
  CryptoInputParcel cryptoInput=data.getParcelable(EXTRA_CRYPTO_INPUT);
  PgpDecryptVerifyInputParcel input=data.getParcelable(DECRYPT_VERIFY_PARCEL);
  PgpDecryptVerify op=new PgpDecryptVerify(this,new ProviderHelper(this),this);
  DecryptVerifyResult decryptVerifyResult=op.execute(input,cryptoInput);
  sendMessageToHandler(MessageStatus.OKAY,decryptVerifyResult);
  break;
}
case ACTION_VERIFY_KEYBASE_PROOF:
{
try {
  Proof proof=new Proof(new JSONObject(data.getString(KEYBASE_PROOF)));
  setProgress(R.string.keybase_message_fetching_data,0,100);
  Prover prover=Prover.findProverFor(proof);
  if (prover == null) {
    sendProofError(getString(R.string.keybase_no_prover_found) + ""String_Node_Str"" + proof.getPrettyName());
    return;
  }
  if (!prover.fetchProofData()) {
    sendProofError(prover.getLog(),getString(R.string.keybase_problem_fetching_evidence));
    return;
  }
  String requiredFingerprint=data.getString(KEYBASE_REQUIRED_FINGERPRINT);
  if (!prover.checkFingerprint(requiredFingerprint)) {
    sendProofError(getString(R.string.keybase_key_mismatch));
    return;
  }
  String domain=prover.dnsTxtCheckRequired();
  if (domain != null) {
    DNSMessage dnsQuery=new Client().query(new Question(domain,Record.TYPE.TXT));
    if (dnsQuery == null) {
      sendProofError(prover.getLog(),getString(R.string.keybase_dns_query_failure));
      return;
    }
    Record[] records=dnsQuery.getAnswers();
    List<List<byte[]>> extents=new ArrayList<List<byte[]>>();
    for (    Record r : records) {
      Data d=r.getPayload();
      if (d instanceof TXT) {
        extents.add(((TXT)d).getExtents());
      }
    }
    if (!prover.checkDnsTxt(extents)) {
      sendProofError(prover.getLog(),null);
      return;
    }
  }
  byte[] messageBytes=prover.getPgpMessage().getBytes();
  if (prover.rawMessageCheckRequired()) {
    InputStream messageByteStream=PGPUtil.getDecoderStream(new ByteArrayInputStream(messageBytes));
    if (!prover.checkRawMessageBytes(messageByteStream)) {
      sendProofError(prover.getLog(),null);
      return;
    }
  }
  PgpDecryptVerify op=new PgpDecryptVerify(this,new ProviderHelper(this),this);
  PgpDecryptVerifyInputParcel input=new PgpDecryptVerifyInputParcel(messageBytes).setSignedLiteralData(true).setRequiredSignerFingerprint(requiredFingerprint);
  DecryptVerifyResult decryptVerifyResult=op.execute(input,new CryptoInputParcel());
  if (!decryptVerifyResult.success()) {
    OperationLog log=decryptVerifyResult.getLog();
    OperationResult.LogEntryParcel lastEntry=null;
    for (    OperationResult.LogEntryParcel entry : log) {
      lastEntry=entry;
    }
    sendProofError(getString(lastEntry.mType.getMsgId()));
    return;
  }
  if (!prover.validate(new String(decryptVerifyResult.getOutputBytes()))) {
    sendProofError(getString(R.string.keybase_message_payload_mismatch));
    return;
  }
  Bundle resultData=new Bundle();
  resultData.putString(ServiceProgressHandler.DATA_MESSAGE,""String_Node_Str"");
  resultData.putString(ServiceProgressHandler.KEYBASE_PROOF_URL,prover.getProofUrl());
  resultData.putString(ServiceProgressHandler.KEYBASE_PRESENCE_URL,prover.getPresenceUrl());
  resultData.putString(ServiceProgressHandler.KEYBASE_PRESENCE_LABEL,prover.getPresenceLabel());
  sendMessageToHandler(MessageStatus.OKAY,resultData);
}
 catch (Exception e) {
  sendErrorToHandler(e);
}
break;
}
case ACTION_DECRYPT_VERIFY:
{
CryptoInputParcel cryptoInput=data.getParcelable(EXTRA_CRYPTO_INPUT);
PgpDecryptVerifyInputParcel input=data.getParcelable(DECRYPT_VERIFY_PARCEL);
PgpDecryptVerify op=new PgpDecryptVerify(this,new ProviderHelper(this),this);
DecryptVerifyResult decryptVerifyResult=op.execute(input,cryptoInput);
sendMessageToHandler(MessageStatus.OKAY,decryptVerifyResult);
break;
}
case ACTION_DELETE:
{
long[] masterKeyIds=data.getLongArray(DELETE_KEY_LIST);
boolean isSecret=data.getBoolean(DELETE_IS_SECRET);
DeleteOperation op=new DeleteOperation(this,new ProviderHelper(this),this);
DeleteResult result=op.execute(masterKeyIds,isSecret);
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_EDIT_KEYRING:
{
SaveKeyringParcel saveParcel=data.getParcelable(EDIT_KEYRING_PARCEL);
CryptoInputParcel cryptoInput=data.getParcelable(EXTRA_CRYPTO_INPUT);
EditKeyOperation op=new EditKeyOperation(this,providerHelper,this,mActionCanceled);
OperationResult result=op.execute(saveParcel,cryptoInput);
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_PROMOTE_KEYRING:
{
long keyRingId=data.getLong(PROMOTE_MASTER_KEY_ID);
byte[] cardAid=data.getByteArray(PROMOTE_CARD_AID);
long[] subKeyIds=data.getLongArray(PROMOTE_SUBKEY_IDS);
PromoteKeyOperation op=new PromoteKeyOperation(this,providerHelper,this,mActionCanceled);
PromoteKeyResult result=op.execute(keyRingId,cardAid,subKeyIds);
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_EXPORT_KEYRING:
{
boolean exportSecret=data.getBoolean(EXPORT_SECRET,false);
String outputFile=data.getString(EXPORT_FILENAME);
Uri outputUri=data.getParcelable(EXPORT_URI);
boolean exportAll=data.getBoolean(EXPORT_ALL);
long[] masterKeyIds=exportAll ? null : data.getLongArray(EXPORT_KEY_RING_MASTER_KEY_ID);
ImportExportOperation importExportOperation=new ImportExportOperation(this,new ProviderHelper(this),this);
ExportResult result;
if (outputFile != null) {
result=importExportOperation.exportToFile(masterKeyIds,exportSecret,outputFile);
}
 else {
result=importExportOperation.exportToUri(masterKeyIds,exportSecret,outputUri);
}
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_IMPORT_KEYRING:
{
String keyServer=data.getString(IMPORT_KEY_SERVER);
ArrayList<ParcelableKeyRing> list=data.getParcelableArrayList(IMPORT_KEY_LIST);
ParcelableFileCache<ParcelableKeyRing> cache=new ParcelableFileCache<>(this,""String_Node_Str"");
ImportExportOperation importExportOperation=new ImportExportOperation(this,providerHelper,this,mActionCanceled);
ImportKeyResult result=list != null ? importExportOperation.importKeyRings(list,keyServer) : importExportOperation.importKeyRings(cache,keyServer);
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_SIGN_ENCRYPT:
{
SignEncryptParcel inputParcel=data.getParcelable(SIGN_ENCRYPT_PARCEL);
CryptoInputParcel cryptoInput=data.getParcelable(EXTRA_CRYPTO_INPUT);
SignEncryptOperation op=new SignEncryptOperation(this,new ProviderHelper(this),this,mActionCanceled);
SignEncryptResult result=op.execute(inputParcel,cryptoInput);
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_UPLOAD_KEYRING:
{
try {
String keyServer=data.getString(UPLOAD_KEY_SERVER);
HkpKeyserver server=new HkpKeyserver(keyServer);
CanonicalizedPublicKeyRing keyring=providerHelper.getCanonicalizedPublicKeyRing(dataUri);
ImportExportOperation importExportOperation=new ImportExportOperation(this,new ProviderHelper(this),this);
try {
importExportOperation.uploadKeyRingToServer(server,keyring);
}
 catch (Keyserver.AddKeyException e) {
throw new PgpGeneralException(""String_Node_Str"");
}
sendMessageToHandler(MessageStatus.OKAY);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
}
}
}","/** 
 * The IntentService calls this method from the default worker thread with the intent that started the service. When this method returns, IntentService stops the service, as appropriate.
 */
@Override protected void onHandleIntent(Intent intent){
  mActionCanceled.set(false);
  Bundle extras=intent.getExtras();
  if (extras == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  if (!(extras.containsKey(EXTRA_MESSENGER) || extras.containsKey(EXTRA_DATA) || (intent.getAction() == null))) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  Uri dataUri=intent.getData();
  mMessenger=(Messenger)extras.get(EXTRA_MESSENGER);
  Bundle data=extras.getBundle(EXTRA_DATA);
  if (data == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  Log.logDebugBundle(data,""String_Node_Str"");
  ProviderHelper providerHelper=new ProviderHelper(this);
  String action=intent.getAction();
switch (action) {
case ACTION_CERTIFY_KEYRING:
{
      CertifyActionsParcel parcel=data.getParcelable(CERTIFY_PARCEL);
      CryptoInputParcel cryptoInput=data.getParcelable(EXTRA_CRYPTO_INPUT);
      String keyServerUri=data.getString(UPLOAD_KEY_SERVER);
      CertifyOperation op=new CertifyOperation(this,providerHelper,this,mActionCanceled);
      CertifyResult result=op.certify(parcel,cryptoInput,keyServerUri);
      sendMessageToHandler(MessageStatus.OKAY,result);
      break;
    }
case ACTION_CONSOLIDATE:
{
    ConsolidateResult result;
    if (data.containsKey(CONSOLIDATE_RECOVERY) && data.getBoolean(CONSOLIDATE_RECOVERY)) {
      result=new ProviderHelper(this).consolidateDatabaseStep2(this);
    }
 else {
      result=new ProviderHelper(this).consolidateDatabaseStep1(this);
    }
    sendMessageToHandler(MessageStatus.OKAY,result);
    break;
  }
case ACTION_DECRYPT_METADATA:
{
  CryptoInputParcel cryptoInput=data.getParcelable(EXTRA_CRYPTO_INPUT);
  PgpDecryptVerifyInputParcel input=data.getParcelable(DECRYPT_VERIFY_PARCEL);
  input.setDecryptMetadataOnly(true);
  PgpDecryptVerify op=new PgpDecryptVerify(this,new ProviderHelper(this),this);
  DecryptVerifyResult decryptVerifyResult=op.execute(input,cryptoInput);
  sendMessageToHandler(MessageStatus.OKAY,decryptVerifyResult);
  break;
}
case ACTION_VERIFY_KEYBASE_PROOF:
{
try {
  Proof proof=new Proof(new JSONObject(data.getString(KEYBASE_PROOF)));
  setProgress(R.string.keybase_message_fetching_data,0,100);
  Prover prover=Prover.findProverFor(proof);
  if (prover == null) {
    sendProofError(getString(R.string.keybase_no_prover_found) + ""String_Node_Str"" + proof.getPrettyName());
    return;
  }
  if (!prover.fetchProofData()) {
    sendProofError(prover.getLog(),getString(R.string.keybase_problem_fetching_evidence));
    return;
  }
  String requiredFingerprint=data.getString(KEYBASE_REQUIRED_FINGERPRINT);
  if (!prover.checkFingerprint(requiredFingerprint)) {
    sendProofError(getString(R.string.keybase_key_mismatch));
    return;
  }
  String domain=prover.dnsTxtCheckRequired();
  if (domain != null) {
    DNSMessage dnsQuery=new Client().query(new Question(domain,Record.TYPE.TXT));
    if (dnsQuery == null) {
      sendProofError(prover.getLog(),getString(R.string.keybase_dns_query_failure));
      return;
    }
    Record[] records=dnsQuery.getAnswers();
    List<List<byte[]>> extents=new ArrayList<List<byte[]>>();
    for (    Record r : records) {
      Data d=r.getPayload();
      if (d instanceof TXT) {
        extents.add(((TXT)d).getExtents());
      }
    }
    if (!prover.checkDnsTxt(extents)) {
      sendProofError(prover.getLog(),null);
      return;
    }
  }
  byte[] messageBytes=prover.getPgpMessage().getBytes();
  if (prover.rawMessageCheckRequired()) {
    InputStream messageByteStream=PGPUtil.getDecoderStream(new ByteArrayInputStream(messageBytes));
    if (!prover.checkRawMessageBytes(messageByteStream)) {
      sendProofError(prover.getLog(),null);
      return;
    }
  }
  PgpDecryptVerify op=new PgpDecryptVerify(this,new ProviderHelper(this),this);
  PgpDecryptVerifyInputParcel input=new PgpDecryptVerifyInputParcel(messageBytes).setSignedLiteralData(true).setRequiredSignerFingerprint(requiredFingerprint);
  DecryptVerifyResult decryptVerifyResult=op.execute(input,new CryptoInputParcel());
  if (!decryptVerifyResult.success()) {
    OperationLog log=decryptVerifyResult.getLog();
    OperationResult.LogEntryParcel lastEntry=null;
    for (    OperationResult.LogEntryParcel entry : log) {
      lastEntry=entry;
    }
    sendProofError(getString(lastEntry.mType.getMsgId()));
    return;
  }
  if (!prover.validate(new String(decryptVerifyResult.getOutputBytes()))) {
    sendProofError(getString(R.string.keybase_message_payload_mismatch));
    return;
  }
  Bundle resultData=new Bundle();
  resultData.putString(ServiceProgressHandler.DATA_MESSAGE,""String_Node_Str"");
  resultData.putString(ServiceProgressHandler.KEYBASE_PROOF_URL,prover.getProofUrl());
  resultData.putString(ServiceProgressHandler.KEYBASE_PRESENCE_URL,prover.getPresenceUrl());
  resultData.putString(ServiceProgressHandler.KEYBASE_PRESENCE_LABEL,prover.getPresenceLabel());
  sendMessageToHandler(MessageStatus.OKAY,resultData);
}
 catch (Exception e) {
  sendErrorToHandler(e);
}
break;
}
case ACTION_DECRYPT_VERIFY:
{
CryptoInputParcel cryptoInput=data.getParcelable(EXTRA_CRYPTO_INPUT);
PgpDecryptVerifyInputParcel input=data.getParcelable(DECRYPT_VERIFY_PARCEL);
input.setDecryptMetadataOnly(false);
PgpDecryptVerify op=new PgpDecryptVerify(this,new ProviderHelper(this),this);
DecryptVerifyResult decryptVerifyResult=op.execute(input,cryptoInput);
sendMessageToHandler(MessageStatus.OKAY,decryptVerifyResult);
break;
}
case ACTION_DELETE:
{
long[] masterKeyIds=data.getLongArray(DELETE_KEY_LIST);
boolean isSecret=data.getBoolean(DELETE_IS_SECRET);
DeleteOperation op=new DeleteOperation(this,new ProviderHelper(this),this);
DeleteResult result=op.execute(masterKeyIds,isSecret);
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_EDIT_KEYRING:
{
SaveKeyringParcel saveParcel=data.getParcelable(EDIT_KEYRING_PARCEL);
CryptoInputParcel cryptoInput=data.getParcelable(EXTRA_CRYPTO_INPUT);
EditKeyOperation op=new EditKeyOperation(this,providerHelper,this,mActionCanceled);
OperationResult result=op.execute(saveParcel,cryptoInput);
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_PROMOTE_KEYRING:
{
long keyRingId=data.getLong(PROMOTE_MASTER_KEY_ID);
byte[] cardAid=data.getByteArray(PROMOTE_CARD_AID);
long[] subKeyIds=data.getLongArray(PROMOTE_SUBKEY_IDS);
PromoteKeyOperation op=new PromoteKeyOperation(this,providerHelper,this,mActionCanceled);
PromoteKeyResult result=op.execute(keyRingId,cardAid,subKeyIds);
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_EXPORT_KEYRING:
{
boolean exportSecret=data.getBoolean(EXPORT_SECRET,false);
String outputFile=data.getString(EXPORT_FILENAME);
Uri outputUri=data.getParcelable(EXPORT_URI);
boolean exportAll=data.getBoolean(EXPORT_ALL);
long[] masterKeyIds=exportAll ? null : data.getLongArray(EXPORT_KEY_RING_MASTER_KEY_ID);
ImportExportOperation importExportOperation=new ImportExportOperation(this,new ProviderHelper(this),this);
ExportResult result;
if (outputFile != null) {
result=importExportOperation.exportToFile(masterKeyIds,exportSecret,outputFile);
}
 else {
result=importExportOperation.exportToUri(masterKeyIds,exportSecret,outputUri);
}
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_IMPORT_KEYRING:
{
String keyServer=data.getString(IMPORT_KEY_SERVER);
ArrayList<ParcelableKeyRing> list=data.getParcelableArrayList(IMPORT_KEY_LIST);
ParcelableFileCache<ParcelableKeyRing> cache=new ParcelableFileCache<>(this,""String_Node_Str"");
ImportExportOperation importExportOperation=new ImportExportOperation(this,providerHelper,this,mActionCanceled);
ImportKeyResult result=list != null ? importExportOperation.importKeyRings(list,keyServer) : importExportOperation.importKeyRings(cache,keyServer);
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_SIGN_ENCRYPT:
{
SignEncryptParcel inputParcel=data.getParcelable(SIGN_ENCRYPT_PARCEL);
CryptoInputParcel cryptoInput=data.getParcelable(EXTRA_CRYPTO_INPUT);
SignEncryptOperation op=new SignEncryptOperation(this,new ProviderHelper(this),this,mActionCanceled);
SignEncryptResult result=op.execute(inputParcel,cryptoInput);
sendMessageToHandler(MessageStatus.OKAY,result);
break;
}
case ACTION_UPLOAD_KEYRING:
{
try {
String keyServer=data.getString(UPLOAD_KEY_SERVER);
HkpKeyserver server=new HkpKeyserver(keyServer);
CanonicalizedPublicKeyRing keyring=providerHelper.getCanonicalizedPublicKeyRing(dataUri);
ImportExportOperation importExportOperation=new ImportExportOperation(this,new ProviderHelper(this),this);
try {
importExportOperation.uploadKeyRingToServer(server,keyring);
}
 catch (Keyserver.AddKeyException e) {
throw new PgpGeneralException(""String_Node_Str"");
}
sendMessageToHandler(MessageStatus.OKAY);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
}
}
}",0.9958340276620564
8310,"@Override @SuppressLint(""String_Node_Str"") protected void cryptoOperation(CryptoInputParcel cryptoInput){
  Intent intent=new Intent(getActivity(),KeychainIntentService.class);
  Bundle data=new Bundle();
  intent.setAction(mCurrentCryptoOperation);
  Log.d(Constants.TAG,""String_Node_Str"" + mInputUri + ""String_Node_Str""+ mOutputUri);
  PgpDecryptVerifyInputParcel input=new PgpDecryptVerifyInputParcel(mInputUri,mOutputUri).setAllowSymmetricDecryption(true).setDecryptMetadataOnly(true);
  data.putParcelable(KeychainIntentService.DECRYPT_VERIFY_PARCEL,input);
  data.putParcelable(KeychainIntentService.EXTRA_CRYPTO_INPUT,cryptoInput);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  ServiceProgressHandler saveHandler=new ServiceProgressHandler(getActivity(),getString(R.string.progress_decrypting),ProgressDialog.STYLE_HORIZONTAL,ProgressDialogFragment.ServiceType.KEYCHAIN_INTENT){
    @Override public void handleMessage(    Message message){
      super.handleMessage(message);
      if (handlePendingMessage(message)) {
        return;
      }
      if (message.arg1 == MessageStatus.OKAY.ordinal()) {
        Bundle returnData=message.getData();
        DecryptVerifyResult pgpResult=returnData.getParcelable(DecryptVerifyResult.EXTRA_RESULT);
        if (pgpResult.success()) {
switch (mCurrentCryptoOperation) {
case KeychainIntentService.ACTION_DECRYPT_METADATA:
{
              askForOutputFilename(pgpResult.getDecryptMetadata().getFilename());
              break;
            }
case KeychainIntentService.ACTION_DECRYPT_VERIFY:
{
            loadVerifyResult(pgpResult);
            if (mDeleteAfter.isChecked()) {
              DeleteFileDialogFragment deleteFileDialog=DeleteFileDialogFragment.newInstance(mInputUri);
              deleteFileDialog.show(getActivity().getSupportFragmentManager(),""String_Node_Str"");
              setInputUri(null);
            }
            break;
          }
default :
{
          Log.e(Constants.TAG,""String_Node_Str"");
          break;
        }
    }
  }
  pgpResult.createNotify(getActivity()).show(DecryptFilesFragment.this);
}
}
}
;
Messenger messenger=new Messenger(saveHandler);
intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
saveHandler.showProgressDialog(getActivity());
getActivity().startService(intent);
}","@Override @SuppressLint(""String_Node_Str"") protected void cryptoOperation(CryptoInputParcel cryptoInput){
  Intent intent=new Intent(getActivity(),KeychainIntentService.class);
  Bundle data=new Bundle();
  intent.setAction(mCurrentCryptoOperation);
  Log.d(Constants.TAG,""String_Node_Str"" + mInputUri + ""String_Node_Str""+ mOutputUri);
  PgpDecryptVerifyInputParcel input=new PgpDecryptVerifyInputParcel(mInputUri,mOutputUri).setAllowSymmetricDecryption(true);
  data.putParcelable(KeychainIntentService.DECRYPT_VERIFY_PARCEL,input);
  data.putParcelable(KeychainIntentService.EXTRA_CRYPTO_INPUT,cryptoInput);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  ServiceProgressHandler saveHandler=new ServiceProgressHandler(getActivity(),getString(R.string.progress_decrypting),ProgressDialog.STYLE_HORIZONTAL,ProgressDialogFragment.ServiceType.KEYCHAIN_INTENT){
    @Override public void handleMessage(    Message message){
      super.handleMessage(message);
      if (handlePendingMessage(message)) {
        return;
      }
      if (message.arg1 == MessageStatus.OKAY.ordinal()) {
        Bundle returnData=message.getData();
        DecryptVerifyResult pgpResult=returnData.getParcelable(DecryptVerifyResult.EXTRA_RESULT);
        if (pgpResult.success()) {
switch (mCurrentCryptoOperation) {
case KeychainIntentService.ACTION_DECRYPT_METADATA:
{
              askForOutputFilename(pgpResult.getDecryptMetadata().getFilename());
              break;
            }
case KeychainIntentService.ACTION_DECRYPT_VERIFY:
{
            loadVerifyResult(pgpResult);
            if (mDeleteAfter.isChecked()) {
              DeleteFileDialogFragment deleteFileDialog=DeleteFileDialogFragment.newInstance(mInputUri);
              deleteFileDialog.show(getActivity().getSupportFragmentManager(),""String_Node_Str"");
              setInputUri(null);
            }
            break;
          }
default :
{
          Log.e(Constants.TAG,""String_Node_Str"");
          break;
        }
    }
  }
  pgpResult.createNotify(getActivity()).show(DecryptFilesFragment.this);
}
}
}
;
Messenger messenger=new Messenger(saveHandler);
intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
saveHandler.showProgressDialog(getActivity());
getActivity().startService(intent);
}",0.9936639720340834
8311,"private PgpEditKeyResult internal(PGPSecretKeyRing sKR,PGPSecretKey masterSecretKey,int masterKeyFlags,long masterKeyExpiry,CryptoInputParcel cryptoInput,SaveKeyringParcel saveParcel,OperationLog log){
  int indent=1;
  NfcSignOperationsBuilder nfcSignOps=new NfcSignOperationsBuilder(cryptoInput.getSignatureTime(),masterSecretKey.getKeyID(),masterSecretKey.getKeyID());
  progress(R.string.progress_modify,0);
  PGPPublicKey masterPublicKey=masterSecretKey.getPublicKey();
  PGPPrivateKey masterPrivateKey;
  if (isDivertToCard(masterSecretKey)) {
    masterPrivateKey=null;
    log.add(LogType.MSG_MF_DIVERT,indent);
  }
 else {
    progress(R.string.progress_modify_unlock,10);
    log.add(LogType.MSG_MF_UNLOCK,indent);
{
      try {
        PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
        masterPrivateKey=masterSecretKey.extractPrivateKey(keyDecryptor);
      }
 catch (      PGPException e) {
        log.add(LogType.MSG_MF_UNLOCK_ERROR,indent + 1);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
      }
    }
  }
  try {
    if (checkCancelled()) {
      log.add(LogType.MSG_OPERATION_CANCELLED,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
    }
{
      PGPPublicKey modifiedPublicKey=masterPublicKey;
      subProgressPush(15,23);
      for (int i=0; i < saveParcel.mAddUserIds.size(); i++) {
        progress(R.string.progress_modify_adduid,(i - 1) * (100 / saveParcel.mAddUserIds.size()));
        String userId=saveParcel.mAddUserIds.get(i);
        log.add(LogType.MSG_MF_UID_ADD,indent,userId);
        if (""String_Node_Str"".equals(userId)) {
          log.add(LogType.MSG_MF_UID_ERROR_EMPTY,indent + 1);
          return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
        }
        @SuppressWarnings(""String_Node_Str"") Iterator<PGPSignature> it=modifiedPublicKey.getSignaturesForID(userId);
        if (it != null) {
          for (          PGPSignature cert : new IterableIterator<>(it)) {
            if (cert.getKeyID() != masterPublicKey.getKeyID()) {
              log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
              return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
            }
            if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION || cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
              modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,cert);
            }
          }
        }
        boolean isPrimary=saveParcel.mChangePrimaryUserId != null && userId.equals(saveParcel.mChangePrimaryUserId);
        try {
          PGPSignature cert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,isPrimary,masterKeyFlags,masterKeyExpiry);
          modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
        }
 catch (        NfcInteractionNeeded e) {
          nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
        }
      }
      subProgressPop();
      subProgressPush(23,32);
      for (int i=0; i < saveParcel.mAddUserAttribute.size(); i++) {
        progress(R.string.progress_modify_adduat,(i - 1) * (100 / saveParcel.mAddUserAttribute.size()));
        WrappedUserAttribute attribute=saveParcel.mAddUserAttribute.get(i);
switch (attribute.getType()) {
case WrappedUserAttribute.UAT_NONE:
          log.add(LogType.MSG_MF_UAT_ERROR_EMPTY,indent);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
case WrappedUserAttribute.UAT_IMAGE:
      log.add(LogType.MSG_MF_UAT_ADD_IMAGE,indent);
    break;
default :
  log.add(LogType.MSG_MF_UAT_ADD_UNKNOWN,indent);
break;
}
PGPUserAttributeSubpacketVector vector=attribute.getVector();
try {
PGPSignature cert=generateUserAttributeSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,vector,masterKeyFlags,masterKeyExpiry);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,vector,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(32,40);
for (int i=0; i < saveParcel.mRevokeUserIds.size(); i++) {
progress(R.string.progress_modify_revokeuid,(i - 1) * (100 / saveParcel.mRevokeUserIds.size()));
String userId=saveParcel.mRevokeUserIds.get(i);
log.add(LogType.MSG_MF_UID_REVOKE,indent,userId);
boolean exists=false;
for (String uid : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
if (userId.equals(uid)) {
exists=true;
break;
}
}
if (!exists) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_REVOKE,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
try {
PGPSignature cert=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
if (saveParcel.mChangePrimaryUserId != null) {
progress(R.string.progress_modify_primaryuid,40);
boolean ok=false;
log.add(LogType.MSG_MF_UID_PRIMARY,indent,saveParcel.mChangePrimaryUserId);
indent+=1;
for (String userId : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
boolean isRevoked=false;
PGPSignature currentCert=null;
for (PGPSignature cert : new IterableIterator<PGPSignature>(modifiedPublicKey.getSignaturesForID(userId))) {
if (cert.getKeyID() != masterPublicKey.getKeyID()) {
  log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION) {
  isRevoked=true;
  continue;
}
if (cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
  currentCert=cert;
}
}
if (currentCert == null) {
log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (isRevoked) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  log.add(LogType.MSG_MF_ERROR_REVOKED_PRIMARY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
continue;
}
if (currentCert.getHashedSubPackets() != null && currentCert.getHashedSubPackets().isPrimaryUserID()) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  ok=true;
  continue;
}
log.add(LogType.MSG_MF_PRIMARY_REPLACE_OLD,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,false,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
continue;
}
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
log.add(LogType.MSG_MF_PRIMARY_NEW,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,true,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
ok=true;
}
}
indent-=1;
if (!ok) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_PRIMARY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
}
if (modifiedPublicKey != masterPublicKey) {
masterSecretKey=PGPSecretKey.replacePublicKey(masterSecretKey,modifiedPublicKey);
masterPublicKey=modifiedPublicKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
}
}
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
subProgressPush(50,60);
for (int i=0; i < saveParcel.mChangeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeychange,(i - 1) * (100 / saveParcel.mChangeSubKeys.size()));
SaveKeyringParcel.SubkeyChange change=saveParcel.mChangeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_CHANGE,indent,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
PGPSecretKey sKey=sKR.getSecretKey(change.mKeyId);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mDummyStrip || change.mDummyDivert != null) {
if (change.mDummyStrip) {
sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey());
}
 else {
if (change.mDummyDivert.length != 16) {
log.add(LogType.MSG_MF_ERROR_DIVERT_SERIAL,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
}
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
if (!change.mRecertify && (change.mExpiry == null && change.mFlags == null)) {
continue;
}
if (change.mExpiry != null && change.mExpiry != 0 && new Date(change.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mKeyId == masterPublicKey.getKeyID()) {
int flags=change.mFlags == null ? masterKeyFlags : change.mFlags;
long expiry=change.mExpiry == null ? masterKeyExpiry : change.mExpiry;
if ((flags & KeyFlags.CERTIFY_OTHER) != KeyFlags.CERTIFY_OTHER) {
log.add(LogType.MSG_MF_ERROR_NO_CERTIFY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=updateMasterCertificates(masterSecretKey,masterPrivateKey,masterPublicKey,flags,expiry,cryptoInput,nfcSignOps,indent,log);
if (pKey == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
masterSecretKey=PGPSecretKey.replacePublicKey(sKey,pKey);
masterPublicKey=pKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
continue;
}
PGPPublicKey pKey=sKey.getPublicKey();
int flags=change.mFlags == null ? readKeyFlags(pKey) : change.mFlags;
long expiry;
if (change.mExpiry == null) {
long valid=pKey.getValidSeconds();
expiry=valid == 0 ? 0 : pKey.getCreationTime().getTime() / 1000 + pKey.getValidSeconds();
}
 else {
expiry=change.mExpiry;
}
for (PGPSignature sig : new IterableIterator<PGPSignature>(pKey.getSignatures())) {
if ((change.mExpiry == null || change.mExpiry == 0L) && sig.getSignatureType() == PGPSignature.SUBKEY_REVOCATION) {
expiry=0;
}
pKey=PGPPublicKey.removeCertification(pKey,sig);
}
PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
PGPPrivateKey subPrivateKey=sKey.extractPrivateKey(keyDecryptor);
PGPSignature sig=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,subPrivateKey,pKey,flags,expiry);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
subProgressPop();
subProgressPush(60,65);
for (int i=0; i < saveParcel.mRevokeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeyrevoke,(i - 1) * (100 / saveParcel.mRevokeSubKeys.size()));
long revocation=saveParcel.mRevokeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_REVOKE,indent,KeyFormattingUtils.convertKeyIdToHex(revocation));
PGPSecretKey sKey=sKR.getSecretKey(revocation);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(revocation));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=sKey.getPublicKey();
try {
PGPSignature sig=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,pKey);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(70,90);
for (int i=0; i < saveParcel.mAddSubKeys.size(); i++) {
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
progress(R.string.progress_modify_subkeyadd,(i - 1) * (100 / saveParcel.mAddSubKeys.size()));
SaveKeyringParcel.SubkeyAdd add=saveParcel.mAddSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_NEW,indent,KeyFormattingUtils.getAlgorithmInfo(add.mAlgorithm,add.mKeySize,add.mCurve));
if (add.mExpiry == null) {
log.add(LogType.MSG_MF_ERROR_NULL_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (add.mExpiry > 0L && new Date(add.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
subProgressPush((i - 1) * (100 / saveParcel.mAddSubKeys.size()),i * (100 / saveParcel.mAddSubKeys.size()));
PGPKeyPair keyPair=createKey(add,cryptoInput.getSignatureTime(),log,indent);
subProgressPop();
if (keyPair == null) {
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=keyPair.getPublicKey();
try {
PGPSignature cert=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,keyPair.getPrivateKey(),pKey,add.mFlags,add.mExpiry);
pKey=PGPPublicKey.addSubkeyBindingCertification(pKey,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
PGPSecretKey sKey;
{
PGPDigestCalculator encryptorHashCalc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_ENCRYPTOR_HASH_ALGO);
PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PgpConstants.SECRET_KEY_ENCRYPTOR_SYMMETRIC_ALGO,encryptorHashCalc,PgpConstants.SECRET_KEY_ENCRYPTOR_S2K_COUNT).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_SIGNATURE_CHECKSUM_HASH_ALGO);
sKey=new PGPSecretKey(keyPair.getPrivateKey(),pKey,sha1Calc,false,keyEncryptor);
}
log.add(LogType.MSG_MF_SUBKEY_NEW_ID,indent + 1,KeyFormattingUtils.convertKeyIdToHex(sKey.getKeyID()));
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
subProgressPop();
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
if (saveParcel.mNewUnlock != null) {
progress(R.string.progress_modify_passphrase,90);
log.add(LogType.MSG_MF_PASSPHRASE,indent);
indent+=1;
sKR=applyNewUnlock(sKR,masterPublicKey,masterPrivateKey,cryptoInput.getPassphrase(),saveParcel.mNewUnlock,log,indent);
if (sKR == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
indent-=1;
}
}
 catch (IOException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_ENCODE,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (PGPException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (SignatureException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_SIG,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
progress(R.string.progress_done,100);
if (!nfcSignOps.isEmpty()) {
log.add(LogType.MSG_MF_REQUIRE_DIVERT,indent);
return new PgpEditKeyResult(log,nfcSignOps.build());
}
log.add(LogType.MSG_MF_SUCCESS,indent);
return new PgpEditKeyResult(OperationResult.RESULT_OK,log,new UncachedKeyRing(sKR));
}","private PgpEditKeyResult internal(PGPSecretKeyRing sKR,PGPSecretKey masterSecretKey,int masterKeyFlags,long masterKeyExpiry,CryptoInputParcel cryptoInput,SaveKeyringParcel saveParcel,OperationLog log,int indent){
  NfcSignOperationsBuilder nfcSignOps=new NfcSignOperationsBuilder(cryptoInput.getSignatureTime(),masterSecretKey.getKeyID(),masterSecretKey.getKeyID());
  progress(R.string.progress_modify,0);
  PGPPublicKey masterPublicKey=masterSecretKey.getPublicKey();
  PGPPrivateKey masterPrivateKey;
  if (isDivertToCard(masterSecretKey)) {
    masterPrivateKey=null;
    log.add(LogType.MSG_MF_DIVERT,indent);
  }
 else {
    progress(R.string.progress_modify_unlock,10);
    log.add(LogType.MSG_MF_UNLOCK,indent);
{
      try {
        PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
        masterPrivateKey=masterSecretKey.extractPrivateKey(keyDecryptor);
      }
 catch (      PGPException e) {
        log.add(LogType.MSG_MF_UNLOCK_ERROR,indent + 1);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
      }
    }
  }
  try {
    if (checkCancelled()) {
      log.add(LogType.MSG_OPERATION_CANCELLED,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
    }
{
      PGPPublicKey modifiedPublicKey=masterPublicKey;
      subProgressPush(15,23);
      for (int i=0; i < saveParcel.mAddUserIds.size(); i++) {
        progress(R.string.progress_modify_adduid,(i - 1) * (100 / saveParcel.mAddUserIds.size()));
        String userId=saveParcel.mAddUserIds.get(i);
        log.add(LogType.MSG_MF_UID_ADD,indent,userId);
        if (""String_Node_Str"".equals(userId)) {
          log.add(LogType.MSG_MF_UID_ERROR_EMPTY,indent + 1);
          return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
        }
        @SuppressWarnings(""String_Node_Str"") Iterator<PGPSignature> it=modifiedPublicKey.getSignaturesForID(userId);
        if (it != null) {
          for (          PGPSignature cert : new IterableIterator<>(it)) {
            if (cert.getKeyID() != masterPublicKey.getKeyID()) {
              log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
              return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
            }
            if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION || cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
              modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,cert);
            }
          }
        }
        boolean isPrimary=saveParcel.mChangePrimaryUserId != null && userId.equals(saveParcel.mChangePrimaryUserId);
        try {
          PGPSignature cert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,isPrimary,masterKeyFlags,masterKeyExpiry);
          modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
        }
 catch (        NfcInteractionNeeded e) {
          nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
        }
      }
      subProgressPop();
      subProgressPush(23,32);
      for (int i=0; i < saveParcel.mAddUserAttribute.size(); i++) {
        progress(R.string.progress_modify_adduat,(i - 1) * (100 / saveParcel.mAddUserAttribute.size()));
        WrappedUserAttribute attribute=saveParcel.mAddUserAttribute.get(i);
switch (attribute.getType()) {
case WrappedUserAttribute.UAT_NONE:
          log.add(LogType.MSG_MF_UAT_ERROR_EMPTY,indent);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
case WrappedUserAttribute.UAT_IMAGE:
      log.add(LogType.MSG_MF_UAT_ADD_IMAGE,indent);
    break;
default :
  log.add(LogType.MSG_MF_UAT_ADD_UNKNOWN,indent);
break;
}
PGPUserAttributeSubpacketVector vector=attribute.getVector();
try {
PGPSignature cert=generateUserAttributeSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,vector,masterKeyFlags,masterKeyExpiry);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,vector,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(32,40);
for (int i=0; i < saveParcel.mRevokeUserIds.size(); i++) {
progress(R.string.progress_modify_revokeuid,(i - 1) * (100 / saveParcel.mRevokeUserIds.size()));
String userId=saveParcel.mRevokeUserIds.get(i);
log.add(LogType.MSG_MF_UID_REVOKE,indent,userId);
boolean exists=false;
for (String uid : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
if (userId.equals(uid)) {
exists=true;
break;
}
}
if (!exists) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_REVOKE,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
try {
PGPSignature cert=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
if (saveParcel.mChangePrimaryUserId != null) {
progress(R.string.progress_modify_primaryuid,40);
boolean ok=false;
log.add(LogType.MSG_MF_UID_PRIMARY,indent,saveParcel.mChangePrimaryUserId);
indent+=1;
for (String userId : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
boolean isRevoked=false;
PGPSignature currentCert=null;
for (PGPSignature cert : new IterableIterator<PGPSignature>(modifiedPublicKey.getSignaturesForID(userId))) {
if (cert.getKeyID() != masterPublicKey.getKeyID()) {
  log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION) {
  isRevoked=true;
  continue;
}
if (cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
  currentCert=cert;
}
}
if (currentCert == null) {
log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (isRevoked) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  log.add(LogType.MSG_MF_ERROR_REVOKED_PRIMARY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
continue;
}
if (currentCert.getHashedSubPackets() != null && currentCert.getHashedSubPackets().isPrimaryUserID()) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  ok=true;
  continue;
}
log.add(LogType.MSG_MF_PRIMARY_REPLACE_OLD,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,false,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
continue;
}
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
log.add(LogType.MSG_MF_PRIMARY_NEW,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,true,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
ok=true;
}
}
indent-=1;
if (!ok) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_PRIMARY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
}
if (modifiedPublicKey != masterPublicKey) {
masterSecretKey=PGPSecretKey.replacePublicKey(masterSecretKey,modifiedPublicKey);
masterPublicKey=modifiedPublicKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
}
}
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
subProgressPush(50,60);
for (int i=0; i < saveParcel.mChangeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeychange,(i - 1) * (100 / saveParcel.mChangeSubKeys.size()));
SaveKeyringParcel.SubkeyChange change=saveParcel.mChangeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_CHANGE,indent,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
PGPSecretKey sKey=sKR.getSecretKey(change.mKeyId);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mDummyStrip || change.mDummyDivert != null) {
if (change.mDummyStrip) {
sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey());
}
 else {
if (change.mDummyDivert.length != 16) {
log.add(LogType.MSG_MF_ERROR_DIVERT_SERIAL,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
}
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
if (!change.mRecertify && (change.mExpiry == null && change.mFlags == null)) {
continue;
}
if (change.mExpiry != null && change.mExpiry != 0 && new Date(change.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mKeyId == masterPublicKey.getKeyID()) {
int flags=change.mFlags == null ? masterKeyFlags : change.mFlags;
long expiry=change.mExpiry == null ? masterKeyExpiry : change.mExpiry;
if ((flags & KeyFlags.CERTIFY_OTHER) != KeyFlags.CERTIFY_OTHER) {
log.add(LogType.MSG_MF_ERROR_NO_CERTIFY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=updateMasterCertificates(masterSecretKey,masterPrivateKey,masterPublicKey,flags,expiry,cryptoInput,nfcSignOps,indent,log);
if (pKey == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
masterSecretKey=PGPSecretKey.replacePublicKey(sKey,pKey);
masterPublicKey=pKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
continue;
}
PGPPublicKey pKey=sKey.getPublicKey();
int flags=change.mFlags == null ? readKeyFlags(pKey) : change.mFlags;
long expiry;
if (change.mExpiry == null) {
long valid=pKey.getValidSeconds();
expiry=valid == 0 ? 0 : pKey.getCreationTime().getTime() / 1000 + pKey.getValidSeconds();
}
 else {
expiry=change.mExpiry;
}
for (PGPSignature sig : new IterableIterator<PGPSignature>(pKey.getSignatures())) {
if ((change.mExpiry == null || change.mExpiry == 0L) && sig.getSignatureType() == PGPSignature.SUBKEY_REVOCATION) {
expiry=0;
}
pKey=PGPPublicKey.removeCertification(pKey,sig);
}
PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
PGPPrivateKey subPrivateKey=sKey.extractPrivateKey(keyDecryptor);
PGPSignature sig=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,subPrivateKey,pKey,flags,expiry);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
subProgressPop();
subProgressPush(60,65);
for (int i=0; i < saveParcel.mRevokeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeyrevoke,(i - 1) * (100 / saveParcel.mRevokeSubKeys.size()));
long revocation=saveParcel.mRevokeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_REVOKE,indent,KeyFormattingUtils.convertKeyIdToHex(revocation));
PGPSecretKey sKey=sKR.getSecretKey(revocation);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(revocation));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=sKey.getPublicKey();
try {
PGPSignature sig=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,pKey);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(70,90);
for (int i=0; i < saveParcel.mAddSubKeys.size(); i++) {
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
progress(R.string.progress_modify_subkeyadd,(i - 1) * (100 / saveParcel.mAddSubKeys.size()));
SaveKeyringParcel.SubkeyAdd add=saveParcel.mAddSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_NEW,indent,KeyFormattingUtils.getAlgorithmInfo(add.mAlgorithm,add.mKeySize,add.mCurve));
if (add.mExpiry == null) {
log.add(LogType.MSG_MF_ERROR_NULL_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (add.mExpiry > 0L && new Date(add.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
subProgressPush((i - 1) * (100 / saveParcel.mAddSubKeys.size()),i * (100 / saveParcel.mAddSubKeys.size()));
PGPKeyPair keyPair=createKey(add,cryptoInput.getSignatureTime(),log,indent);
subProgressPop();
if (keyPair == null) {
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=keyPair.getPublicKey();
try {
PGPSignature cert=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,keyPair.getPrivateKey(),pKey,add.mFlags,add.mExpiry);
pKey=PGPPublicKey.addSubkeyBindingCertification(pKey,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
PGPSecretKey sKey;
{
PGPDigestCalculator encryptorHashCalc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_ENCRYPTOR_HASH_ALGO);
PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PgpConstants.SECRET_KEY_ENCRYPTOR_SYMMETRIC_ALGO,encryptorHashCalc,PgpConstants.SECRET_KEY_ENCRYPTOR_S2K_COUNT).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_SIGNATURE_CHECKSUM_HASH_ALGO);
sKey=new PGPSecretKey(keyPair.getPrivateKey(),pKey,sha1Calc,false,keyEncryptor);
}
log.add(LogType.MSG_MF_SUBKEY_NEW_ID,indent + 1,KeyFormattingUtils.convertKeyIdToHex(sKey.getKeyID()));
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
subProgressPop();
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
if (saveParcel.mNewUnlock != null) {
progress(R.string.progress_modify_passphrase,90);
log.add(LogType.MSG_MF_PASSPHRASE,indent);
indent+=1;
sKR=applyNewUnlock(sKR,masterPublicKey,masterPrivateKey,cryptoInput.getPassphrase(),saveParcel.mNewUnlock,log,indent);
if (sKR == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
indent-=1;
}
}
 catch (IOException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_ENCODE,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (PGPException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (SignatureException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_SIG,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
progress(R.string.progress_done,100);
if (!nfcSignOps.isEmpty()) {
log.add(LogType.MSG_MF_REQUIRE_DIVERT,indent);
return new PgpEditKeyResult(log,nfcSignOps.build());
}
log.add(LogType.MSG_MF_SUCCESS,indent);
return new PgpEditKeyResult(OperationResult.RESULT_OK,log,new UncachedKeyRing(sKR));
}",0.999197121532011
8312,"/** 
 * This method introduces a list of modifications specified by a SaveKeyringParcel to a WrappedSecretKeyRing. This method relies on WrappedSecretKeyRing's canonicalization property! Note that PGPPublicKeyRings can not be directly modified. Instead, the corresponding PGPSecretKeyRing must be modified and consequently consolidated with its public counterpart. This is a natural workflow since pgp keyrings are immutable data structures: Old semantics are changed by adding new certificates, which implicitly override older certificates. Note that this method does not care about any ""special"" type of master key. If unlocking with a passphrase fails, the operation will fail with an unlocking error. More specific handling of errors should be done in UI code! If the passphrase is null, only a restricted subset of operations will be available, namely stripping of subkeys and changing the protection mode of dummy keys.
 */
public PgpEditKeyResult modifySecretKeyRing(CanonicalizedSecretKeyRing wsKR,CryptoInputParcel cryptoInput,SaveKeyringParcel saveParcel){
  OperationLog log=new OperationLog();
  int indent=0;
  log.add(LogType.MSG_MF,indent,KeyFormattingUtils.convertKeyIdToHex(wsKR.getMasterKeyId()));
  indent+=1;
  progress(R.string.progress_building_key,0);
  if (saveParcel.mMasterKeyId == null || saveParcel.mMasterKeyId != wsKR.getMasterKeyId()) {
    log.add(LogType.MSG_MF_ERROR_KEYID,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  PGPSecretKeyRing sKR=wsKR.getRing();
  PGPSecretKey masterSecretKey=sKR.getSecretKey();
  if (saveParcel.mFingerprint == null || !Arrays.equals(saveParcel.mFingerprint,masterSecretKey.getPublicKey().getFingerprint())) {
    log.add(LogType.MSG_MF_ERROR_FINGERPRINT,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  if (saveParcel.isEmpty()) {
    log.add(LogType.MSG_MF_ERROR_NOOP,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  if (isDummy(masterSecretKey) || saveParcel.isRestrictedOnly()) {
    log.add(LogType.MSG_MF_RESTRICTED_MODE,indent);
    return internalRestricted(sKR,saveParcel,log);
  }
  if (!isDivertToCard(masterSecretKey) && !cryptoInput.hasPassphrase()) {
    log.add(LogType.MSG_MF_REQUIRE_PASSPHRASE,indent);
    return new PgpEditKeyResult(log,RequiredInputParcel.createRequiredSignPassphrase(masterSecretKey.getKeyID(),masterSecretKey.getKeyID(),cryptoInput.getSignatureTime()));
  }
  PGPPublicKey masterPublicKey=masterSecretKey.getPublicKey();
  int masterKeyFlags=readKeyFlags(masterPublicKey) | KeyFlags.CERTIFY_OTHER;
  Date expiryTime=wsKR.getPublicKey().getExpiryTime();
  long masterKeyExpiry=expiryTime != null ? expiryTime.getTime() / 1000 : 0L;
  return internal(sKR,masterSecretKey,masterKeyFlags,masterKeyExpiry,cryptoInput,saveParcel,log);
}","/** 
 * This method introduces a list of modifications specified by a SaveKeyringParcel to a WrappedSecretKeyRing. This method relies on WrappedSecretKeyRing's canonicalization property! Note that PGPPublicKeyRings can not be directly modified. Instead, the corresponding PGPSecretKeyRing must be modified and consequently consolidated with its public counterpart. This is a natural workflow since pgp keyrings are immutable data structures: Old semantics are changed by adding new certificates, which implicitly override older certificates. Note that this method does not care about any ""special"" type of master key. If unlocking with a passphrase fails, the operation will fail with an unlocking error. More specific handling of errors should be done in UI code! If the passphrase is null, only a restricted subset of operations will be available, namely stripping of subkeys and changing the protection mode of dummy keys.
 */
public PgpEditKeyResult modifySecretKeyRing(CanonicalizedSecretKeyRing wsKR,CryptoInputParcel cryptoInput,SaveKeyringParcel saveParcel){
  OperationLog log=new OperationLog();
  int indent=0;
  log.add(LogType.MSG_MF,indent,KeyFormattingUtils.convertKeyIdToHex(wsKR.getMasterKeyId()));
  indent+=1;
  progress(R.string.progress_building_key,0);
  if (saveParcel.mMasterKeyId == null || saveParcel.mMasterKeyId != wsKR.getMasterKeyId()) {
    log.add(LogType.MSG_MF_ERROR_KEYID,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  PGPSecretKeyRing sKR=wsKR.getRing();
  PGPSecretKey masterSecretKey=sKR.getSecretKey();
  if (saveParcel.mFingerprint == null || !Arrays.equals(saveParcel.mFingerprint,masterSecretKey.getPublicKey().getFingerprint())) {
    log.add(LogType.MSG_MF_ERROR_FINGERPRINT,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  if (saveParcel.isEmpty()) {
    log.add(LogType.MSG_MF_ERROR_NOOP,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  if (isDummy(masterSecretKey) || saveParcel.isRestrictedOnly()) {
    log.add(LogType.MSG_MF_RESTRICTED_MODE,indent);
    return internalRestricted(sKR,saveParcel,log);
  }
  if (!isDivertToCard(masterSecretKey) && !cryptoInput.hasPassphrase()) {
    log.add(LogType.MSG_MF_REQUIRE_PASSPHRASE,indent);
    return new PgpEditKeyResult(log,RequiredInputParcel.createRequiredSignPassphrase(masterSecretKey.getKeyID(),masterSecretKey.getKeyID(),cryptoInput.getSignatureTime()));
  }
  PGPPublicKey masterPublicKey=masterSecretKey.getPublicKey();
  int masterKeyFlags=readKeyFlags(masterPublicKey) | KeyFlags.CERTIFY_OTHER;
  Date expiryTime=wsKR.getPublicKey().getExpiryTime();
  long masterKeyExpiry=expiryTime != null ? expiryTime.getTime() / 1000 : 0L;
  return internal(sKR,masterSecretKey,masterKeyFlags,masterKeyExpiry,cryptoInput,saveParcel,log,indent);
}",0.9987742952197514
8313,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main_activity);
  Fragment mainFragment=new KeyListFragment();
  FragmentManager fm=getSupportFragmentManager();
  FragmentTransaction transaction=fm.beginTransaction();
  transaction.replace(R.id.main_fragment_container,mainFragment);
  transaction.commit();
  mToolbar=(Toolbar)findViewById(R.id.toolbar);
  mToolbar.setTitle(R.string.app_name);
  setSupportActionBar(mToolbar);
  result=new Drawer().withActivity(this).withHeader(R.layout.main_drawer_header).withToolbar(mToolbar).addDrawerItems(new PrimaryDrawerItem().withName(R.string.nav_keys).withIcon(CommunityMaterial.Icon.cmd_key).withIdentifier(1).withCheckable(false),new PrimaryDrawerItem().withName(R.string.nav_encrypt_decrypt).withIcon(FontAwesome.Icon.faw_lock).withIdentifier(2).withCheckable(false),new PrimaryDrawerItem().withName(R.string.title_api_registered_apps).withIcon(CommunityMaterial.Icon.cmd_apps).withIdentifier(3).withCheckable(false)).addStickyDrawerItems(new PrimaryDrawerItem().withName(R.string.menu_preferences).withIcon(GoogleMaterial.Icon.gmd_settings).withIdentifier(4).withCheckable(false),new PrimaryDrawerItem().withName(R.string.menu_help).withIcon(CommunityMaterial.Icon.cmd_help_circle).withIdentifier(5).withCheckable(false)).withOnDrawerItemClickListener(new Drawer.OnDrawerItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id,    IDrawerItem drawerItem){
      if (drawerItem != null) {
        Intent intent=null;
switch (drawerItem.getIdentifier()) {
case 1:
          onKeysSelected();
        break;
case 2:
      onEnDecryptSelected();
    break;
case 3:
  onAppsSelected();
break;
case 4:
intent=new Intent(MainActivity.this,SettingsActivity.class);
break;
case 5:
intent=new Intent(MainActivity.this,HelpActivity.class);
break;
}
if (intent != null) {
MainActivity.this.startActivity(intent);
}
}
}
}
).withSelectedItem(-1).withSavedInstance(savedInstanceState).build();
Preferences prefs=Preferences.getPreferences(this);
if (prefs.isFirstTime()) {
Intent intent=new Intent(this,CreateKeyActivity.class);
intent.putExtra(CreateKeyActivity.EXTRA_FIRST_TIME,true);
startActivity(intent);
finish();
return;
}
Intent data=getIntent();
if (data != null && data.hasExtra(OperationResult.EXTRA_RESULT)) {
OperationResult result=data.getParcelableExtra(OperationResult.EXTRA_RESULT);
result.createNotify(this).show();
}
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main_activity);
  mToolbar=(Toolbar)findViewById(R.id.toolbar);
  mToolbar.setTitle(R.string.app_name);
  setSupportActionBar(mToolbar);
  mDrawerResult=new Drawer().withActivity(this).withHeader(R.layout.main_drawer_header).withToolbar(mToolbar).addDrawerItems(new PrimaryDrawerItem().withName(R.string.nav_keys).withIcon(CommunityMaterial.Icon.cmd_key).withIdentifier(1).withCheckable(false),new PrimaryDrawerItem().withName(R.string.nav_encrypt_decrypt).withIcon(FontAwesome.Icon.faw_lock).withIdentifier(2).withCheckable(false),new PrimaryDrawerItem().withName(R.string.title_api_registered_apps).withIcon(CommunityMaterial.Icon.cmd_apps).withIdentifier(3).withCheckable(false)).addStickyDrawerItems(new PrimaryDrawerItem().withName(R.string.menu_preferences).withIcon(GoogleMaterial.Icon.gmd_settings).withIdentifier(4).withCheckable(false),new PrimaryDrawerItem().withName(R.string.menu_help).withIcon(CommunityMaterial.Icon.cmd_help_circle).withIdentifier(5).withCheckable(false)).withOnDrawerItemClickListener(new Drawer.OnDrawerItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id,    IDrawerItem drawerItem){
      if (drawerItem != null) {
        Intent intent=null;
switch (drawerItem.getIdentifier()) {
case 1:
          onKeysSelected();
        break;
case 2:
      onEnDecryptSelected();
    break;
case 3:
  onAppsSelected();
break;
case 4:
intent=new Intent(MainActivity.this,SettingsActivity.class);
break;
case 5:
intent=new Intent(MainActivity.this,HelpActivity.class);
break;
}
if (intent != null) {
MainActivity.this.startActivity(intent);
}
}
}
}
).withSelectedItem(-1).withSavedInstance(savedInstanceState).build();
Preferences prefs=Preferences.getPreferences(this);
if (prefs.isFirstTime()) {
Intent intent=new Intent(this,CreateKeyActivity.class);
intent.putExtra(CreateKeyActivity.EXTRA_FIRST_TIME,true);
startActivity(intent);
finish();
return;
}
Intent data=getIntent();
if (data != null && data.hasExtra(OperationResult.EXTRA_RESULT)) {
OperationResult result=data.getParcelableExtra(OperationResult.EXTRA_RESULT);
result.createNotify(this).show();
}
if (savedInstanceState == null) {
onKeysSelected();
}
}",0.8923203623635989
8314,"private boolean onEnDecryptSelected(){
  mToolbar.setTitle(R.string.nav_encrypt_decrypt);
  clearFragments();
  if (mEncryptDecryptOverviewFragment == null) {
    mEncryptDecryptOverviewFragment=new EncryptDecryptOverviewFragment();
  }
  setFragment(mEncryptDecryptOverviewFragment);
  return true;
}","private void onEnDecryptSelected(){
  mToolbar.setTitle(R.string.nav_encrypt_decrypt);
  Fragment frag=new EncryptDecryptOverviewFragment();
  setFragment(frag,true);
}",0.6865671641791045
8315,"private void setFragment(Fragment fragment,boolean addToBackStack){
  this.mLastUsedFragment=fragment;
  FragmentTransaction ft=getSupportFragmentManager().beginTransaction();
  ft.replace(R.id.main_fragment_container,fragment);
  if (addToBackStack) {
    ft.addToBackStack(null);
  }
  ft.commit();
}","private void setFragment(Fragment fragment,boolean addToBackStack){
  FragmentManager fragmentManager=getSupportFragmentManager();
  fragmentManager.popBackStack(null,FragmentManager.POP_BACK_STACK_INCLUSIVE);
  FragmentTransaction ft=fragmentManager.beginTransaction();
  ft.replace(R.id.main_fragment_container,fragment);
  if (addToBackStack) {
    ft.addToBackStack(null);
  }
  ft.commit();
}",0.2804005722460658
8316,"@Override protected void onSaveInstanceState(Bundle outState){
  outState=result.saveInstanceState(outState);
  super.onSaveInstanceState(outState);
}","@Override protected void onSaveInstanceState(Bundle outState){
  outState=mDrawerResult.saveInstanceState(outState);
  super.onSaveInstanceState(outState);
}",0.977198697068404
8317,"private boolean onAppsSelected(){
  mToolbar.setTitle(R.string.nav_apps);
  clearFragments();
  if (mAppsListFragment == null) {
    mAppsListFragment=new AppsListFragment();
  }
  setFragment(mAppsListFragment);
  return true;
}","private void onAppsSelected(){
  mToolbar.setTitle(R.string.nav_apps);
  Fragment frag=new AppsListFragment();
  setFragment(frag,true);
}",0.7138964577656676
8318,"private boolean onKeysSelected(){
  mToolbar.setTitle(R.string.app_name);
  clearFragments();
  if (mKeyListFragment == null) {
    mKeyListFragment=new KeyListFragment();
  }
  setFragment(mKeyListFragment,false);
  return true;
}","private void onKeysSelected(){
  mToolbar.setTitle(R.string.app_name);
  Fragment frag=new KeyListFragment();
  setFragment(frag,false);
}",0.7208672086720868
8319,"@Override public void onBackPressed(){
  if (result != null && result.isDrawerOpen()) {
    result.closeDrawer();
  }
 else {
    super.onBackPressed();
  }
}","@Override public void onBackPressed(){
  if (mDrawerResult != null && mDrawerResult.isDrawerOpen()) {
    mDrawerResult.closeDrawer();
  }
 else {
    super.onBackPressed();
  }
}",0.9376854599406528
8320,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main_activity);
  Fragment mainFragment=new KeyListFragment();
  FragmentManager fm=getSupportFragmentManager();
  FragmentTransaction transaction=fm.beginTransaction();
  transaction.replace(R.id.main_fragment_container,mainFragment);
  transaction.commit();
  mToolbar=(Toolbar)findViewById(R.id.toolbar);
  mToolbar.setTitle(R.string.app_name);
  setSupportActionBar(mToolbar);
  result=new Drawer().withActivity(this).withHeader(R.layout.main_drawer_header).withToolbar(mToolbar).addDrawerItems(new PrimaryDrawerItem().withName(R.string.nav_keys).withIcon(CommunityMaterial.Icon.cmd_key).withIdentifier(1).withCheckable(false),new PrimaryDrawerItem().withName(R.string.nav_encrypt_decrypt).withIcon(FontAwesome.Icon.faw_lock).withIdentifier(2).withCheckable(false),new PrimaryDrawerItem().withName(R.string.title_api_registered_apps).withIcon(CommunityMaterial.Icon.cmd_apps).withIdentifier(3).withCheckable(false)).addStickyDrawerItems(new PrimaryDrawerItem().withName(R.string.menu_preferences).withIcon(GoogleMaterial.Icon.gmd_settings).withIdentifier(4).withCheckable(false),new PrimaryDrawerItem().withName(R.string.menu_help).withIcon(CommunityMaterial.Icon.cmd_help_circle).withIdentifier(5).withCheckable(false)).withOnDrawerItemClickListener(new Drawer.OnDrawerItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id,    IDrawerItem drawerItem){
      if (drawerItem != null) {
        Intent intent=null;
switch (drawerItem.getIdentifier()) {
case 1:
          onKeysSelected();
        break;
case 2:
      onEnDecryptSelected();
    break;
case 3:
  onAppsSelected();
break;
case 4:
intent=new Intent(MainActivity.this,SettingsActivity.class);
break;
case 5:
intent=new Intent(MainActivity.this,HelpActivity.class);
break;
}
if (intent != null) {
MainActivity.this.startActivity(intent);
}
}
}
}
).withSelectedItem(-1).withSavedInstance(savedInstanceState).build();
Preferences prefs=Preferences.getPreferences(this);
if (prefs.isFirstTime()) {
Intent intent=new Intent(this,CreateKeyActivity.class);
intent.putExtra(CreateKeyActivity.EXTRA_FIRST_TIME,true);
startActivity(intent);
finish();
return;
}
Intent data=getIntent();
if (data != null && data.hasExtra(OperationResult.EXTRA_RESULT)) {
OperationResult result=data.getParcelableExtra(OperationResult.EXTRA_RESULT);
result.createNotify(this).show();
}
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main_activity);
  mToolbar=(Toolbar)findViewById(R.id.toolbar);
  mToolbar.setTitle(R.string.app_name);
  setSupportActionBar(mToolbar);
  mDrawerResult=new Drawer().withActivity(this).withHeader(R.layout.main_drawer_header).withToolbar(mToolbar).addDrawerItems(new PrimaryDrawerItem().withName(R.string.nav_keys).withIcon(CommunityMaterial.Icon.cmd_key).withIdentifier(1).withCheckable(false),new PrimaryDrawerItem().withName(R.string.nav_encrypt_decrypt).withIcon(FontAwesome.Icon.faw_lock).withIdentifier(2).withCheckable(false),new PrimaryDrawerItem().withName(R.string.title_api_registered_apps).withIcon(CommunityMaterial.Icon.cmd_apps).withIdentifier(3).withCheckable(false)).addStickyDrawerItems(new PrimaryDrawerItem().withName(R.string.menu_preferences).withIcon(GoogleMaterial.Icon.gmd_settings).withIdentifier(4).withCheckable(false),new PrimaryDrawerItem().withName(R.string.menu_help).withIcon(CommunityMaterial.Icon.cmd_help_circle).withIdentifier(5).withCheckable(false)).withOnDrawerItemClickListener(new Drawer.OnDrawerItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id,    IDrawerItem drawerItem){
      if (drawerItem != null) {
        Intent intent=null;
switch (drawerItem.getIdentifier()) {
case 1:
          onKeysSelected();
        break;
case 2:
      onEnDecryptSelected();
    break;
case 3:
  onAppsSelected();
break;
case 4:
intent=new Intent(MainActivity.this,SettingsActivity.class);
break;
case 5:
intent=new Intent(MainActivity.this,HelpActivity.class);
break;
}
if (intent != null) {
MainActivity.this.startActivity(intent);
}
}
}
}
).withSelectedItem(-1).withSavedInstance(savedInstanceState).build();
Preferences prefs=Preferences.getPreferences(this);
if (prefs.isFirstTime()) {
Intent intent=new Intent(this,CreateKeyActivity.class);
intent.putExtra(CreateKeyActivity.EXTRA_FIRST_TIME,true);
startActivity(intent);
finish();
return;
}
Intent data=getIntent();
if (data != null && data.hasExtra(OperationResult.EXTRA_RESULT)) {
OperationResult result=data.getParcelableExtra(OperationResult.EXTRA_RESULT);
result.createNotify(this).show();
}
if (savedInstanceState == null) {
onKeysSelected();
}
}",0.8923203623635989
8321,"private boolean onEnDecryptSelected(){
  mToolbar.setTitle(R.string.nav_encrypt_decrypt);
  clearFragments();
  if (mEncryptDecryptOverviewFragment == null) {
    mEncryptDecryptOverviewFragment=new EncryptDecryptOverviewFragment();
  }
  setFragment(mEncryptDecryptOverviewFragment);
  return true;
}","private void onEnDecryptSelected(){
  mToolbar.setTitle(R.string.nav_encrypt_decrypt);
  Fragment frag=new EncryptDecryptOverviewFragment();
  setFragment(frag,true);
}",0.6865671641791045
8322,"private void setFragment(Fragment fragment,boolean addToBackStack){
  this.mLastUsedFragment=fragment;
  FragmentTransaction ft=getSupportFragmentManager().beginTransaction();
  ft.replace(R.id.main_fragment_container,fragment);
  if (addToBackStack) {
    ft.addToBackStack(null);
  }
  ft.commit();
}","private void setFragment(Fragment fragment,boolean addToBackStack){
  FragmentManager fragmentManager=getSupportFragmentManager();
  fragmentManager.popBackStack(null,FragmentManager.POP_BACK_STACK_INCLUSIVE);
  FragmentTransaction ft=fragmentManager.beginTransaction();
  ft.replace(R.id.main_fragment_container,fragment);
  if (addToBackStack) {
    ft.addToBackStack(null);
  }
  ft.commit();
}",0.2804005722460658
8323,"@Override protected void onSaveInstanceState(Bundle outState){
  outState=result.saveInstanceState(outState);
  super.onSaveInstanceState(outState);
}","@Override protected void onSaveInstanceState(Bundle outState){
  outState=mDrawerResult.saveInstanceState(outState);
  super.onSaveInstanceState(outState);
}",0.977198697068404
8324,"private boolean onAppsSelected(){
  mToolbar.setTitle(R.string.nav_apps);
  clearFragments();
  if (mAppsListFragment == null) {
    mAppsListFragment=new AppsListFragment();
  }
  setFragment(mAppsListFragment);
  return true;
}","private void onAppsSelected(){
  mToolbar.setTitle(R.string.nav_apps);
  Fragment frag=new AppsListFragment();
  setFragment(frag,true);
}",0.7138964577656676
8325,"private boolean onKeysSelected(){
  mToolbar.setTitle(R.string.app_name);
  clearFragments();
  if (mKeyListFragment == null) {
    mKeyListFragment=new KeyListFragment();
  }
  setFragment(mKeyListFragment,false);
  return true;
}","private void onKeysSelected(){
  mToolbar.setTitle(R.string.app_name);
  Fragment frag=new KeyListFragment();
  setFragment(frag,false);
}",0.7208672086720868
8326,"@Override public void onBackPressed(){
  if (result != null && result.isDrawerOpen()) {
    result.closeDrawer();
  }
 else {
    super.onBackPressed();
  }
}","@Override public void onBackPressed(){
  if (mDrawerResult != null && mDrawerResult.isDrawerOpen()) {
    mDrawerResult.closeDrawer();
  }
 else {
    super.onBackPressed();
  }
}",0.9376854599406528
8327,"public OperationResult execute(SaveKeyringParcel saveParcel,CryptoInputParcel cryptoInput){
  OperationLog log=new OperationLog();
  log.add(LogType.MSG_ED,0);
  if (saveParcel == null) {
    log.add(LogType.MSG_ED_ERROR_NO_PARCEL,1);
    return new EditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
  }
  PgpEditKeyResult modifyResult;
{
    PgpKeyOperation keyOperations=new PgpKeyOperation(new ProgressScaler(mProgressable,10,60,100),mCancelled);
    if (saveParcel.mMasterKeyId != null) {
      try {
        log.add(LogType.MSG_ED_FETCHING,1,KeyFormattingUtils.convertKeyIdToHex(saveParcel.mMasterKeyId));
        CanonicalizedSecretKeyRing secRing=mProviderHelper.getCanonicalizedSecretKeyRing(saveParcel.mMasterKeyId);
        modifyResult=keyOperations.modifySecretKeyRing(secRing,cryptoInput,saveParcel,log);
        if (modifyResult.isPending()) {
          return modifyResult;
        }
      }
 catch (      NotFoundException e) {
        log.add(LogType.MSG_ED_ERROR_KEY_NOT_FOUND,2);
        return new EditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
      }
    }
 else {
      modifyResult=keyOperations.createSecretKeyRing(saveParcel);
    }
  }
  log.add(modifyResult,1);
  if (checkCancelled()) {
    log.add(LogType.MSG_OPERATION_CANCELLED,0);
    return new EditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
  }
  if (!modifyResult.success()) {
    return new EditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
  }
  mProgressable.setPreventCancel();
  UncachedKeyRing ring=modifyResult.getRing();
  SaveKeyringResult saveResult=mProviderHelper.saveSecretKeyRing(ring,new ProgressScaler(mProgressable,60,95,100));
  log.add(saveResult,1);
  if (!saveResult.success()) {
    return new EditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
  }
  if (saveParcel.mNewUnlock != null) {
    log.add(LogType.MSG_ED_CACHING_NEW,1);
    PassphraseCacheService.addCachedPassphrase(mContext,ring.getMasterKeyId(),ring.getMasterKeyId(),saveParcel.mNewUnlock.mNewPassphrase != null ? saveParcel.mNewUnlock.mNewPassphrase : saveParcel.mNewUnlock.mNewPin,ring.getPublicKey().getPrimaryUserIdWithFallback());
  }
  updateProgress(R.string.progress_done,100,100);
  ContactSyncAdapterService.requestSync();
  log.add(LogType.MSG_ED_SUCCESS,0);
  return new EditKeyResult(EditKeyResult.RESULT_OK,log,ring.getMasterKeyId());
}","public OperationResult execute(SaveKeyringParcel saveParcel,CryptoInputParcel cryptoInput){
  OperationLog log=new OperationLog();
  log.add(LogType.MSG_ED,0);
  if (saveParcel == null) {
    log.add(LogType.MSG_ED_ERROR_NO_PARCEL,1);
    return new EditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
  }
  PgpEditKeyResult modifyResult;
{
    PgpKeyOperation keyOperations=new PgpKeyOperation(new ProgressScaler(mProgressable,10,60,100),mCancelled);
    if (saveParcel.mMasterKeyId != null) {
      try {
        log.add(LogType.MSG_ED_FETCHING,1,KeyFormattingUtils.convertKeyIdToHex(saveParcel.mMasterKeyId));
        CanonicalizedSecretKeyRing secRing=mProviderHelper.getCanonicalizedSecretKeyRing(saveParcel.mMasterKeyId);
        modifyResult=keyOperations.modifySecretKeyRing(secRing,cryptoInput,saveParcel,log,2);
        if (modifyResult.isPending()) {
          return modifyResult;
        }
      }
 catch (      NotFoundException e) {
        log.add(LogType.MSG_ED_ERROR_KEY_NOT_FOUND,2);
        return new EditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
      }
    }
 else {
      modifyResult=keyOperations.createSecretKeyRing(saveParcel);
    }
  }
  log.add(modifyResult,1);
  if (checkCancelled()) {
    log.add(LogType.MSG_OPERATION_CANCELLED,0);
    return new EditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
  }
  if (!modifyResult.success()) {
    return new EditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
  }
  mProgressable.setPreventCancel();
  UncachedKeyRing ring=modifyResult.getRing();
  SaveKeyringResult saveResult=mProviderHelper.saveSecretKeyRing(ring,new ProgressScaler(mProgressable,60,95,100));
  log.add(saveResult,1);
  if (!saveResult.success()) {
    return new EditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
  }
  if (saveParcel.mNewUnlock != null) {
    log.add(LogType.MSG_ED_CACHING_NEW,1);
    PassphraseCacheService.addCachedPassphrase(mContext,ring.getMasterKeyId(),ring.getMasterKeyId(),saveParcel.mNewUnlock.mNewPassphrase != null ? saveParcel.mNewUnlock.mNewPassphrase : saveParcel.mNewUnlock.mNewPin,ring.getPublicKey().getPrimaryUserIdWithFallback());
  }
  updateProgress(R.string.progress_done,100,100);
  ContactSyncAdapterService.requestSync();
  log.add(LogType.MSG_ED_SUCCESS,0);
  return new EditKeyResult(EditKeyResult.RESULT_OK,log,ring.getMasterKeyId());
}",0.9995735607675906
8328,"private PgpEditKeyResult internal(PGPSecretKeyRing sKR,PGPSecretKey masterSecretKey,int masterKeyFlags,long masterKeyExpiry,CryptoInputParcel cryptoInput,SaveKeyringParcel saveParcel,OperationLog log){
  int indent=1;
  NfcSignOperationsBuilder nfcSignOps=new NfcSignOperationsBuilder(cryptoInput.getSignatureTime(),masterSecretKey.getKeyID(),masterSecretKey.getKeyID());
  NfcKeyToCardOperationsBuilder nfcKeyToCardOps=new NfcKeyToCardOperationsBuilder(masterSecretKey.getKeyID());
  progress(R.string.progress_modify,0);
  PGPPublicKey masterPublicKey=masterSecretKey.getPublicKey();
  PGPPrivateKey masterPrivateKey;
  if (isDivertToCard(masterSecretKey)) {
    masterPrivateKey=null;
    log.add(LogType.MSG_MF_DIVERT,indent);
  }
 else {
    progress(R.string.progress_modify_unlock,10);
    log.add(LogType.MSG_MF_UNLOCK,indent);
{
      try {
        PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
        masterPrivateKey=masterSecretKey.extractPrivateKey(keyDecryptor);
      }
 catch (      PGPException e) {
        log.add(LogType.MSG_MF_UNLOCK_ERROR,indent + 1);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
      }
    }
  }
  try {
    if (checkCancelled()) {
      log.add(LogType.MSG_OPERATION_CANCELLED,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
    }
{
      PGPPublicKey modifiedPublicKey=masterPublicKey;
      subProgressPush(15,23);
      for (int i=0; i < saveParcel.mAddUserIds.size(); i++) {
        progress(R.string.progress_modify_adduid,(i - 1) * (100 / saveParcel.mAddUserIds.size()));
        String userId=saveParcel.mAddUserIds.get(i);
        log.add(LogType.MSG_MF_UID_ADD,indent,userId);
        if (""String_Node_Str"".equals(userId)) {
          log.add(LogType.MSG_MF_UID_ERROR_EMPTY,indent + 1);
          return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
        }
        @SuppressWarnings(""String_Node_Str"") Iterator<PGPSignature> it=modifiedPublicKey.getSignaturesForID(userId);
        if (it != null) {
          for (          PGPSignature cert : new IterableIterator<>(it)) {
            if (cert.getKeyID() != masterPublicKey.getKeyID()) {
              log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
              return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
            }
            if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION || cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
              modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,cert);
            }
          }
        }
        boolean isPrimary=saveParcel.mChangePrimaryUserId != null && userId.equals(saveParcel.mChangePrimaryUserId);
        try {
          PGPSignature cert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,isPrimary,masterKeyFlags,masterKeyExpiry);
          modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
        }
 catch (        NfcInteractionNeeded e) {
          nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
        }
      }
      subProgressPop();
      subProgressPush(23,32);
      for (int i=0; i < saveParcel.mAddUserAttribute.size(); i++) {
        progress(R.string.progress_modify_adduat,(i - 1) * (100 / saveParcel.mAddUserAttribute.size()));
        WrappedUserAttribute attribute=saveParcel.mAddUserAttribute.get(i);
switch (attribute.getType()) {
case WrappedUserAttribute.UAT_NONE:
          log.add(LogType.MSG_MF_UAT_ERROR_EMPTY,indent);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
case WrappedUserAttribute.UAT_IMAGE:
      log.add(LogType.MSG_MF_UAT_ADD_IMAGE,indent);
    break;
default :
  log.add(LogType.MSG_MF_UAT_ADD_UNKNOWN,indent);
break;
}
PGPUserAttributeSubpacketVector vector=attribute.getVector();
try {
PGPSignature cert=generateUserAttributeSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,vector);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,vector,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(32,40);
for (int i=0; i < saveParcel.mRevokeUserIds.size(); i++) {
progress(R.string.progress_modify_revokeuid,(i - 1) * (100 / saveParcel.mRevokeUserIds.size()));
String userId=saveParcel.mRevokeUserIds.get(i);
log.add(LogType.MSG_MF_UID_REVOKE,indent,userId);
boolean exists=false;
for (String uid : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
if (userId.equals(uid)) {
exists=true;
break;
}
}
if (!exists) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_REVOKE,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
try {
PGPSignature cert=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
if (saveParcel.mChangePrimaryUserId != null) {
progress(R.string.progress_modify_primaryuid,40);
boolean ok=false;
log.add(LogType.MSG_MF_UID_PRIMARY,indent,saveParcel.mChangePrimaryUserId);
indent+=1;
for (String userId : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
boolean isRevoked=false;
PGPSignature currentCert=null;
for (PGPSignature cert : new IterableIterator<PGPSignature>(modifiedPublicKey.getSignaturesForID(userId))) {
if (cert.getKeyID() != masterPublicKey.getKeyID()) {
  log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION) {
  isRevoked=true;
  continue;
}
if (cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
  currentCert=cert;
}
}
if (currentCert == null) {
log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (isRevoked) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  log.add(LogType.MSG_MF_ERROR_REVOKED_PRIMARY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
continue;
}
if (currentCert.getHashedSubPackets() != null && currentCert.getHashedSubPackets().isPrimaryUserID()) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  ok=true;
  continue;
}
log.add(LogType.MSG_MF_PRIMARY_REPLACE_OLD,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,false,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
continue;
}
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
log.add(LogType.MSG_MF_PRIMARY_NEW,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,true,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
ok=true;
}
}
indent-=1;
if (!ok) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_PRIMARY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
}
if (modifiedPublicKey != masterPublicKey) {
masterSecretKey=PGPSecretKey.replacePublicKey(masterSecretKey,modifiedPublicKey);
masterPublicKey=modifiedPublicKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
}
}
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
subProgressPush(50,60);
for (int i=0; i < saveParcel.mChangeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeychange,(i - 1) * (100 / saveParcel.mChangeSubKeys.size()));
SaveKeyringParcel.SubkeyChange change=saveParcel.mChangeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_CHANGE,indent,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
PGPSecretKey sKey=sKR.getSecretKey(change.mKeyId);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mDummyStrip) {
sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey());
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
 else if (change.mMoveKeyToCard) {
if (checkSmartCardCompatibility(sKey,log,indent + 1)) {
log.add(LogType.MSG_MF_KEYTOCARD_START,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
nfcKeyToCardOps.addSubkey(change.mKeyId);
}
 else {
return new PgpEditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
}
}
 else if (change.mDummyDivert != null) {
if (change.mDummyDivert.length != 16) {
log.add(LogType.MSG_MF_ERROR_DIVERT_SERIAL,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
log.add(LogType.MSG_MF_KEYTOCARD_FINISH,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId),Hex.toHexString(change.mDummyDivert,8,6));
sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey(),change.mDummyDivert);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
if (!change.mRecertify && (change.mExpiry == null && change.mFlags == null)) {
continue;
}
if (change.mExpiry != null && change.mExpiry != 0 && new Date(change.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mKeyId == masterPublicKey.getKeyID()) {
int flags=change.mFlags == null ? masterKeyFlags : change.mFlags;
long expiry=change.mExpiry == null ? masterKeyExpiry : change.mExpiry;
if ((flags & KeyFlags.CERTIFY_OTHER) != KeyFlags.CERTIFY_OTHER) {
log.add(LogType.MSG_MF_ERROR_NO_CERTIFY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=updateMasterCertificates(masterSecretKey,masterPrivateKey,masterPublicKey,flags,expiry,cryptoInput,nfcSignOps,indent,log);
if (pKey == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
masterSecretKey=PGPSecretKey.replacePublicKey(sKey,pKey);
masterPublicKey=pKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
continue;
}
PGPPublicKey pKey=sKey.getPublicKey();
int flags=change.mFlags == null ? readKeyFlags(pKey) : change.mFlags;
long expiry;
if (change.mExpiry == null) {
long valid=pKey.getValidSeconds();
expiry=valid == 0 ? 0 : pKey.getCreationTime().getTime() / 1000 + pKey.getValidSeconds();
}
 else {
expiry=change.mExpiry;
}
for (PGPSignature sig : new IterableIterator<PGPSignature>(pKey.getSignatures())) {
if ((change.mExpiry == null || change.mExpiry == 0L) && sig.getSignatureType() == PGPSignature.SUBKEY_REVOCATION) {
expiry=0;
}
pKey=PGPPublicKey.removeCertification(pKey,sig);
}
PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
PGPPrivateKey subPrivateKey=sKey.extractPrivateKey(keyDecryptor);
PGPSignature sig=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,subPrivateKey,pKey,flags,expiry);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
subProgressPop();
subProgressPush(60,65);
for (int i=0; i < saveParcel.mRevokeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeyrevoke,(i - 1) * (100 / saveParcel.mRevokeSubKeys.size()));
long revocation=saveParcel.mRevokeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_REVOKE,indent,KeyFormattingUtils.convertKeyIdToHex(revocation));
PGPSecretKey sKey=sKR.getSecretKey(revocation);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(revocation));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=sKey.getPublicKey();
try {
PGPSignature sig=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,pKey);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(70,90);
for (int i=0; i < saveParcel.mAddSubKeys.size(); i++) {
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
progress(R.string.progress_modify_subkeyadd,(i - 1) * (100 / saveParcel.mAddSubKeys.size()));
SaveKeyringParcel.SubkeyAdd add=saveParcel.mAddSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_NEW,indent,KeyFormattingUtils.getAlgorithmInfo(add.mAlgorithm,add.mKeySize,add.mCurve));
if (add.mExpiry == null) {
log.add(LogType.MSG_MF_ERROR_NULL_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (add.mExpiry > 0L && new Date(add.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
subProgressPush((i - 1) * (100 / saveParcel.mAddSubKeys.size()),i * (100 / saveParcel.mAddSubKeys.size()));
PGPKeyPair keyPair=createKey(add,log,indent);
subProgressPop();
if (keyPair == null) {
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=keyPair.getPublicKey();
try {
PGPSignature cert=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,keyPair.getPrivateKey(),pKey,add.mFlags,add.mExpiry);
pKey=PGPPublicKey.addSubkeyBindingCertification(pKey,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
PGPSecretKey sKey;
{
PGPDigestCalculator encryptorHashCalc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_ENCRYPTOR_HASH_ALGO);
PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PgpConstants.SECRET_KEY_ENCRYPTOR_SYMMETRIC_ALGO,encryptorHashCalc,PgpConstants.SECRET_KEY_ENCRYPTOR_S2K_COUNT).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_SIGNATURE_CHECKSUM_HASH_ALGO);
sKey=new PGPSecretKey(keyPair.getPrivateKey(),pKey,sha1Calc,false,keyEncryptor);
}
log.add(LogType.MSG_MF_SUBKEY_NEW_ID,indent + 1,KeyFormattingUtils.convertKeyIdToHex(sKey.getKeyID()));
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
subProgressPop();
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
if (saveParcel.mNewUnlock != null) {
progress(R.string.progress_modify_passphrase,90);
log.add(LogType.MSG_MF_PASSPHRASE,indent);
indent+=1;
sKR=applyNewUnlock(sKR,masterPublicKey,masterPrivateKey,cryptoInput.getPassphrase(),saveParcel.mNewUnlock,log,indent);
if (sKR == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
indent-=1;
}
}
 catch (IOException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_ENCODE,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (PGPException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (SignatureException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_SIG,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
progress(R.string.progress_done,100);
if (!nfcSignOps.isEmpty() && !nfcKeyToCardOps.isEmpty()) {
log.add(LogType.MSG_MF_ERROR_CONFLICTING_NFC_COMMANDS,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (!nfcSignOps.isEmpty()) {
log.add(LogType.MSG_MF_REQUIRE_DIVERT,indent);
return new PgpEditKeyResult(log,nfcSignOps.build());
}
if (!nfcKeyToCardOps.isEmpty()) {
log.add(LogType.MSG_MF_REQUIRE_DIVERT,indent);
return new PgpEditKeyResult(log,nfcKeyToCardOps.build());
}
log.add(LogType.MSG_MF_SUCCESS,indent);
return new PgpEditKeyResult(OperationResult.RESULT_OK,log,new UncachedKeyRing(sKR));
}","private PgpEditKeyResult internal(PGPSecretKeyRing sKR,PGPSecretKey masterSecretKey,int masterKeyFlags,long masterKeyExpiry,CryptoInputParcel cryptoInput,SaveKeyringParcel saveParcel,OperationLog log,int indent){
  NfcSignOperationsBuilder nfcSignOps=new NfcSignOperationsBuilder(cryptoInput.getSignatureTime(),masterSecretKey.getKeyID(),masterSecretKey.getKeyID());
  NfcKeyToCardOperationsBuilder nfcKeyToCardOps=new NfcKeyToCardOperationsBuilder(masterSecretKey.getKeyID());
  progress(R.string.progress_modify,0);
  PGPPublicKey masterPublicKey=masterSecretKey.getPublicKey();
  PGPPrivateKey masterPrivateKey;
  if (isDivertToCard(masterSecretKey)) {
    masterPrivateKey=null;
    log.add(LogType.MSG_MF_DIVERT,indent);
  }
 else {
    progress(R.string.progress_modify_unlock,10);
    log.add(LogType.MSG_MF_UNLOCK,indent);
{
      try {
        PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
        masterPrivateKey=masterSecretKey.extractPrivateKey(keyDecryptor);
      }
 catch (      PGPException e) {
        log.add(LogType.MSG_MF_UNLOCK_ERROR,indent + 1);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
      }
    }
  }
  try {
    if (checkCancelled()) {
      log.add(LogType.MSG_OPERATION_CANCELLED,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
    }
{
      PGPPublicKey modifiedPublicKey=masterPublicKey;
      subProgressPush(15,23);
      for (int i=0; i < saveParcel.mAddUserIds.size(); i++) {
        progress(R.string.progress_modify_adduid,(i - 1) * (100 / saveParcel.mAddUserIds.size()));
        String userId=saveParcel.mAddUserIds.get(i);
        log.add(LogType.MSG_MF_UID_ADD,indent,userId);
        if (""String_Node_Str"".equals(userId)) {
          log.add(LogType.MSG_MF_UID_ERROR_EMPTY,indent + 1);
          return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
        }
        @SuppressWarnings(""String_Node_Str"") Iterator<PGPSignature> it=modifiedPublicKey.getSignaturesForID(userId);
        if (it != null) {
          for (          PGPSignature cert : new IterableIterator<>(it)) {
            if (cert.getKeyID() != masterPublicKey.getKeyID()) {
              log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
              return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
            }
            if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION || cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
              modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,cert);
            }
          }
        }
        boolean isPrimary=saveParcel.mChangePrimaryUserId != null && userId.equals(saveParcel.mChangePrimaryUserId);
        try {
          PGPSignature cert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,isPrimary,masterKeyFlags,masterKeyExpiry);
          modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
        }
 catch (        NfcInteractionNeeded e) {
          nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
        }
      }
      subProgressPop();
      subProgressPush(23,32);
      for (int i=0; i < saveParcel.mAddUserAttribute.size(); i++) {
        progress(R.string.progress_modify_adduat,(i - 1) * (100 / saveParcel.mAddUserAttribute.size()));
        WrappedUserAttribute attribute=saveParcel.mAddUserAttribute.get(i);
switch (attribute.getType()) {
case WrappedUserAttribute.UAT_NONE:
          log.add(LogType.MSG_MF_UAT_ERROR_EMPTY,indent);
        return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
case WrappedUserAttribute.UAT_IMAGE:
      log.add(LogType.MSG_MF_UAT_ADD_IMAGE,indent);
    break;
default :
  log.add(LogType.MSG_MF_UAT_ADD_UNKNOWN,indent);
break;
}
PGPUserAttributeSubpacketVector vector=attribute.getVector();
try {
PGPSignature cert=generateUserAttributeSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,vector);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,vector,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(32,40);
for (int i=0; i < saveParcel.mRevokeUserIds.size(); i++) {
progress(R.string.progress_modify_revokeuid,(i - 1) * (100 / saveParcel.mRevokeUserIds.size()));
String userId=saveParcel.mRevokeUserIds.get(i);
log.add(LogType.MSG_MF_UID_REVOKE,indent,userId);
boolean exists=false;
for (String uid : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
if (userId.equals(uid)) {
exists=true;
break;
}
}
if (!exists) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_REVOKE,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
try {
PGPSignature cert=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId);
modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
if (saveParcel.mChangePrimaryUserId != null) {
progress(R.string.progress_modify_primaryuid,40);
boolean ok=false;
log.add(LogType.MSG_MF_UID_PRIMARY,indent,saveParcel.mChangePrimaryUserId);
indent+=1;
for (String userId : new IterableIterator<String>(modifiedPublicKey.getUserIDs())) {
boolean isRevoked=false;
PGPSignature currentCert=null;
for (PGPSignature cert : new IterableIterator<PGPSignature>(modifiedPublicKey.getSignaturesForID(userId))) {
if (cert.getKeyID() != masterPublicKey.getKeyID()) {
  log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (cert.getSignatureType() == PGPSignature.CERTIFICATION_REVOCATION) {
  isRevoked=true;
  continue;
}
if (cert.getSignatureType() == PGPSignature.NO_CERTIFICATION || cert.getSignatureType() == PGPSignature.CASUAL_CERTIFICATION || cert.getSignatureType() == PGPSignature.POSITIVE_CERTIFICATION || cert.getSignatureType() == PGPSignature.DEFAULT_CERTIFICATION) {
  currentCert=cert;
}
}
if (currentCert == null) {
log.add(LogType.MSG_MF_ERROR_INTEGRITY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (isRevoked) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  log.add(LogType.MSG_MF_ERROR_REVOKED_PRIMARY,indent);
  return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
continue;
}
if (currentCert.getHashedSubPackets() != null && currentCert.getHashedSubPackets().isPrimaryUserID()) {
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
  ok=true;
  continue;
}
log.add(LogType.MSG_MF_PRIMARY_REPLACE_OLD,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,false,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
continue;
}
if (userId.equals(saveParcel.mChangePrimaryUserId)) {
log.add(LogType.MSG_MF_PRIMARY_NEW,indent);
modifiedPublicKey=PGPPublicKey.removeCertification(modifiedPublicKey,userId,currentCert);
try {
  PGPSignature newCert=generateUserIdSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPrivateKey,masterPublicKey,userId,true,masterKeyFlags,masterKeyExpiry);
  modifiedPublicKey=PGPPublicKey.addCertification(modifiedPublicKey,userId,newCert);
}
 catch (NfcInteractionNeeded e) {
  nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
ok=true;
}
}
indent-=1;
if (!ok) {
log.add(LogType.MSG_MF_ERROR_NOEXIST_PRIMARY,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
}
if (modifiedPublicKey != masterPublicKey) {
masterSecretKey=PGPSecretKey.replacePublicKey(masterSecretKey,modifiedPublicKey);
masterPublicKey=modifiedPublicKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
}
}
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
subProgressPush(50,60);
for (int i=0; i < saveParcel.mChangeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeychange,(i - 1) * (100 / saveParcel.mChangeSubKeys.size()));
SaveKeyringParcel.SubkeyChange change=saveParcel.mChangeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_CHANGE,indent,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
PGPSecretKey sKey=sKR.getSecretKey(change.mKeyId);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mDummyStrip) {
sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey());
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
 else if (change.mMoveKeyToCard) {
if (checkSmartCardCompatibility(sKey,log,indent + 1)) {
log.add(LogType.MSG_MF_KEYTOCARD_START,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
nfcKeyToCardOps.addSubkey(change.mKeyId);
}
 else {
return new PgpEditKeyResult(EditKeyResult.RESULT_ERROR,log,null);
}
}
 else if (change.mDummyDivert != null) {
if (change.mDummyDivert.length != 16) {
log.add(LogType.MSG_MF_ERROR_DIVERT_SERIAL,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
log.add(LogType.MSG_MF_KEYTOCARD_FINISH,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId),Hex.toHexString(change.mDummyDivert,8,6));
sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey(),change.mDummyDivert);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
if (!change.mRecertify && (change.mExpiry == null && change.mFlags == null)) {
continue;
}
if (change.mExpiry != null && change.mExpiry != 0 && new Date(change.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (change.mKeyId == masterPublicKey.getKeyID()) {
int flags=change.mFlags == null ? masterKeyFlags : change.mFlags;
long expiry=change.mExpiry == null ? masterKeyExpiry : change.mExpiry;
if ((flags & KeyFlags.CERTIFY_OTHER) != KeyFlags.CERTIFY_OTHER) {
log.add(LogType.MSG_MF_ERROR_NO_CERTIFY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=updateMasterCertificates(masterSecretKey,masterPrivateKey,masterPublicKey,flags,expiry,cryptoInput,nfcSignOps,indent,log);
if (pKey == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
masterSecretKey=PGPSecretKey.replacePublicKey(sKey,pKey);
masterPublicKey=pKey;
sKR=PGPSecretKeyRing.insertSecretKey(sKR,masterSecretKey);
continue;
}
PGPPublicKey pKey=sKey.getPublicKey();
int flags=change.mFlags == null ? readKeyFlags(pKey) : change.mFlags;
long expiry;
if (change.mExpiry == null) {
long valid=pKey.getValidSeconds();
expiry=valid == 0 ? 0 : pKey.getCreationTime().getTime() / 1000 + pKey.getValidSeconds();
}
 else {
expiry=change.mExpiry;
}
for (PGPSignature sig : new IterableIterator<PGPSignature>(pKey.getSignatures())) {
if ((change.mExpiry == null || change.mExpiry == 0L) && sig.getSignatureType() == PGPSignature.SUBKEY_REVOCATION) {
expiry=0;
}
pKey=PGPPublicKey.removeCertification(pKey,sig);
}
PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
PGPPrivateKey subPrivateKey=sKey.extractPrivateKey(keyDecryptor);
PGPSignature sig=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,subPrivateKey,pKey,flags,expiry);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
subProgressPop();
subProgressPush(60,65);
for (int i=0; i < saveParcel.mRevokeSubKeys.size(); i++) {
progress(R.string.progress_modify_subkeyrevoke,(i - 1) * (100 / saveParcel.mRevokeSubKeys.size()));
long revocation=saveParcel.mRevokeSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_REVOKE,indent,KeyFormattingUtils.convertKeyIdToHex(revocation));
PGPSecretKey sKey=sKR.getSecretKey(revocation);
if (sKey == null) {
log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(revocation));
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=sKey.getPublicKey();
try {
PGPSignature sig=generateRevocationSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,pKey);
pKey=PGPPublicKey.addCertification(pKey,sig);
sKR=PGPSecretKeyRing.insertSecretKey(sKR,PGPSecretKey.replacePublicKey(sKey,pKey));
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
}
subProgressPop();
subProgressPush(70,90);
for (int i=0; i < saveParcel.mAddSubKeys.size(); i++) {
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
progress(R.string.progress_modify_subkeyadd,(i - 1) * (100 / saveParcel.mAddSubKeys.size()));
SaveKeyringParcel.SubkeyAdd add=saveParcel.mAddSubKeys.get(i);
log.add(LogType.MSG_MF_SUBKEY_NEW,indent,KeyFormattingUtils.getAlgorithmInfo(add.mAlgorithm,add.mKeySize,add.mCurve));
if (add.mExpiry == null) {
log.add(LogType.MSG_MF_ERROR_NULL_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (add.mExpiry > 0L && new Date(add.mExpiry * 1000).before(new Date())) {
log.add(LogType.MSG_MF_ERROR_PAST_EXPIRY,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
subProgressPush((i - 1) * (100 / saveParcel.mAddSubKeys.size()),i * (100 / saveParcel.mAddSubKeys.size()));
PGPKeyPair keyPair=createKey(add,log,indent);
subProgressPop();
if (keyPair == null) {
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
PGPPublicKey pKey=keyPair.getPublicKey();
try {
PGPSignature cert=generateSubkeyBindingSignature(getSignatureGenerator(masterSecretKey,cryptoInput),cryptoInput.getSignatureTime(),masterPublicKey,masterPrivateKey,keyPair.getPrivateKey(),pKey,add.mFlags,add.mExpiry);
pKey=PGPPublicKey.addSubkeyBindingCertification(pKey,cert);
}
 catch (NfcInteractionNeeded e) {
nfcSignOps.addHash(e.hashToSign,e.hashAlgo);
}
PGPSecretKey sKey;
{
PGPDigestCalculator encryptorHashCalc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_ENCRYPTOR_HASH_ALGO);
PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PgpConstants.SECRET_KEY_ENCRYPTOR_SYMMETRIC_ALGO,encryptorHashCalc,PgpConstants.SECRET_KEY_ENCRYPTOR_S2K_COUNT).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(cryptoInput.getPassphrase().getCharArray());
PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_SIGNATURE_CHECKSUM_HASH_ALGO);
sKey=new PGPSecretKey(keyPair.getPrivateKey(),pKey,sha1Calc,false,keyEncryptor);
}
log.add(LogType.MSG_MF_SUBKEY_NEW_ID,indent + 1,KeyFormattingUtils.convertKeyIdToHex(sKey.getKeyID()));
sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
}
subProgressPop();
if (checkCancelled()) {
log.add(LogType.MSG_OPERATION_CANCELLED,indent);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
}
if (saveParcel.mNewUnlock != null) {
progress(R.string.progress_modify_passphrase,90);
log.add(LogType.MSG_MF_PASSPHRASE,indent);
indent+=1;
sKR=applyNewUnlock(sKR,masterPublicKey,masterPrivateKey,cryptoInput.getPassphrase(),saveParcel.mNewUnlock,log,indent);
if (sKR == null) {
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
indent-=1;
}
}
 catch (IOException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_ENCODE,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (PGPException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_PGP,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
catch (SignatureException e) {
Log.e(Constants.TAG,""String_Node_Str"",e);
log.add(LogType.MSG_MF_ERROR_SIG,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
progress(R.string.progress_done,100);
if (!nfcSignOps.isEmpty() && !nfcKeyToCardOps.isEmpty()) {
log.add(LogType.MSG_MF_ERROR_CONFLICTING_NFC_COMMANDS,indent + 1);
return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
}
if (!nfcSignOps.isEmpty()) {
log.add(LogType.MSG_MF_REQUIRE_DIVERT,indent);
return new PgpEditKeyResult(log,nfcSignOps.build());
}
if (!nfcKeyToCardOps.isEmpty()) {
log.add(LogType.MSG_MF_REQUIRE_DIVERT,indent);
return new PgpEditKeyResult(log,nfcKeyToCardOps.build());
}
log.add(LogType.MSG_MF_SUCCESS,indent);
return new PgpEditKeyResult(OperationResult.RESULT_OK,log,new UncachedKeyRing(sKR));
}",0.9992401857323764
8329,"public PgpEditKeyResult createSecretKeyRing(SaveKeyringParcel saveParcel){
  OperationLog log=new OperationLog();
  int indent=0;
  try {
    log.add(LogType.MSG_CR,indent);
    progress(R.string.progress_building_key,0);
    indent+=1;
    if (saveParcel.mAddSubKeys.isEmpty()) {
      log.add(LogType.MSG_CR_ERROR_NO_MASTER,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    if (saveParcel.mAddUserIds.isEmpty()) {
      log.add(LogType.MSG_CR_ERROR_NO_USER_ID,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    SubkeyAdd add=saveParcel.mAddSubKeys.remove(0);
    if ((add.mFlags & KeyFlags.CERTIFY_OTHER) != KeyFlags.CERTIFY_OTHER) {
      log.add(LogType.MSG_CR_ERROR_NO_CERTIFY,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    if (add.mExpiry == null) {
      log.add(LogType.MSG_CR_ERROR_NULL_EXPIRY,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    subProgressPush(10,30);
    PGPKeyPair keyPair=createKey(add,log,indent);
    subProgressPop();
    if (keyPair == null) {
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    progress(R.string.progress_building_master_key,40);
    PGPDigestCalculator encryptorHashCalc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_ENCRYPTOR_HASH_ALGO);
    PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PgpConstants.SECRET_KEY_ENCRYPTOR_SYMMETRIC_ALGO,encryptorHashCalc,PgpConstants.SECRET_KEY_ENCRYPTOR_S2K_COUNT).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(""String_Node_Str"".toCharArray());
    PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_SIGNATURE_CHECKSUM_HASH_ALGO);
    PGPSecretKey masterSecretKey=new PGPSecretKey(keyPair.getPrivateKey(),keyPair.getPublicKey(),sha1Calc,true,keyEncryptor);
    PGPSecretKeyRing sKR=new PGPSecretKeyRing(masterSecretKey.getEncoded(),new JcaKeyFingerprintCalculator());
    subProgressPush(50,100);
    CryptoInputParcel cryptoInput=new CryptoInputParcel(new Date(),new Passphrase(""String_Node_Str""));
    return internal(sKR,masterSecretKey,add.mFlags,add.mExpiry,cryptoInput,saveParcel,log);
  }
 catch (  PGPException e) {
    log.add(LogType.MSG_CR_ERROR_INTERNAL_PGP,indent);
    Log.e(Constants.TAG,""String_Node_Str"",e);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
}","public PgpEditKeyResult createSecretKeyRing(SaveKeyringParcel saveParcel){
  OperationLog log=new OperationLog();
  int indent=0;
  try {
    log.add(LogType.MSG_CR,indent);
    progress(R.string.progress_building_key,0);
    indent+=1;
    if (saveParcel.mAddSubKeys.isEmpty()) {
      log.add(LogType.MSG_CR_ERROR_NO_MASTER,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    if (saveParcel.mAddUserIds.isEmpty()) {
      log.add(LogType.MSG_CR_ERROR_NO_USER_ID,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    SubkeyAdd add=saveParcel.mAddSubKeys.remove(0);
    if ((add.mFlags & KeyFlags.CERTIFY_OTHER) != KeyFlags.CERTIFY_OTHER) {
      log.add(LogType.MSG_CR_ERROR_NO_CERTIFY,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    if (add.mExpiry == null) {
      log.add(LogType.MSG_CR_ERROR_NULL_EXPIRY,indent);
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    subProgressPush(10,30);
    PGPKeyPair keyPair=createKey(add,log,indent);
    subProgressPop();
    if (keyPair == null) {
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    progress(R.string.progress_building_master_key,40);
    PGPDigestCalculator encryptorHashCalc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_ENCRYPTOR_HASH_ALGO);
    PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PgpConstants.SECRET_KEY_ENCRYPTOR_SYMMETRIC_ALGO,encryptorHashCalc,PgpConstants.SECRET_KEY_ENCRYPTOR_S2K_COUNT).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(""String_Node_Str"".toCharArray());
    PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(PgpConstants.SECRET_KEY_SIGNATURE_CHECKSUM_HASH_ALGO);
    PGPSecretKey masterSecretKey=new PGPSecretKey(keyPair.getPrivateKey(),keyPair.getPublicKey(),sha1Calc,true,keyEncryptor);
    PGPSecretKeyRing sKR=new PGPSecretKeyRing(masterSecretKey.getEncoded(),new JcaKeyFingerprintCalculator());
    subProgressPush(50,100);
    CryptoInputParcel cryptoInput=new CryptoInputParcel(new Date(),new Passphrase(""String_Node_Str""));
    return internal(sKR,masterSecretKey,add.mFlags,add.mExpiry,cryptoInput,saveParcel,log,indent);
  }
 catch (  PGPException e) {
    log.add(LogType.MSG_CR_ERROR_INTERNAL_PGP,indent);
    Log.e(Constants.TAG,""String_Node_Str"",e);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
}",0.9986947603953013
8330,"/** 
 * This method does the actual modifications in a keyring just like internal, except it supports only the subset of operations which require no passphrase, and will error otherwise.
 */
private PgpEditKeyResult internalRestricted(PGPSecretKeyRing sKR,SaveKeyringParcel saveParcel,OperationLog log){
  int indent=1;
  progress(R.string.progress_modify,0);
  if (!saveParcel.isRestrictedOnly()) {
    log.add(LogType.MSG_MF_ERROR_RESTRICTED,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  if (checkCancelled()) {
    log.add(LogType.MSG_OPERATION_CANCELLED,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
  }
  subProgressPush(50,60);
  for (int i=0; i < saveParcel.mChangeSubKeys.size(); i++) {
    progress(R.string.progress_modify_subkeychange,(i - 1) * (100 / saveParcel.mChangeSubKeys.size()));
    SaveKeyringParcel.SubkeyChange change=saveParcel.mChangeSubKeys.get(i);
    log.add(LogType.MSG_MF_SUBKEY_CHANGE,indent,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
    PGPSecretKey sKey=sKR.getSecretKey(change.mKeyId);
    if (sKey == null) {
      log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    if (change.mDummyStrip || change.mDummyDivert != null) {
      if (change.mDummyStrip) {
        sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey());
      }
 else {
        if (change.mDummyDivert.length != 16) {
          log.add(LogType.MSG_MF_ERROR_DIVERT_SERIAL,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
          return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
        }
        log.add(LogType.MSG_MF_KEYTOCARD_FINISH,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId),Hex.toHexString(change.mDummyDivert,8,6));
        sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey(),change.mDummyDivert);
      }
      sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
    }
  }
  progress(R.string.progress_done,100);
  log.add(LogType.MSG_MF_SUCCESS,indent);
  return new PgpEditKeyResult(OperationResult.RESULT_OK,log,new UncachedKeyRing(sKR));
}","/** 
 * This method does the actual modifications in a keyring just like internal, except it supports only the subset of operations which require no passphrase, and will error otherwise.
 */
private PgpEditKeyResult internalRestricted(PGPSecretKeyRing sKR,SaveKeyringParcel saveParcel,OperationLog log,int indent){
  progress(R.string.progress_modify,0);
  if (!saveParcel.isRestrictedOnly()) {
    log.add(LogType.MSG_MF_ERROR_RESTRICTED,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  if (checkCancelled()) {
    log.add(LogType.MSG_OPERATION_CANCELLED,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_CANCELLED,log,null);
  }
  subProgressPush(50,60);
  for (int i=0; i < saveParcel.mChangeSubKeys.size(); i++) {
    progress(R.string.progress_modify_subkeychange,(i - 1) * (100 / saveParcel.mChangeSubKeys.size()));
    SaveKeyringParcel.SubkeyChange change=saveParcel.mChangeSubKeys.get(i);
    log.add(LogType.MSG_MF_SUBKEY_CHANGE,indent,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
    PGPSecretKey sKey=sKR.getSecretKey(change.mKeyId);
    if (sKey == null) {
      log.add(LogType.MSG_MF_ERROR_SUBKEY_MISSING,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
      return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
    }
    if (change.mDummyStrip || change.mDummyDivert != null) {
      if (change.mDummyStrip) {
        sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey());
      }
 else {
        if (change.mDummyDivert.length != 16) {
          log.add(LogType.MSG_MF_ERROR_DIVERT_SERIAL,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId));
          return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
        }
        log.add(LogType.MSG_MF_KEYTOCARD_FINISH,indent + 1,KeyFormattingUtils.convertKeyIdToHex(change.mKeyId),Hex.toHexString(change.mDummyDivert,8,6));
        sKey=PGPSecretKey.constructGnuDummyKey(sKey.getPublicKey(),change.mDummyDivert);
      }
      sKR=PGPSecretKeyRing.insertSecretKey(sKR,sKey);
    }
  }
  progress(R.string.progress_done,100);
  log.add(LogType.MSG_MF_SUCCESS,indent);
  return new PgpEditKeyResult(OperationResult.RESULT_OK,log,new UncachedKeyRing(sKR));
}",0.9939986663703044
8331,"private static boolean checkSmartCardCompatibility(PGPSecretKey key,OperationLog log,int indent){
  PGPPublicKey publicKey=key.getPublicKey();
  int algorithm=publicKey.getAlgorithm();
  if (algorithm != PublicKeyAlgorithmTags.RSA_ENCRYPT && algorithm != PublicKeyAlgorithmTags.RSA_SIGN && algorithm != PublicKeyAlgorithmTags.RSA_GENERAL) {
    log.add(OperationResult.LogType.MSG_K2C_ERROR_BAD_ALGO,indent + 1);
    return true;
  }
  int keySize=publicKey.getBitStrength();
  if (keySize != 2048) {
    log.add(OperationResult.LogType.MSG_K2C_ERROR_BAD_SIZE,indent + 1);
    return false;
  }
  if (isDivertToCard(key) || isDummy(key)) {
    log.add(OperationResult.LogType.MSG_K2C_ERROR_BAD_STRIPPED,indent + 1);
    return false;
  }
  return true;
}","private static boolean checkSmartCardCompatibility(PGPSecretKey key,OperationLog log,int indent){
  PGPPublicKey publicKey=key.getPublicKey();
  int algorithm=publicKey.getAlgorithm();
  if (algorithm != PublicKeyAlgorithmTags.RSA_ENCRYPT && algorithm != PublicKeyAlgorithmTags.RSA_SIGN && algorithm != PublicKeyAlgorithmTags.RSA_GENERAL) {
    log.add(LogType.MSG_MF_ERROR_BAD_NFC_ALGO,indent + 1);
    return false;
  }
  int keySize=publicKey.getBitStrength();
  if (keySize != 2048) {
    log.add(LogType.MSG_MF_ERROR_BAD_NFC_SIZE,indent + 1);
    return false;
  }
  if (isDivertToCard(key) || isDummy(key)) {
    log.add(LogType.MSG_MF_ERROR_BAD_NFC_STRIPPED,indent + 1);
    return false;
  }
  return true;
}",0.8625850340136054
8332,"public PgpEditKeyResult modifySecretKeyRing(CanonicalizedSecretKeyRing wsKR,CryptoInputParcel cryptoInput,SaveKeyringParcel saveParcel,OperationLog log){
  int indent=0;
  log.add(LogType.MSG_MF,indent,KeyFormattingUtils.convertKeyIdToHex(wsKR.getMasterKeyId()));
  indent+=1;
  progress(R.string.progress_building_key,0);
  if (saveParcel.mMasterKeyId == null || saveParcel.mMasterKeyId != wsKR.getMasterKeyId()) {
    log.add(LogType.MSG_MF_ERROR_KEYID,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  PGPSecretKeyRing sKR=wsKR.getRing();
  PGPSecretKey masterSecretKey=sKR.getSecretKey();
  if (saveParcel.mFingerprint == null || !Arrays.equals(saveParcel.mFingerprint,masterSecretKey.getPublicKey().getFingerprint())) {
    log.add(LogType.MSG_MF_ERROR_FINGERPRINT,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  if (saveParcel.isEmpty()) {
    log.add(LogType.MSG_MF_ERROR_NOOP,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  for (  SaveKeyringParcel.SubkeyChange change : saveParcel.mChangeSubKeys) {
    if (change.mMoveKeyToCard) {
      byte[] subKeyId=new byte[8];
      ByteBuffer buf=ByteBuffer.wrap(subKeyId);
      buf.putLong(change.mKeyId).rewind();
      byte[] serialNumber=cryptoInput.getCryptoData().get(buf);
      if (serialNumber != null) {
        change.mMoveKeyToCard=false;
        change.mDummyDivert=serialNumber;
      }
    }
  }
  if (isDummy(masterSecretKey) || saveParcel.isRestrictedOnly()) {
    log.add(LogType.MSG_MF_RESTRICTED_MODE,indent);
    return internalRestricted(sKR,saveParcel,log);
  }
  if (!isDivertToCard(masterSecretKey) && !cryptoInput.hasPassphrase()) {
    log.add(LogType.MSG_MF_REQUIRE_PASSPHRASE,indent);
    return new PgpEditKeyResult(log,RequiredInputParcel.createRequiredSignPassphrase(masterSecretKey.getKeyID(),masterSecretKey.getKeyID(),cryptoInput.getSignatureTime()));
  }
  PGPPublicKey masterPublicKey=masterSecretKey.getPublicKey();
  int masterKeyFlags=readKeyFlags(masterPublicKey) | KeyFlags.CERTIFY_OTHER;
  Date expiryTime=wsKR.getPublicKey().getExpiryTime();
  long masterKeyExpiry=expiryTime != null ? expiryTime.getTime() / 1000 : 0L;
  return internal(sKR,masterSecretKey,masterKeyFlags,masterKeyExpiry,cryptoInput,saveParcel,log);
}","public PgpEditKeyResult modifySecretKeyRing(CanonicalizedSecretKeyRing wsKR,CryptoInputParcel cryptoInput,SaveKeyringParcel saveParcel,OperationLog log,int indent){
  log.add(LogType.MSG_MF,indent,KeyFormattingUtils.convertKeyIdToHex(wsKR.getMasterKeyId()));
  indent+=1;
  progress(R.string.progress_building_key,0);
  if (saveParcel.mMasterKeyId == null || saveParcel.mMasterKeyId != wsKR.getMasterKeyId()) {
    log.add(LogType.MSG_MF_ERROR_KEYID,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  PGPSecretKeyRing sKR=wsKR.getRing();
  PGPSecretKey masterSecretKey=sKR.getSecretKey();
  if (saveParcel.mFingerprint == null || !Arrays.equals(saveParcel.mFingerprint,masterSecretKey.getPublicKey().getFingerprint())) {
    log.add(LogType.MSG_MF_ERROR_FINGERPRINT,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  if (saveParcel.isEmpty()) {
    log.add(LogType.MSG_MF_ERROR_NOOP,indent);
    return new PgpEditKeyResult(PgpEditKeyResult.RESULT_ERROR,log,null);
  }
  for (  SaveKeyringParcel.SubkeyChange change : saveParcel.mChangeSubKeys) {
    if (change.mMoveKeyToCard) {
      byte[] subKeyId=new byte[8];
      ByteBuffer buf=ByteBuffer.wrap(subKeyId);
      buf.putLong(change.mKeyId).rewind();
      byte[] serialNumber=cryptoInput.getCryptoData().get(buf);
      if (serialNumber != null) {
        change.mMoveKeyToCard=false;
        change.mDummyDivert=serialNumber;
      }
    }
  }
  if (isDummy(masterSecretKey) || saveParcel.isRestrictedOnly()) {
    log.add(LogType.MSG_MF_RESTRICTED_MODE,indent);
    return internalRestricted(sKR,saveParcel,log,indent + 1);
  }
  if (!isDivertToCard(masterSecretKey) && !cryptoInput.hasPassphrase()) {
    log.add(LogType.MSG_MF_REQUIRE_PASSPHRASE,indent);
    return new PgpEditKeyResult(log,RequiredInputParcel.createRequiredSignPassphrase(masterSecretKey.getKeyID(),masterSecretKey.getKeyID(),cryptoInput.getSignatureTime()));
  }
  PGPPublicKey masterPublicKey=masterSecretKey.getPublicKey();
  int masterKeyFlags=readKeyFlags(masterPublicKey) | KeyFlags.CERTIFY_OTHER;
  Date expiryTime=wsKR.getPublicKey().getExpiryTime();
  long masterKeyExpiry=expiryTime != null ? expiryTime.getTime() / 1000 : 0L;
  return internal(sKR,masterSecretKey,masterKeyFlags,masterKeyExpiry,cryptoInput,saveParcel,log,indent);
}",0.9903784477228992
8333,"private void editSubkey(final int position){
  final long keyId=mSubkeysAdapter.getKeyId(position);
  Handler returnHandler=new Handler(){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case EditSubkeyDialogFragment.MESSAGE_CHANGE_EXPIRY:
        editSubkeyExpiry(position);
      break;
case EditSubkeyDialogFragment.MESSAGE_REVOKE:
    if (mSaveKeyringParcel.mRevokeSubKeys.contains(keyId)) {
      mSaveKeyringParcel.mRevokeSubKeys.remove(keyId);
    }
 else {
      mSaveKeyringParcel.mRevokeSubKeys.add(keyId);
    }
  break;
case EditSubkeyDialogFragment.MESSAGE_STRIP:
{
  CanonicalizedSecretKey.SecretKeyType secretKeyType=mSubkeysAdapter.getSecretKeyType(position);
  if (secretKeyType == CanonicalizedSecretKey.SecretKeyType.GNU_DUMMY) {
    break;
  }
  SubkeyChange change=mSaveKeyringParcel.getSubkeyChange(keyId);
  if (change == null) {
    mSaveKeyringParcel.mChangeSubKeys.add(new SubkeyChange(keyId,true,false));
    break;
  }
  change.mDummyStrip=!change.mDummyStrip;
  if (change.mDummyStrip && change.mMoveKeyToCard) {
    change.mMoveKeyToCard=false;
  }
  break;
}
case EditSubkeyDialogFragment.MESSAGE_KEYTOCARD:
{
CanonicalizedSecretKey.SecretKeyType secretKeyType=mSubkeysAdapter.getSecretKeyType(position);
if (secretKeyType == CanonicalizedSecretKey.SecretKeyType.DIVERT_TO_CARD || secretKeyType == CanonicalizedSecretKey.SecretKeyType.GNU_DUMMY) {
  Toast.makeText(EditKeyFragment.this.getActivity(),R.string.edit_key_error_bad_nfc_stripped,Toast.LENGTH_SHORT).show();
  break;
}
SubkeyChange change;
change=mSaveKeyringParcel.getSubkeyChange(keyId);
if (change == null) {
  mSaveKeyringParcel.mChangeSubKeys.add(new SubkeyChange(keyId,false,true));
  break;
}
change.mMoveKeyToCard=!change.mMoveKeyToCard;
if (change.mMoveKeyToCard && change.mDummyStrip) {
  change.mDummyStrip=false;
}
break;
}
}
getLoaderManager().getLoader(LOADER_ID_SUBKEYS).forceLoad();
}
}
;
final Messenger messenger=new Messenger(returnHandler);
DialogFragmentWorkaround.INTERFACE.runnableRunDelayed(new Runnable(){
public void run(){
EditSubkeyDialogFragment dialogFragment=EditSubkeyDialogFragment.newInstance(messenger);
dialogFragment.show(getActivity().getSupportFragmentManager(),""String_Node_Str"");
}
}
);
}","private void editSubkey(final int position){
  final long keyId=mSubkeysAdapter.getKeyId(position);
  Handler returnHandler=new Handler(){
    @Override public void handleMessage(    Message message){
switch (message.what) {
case EditSubkeyDialogFragment.MESSAGE_CHANGE_EXPIRY:
        editSubkeyExpiry(position);
      break;
case EditSubkeyDialogFragment.MESSAGE_REVOKE:
    if (mSaveKeyringParcel.mRevokeSubKeys.contains(keyId)) {
      mSaveKeyringParcel.mRevokeSubKeys.remove(keyId);
    }
 else {
      mSaveKeyringParcel.mRevokeSubKeys.add(keyId);
    }
  break;
case EditSubkeyDialogFragment.MESSAGE_STRIP:
{
  SecretKeyType secretKeyType=mSubkeysAdapter.getSecretKeyType(position);
  if (secretKeyType == SecretKeyType.GNU_DUMMY) {
    break;
  }
  SubkeyChange change=mSaveKeyringParcel.getSubkeyChange(keyId);
  if (change == null) {
    mSaveKeyringParcel.mChangeSubKeys.add(new SubkeyChange(keyId,true,false));
    break;
  }
  change.mDummyStrip=!change.mDummyStrip;
  if (change.mDummyStrip && change.mMoveKeyToCard) {
    change.mMoveKeyToCard=false;
  }
  break;
}
case EditSubkeyDialogFragment.MESSAGE_KEYTOCARD:
{
Activity activity=EditKeyFragment.this.getActivity();
SecretKeyType secretKeyType=mSubkeysAdapter.getSecretKeyType(position);
if (secretKeyType == SecretKeyType.DIVERT_TO_CARD || secretKeyType == SecretKeyType.GNU_DUMMY) {
  Notify.create(activity,R.string.edit_key_error_bad_nfc_stripped,Notify.Style.ERROR).show((ViewGroup)activity.findViewById(R.id.import_snackbar));
  break;
}
int algorithm=mSubkeysAdapter.getAlgorithm(position);
if (algorithm != 1 && algorithm != 2 && algorithm != 3) {
  Notify.create(activity,R.string.edit_key_error_bad_nfc_algo,Notify.Style.ERROR).show((ViewGroup)activity.findViewById(R.id.import_snackbar));
  break;
}
if (mSubkeysAdapter.getKeySize(position) != 2048) {
  Notify.create(activity,R.string.edit_key_error_bad_nfc_size,Notify.Style.ERROR).show((ViewGroup)activity.findViewById(R.id.import_snackbar));
  break;
}
SubkeyChange change;
change=mSaveKeyringParcel.getSubkeyChange(keyId);
if (change == null) {
  mSaveKeyringParcel.mChangeSubKeys.add(new SubkeyChange(keyId,false,true));
  break;
}
change.mMoveKeyToCard=!change.mMoveKeyToCard;
if (change.mMoveKeyToCard && change.mDummyStrip) {
  change.mDummyStrip=false;
}
break;
}
}
getLoaderManager().getLoader(LOADER_ID_SUBKEYS).forceLoad();
}
}
;
final Messenger messenger=new Messenger(returnHandler);
DialogFragmentWorkaround.INTERFACE.runnableRunDelayed(new Runnable(){
public void run(){
EditSubkeyDialogFragment dialogFragment=EditSubkeyDialogFragment.newInstance(messenger);
dialogFragment.show(getActivity().getSupportFragmentManager(),""String_Node_Str"");
}
}
);
}",0.836627672448568
8334,"@Override public void onClick(View v){
  launchContactActivity(finalContactId,context);
}","@Override public void onClick(View v){
  launchContactActivity(contactId,context);
}",0.9595375722543352
8335,"@Override public Loader<Cursor> onCreateLoader(int id,Bundle args){
  setContentShown(false);
switch (id) {
case LOADER_ID_UNIFIED:
{
      Uri baseUri=KeychainContract.KeyRings.buildUnifiedKeyRingUri(mDataUri);
      return new CursorLoader(getActivity(),baseUri,UNIFIED_PROJECTION,null,null,null);
    }
case LOADER_ID_USER_IDS:
  return UserIdsAdapter.createLoader(getActivity(),mDataUri);
default :
return null;
}
}","@Override public Loader<Cursor> onCreateLoader(int id,Bundle args){
  setContentShown(false);
switch (id) {
case LOADER_ID_UNIFIED:
{
      Uri baseUri=KeychainContract.KeyRings.buildUnifiedKeyRingUri(mDataUri);
      return new CursorLoader(getActivity(),baseUri,UNIFIED_PROJECTION,null,null,null);
    }
case LOADER_ID_USER_IDS:
  return UserIdsAdapter.createLoader(getActivity(),mDataUri);
case LOADER_ID_LINKED_CONTACT:
{
  long masterKeyId=args.getLong(LOADER_LINKED_CONTACT_MASTER_KEY_ID);
  boolean isSecret=args.getBoolean(LOADER_LINKED_CONTACT_IS_SECRET);
  Uri baseUri;
  if (isSecret)   baseUri=ContactsContract.Profile.CONTENT_RAW_CONTACTS_URI;
 else   baseUri=ContactsContract.RawContacts.CONTENT_URI;
  return new CursorLoader(getActivity(),baseUri,RAWCONTACT_PROJECTION,ContactsContract.RawContacts.ACCOUNT_TYPE + ""String_Node_Str"" + ContactsContract.RawContacts.SOURCE_ID+ ""String_Node_Str""+ ContactsContract.RawContacts.DELETED+ ""String_Node_Str"",new String[]{Constants.ACCOUNT_TYPE,Long.toString(masterKeyId),""String_Node_Str""},null);
}
default :
return null;
}
}",0.556
8336,"@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
  if (data.getCount() == 0) {
    return;
  }
switch (loader.getId()) {
case LOADER_ID_UNIFIED:
{
      if (data.moveToFirst()) {
        mIsSecret=data.getInt(INDEX_HAS_ANY_SECRET) != 0;
        if (!mSystemContactLoaded) {
          long masterKeyId=data.getLong(INDEX_MASTER_KEY_ID);
          loadLinkedSystemContact(masterKeyId);
        }
        mUserIdsAdapter=new UserIdsAdapter(getActivity(),null,0,!mIsSecret,null);
        mUserIds.setAdapter(mUserIdsAdapter);
        getLoaderManager().initLoader(LOADER_ID_USER_IDS,null,this);
        break;
      }
    }
case LOADER_ID_USER_IDS:
{
    mUserIdsAdapter.swapCursor(data);
    break;
  }
}
setContentShown(true);
}","@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
  if (data.getCount() == 0) {
    return;
  }
switch (loader.getId()) {
case LOADER_ID_UNIFIED:
{
      if (data.moveToFirst()) {
        mIsSecret=data.getInt(INDEX_HAS_ANY_SECRET) != 0;
        mUserIdsAdapter=new UserIdsAdapter(getActivity(),null,0,!mIsSecret,null);
        mUserIds.setAdapter(mUserIdsAdapter);
        getLoaderManager().initLoader(LOADER_ID_USER_IDS,null,this);
        long masterKeyId=data.getLong(INDEX_MASTER_KEY_ID);
        long contactId=ContactHelper.findContactId(getActivity().getContentResolver(),masterKeyId);
        loadLinkedSystemContact(contactId);
        Bundle linkedContactData=new Bundle();
        linkedContactData.putLong(LOADER_LINKED_CONTACT_MASTER_KEY_ID,masterKeyId);
        linkedContactData.putBoolean(LOADER_LINKED_CONTACT_IS_SECRET,mIsSecret);
        getLoaderManager().initLoader(LOADER_ID_LINKED_CONTACT,linkedContactData,this);
        break;
      }
    }
case LOADER_ID_USER_IDS:
{
    mUserIdsAdapter.swapCursor(data);
    break;
  }
case LOADER_ID_LINKED_CONTACT:
{
  if (data.moveToFirst()) {
    long contactId=data.getLong(INDEX_CONTACT_ID);
    loadLinkedSystemContact(contactId);
  }
  break;
}
}
setContentShown(true);
}",0.5888778550148958
8337,"/** 
 * Checks if a system contact exists for given masterKeyId, and if it does, sets name, picture and onClickListener for the linked system contact's layout In the case of a secret key, ""me"" contact details are loaded
 * @param masterKeyId
 */
private void loadLinkedSystemContact(final long masterKeyId){
  final Context context=mSystemContactName.getContext();
  final ContentResolver resolver=context.getContentResolver();
  long contactId;
  String contactName=null;
  if (mIsSecret) {
    contactId=ContactHelper.getMainProfileContactId(resolver);
    List<String> mainProfileNames=ContactHelper.getMainProfileContactName(context);
    if (mainProfileNames != null && mainProfileNames.size() > 0) {
      contactName=mainProfileNames.get(0);
    }
  }
 else {
    contactId=ContactHelper.findContactId(resolver,masterKeyId);
    contactName=ContactHelper.getContactName(resolver,contactId);
  }
  if (contactName != null) {
    mSystemContactName.setText(contactName);
    Bitmap picture;
    if (mIsSecret) {
      picture=ContactHelper.loadMainProfilePhoto(resolver,false);
    }
 else {
      picture=ContactHelper.loadPhotoByMasterKeyId(resolver,masterKeyId,false);
    }
    if (picture != null)     mSystemContactPicture.setImageBitmap(picture);
    final long finalContactId=contactId;
    mSystemContactLayout.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        launchContactActivity(finalContactId,context);
      }
    }
);
    mSystemContactLoaded=true;
  }
}","/** 
 * Expects to be called only if a linked system contact exists. Sets name, picture and onClickListener for the linked system contact's layout. In the case of a secret key, ""me"" contact details are loaded.
 * @param contactId
 */
private void loadLinkedSystemContact(final long contactId){
  final Context context=mSystemContactName.getContext();
  final ContentResolver resolver=context.getContentResolver();
  String contactName=null;
  if (mIsSecret) {
    List<String> mainProfileNames=ContactHelper.getMainProfileContactName(context);
    if (mainProfileNames != null && mainProfileNames.size() > 0) {
      contactName=mainProfileNames.get(0);
    }
  }
 else {
    contactName=ContactHelper.getContactName(resolver,contactId);
  }
  if (contactName != null) {
    mSystemContactName.setText(contactName);
    Bitmap picture;
    if (mIsSecret) {
      picture=ContactHelper.loadMainProfilePhoto(resolver,false);
    }
 else {
      picture=ContactHelper.loadPhotoByContactId(resolver,contactId,false);
    }
    if (picture != null)     mSystemContactPicture.setImageBitmap(picture);
    mSystemContactLayout.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        launchContactActivity(contactId,context);
      }
    }
);
  }
}",0.8486352357320099
8338,"public static Bitmap loadPhotoByMasterKeyId(ContentResolver contentResolver,long masterKeyId,boolean highRes){
  if (masterKeyId == -1) {
    return null;
  }
  try {
    long rawContactId=findRawContactId(contentResolver,masterKeyId);
    if (rawContactId == -1) {
      return null;
    }
    Uri rawContactUri=ContentUris.withAppendedId(ContactsContract.RawContacts.CONTENT_URI,rawContactId);
    Uri contactUri=ContactsContract.RawContacts.getContactLookupUri(contentResolver,rawContactUri);
    InputStream photoInputStream=ContactsContract.Contacts.openContactPhotoInputStream(contentResolver,contactUri,highRes);
    if (photoInputStream == null) {
      return null;
    }
    return BitmapFactory.decodeStream(photoInputStream);
  }
 catch (  Throwable ignored) {
    return null;
  }
}","public static Bitmap loadPhotoByMasterKeyId(ContentResolver contentResolver,long masterKeyId,boolean highRes){
  if (masterKeyId == -1) {
    return null;
  }
  try {
    long contactId=findContactId(contentResolver,masterKeyId);
    return loadPhotoByContactId(contentResolver,contactId,highRes);
  }
 catch (  Throwable ignored) {
    return null;
  }
}",0.3426086956521739
8339,"@Override public void setPassphrase(Passphrase passphrase){
  mPassphrase.removeFromMemory();
  mPassphrase=passphrase;
}","@Override public void setPassphrase(Passphrase passphrase){
  if (mPassphrase != null) {
    mPassphrase.removeFromMemory();
  }
  mPassphrase=passphrase;
}",0.8736462093862816
8340,"public static Showable createNotify(Activity activity,String msg,int duration,Style style,final ActionListener listener,int resIdAction){
}","public static Showable createNotify(final Activity activity,String msg,int duration,Style style,final ActionListener listener,int resIdAction){
}",0.9788732394366196
8341,"public SignEncryptResult execute(SignEncryptParcel input){
  OperationLog log=new OperationLog();
  log.add(LogType.MSG_SE,0);
  ArrayDeque<Uri> inputUris=new ArrayDeque<>(input.getInputUris());
  ArrayDeque<Uri> outputUris=new ArrayDeque<>(input.getOutputUris());
  byte[] inputBytes=input.getBytes();
  byte[] outputBytes=null;
  ArrayList<PgpSignEncryptResult> results=new ArrayList<>();
  do {
    if (checkCancelled()) {
      log.add(LogType.MSG_OPERATION_CANCELLED,0);
      return new SignEncryptResult(SignEncryptResult.RESULT_CANCELLED,log,results);
    }
    InputData inputData;
{
      if (inputBytes != null) {
        log.add(LogType.MSG_SE_INPUT_BYTES,1);
        InputStream is=new ByteArrayInputStream(inputBytes);
        inputData=new InputData(is,inputBytes.length);
        inputBytes=null;
      }
 else {
        if (inputUris.isEmpty()) {
          log.add(LogType.MSG_SE_ERROR_NO_INPUT,1);
          return new SignEncryptResult(SignEncryptResult.RESULT_ERROR,log,results);
        }
        log.add(LogType.MSG_SE_INPUT_URI,1);
        Uri uri=inputUris.removeFirst();
        try {
          InputStream is=mContext.getContentResolver().openInputStream(uri);
          long fileSize=FileHelper.getFileSize(mContext,uri,0);
          String filename=FileHelper.getFilename(mContext,uri);
          inputData=new InputData(is,fileSize,filename);
        }
 catch (        FileNotFoundException e) {
          log.add(LogType.MSG_SE_ERROR_INPUT_URI_NOT_FOUND,1);
          return new SignEncryptResult(SignEncryptResult.RESULT_ERROR,log,results);
        }
      }
    }
    OutputStream outStream;
{
      if (!outputUris.isEmpty()) {
        try {
          Uri outputUri=outputUris.removeFirst();
          outStream=mContext.getContentResolver().openOutputStream(outputUri);
        }
 catch (        FileNotFoundException e) {
          log.add(LogType.MSG_SE_ERROR_OUTPUT_URI_NOT_FOUND,1);
          return new SignEncryptResult(SignEncryptResult.RESULT_ERROR,log,results);
        }
      }
 else {
        if (outputBytes != null) {
          log.add(LogType.MSG_SE_ERROR_TOO_MANY_INPUTS,1);
          return new SignEncryptResult(SignEncryptResult.RESULT_ERROR,log,results);
        }
        outStream=new ByteArrayOutputStream();
      }
    }
    PgpSignEncryptOperation op=new PgpSignEncryptOperation(mContext,mProviderHelper,new ProgressScaler(),mCancelled);
    PgpSignEncryptResult result=op.execute(input,inputData,outStream);
    results.add(result);
    log.add(result,2);
    if (result.isPending()) {
      return new SignEncryptResult(SignEncryptResult.RESULT_PENDING,log,results);
    }
    if (!result.success()) {
      return new SignEncryptResult(SignEncryptResult.RESULT_ERROR,log,results);
    }
    if (outStream instanceof ByteArrayOutputStream) {
      outputBytes=((ByteArrayOutputStream)outStream).toByteArray();
    }
  }
 while (!inputUris.isEmpty());
  if (!outputUris.isEmpty()) {
    log.add(LogType.MSG_SE_WARN_OUTPUT_LEFT,1);
  }
  log.add(LogType.MSG_SE_SUCCESS,1);
  return new SignEncryptResult(SignEncryptResult.RESULT_OK,log,results,outputBytes);
}","public SignEncryptResult execute(SignEncryptParcel input){
  OperationLog log=new OperationLog();
  log.add(LogType.MSG_SE,0);
  ArrayDeque<Uri> inputUris=new ArrayDeque<>(input.getInputUris());
  ArrayDeque<Uri> outputUris=new ArrayDeque<>(input.getOutputUris());
  byte[] inputBytes=input.getBytes();
  byte[] outputBytes=null;
  int total=inputBytes != null ? 1 : inputUris.size(), count=0;
  ArrayList<PgpSignEncryptResult> results=new ArrayList<>();
  do {
    if (checkCancelled()) {
      log.add(LogType.MSG_OPERATION_CANCELLED,0);
      return new SignEncryptResult(SignEncryptResult.RESULT_CANCELLED,log,results);
    }
    InputData inputData;
{
      if (inputBytes != null) {
        log.add(LogType.MSG_SE_INPUT_BYTES,1);
        InputStream is=new ByteArrayInputStream(inputBytes);
        inputData=new InputData(is,inputBytes.length);
        inputBytes=null;
      }
 else {
        if (inputUris.isEmpty()) {
          log.add(LogType.MSG_SE_ERROR_NO_INPUT,1);
          return new SignEncryptResult(SignEncryptResult.RESULT_ERROR,log,results);
        }
        log.add(LogType.MSG_SE_INPUT_URI,1);
        Uri uri=inputUris.removeFirst();
        try {
          InputStream is=mContext.getContentResolver().openInputStream(uri);
          long fileSize=FileHelper.getFileSize(mContext,uri,0);
          String filename=FileHelper.getFilename(mContext,uri);
          inputData=new InputData(is,fileSize,filename);
        }
 catch (        FileNotFoundException e) {
          log.add(LogType.MSG_SE_ERROR_INPUT_URI_NOT_FOUND,1);
          return new SignEncryptResult(SignEncryptResult.RESULT_ERROR,log,results);
        }
      }
    }
    OutputStream outStream;
{
      if (!outputUris.isEmpty()) {
        try {
          Uri outputUri=outputUris.removeFirst();
          outStream=mContext.getContentResolver().openOutputStream(outputUri);
        }
 catch (        FileNotFoundException e) {
          log.add(LogType.MSG_SE_ERROR_OUTPUT_URI_NOT_FOUND,1);
          return new SignEncryptResult(SignEncryptResult.RESULT_ERROR,log,results);
        }
      }
 else {
        if (outputBytes != null) {
          log.add(LogType.MSG_SE_ERROR_TOO_MANY_INPUTS,1);
          return new SignEncryptResult(SignEncryptResult.RESULT_ERROR,log,results);
        }
        outStream=new ByteArrayOutputStream();
      }
    }
    PgpSignEncryptOperation op=new PgpSignEncryptOperation(mContext,mProviderHelper,new ProgressScaler(mProgressable,100 * count / total,100 * ++count / total,100),mCancelled);
    PgpSignEncryptResult result=op.execute(input,inputData,outStream);
    results.add(result);
    log.add(result,2);
    if (result.isPending()) {
      return new SignEncryptResult(SignEncryptResult.RESULT_PENDING,log,results);
    }
    if (!result.success()) {
      return new SignEncryptResult(SignEncryptResult.RESULT_ERROR,log,results);
    }
    if (outStream instanceof ByteArrayOutputStream) {
      outputBytes=((ByteArrayOutputStream)outStream).toByteArray();
    }
  }
 while (!inputUris.isEmpty());
  if (!outputUris.isEmpty()) {
    log.add(LogType.MSG_SE_WARN_OUTPUT_LEFT,1);
  }
  log.add(LogType.MSG_SE_SUCCESS,1);
  return new SignEncryptResult(SignEncryptResult.RESULT_OK,log,results,outputBytes);
}",0.9806634177016192
8342,"@Override public void onEncryptSuccess(SignEncryptResult result){
  if (mDeleteAfterEncrypt) {
    for (    Uri inputUri : mInputUris) {
      DeleteFileDialogFragment deleteFileDialog=DeleteFileDialogFragment.newInstance(inputUri);
      deleteFileDialog.show(getSupportFragmentManager(),""String_Node_Str"");
    }
    mInputUris.clear();
    notifyUpdate();
  }
  if (mShareAfterEncrypt) {
    startActivity(sendWithChooserExcludingEncrypt());
  }
 else {
    result.createNotify(EncryptFilesActivity.this).show();
  }
}","@Override public void onEncryptSuccess(final SignEncryptResult result){
  if (mDeleteAfterEncrypt) {
    final Uri[] inputUris=mInputUris.toArray(new Uri[mInputUris.size()]);
    DeleteFileDialogFragment deleteFileDialog=DeleteFileDialogFragment.newInstance(inputUris);
    deleteFileDialog.setOnDeletedListener(new DeleteFileDialogFragment.OnDeletedListener(){
      @Override public void onDeleted(){
        if (mShareAfterEncrypt) {
          startActivity(sendWithChooserExcludingEncrypt());
        }
 else {
          result.createNotify(EncryptFilesActivity.this).show();
        }
      }
    }
);
    deleteFileDialog.show(getSupportFragmentManager(),""String_Node_Str"");
    mInputUris.clear();
    notifyUpdate();
  }
 else {
    if (mShareAfterEncrypt) {
      startActivity(sendWithChooserExcludingEncrypt());
    }
 else {
      result.createNotify(EncryptFilesActivity.this).show();
    }
  }
}",0.6979020979020979
8343,"private void addInputUri(Uri inputUri){
  if (inputUri == null) {
    return;
  }
  mEncryptInterface.getInputUris().add(inputUri);
  mEncryptInterface.notifyUpdate();
  mSelectedFiles.requestFocus();
}","private void addInputUri(Uri inputUri){
  if (inputUri == null) {
    return;
  }
  if (mEncryptInterface.getInputUris().contains(inputUri)) {
    Notify.showNotify(getActivity(),getActivity().getString(R.string.error_file_added_already,FileHelper.getFilename(getActivity(),inputUri)),Notify.Style.ERROR);
    return;
  }
  mEncryptInterface.getInputUris().add(inputUri);
  mEncryptInterface.notifyUpdate();
  mSelectedFiles.requestFocus();
}",0.5838509316770186
8344,"/** 
 * Creates dialog
 */
@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final FragmentActivity activity=getActivity();
  final Uri deleteUri=getArguments().getParcelable(ARG_DELETE_URI);
  final String deleteFilename=FileHelper.getFilename(getActivity(),deleteUri);
  CustomAlertDialogBuilder alert=new CustomAlertDialogBuilder(activity);
  alert.setMessage(this.getString(R.string.file_delete_confirmation,deleteFilename));
  alert.setPositiveButton(R.string.btn_delete,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dismiss();
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
        try {
          if (DocumentsContract.deleteDocument(getActivity().getContentResolver(),deleteUri)) {
            Toast.makeText(getActivity(),getActivity().getString(R.string.file_delete_successful,deleteFilename),Toast.LENGTH_LONG).show();
            return;
          }
        }
 catch (        UnsupportedOperationException e) {
          Log.d(Constants.TAG,""String_Node_Str"",e);
        }
      }
      try {
        if (getActivity().getContentResolver().delete(deleteUri,null,null) > 0) {
          Toast.makeText(getActivity(),getActivity().getString(R.string.file_delete_successful,deleteFilename),Toast.LENGTH_LONG).show();
          return;
        }
      }
 catch (      UnsupportedOperationException e) {
        Log.d(Constants.TAG,""String_Node_Str"",e);
      }
      if (new File(deleteUri.getPath()).delete()) {
        Toast.makeText(getActivity(),getActivity().getString(R.string.file_delete_successful,deleteFilename),Toast.LENGTH_LONG).show();
        return;
      }
      Toast.makeText(getActivity(),getActivity().getString(R.string.error_file_delete_failed,deleteFilename),Toast.LENGTH_LONG).show();
    }
  }
);
  alert.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dismiss();
    }
  }
);
  alert.setCancelable(true);
  return alert.show();
}","/** 
 * Creates dialog
 */
@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final FragmentActivity activity=getActivity();
  final Uri[] deleteUris=(Uri[])getArguments().getParcelableArray(ARG_DELETE_URIS);
  final StringBuilder deleteFileNames=new StringBuilder();
  final HashMap<Uri,String> deleteFileNameMap=new HashMap<>();
  for (  Uri deleteUri : deleteUris) {
    String deleteFileName=FileHelper.getFilename(getActivity(),deleteUri);
    deleteFileNames.append('\n').append(deleteFileName);
    deleteFileNameMap.put(deleteUri,deleteFileName);
  }
  CustomAlertDialogBuilder alert=new CustomAlertDialogBuilder(activity);
  alert.setMessage(this.getString(R.string.file_delete_confirmation,deleteFileNames.toString()));
  alert.setPositiveButton(R.string.btn_delete,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dismiss();
      ArrayList<String> failedFileNameList=new ArrayList<>();
      for (      Uri deleteUri : deleteUris) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
          try {
            if (DocumentsContract.deleteDocument(getActivity().getContentResolver(),deleteUri)) {
              continue;
            }
          }
 catch (          Exception e) {
            Log.d(Constants.TAG,""String_Node_Str"",e);
          }
        }
        try {
          if (getActivity().getContentResolver().delete(deleteUri,null,null) > 0) {
            continue;
          }
        }
 catch (        Exception e) {
          Log.d(Constants.TAG,""String_Node_Str"",e);
        }
        if (new File(deleteUri.getPath()).delete()) {
          continue;
        }
        failedFileNameList.add(deleteFileNameMap.get(deleteUri));
      }
      StringBuilder failedFileNames=new StringBuilder();
      if (!failedFileNameList.isEmpty()) {
        for (        String failedFileName : failedFileNameList) {
          failedFileNames.append('\n').append(failedFileName);
        }
        failedFileNames.append('\n').append(getActivity().getString(R.string.error_file_delete_failed));
      }
      Toast.makeText(getActivity(),getActivity().getString(R.string.file_delete_successful,deleteUris.length - failedFileNameList.size(),deleteUris.length,failedFileNames.toString()),Toast.LENGTH_LONG).show();
      if (onDeletedListener != null) {
        onDeletedListener.onDeleted();
      }
    }
  }
);
  alert.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dismiss();
    }
  }
);
  alert.setCancelable(true);
  return alert.show();
}",0.5047478370964339
8345,"/** 
 * Creates new instance of this delete file dialog fragment
 */
public static DeleteFileDialogFragment newInstance(Uri deleteUri){
  DeleteFileDialogFragment frag=new DeleteFileDialogFragment();
  Bundle args=new Bundle();
  args.putParcelable(ARG_DELETE_URI,deleteUri);
  frag.setArguments(args);
  return frag;
}","/** 
 * Creates new instance of this delete file dialog fragment
 */
public static DeleteFileDialogFragment newInstance(Uri... deleteUris){
  DeleteFileDialogFragment frag=new DeleteFileDialogFragment();
  Bundle args=new Bundle();
  args.putParcelableArray(ARG_DELETE_URIS,deleteUris);
  frag.setArguments(args);
  return frag;
}",0.9830508474576272
8346,"public View getView(final int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=mInflater.inflate(R.layout.view_key_adv_user_id_item,null);
    final ViewHolder holder=new ViewHolder();
    holder.vAddress=(TextView)convertView.findViewById(R.id.user_id_item_address);
    holder.vName=(TextView)convertView.findViewById(R.id.user_id_item_name);
    holder.vComment=(TextView)convertView.findViewById(R.id.user_id_item_comment);
    holder.vDelete=(ImageButton)convertView.findViewById(R.id.user_id_item_delete_button);
    holder.vDelete.setVisibility(View.VISIBLE);
    CheckBox checkBox=(CheckBox)convertView.findViewById(R.id.user_id_item_check_box);
    View certifiedLayout=convertView.findViewById(R.id.user_id_item_certified_layout);
    ImageView editImage=(ImageView)convertView.findViewById(R.id.user_id_item_edit_image);
    checkBox.setVisibility(View.GONE);
    certifiedLayout.setVisibility(View.GONE);
    editImage.setVisibility(View.GONE);
    convertView.setTag(holder);
    holder.vDelete.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        UserIdsAddedAdapter.this.remove(holder.mModel);
      }
    }
);
  }
  final ViewHolder holder=(ViewHolder)convertView.getTag();
  holder.mModel=getItem(position);
  String[] splitUserId=KeyRing.splitUserId(holder.mModel);
  if (splitUserId[0] != null) {
    holder.vName.setText(splitUserId[0]);
  }
 else {
    holder.vName.setText(R.string.user_id_no_name);
  }
  if (splitUserId[1] != null) {
    holder.vAddress.setText(splitUserId[1]);
    holder.vAddress.setVisibility(View.VISIBLE);
  }
 else {
    holder.vAddress.setVisibility(View.GONE);
  }
  if (splitUserId[2] != null) {
    holder.vComment.setText(splitUserId[2]);
    holder.vComment.setVisibility(View.VISIBLE);
  }
 else {
    holder.vComment.setVisibility(View.GONE);
  }
  boolean isPrimary=mNewKeyring && position == 0;
  if (isPrimary) {
    holder.vName.setTypeface(null,Typeface.BOLD);
    holder.vAddress.setTypeface(null,Typeface.BOLD);
  }
 else {
    holder.vName.setTypeface(null,Typeface.NORMAL);
    holder.vAddress.setTypeface(null,Typeface.NORMAL);
  }
  return convertView;
}","public View getView(final int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=mInflater.inflate(R.layout.view_key_adv_user_id_item,null);
    final ViewHolder holder=new ViewHolder();
    holder.vAddress=(TextView)convertView.findViewById(R.id.user_id_item_address);
    holder.vName=(TextView)convertView.findViewById(R.id.user_id_item_name);
    holder.vComment=(TextView)convertView.findViewById(R.id.user_id_item_comment);
    holder.vDelete=(ImageButton)convertView.findViewById(R.id.user_id_item_delete_button);
    holder.vDelete.setVisibility(View.VISIBLE);
    View certifiedLayout=convertView.findViewById(R.id.user_id_item_certified_layout);
    ImageView editImage=(ImageView)convertView.findViewById(R.id.user_id_item_edit_image);
    certifiedLayout.setVisibility(View.GONE);
    editImage.setVisibility(View.GONE);
    convertView.setTag(holder);
    holder.vDelete.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        UserIdsAddedAdapter.this.remove(holder.mModel);
      }
    }
);
  }
  final ViewHolder holder=(ViewHolder)convertView.getTag();
  holder.mModel=getItem(position);
  String[] splitUserId=KeyRing.splitUserId(holder.mModel);
  if (splitUserId[0] != null) {
    holder.vName.setText(splitUserId[0]);
  }
 else {
    holder.vName.setText(R.string.user_id_no_name);
  }
  if (splitUserId[1] != null) {
    holder.vAddress.setText(splitUserId[1]);
    holder.vAddress.setVisibility(View.VISIBLE);
  }
 else {
    holder.vAddress.setVisibility(View.GONE);
  }
  if (splitUserId[2] != null) {
    holder.vComment.setText(splitUserId[2]);
    holder.vComment.setVisibility(View.VISIBLE);
  }
 else {
    holder.vComment.setVisibility(View.GONE);
  }
  boolean isPrimary=mNewKeyring && position == 0;
  if (isPrimary) {
    holder.vName.setTypeface(null,Typeface.BOLD);
    holder.vAddress.setTypeface(null,Typeface.BOLD);
  }
 else {
    holder.vName.setTypeface(null,Typeface.NORMAL);
    holder.vAddress.setTypeface(null,Typeface.NORMAL);
  }
  return convertView;
}",0.9042305904230592
8347,"@Override protected void initLayout(){
  setContentView(R.layout.certify_fingerprint_activity);
}","@Override protected void initLayout(){
  setContentView(R.layout.certify_fingerprint_activity);
  changeToolbarColor();
}",0.8899082568807339
8348,"@Override protected void initLayout(){
  setContentView(R.layout.certify_key_activity);
}","@Override protected void initLayout(){
  setContentView(R.layout.certify_key_activity);
  changeToolbarColor();
}",0.8811881188118812
8349,"private void processScannedContent(Uri uri){
  Log.d(Constants.TAG,""String_Node_Str"" + uri.toString());
  String fingerprint=null;
  if (uri.getScheme().toLowerCase(Locale.ENGLISH).equals(Constants.FINGERPRINT_SCHEME)) {
    fingerprint=uri.getEncodedSchemeSpecificPart().toLowerCase(Locale.ENGLISH);
  }
  if (fingerprint == null) {
    SingletonResult result=new SingletonResult(SingletonResult.RESULT_ERROR,OperationResult.LogType.MSG_WRONG_QR_CODE);
    Intent intent=new Intent();
    intent.putExtra(SingletonResult.EXTRA_RESULT,result);
    returnResult(intent);
    return;
  }
  if (returnResult) {
    Intent result=new Intent();
    result.putExtra(EXTRA_FINGERPRINT,fingerprint);
    setResult(RESULT_OK,result);
    finish();
  }
 else {
    importKeys(fingerprint);
  }
}","private void processScannedContent(Uri uri){
  Log.d(Constants.TAG,""String_Node_Str"" + uri);
  String fingerprint=null;
  if (uri.getScheme().toLowerCase(Locale.ENGLISH).equals(Constants.FINGERPRINT_SCHEME)) {
    fingerprint=uri.getEncodedSchemeSpecificPart().toLowerCase(Locale.ENGLISH);
  }
  if (fingerprint == null) {
    SingletonResult result=new SingletonResult(SingletonResult.RESULT_ERROR,OperationResult.LogType.MSG_WRONG_QR_CODE);
    Intent intent=new Intent();
    intent.putExtra(SingletonResult.EXTRA_RESULT,result);
    returnResult(intent);
    return;
  }
  if (returnResult) {
    Intent result=new Intent();
    result.putExtra(EXTRA_FINGERPRINT,fingerprint);
    setResult(RESULT_OK,result);
    finish();
  }
 else {
    importKeys(fingerprint);
  }
}",0.9929441949967928
8350,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mExportHelper=new ExportHelper(this);
  mProviderHelper=new ProviderHelper(this);
  setTitle(null);
  mName=(TextView)findViewById(R.id.view_key_name);
  mStatusText=(TextView)findViewById(R.id.view_key_status);
  mStatusImage=(ImageView)findViewById(R.id.view_key_status_image);
  mBigToolbar=(RelativeLayout)findViewById(R.id.toolbar_big);
  mActionEncryptFile=(ImageButton)findViewById(R.id.view_key_action_encrypt_files);
  mActionEncryptText=(ImageButton)findViewById(R.id.view_key_action_encrypt_text);
  mActionNfc=(ImageButton)findViewById(R.id.view_key_action_nfc);
  mFab=(FloatingActionButton)findViewById(R.id.fab);
  mPhoto=(AspectRatioImageView)findViewById(R.id.view_key_photo);
  mQrCode=(ImageView)findViewById(R.id.view_key_qr_code);
  mQrCodeLayout=(CardView)findViewById(R.id.view_key_qr_code_layout);
  mRotateSpin=AnimationUtils.loadAnimation(this,R.anim.rotate_spin);
  mRotateSpin.setAnimationListener(new AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      mRefreshItem.getActionView().clearAnimation();
      mRefreshItem.setActionView(null);
      mRefreshItem.setEnabled(true);
      supportInvalidateOptionsMenu();
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  mRotate=AnimationUtils.loadAnimation(this,R.anim.rotate);
  mRotate.setRepeatCount(Animation.INFINITE);
  mRotate.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
    }
    @Override public void onAnimationRepeat(    Animation animation){
      if (!mIsRefreshing) {
        mRefreshItem.getActionView().clearAnimation();
        mRefreshItem.getActionView().startAnimation(mRotateSpin);
      }
    }
  }
);
  mRefresh=getLayoutInflater().inflate(R.layout.indeterminate_progress,null);
  mDataUri=getIntent().getData();
  if (mDataUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (mDataUri.getHost().equals(ContactsContract.AUTHORITY)) {
    mDataUri=ContactHelper.dataUriFromContactUri(this,mDataUri);
    if (mDataUri == null) {
      Log.e(Constants.TAG,""String_Node_Str"");
      Toast.makeText(this,R.string.error_contacts_key_id_missing,Toast.LENGTH_LONG).show();
      finish();
      return;
    }
  }
  Log.i(Constants.TAG,""String_Node_Str"" + mDataUri.toString());
  mActionEncryptFile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      encrypt(mDataUri,false);
    }
  }
);
  mActionEncryptText.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      encrypt(mDataUri,true);
    }
  }
);
  mFab.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (mIsSecret) {
        startSafeSlinger(mDataUri);
      }
 else {
        scanQrCode();
      }
    }
  }
);
  mQrCodeLayout.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      showQrCodeDialog();
    }
  }
);
  mActionNfc.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      invokeNfcBeam();
    }
  }
);
  getSupportLoaderManager().initLoader(LOADER_ID_UNIFIED,null,this);
  initNfc(mDataUri);
  startFragment(savedInstanceState,mDataUri);
}","@SuppressLint(""String_Node_Str"") @Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mExportHelper=new ExportHelper(this);
  mProviderHelper=new ProviderHelper(this);
  setTitle(null);
  mName=(TextView)findViewById(R.id.view_key_name);
  mStatusText=(TextView)findViewById(R.id.view_key_status);
  mStatusImage=(ImageView)findViewById(R.id.view_key_status_image);
  mBigToolbar=(RelativeLayout)findViewById(R.id.toolbar_big);
  mActionEncryptFile=(ImageButton)findViewById(R.id.view_key_action_encrypt_files);
  mActionEncryptText=(ImageButton)findViewById(R.id.view_key_action_encrypt_text);
  mActionNfc=(ImageButton)findViewById(R.id.view_key_action_nfc);
  mFab=(FloatingActionButton)findViewById(R.id.fab);
  mPhoto=(AspectRatioImageView)findViewById(R.id.view_key_photo);
  mQrCode=(ImageView)findViewById(R.id.view_key_qr_code);
  mQrCodeLayout=(CardView)findViewById(R.id.view_key_qr_code_layout);
  mRotateSpin=AnimationUtils.loadAnimation(this,R.anim.rotate_spin);
  mRotateSpin.setAnimationListener(new AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      mRefreshItem.getActionView().clearAnimation();
      mRefreshItem.setActionView(null);
      mRefreshItem.setEnabled(true);
      supportInvalidateOptionsMenu();
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  mRotate=AnimationUtils.loadAnimation(this,R.anim.rotate);
  mRotate.setRepeatCount(Animation.INFINITE);
  mRotate.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
    }
    @Override public void onAnimationRepeat(    Animation animation){
      if (!mIsRefreshing) {
        mRefreshItem.getActionView().clearAnimation();
        mRefreshItem.getActionView().startAnimation(mRotateSpin);
      }
    }
  }
);
  mRefresh=getLayoutInflater().inflate(R.layout.indeterminate_progress,null);
  mDataUri=getIntent().getData();
  if (mDataUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (mDataUri.getHost().equals(ContactsContract.AUTHORITY)) {
    mDataUri=ContactHelper.dataUriFromContactUri(this,mDataUri);
    if (mDataUri == null) {
      Log.e(Constants.TAG,""String_Node_Str"");
      Toast.makeText(this,R.string.error_contacts_key_id_missing,Toast.LENGTH_LONG).show();
      finish();
      return;
    }
  }
  Log.i(Constants.TAG,""String_Node_Str"" + mDataUri);
  mActionEncryptFile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      encrypt(mDataUri,false);
    }
  }
);
  mActionEncryptText.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      encrypt(mDataUri,true);
    }
  }
);
  mFab.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (mIsSecret) {
        startSafeSlinger(mDataUri);
      }
 else {
        scanQrCode();
      }
    }
  }
);
  mQrCodeLayout.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      showQrCodeDialog();
    }
  }
);
  mActionNfc.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      invokeNfcBeam();
    }
  }
);
  getSupportLoaderManager().initLoader(LOADER_ID_UNIFIED,null,this);
  initNfc(mDataUri);
  startFragment(savedInstanceState,mDataUri);
}",0.9938854919399668
8351,"/** 
 * Load QR Code asynchronously and with a fade in animation
 * @param fingerprint
 */
private void loadQrCode(final String fingerprint){
  AsyncTask<Void,Void,Bitmap> loadTask=new AsyncTask<Void,Void,Bitmap>(){
    protected Bitmap doInBackground(    Void... unused){
      String qrCodeContent=Constants.FINGERPRINT_SCHEME + ""String_Node_Str"" + fingerprint;
      return QrCodeUtils.getQRCodeBitmap(qrCodeContent,0);
    }
    protected void onPostExecute(    Bitmap qrCode){
      Bitmap scaled=Bitmap.createScaledBitmap(qrCode,mQrCode.getHeight(),mQrCode.getHeight(),false);
      mQrCode.setImageBitmap(scaled);
      AlphaAnimation anim=new AlphaAnimation(0.0f,1.0f);
      anim.setDuration(200);
      mQrCode.startAnimation(anim);
    }
  }
;
  loadTask.execute();
}","/** 
 * Load QR Code asynchronously and with a fade in animation
 */
private void loadQrCode(final String fingerprint){
  AsyncTask<Void,Void,Bitmap> loadTask=new AsyncTask<Void,Void,Bitmap>(){
    protected Bitmap doInBackground(    Void... unused){
      String qrCodeContent=Constants.FINGERPRINT_SCHEME + ""String_Node_Str"" + fingerprint;
      return QrCodeUtils.getQRCodeBitmap(qrCodeContent,0);
    }
    protected void onPostExecute(    Bitmap qrCode){
      Bitmap scaled=Bitmap.createScaledBitmap(qrCode,mQrCode.getHeight(),mQrCode.getHeight(),false);
      mQrCode.setImageBitmap(scaled);
      AlphaAnimation anim=new AlphaAnimation(0.0f,1.0f);
      anim.setDuration(200);
      mQrCode.startAnimation(anim);
    }
  }
;
  loadTask.execute();
}",0.9856584093872228
8352,"private ExportResult exportKeyRings(OperationLog log,long[] masterKeyIds,boolean exportSecret,OutputStream outStream){
  int okSecret=0, okPublic=0, progress=0;
  try {
    String selection=null, ids[]=null;
    if (masterKeyIds != null) {
      ids=new String[masterKeyIds.length];
      StringBuilder placeholders=new StringBuilder(""String_Node_Str"");
      for (int i=0; i < masterKeyIds.length; i++) {
        ids[i]=Long.toString(masterKeyIds[i]);
        if (i != 0) {
          placeholders.append(""String_Node_Str"");
        }
      }
      selection=Tables.KEY_RINGS_PUBLIC + ""String_Node_Str"" + KeyRings.MASTER_KEY_ID+ ""String_Node_Str""+ placeholders+ ""String_Node_Str"";
    }
    Cursor cursor=mProviderHelper.getContentResolver().query(KeyRings.buildUnifiedKeyRingsUri(),new String[]{KeyRings.MASTER_KEY_ID,KeyRings.PUBKEY_DATA,KeyRings.PRIVKEY_DATA,KeyRings.HAS_ANY_SECRET},selection,ids,Tables.KEYS + ""String_Node_Str"" + KeyRings.MASTER_KEY_ID);
    if (cursor == null || !cursor.moveToFirst()) {
      log.add(LogType.MSG_EXPORT_ERROR_DB,1);
      return new ExportResult(ExportResult.RESULT_ERROR,log,okPublic,okSecret);
    }
    int numKeys=cursor.getCount();
    updateProgress(mContext.getResources().getQuantityString(R.plurals.progress_exporting_key,numKeys),0,numKeys);
    while (!cursor.isAfterLast()) {
      ArmoredOutputStream arOutStream=new ArmoredOutputStream(outStream);
      String version=PgpHelper.getVersionForHeader(mContext);
      if (version != null) {
        arOutStream.setHeader(""String_Node_Str"",version);
      }
      long keyId=cursor.getLong(0);
      log.add(LogType.MSG_EXPORT_PUBLIC,1,KeyFormattingUtils.beautifyKeyId(keyId));
{
        byte[] data=cursor.getBlob(1);
        arOutStream.write(data);
        arOutStream.close();
        okPublic+=1;
      }
      if (exportSecret && cursor.getInt(3) > 0) {
        log.add(LogType.MSG_EXPORT_SECRET,2,KeyFormattingUtils.beautifyKeyId(keyId));
        byte[] data=cursor.getBlob(2);
        arOutStream.write(data);
        okSecret+=1;
      }
      updateProgress(progress++,numKeys);
      cursor.moveToNext();
    }
    updateProgress(R.string.progress_done,numKeys,numKeys);
  }
 catch (  IOException e) {
    log.add(LogType.MSG_EXPORT_ERROR_IO,1);
    return new ExportResult(ExportResult.RESULT_ERROR,log,okPublic,okSecret);
  }
  log.add(LogType.MSG_EXPORT_SUCCESS,1);
  return new ExportResult(ExportResult.RESULT_OK,log,okPublic,okSecret);
}","private ExportResult exportKeyRings(OperationLog log,long[] masterKeyIds,boolean exportSecret,OutputStream outStream){
  if (!BufferedOutputStream.class.isInstance(outStream)) {
    outStream=new BufferedOutputStream(outStream);
  }
  int okSecret=0, okPublic=0, progress=0;
  try {
    String selection=null, ids[]=null;
    if (masterKeyIds != null) {
      ids=new String[masterKeyIds.length];
      StringBuilder placeholders=new StringBuilder(""String_Node_Str"");
      for (int i=0; i < masterKeyIds.length; i++) {
        ids[i]=Long.toString(masterKeyIds[i]);
        if (i != 0) {
          placeholders.append(""String_Node_Str"");
        }
      }
      selection=Tables.KEY_RINGS_PUBLIC + ""String_Node_Str"" + KeyRings.MASTER_KEY_ID+ ""String_Node_Str""+ placeholders+ ""String_Node_Str"";
    }
    Cursor cursor=mProviderHelper.getContentResolver().query(KeyRings.buildUnifiedKeyRingsUri(),new String[]{KeyRings.MASTER_KEY_ID,KeyRings.PUBKEY_DATA,KeyRings.PRIVKEY_DATA,KeyRings.HAS_ANY_SECRET},selection,ids,Tables.KEYS + ""String_Node_Str"" + KeyRings.MASTER_KEY_ID);
    if (cursor == null || !cursor.moveToFirst()) {
      log.add(LogType.MSG_EXPORT_ERROR_DB,1);
      return new ExportResult(ExportResult.RESULT_ERROR,log,okPublic,okSecret);
    }
    int numKeys=cursor.getCount();
    updateProgress(mContext.getResources().getQuantityString(R.plurals.progress_exporting_key,numKeys),0,numKeys);
    while (!cursor.isAfterLast()) {
      ArmoredOutputStream arOutStream=new ArmoredOutputStream(outStream);
      String version=PgpHelper.getVersionForHeader(mContext);
      if (version != null) {
        arOutStream.setHeader(""String_Node_Str"",version);
      }
      long keyId=cursor.getLong(0);
      log.add(LogType.MSG_EXPORT_PUBLIC,1,KeyFormattingUtils.beautifyKeyId(keyId));
{
        byte[] data=cursor.getBlob(1);
        arOutStream.write(data);
        arOutStream.close();
        okPublic+=1;
      }
      if (exportSecret && cursor.getInt(3) > 0) {
        log.add(LogType.MSG_EXPORT_SECRET,2,KeyFormattingUtils.beautifyKeyId(keyId));
        byte[] data=cursor.getBlob(2);
        arOutStream.write(data);
        okSecret+=1;
      }
      updateProgress(progress++,numKeys);
      cursor.moveToNext();
    }
    updateProgress(R.string.progress_done,numKeys,numKeys);
  }
 catch (  IOException e) {
    log.add(LogType.MSG_EXPORT_ERROR_IO,1);
    return new ExportResult(ExportResult.RESULT_ERROR,log,okPublic,okSecret);
  }
  log.add(LogType.MSG_EXPORT_SUCCESS,1);
  return new ExportResult(ExportResult.RESULT_OK,log,okPublic,okSecret);
}",0.977317946677278
8353,"/** 
 * ""Canonicalizes"" a public key, removing inconsistencies in the process. More specifically: - Remove all non-verifying self-certificates - Remove all ""future"" self-certificates - Remove all certificates flagged as ""local"" - Remove all certificates which are superseded by a newer one on the same target, including revocations with later re-certifications. - Remove all certificates in other positions if not of known type: - key revocation signatures on the master key - subkey binding signatures for subkeys - certifications and certification revocations for user ids - If a subkey retains no valid subkey binding certificate, remove it - If a user id retains no valid self certificate, remove it - If the key is a secret key, remove all certificates by foreign keys - If no valid user id remains, log an error and return null This operation writes an OperationLog which can be used as part of an OperationResultParcel.
 * @return A canonicalized key, or null on fatal error (log will include a message in this case)
 */
@SuppressWarnings(""String_Node_Str"") public CanonicalizedKeyRing canonicalize(OperationLog log,int indent){
  log.add(isSecret() ? LogType.MSG_KC_SECRET : LogType.MSG_KC_PUBLIC,indent,KeyFormattingUtils.convertKeyIdToHex(getMasterKeyId()));
  indent+=1;
  if (getVersion() <= 3) {
    log.add(LogType.MSG_KC_ERROR_V3,indent);
    return null;
  }
  final Date now=new Date();
  int redundantCerts=0, badCerts=0;
  PGPKeyRing ring=mRing;
  PGPPublicKey masterKey=mRing.getPublicKey();
  final long masterKeyId=masterKey.getKeyID();
  if (Arrays.binarySearch(KNOWN_ALGORITHMS,masterKey.getAlgorithm()) < 0) {
    log.add(LogType.MSG_KC_ERROR_MASTER_ALGO,indent,Integer.toString(masterKey.getAlgorithm()));
    return null;
  }
{
    log.add(LogType.MSG_KC_MASTER,indent,KeyFormattingUtils.convertKeyIdToHex(masterKey.getKeyID()));
    indent+=1;
    PGPPublicKey modified=masterKey;
    PGPSignature revocation=null;
    for (    PGPSignature zert : new IterableIterator<PGPSignature>(masterKey.getKeySignatures())) {
      int type=zert.getSignatureType();
      if (type == PGPSignature.NO_CERTIFICATION || type == PGPSignature.DEFAULT_CERTIFICATION || type == PGPSignature.CASUAL_CERTIFICATION || type == PGPSignature.POSITIVE_CERTIFICATION || type == PGPSignature.CERTIFICATION_REVOCATION) {
        log.add(LogType.MSG_KC_REVOKE_BAD_TYPE_UID,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      WrappedSignature cert=new WrappedSignature(zert);
      if (type != PGPSignature.KEY_REVOCATION) {
        log.add(LogType.MSG_KC_REVOKE_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(type,16));
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (cert.getCreationTime().after(now)) {
        log.add(LogType.MSG_KC_REVOKE_BAD_TIME,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (cert.isLocal()) {
        log.add(LogType.MSG_KC_REVOKE_BAD_LOCAL,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      try {
        cert.init(masterKey);
        if (!cert.verifySignature(masterKey)) {
          log.add(LogType.MSG_KC_REVOKE_BAD,indent);
          modified=PGPPublicKey.removeCertification(modified,zert);
          badCerts+=1;
          continue;
        }
      }
 catch (      PgpGeneralException e) {
        log.add(LogType.MSG_KC_REVOKE_BAD_ERR,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (revocation == null) {
        revocation=zert;
      }
 else       if (revocation.getCreationTime().before(zert.getCreationTime())) {
        log.add(LogType.MSG_KC_REVOKE_DUP,indent);
        modified=PGPPublicKey.removeCertification(modified,revocation);
        redundantCerts+=1;
        revocation=zert;
      }
 else {
        log.add(LogType.MSG_KC_REVOKE_DUP,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        redundantCerts+=1;
      }
    }
    ArrayList<byte[]> processedUserIds=new ArrayList<byte[]>();
    for (    byte[] rawUserId : new IterableIterator<byte[]>(masterKey.getRawUserIDs())) {
      String userId=Utf8Util.fromUTF8ByteArrayReplaceBadEncoding(rawUserId);
      if (processedUserIds.contains(rawUserId)) {
        log.add(LogType.MSG_KC_UID_DUP,indent,userId);
        modified=PGPPublicKey.removeCertification(modified,rawUserId);
      }
      processedUserIds.add(rawUserId);
      PGPSignature selfCert=null;
      revocation=null;
      @SuppressWarnings(""String_Node_Str"") Iterator<PGPSignature> signaturesIt=masterKey.getSignaturesForID(rawUserId);
      if (signaturesIt != null) {
        for (        PGPSignature zert : new IterableIterator<PGPSignature>(signaturesIt)) {
          WrappedSignature cert=new WrappedSignature(zert);
          long certId=cert.getKeyId();
          int type=zert.getSignatureType();
          if (type != PGPSignature.DEFAULT_CERTIFICATION && type != PGPSignature.NO_CERTIFICATION && type != PGPSignature.CASUAL_CERTIFICATION && type != PGPSignature.POSITIVE_CERTIFICATION && type != PGPSignature.CERTIFICATION_REVOCATION) {
            log.add(LogType.MSG_KC_UID_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(zert.getSignatureType(),16));
            modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
            badCerts+=1;
            continue;
          }
          if (cert.getCreationTime().after(now)) {
            log.add(LogType.MSG_KC_UID_BAD_TIME,indent);
            modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
            badCerts+=1;
            continue;
          }
          if (cert.isLocal()) {
            log.add(LogType.MSG_KC_UID_BAD_LOCAL,indent);
            modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
            badCerts+=1;
            continue;
          }
          if (certId != masterKeyId) {
            if (isSecret()) {
              log.add(LogType.MSG_KC_UID_FOREIGN,indent,KeyFormattingUtils.convertKeyIdToHex(certId));
              modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
              badCerts+=1;
            }
            continue;
          }
          try {
            cert.init(masterKey);
            if (!cert.verifySignature(masterKey,rawUserId)) {
              log.add(LogType.MSG_KC_UID_BAD,indent,userId);
              modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
              badCerts+=1;
              continue;
            }
            if (!Utf8Util.isValidUTF8(rawUserId)) {
              log.add(LogType.MSG_KC_UID_WARN_ENCODING,indent);
            }
          }
 catch (          PgpGeneralException e) {
            log.add(LogType.MSG_KC_UID_BAD_ERR,indent,userId);
            modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
            badCerts+=1;
            continue;
          }
switch (type) {
case PGPSignature.DEFAULT_CERTIFICATION:
case PGPSignature.NO_CERTIFICATION:
case PGPSignature.CASUAL_CERTIFICATION:
case PGPSignature.POSITIVE_CERTIFICATION:
            if (selfCert == null) {
              selfCert=zert;
            }
 else             if (selfCert.getCreationTime().before(cert.getCreationTime())) {
              log.add(LogType.MSG_KC_UID_CERT_DUP,indent,userId);
              modified=PGPPublicKey.removeCertification(modified,rawUserId,selfCert);
              redundantCerts+=1;
              selfCert=zert;
            }
 else {
              log.add(LogType.MSG_KC_UID_CERT_DUP,indent,userId);
              modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
              redundantCerts+=1;
            }
          if (revocation != null && revocation.getCreationTime().before(selfCert.getCreationTime())) {
            log.add(LogType.MSG_KC_UID_REVOKE_OLD,indent,userId);
            modified=PGPPublicKey.removeCertification(modified,rawUserId,revocation);
            revocation=null;
            redundantCerts+=1;
          }
        break;
case PGPSignature.CERTIFICATION_REVOCATION:
      if (selfCert != null && selfCert.getCreationTime().after(zert.getCreationTime())) {
        log.add(LogType.MSG_KC_UID_REVOKE_OLD,indent,userId);
        modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
        redundantCerts+=1;
        continue;
      }
    if (revocation == null) {
      revocation=zert;
    }
 else     if (revocation.getCreationTime().before(cert.getCreationTime())) {
      log.add(LogType.MSG_KC_UID_REVOKE_DUP,indent,userId);
      modified=PGPPublicKey.removeCertification(modified,rawUserId,revocation);
      redundantCerts+=1;
      revocation=zert;
    }
 else {
      log.add(LogType.MSG_KC_UID_REVOKE_DUP,indent,userId);
      modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
      redundantCerts+=1;
    }
  break;
}
}
}
if (selfCert == null && revocation == null) {
log.add(LogType.MSG_KC_UID_REMOVE,indent,userId);
modified=PGPPublicKey.removeCertification(modified,rawUserId);
}
}
if (modified == null || !modified.getUserIDs().hasNext()) {
log.add(LogType.MSG_KC_ERROR_NO_UID,indent);
return null;
}
ring=replacePublicKey(ring,modified);
indent-=1;
}
Set<Long> knownIds=new HashSet<Long>();
for (PGPPublicKey key : new IterableIterator<PGPPublicKey>(ring.getPublicKeys())) {
if (knownIds.contains(key.getKeyID())) {
log.add(LogType.MSG_KC_ERROR_DUP_KEY,indent,KeyFormattingUtils.convertKeyIdToHex(key.getKeyID()));
return null;
}
knownIds.add(key.getKeyID());
if (key.isMasterKey()) {
continue;
}
log.add(LogType.MSG_KC_SUB,indent,KeyFormattingUtils.convertKeyIdToHex(key.getKeyID()));
indent+=1;
if (Arrays.binarySearch(KNOWN_ALGORITHMS,key.getAlgorithm()) < 0) {
ring=removeSubKey(ring,key);
log.add(LogType.MSG_KC_SUB_UNKNOWN_ALGO,indent,Integer.toString(key.getAlgorithm()));
indent-=1;
continue;
}
PGPPublicKey modified=key;
PGPSignature selfCert=null, revocation=null;
uids: for (PGPSignature zert : new IterableIterator<PGPSignature>(key.getSignatures())) {
modified=PGPPublicKey.removeCertification(modified,zert);
WrappedSignature cert=new WrappedSignature(zert);
int type=cert.getSignatureType();
if (cert.getKeyId() != masterKey.getKeyID()) {
log.add(LogType.MSG_KC_SUB_BAD_KEYID,indent);
badCerts+=1;
continue;
}
if (type != PGPSignature.SUBKEY_BINDING && type != PGPSignature.SUBKEY_REVOCATION) {
log.add(LogType.MSG_KC_SUB_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(type,16));
badCerts+=1;
continue;
}
if (cert.getCreationTime().after(now)) {
log.add(LogType.MSG_KC_SUB_BAD_TIME,indent);
badCerts+=1;
continue;
}
if (cert.isLocal()) {
log.add(LogType.MSG_KC_SUB_BAD_LOCAL,indent);
badCerts+=1;
continue;
}
if (type == PGPSignature.SUBKEY_BINDING) {
try {
cert.init(masterKey);
if (!cert.verifySignature(masterKey,key)) {
log.add(LogType.MSG_KC_SUB_BAD,indent);
badCerts+=1;
continue;
}
}
 catch (PgpGeneralException e) {
log.add(LogType.MSG_KC_SUB_BAD_ERR,indent);
badCerts+=1;
continue;
}
boolean needsPrimaryBinding=false;
if (isSigningAlgo(key.getAlgorithm())) {
if (zert.getHashedSubPackets() != null && zert.getHashedSubPackets().hasSubpacket(SignatureSubpacketTags.KEY_FLAGS)) {
int flags=((KeyFlags)zert.getHashedSubPackets().getSubpacket(SignatureSubpacketTags.KEY_FLAGS)).getFlags();
if ((flags & KeyFlags.SIGN_DATA) == KeyFlags.SIGN_DATA) {
  needsPrimaryBinding=true;
}
}
 else {
needsPrimaryBinding=true;
}
}
if (needsPrimaryBinding) {
boolean ok=false;
if (zert.getUnhashedSubPackets() != null) try {
PGPSignatureList list=zert.getUnhashedSubPackets().getEmbeddedSignatures();
for (int i=0; i < list.size(); i++) {
  WrappedSignature subsig=new WrappedSignature(list.get(i));
  if (subsig.getSignatureType() == PGPSignature.PRIMARYKEY_BINDING) {
    subsig.init(key);
    if (subsig.verifySignature(masterKey,key)) {
      ok=true;
    }
 else {
      log.add(LogType.MSG_KC_SUB_PRIMARY_BAD,indent);
      badCerts+=1;
      continue uids;
    }
  }
}
}
 catch (Exception e) {
log.add(LogType.MSG_KC_SUB_PRIMARY_BAD_ERR,indent);
badCerts+=1;
continue;
}
if (!ok) {
log.add(LogType.MSG_KC_SUB_PRIMARY_NONE,indent);
badCerts+=1;
continue;
}
}
if (selfCert != null && cert.getCreationTime().before(selfCert.getCreationTime())) {
log.add(LogType.MSG_KC_SUB_DUP,indent);
redundantCerts+=1;
continue;
}
selfCert=zert;
if (revocation != null && selfCert.getCreationTime().after(revocation.getCreationTime())) {
log.add(LogType.MSG_KC_SUB_REVOKE_DUP,indent);
redundantCerts+=1;
revocation=null;
}
}
 else {
try {
cert.init(masterKey);
if (!cert.verifySignature(masterKey,key)) {
log.add(LogType.MSG_KC_SUB_REVOKE_BAD,indent);
badCerts+=1;
continue;
}
}
 catch (PgpGeneralException e) {
log.add(LogType.MSG_KC_SUB_REVOKE_BAD_ERR,indent);
badCerts+=1;
continue;
}
if (selfCert != null && selfCert.getCreationTime().after(cert.getCreationTime())) {
log.add(LogType.MSG_KC_SUB_REVOKE_DUP,indent);
redundantCerts+=1;
continue;
}
revocation=zert;
}
}
if (selfCert == null) {
ring=removeSubKey(ring,key);
log.add(LogType.MSG_KC_SUB_NO_CERT,indent,KeyFormattingUtils.convertKeyIdToHex(key.getKeyID()));
indent-=1;
continue;
}
if (selfCert.getHashedSubPackets() == null && selfCert.getHashedSubPackets().hasSubpacket(SignatureSubpacketTags.KEY_FLAGS)) {
int flags=((KeyFlags)selfCert.getHashedSubPackets().getSubpacket(SignatureSubpacketTags.KEY_FLAGS)).getFlags();
int algo=key.getAlgorithm();
if (!isSigningAlgo(algo) && (flags & KeyFlags.SIGN_DATA) == KeyFlags.SIGN_DATA) {
log.add(LogType.MSG_KC_SUB_ALGO_BAD_SIGN,indent);
}
if (!isEncryptionAlgo(algo) && ((flags & KeyFlags.ENCRYPT_STORAGE) == KeyFlags.ENCRYPT_STORAGE || (flags & KeyFlags.ENCRYPT_COMMS) == KeyFlags.ENCRYPT_COMMS)) {
log.add(LogType.MSG_KC_SUB_ALGO_BAD_ENCRYPT,indent);
}
}
modified=PGPPublicKey.addCertification(modified,selfCert);
if (revocation != null) {
modified=PGPPublicKey.addCertification(modified,revocation);
}
ring=replacePublicKey(ring,modified);
indent-=1;
}
if (badCerts > 0 && redundantCerts > 0) {
log.add(LogType.MSG_KC_SUCCESS_BAD_AND_RED,indent,Integer.toString(badCerts),Integer.toString(redundantCerts));
}
 else if (badCerts > 0) {
log.add(LogType.MSG_KC_SUCCESS_BAD,indent,badCerts);
}
 else if (redundantCerts > 0) {
log.add(LogType.MSG_KC_SUCCESS_REDUNDANT,indent,redundantCerts);
}
 else {
log.add(LogType.MSG_KC_SUCCESS,indent);
}
return isSecret() ? new CanonicalizedSecretKeyRing((PGPSecretKeyRing)ring,1) : new CanonicalizedPublicKeyRing((PGPPublicKeyRing)ring,0);
}","/** 
 * ""Canonicalizes"" a public key, removing inconsistencies in the process. More specifically: - Remove all non-verifying self-certificates - Remove all ""future"" self-certificates - Remove all certificates flagged as ""local"" - Remove all certificates which are superseded by a newer one on the same target, including revocations with later re-certifications. - Remove all certificates in other positions if not of known type: - key revocation signatures on the master key - subkey binding signatures for subkeys - certifications and certification revocations for user ids - If a subkey retains no valid subkey binding certificate, remove it - If a user id retains no valid self certificate, remove it - If the key is a secret key, remove all certificates by foreign keys - If no valid user id remains, log an error and return null This operation writes an OperationLog which can be used as part of an OperationResultParcel.
 * @return A canonicalized key, or null on fatal error (log will include a message in this case)
 */
@SuppressWarnings(""String_Node_Str"") public CanonicalizedKeyRing canonicalize(OperationLog log,int indent){
  log.add(isSecret() ? LogType.MSG_KC_SECRET : LogType.MSG_KC_PUBLIC,indent,KeyFormattingUtils.convertKeyIdToHex(getMasterKeyId()));
  indent+=1;
  if (getVersion() <= 3) {
    log.add(LogType.MSG_KC_ERROR_V3,indent);
    return null;
  }
  final Date now=new Date();
  int redundantCerts=0, badCerts=0;
  PGPKeyRing ring=mRing;
  PGPPublicKey masterKey=mRing.getPublicKey();
  final long masterKeyId=masterKey.getKeyID();
  if (Arrays.binarySearch(KNOWN_ALGORITHMS,masterKey.getAlgorithm()) < 0) {
    log.add(LogType.MSG_KC_ERROR_MASTER_ALGO,indent,Integer.toString(masterKey.getAlgorithm()));
    return null;
  }
{
    log.add(LogType.MSG_KC_MASTER,indent,KeyFormattingUtils.convertKeyIdToHex(masterKey.getKeyID()));
    indent+=1;
    PGPPublicKey modified=masterKey;
    PGPSignature revocation=null;
    for (    PGPSignature zert : new IterableIterator<PGPSignature>(masterKey.getKeySignatures())) {
      int type=zert.getSignatureType();
      if (type == PGPSignature.NO_CERTIFICATION || type == PGPSignature.DEFAULT_CERTIFICATION || type == PGPSignature.CASUAL_CERTIFICATION || type == PGPSignature.POSITIVE_CERTIFICATION || type == PGPSignature.CERTIFICATION_REVOCATION) {
        log.add(LogType.MSG_KC_REVOKE_BAD_TYPE_UID,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      WrappedSignature cert=new WrappedSignature(zert);
      if (type != PGPSignature.KEY_REVOCATION) {
        log.add(LogType.MSG_KC_REVOKE_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(type,16));
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (cert.getCreationTime().after(now)) {
        log.add(LogType.MSG_KC_REVOKE_BAD_TIME,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (cert.isLocal()) {
        log.add(LogType.MSG_KC_REVOKE_BAD_LOCAL,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      try {
        cert.init(masterKey);
        if (!cert.verifySignature(masterKey)) {
          log.add(LogType.MSG_KC_REVOKE_BAD,indent);
          modified=PGPPublicKey.removeCertification(modified,zert);
          badCerts+=1;
          continue;
        }
      }
 catch (      PgpGeneralException e) {
        log.add(LogType.MSG_KC_REVOKE_BAD_ERR,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (revocation == null) {
        revocation=zert;
      }
 else       if (revocation.getCreationTime().before(zert.getCreationTime())) {
        log.add(LogType.MSG_KC_REVOKE_DUP,indent);
        modified=PGPPublicKey.removeCertification(modified,revocation);
        redundantCerts+=1;
        revocation=zert;
      }
 else {
        log.add(LogType.MSG_KC_REVOKE_DUP,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        redundantCerts+=1;
      }
    }
    ArrayList<byte[]> processedUserIds=new ArrayList<byte[]>();
    for (    byte[] rawUserId : new IterableIterator<byte[]>(masterKey.getRawUserIDs())) {
      String userId=Utf8Util.fromUTF8ByteArrayReplaceBadEncoding(rawUserId);
      if (processedUserIds.contains(rawUserId)) {
        log.add(LogType.MSG_KC_UID_DUP,indent,userId);
        modified=PGPPublicKey.removeCertification(modified,rawUserId);
      }
      processedUserIds.add(rawUserId);
      PGPSignature selfCert=null;
      revocation=null;
      @SuppressWarnings(""String_Node_Str"") Iterator<PGPSignature> signaturesIt=masterKey.getSignaturesForID(rawUserId);
      if (signaturesIt != null) {
        for (        PGPSignature zert : new IterableIterator<PGPSignature>(signaturesIt)) {
          WrappedSignature cert=new WrappedSignature(zert);
          long certId=cert.getKeyId();
          int type=zert.getSignatureType();
          if (type != PGPSignature.DEFAULT_CERTIFICATION && type != PGPSignature.NO_CERTIFICATION && type != PGPSignature.CASUAL_CERTIFICATION && type != PGPSignature.POSITIVE_CERTIFICATION && type != PGPSignature.CERTIFICATION_REVOCATION) {
            log.add(LogType.MSG_KC_UID_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(zert.getSignatureType(),16));
            modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
            badCerts+=1;
            continue;
          }
          if (cert.getCreationTime().after(now)) {
            log.add(LogType.MSG_KC_UID_BAD_TIME,indent);
            modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
            badCerts+=1;
            continue;
          }
          if (cert.isLocal()) {
            log.add(LogType.MSG_KC_UID_BAD_LOCAL,indent);
            modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
            badCerts+=1;
            continue;
          }
          if (certId != masterKeyId) {
            if (isSecret()) {
              log.add(LogType.MSG_KC_UID_FOREIGN,indent,KeyFormattingUtils.convertKeyIdToHex(certId));
              modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
              badCerts+=1;
            }
            continue;
          }
          try {
            cert.init(masterKey);
            if (!cert.verifySignature(masterKey,rawUserId)) {
              log.add(LogType.MSG_KC_UID_BAD,indent,userId);
              modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
              badCerts+=1;
              continue;
            }
            if (!Utf8Util.isValidUTF8(rawUserId)) {
              log.add(LogType.MSG_KC_UID_WARN_ENCODING,indent);
            }
          }
 catch (          PgpGeneralException e) {
            log.add(LogType.MSG_KC_UID_BAD_ERR,indent,userId);
            modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
            badCerts+=1;
            continue;
          }
switch (type) {
case PGPSignature.DEFAULT_CERTIFICATION:
case PGPSignature.NO_CERTIFICATION:
case PGPSignature.CASUAL_CERTIFICATION:
case PGPSignature.POSITIVE_CERTIFICATION:
            if (selfCert == null) {
              selfCert=zert;
            }
 else             if (selfCert.getCreationTime().before(cert.getCreationTime())) {
              log.add(LogType.MSG_KC_UID_CERT_DUP,indent,userId);
              modified=PGPPublicKey.removeCertification(modified,rawUserId,selfCert);
              redundantCerts+=1;
              selfCert=zert;
            }
 else {
              log.add(LogType.MSG_KC_UID_CERT_DUP,indent,userId);
              modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
              redundantCerts+=1;
            }
          if (revocation != null && revocation.getCreationTime().before(selfCert.getCreationTime())) {
            log.add(LogType.MSG_KC_UID_REVOKE_OLD,indent,userId);
            modified=PGPPublicKey.removeCertification(modified,rawUserId,revocation);
            revocation=null;
            redundantCerts+=1;
          }
        break;
case PGPSignature.CERTIFICATION_REVOCATION:
      if (selfCert != null && selfCert.getCreationTime().after(zert.getCreationTime())) {
        log.add(LogType.MSG_KC_UID_REVOKE_OLD,indent,userId);
        modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
        redundantCerts+=1;
        continue;
      }
    if (revocation == null) {
      revocation=zert;
    }
 else     if (revocation.getCreationTime().before(cert.getCreationTime())) {
      log.add(LogType.MSG_KC_UID_REVOKE_DUP,indent,userId);
      modified=PGPPublicKey.removeCertification(modified,rawUserId,revocation);
      redundantCerts+=1;
      revocation=zert;
    }
 else {
      log.add(LogType.MSG_KC_UID_REVOKE_DUP,indent,userId);
      modified=PGPPublicKey.removeCertification(modified,rawUserId,zert);
      redundantCerts+=1;
    }
  break;
}
}
}
if (selfCert == null && revocation == null) {
log.add(LogType.MSG_KC_UID_REMOVE,indent,userId);
modified=PGPPublicKey.removeCertification(modified,rawUserId);
}
}
if (modified == null || !modified.getUserIDs().hasNext()) {
log.add(LogType.MSG_KC_ERROR_NO_UID,indent);
return null;
}
ring=replacePublicKey(ring,modified);
indent-=1;
}
Set<Long> knownIds=new HashSet<Long>();
for (PGPPublicKey key : new IterableIterator<PGPPublicKey>(ring.getPublicKeys())) {
if (knownIds.contains(key.getKeyID())) {
log.add(LogType.MSG_KC_ERROR_DUP_KEY,indent,KeyFormattingUtils.convertKeyIdToHex(key.getKeyID()));
return null;
}
knownIds.add(key.getKeyID());
if (key.isMasterKey()) {
continue;
}
log.add(LogType.MSG_KC_SUB,indent,KeyFormattingUtils.convertKeyIdToHex(key.getKeyID()));
indent+=1;
if (Arrays.binarySearch(KNOWN_ALGORITHMS,key.getAlgorithm()) < 0) {
ring=removeSubKey(ring,key);
log.add(LogType.MSG_KC_SUB_UNKNOWN_ALGO,indent,Integer.toString(key.getAlgorithm()));
indent-=1;
continue;
}
PGPPublicKey modified=key;
PGPSignature selfCert=null, revocation=null;
uids: for (PGPSignature zert : new IterableIterator<PGPSignature>(key.getSignatures())) {
modified=PGPPublicKey.removeCertification(modified,zert);
WrappedSignature cert=new WrappedSignature(zert);
int type=cert.getSignatureType();
if (cert.getKeyId() != masterKey.getKeyID()) {
log.add(LogType.MSG_KC_SUB_BAD_KEYID,indent);
badCerts+=1;
continue;
}
if (type != PGPSignature.SUBKEY_BINDING && type != PGPSignature.SUBKEY_REVOCATION) {
log.add(LogType.MSG_KC_SUB_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(type,16));
badCerts+=1;
continue;
}
if (cert.getCreationTime().after(now)) {
log.add(LogType.MSG_KC_SUB_BAD_TIME,indent);
badCerts+=1;
continue;
}
if (cert.isLocal()) {
log.add(LogType.MSG_KC_SUB_BAD_LOCAL,indent);
badCerts+=1;
continue;
}
if (type == PGPSignature.SUBKEY_BINDING) {
try {
cert.init(masterKey);
if (!cert.verifySignature(masterKey,key)) {
log.add(LogType.MSG_KC_SUB_BAD,indent);
badCerts+=1;
continue;
}
}
 catch (PgpGeneralException e) {
log.add(LogType.MSG_KC_SUB_BAD_ERR,indent);
badCerts+=1;
continue;
}
boolean needsPrimaryBinding=false;
if (isSigningAlgo(key.getAlgorithm())) {
if (zert.getHashedSubPackets() != null && zert.getHashedSubPackets().hasSubpacket(SignatureSubpacketTags.KEY_FLAGS)) {
int flags=((KeyFlags)zert.getHashedSubPackets().getSubpacket(SignatureSubpacketTags.KEY_FLAGS)).getFlags();
if ((flags & KeyFlags.SIGN_DATA) == KeyFlags.SIGN_DATA) {
  needsPrimaryBinding=true;
}
}
 else {
needsPrimaryBinding=true;
}
}
if (needsPrimaryBinding) {
boolean ok=false;
if (zert.getUnhashedSubPackets() != null) try {
PGPSignatureList list=zert.getUnhashedSubPackets().getEmbeddedSignatures();
for (int i=0; i < list.size(); i++) {
  WrappedSignature subsig=new WrappedSignature(list.get(i));
  if (subsig.getSignatureType() == PGPSignature.PRIMARYKEY_BINDING) {
    subsig.init(key);
    if (subsig.verifySignature(masterKey,key)) {
      ok=true;
    }
 else {
      log.add(LogType.MSG_KC_SUB_PRIMARY_BAD,indent);
      badCerts+=1;
      continue uids;
    }
  }
}
}
 catch (Exception e) {
log.add(LogType.MSG_KC_SUB_PRIMARY_BAD_ERR,indent);
badCerts+=1;
continue;
}
if (!ok) {
log.add(LogType.MSG_KC_SUB_PRIMARY_NONE,indent);
badCerts+=1;
continue;
}
}
if (selfCert != null && cert.getCreationTime().before(selfCert.getCreationTime())) {
log.add(LogType.MSG_KC_SUB_DUP,indent);
redundantCerts+=1;
continue;
}
selfCert=zert;
if (revocation != null && selfCert.getCreationTime().after(revocation.getCreationTime())) {
log.add(LogType.MSG_KC_SUB_REVOKE_DUP,indent);
redundantCerts+=1;
revocation=null;
}
}
 else {
try {
cert.init(masterKey);
if (!cert.verifySignature(masterKey,key)) {
log.add(LogType.MSG_KC_SUB_REVOKE_BAD,indent);
badCerts+=1;
continue;
}
}
 catch (PgpGeneralException e) {
log.add(LogType.MSG_KC_SUB_REVOKE_BAD_ERR,indent);
badCerts+=1;
continue;
}
if (selfCert != null && selfCert.getCreationTime().after(cert.getCreationTime())) {
log.add(LogType.MSG_KC_SUB_REVOKE_DUP,indent);
redundantCerts+=1;
continue;
}
revocation=zert;
}
}
if (selfCert == null) {
ring=removeSubKey(ring,key);
log.add(LogType.MSG_KC_SUB_NO_CERT,indent,KeyFormattingUtils.convertKeyIdToHex(key.getKeyID()));
indent-=1;
continue;
}
if (selfCert.getHashedSubPackets() != null && selfCert.getHashedSubPackets().hasSubpacket(SignatureSubpacketTags.KEY_FLAGS)) {
int flags=((KeyFlags)selfCert.getHashedSubPackets().getSubpacket(SignatureSubpacketTags.KEY_FLAGS)).getFlags();
int algo=key.getAlgorithm();
if (!isSigningAlgo(algo) && (flags & KeyFlags.SIGN_DATA) == KeyFlags.SIGN_DATA) {
log.add(LogType.MSG_KC_SUB_ALGO_BAD_SIGN,indent);
}
if (!isEncryptionAlgo(algo) && ((flags & KeyFlags.ENCRYPT_STORAGE) == KeyFlags.ENCRYPT_STORAGE || (flags & KeyFlags.ENCRYPT_COMMS) == KeyFlags.ENCRYPT_COMMS)) {
log.add(LogType.MSG_KC_SUB_ALGO_BAD_ENCRYPT,indent);
}
}
modified=PGPPublicKey.addCertification(modified,selfCert);
if (revocation != null) {
modified=PGPPublicKey.addCertification(modified,revocation);
}
ring=replacePublicKey(ring,modified);
indent-=1;
}
if (badCerts > 0 && redundantCerts > 0) {
log.add(LogType.MSG_KC_SUCCESS_BAD_AND_RED,indent,Integer.toString(badCerts),Integer.toString(redundantCerts));
}
 else if (badCerts > 0) {
log.add(LogType.MSG_KC_SUCCESS_BAD,indent,badCerts);
}
 else if (redundantCerts > 0) {
log.add(LogType.MSG_KC_SUCCESS_REDUNDANT,indent,redundantCerts);
}
 else {
log.add(LogType.MSG_KC_SUCCESS,indent);
}
return isSecret() ? new CanonicalizedSecretKeyRing((PGPSecretKeyRing)ring,1) : new CanonicalizedPublicKeyRing((PGPPublicKeyRing)ring,0);
}",0.9999317126468178
8354,"private boolean mergeDupes(ImportKeysListEntry incoming,ImportKeysListEntry existing){
  boolean modified=false;
  if (incoming.isRevoked()) {
    existing.setRevoked(true);
    modified=true;
  }
  if (incoming.isExpired()) {
    existing.setExpired(true);
    modified=true;
  }
  for (  String origin : incoming.getOrigins()) {
    existing.addOrigin(origin);
  }
  ArrayList<String> incomingIDs=incoming.getUserIds();
  ArrayList<String> existingIDs=existing.getUserIds();
  for (  String incomingID : incomingIDs) {
    if (!existingIDs.contains(incomingID)) {
      existingIDs.add(incomingID);
      modified=true;
    }
  }
  existing.updateMergedUserIds();
  return modified;
}","private boolean mergeDupes(ImportKeysListEntry incoming,ImportKeysListEntry existing){
  boolean modified=false;
  if (incoming.isRevoked()) {
    existing.setRevoked(true);
    modified=true;
  }
  if (incoming.isExpired()) {
    existing.setExpired(true);
    modified=true;
  }
  for (  String origin : incoming.getOrigins()) {
    existing.addOrigin(origin);
    if (KeybaseKeyserver.ORIGIN.equals(origin)) {
      existing.setExtraData(incoming.getExtraData());
    }
  }
  ArrayList<String> incomingIDs=incoming.getUserIds();
  ArrayList<String> existingIDs=existing.getUserIds();
  for (  String incomingID : incomingIDs) {
    if (!existingIDs.contains(incomingID)) {
      existingIDs.add(incomingID);
      modified=true;
    }
  }
  existing.updateMergedUserIds();
  return modified;
}",0.9257759784075572
8355,"/** 
 * The IntentService calls this method from the default worker thread with the intent that started the service. When this method returns, IntentService stops the service, as appropriate.
 */
@Override protected void onHandleIntent(Intent intent){
  mActionCanceled.set(false);
  Bundle extras=intent.getExtras();
  if (extras == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  if (!(extras.containsKey(EXTRA_MESSENGER) || extras.containsKey(EXTRA_DATA) || (intent.getAction() == null))) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  Uri dataUri=intent.getData();
  mMessenger=(Messenger)extras.get(EXTRA_MESSENGER);
  Bundle data=extras.getBundle(EXTRA_DATA);
  if (data == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  OtherHelper.logDebugBundle(data,""String_Node_Str"");
  String action=intent.getAction();
  if (ACTION_ENCRYPT_SIGN.equals(action)) {
    try {
      int source=data.get(SOURCE) != null ? data.getInt(SOURCE) : data.getInt(TARGET);
      Bundle resultData=new Bundle();
      long sigMasterKeyId=data.getLong(ENCRYPT_SIGNATURE_MASTER_ID);
      String symmetricPassphrase=data.getString(ENCRYPT_SYMMETRIC_PASSPHRASE);
      boolean useAsciiArmor=data.getBoolean(ENCRYPT_USE_ASCII_ARMOR);
      long encryptionKeyIds[]=data.getLongArray(ENCRYPT_ENCRYPTION_KEYS_IDS);
      int compressionId=data.getInt(ENCRYPT_COMPRESSION_ID);
      int urisCount=data.containsKey(ENCRYPT_INPUT_URIS) ? data.getParcelableArrayList(ENCRYPT_INPUT_URIS).size() : 1;
      for (int i=0; i < urisCount; i++) {
        data.putInt(SELECTED_URI,i);
        InputData inputData=createEncryptInputData(data);
        OutputStream outStream=createCryptOutputStream(data);
        String originalFilename=getOriginalFilename(data);
        PgpSignEncrypt.Builder builder=new PgpSignEncrypt.Builder(new ProviderHelper(this),inputData,outStream);
        builder.setProgressable(this).setEnableAsciiArmorOutput(useAsciiArmor).setVersionHeader(PgpHelper.getVersionForHeader(this)).setCompressionId(compressionId).setSymmetricEncryptionAlgorithm(Preferences.getPreferences(this).getDefaultEncryptionAlgorithm()).setEncryptionMasterKeyIds(encryptionKeyIds).setSymmetricPassphrase(symmetricPassphrase).setOriginalFilename(originalFilename);
        try {
          CachedPublicKeyRing signingRing=new ProviderHelper(this).getCachedPublicKeyRing(sigMasterKeyId);
          long sigSubKeyId=signingRing.getSignId();
          String passphrase=PassphraseCacheService.getCachedPassphrase(this,sigSubKeyId);
          builder.setSignatureMasterKeyId(sigMasterKeyId).setSignatureSubKeyId(sigSubKeyId).setSignaturePassphrase(passphrase).setSignatureHashAlgorithm(Preferences.getPreferences(this).getDefaultHashAlgorithm()).setAdditionalEncryptId(sigMasterKeyId);
        }
 catch (        PgpGeneralException e) {
        }
        if (source == IO_BYTES) {
          builder.setCleartextInput(true);
        }
        builder.build().execute();
        outStream.close();
        finalizeEncryptOutputStream(data,resultData,outStream);
      }
      OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,resultData);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_DECRYPT_VERIFY.equals(action)) {
    try {
      String passphrase=data.getString(DECRYPT_PASSPHRASE);
      InputData inputData=createDecryptInputData(data);
      OutputStream outStream=createCryptOutputStream(data);
      Bundle resultData=new Bundle();
      PgpDecryptVerify.Builder builder=new PgpDecryptVerify.Builder(new ProviderHelper(this),new PgpDecryptVerify.PassphraseCache(){
        @Override public String getCachedPassphrase(        long masterKeyId){
          try {
            return PassphraseCacheService.getCachedPassphrase(KeychainIntentService.this,masterKeyId);
          }
 catch (          PassphraseCacheService.KeyNotFoundException e) {
            return null;
          }
        }
      }
,inputData,outStream);
      builder.setProgressable(this).setAllowSymmetricDecryption(true).setPassphrase(passphrase);
      DecryptVerifyResult decryptVerifyResult=builder.build().execute();
      outStream.close();
      resultData.putParcelable(RESULT_DECRYPT_VERIFY_RESULT,decryptVerifyResult);
      finalizeDecryptOutputStream(data,resultData,outStream);
      OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,resultData);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_DECRYPT_METADATA.equals(action)) {
    try {
      String passphrase=data.getString(DECRYPT_PASSPHRASE);
      InputData inputData=createDecryptInputData(data);
      Bundle resultData=new Bundle();
      PgpDecryptVerify.Builder builder=new PgpDecryptVerify.Builder(new ProviderHelper(this),new PgpDecryptVerify.PassphraseCache(){
        @Override public String getCachedPassphrase(        long masterKeyId) throws PgpDecryptVerify.NoSecretKeyException {
          try {
            return PassphraseCacheService.getCachedPassphrase(KeychainIntentService.this,masterKeyId);
          }
 catch (          PassphraseCacheService.KeyNotFoundException e) {
            throw new PgpDecryptVerify.NoSecretKeyException();
          }
        }
      }
,inputData,null);
      builder.setProgressable(this).setAllowSymmetricDecryption(true).setPassphrase(passphrase).setDecryptMetadataOnly(true);
      DecryptVerifyResult decryptVerifyResult=builder.build().execute();
      resultData.putParcelable(RESULT_DECRYPT_VERIFY_RESULT,decryptVerifyResult);
      OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,resultData);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_EDIT_KEYRING.equals(action)) {
    try {
      SaveKeyringParcel saveParcel=data.getParcelable(EDIT_KEYRING_PARCEL);
      if (saveParcel == null) {
        Log.e(Constants.TAG,""String_Node_Str"");
        return;
      }
      PgpKeyOperation keyOperations=new PgpKeyOperation(new ProgressScaler(this,10,60,100),mActionCanceled);
      EditKeyResult modifyResult;
      if (saveParcel.mMasterKeyId != null) {
        String passphrase=data.getString(EDIT_KEYRING_PASSPHRASE);
        CanonicalizedSecretKeyRing secRing=new ProviderHelper(this).getCanonicalizedSecretKeyRing(saveParcel.mMasterKeyId);
        modifyResult=keyOperations.modifySecretKeyRing(secRing,saveParcel,passphrase);
      }
 else {
        modifyResult=keyOperations.createSecretKeyRing(saveParcel);
      }
      if (!modifyResult.success()) {
        SaveKeyringResult saveResult=new SaveKeyringResult(SaveKeyringResult.RESULT_ERROR,modifyResult.getLog(),null);
        sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,saveResult);
        return;
      }
      UncachedKeyRing ring=modifyResult.getRing();
      if (mActionCanceled.get()) {
        OperationLog log=modifyResult.getLog();
        if (!modifyResult.cancelled()) {
          log.add(LogLevel.CANCELLED,LogType.MSG_OPERATION_CANCELLED,0);
        }
        SaveKeyringResult saveResult=new SaveKeyringResult(SaveKeyringResult.RESULT_CANCELLED,log,null);
        sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,saveResult);
        return;
      }
      SaveKeyringResult saveResult=new ProviderHelper(this,modifyResult.getLog()).saveSecretKeyRing(ring,new ProgressScaler(this,60,95,100));
      if (!saveResult.success()) {
        sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,saveResult);
        return;
      }
      if (saveParcel.mNewPassphrase != null) {
        PassphraseCacheService.addCachedPassphrase(this,ring.getMasterKeyId(),saveParcel.mNewPassphrase,ring.getPublicKey().getPrimaryUserIdWithFallback());
      }
      setProgress(R.string.progress_done,100,100);
      ContactSyncAdapterService.requestSync();
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,saveResult);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_DELETE_FILE_SECURELY.equals(action)) {
    try {
      String deleteFile=data.getString(DELETE_FILE);
      try {
        PgpHelper.deleteFileSecurely(this,this,new File(deleteFile));
      }
 catch (      FileNotFoundException e) {
        throw new PgpGeneralException(getString(R.string.error_file_not_found,deleteFile));
      }
catch (      IOException e) {
        throw new PgpGeneralException(getString(R.string.error_file_delete_failed,deleteFile));
      }
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_IMPORT_KEYRING.equals(action)) {
    try {
      List<ParcelableKeyRing> entries;
      if (data.containsKey(IMPORT_KEY_LIST)) {
        entries=data.getParcelableArrayList(IMPORT_KEY_LIST);
      }
 else {
        ParcelableFileCache<ParcelableKeyRing> cache=new ParcelableFileCache<ParcelableKeyRing>(this,""String_Node_Str"");
        entries=cache.readCacheIntoList();
      }
      ProviderHelper providerHelper=new ProviderHelper(this);
      PgpImportExport pgpImportExport=new PgpImportExport(this,providerHelper,this,mActionCanceled);
      ImportKeyResult result=pgpImportExport.importKeyRings(entries);
      if (result.mSecret > 0) {
        sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_PREVENT_CANCEL);
        providerHelper.consolidateDatabaseStep1(this);
      }
      ContactSyncAdapterService.requestSync();
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,result);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_EXPORT_KEYRING.equals(action)) {
    try {
      boolean exportSecret=data.getBoolean(EXPORT_SECRET,false);
      long[] masterKeyIds=data.getLongArray(EXPORT_KEY_RING_MASTER_KEY_ID);
      String outputFile=data.getString(EXPORT_FILENAME);
      Uri outputUri=data.getParcelable(EXPORT_URI);
      boolean exportAll=data.getBoolean(EXPORT_ALL);
      if (outputFile != null) {
        if (!FileHelper.isStorageMounted(outputFile)) {
          throw new PgpGeneralException(getString(R.string.error_external_storage_not_ready));
        }
      }
      ArrayList<Long> publicMasterKeyIds=new ArrayList<Long>();
      ArrayList<Long> secretMasterKeyIds=new ArrayList<Long>();
      String selection=null;
      if (!exportAll) {
        selection=KeychainDatabase.Tables.KEYS + ""String_Node_Str"" + KeyRings.MASTER_KEY_ID+ ""String_Node_Str"";
        for (        long l : masterKeyIds) {
          selection+=Long.toString(l) + ""String_Node_Str"";
        }
        selection=selection.substring(0,selection.length() - 1) + ""String_Node_Str"";
      }
      Cursor cursor=getContentResolver().query(KeyRings.buildUnifiedKeyRingsUri(),new String[]{KeyRings.MASTER_KEY_ID,KeyRings.HAS_ANY_SECRET},selection,null,null);
      try {
        if (cursor != null && cursor.moveToFirst())         do {
          publicMasterKeyIds.add(cursor.getLong(0));
          if (exportSecret && cursor.getInt(1) != 0)           secretMasterKeyIds.add(cursor.getLong(0));
        }
 while (cursor.moveToNext());
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
      OutputStream outStream;
      if (outputFile != null) {
        outStream=new FileOutputStream(outputFile);
      }
 else {
        outStream=getContentResolver().openOutputStream(outputUri);
      }
      PgpImportExport pgpImportExport=new PgpImportExport(this,new ProviderHelper(this),this);
      Bundle resultData=pgpImportExport.exportKeyRings(publicMasterKeyIds,secretMasterKeyIds,outStream);
      if (mActionCanceled.get() && outputFile != null) {
        new File(outputFile).delete();
      }
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,resultData);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_UPLOAD_KEYRING.equals(action)) {
    try {
      String keyServer=data.getString(UPLOAD_KEY_SERVER);
      HkpKeyserver server=new HkpKeyserver(keyServer);
      ProviderHelper providerHelper=new ProviderHelper(this);
      CanonicalizedPublicKeyRing keyring=providerHelper.getCanonicalizedPublicKeyRing(dataUri);
      PgpImportExport pgpImportExport=new PgpImportExport(this,new ProviderHelper(this),this);
      try {
        pgpImportExport.uploadKeyRingToServer(server,keyring);
      }
 catch (      Keyserver.AddKeyException e) {
        throw new PgpGeneralException(""String_Node_Str"");
      }
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_DOWNLOAD_AND_IMPORT_KEYS.equals(action) || ACTION_IMPORT_KEYBASE_KEYS.equals(action)) {
    try {
      ArrayList<ImportKeysListEntry> entries=data.getParcelableArrayList(DOWNLOAD_KEY_LIST);
      String keyServer=data.getString(DOWNLOAD_KEY_SERVER);
      ArrayList<ParcelableKeyRing> keyRings=new ArrayList<ParcelableKeyRing>(entries.size());
      for (      ImportKeysListEntry entry : entries) {
        Keyserver server;
        if (entry.getOrigin() == null) {
          server=new HkpKeyserver(keyServer);
        }
 else         if (KeybaseKeyserver.ORIGIN.equals(entry.getOrigin())) {
          server=new KeybaseKeyserver();
        }
 else {
          server=new HkpKeyserver(entry.getOrigin());
        }
        byte[] downloadedKeyBytes;
        if (KeybaseKeyserver.ORIGIN.equals(entry.getOrigin())) {
          downloadedKeyBytes=server.get(entry.getExtraData()).getBytes();
        }
 else         if (entry.getFingerprintHex() != null) {
          downloadedKeyBytes=server.get(""String_Node_Str"" + entry.getFingerprintHex()).getBytes();
        }
 else {
          downloadedKeyBytes=server.get(entry.getKeyIdHex()).getBytes();
        }
        keyRings.add(new ParcelableKeyRing(downloadedKeyBytes,entry.getFingerprintHex()));
      }
      Intent importIntent=new Intent(this,KeychainIntentService.class);
      importIntent.setAction(ACTION_IMPORT_KEYRING);
      Bundle importData=new Bundle();
      importData.putParcelableArrayList(IMPORT_KEY_LIST,keyRings);
      importIntent.putExtra(EXTRA_DATA,importData);
      importIntent.putExtra(EXTRA_MESSENGER,mMessenger);
      onHandleIntent(importIntent);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_CERTIFY_KEYRING.equals(action)) {
    try {
      long masterKeyId=data.getLong(CERTIFY_KEY_MASTER_KEY_ID);
      long pubKeyId=data.getLong(CERTIFY_KEY_PUB_KEY_ID);
      ArrayList<String> userIds=data.getStringArrayList(CERTIFY_KEY_UIDS);
      String signaturePassphrase=PassphraseCacheService.getCachedPassphrase(this,masterKeyId);
      if (signaturePassphrase == null) {
        throw new PgpGeneralException(""String_Node_Str"");
      }
      ProviderHelper providerHelper=new ProviderHelper(this);
      CanonicalizedPublicKeyRing publicRing=providerHelper.getCanonicalizedPublicKeyRing(pubKeyId);
      CanonicalizedSecretKeyRing secretKeyRing=providerHelper.getCanonicalizedSecretKeyRing(masterKeyId);
      CanonicalizedSecretKey certificationKey=secretKeyRing.getSecretKey();
      if (!certificationKey.unlock(signaturePassphrase)) {
        throw new PgpGeneralException(""String_Node_Str"");
      }
      UncachedKeyRing newRing=certificationKey.certifyUserIds(publicRing,userIds,null,null);
      providerHelper.savePublicKeyRing(newRing);
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_DELETE.equals(action)) {
    try {
      long[] masterKeyIds=data.getLongArray(DELETE_KEY_LIST);
      boolean isSecret=data.getBoolean(DELETE_IS_SECRET);
      if (masterKeyIds.length == 0) {
        throw new PgpGeneralException(""String_Node_Str"");
      }
      if (isSecret && masterKeyIds.length > 1) {
        throw new PgpGeneralException(""String_Node_Str"");
      }
      boolean success=false;
      for (      long masterKeyId : masterKeyIds) {
        int count=getContentResolver().delete(KeyRingData.buildPublicKeyRingUri(masterKeyId),null,null);
        success|=count > 0;
      }
      if (isSecret && success) {
        new ProviderHelper(this).consolidateDatabaseStep1(this);
      }
      if (success) {
        ContactSyncAdapterService.requestSync();
        sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY);
      }
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_CONSOLIDATE.equals(action)) {
    ConsolidateResult result;
    if (data.containsKey(CONSOLIDATE_RECOVERY) && data.getBoolean(CONSOLIDATE_RECOVERY)) {
      result=new ProviderHelper(this).consolidateDatabaseStep2(this);
    }
 else {
      result=new ProviderHelper(this).consolidateDatabaseStep1(this);
    }
    sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,result);
  }
}","/** 
 * The IntentService calls this method from the default worker thread with the intent that started the service. When this method returns, IntentService stops the service, as appropriate.
 */
@Override protected void onHandleIntent(Intent intent){
  mActionCanceled.set(false);
  Bundle extras=intent.getExtras();
  if (extras == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  if (!(extras.containsKey(EXTRA_MESSENGER) || extras.containsKey(EXTRA_DATA) || (intent.getAction() == null))) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  Uri dataUri=intent.getData();
  mMessenger=(Messenger)extras.get(EXTRA_MESSENGER);
  Bundle data=extras.getBundle(EXTRA_DATA);
  if (data == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  OtherHelper.logDebugBundle(data,""String_Node_Str"");
  String action=intent.getAction();
  if (ACTION_ENCRYPT_SIGN.equals(action)) {
    try {
      int source=data.get(SOURCE) != null ? data.getInt(SOURCE) : data.getInt(TARGET);
      Bundle resultData=new Bundle();
      long sigMasterKeyId=data.getLong(ENCRYPT_SIGNATURE_MASTER_ID);
      String symmetricPassphrase=data.getString(ENCRYPT_SYMMETRIC_PASSPHRASE);
      boolean useAsciiArmor=data.getBoolean(ENCRYPT_USE_ASCII_ARMOR);
      long encryptionKeyIds[]=data.getLongArray(ENCRYPT_ENCRYPTION_KEYS_IDS);
      int compressionId=data.getInt(ENCRYPT_COMPRESSION_ID);
      int urisCount=data.containsKey(ENCRYPT_INPUT_URIS) ? data.getParcelableArrayList(ENCRYPT_INPUT_URIS).size() : 1;
      for (int i=0; i < urisCount; i++) {
        data.putInt(SELECTED_URI,i);
        InputData inputData=createEncryptInputData(data);
        OutputStream outStream=createCryptOutputStream(data);
        String originalFilename=getOriginalFilename(data);
        PgpSignEncrypt.Builder builder=new PgpSignEncrypt.Builder(new ProviderHelper(this),inputData,outStream);
        builder.setProgressable(this).setEnableAsciiArmorOutput(useAsciiArmor).setVersionHeader(PgpHelper.getVersionForHeader(this)).setCompressionId(compressionId).setSymmetricEncryptionAlgorithm(Preferences.getPreferences(this).getDefaultEncryptionAlgorithm()).setEncryptionMasterKeyIds(encryptionKeyIds).setSymmetricPassphrase(symmetricPassphrase).setOriginalFilename(originalFilename);
        try {
          CachedPublicKeyRing signingRing=new ProviderHelper(this).getCachedPublicKeyRing(sigMasterKeyId);
          long sigSubKeyId=signingRing.getSignId();
          String passphrase=PassphraseCacheService.getCachedPassphrase(this,sigSubKeyId);
          builder.setSignatureMasterKeyId(sigMasterKeyId).setSignatureSubKeyId(sigSubKeyId).setSignaturePassphrase(passphrase).setSignatureHashAlgorithm(Preferences.getPreferences(this).getDefaultHashAlgorithm()).setAdditionalEncryptId(sigMasterKeyId);
        }
 catch (        PgpGeneralException e) {
        }
        if (source == IO_BYTES) {
          builder.setCleartextInput(true);
        }
        builder.build().execute();
        outStream.close();
        finalizeEncryptOutputStream(data,resultData,outStream);
      }
      OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,resultData);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_DECRYPT_VERIFY.equals(action)) {
    try {
      String passphrase=data.getString(DECRYPT_PASSPHRASE);
      InputData inputData=createDecryptInputData(data);
      OutputStream outStream=createCryptOutputStream(data);
      Bundle resultData=new Bundle();
      PgpDecryptVerify.Builder builder=new PgpDecryptVerify.Builder(new ProviderHelper(this),new PgpDecryptVerify.PassphraseCache(){
        @Override public String getCachedPassphrase(        long masterKeyId){
          try {
            return PassphraseCacheService.getCachedPassphrase(KeychainIntentService.this,masterKeyId);
          }
 catch (          PassphraseCacheService.KeyNotFoundException e) {
            return null;
          }
        }
      }
,inputData,outStream);
      builder.setProgressable(this).setAllowSymmetricDecryption(true).setPassphrase(passphrase);
      DecryptVerifyResult decryptVerifyResult=builder.build().execute();
      outStream.close();
      resultData.putParcelable(RESULT_DECRYPT_VERIFY_RESULT,decryptVerifyResult);
      finalizeDecryptOutputStream(data,resultData,outStream);
      OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,resultData);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_DECRYPT_METADATA.equals(action)) {
    try {
      String passphrase=data.getString(DECRYPT_PASSPHRASE);
      InputData inputData=createDecryptInputData(data);
      Bundle resultData=new Bundle();
      PgpDecryptVerify.Builder builder=new PgpDecryptVerify.Builder(new ProviderHelper(this),new PgpDecryptVerify.PassphraseCache(){
        @Override public String getCachedPassphrase(        long masterKeyId) throws PgpDecryptVerify.NoSecretKeyException {
          try {
            return PassphraseCacheService.getCachedPassphrase(KeychainIntentService.this,masterKeyId);
          }
 catch (          PassphraseCacheService.KeyNotFoundException e) {
            throw new PgpDecryptVerify.NoSecretKeyException();
          }
        }
      }
,inputData,null);
      builder.setProgressable(this).setAllowSymmetricDecryption(true).setPassphrase(passphrase).setDecryptMetadataOnly(true);
      DecryptVerifyResult decryptVerifyResult=builder.build().execute();
      resultData.putParcelable(RESULT_DECRYPT_VERIFY_RESULT,decryptVerifyResult);
      OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,resultData);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_EDIT_KEYRING.equals(action)) {
    try {
      SaveKeyringParcel saveParcel=data.getParcelable(EDIT_KEYRING_PARCEL);
      if (saveParcel == null) {
        Log.e(Constants.TAG,""String_Node_Str"");
        return;
      }
      PgpKeyOperation keyOperations=new PgpKeyOperation(new ProgressScaler(this,10,60,100),mActionCanceled);
      EditKeyResult modifyResult;
      if (saveParcel.mMasterKeyId != null) {
        String passphrase=data.getString(EDIT_KEYRING_PASSPHRASE);
        CanonicalizedSecretKeyRing secRing=new ProviderHelper(this).getCanonicalizedSecretKeyRing(saveParcel.mMasterKeyId);
        modifyResult=keyOperations.modifySecretKeyRing(secRing,saveParcel,passphrase);
      }
 else {
        modifyResult=keyOperations.createSecretKeyRing(saveParcel);
      }
      if (!modifyResult.success()) {
        SaveKeyringResult saveResult=new SaveKeyringResult(SaveKeyringResult.RESULT_ERROR,modifyResult.getLog(),null);
        sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,saveResult);
        return;
      }
      UncachedKeyRing ring=modifyResult.getRing();
      if (mActionCanceled.get()) {
        OperationLog log=modifyResult.getLog();
        if (!modifyResult.cancelled()) {
          log.add(LogLevel.CANCELLED,LogType.MSG_OPERATION_CANCELLED,0);
        }
        SaveKeyringResult saveResult=new SaveKeyringResult(SaveKeyringResult.RESULT_CANCELLED,log,null);
        sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,saveResult);
        return;
      }
      SaveKeyringResult saveResult=new ProviderHelper(this,modifyResult.getLog()).saveSecretKeyRing(ring,new ProgressScaler(this,60,95,100));
      if (!saveResult.success()) {
        sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,saveResult);
        return;
      }
      if (saveParcel.mNewPassphrase != null) {
        PassphraseCacheService.addCachedPassphrase(this,ring.getMasterKeyId(),saveParcel.mNewPassphrase,ring.getPublicKey().getPrimaryUserIdWithFallback());
      }
      setProgress(R.string.progress_done,100,100);
      ContactSyncAdapterService.requestSync();
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,saveResult);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_DELETE_FILE_SECURELY.equals(action)) {
    try {
      String deleteFile=data.getString(DELETE_FILE);
      try {
        PgpHelper.deleteFileSecurely(this,this,new File(deleteFile));
      }
 catch (      FileNotFoundException e) {
        throw new PgpGeneralException(getString(R.string.error_file_not_found,deleteFile));
      }
catch (      IOException e) {
        throw new PgpGeneralException(getString(R.string.error_file_delete_failed,deleteFile));
      }
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_IMPORT_KEYRING.equals(action)) {
    try {
      List<ParcelableKeyRing> entries;
      if (data.containsKey(IMPORT_KEY_LIST)) {
        entries=data.getParcelableArrayList(IMPORT_KEY_LIST);
      }
 else {
        ParcelableFileCache<ParcelableKeyRing> cache=new ParcelableFileCache<ParcelableKeyRing>(this,""String_Node_Str"");
        entries=cache.readCacheIntoList();
      }
      ProviderHelper providerHelper=new ProviderHelper(this);
      PgpImportExport pgpImportExport=new PgpImportExport(this,providerHelper,this,mActionCanceled);
      ImportKeyResult result=pgpImportExport.importKeyRings(entries);
      if (result.mSecret > 0) {
        sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_PREVENT_CANCEL);
        providerHelper.consolidateDatabaseStep1(this);
      }
      ContactSyncAdapterService.requestSync();
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,result);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_EXPORT_KEYRING.equals(action)) {
    try {
      boolean exportSecret=data.getBoolean(EXPORT_SECRET,false);
      long[] masterKeyIds=data.getLongArray(EXPORT_KEY_RING_MASTER_KEY_ID);
      String outputFile=data.getString(EXPORT_FILENAME);
      Uri outputUri=data.getParcelable(EXPORT_URI);
      boolean exportAll=data.getBoolean(EXPORT_ALL);
      if (outputFile != null) {
        if (!FileHelper.isStorageMounted(outputFile)) {
          throw new PgpGeneralException(getString(R.string.error_external_storage_not_ready));
        }
      }
      ArrayList<Long> publicMasterKeyIds=new ArrayList<Long>();
      ArrayList<Long> secretMasterKeyIds=new ArrayList<Long>();
      String selection=null;
      if (!exportAll) {
        selection=KeychainDatabase.Tables.KEYS + ""String_Node_Str"" + KeyRings.MASTER_KEY_ID+ ""String_Node_Str"";
        for (        long l : masterKeyIds) {
          selection+=Long.toString(l) + ""String_Node_Str"";
        }
        selection=selection.substring(0,selection.length() - 1) + ""String_Node_Str"";
      }
      Cursor cursor=getContentResolver().query(KeyRings.buildUnifiedKeyRingsUri(),new String[]{KeyRings.MASTER_KEY_ID,KeyRings.HAS_ANY_SECRET},selection,null,null);
      try {
        if (cursor != null && cursor.moveToFirst())         do {
          publicMasterKeyIds.add(cursor.getLong(0));
          if (exportSecret && cursor.getInt(1) != 0)           secretMasterKeyIds.add(cursor.getLong(0));
        }
 while (cursor.moveToNext());
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
      OutputStream outStream;
      if (outputFile != null) {
        outStream=new FileOutputStream(outputFile);
      }
 else {
        outStream=getContentResolver().openOutputStream(outputUri);
      }
      PgpImportExport pgpImportExport=new PgpImportExport(this,new ProviderHelper(this),this);
      Bundle resultData=pgpImportExport.exportKeyRings(publicMasterKeyIds,secretMasterKeyIds,outStream);
      if (mActionCanceled.get() && outputFile != null) {
        new File(outputFile).delete();
      }
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,resultData);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_UPLOAD_KEYRING.equals(action)) {
    try {
      String keyServer=data.getString(UPLOAD_KEY_SERVER);
      HkpKeyserver server=new HkpKeyserver(keyServer);
      ProviderHelper providerHelper=new ProviderHelper(this);
      CanonicalizedPublicKeyRing keyring=providerHelper.getCanonicalizedPublicKeyRing(dataUri);
      PgpImportExport pgpImportExport=new PgpImportExport(this,new ProviderHelper(this),this);
      try {
        pgpImportExport.uploadKeyRingToServer(server,keyring);
      }
 catch (      Keyserver.AddKeyException e) {
        throw new PgpGeneralException(""String_Node_Str"");
      }
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_DOWNLOAD_AND_IMPORT_KEYS.equals(action) || ACTION_IMPORT_KEYBASE_KEYS.equals(action)) {
    ArrayList<ImportKeysListEntry> entries=data.getParcelableArrayList(DOWNLOAD_KEY_LIST);
    String keyServer=data.getString(DOWNLOAD_KEY_SERVER);
    ArrayList<ParcelableKeyRing> keyRings=new ArrayList<ParcelableKeyRing>(entries.size());
    for (    ImportKeysListEntry entry : entries) {
      try {
        Keyserver server;
        if (entry.getOrigin() == null) {
          server=new HkpKeyserver(keyServer);
        }
 else         if (KeybaseKeyserver.ORIGIN.equals(entry.getOrigin())) {
          server=new KeybaseKeyserver();
        }
 else {
          server=new HkpKeyserver(entry.getOrigin());
        }
        byte[] downloadedKeyBytes;
        if (KeybaseKeyserver.ORIGIN.equals(entry.getOrigin())) {
          downloadedKeyBytes=server.get(entry.getExtraData()).getBytes();
        }
 else         if (entry.getFingerprintHex() != null) {
          downloadedKeyBytes=server.get(""String_Node_Str"" + entry.getFingerprintHex()).getBytes();
        }
 else {
          downloadedKeyBytes=server.get(entry.getKeyIdHex()).getBytes();
        }
        keyRings.add(new ParcelableKeyRing(downloadedKeyBytes,entry.getFingerprintHex()));
      }
 catch (      Exception e) {
        sendErrorToHandler(e);
      }
    }
    Intent importIntent=new Intent(this,KeychainIntentService.class);
    importIntent.setAction(ACTION_IMPORT_KEYRING);
    Bundle importData=new Bundle();
    importData.putParcelableArrayList(IMPORT_KEY_LIST,keyRings);
    importIntent.putExtra(EXTRA_DATA,importData);
    importIntent.putExtra(EXTRA_MESSENGER,mMessenger);
    onHandleIntent(importIntent);
  }
 else   if (ACTION_CERTIFY_KEYRING.equals(action)) {
    try {
      long masterKeyId=data.getLong(CERTIFY_KEY_MASTER_KEY_ID);
      long pubKeyId=data.getLong(CERTIFY_KEY_PUB_KEY_ID);
      ArrayList<String> userIds=data.getStringArrayList(CERTIFY_KEY_UIDS);
      String signaturePassphrase=PassphraseCacheService.getCachedPassphrase(this,masterKeyId);
      if (signaturePassphrase == null) {
        throw new PgpGeneralException(""String_Node_Str"");
      }
      ProviderHelper providerHelper=new ProviderHelper(this);
      CanonicalizedPublicKeyRing publicRing=providerHelper.getCanonicalizedPublicKeyRing(pubKeyId);
      CanonicalizedSecretKeyRing secretKeyRing=providerHelper.getCanonicalizedSecretKeyRing(masterKeyId);
      CanonicalizedSecretKey certificationKey=secretKeyRing.getSecretKey();
      if (!certificationKey.unlock(signaturePassphrase)) {
        throw new PgpGeneralException(""String_Node_Str"");
      }
      UncachedKeyRing newRing=certificationKey.certifyUserIds(publicRing,userIds,null,null);
      providerHelper.savePublicKeyRing(newRing);
      sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY);
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_DELETE.equals(action)) {
    try {
      long[] masterKeyIds=data.getLongArray(DELETE_KEY_LIST);
      boolean isSecret=data.getBoolean(DELETE_IS_SECRET);
      if (masterKeyIds.length == 0) {
        throw new PgpGeneralException(""String_Node_Str"");
      }
      if (isSecret && masterKeyIds.length > 1) {
        throw new PgpGeneralException(""String_Node_Str"");
      }
      boolean success=false;
      for (      long masterKeyId : masterKeyIds) {
        int count=getContentResolver().delete(KeyRingData.buildPublicKeyRingUri(masterKeyId),null,null);
        success|=count > 0;
      }
      if (isSecret && success) {
        new ProviderHelper(this).consolidateDatabaseStep1(this);
      }
      if (success) {
        ContactSyncAdapterService.requestSync();
        sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY);
      }
    }
 catch (    Exception e) {
      sendErrorToHandler(e);
    }
  }
 else   if (ACTION_CONSOLIDATE.equals(action)) {
    ConsolidateResult result;
    if (data.containsKey(CONSOLIDATE_RECOVERY) && data.getBoolean(CONSOLIDATE_RECOVERY)) {
      result=new ProviderHelper(this).consolidateDatabaseStep2(this);
    }
 else {
      result=new ProviderHelper(this).consolidateDatabaseStep1(this);
    }
    sendMessageToHandler(KeychainIntentServiceHandler.MESSAGE_OKAY,result);
  }
}",0.9945763107249082
8356,"@Override public boolean canChildScrollUp(){
  if (mStickyListHeadersListView == null) {
    return super.canChildScrollUp();
  }
  return (mIsLocked || (mStickyListHeadersListView.getWrappedList().getChildCount() > 0 && (mStickyListHeadersListView.getTop() > 0 || mStickyListHeadersListView.getFirstVisiblePosition() > 0)));
}","@Override public boolean canChildScrollUp(){
  if (mStickyListHeadersListView == null) {
    return super.canChildScrollUp();
  }
  return (mIsLocked || (mStickyListHeadersListView.getWrappedList().getChildCount() > 0 && (mStickyListHeadersListView.getWrappedList().getChildAt(0).getTop() < 0 || mStickyListHeadersListView.getFirstVisiblePosition() > 0)));
}",0.9518248175182482
8357,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final FragmentActivity context=getActivity();
  final LayoutInflater mInflater;
  mWillBeMasterKey=getArguments().getBoolean(ARG_WILL_BE_MASTER_KEY);
  mInflater=context.getLayoutInflater();
  CustomAlertDialogBuilder dialog=new CustomAlertDialogBuilder(context);
  View view=mInflater.inflate(R.layout.add_subkey_dialog,null);
  dialog.setView(view);
  dialog.setTitle(R.string.title_add_subkey);
  mNoExpiryCheckBox=(CheckBox)view.findViewById(R.id.add_subkey_no_expiry);
  mExpiryRow=(TableRow)view.findViewById(R.id.add_subkey_expiry_row);
  mExpiryDatePicker=(DatePicker)view.findViewById(R.id.add_subkey_expiry_date_picker);
  mAlgorithmSpinner=(Spinner)view.findViewById(R.id.add_subkey_algorithm);
  mKeySizeSpinner=(Spinner)view.findViewById(R.id.add_subkey_size);
  mCustomKeyTextView=(TextView)view.findViewById(R.id.add_subkey_custom_key_size_label);
  mCustomKeyEditText=(EditText)view.findViewById(R.id.add_subkey_custom_key_size_input);
  mCustomKeyInfoTextView=(TextView)view.findViewById(R.id.add_subkey_custom_key_size_info);
  mFlagCertify=(CheckBox)view.findViewById(R.id.add_subkey_flag_certify);
  mFlagSign=(CheckBox)view.findViewById(R.id.add_subkey_flag_sign);
  mFlagEncrypt=(CheckBox)view.findViewById(R.id.add_subkey_flag_encrypt);
  mFlagAuthenticate=(CheckBox)view.findViewById(R.id.add_subkey_flag_authenticate);
  mNoExpiryCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      if (isChecked) {
        mExpiryRow.setVisibility(View.GONE);
      }
 else {
        mExpiryRow.setVisibility(View.VISIBLE);
      }
    }
  }
);
  if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.HONEYCOMB) {
    mExpiryDatePicker.setMinDate(new Date().getTime() + DateUtils.DAY_IN_MILLIS);
  }
  ArrayList<Choice> choices=new ArrayList<Choice>();
  choices.add(new Choice(PublicKeyAlgorithmTags.DSA,getResources().getString(R.string.dsa)));
  if (!mWillBeMasterKey) {
    choices.add(new Choice(PublicKeyAlgorithmTags.ELGAMAL_ENCRYPT,getResources().getString(R.string.elgamal)));
  }
  choices.add(new Choice(PublicKeyAlgorithmTags.RSA_GENERAL,getResources().getString(R.string.rsa)));
  ArrayAdapter<Choice> adapter=new ArrayAdapter<Choice>(context,android.R.layout.simple_spinner_item,choices);
  adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  mAlgorithmSpinner.setAdapter(adapter);
  for (int i=0; i < choices.size(); ++i) {
    if (choices.get(i).getId() == PublicKeyAlgorithmTags.RSA_GENERAL) {
      mAlgorithmSpinner.setSelection(i);
      break;
    }
  }
  ArrayAdapter<CharSequence> keySizeAdapter=new ArrayAdapter<CharSequence>(context,android.R.layout.simple_spinner_item,new ArrayList<CharSequence>(Arrays.asList(getResources().getStringArray(R.array.rsa_key_size_spinner_values))));
  keySizeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  mKeySizeSpinner.setAdapter(keySizeAdapter);
  mKeySizeSpinner.setSelection(1);
  dialog.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface di,    int id){
      di.dismiss();
      Choice newKeyAlgorithmChoice=(Choice)mAlgorithmSpinner.getSelectedItem();
      int newKeySize=getProperKeyLength(newKeyAlgorithmChoice.getId(),getSelectedKeyLength());
      int flags=0;
      if (mFlagCertify.isChecked()) {
        flags|=KeyFlags.CERTIFY_OTHER;
      }
      if (mFlagSign.isChecked()) {
        flags|=KeyFlags.SIGN_DATA;
      }
      if (mFlagEncrypt.isChecked()) {
        flags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
      }
      if (mFlagAuthenticate.isChecked()) {
        flags|=KeyFlags.AUTHENTICATION;
      }
      long expiry;
      if (mNoExpiryCheckBox.isChecked()) {
        expiry=0L;
      }
 else {
        Calendar selectedCal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
        selectedCal.set(mExpiryDatePicker.getYear(),mExpiryDatePicker.getMonth(),mExpiryDatePicker.getDayOfMonth());
        expiry=selectedCal.getTime().getTime() / 1000;
      }
      SaveKeyringParcel.SubkeyAdd newSubkey=new SaveKeyringParcel.SubkeyAdd(newKeyAlgorithmChoice.getId(),newKeySize,flags,expiry);
      mAlgorithmSelectedListener.onAlgorithmSelected(newSubkey);
    }
  }
);
  dialog.setCancelable(true);
  dialog.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface di,    int id){
      di.dismiss();
    }
  }
);
  final AlertDialog alertDialog=dialog.show();
  mCustomKeyEditText.addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      setOkButtonAvailability(alertDialog);
    }
  }
);
  mKeySizeSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      setCustomKeyVisibility();
      setOkButtonAvailability(alertDialog);
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  mAlgorithmSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      updateUiForAlgorithm(((Choice)parent.getSelectedItem()).getId());
      setCustomKeyVisibility();
      setOkButtonAvailability(alertDialog);
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  return alertDialog;
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final FragmentActivity context=getActivity();
  final LayoutInflater mInflater;
  mWillBeMasterKey=getArguments().getBoolean(ARG_WILL_BE_MASTER_KEY);
  mInflater=context.getLayoutInflater();
  CustomAlertDialogBuilder dialog=new CustomAlertDialogBuilder(context);
  View view=mInflater.inflate(R.layout.add_subkey_dialog,null);
  dialog.setView(view);
  dialog.setTitle(R.string.title_add_subkey);
  mNoExpiryCheckBox=(CheckBox)view.findViewById(R.id.add_subkey_no_expiry);
  mExpiryRow=(TableRow)view.findViewById(R.id.add_subkey_expiry_row);
  mExpiryDatePicker=(DatePicker)view.findViewById(R.id.add_subkey_expiry_date_picker);
  mAlgorithmSpinner=(Spinner)view.findViewById(R.id.add_subkey_algorithm);
  mKeySizeSpinner=(Spinner)view.findViewById(R.id.add_subkey_size);
  mCustomKeyTextView=(TextView)view.findViewById(R.id.add_subkey_custom_key_size_label);
  mCustomKeyEditText=(EditText)view.findViewById(R.id.add_subkey_custom_key_size_input);
  mCustomKeyInfoTextView=(TextView)view.findViewById(R.id.add_subkey_custom_key_size_info);
  mFlagCertify=(CheckBox)view.findViewById(R.id.add_subkey_flag_certify);
  mFlagSign=(CheckBox)view.findViewById(R.id.add_subkey_flag_sign);
  mFlagEncrypt=(CheckBox)view.findViewById(R.id.add_subkey_flag_encrypt);
  mFlagAuthenticate=(CheckBox)view.findViewById(R.id.add_subkey_flag_authenticate);
  mNoExpiryCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      if (isChecked) {
        mExpiryRow.setVisibility(View.GONE);
      }
 else {
        mExpiryRow.setVisibility(View.VISIBLE);
      }
    }
  }
);
  if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.HONEYCOMB) {
    mExpiryDatePicker.setMinDate(new Date().getTime() + DateUtils.DAY_IN_MILLIS);
  }
  ArrayList<Choice> choices=new ArrayList<Choice>();
  choices.add(new Choice(PublicKeyAlgorithmTags.DSA,getResources().getString(R.string.dsa)));
  if (!mWillBeMasterKey) {
    choices.add(new Choice(PublicKeyAlgorithmTags.ELGAMAL_ENCRYPT,getResources().getString(R.string.elgamal)));
  }
  choices.add(new Choice(PublicKeyAlgorithmTags.RSA_GENERAL,getResources().getString(R.string.rsa)));
  ArrayAdapter<Choice> adapter=new ArrayAdapter<Choice>(context,android.R.layout.simple_spinner_item,choices);
  adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  mAlgorithmSpinner.setAdapter(adapter);
  for (int i=0; i < choices.size(); ++i) {
    if (choices.get(i).getId() == PublicKeyAlgorithmTags.RSA_GENERAL) {
      mAlgorithmSpinner.setSelection(i);
      break;
    }
  }
  ArrayAdapter<CharSequence> keySizeAdapter=new ArrayAdapter<CharSequence>(context,android.R.layout.simple_spinner_item,new ArrayList<CharSequence>(Arrays.asList(getResources().getStringArray(R.array.rsa_key_size_spinner_values))));
  keySizeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  mKeySizeSpinner.setAdapter(keySizeAdapter);
  mKeySizeSpinner.setSelection(1);
  dialog.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface di,    int id){
      di.dismiss();
      Choice newKeyAlgorithmChoice=(Choice)mAlgorithmSpinner.getSelectedItem();
      int newKeySize=getProperKeyLength(newKeyAlgorithmChoice.getId(),getSelectedKeyLength());
      int flags=0;
      if (mFlagCertify.isChecked()) {
        flags|=KeyFlags.CERTIFY_OTHER;
      }
      if (mFlagSign.isChecked()) {
        flags|=KeyFlags.SIGN_DATA;
      }
      if (mFlagEncrypt.isChecked()) {
        flags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
      }
      if (mFlagAuthenticate.isChecked()) {
        flags|=KeyFlags.AUTHENTICATION;
      }
      long expiry;
      if (mNoExpiryCheckBox.isChecked()) {
        expiry=0L;
      }
 else {
        Calendar selectedCal=Calendar.getInstance(TimeZone.getDefault());
        selectedCal.set(mExpiryDatePicker.getYear(),mExpiryDatePicker.getMonth(),mExpiryDatePicker.getDayOfMonth());
        selectedCal.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
        expiry=selectedCal.getTime().getTime() / 1000;
      }
      SaveKeyringParcel.SubkeyAdd newSubkey=new SaveKeyringParcel.SubkeyAdd(newKeyAlgorithmChoice.getId(),newKeySize,flags,expiry);
      mAlgorithmSelectedListener.onAlgorithmSelected(newSubkey);
    }
  }
);
  dialog.setCancelable(true);
  dialog.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface di,    int id){
      di.dismiss();
    }
  }
);
  final AlertDialog alertDialog=dialog.show();
  mCustomKeyEditText.addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      setOkButtonAvailability(alertDialog);
    }
  }
);
  mKeySizeSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      setCustomKeyVisibility();
      setOkButtonAvailability(alertDialog);
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  mAlgorithmSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
    @Override public void onItemSelected(    AdapterView<?> parent,    View view,    int position,    long id){
      updateUiForAlgorithm(((Choice)parent.getSelectedItem()).getId());
      setCustomKeyVisibility();
      setOkButtonAvailability(alertDialog);
    }
    @Override public void onNothingSelected(    AdapterView<?> parent){
    }
  }
);
  return alertDialog;
}",0.9909380768585332
8358,"/** 
 * Creates dialog
 */
@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final Activity activity=getActivity();
  mMessenger=getArguments().getParcelable(ARG_MESSENGER);
  Date creationDate=new Date(getArguments().getLong(ARG_CREATION_DATE) * 1000);
  Date expiryDate=new Date(getArguments().getLong(ARG_EXPIRY_DATE) * 1000);
  Calendar creationCal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
  creationCal.setTime(creationDate);
  mExpiryCal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
  mExpiryCal.setTime(expiryDate);
  Log.d(Constants.TAG,""String_Node_Str"");
  CustomAlertDialogBuilder alert=new CustomAlertDialogBuilder(activity);
  alert.setTitle(R.string.expiry_date_dialog_title);
  LayoutInflater inflater=activity.getLayoutInflater();
  View view=inflater.inflate(R.layout.edit_subkey_expiry_dialog,null);
  alert.setView(view);
  mDatePicker=(DatePicker)view.findViewById(R.id.edit_subkey_expiry_date_picker);
  if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.HONEYCOMB) {
    if (creationCal.before(mExpiryCal)) {
      mDatePicker.setMinDate(creationCal.getTime().getTime() + DateUtils.DAY_IN_MILLIS);
    }
 else {
      mDatePicker.setMinDate(mExpiryCal.getTime().getTime() + DateUtils.DAY_IN_MILLIS);
    }
  }
  alert.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dismiss();
      Calendar selectedCal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
      selectedCal.set(mDatePicker.getYear(),mDatePicker.getMonth(),mDatePicker.getDayOfMonth());
      if (mExpiryCal != null) {
        long numDays=(selectedCal.getTimeInMillis() / 86400000) - (mExpiryCal.getTimeInMillis() / 86400000);
        if (numDays > 0) {
          Bundle data=new Bundle();
          data.putSerializable(MESSAGE_DATA_EXPIRY_DATE,selectedCal.getTime().getTime() / 1000);
          sendMessageToHandler(MESSAGE_NEW_EXPIRY_DATE,data);
        }
      }
 else {
        Bundle data=new Bundle();
        data.putSerializable(MESSAGE_DATA_EXPIRY_DATE,selectedCal.getTime().getTime() / 1000);
        sendMessageToHandler(MESSAGE_NEW_EXPIRY_DATE,data);
      }
    }
  }
);
  alert.setNeutralButton(R.string.btn_no_date,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dismiss();
      Bundle data=new Bundle();
      data.putSerializable(MESSAGE_DATA_EXPIRY_DATE,0L);
      sendMessageToHandler(MESSAGE_NEW_EXPIRY_DATE,data);
    }
  }
);
  alert.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dismiss();
    }
  }
);
  return alert.show();
}","/** 
 * Creates dialog
 */
@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final Activity activity=getActivity();
  mMessenger=getArguments().getParcelable(ARG_MESSENGER);
  long creationDate=getArguments().getLong(ARG_CREATION_DATE);
  long expiryDate=getArguments().getLong(ARG_EXPIRY_DATE);
  Calendar creationCal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
  creationCal.setTime(new Date(creationDate * 1000));
  final Calendar expiryCal=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
  expiryCal.setTime(new Date(expiryDate * 1000));
  creationCal.setTimeZone(TimeZone.getDefault());
  expiryCal.setTimeZone(TimeZone.getDefault());
  CustomAlertDialogBuilder alert=new CustomAlertDialogBuilder(activity);
  alert.setTitle(R.string.expiry_date_dialog_title);
  LayoutInflater inflater=activity.getLayoutInflater();
  View view=inflater.inflate(R.layout.edit_subkey_expiry_dialog,null);
  alert.setView(view);
  mDatePicker=(DatePicker)view.findViewById(R.id.edit_subkey_expiry_date_picker);
  if (expiryDate == 0L) {
    Calendar creationCalPlusOne=(Calendar)creationCal.clone();
    creationCalPlusOne.add(Calendar.DAY_OF_MONTH,1);
    mDatePicker.init(creationCalPlusOne.get(Calendar.YEAR),creationCalPlusOne.get(Calendar.MONTH),creationCalPlusOne.get(Calendar.DAY_OF_MONTH),null);
  }
 else {
    Calendar expiryCalPlusOne=(Calendar)expiryCal.clone();
    expiryCalPlusOne.add(Calendar.DAY_OF_MONTH,1);
    mDatePicker.init(expiryCalPlusOne.get(Calendar.YEAR),expiryCalPlusOne.get(Calendar.MONTH),expiryCalPlusOne.get(Calendar.DAY_OF_MONTH),null);
  }
  if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.HONEYCOMB) {
    if (expiryDate == 0L || creationCal.before(expiryCal)) {
      mDatePicker.setMinDate(creationCal.getTime().getTime() + DateUtils.DAY_IN_MILLIS);
    }
 else {
      mDatePicker.setMinDate(expiryCal.getTime().getTime() + DateUtils.DAY_IN_MILLIS);
    }
  }
  alert.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dismiss();
      Calendar selectedCal=Calendar.getInstance(TimeZone.getDefault());
      selectedCal.set(mDatePicker.getYear(),mDatePicker.getMonth(),mDatePicker.getDayOfMonth());
      selectedCal.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
      long numDays=(selectedCal.getTimeInMillis() / 86400000) - (expiryCal.getTimeInMillis() / 86400000);
      if (numDays > 0) {
        Bundle data=new Bundle();
        data.putSerializable(MESSAGE_DATA_EXPIRY_DATE,selectedCal.getTime().getTime() / 1000);
        sendMessageToHandler(MESSAGE_NEW_EXPIRY_DATE,data);
      }
    }
  }
);
  alert.setNeutralButton(R.string.btn_no_date,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dismiss();
      Bundle data=new Bundle();
      data.putSerializable(MESSAGE_DATA_EXPIRY_DATE,0L);
      sendMessageToHandler(MESSAGE_NEW_EXPIRY_DATE,data);
    }
  }
);
  alert.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dismiss();
    }
  }
);
  return alert.show();
}",0.6587965240203312
8359,"private KeyRing getCanonicalizedKeyRing(Uri queryUri,boolean secret) throws NotFoundException {
  Cursor cursor=mContentResolver.query(queryUri,new String[]{KeyRings.HAS_ANY_SECRET,KeyRings.VERIFIED,secret ? KeyRings.PRIVKEY_DATA : KeyRings.PUBKEY_DATA},null,null,null);
  try {
    if (cursor != null && cursor.moveToFirst()) {
      boolean hasAnySecret=cursor.getInt(0) > 0;
      int verified=cursor.getInt(1);
      byte[] blob=cursor.getBlob(2);
      if (secret & !hasAnySecret) {
        throw new NotFoundException(""String_Node_Str"");
      }
      return secret ? new CanonicalizedSecretKeyRing(blob,true,verified) : new CanonicalizedPublicKeyRing(blob,verified);
    }
 else {
      throw new NotFoundException(""String_Node_Str"");
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","private KeyRing getCanonicalizedKeyRing(Uri queryUri,boolean secret) throws NotFoundException {
  if (!queryUri.getPath().contains(""String_Node_Str"")) {
    throw new RuntimeException(""String_Node_Str"");
  }
  Cursor cursor=mContentResolver.query(queryUri,new String[]{KeyRings.HAS_ANY_SECRET,KeyRings.VERIFIED,secret ? KeyRings.PRIVKEY_DATA : KeyRings.PUBKEY_DATA},null,null,null);
  try {
    if (cursor != null && cursor.moveToFirst()) {
      boolean hasAnySecret=cursor.getInt(0) > 0;
      int verified=cursor.getInt(1);
      byte[] blob=cursor.getBlob(2);
      if (secret & !hasAnySecret) {
        throw new NotFoundException(""String_Node_Str"");
      }
      return secret ? new CanonicalizedSecretKeyRing(blob,true,verified) : new CanonicalizedPublicKeyRing(blob,verified);
    }
 else {
      throw new NotFoundException(""String_Node_Str"");
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}",0.9362912400455062
8360,"private void uploadKey(){
  Intent intent=new Intent(this,KeychainIntentService.class);
  intent.setAction(KeychainIntentService.ACTION_UPLOAD_KEYRING);
  Uri blobUri=KeychainContract.KeyRingData.buildPublicKeyRingUri(mDataUri);
  intent.setData(blobUri);
  Bundle data=new Bundle();
  String server=(String)mKeyServerSpinner.getSelectedItem();
  data.putString(KeychainIntentService.UPLOAD_KEY_SERVER,server);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,getString(R.string.progress_exporting),ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Toast.makeText(UploadKeyActivity.this,R.string.key_send_success,Toast.LENGTH_SHORT).show();
        finish();
      }
    }
  }
;
  Messenger messenger=new Messenger(saveHandler);
  intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
  saveHandler.showProgressDialog(this);
  startService(intent);
}","private void uploadKey(){
  Intent intent=new Intent(this,KeychainIntentService.class);
  intent.setAction(KeychainIntentService.ACTION_UPLOAD_KEYRING);
  Uri blobUri=KeyRings.buildUnifiedKeyRingUri(mDataUri);
  intent.setData(blobUri);
  Bundle data=new Bundle();
  String server=(String)mKeyServerSpinner.getSelectedItem();
  data.putString(KeychainIntentService.UPLOAD_KEY_SERVER,server);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,getString(R.string.progress_exporting),ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Toast.makeText(UploadKeyActivity.this,R.string.key_send_success,Toast.LENGTH_SHORT).show();
        finish();
      }
    }
  }
;
  Messenger messenger=new Messenger(saveHandler);
  intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
  saveHandler.showProgressDialog(this);
  startService(intent);
}",0.9803383630544124
8361,"@Override protected void onCreate(Bundle savedInstanceState){
  requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  super.onCreate(savedInstanceState);
  mExportHelper=new ExportHelper(this);
  mProviderHelper=new ProviderHelper(this);
  ActionBar actionBar=getSupportActionBar();
  actionBar.setDisplayHomeAsUpEnabled(true);
  actionBar.setIcon(android.R.color.transparent);
  actionBar.setHomeButtonEnabled(true);
  setContentView(R.layout.view_key_activity);
  mStatusLayout=(LinearLayout)findViewById(R.id.view_key_status_layout);
  mStatusText=(TextView)findViewById(R.id.view_key_status_text);
  mStatusImage=(ImageView)findViewById(R.id.view_key_status_image);
  mStatusDivider=findViewById(R.id.view_key_status_divider);
  mViewPager=(ViewPager)findViewById(R.id.view_key_pager);
  mSlidingTabLayout=(SlidingTabLayout)findViewById(R.id.view_key_sliding_tab_layout);
  mSlidingTabLayout.setCustomTabColorizer(new TabColorizer(){
    @Override public int getIndicatorColor(    int position){
      return position == TAB_CERTS || position == TAB_KEYS ? 0xFFFF4444 : 0xFFAA66CC;
    }
    @Override public int getDividerColor(    int position){
      return 0;
    }
  }
);
  int switchToTab=TAB_MAIN;
  Intent intent=getIntent();
  if (intent.getExtras() != null && intent.getExtras().containsKey(EXTRA_SELECTED_TAB)) {
    switchToTab=intent.getExtras().getInt(EXTRA_SELECTED_TAB);
  }
  Uri dataUri=getDataUri();
  if (dataUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
  loadData(dataUri);
  initNfc(dataUri);
  mShowAdvancedTabs=false;
  initTabs(dataUri);
  mViewPager.setCurrentItem(switchToTab);
}","@Override protected void onCreate(Bundle savedInstanceState){
  requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  super.onCreate(savedInstanceState);
  mExportHelper=new ExportHelper(this);
  mProviderHelper=new ProviderHelper(this);
  ActionBar actionBar=getSupportActionBar();
  actionBar.setDisplayHomeAsUpEnabled(true);
  actionBar.setIcon(android.R.color.transparent);
  actionBar.setHomeButtonEnabled(true);
  setContentView(R.layout.view_key_activity);
  mStatusLayout=(LinearLayout)findViewById(R.id.view_key_status_layout);
  mStatusText=(TextView)findViewById(R.id.view_key_status_text);
  mStatusImage=(ImageView)findViewById(R.id.view_key_status_image);
  mStatusDivider=findViewById(R.id.view_key_status_divider);
  mViewPager=(ViewPager)findViewById(R.id.view_key_pager);
  mSlidingTabLayout=(SlidingTabLayout)findViewById(R.id.view_key_sliding_tab_layout);
  mSlidingTabLayout.setCustomTabColorizer(new TabColorizer(){
    @Override public int getIndicatorColor(    int position){
      return position == TAB_CERTS || position == TAB_KEYS ? 0xFFFF4444 : 0xFFAA66CC;
    }
    @Override public int getDividerColor(    int position){
      return 0;
    }
  }
);
  int switchToTab=TAB_MAIN;
  Intent intent=getIntent();
  if (intent.getExtras() != null && intent.getExtras().containsKey(EXTRA_SELECTED_TAB)) {
    switchToTab=intent.getExtras().getInt(EXTRA_SELECTED_TAB);
  }
  mDataUri=getIntent().getData();
  if (mDataUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
  if (mDataUri.getHost().equals(ContactsContract.AUTHORITY)) {
    mDataUri=ContactHelper.dataUriFromContactUri(this,mDataUri);
  }
  Log.i(Constants.TAG,""String_Node_Str"" + mDataUri.toString());
  getSupportLoaderManager().initLoader(LOADER_ID_UNIFIED,null,this);
  initNfc(mDataUri);
  mShowAdvancedTabs=false;
  initTabs(mDataUri);
  mViewPager.setCurrentItem(switchToTab);
}",0.9158982956132998
8362,"/** 
 * Executed when service is started by intent
 */
@Override public int onStartCommand(Intent intent,int flags,int startId){
  Log.d(Constants.TAG,""String_Node_Str"");
  registerReceiver();
  if (intent != null && intent.getAction() != null) {
    if (ACTION_PASSPHRASE_CACHE_ADD.equals(intent.getAction())) {
      long ttl=intent.getLongExtra(EXTRA_TTL,DEFAULT_TTL);
      long keyId=intent.getLongExtra(EXTRA_KEY_ID,-1);
      String passphrase=intent.getStringExtra(EXTRA_PASSPHRASE);
      String primaryUserID=intent.getStringExtra(EXTRA_USERID);
      Log.d(Constants.TAG,""String_Node_Str"" + keyId + ""String_Node_Str""+ ttl+ ""String_Node_Str""+ primaryUserID);
      mPassphraseCache.put(keyId,new CachedPassphrase(passphrase,primaryUserID));
      if (ttl > 0) {
        long triggerTime=new Date().getTime() + (ttl * 1000);
        AlarmManager am=(AlarmManager)this.getSystemService(Context.ALARM_SERVICE);
        am.set(AlarmManager.RTC_WAKEUP,triggerTime,buildIntent(this,keyId));
      }
      updateNotifications();
    }
 else     if (ACTION_PASSPHRASE_CACHE_GET.equals(intent.getAction())) {
      long keyId=intent.getLongExtra(EXTRA_KEY_ID,-1);
      Messenger messenger=intent.getParcelableExtra(EXTRA_MESSENGER);
      String passphrase=getCachedPassphraseImpl(keyId);
      Message msg=Message.obtain();
      Bundle bundle=new Bundle();
      bundle.putString(EXTRA_PASSPHRASE,passphrase);
      msg.obj=bundle;
      try {
        messenger.send(msg);
      }
 catch (      RemoteException e) {
        Log.e(Constants.TAG,""String_Node_Str"",e);
      }
    }
 else     if (ACTION_PASSPHRASE_CACHE_PURGE.equals(intent.getAction())) {
      AlarmManager am=(AlarmManager)this.getSystemService(Context.ALARM_SERVICE);
      for (int i=0; i < mPassphraseCache.size(); i++) {
        am.cancel(buildIntent(this,mPassphraseCache.keyAt(i)));
      }
      mPassphraseCache.clear();
      updateNotifications();
    }
 else {
      Log.e(Constants.TAG,""String_Node_Str"");
    }
  }
  return START_STICKY;
}","/** 
 * Executed when service is started by intent
 */
@Override public int onStartCommand(Intent intent,int flags,int startId){
  Log.d(Constants.TAG,""String_Node_Str"");
  registerReceiver();
  if (intent != null && intent.getAction() != null) {
    if (ACTION_PASSPHRASE_CACHE_ADD.equals(intent.getAction())) {
      long ttl=intent.getLongExtra(EXTRA_TTL,DEFAULT_TTL);
      long keyId=intent.getLongExtra(EXTRA_KEY_ID,-1);
      String passphrase=intent.getStringExtra(EXTRA_PASSPHRASE);
      String primaryUserID=intent.getStringExtra(EXTRA_USERID);
      Log.d(Constants.TAG,""String_Node_Str"" + keyId + ""String_Node_Str""+ ttl+ ""String_Node_Str""+ primaryUserID);
      mPassphraseCache.put(keyId,new CachedPassphrase(passphrase,primaryUserID));
      if (ttl > 0) {
        long triggerTime=new Date().getTime() + (ttl * 1000);
        AlarmManager am=(AlarmManager)this.getSystemService(Context.ALARM_SERVICE);
        am.set(AlarmManager.RTC_WAKEUP,triggerTime,buildIntent(this,keyId));
      }
      updateNotifications();
    }
 else     if (ACTION_PASSPHRASE_CACHE_GET.equals(intent.getAction())) {
      long keyId=intent.getLongExtra(EXTRA_KEY_ID,-1);
      Messenger messenger=intent.getParcelableExtra(EXTRA_MESSENGER);
      String passphrase=getCachedPassphraseImpl(keyId);
      Message msg=Message.obtain();
      Bundle bundle=new Bundle();
      bundle.putString(EXTRA_PASSPHRASE,passphrase);
      msg.obj=bundle;
      try {
        messenger.send(msg);
      }
 catch (      RemoteException e) {
        Log.e(Constants.TAG,""String_Node_Str"",e);
      }
    }
 else     if (ACTION_PASSPHRASE_CACHE_CLEAR.equals(intent.getAction())) {
      AlarmManager am=(AlarmManager)this.getSystemService(Context.ALARM_SERVICE);
      for (int i=0; i < mPassphraseCache.size(); i++) {
        am.cancel(buildIntent(this,mPassphraseCache.keyAt(i)));
      }
      mPassphraseCache.clear();
      updateNotifications();
    }
 else {
      Log.e(Constants.TAG,""String_Node_Str"");
    }
  }
  return START_STICKY;
}",0.9975284231339596
8363,"private void updateNotifications(){
  NotificationManager notificationManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
  if (mPassphraseCache.size() > 0) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
      NotificationCompat.Builder builder=new NotificationCompat.Builder(this);
      builder.setSmallIcon(R.drawable.ic_launcher).setContentTitle(getString(R.string.app_name)).setContentText(String.format(getString(R.string.passp_cache_notif_n_keys,mPassphraseCache.size())));
      NotificationCompat.InboxStyle inboxStyle=new NotificationCompat.InboxStyle();
      inboxStyle.setBigContentTitle(getString(R.string.passp_cache_notif_keys));
      for (int i=0; i < mPassphraseCache.size(); i++) {
        inboxStyle.addLine(mPassphraseCache.valueAt(i).getPrimaryUserID());
      }
      builder.setStyle(inboxStyle);
      Intent intent=new Intent(getApplicationContext(),PassphraseCacheService.class);
      intent.setAction(ACTION_PASSPHRASE_CACHE_PURGE);
      builder.addAction(R.drawable.abc_ic_clear_normal,getString(R.string.passp_cache_notif_purge),PendingIntent.getService(getApplicationContext(),0,intent,PendingIntent.FLAG_UPDATE_CURRENT));
      notificationManager.notify(NOTIFICATION_ID,builder.build());
    }
 else {
      NotificationCompat.Builder builder=new NotificationCompat.Builder(this);
      builder.setSmallIcon(R.drawable.ic_launcher).setContentTitle(String.format(getString(R.string.passp_cache_notif_n_keys,mPassphraseCache.size()))).setContentText(getString(R.string.passp_cache_notif_click_to_purge));
      Intent intent=new Intent(getApplicationContext(),PassphraseCacheService.class);
      intent.setAction(ACTION_PASSPHRASE_CACHE_PURGE);
      builder.setContentIntent(PendingIntent.getService(getApplicationContext(),0,intent,PendingIntent.FLAG_UPDATE_CURRENT));
      notificationManager.notify(NOTIFICATION_ID,builder.build());
    }
  }
 else {
    notificationManager.cancel(NOTIFICATION_ID);
  }
}","private void updateNotifications(){
  NotificationManager notificationManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
  if (mPassphraseCache.size() > 0) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
      NotificationCompat.Builder builder=new NotificationCompat.Builder(this);
      builder.setSmallIcon(R.drawable.ic_launcher).setContentTitle(getString(R.string.app_name)).setContentText(String.format(getString(R.string.passp_cache_notif_n_keys,mPassphraseCache.size())));
      NotificationCompat.InboxStyle inboxStyle=new NotificationCompat.InboxStyle();
      inboxStyle.setBigContentTitle(getString(R.string.passp_cache_notif_keys));
      for (int i=0; i < mPassphraseCache.size(); i++) {
        inboxStyle.addLine(mPassphraseCache.valueAt(i).getPrimaryUserID());
      }
      builder.setStyle(inboxStyle);
      Intent intent=new Intent(getApplicationContext(),PassphraseCacheService.class);
      intent.setAction(ACTION_PASSPHRASE_CACHE_CLEAR);
      builder.addAction(R.drawable.abc_ic_clear_normal,getString(R.string.passp_cache_notif_clear),PendingIntent.getService(getApplicationContext(),0,intent,PendingIntent.FLAG_UPDATE_CURRENT));
      notificationManager.notify(NOTIFICATION_ID,builder.build());
    }
 else {
      NotificationCompat.Builder builder=new NotificationCompat.Builder(this);
      builder.setSmallIcon(R.drawable.ic_launcher).setContentTitle(String.format(getString(R.string.passp_cache_notif_n_keys,mPassphraseCache.size()))).setContentText(getString(R.string.passp_cache_notif_click_to_clear));
      Intent intent=new Intent(getApplicationContext(),PassphraseCacheService.class);
      intent.setAction(ACTION_PASSPHRASE_CACHE_CLEAR);
      builder.setContentIntent(PendingIntent.getService(getApplicationContext(),0,intent,PendingIntent.FLAG_UPDATE_CURRENT));
      notificationManager.notify(NOTIFICATION_ID,builder.build());
    }
  }
 else {
    notificationManager.cancel(NOTIFICATION_ID);
  }
}",0.9909638554216867
8364,"/** 
 * Internal implementation to get cached passphrase.
 * @param keyId
 * @return
 */
private String getCachedPassphraseImpl(long keyId){
  if (keyId == Constants.key.symmetric) {
    Log.d(Constants.TAG,""String_Node_Str"");
    String cachedPassphrase=mPassphraseCache.get(Constants.key.symmetric).getPassphrase();
    if (cachedPassphrase == null) {
      return null;
    }
    addCachedPassphrase(this,Constants.key.symmetric,cachedPassphrase,""String_Node_Str"");
    return cachedPassphrase;
  }
  try {
    Log.d(Constants.TAG,""String_Node_Str"" + keyId);
    WrappedSecretKeyRing key=new ProviderHelper(this).getWrappedSecretKeyRing(KeychainContract.KeyRings.buildUnifiedKeyRingsFindBySubkeyUri(keyId));
    if (!key.hasPassphrase()) {
      Log.d(Constants.TAG,""String_Node_Str"");
      try {
        addCachedPassphrase(this,keyId,""String_Node_Str"",key.getPrimaryUserId());
      }
 catch (      PgpGeneralException e) {
        Log.d(Constants.TAG,""String_Node_Str"");
      }
      return ""String_Node_Str"";
    }
    CachedPassphrase cachedPassphrase=mPassphraseCache.get(keyId);
    if (cachedPassphrase == null) {
      Log.d(Constants.TAG,""String_Node_Str"");
      return null;
    }
    Log.d(Constants.TAG,""String_Node_Str"");
    addCachedPassphrase(this,keyId,cachedPassphrase.getPassphrase(),cachedPassphrase.getPrimaryUserID());
    return cachedPassphrase.getPassphrase();
  }
 catch (  ProviderHelper.NotFoundException e) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return null;
  }
}","/** 
 * Internal implementation to get cached passphrase.
 * @param keyId
 * @return
 */
private String getCachedPassphraseImpl(long keyId){
  if (keyId == Constants.key.symmetric) {
    Log.d(Constants.TAG,""String_Node_Str"");
    String cachedPassphrase=mPassphraseCache.get(Constants.key.symmetric).getPassphrase();
    if (cachedPassphrase == null) {
      return null;
    }
    addCachedPassphrase(this,Constants.key.symmetric,cachedPassphrase,getString(R.string.passp_cache_notif_pwd));
    return cachedPassphrase;
  }
  try {
    Log.d(Constants.TAG,""String_Node_Str"" + keyId);
    WrappedSecretKeyRing key=new ProviderHelper(this).getWrappedSecretKeyRing(KeychainContract.KeyRings.buildUnifiedKeyRingsFindBySubkeyUri(keyId));
    if (!key.hasPassphrase()) {
      Log.d(Constants.TAG,""String_Node_Str"");
      try {
        addCachedPassphrase(this,keyId,""String_Node_Str"",key.getPrimaryUserId());
      }
 catch (      PgpGeneralException e) {
        Log.d(Constants.TAG,""String_Node_Str"");
      }
      return ""String_Node_Str"";
    }
    CachedPassphrase cachedPassphrase=mPassphraseCache.get(keyId);
    if (cachedPassphrase == null) {
      Log.d(Constants.TAG,""String_Node_Str"");
      return null;
    }
    Log.d(Constants.TAG,""String_Node_Str"");
    addCachedPassphrase(this,keyId,cachedPassphrase.getPassphrase(),cachedPassphrase.getPrimaryUserID());
    return cachedPassphrase.getPassphrase();
  }
 catch (  ProviderHelper.NotFoundException e) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return null;
  }
}",0.9809586342744584
8365,"/** 
 * Creates dialog
 */
@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final Activity activity=getActivity();
  final long secretKeyId=getArguments().getLong(ARG_SECRET_KEY_ID);
  mMessenger=getArguments().getParcelable(ARG_MESSENGER);
  CustomAlertDialogBuilder alert=new CustomAlertDialogBuilder(activity);
  alert.setTitle(R.string.title_authentication);
  final WrappedSecretKeyRing secretRing;
  String userId;
  if (secretKeyId == Constants.key.symmetric || secretKeyId == Constants.key.none) {
    alert.setMessage(R.string.passphrase_for_symmetric_encryption);
    secretRing=null;
  }
 else {
    try {
      ProviderHelper helper=new ProviderHelper(activity);
      secretRing=helper.getWrappedSecretKeyRing(secretKeyId);
      try {
        userId=secretRing.getPrimaryUserId();
      }
 catch (      PgpGeneralException e) {
        userId=null;
      }
    }
 catch (    ProviderHelper.NotFoundException e) {
      alert.setTitle(R.string.title_key_not_found);
      alert.setMessage(getString(R.string.key_not_found,secretKeyId));
      alert.setPositiveButton(android.R.string.ok,new OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          dismiss();
        }
      }
);
      alert.setCancelable(false);
      mCanKB=false;
      return alert.create();
    }
    Log.d(Constants.TAG,""String_Node_Str"" + userId + ""String_Node_Str"");
    alert.setMessage(getString(R.string.passphrase_for,userId));
  }
  LayoutInflater inflater=activity.getLayoutInflater();
  View view=inflater.inflate(R.layout.passphrase_dialog,null);
  alert.setView(view);
  mPassphraseEditText=(EditText)view.findViewById(R.id.passphrase_passphrase);
  alert.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dismiss();
      String passphrase=mPassphraseEditText.getText().toString();
      if (secretRing == null) {
        PassphraseCacheService.addCachedPassphrase(activity,Constants.key.symmetric,passphrase,""String_Node_Str"");
        Bundle data=new Bundle();
        data.putString(MESSAGE_DATA_PASSPHRASE,passphrase);
        sendMessageToHandler(MESSAGE_OKAY,data);
        return;
      }
      WrappedSecretKey unlockedSecretKey=null;
      for (      WrappedSecretKey clickSecretKey : secretRing.secretKeyIterator()) {
        try {
          boolean unlocked=clickSecretKey.unlock(passphrase);
          if (unlocked) {
            unlockedSecretKey=clickSecretKey;
            break;
          }
        }
 catch (        PgpGeneralException e) {
          Toast.makeText(activity,R.string.error_could_not_extract_private_key,Toast.LENGTH_SHORT).show();
          sendMessageToHandler(MESSAGE_CANCEL);
          return;
        }
      }
      if (unlockedSecretKey == null) {
        Toast.makeText(activity,R.string.wrong_passphrase,Toast.LENGTH_SHORT).show();
        sendMessageToHandler(MESSAGE_CANCEL);
        return;
      }
      long masterKeyId=secretRing.getMasterKeyId();
      Log.d(Constants.TAG,""String_Node_Str"");
      try {
        PassphraseCacheService.addCachedPassphrase(activity,masterKeyId,passphrase,secretRing.getPrimaryUserId());
      }
 catch (      PgpGeneralException e) {
        Log.e(Constants.TAG,e.getMessage());
      }
      if (unlockedSecretKey.getKeyId() != masterKeyId) {
        PassphraseCacheService.addCachedPassphrase(activity,unlockedSecretKey.getKeyId(),passphrase,unlockedSecretKey.getPrimaryUserId());
      }
      Bundle data=new Bundle();
      data.putString(MESSAGE_DATA_PASSPHRASE,passphrase);
      sendMessageToHandler(MESSAGE_OKAY,data);
    }
  }
);
  alert.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  mCanKB=true;
  return alert.show();
}","/** 
 * Creates dialog
 */
@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final Activity activity=getActivity();
  final long secretKeyId=getArguments().getLong(ARG_SECRET_KEY_ID);
  mMessenger=getArguments().getParcelable(ARG_MESSENGER);
  CustomAlertDialogBuilder alert=new CustomAlertDialogBuilder(activity);
  alert.setTitle(R.string.title_authentication);
  final WrappedSecretKeyRing secretRing;
  String userId;
  if (secretKeyId == Constants.key.symmetric || secretKeyId == Constants.key.none) {
    alert.setMessage(R.string.passphrase_for_symmetric_encryption);
    secretRing=null;
  }
 else {
    try {
      ProviderHelper helper=new ProviderHelper(activity);
      secretRing=helper.getWrappedSecretKeyRing(secretKeyId);
      try {
        userId=secretRing.getPrimaryUserId();
      }
 catch (      PgpGeneralException e) {
        userId=null;
      }
    }
 catch (    ProviderHelper.NotFoundException e) {
      alert.setTitle(R.string.title_key_not_found);
      alert.setMessage(getString(R.string.key_not_found,secretKeyId));
      alert.setPositiveButton(android.R.string.ok,new OnClickListener(){
        public void onClick(        DialogInterface dialog,        int which){
          dismiss();
        }
      }
);
      alert.setCancelable(false);
      mCanKB=false;
      return alert.create();
    }
    Log.d(Constants.TAG,""String_Node_Str"" + userId + ""String_Node_Str"");
    alert.setMessage(getString(R.string.passphrase_for,userId));
  }
  LayoutInflater inflater=activity.getLayoutInflater();
  View view=inflater.inflate(R.layout.passphrase_dialog,null);
  alert.setView(view);
  mPassphraseEditText=(EditText)view.findViewById(R.id.passphrase_passphrase);
  alert.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dismiss();
      String passphrase=mPassphraseEditText.getText().toString();
      if (secretRing == null) {
        PassphraseCacheService.addCachedPassphrase(activity,Constants.key.symmetric,passphrase,getString(R.string.passp_cache_notif_pwd));
        Bundle data=new Bundle();
        data.putString(MESSAGE_DATA_PASSPHRASE,passphrase);
        sendMessageToHandler(MESSAGE_OKAY,data);
        return;
      }
      WrappedSecretKey unlockedSecretKey=null;
      for (      WrappedSecretKey clickSecretKey : secretRing.secretKeyIterator()) {
        try {
          boolean unlocked=clickSecretKey.unlock(passphrase);
          if (unlocked) {
            unlockedSecretKey=clickSecretKey;
            break;
          }
        }
 catch (        PgpGeneralException e) {
          Toast.makeText(activity,R.string.error_could_not_extract_private_key,Toast.LENGTH_SHORT).show();
          sendMessageToHandler(MESSAGE_CANCEL);
          return;
        }
      }
      if (unlockedSecretKey == null) {
        Toast.makeText(activity,R.string.wrong_passphrase,Toast.LENGTH_SHORT).show();
        sendMessageToHandler(MESSAGE_CANCEL);
        return;
      }
      long masterKeyId=secretRing.getMasterKeyId();
      Log.d(Constants.TAG,""String_Node_Str"");
      try {
        PassphraseCacheService.addCachedPassphrase(activity,masterKeyId,passphrase,secretRing.getPrimaryUserId());
      }
 catch (      PgpGeneralException e) {
        Log.e(Constants.TAG,""String_Node_Str"",e);
      }
      if (unlockedSecretKey.getKeyId() != masterKeyId) {
        PassphraseCacheService.addCachedPassphrase(activity,unlockedSecretKey.getKeyId(),passphrase,unlockedSecretKey.getPrimaryUserId());
      }
      Bundle data=new Bundle();
      data.putString(MESSAGE_DATA_PASSPHRASE,passphrase);
      sendMessageToHandler(MESSAGE_OKAY,data);
    }
  }
);
  alert.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int id){
      dialog.cancel();
    }
  }
);
  mCanKB=true;
  return alert.show();
}",0.9884853852967228
8366,"/** 
 * ""Canonicalizes"" a public key, removing inconsistencies in the process. This variant can be applied to public keyrings only. More specifically: - Remove all non-verifying self-certificates - Remove all ""future"" self-certificates - Remove all certificates flagged as ""local"" - Remove all certificates which are superseded by a newer one on the same target, including revocations with later re-certifications. - Remove all certificates of unknown type: - key revocation signatures on the master key - subkey binding signatures for subkeys - certifications and certification revocations for user ids - If a subkey retains no valid subkey binding certificate, remove it - If a user id retains no valid self certificate, remove it - If the key is a secret key, remove all certificates by foreign keys - If no valid user id remains, log an error and return null This operation writes an OperationLog which can be used as part of a OperationResultParcel.
 * @return A canonicalized key, or null on fatal error
 */
@SuppressWarnings(""String_Node_Str"") public UncachedKeyRing canonicalize(OperationLog log,int indent){
  log.add(LogLevel.START,isSecret() ? LogType.MSG_KC_SECRET : LogType.MSG_KC_PUBLIC,indent,PgpKeyHelper.convertKeyIdToHex(getMasterKeyId()));
  indent+=1;
  final Date now=new Date();
  int redundantCerts=0, badCerts=0;
  PGPKeyRing ring=mRing;
  PGPPublicKey masterKey=mRing.getPublicKey();
  final long masterKeyId=masterKey.getKeyID();
{
    log.add(LogLevel.DEBUG,LogType.MSG_KC_MASTER,indent,PgpKeyHelper.convertKeyIdToHex(masterKey.getKeyID()));
    indent+=1;
    PGPPublicKey modified=masterKey;
    PGPSignature revocation=null;
    for (    PGPSignature zert : new IterableIterator<PGPSignature>(masterKey.getSignatures())) {
      int type=zert.getSignatureType();
      if (type == PGPSignature.NO_CERTIFICATION || type == PGPSignature.DEFAULT_CERTIFICATION || type == PGPSignature.CASUAL_CERTIFICATION || type == PGPSignature.POSITIVE_CERTIFICATION || type == PGPSignature.CERTIFICATION_REVOCATION) {
        continue;
      }
      WrappedSignature cert=new WrappedSignature(zert);
      if (type != PGPSignature.KEY_REVOCATION) {
        log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(type,16));
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (cert.getCreationTime().after(now)) {
        log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_TIME,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (cert.isLocal()) {
        log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_LOCAL,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      try {
        cert.init(masterKey);
        if (!cert.verifySignature(masterKey)) {
          log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD,indent);
          modified=PGPPublicKey.removeCertification(modified,zert);
          badCerts+=1;
          continue;
        }
      }
 catch (      PgpGeneralException e) {
        log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_ERR,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (revocation == null) {
        revocation=zert;
      }
 else       if (revocation.getCreationTime().before(zert.getCreationTime())) {
        modified=PGPPublicKey.removeCertification(modified,revocation);
        redundantCerts+=1;
        log.add(LogLevel.INFO,LogType.MSG_KC_REVOKE_DUP,indent);
        revocation=zert;
      }
 else {
        modified=PGPPublicKey.removeCertification(modified,zert);
        redundantCerts+=1;
        log.add(LogLevel.INFO,LogType.MSG_KC_REVOKE_DUP,indent);
      }
    }
    for (    String userId : new IterableIterator<String>(masterKey.getUserIDs())) {
      PGPSignature selfCert=null;
      revocation=null;
      for (      PGPSignature zert : new IterableIterator<PGPSignature>(masterKey.getSignaturesForID(userId))) {
        WrappedSignature cert=new WrappedSignature(zert);
        long certId=cert.getKeyId();
        int type=zert.getSignatureType();
        if (type != PGPSignature.DEFAULT_CERTIFICATION && type != PGPSignature.NO_CERTIFICATION && type != PGPSignature.CASUAL_CERTIFICATION && type != PGPSignature.POSITIVE_CERTIFICATION && type != PGPSignature.CERTIFICATION_REVOCATION) {
          log.add(LogLevel.WARN,LogType.MSG_KC_UID_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(zert.getSignatureType(),16));
          modified=PGPPublicKey.removeCertification(modified,userId,zert);
          badCerts+=1;
        }
        if (cert.getCreationTime().after(now)) {
          log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_TIME,indent);
          modified=PGPPublicKey.removeCertification(modified,zert);
          badCerts+=1;
          continue;
        }
        if (cert.isLocal()) {
          log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_LOCAL,indent);
          modified=PGPPublicKey.removeCertification(modified,zert);
          badCerts+=1;
          continue;
        }
        if (certId != masterKeyId) {
          if (isSecret()) {
            log.add(LogLevel.WARN,LogType.MSG_KC_UID_FOREIGN,indent,PgpKeyHelper.convertKeyIdToHex(certId));
            modified=PGPPublicKey.removeCertification(modified,userId,zert);
            badCerts+=1;
          }
          continue;
        }
        try {
          cert.init(masterKey);
          if (!cert.verifySignature(masterKey,userId)) {
            log.add(LogLevel.WARN,LogType.MSG_KC_UID_BAD,indent,userId);
            modified=PGPPublicKey.removeCertification(modified,userId,zert);
            badCerts+=1;
            continue;
          }
        }
 catch (        PgpGeneralException e) {
          log.add(LogLevel.WARN,LogType.MSG_KC_UID_BAD_ERR,indent,userId);
          modified=PGPPublicKey.removeCertification(modified,userId,zert);
          badCerts+=1;
          continue;
        }
switch (type) {
case PGPSignature.DEFAULT_CERTIFICATION:
case PGPSignature.NO_CERTIFICATION:
case PGPSignature.CASUAL_CERTIFICATION:
case PGPSignature.POSITIVE_CERTIFICATION:
          if (selfCert == null) {
            selfCert=zert;
          }
 else           if (selfCert.getCreationTime().before(cert.getCreationTime())) {
            modified=PGPPublicKey.removeCertification(modified,userId,selfCert);
            redundantCerts+=1;
            log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_DUP,indent,userId);
            selfCert=zert;
          }
 else {
            modified=PGPPublicKey.removeCertification(modified,userId,zert);
            redundantCerts+=1;
            log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_DUP,indent,userId);
          }
        if (revocation != null && revocation.getCreationTime().before(selfCert.getCreationTime())) {
          modified=PGPPublicKey.removeCertification(modified,userId,revocation);
          revocation=null;
          redundantCerts+=1;
          log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_REVOKE_OLD,indent,userId);
        }
      break;
case PGPSignature.CERTIFICATION_REVOCATION:
    if (selfCert != null && selfCert.getCreationTime().after(zert.getCreationTime())) {
      modified=PGPPublicKey.removeCertification(modified,userId,zert);
      redundantCerts+=1;
      log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_REVOKE_OLD,indent,userId);
      continue;
    }
  if (revocation == null) {
    revocation=zert;
  }
 else   if (revocation.getCreationTime().before(cert.getCreationTime())) {
    modified=PGPPublicKey.removeCertification(modified,userId,revocation);
    redundantCerts+=1;
    log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_REVOKE_DUP,indent,userId);
    revocation=zert;
  }
 else {
    modified=PGPPublicKey.removeCertification(modified,userId,zert);
    redundantCerts+=1;
    log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_REVOKE_DUP,indent,userId);
  }
break;
}
}
if (selfCert == null && revocation == null) {
modified=PGPPublicKey.removeCertification(modified,userId);
log.add(LogLevel.ERROR,LogType.MSG_KC_UID_REVOKE_DUP,indent,userId);
}
}
if (!modified.getUserIDs().hasNext()) {
log.add(LogLevel.ERROR,LogType.MSG_KC_FATAL_NO_UID,indent);
return null;
}
ring=replacePublicKey(ring,modified);
indent-=1;
}
for (PGPPublicKey key : new IterableIterator<PGPPublicKey>(ring.getPublicKeys())) {
if (key.isMasterKey()) {
continue;
}
log.add(LogLevel.DEBUG,LogType.MSG_KC_SUB,indent,PgpKeyHelper.convertKeyIdToHex(key.getKeyID()));
indent+=1;
PGPPublicKey modified=key;
PGPSignature selfCert=null, revocation=null;
uids: for (PGPSignature zert : new IterableIterator<PGPSignature>(key.getSignatures())) {
modified=PGPPublicKey.removeCertification(modified,zert);
WrappedSignature cert=new WrappedSignature(zert);
int type=cert.getSignatureType();
if (cert.getKeyId() != masterKey.getKeyID()) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD_KEYID,indent);
badCerts+=1;
continue;
}
if (type != PGPSignature.SUBKEY_BINDING && type != PGPSignature.SUBKEY_REVOCATION) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(type,16));
badCerts+=1;
continue;
}
if (cert.getCreationTime().after(now)) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD_TIME,indent);
badCerts+=1;
continue;
}
if (cert.isLocal()) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD_LOCAL,indent);
badCerts+=1;
continue;
}
if (type == PGPSignature.SUBKEY_BINDING) {
try {
cert.init(masterKey);
if (!cert.verifySignature(masterKey,key)) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD,indent);
badCerts+=1;
continue;
}
}
 catch (PgpGeneralException e) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD_ERR,indent);
badCerts+=1;
continue;
}
if (zert.getHashedSubPackets().hasSubpacket(SignatureSubpacketTags.KEY_FLAGS)) {
int flags=((KeyFlags)zert.getHashedSubPackets().getSubpacket(SignatureSubpacketTags.KEY_FLAGS)).getFlags();
if ((flags & PGPKeyFlags.CAN_SIGN) == PGPKeyFlags.CAN_SIGN) {
try {
  PGPSignatureList list=zert.getUnhashedSubPackets().getEmbeddedSignatures();
  boolean ok=false;
  for (int i=0; i < list.size(); i++) {
    WrappedSignature subsig=new WrappedSignature(list.get(i));
    if (subsig.getSignatureType() == PGPSignature.PRIMARYKEY_BINDING) {
      subsig.init(key);
      if (subsig.verifySignature(masterKey,key)) {
        ok=true;
      }
 else {
        log.add(LogLevel.WARN,LogType.MSG_KC_SUB_PRIMARY_BAD,indent);
        badCerts+=1;
        continue uids;
      }
    }
  }
  if (!ok) {
    log.add(LogLevel.WARN,LogType.MSG_KC_SUB_PRIMARY_NONE,indent);
    badCerts+=1;
    continue;
  }
}
 catch (Exception e) {
  log.add(LogLevel.WARN,LogType.MSG_KC_SUB_PRIMARY_BAD_ERR,indent);
  badCerts+=1;
  continue;
}
}
}
if (selfCert != null && selfCert.getCreationTime().before(cert.getCreationTime())) {
log.add(LogLevel.DEBUG,LogType.MSG_KC_SUB_DUP,indent);
redundantCerts+=1;
continue;
}
selfCert=zert;
if (revocation != null && selfCert.getCreationTime().after(revocation.getCreationTime())) {
revocation=null;
}
}
 else {
try {
cert.init(masterKey);
if (!cert.verifySignature(key)) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_REVOKE_BAD,indent);
badCerts+=1;
continue;
}
}
 catch (PgpGeneralException e) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_REVOKE_BAD_ERR,indent);
badCerts+=1;
continue;
}
if (selfCert != null && selfCert.getCreationTime().after(cert.getCreationTime())) {
log.add(LogLevel.DEBUG,LogType.MSG_KC_SUB_REVOKE_DUP,indent);
redundantCerts+=1;
continue;
}
revocation=zert;
}
}
if (selfCert == null) {
ring=replacePublicKey(ring,modified);
log.add(LogLevel.ERROR,LogType.MSG_KC_SUB_NO_CERT,indent,PgpKeyHelper.convertKeyIdToHex(key.getKeyID()));
indent-=1;
continue;
}
modified=PGPPublicKey.addCertification(modified,selfCert);
if (revocation != null) {
modified=PGPPublicKey.addCertification(modified,revocation);
}
ring=replacePublicKey(ring,modified);
indent-=1;
}
if (badCerts > 0 && redundantCerts > 0) {
log.add(LogLevel.OK,LogType.MSG_KC_SUCCESS_BAD_AND_RED,indent,Integer.toString(badCerts),Integer.toString(redundantCerts));
}
 else if (badCerts > 0) {
log.add(LogLevel.OK,LogType.MSG_KC_SUCCESS_BAD,indent,badCerts);
}
 else if (redundantCerts > 0) {
log.add(LogLevel.OK,LogType.MSG_KC_SUCCESS_REDUNDANT,indent,redundantCerts);
}
 else {
log.add(LogLevel.OK,LogType.MSG_KC_SUCCESS,indent);
}
return new UncachedKeyRing(ring,true);
}","/** 
 * ""Canonicalizes"" a public key, removing inconsistencies in the process. This variant can be applied to public keyrings only. More specifically: - Remove all non-verifying self-certificates - Remove all ""future"" self-certificates - Remove all certificates flagged as ""local"" - Remove all certificates which are superseded by a newer one on the same target, including revocations with later re-certifications. - Remove all certificates of unknown type: - key revocation signatures on the master key - subkey binding signatures for subkeys - certifications and certification revocations for user ids - If a subkey retains no valid subkey binding certificate, remove it - If a user id retains no valid self certificate, remove it - If the key is a secret key, remove all certificates by foreign keys - If no valid user id remains, log an error and return null This operation writes an OperationLog which can be used as part of a OperationResultParcel.
 * @return A canonicalized key, or null on fatal error
 */
@SuppressWarnings(""String_Node_Str"") public UncachedKeyRing canonicalize(OperationLog log,int indent){
  log.add(LogLevel.START,isSecret() ? LogType.MSG_KC_SECRET : LogType.MSG_KC_PUBLIC,indent,PgpKeyHelper.convertKeyIdToHex(getMasterKeyId()));
  indent+=1;
  final Date now=new Date();
  int redundantCerts=0, badCerts=0;
  PGPKeyRing ring=mRing;
  PGPPublicKey masterKey=mRing.getPublicKey();
  final long masterKeyId=masterKey.getKeyID();
{
    log.add(LogLevel.DEBUG,LogType.MSG_KC_MASTER,indent,PgpKeyHelper.convertKeyIdToHex(masterKey.getKeyID()));
    indent+=1;
    PGPPublicKey modified=masterKey;
    PGPSignature revocation=null;
    for (    PGPSignature zert : new IterableIterator<PGPSignature>(masterKey.getSignatures())) {
      int type=zert.getSignatureType();
      if (type == PGPSignature.NO_CERTIFICATION || type == PGPSignature.DEFAULT_CERTIFICATION || type == PGPSignature.CASUAL_CERTIFICATION || type == PGPSignature.POSITIVE_CERTIFICATION || type == PGPSignature.CERTIFICATION_REVOCATION) {
        continue;
      }
      WrappedSignature cert=new WrappedSignature(zert);
      if (type != PGPSignature.KEY_REVOCATION) {
        log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(type,16));
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (cert.getCreationTime().after(now)) {
        log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_TIME,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (cert.isLocal()) {
        log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_LOCAL,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      try {
        cert.init(masterKey);
        if (!cert.verifySignature(masterKey)) {
          log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD,indent);
          modified=PGPPublicKey.removeCertification(modified,zert);
          badCerts+=1;
          continue;
        }
      }
 catch (      PgpGeneralException e) {
        log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_ERR,indent);
        modified=PGPPublicKey.removeCertification(modified,zert);
        badCerts+=1;
        continue;
      }
      if (revocation == null) {
        revocation=zert;
      }
 else       if (revocation.getCreationTime().before(zert.getCreationTime())) {
        modified=PGPPublicKey.removeCertification(modified,revocation);
        redundantCerts+=1;
        log.add(LogLevel.INFO,LogType.MSG_KC_REVOKE_DUP,indent);
        revocation=zert;
      }
 else {
        modified=PGPPublicKey.removeCertification(modified,zert);
        redundantCerts+=1;
        log.add(LogLevel.INFO,LogType.MSG_KC_REVOKE_DUP,indent);
      }
    }
    for (    String userId : new IterableIterator<String>(masterKey.getUserIDs())) {
      PGPSignature selfCert=null;
      revocation=null;
      for (      PGPSignature zert : new IterableIterator<PGPSignature>(masterKey.getSignaturesForID(userId))) {
        WrappedSignature cert=new WrappedSignature(zert);
        long certId=cert.getKeyId();
        int type=zert.getSignatureType();
        if (type != PGPSignature.DEFAULT_CERTIFICATION && type != PGPSignature.NO_CERTIFICATION && type != PGPSignature.CASUAL_CERTIFICATION && type != PGPSignature.POSITIVE_CERTIFICATION && type != PGPSignature.CERTIFICATION_REVOCATION) {
          log.add(LogLevel.WARN,LogType.MSG_KC_UID_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(zert.getSignatureType(),16));
          modified=PGPPublicKey.removeCertification(modified,userId,zert);
          badCerts+=1;
        }
        if (cert.getCreationTime().after(now)) {
          log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_TIME,indent);
          modified=PGPPublicKey.removeCertification(modified,zert);
          badCerts+=1;
          continue;
        }
        if (cert.isLocal()) {
          log.add(LogLevel.WARN,LogType.MSG_KC_REVOKE_BAD_LOCAL,indent);
          modified=PGPPublicKey.removeCertification(modified,zert);
          badCerts+=1;
          continue;
        }
        if (certId != masterKeyId) {
          if (isSecret()) {
            log.add(LogLevel.WARN,LogType.MSG_KC_UID_FOREIGN,indent,PgpKeyHelper.convertKeyIdToHex(certId));
            modified=PGPPublicKey.removeCertification(modified,userId,zert);
            badCerts+=1;
          }
          continue;
        }
        try {
          cert.init(masterKey);
          if (!cert.verifySignature(masterKey,userId)) {
            log.add(LogLevel.WARN,LogType.MSG_KC_UID_BAD,indent,userId);
            modified=PGPPublicKey.removeCertification(modified,userId,zert);
            badCerts+=1;
            continue;
          }
        }
 catch (        PgpGeneralException e) {
          log.add(LogLevel.WARN,LogType.MSG_KC_UID_BAD_ERR,indent,userId);
          modified=PGPPublicKey.removeCertification(modified,userId,zert);
          badCerts+=1;
          continue;
        }
switch (type) {
case PGPSignature.DEFAULT_CERTIFICATION:
case PGPSignature.NO_CERTIFICATION:
case PGPSignature.CASUAL_CERTIFICATION:
case PGPSignature.POSITIVE_CERTIFICATION:
          if (selfCert == null) {
            selfCert=zert;
          }
 else           if (selfCert.getCreationTime().before(cert.getCreationTime())) {
            modified=PGPPublicKey.removeCertification(modified,userId,selfCert);
            redundantCerts+=1;
            log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_DUP,indent,userId);
            selfCert=zert;
          }
 else {
            modified=PGPPublicKey.removeCertification(modified,userId,zert);
            redundantCerts+=1;
            log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_DUP,indent,userId);
          }
        if (revocation != null && revocation.getCreationTime().before(selfCert.getCreationTime())) {
          modified=PGPPublicKey.removeCertification(modified,userId,revocation);
          revocation=null;
          redundantCerts+=1;
          log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_REVOKE_OLD,indent,userId);
        }
      break;
case PGPSignature.CERTIFICATION_REVOCATION:
    if (selfCert != null && selfCert.getCreationTime().after(zert.getCreationTime())) {
      modified=PGPPublicKey.removeCertification(modified,userId,zert);
      redundantCerts+=1;
      log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_REVOKE_OLD,indent,userId);
      continue;
    }
  if (revocation == null) {
    revocation=zert;
  }
 else   if (revocation.getCreationTime().before(cert.getCreationTime())) {
    modified=PGPPublicKey.removeCertification(modified,userId,revocation);
    redundantCerts+=1;
    log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_REVOKE_DUP,indent,userId);
    revocation=zert;
  }
 else {
    modified=PGPPublicKey.removeCertification(modified,userId,zert);
    redundantCerts+=1;
    log.add(LogLevel.DEBUG,LogType.MSG_KC_UID_REVOKE_DUP,indent,userId);
  }
break;
}
}
if (selfCert == null && revocation == null) {
modified=PGPPublicKey.removeCertification(modified,userId);
log.add(LogLevel.ERROR,LogType.MSG_KC_UID_REVOKE_DUP,indent,userId);
}
}
if (!modified.getUserIDs().hasNext()) {
log.add(LogLevel.ERROR,LogType.MSG_KC_FATAL_NO_UID,indent);
return null;
}
ring=replacePublicKey(ring,modified);
indent-=1;
}
for (PGPPublicKey key : new IterableIterator<PGPPublicKey>(ring.getPublicKeys())) {
if (key.isMasterKey()) {
continue;
}
log.add(LogLevel.DEBUG,LogType.MSG_KC_SUB,indent,PgpKeyHelper.convertKeyIdToHex(key.getKeyID()));
indent+=1;
PGPPublicKey modified=key;
PGPSignature selfCert=null, revocation=null;
uids: for (PGPSignature zert : new IterableIterator<PGPSignature>(key.getSignatures())) {
modified=PGPPublicKey.removeCertification(modified,zert);
WrappedSignature cert=new WrappedSignature(zert);
int type=cert.getSignatureType();
if (cert.getKeyId() != masterKey.getKeyID()) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD_KEYID,indent);
badCerts+=1;
continue;
}
if (type != PGPSignature.SUBKEY_BINDING && type != PGPSignature.SUBKEY_REVOCATION) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD_TYPE,indent,""String_Node_Str"" + Integer.toString(type,16));
badCerts+=1;
continue;
}
if (cert.getCreationTime().after(now)) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD_TIME,indent);
badCerts+=1;
continue;
}
if (cert.isLocal()) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD_LOCAL,indent);
badCerts+=1;
continue;
}
if (type == PGPSignature.SUBKEY_BINDING) {
try {
cert.init(masterKey);
if (!cert.verifySignature(masterKey,key)) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD,indent);
badCerts+=1;
continue;
}
}
 catch (PgpGeneralException e) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_BAD_ERR,indent);
badCerts+=1;
continue;
}
if (zert.getHashedSubPackets().hasSubpacket(SignatureSubpacketTags.KEY_FLAGS)) {
int flags=((KeyFlags)zert.getHashedSubPackets().getSubpacket(SignatureSubpacketTags.KEY_FLAGS)).getFlags();
if ((flags & PGPKeyFlags.CAN_SIGN) == PGPKeyFlags.CAN_SIGN) {
try {
  PGPSignatureList list=zert.getUnhashedSubPackets().getEmbeddedSignatures();
  boolean ok=false;
  for (int i=0; i < list.size(); i++) {
    WrappedSignature subsig=new WrappedSignature(list.get(i));
    if (subsig.getSignatureType() == PGPSignature.PRIMARYKEY_BINDING) {
      subsig.init(key);
      if (subsig.verifySignature(masterKey,key)) {
        ok=true;
      }
 else {
        log.add(LogLevel.WARN,LogType.MSG_KC_SUB_PRIMARY_BAD,indent);
        badCerts+=1;
        continue uids;
      }
    }
  }
  if (!ok) {
    log.add(LogLevel.WARN,LogType.MSG_KC_SUB_PRIMARY_NONE,indent);
    badCerts+=1;
    continue;
  }
}
 catch (Exception e) {
  log.add(LogLevel.WARN,LogType.MSG_KC_SUB_PRIMARY_BAD_ERR,indent);
  badCerts+=1;
  continue;
}
}
}
if (selfCert != null && selfCert.getCreationTime().before(cert.getCreationTime())) {
log.add(LogLevel.DEBUG,LogType.MSG_KC_SUB_DUP,indent);
redundantCerts+=1;
continue;
}
selfCert=zert;
if (revocation != null && selfCert.getCreationTime().after(revocation.getCreationTime())) {
revocation=null;
}
}
 else {
try {
cert.init(masterKey);
if (!cert.verifySignature(masterKey,key)) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_REVOKE_BAD,indent);
badCerts+=1;
continue;
}
}
 catch (PgpGeneralException e) {
log.add(LogLevel.WARN,LogType.MSG_KC_SUB_REVOKE_BAD_ERR,indent);
badCerts+=1;
continue;
}
if (selfCert != null && selfCert.getCreationTime().after(cert.getCreationTime())) {
log.add(LogLevel.DEBUG,LogType.MSG_KC_SUB_REVOKE_DUP,indent);
redundantCerts+=1;
continue;
}
revocation=zert;
}
}
if (selfCert == null) {
ring=replacePublicKey(ring,modified);
log.add(LogLevel.ERROR,LogType.MSG_KC_SUB_NO_CERT,indent,PgpKeyHelper.convertKeyIdToHex(key.getKeyID()));
indent-=1;
continue;
}
modified=PGPPublicKey.addCertification(modified,selfCert);
if (revocation != null) {
modified=PGPPublicKey.addCertification(modified,revocation);
}
ring=replacePublicKey(ring,modified);
indent-=1;
}
if (badCerts > 0 && redundantCerts > 0) {
log.add(LogLevel.OK,LogType.MSG_KC_SUCCESS_BAD_AND_RED,indent,Integer.toString(badCerts),Integer.toString(redundantCerts));
}
 else if (badCerts > 0) {
log.add(LogLevel.OK,LogType.MSG_KC_SUCCESS_BAD,indent,badCerts);
}
 else if (redundantCerts > 0) {
log.add(LogLevel.OK,LogType.MSG_KC_SUCCESS_REDUNDANT,indent,redundantCerts);
}
 else {
log.add(LogLevel.OK,LogType.MSG_KC_SUCCESS,indent);
}
return new UncachedKeyRing(ring,true);
}",0.9995982645026514
8367,"private void updateView(){
  if (mEncryptionKeyIds == null || mEncryptionKeyIds.length == 0) {
    mSelectKeysButton.setText(getString(R.string.select_keys_button_default));
  }
 else {
    mSelectKeysButton.setText(getResources().getQuantityString(R.plurals.select_keys_button,mEncryptionKeyIds.length,mEncryptionKeyIds.length));
  }
  if (mSecretKeyId == Constants.key.none) {
    mSign.setChecked(false);
    mMainUserId.setText(""String_Node_Str"");
    mMainUserIdRest.setText(""String_Node_Str"");
  }
 else {
    String[] userId;
    try {
      userId=mProviderHelper.getCachedPublicKeyRing(KeyRings.buildUnifiedKeyRingUri(mSecretKeyId)).getSplitPrimaryUserId();
    }
 catch (    PgpGeneralException e) {
      userId=null;
    }
    if (userId != null && userId[0] != null) {
      mMainUserId.setText(userId[0]);
    }
 else {
      mMainUserId.setText(getResources().getString(R.string.user_id_no_name));
    }
    if (userId != null && userId[1] != null) {
      mMainUserIdRest.setText(userId[1]);
    }
 else {
      mMainUserIdRest.setText(""String_Node_Str"");
    }
    mSign.setChecked(true);
  }
}","private void updateView(){
  if (mEncryptionKeyIds == null || mEncryptionKeyIds.length == 0) {
    mSelectKeysButton.setText(getString(R.string.select_keys_button_default));
  }
 else {
    mSelectKeysButton.setText(getResources().getQuantityString(R.plurals.select_keys_button,mEncryptionKeyIds.length,mEncryptionKeyIds.length));
  }
  if (mSecretKeyId == Constants.key.none) {
    mSign.setChecked(false);
    mMainUserId.setText(""String_Node_Str"");
    mMainUserIdRest.setText(""String_Node_Str"");
  }
 else {
    String[] userId;
    try {
      userId=mProviderHelper.getCachedPublicKeyRing(KeyRings.buildUnifiedKeyRingUri(mSecretKeyId)).getSplitPrimaryUserId();
    }
 catch (    PgpGeneralException e) {
      userId=null;
    }
    if (userId != null && userId[0] != null) {
      mMainUserId.setText(String.format(""String_Node_Str"",Long.parseLong(userId[0])));
    }
 else {
      mMainUserId.setText(getResources().getString(R.string.user_id_no_name));
    }
    if (userId != null && userId[1] != null) {
      mMainUserIdRest.setText(userId[1]);
    }
 else {
      mMainUserIdRest.setText(""String_Node_Str"");
    }
    mSign.setChecked(true);
  }
}",0.9784236019374724
8368,"@Override public ArrayList<ImportKeysListEntry> search(String query) throws QueryFailedException, QueryNeedsRepairException {
  ArrayList<ImportKeysListEntry> results=new ArrayList<ImportKeysListEntry>();
  if (query.length() < 3) {
    throw new QueryTooShortException();
  }
  String encodedQuery;
  try {
    encodedQuery=URLEncoder.encode(query,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    return null;
  }
  String request=""String_Node_Str"" + encodedQuery;
  String data;
  try {
    data=query(request);
  }
 catch (  HttpError e) {
    if (e.getCode() == 404) {
      return results;
    }
 else {
      if (e.getData().toLowerCase(Locale.US).contains(""String_Node_Str"")) {
        return results;
      }
 else       if (e.getData().toLowerCase(Locale.US).contains(""String_Node_Str"")) {
        throw new TooManyResponsesException();
      }
 else       if (e.getData().toLowerCase(Locale.US).contains(""String_Node_Str"")) {
        throw new QueryTooShortException();
      }
    }
    throw new QueryFailedException(""String_Node_Str"" + mHost + ""String_Node_Str"");
  }
  final Matcher matcher=PUB_KEY_LINE.matcher(data);
  while (matcher.find()) {
    final ImportKeysListEntry entry=new ImportKeysListEntry();
    entry.setQuery(query);
    entry.setOrigin(getUrlPrefix() + mHost + ""String_Node_Str""+ mPort);
    entry.setBitStrength(Integer.parseInt(matcher.group(3)));
    final int algorithmId=Integer.decode(matcher.group(2));
    entry.setAlgorithm(PgpKeyHelper.getAlgorithmInfo(algorithmId));
    String fingerprintOrKeyId=matcher.group(1);
    if (fingerprintOrKeyId.length() > 16) {
      entry.setFingerprintHex(fingerprintOrKeyId.toLowerCase(Locale.US));
      entry.setKeyIdHex(""String_Node_Str"" + fingerprintOrKeyId.substring(fingerprintOrKeyId.length() - 16,fingerprintOrKeyId.length()));
    }
 else {
      entry.setKeyIdHex(""String_Node_Str"" + fingerprintOrKeyId);
    }
    final long creationDate=Long.parseLong(matcher.group(4));
    final GregorianCalendar tmpGreg=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
    tmpGreg.setTimeInMillis(creationDate * 1000);
    entry.setDate(tmpGreg.getTime());
    entry.setRevoked(matcher.group(6).contains(""String_Node_Str""));
    entry.setExpired(matcher.group(6).contains(""String_Node_Str""));
    ArrayList<String> userIds=new ArrayList<String>();
    final String uidLines=matcher.group(7);
    final Matcher uidMatcher=UID_LINE.matcher(uidLines);
    while (uidMatcher.find()) {
      String tmp=uidMatcher.group(1).trim();
      if (tmp.contains(""String_Node_Str"")) {
        try {
          tmp=(URLDecoder.decode(tmp,""String_Node_Str""));
        }
 catch (        UnsupportedEncodingException ignored) {
        }
      }
      userIds.add(tmp);
    }
    entry.setUserIds(userIds);
    entry.setPrimaryUserId(userIds.get(0));
    results.add(entry);
  }
  return results;
}","@Override public ArrayList<ImportKeysListEntry> search(String query) throws QueryFailedException, QueryNeedsRepairException {
  ArrayList<ImportKeysListEntry> results=new ArrayList<ImportKeysListEntry>();
  if (query.length() < 3) {
    throw new QueryTooShortException();
  }
  String encodedQuery;
  try {
    encodedQuery=URLEncoder.encode(query,""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    return null;
  }
  String request=""String_Node_Str"" + encodedQuery;
  String data;
  try {
    data=query(request);
  }
 catch (  HttpError e) {
    if (e.getCode() == 404) {
      return results;
    }
 else {
      if (e.getData().toLowerCase(Locale.US).contains(""String_Node_Str"")) {
        return results;
      }
 else       if (e.getData().toLowerCase(Locale.US).contains(""String_Node_Str"")) {
        throw new TooManyResponsesException();
      }
 else       if (e.getData().toLowerCase(Locale.US).contains(""String_Node_Str"")) {
        throw new QueryTooShortException();
      }
    }
    throw new QueryFailedException(""String_Node_Str"" + mHost + ""String_Node_Str"");
  }
  final Matcher matcher=PUB_KEY_LINE.matcher(data);
  while (matcher.find()) {
    final ImportKeysListEntry entry=new ImportKeysListEntry();
    entry.setQuery(query);
    entry.setOrigin(getUrlPrefix() + mHost + ""String_Node_Str""+ mPort);
    entry.setBitStrength(Integer.parseInt(matcher.group(3)));
    final int algorithmId=Integer.decode(matcher.group(2));
    entry.setAlgorithm(PgpKeyHelper.getAlgorithmInfo(algorithmId));
    String fingerprintOrKeyId=matcher.group(1);
    if (fingerprintOrKeyId.length() > 16) {
      entry.setFingerprintHex(fingerprintOrKeyId.toLowerCase(Locale.US));
      entry.setKeyIdHex(""String_Node_Str"" + fingerprintOrKeyId.substring(fingerprintOrKeyId.length() - 16,fingerprintOrKeyId.length()));
    }
 else {
      entry.setKeyIdHex(""String_Node_Str"" + fingerprintOrKeyId);
    }
    final long creationDate=Long.parseLong(matcher.group(4));
    final GregorianCalendar tmpGreg=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
    tmpGreg.setTimeInMillis(creationDate * 1000);
    entry.setDate(tmpGreg.getTime());
    entry.setRevoked(matcher.group(6).contains(""String_Node_Str""));
    entry.setExpired(matcher.group(6).contains(""String_Node_Str""));
    ArrayList<String> userIds=new ArrayList<String>();
    final String uidLines=matcher.group(7);
    final Matcher uidMatcher=UID_LINE.matcher(uidLines);
    while (uidMatcher.find()) {
      String tmp=uidMatcher.group(1).trim();
      if (tmp.contains(""String_Node_Str"")) {
        if (tmp.contains(""String_Node_Str"")) {
          tmp=tmp.replace(""String_Node_Str"",""String_Node_Str"");
        }
        try {
          tmp=(URLDecoder.decode(tmp,""String_Node_Str""));
        }
 catch (        UnsupportedEncodingException ignored) {
        }
      }
      userIds.add(tmp);
    }
    entry.setUserIds(userIds);
    entry.setPrimaryUserId(userIds.get(0));
    results.add(entry);
  }
  return results;
}",0.9795296904077144
8369,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.import_keys_activity);
  mViewPager=(ViewPager)findViewById(R.id.import_pager);
  mSlidingTabLayout=(SlidingTabLayout)findViewById(R.id.import_sliding_tab_layout);
  mImportButton=findViewById(R.id.import_import);
  mImportButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      importKeys();
    }
  }
);
  mNavigationStrings=getResources().getStringArray(R.array.import_action_list);
  handleActions(savedInstanceState,getIntent());
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.import_keys_activity);
  mViewPager=(ViewPager)findViewById(R.id.import_pager);
  mSlidingTabLayout=(SlidingTabLayout)findViewById(R.id.import_sliding_tab_layout);
  mImportButton=findViewById(R.id.import_import);
  mImportButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      importKeys();
    }
  }
);
  handleActions(savedInstanceState,getIntent());
}",0.8820422535211268
8370,"/** 
 * Scroll ViewPager left and right
 * @param event
 * @return
 */
@Override public boolean onTouchEvent(MotionEvent event){
  boolean result=super.onTouchEvent(event);
  if (!result) {
    mViewPager.onTouchEvent(event);
  }
  return result;
}","/** 
 * Scroll ViewPager left and right
 * @param event
 * @return
 */
@Override public boolean onTouchEvent(MotionEvent event){
  boolean result=super.onTouchEvent(event);
  if (!result) {
    try {
      mViewPager.onTouchEvent(event);
    }
 catch (    IllegalArgumentException e) {
      Log.d(Constants.TAG,""String_Node_Str"");
    }
  }
  return result;
}",0.7697368421052632
8371,"public static void writeKeysToContacts(Context context){
  ContentResolver resolver=context.getContentResolver();
  Cursor cursor=resolver.query(KeychainContract.KeyRings.buildUnifiedKeyRingsUri(),KEYS_TO_CONTACT_PROJECTION,null,null,null);
  if (cursor != null) {
    while (cursor.moveToNext()) {
      String[] userId=PgpKeyHelper.splitUserId(cursor.getString(0));
      String fingerprint=PgpKeyHelper.convertFingerprintToHex(cursor.getBlob(1));
      String keyIdShort=PgpKeyHelper.convertKeyIdToHexShort(cursor.getLong(2));
      long masterKeyId=cursor.getLong(3);
      int rawContactId=-1;
      Cursor raw=resolver.query(ContactsContract.RawContacts.CONTENT_URI,RAW_CONTACT_ID_PROJECTION,FIND_RAW_CONTACT_SELECTION,new String[]{Constants.PACKAGE_NAME,fingerprint},null,null);
      if (raw != null) {
        if (raw.moveToNext()) {
          rawContactId=raw.getInt(0);
        }
        raw.close();
      }
      ArrayList<ContentProviderOperation> ops=new ArrayList<ContentProviderOperation>();
      if (rawContactId == -1) {
        ops.add(ContentProviderOperation.newInsert(ContactsContract.RawContacts.CONTENT_URI).withValue(ContactsContract.RawContacts.ACCOUNT_NAME,context.getString(R.string.app_name)).withValue(ContactsContract.RawContacts.ACCOUNT_TYPE,Constants.PACKAGE_NAME).withValue(ContactsContract.RawContacts.SOURCE_ID,fingerprint).build());
        if (userId[0] != null) {
          ops.add(ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI).withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID,0).withValue(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE).withValue(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME,userId[0]).build());
        }
        if (userId[1] != null) {
          ops.add(ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI).withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID,0).withValue(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Email.CONTENT_ITEM_TYPE).withValue(ContactsContract.CommonDataKinds.Email.DATA,userId[1]).build());
        }
        ops.add(ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI).withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID,0).withValue(ContactsContract.Data.MIMETYPE,Constants.CUSTOM_CONTACT_DATA_MIME_TYPE).withValue(ContactsContract.Data.DATA1,String.format(context.getString(R.string.contact_show_key),keyIdShort)).withValue(ContactsContract.Data.DATA2,masterKeyId).build());
      }
      try {
        resolver.applyBatch(ContactsContract.AUTHORITY,ops);
      }
 catch (      RemoteException e) {
        e.printStackTrace();
      }
catch (      OperationApplicationException e) {
        e.printStackTrace();
      }
    }
    cursor.close();
  }
}","public static void writeKeysToContacts(Context context){
  ContentResolver resolver=context.getContentResolver();
  Cursor cursor=resolver.query(KeychainContract.KeyRings.buildUnifiedKeyRingsUri(),KEYS_TO_CONTACT_PROJECTION,null,null,null);
  if (cursor != null) {
    while (cursor.moveToNext()) {
      String[] userId=KeyRing.splitUserId(cursor.getString(0));
      String fingerprint=PgpKeyHelper.convertFingerprintToHex(cursor.getBlob(1));
      String keyIdShort=PgpKeyHelper.convertKeyIdToHexShort(cursor.getLong(2));
      long masterKeyId=cursor.getLong(3);
      int rawContactId=-1;
      Cursor raw=resolver.query(ContactsContract.RawContacts.CONTENT_URI,RAW_CONTACT_ID_PROJECTION,FIND_RAW_CONTACT_SELECTION,new String[]{Constants.PACKAGE_NAME,fingerprint},null,null);
      if (raw != null) {
        if (raw.moveToNext()) {
          rawContactId=raw.getInt(0);
        }
        raw.close();
      }
      ArrayList<ContentProviderOperation> ops=new ArrayList<ContentProviderOperation>();
      if (rawContactId == -1) {
        ops.add(ContentProviderOperation.newInsert(ContactsContract.RawContacts.CONTENT_URI).withValue(ContactsContract.RawContacts.ACCOUNT_NAME,context.getString(R.string.app_name)).withValue(ContactsContract.RawContacts.ACCOUNT_TYPE,Constants.PACKAGE_NAME).withValue(ContactsContract.RawContacts.SOURCE_ID,fingerprint).build());
        if (userId[0] != null) {
          ops.add(ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI).withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID,0).withValue(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE).withValue(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME,userId[0]).build());
        }
        if (userId[1] != null) {
          ops.add(ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI).withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID,0).withValue(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Email.CONTENT_ITEM_TYPE).withValue(ContactsContract.CommonDataKinds.Email.DATA,userId[1]).build());
        }
        ops.add(ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI).withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID,0).withValue(ContactsContract.Data.MIMETYPE,Constants.CUSTOM_CONTACT_DATA_MIME_TYPE).withValue(ContactsContract.Data.DATA1,String.format(context.getString(R.string.contact_show_key),keyIdShort)).withValue(ContactsContract.Data.DATA2,masterKeyId).build());
      }
      try {
        resolver.applyBatch(ContactsContract.AUTHORITY,ops);
      }
 catch (      RemoteException e) {
        e.printStackTrace();
      }
catch (      OperationApplicationException e) {
        e.printStackTrace();
      }
    }
    cursor.close();
  }
}",0.9976872442625868
8372,"private JSONObject getFromKeybase(String path,String query) throws QueryFailedException {
  try {
    String url=""String_Node_Str"" + path + URLEncoder.encode(query,""String_Node_Str"");
    Log.d(Constants.TAG,""String_Node_Str"" + url);
    URL realUrl=new URL(url);
    HttpURLConnection conn=(HttpURLConnection)realUrl.openConnection();
    conn.setConnectTimeout(5000);
    conn.setReadTimeout(25000);
    conn.connect();
    int response=conn.getResponseCode();
    if (response >= 200 && response < 300) {
      String text=readAll(conn.getInputStream(),conn.getContentEncoding());
      try {
        JSONObject json=new JSONObject(text);
        if (JWalk.getInt(json,""String_Node_Str"",""String_Node_Str"") != 0) {
          throw new QueryFailedException(""String_Node_Str"");
        }
        return json;
      }
 catch (      JSONException e) {
        throw new QueryFailedException(""String_Node_Str"");
      }
    }
 else {
      String message=readAll(conn.getErrorStream(),conn.getContentEncoding());
      throw new QueryFailedException(""String_Node_Str"" + response + ""String_Node_Str""+ message);
    }
  }
 catch (  Exception e) {
    throw new QueryFailedException(""String_Node_Str"");
  }
}","private JSONObject getFromKeybase(String path,String query) throws QueryFailedException {
  try {
    String url=""String_Node_Str"" + path + URLEncoder.encode(query,""String_Node_Str"");
    Log.d(Constants.TAG,""String_Node_Str"" + url);
    URL realUrl=new URL(url);
    HttpURLConnection conn=(HttpURLConnection)realUrl.openConnection();
    conn.setConnectTimeout(5000);
    conn.setReadTimeout(25000);
    conn.connect();
    int response=conn.getResponseCode();
    if (response >= 200 && response < 300) {
      String text=readAll(conn.getInputStream(),conn.getContentEncoding());
      try {
        JSONObject json=new JSONObject(text);
        if (JWalk.getInt(json,""String_Node_Str"",""String_Node_Str"") != 0) {
          throw new QueryFailedException(""String_Node_Str"" + path + ""String_Node_Str""+ query);
        }
        return json;
      }
 catch (      JSONException e) {
        throw new QueryFailedException(""String_Node_Str"");
      }
    }
 else {
      String message=readAll(conn.getErrorStream(),conn.getContentEncoding());
      throw new QueryFailedException(""String_Node_Str"" + response + ""String_Node_Str""+ message);
    }
  }
 catch (  Exception e) {
    throw new QueryFailedException(""String_Node_Str"");
  }
}",0.9860541427399508
8373,"private LongSparseArray<UncachedPublicKey> getUncachedMasterKeys(Uri queryUri){
  Cursor cursor=mContentResolver.query(queryUri,new String[]{KeyRingData.MASTER_KEY_ID,KeyRingData.KEY_RING_DATA},null,null,null);
  LongSparseArray<UncachedPublicKey> result=new LongSparseArray<UncachedPublicKey>(cursor.getCount());
  try {
    if (cursor != null && cursor.moveToFirst())     do {
      long masterKeyId=cursor.getLong(0);
      byte[] data=cursor.getBlob(1);
      if (data != null) {
        try {
          result.put(masterKeyId,UncachedKeyRing.decodePublicFromData(data).getPublicKey());
        }
 catch (        PgpGeneralException e) {
          Log.e(Constants.TAG,""String_Node_Str"");
        }
catch (        IOException e) {
          Log.e(Constants.TAG,""String_Node_Str"");
        }
      }
    }
 while (cursor.moveToNext());
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return result;
}","private LongSparseArray<UncachedPublicKey> getUncachedMasterKeys(Uri queryUri){
  Cursor cursor=mContentResolver.query(queryUri,new String[]{KeyRingData.MASTER_KEY_ID,KeyRingData.KEY_RING_DATA},null,null,null);
  LongSparseArray<UncachedPublicKey> result=new LongSparseArray<UncachedPublicKey>(cursor.getCount());
  try {
    if (cursor != null && cursor.moveToFirst())     do {
      long masterKeyId=cursor.getLong(0);
      byte[] data=cursor.getBlob(1);
      if (data != null) {
        try {
          result.put(masterKeyId,UncachedKeyRing.decodeFromData(data).getPublicKey());
        }
 catch (        PgpGeneralException e) {
          Log.e(Constants.TAG,""String_Node_Str"" + masterKeyId,e);
        }
catch (        IOException e) {
          Log.e(Constants.TAG,""String_Node_Str"" + masterKeyId,e);
        }
      }
    }
 while (cursor.moveToNext());
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
  return result;
}",0.9798515376458112
8374,"public void buildSecretKey(SaveKeyringParcel saveParcel) throws PgpGeneralException, PGPException, SignatureException, IOException {
  updateProgress(R.string.progress_building_key,0,100);
  PGPSecretKey masterKey=saveParcel.keys.get(0);
  PGPSecretKeyRing mKR=ProviderHelper.getPGPSecretKeyRingByKeyId(mContext,masterKey.getKeyID());
  PGPPublicKeyRing pKR=ProviderHelper.getPGPPublicKeyRingByKeyId(mContext,masterKey.getKeyID());
  if (saveParcel.oldPassPhrase == null) {
    saveParcel.oldPassPhrase=""String_Node_Str"";
  }
  if (saveParcel.newPassPhrase == null) {
    saveParcel.newPassPhrase=""String_Node_Str"";
  }
  if (mKR == null) {
    buildNewSecretKey(saveParcel.userIDs,saveParcel.keys,saveParcel.keysExpiryDates,saveParcel.keysUsages,saveParcel.newPassPhrase,saveParcel.oldPassPhrase);
    return;
  }
  for (  PGPSecretKey dKey : saveParcel.deletedKeys) {
    mKR=PGPSecretKeyRing.removeSecretKey(mKR,dKey);
  }
  masterKey=mKR.getSecretKey();
  PGPPublicKey masterPublicKey=masterKey.getPublicKey();
  int usageId=saveParcel.keysUsages.get(0);
  boolean canSign;
  String mainUserId=saveParcel.userIDs.get(0);
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(saveParcel.oldPassPhrase.toCharArray());
  PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(keyDecryptor);
  updateProgress(R.string.progress_certifying_master_key,20,100);
  for (  String delID : saveParcel.deletedIDs) {
    masterPublicKey=PGPPublicKey.removeCertification(masterPublicKey,delID);
  }
  int user_id_index=0;
  boolean anyIDChanged=false;
  if (saveParcel.primaryIDChanged) {
    anyIDChanged=true;
    ArrayList<Pair<String,PGPSignature>> sigList=new ArrayList<Pair<String,PGPSignature>>();
    for (    String userId : saveParcel.userIDs) {
      String orig_id=saveParcel.originalIDs.get(user_id_index);
      if (orig_id.equals(userId)) {
        Iterator<PGPSignature> orig_sigs=masterPublicKey.getSignaturesForID(orig_id);
        while (orig_sigs.hasNext()) {
          PGPSignature orig_sig=orig_sigs.next();
          sigList.add(new Pair<String,PGPSignature>(orig_id,orig_sig));
        }
      }
 else {
        PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
        PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
        sGen.init(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
        PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
        sigList.add(new Pair<String,PGPSignature>(userId,certification));
      }
      masterPublicKey=PGPPublicKey.removeCertification(masterPublicKey,orig_id);
      user_id_index++;
    }
    for (    Pair<String,PGPSignature> to_add : sigList) {
      masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,to_add.first,to_add.second);
    }
  }
 else {
    for (    String userId : saveParcel.userIDs) {
      String orig_id=saveParcel.originalIDs.get(user_id_index);
      if (!orig_id.equals(userId)) {
        anyIDChanged=true;
        PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
        PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
        sGen.init(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
        PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
        masterPublicKey=PGPPublicKey.removeCertification(masterPublicKey,orig_id);
        masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,userId,certification);
      }
      user_id_index++;
    }
  }
  if (anyIDChanged) {
    pKR=PGPPublicKeyRing.insertPublicKey(pKR,masterPublicKey);
    mKR=PGPSecretKeyRing.replacePublicKeys(mKR,pKR);
  }
  PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
  PGPSignatureSubpacketGenerator hashedPacketsGen=new PGPSignatureSubpacketGenerator();
  PGPSignatureSubpacketGenerator unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
  hashedPacketsGen.setKeyFlags(true,usageId);
  hashedPacketsGen.setPreferredSymmetricAlgorithms(true,PREFERRED_SYMMETRIC_ALGORITHMS);
  hashedPacketsGen.setPreferredHashAlgorithms(true,PREFERRED_HASH_ALGORITHMS);
  hashedPacketsGen.setPreferredCompressionAlgorithms(true,PREFERRED_COMPRESSION_ALGORITHMS);
  if (saveParcel.keysExpiryDates.get(0) != null) {
    GregorianCalendar creationDate=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
    creationDate.setTime(masterPublicKey.getCreationTime());
    GregorianCalendar expiryDate=saveParcel.keysExpiryDates.get(0);
    long numDays=(expiryDate.getTimeInMillis() / 86400000) - (creationDate.getTimeInMillis() / 86400000);
    if (numDays <= 0)     throw new PgpGeneralException(mContext.getString(R.string.error_expiry_must_come_after_creation));
    hashedPacketsGen.setKeyExpirationTime(false,numDays * 86400);
  }
 else {
    hashedPacketsGen.setKeyExpirationTime(false,0);
  }
  updateProgress(R.string.progress_building_master_key,30,100);
  PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
  PGPContentSignerBuilder certificationSignerBuilder=new JcaPGPContentSignerBuilder(masterKeyPair.getPublicKey().getAlgorithm(),HashAlgorithmTags.SHA1);
  PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(saveParcel.oldPassPhrase.toCharArray());
  PGPKeyRingGenerator keyGen=new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION,masterKeyPair,mainUserId,sha1Calc,hashedPacketsGen.generate(),unhashedPacketsGen.generate(),certificationSignerBuilder,keyEncryptor);
  for (int i=0; i < saveParcel.keys.size(); ++i) {
    updateProgress(40 + 50 * i / saveParcel.keys.size(),100);
    if (saveParcel.moddedKeys[i]) {
      PGPSecretKey subKey=saveParcel.keys.get(i);
      PGPPublicKey subPublicKey=subKey.getPublicKey();
      PBESecretKeyDecryptor keyDecryptor2;
      if (saveParcel.newKeys[i]) {
        keyDecryptor2=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(""String_Node_Str"".toCharArray());
      }
 else {
        keyDecryptor2=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(saveParcel.oldPassPhrase.toCharArray());
      }
      PGPPrivateKey subPrivateKey=subKey.extractPrivateKey(keyDecryptor2);
      PGPKeyPair subKeyPair=new PGPKeyPair(subPublicKey,subPrivateKey);
      hashedPacketsGen=new PGPSignatureSubpacketGenerator();
      unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
      usageId=saveParcel.keysUsages.get(i);
      canSign=(usageId & KeyFlags.SIGN_DATA) > 0;
      if (canSign) {
        Date todayDate=new Date();
        hashedPacketsGen.setSignatureCreationTime(false,todayDate);
        PGPSignatureSubpacketGenerator subHashedPacketsGen=new PGPSignatureSubpacketGenerator();
        subHashedPacketsGen.setSignatureCreationTime(false,todayDate);
        PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(subPublicKey.getAlgorithm(),PGPUtil.SHA1).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
        PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
        sGen.init(PGPSignature.PRIMARYKEY_BINDING,subPrivateKey);
        sGen.setHashedSubpackets(subHashedPacketsGen.generate());
        PGPSignature certification=sGen.generateCertification(masterPublicKey,subPublicKey);
        unhashedPacketsGen.setEmbeddedSignature(false,certification);
      }
      hashedPacketsGen.setKeyFlags(false,usageId);
      if (saveParcel.keysExpiryDates.get(i) != null) {
        GregorianCalendar creationDate=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
        creationDate.setTime(subPublicKey.getCreationTime());
        GregorianCalendar expiryDate=saveParcel.keysExpiryDates.get(i);
        long numDays=(expiryDate.getTimeInMillis() / 86400000) - (creationDate.getTimeInMillis() / 86400000);
        if (numDays <= 0)         throw new PgpGeneralException(mContext.getString(R.string.error_expiry_must_come_after_creation));
        hashedPacketsGen.setKeyExpirationTime(false,numDays * 86400);
      }
 else {
        hashedPacketsGen.setKeyExpirationTime(false,0);
      }
      keyGen.addSubKey(subKeyPair,hashedPacketsGen.generate(),unhashedPacketsGen.generate());
    }
  }
  PGPSecretKeyRing updatedSecretKeyRing=keyGen.generateSecretKeyRing();
  Iterator<PGPSecretKey> itr=updatedSecretKeyRing.getSecretKeys();
  while (itr.hasNext()) {
    PGPSecretKey theNextKey=itr.next();
    if ((theNextKey.isMasterKey() && saveParcel.moddedKeys[0]) || !theNextKey.isMasterKey()) {
      mKR=PGPSecretKeyRing.insertSecretKey(mKR,theNextKey);
      pKR=PGPPublicKeyRing.insertPublicKey(pKR,theNextKey.getPublicKey());
    }
  }
  PBESecretKeyEncryptor keyEncryptorNew=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(saveParcel.newPassPhrase.toCharArray());
  mKR=PGPSecretKeyRing.copyWithNewPassword(mKR,keyDecryptor,keyEncryptorNew);
  updateProgress(R.string.progress_saving_key_ring,90,100);
  ProviderHelper.saveKeyRing(mContext,mKR);
  ProviderHelper.saveKeyRing(mContext,pKR);
  updateProgress(R.string.progress_done,100,100);
}","public void buildSecretKey(SaveKeyringParcel saveParcel) throws PgpGeneralException, PGPException, SignatureException, IOException {
  updateProgress(R.string.progress_building_key,0,100);
  PGPSecretKey masterKey=saveParcel.keys.get(0);
  PGPSecretKeyRing mKR=ProviderHelper.getPGPSecretKeyRingByKeyId(mContext,masterKey.getKeyID());
  PGPPublicKeyRing pKR=ProviderHelper.getPGPPublicKeyRingByKeyId(mContext,masterKey.getKeyID());
  if (saveParcel.oldPassPhrase == null) {
    saveParcel.oldPassPhrase=""String_Node_Str"";
  }
  if (saveParcel.newPassPhrase == null) {
    saveParcel.newPassPhrase=""String_Node_Str"";
  }
  if (mKR == null) {
    buildNewSecretKey(saveParcel.userIDs,saveParcel.keys,saveParcel.keysExpiryDates,saveParcel.keysUsages,saveParcel.newPassPhrase,saveParcel.oldPassPhrase);
    return;
  }
  if (saveParcel.deletedKeys != null) {
    for (    PGPSecretKey dKey : saveParcel.deletedKeys) {
      mKR=PGPSecretKeyRing.removeSecretKey(mKR,dKey);
    }
  }
  masterKey=mKR.getSecretKey();
  PGPPublicKey masterPublicKey=masterKey.getPublicKey();
  int usageId=saveParcel.keysUsages.get(0);
  boolean canSign;
  String mainUserId=saveParcel.userIDs.get(0);
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(saveParcel.oldPassPhrase.toCharArray());
  PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(keyDecryptor);
  updateProgress(R.string.progress_certifying_master_key,20,100);
  for (  String delID : saveParcel.deletedIDs) {
    masterPublicKey=PGPPublicKey.removeCertification(masterPublicKey,delID);
  }
  int user_id_index=0;
  boolean anyIDChanged=false;
  PGPSignatureSubpacketGenerator hashedPacketsGen=new PGPSignatureSubpacketGenerator();
  PGPSignatureSubpacketGenerator unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
  hashedPacketsGen.setKeyFlags(true,usageId);
  hashedPacketsGen.setPreferredSymmetricAlgorithms(true,PREFERRED_SYMMETRIC_ALGORITHMS);
  hashedPacketsGen.setPreferredHashAlgorithms(true,PREFERRED_HASH_ALGORITHMS);
  hashedPacketsGen.setPreferredCompressionAlgorithms(true,PREFERRED_COMPRESSION_ALGORITHMS);
  if (saveParcel.keysExpiryDates.get(0) != null) {
    GregorianCalendar creationDate=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
    creationDate.setTime(masterPublicKey.getCreationTime());
    GregorianCalendar expiryDate=saveParcel.keysExpiryDates.get(0);
    long numDays=(expiryDate.getTimeInMillis() / 86400000) - (creationDate.getTimeInMillis() / 86400000);
    if (numDays <= 0)     throw new PgpGeneralException(mContext.getString(R.string.error_expiry_must_come_after_creation));
    hashedPacketsGen.setKeyExpirationTime(false,numDays * 86400);
  }
 else {
    hashedPacketsGen.setKeyExpirationTime(false,0);
  }
  if (saveParcel.primaryIDChanged) {
    anyIDChanged=true;
    ArrayList<Pair<String,PGPSignature>> sigList=new ArrayList<Pair<String,PGPSignature>>();
    for (    String userId : saveParcel.userIDs) {
      String orig_id=saveParcel.originalIDs.get(user_id_index);
      if (orig_id.equals(userId)) {
        Iterator<PGPSignature> orig_sigs=masterPublicKey.getSignaturesForID(orig_id);
        while (orig_sigs.hasNext()) {
          PGPSignature orig_sig=orig_sigs.next();
          sigList.add(new Pair<String,PGPSignature>(orig_id,orig_sig));
        }
      }
 else {
        PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
        PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
        sGen.init(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
        if (user_id_index == 0) {
          sGen.setHashedSubpackets(hashedPacketsGen.generate());
          sGen.setUnhashedSubpackets(unhashedPacketsGen.generate());
        }
        PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
        sigList.add(new Pair<String,PGPSignature>(userId,certification));
      }
      if (!orig_id.equals(""String_Node_Str"")) {
        masterPublicKey=PGPPublicKey.removeCertification(masterPublicKey,orig_id);
      }
      user_id_index++;
    }
    for (    Pair<String,PGPSignature> to_add : sigList) {
      masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,to_add.first,to_add.second);
    }
  }
 else {
    for (    String userId : saveParcel.userIDs) {
      String orig_id=saveParcel.originalIDs.get(user_id_index);
      if (!orig_id.equals(userId)) {
        anyIDChanged=true;
        PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
        PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
        sGen.init(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
        if (user_id_index == 0) {
          sGen.setHashedSubpackets(hashedPacketsGen.generate());
          sGen.setUnhashedSubpackets(unhashedPacketsGen.generate());
        }
        PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
        if (!orig_id.equals(""String_Node_Str"")) {
          masterPublicKey=PGPPublicKey.removeCertification(masterPublicKey,orig_id);
        }
        masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,userId,certification);
      }
      user_id_index++;
    }
  }
  if (anyIDChanged) {
    pKR=PGPPublicKeyRing.insertPublicKey(pKR,masterPublicKey);
    mKR=PGPSecretKeyRing.replacePublicKeys(mKR,pKR);
  }
  PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
  updateProgress(R.string.progress_building_master_key,30,100);
  PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
  PGPContentSignerBuilder certificationSignerBuilder=new JcaPGPContentSignerBuilder(masterKeyPair.getPublicKey().getAlgorithm(),HashAlgorithmTags.SHA1);
  PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(saveParcel.oldPassPhrase.toCharArray());
  PGPKeyRingGenerator keyGen=new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION,masterKeyPair,mainUserId,sha1Calc,hashedPacketsGen.generate(),unhashedPacketsGen.generate(),certificationSignerBuilder,keyEncryptor);
  for (int i=1; i < saveParcel.keys.size(); ++i) {
    updateProgress(40 + 50 * i / saveParcel.keys.size(),100);
    if (saveParcel.moddedKeys[i]) {
      PGPSecretKey subKey=saveParcel.keys.get(i);
      PGPPublicKey subPublicKey=subKey.getPublicKey();
      PBESecretKeyDecryptor keyDecryptor2;
      if (saveParcel.newKeys[i]) {
        keyDecryptor2=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(""String_Node_Str"".toCharArray());
      }
 else {
        keyDecryptor2=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(saveParcel.oldPassPhrase.toCharArray());
      }
      PGPPrivateKey subPrivateKey=subKey.extractPrivateKey(keyDecryptor2);
      PGPKeyPair subKeyPair=new PGPKeyPair(subPublicKey,subPrivateKey);
      hashedPacketsGen=new PGPSignatureSubpacketGenerator();
      unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
      usageId=saveParcel.keysUsages.get(i);
      canSign=(usageId & KeyFlags.SIGN_DATA) > 0;
      if (canSign) {
        Date todayDate=new Date();
        hashedPacketsGen.setSignatureCreationTime(false,todayDate);
        PGPSignatureSubpacketGenerator subHashedPacketsGen=new PGPSignatureSubpacketGenerator();
        subHashedPacketsGen.setSignatureCreationTime(false,todayDate);
        PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(subPublicKey.getAlgorithm(),PGPUtil.SHA1).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
        PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
        sGen.init(PGPSignature.PRIMARYKEY_BINDING,subPrivateKey);
        sGen.setHashedSubpackets(subHashedPacketsGen.generate());
        PGPSignature certification=sGen.generateCertification(masterPublicKey,subPublicKey);
        unhashedPacketsGen.setEmbeddedSignature(false,certification);
      }
      hashedPacketsGen.setKeyFlags(false,usageId);
      if (saveParcel.keysExpiryDates.get(i) != null) {
        GregorianCalendar creationDate=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
        creationDate.setTime(subPublicKey.getCreationTime());
        GregorianCalendar expiryDate=saveParcel.keysExpiryDates.get(i);
        long numDays=(expiryDate.getTimeInMillis() / 86400000) - (creationDate.getTimeInMillis() / 86400000);
        if (numDays <= 0)         throw new PgpGeneralException(mContext.getString(R.string.error_expiry_must_come_after_creation));
        hashedPacketsGen.setKeyExpirationTime(false,numDays * 86400);
      }
 else {
        hashedPacketsGen.setKeyExpirationTime(false,0);
      }
      keyGen.addSubKey(subKeyPair,hashedPacketsGen.generate(),unhashedPacketsGen.generate());
    }
  }
  PGPSecretKeyRing updatedSecretKeyRing=keyGen.generateSecretKeyRing();
  Iterator<PGPSecretKey> itr=updatedSecretKeyRing.getSecretKeys();
  while (itr.hasNext()) {
    PGPSecretKey theNextKey=itr.next();
    if ((theNextKey.isMasterKey() && saveParcel.moddedKeys[0]) || !theNextKey.isMasterKey()) {
      mKR=PGPSecretKeyRing.insertSecretKey(mKR,theNextKey);
      pKR=PGPPublicKeyRing.insertPublicKey(pKR,theNextKey.getPublicKey());
    }
  }
  PBESecretKeyEncryptor keyEncryptorNew=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(saveParcel.newPassPhrase.toCharArray());
  mKR=PGPSecretKeyRing.copyWithNewPassword(mKR,keyDecryptor,keyEncryptorNew);
  updateProgress(R.string.progress_saving_key_ring,90,100);
  ProviderHelper.saveKeyRing(mContext,mKR);
  ProviderHelper.saveKeyRing(mContext,pKR);
  updateProgress(R.string.progress_done,100,100);
}",0.8526444512381535
8375,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder){
  Log.v(Constants.TAG,""String_Node_Str"" + uri + ""String_Node_Str""+ Arrays.toString(projection)+ ""String_Node_Str"");
  SQLiteQueryBuilder qb=new SQLiteQueryBuilder();
  SQLiteDatabase db=mApgDatabase.getReadableDatabase();
  int match=mUriMatcher.match(uri);
  String groupBy=null, having=null;
  boolean all=false;
switch (match) {
case UNIFIED_KEY_RING:
    qb=buildKeyRingQuery(qb,match);
  groupBy=Tables.KEY_RINGS + ""String_Node_Str"" + KeyRingsColumns.MASTER_KEY_ID;
if (TextUtils.isEmpty(sortOrder)) {
  sortOrder=KeyRings.TYPE + ""String_Node_Str"" + Tables.USER_IDS+ ""String_Node_Str""+ UserIdsColumns.USER_ID+ ""String_Node_Str"";
}
break;
case PUBLIC_KEY_RING:
case SECRET_KEY_RING:
qb=buildKeyRingQuery(qb,match);
if (TextUtils.isEmpty(sortOrder)) {
sortOrder=Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.USER_ID+ ""String_Node_Str"";
}
break;
case PUBLIC_KEY_RING_BY_ROW_ID:
case SECRET_KEY_RING_BY_ROW_ID:
qb=buildKeyRingQuery(qb,match);
qb.appendWhere(""String_Node_Str"" + Tables.KEY_RINGS + ""String_Node_Str""+ BaseColumns._ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
if (TextUtils.isEmpty(sortOrder)) {
sortOrder=Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.USER_ID+ ""String_Node_Str"";
}
break;
case PUBLIC_KEY_RING_BY_MASTER_KEY_ID:
case SECRET_KEY_RING_BY_MASTER_KEY_ID:
qb=buildKeyRingQuery(qb,match);
qb.appendWhere(""String_Node_Str"" + Tables.KEY_RINGS + ""String_Node_Str""+ KeyRingsColumns.MASTER_KEY_ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
if (TextUtils.isEmpty(sortOrder)) {
sortOrder=Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.USER_ID+ ""String_Node_Str"";
}
break;
case SECRET_KEY_RING_BY_KEY_ID:
case PUBLIC_KEY_RING_BY_KEY_ID:
qb=buildKeyRingQueryWithSpecificKey(qb,match);
qb.appendWhere(""String_Node_Str"" + Tables.KEYS + ""String_Node_Str""+ KeysColumns.KEY_ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
if (TextUtils.isEmpty(sortOrder)) {
sortOrder=Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.USER_ID+ ""String_Node_Str"";
}
break;
case SECRET_KEY_RING_BY_EMAILS:
case PUBLIC_KEY_RING_BY_EMAILS:
qb=buildKeyRingQuery(qb,match);
String emails=uri.getLastPathSegment();
String chunks[]=emails.split(""String_Node_Str"");
boolean gotCondition=false;
String emailWhere=""String_Node_Str"";
for (int i=0; i < chunks.length; ++i) {
if (chunks[i].length() == 0) {
continue;
}
if (i != 0) {
emailWhere+=""String_Node_Str"";
}
emailWhere+=""String_Node_Str"" + UserIdsColumns.USER_ID + ""String_Node_Str"";
emailWhere+=DatabaseUtils.sqlEscapeString(""String_Node_Str"" + chunks[i] + ""String_Node_Str"");
gotCondition=true;
}
if (gotCondition) {
qb.appendWhere(""String_Node_Str"" + BaseColumns._ID + ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIdsColumns.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.KEY_RINGS+ ""String_Node_Str""+ BaseColumns._ID+ ""String_Node_Str""+ emailWhere+ ""String_Node_Str"");
}
break;
case SECRET_KEY_RING_BY_LIKE_EMAIL:
case PUBLIC_KEY_RING_BY_LIKE_EMAIL:
qb=buildKeyRingQuery(qb,match);
String likeEmail=uri.getLastPathSegment();
String likeEmailWhere=""String_Node_Str"" + UserIdsColumns.USER_ID + ""String_Node_Str""+ DatabaseUtils.sqlEscapeString(""String_Node_Str"" + likeEmail + ""String_Node_Str"");
qb.appendWhere(""String_Node_Str"" + BaseColumns._ID + ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIdsColumns.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.KEY_RINGS+ ""String_Node_Str""+ BaseColumns._ID+ ""String_Node_Str""+ likeEmailWhere+ ""String_Node_Str"");
break;
case PUBLIC_KEY_RING_KEY:
case SECRET_KEY_RING_KEY:
qb.setTables(Tables.KEYS);
qb.appendWhere(KeysColumns.TYPE + ""String_Node_Str"");
qb.appendWhereEscapeString(Integer.toString(getKeyType(match)));
qb.appendWhere(""String_Node_Str"" + KeysColumns.KEY_RING_ROW_ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
qb.setProjectionMap(getProjectionMapForKeys());
break;
case PUBLIC_KEY_RING_KEY_BY_ROW_ID:
case SECRET_KEY_RING_KEY_BY_ROW_ID:
qb.setTables(Tables.KEYS);
qb.appendWhere(KeysColumns.TYPE + ""String_Node_Str"");
qb.appendWhereEscapeString(Integer.toString(getKeyType(match)));
qb.appendWhere(""String_Node_Str"" + KeysColumns.KEY_RING_ROW_ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
qb.appendWhere(""String_Node_Str"" + BaseColumns._ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
qb.setProjectionMap(getProjectionMapForKeys());
break;
case PUBLIC_KEY_RING_BY_MASTER_KEY_ID_USER_ID:
qb.setTables(Tables.USER_IDS + ""String_Node_Str"" + Tables.KEY_RINGS+ ""String_Node_Str""+ ""String_Node_Str""+ Tables.KEY_RINGS+ ""String_Node_Str""+ BaseColumns._ID+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ KeysColumns.KEY_RING_ROW_ID+ ""String_Node_Str"");
qb.appendWhere(Tables.KEY_RINGS + ""String_Node_Str"" + KeyRingsColumns.MASTER_KEY_ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(3));
qb.setProjectionMap(getProjectionMapForUserIds());
break;
case PUBLIC_KEY_RING_USER_ID:
case SECRET_KEY_RING_USER_ID:
qb.setTables(Tables.USER_IDS + ""String_Node_Str"" + Tables.CERTS+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIds.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIds.RANK+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.RANK+ ""String_Node_Str"");
groupBy=Tables.USER_IDS + ""String_Node_Str"" + UserIds.RANK;
HashMap<String,String> pmap=new HashMap<String,String>();
pmap.put(UserIds._ID,Tables.USER_IDS + ""String_Node_Str"" + UserIds._ID);
pmap.put(UserIds.USER_ID,Tables.USER_IDS + ""String_Node_Str"" + UserIds.USER_ID);
pmap.put(UserIds.RANK,Tables.USER_IDS + ""String_Node_Str"" + UserIds.RANK);
pmap.put(""String_Node_Str"",""String_Node_Str"" + Tables.CERTS + ""String_Node_Str""+ Certs._ID+ ""String_Node_Str"");
qb.setProjectionMap(pmap);
qb.appendWhere(Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.KEY_RING_ROW_ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
break;
case PUBLIC_KEY_RING_USER_ID_BY_ROW_ID:
case SECRET_KEY_RING_USER_ID_BY_ROW_ID:
qb.setTables(Tables.USER_IDS);
qb.appendWhere(UserIdsColumns.KEY_RING_ROW_ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
qb.appendWhere(""String_Node_Str"" + BaseColumns._ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
break;
case CERTS_BY_ROW_ID:
case CERTS_BY_KEY_ROW_ID_ALL:
all=true;
case CERTS_BY_KEY_ROW_ID:
qb.setTables(Tables.CERTS + ""String_Node_Str"" + Tables.USER_IDS+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIds.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.RANK+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIds.RANK+ ""String_Node_Str""+ (all ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.KEY_ID_CERTIFIER+ ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Keys.KEY_ID+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Keys.KEY_RING_ROW_ID+ ""String_Node_Str""+ ""String_Node_Str""+ UserIds.KEY_RING_ROW_ID+ ""String_Node_Str""+ ""String_Node_Str""+ Keys.RANK+ ""String_Node_Str""+ ""String_Node_Str"");
HashMap<String,String> pmap2=new HashMap<String,String>();
pmap2.put(Certs._ID,Tables.CERTS + ""String_Node_Str"" + Certs._ID);
pmap2.put(Certs.KEY_ID,Tables.CERTS + ""String_Node_Str"" + Certs.KEY_ID);
pmap2.put(Certs.RANK,Tables.CERTS + ""String_Node_Str"" + Certs.RANK);
pmap2.put(Certs.CREATION,Tables.CERTS + ""String_Node_Str"" + Certs.CREATION);
pmap2.put(Certs.KEY_ID_CERTIFIER,Tables.CERTS + ""String_Node_Str"" + Certs.KEY_ID_CERTIFIER);
pmap2.put(Certs.KEY_DATA,Tables.CERTS + ""String_Node_Str"" + Certs.KEY_DATA);
pmap2.put(Certs.VERIFIED,Tables.CERTS + ""String_Node_Str"" + Certs.VERIFIED);
pmap2.put(UserIds.USER_ID,Tables.USER_IDS + ""String_Node_Str"" + UserIds.USER_ID);
pmap2.put(""String_Node_Str"",""String_Node_Str"" + UserIds.USER_ID + ""String_Node_Str"");
qb.setProjectionMap(pmap2);
if (match == CERTS_BY_ROW_ID) {
qb.appendWhere(Tables.CERTS + ""String_Node_Str"" + Certs._ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(1));
}
 else {
qb.appendWhere(Tables.CERTS + ""String_Node_Str"" + Certs.KEY_RING_ROW_ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
}
break;
case API_APPS:
qb.setTables(Tables.API_APPS);
break;
case API_APPS_BY_ROW_ID:
qb.setTables(Tables.API_APPS);
qb.appendWhere(BaseColumns._ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
break;
case API_APPS_BY_PACKAGE_NAME:
qb.setTables(Tables.API_APPS);
qb.appendWhere(ApiApps.PACKAGE_NAME + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + uri);
}
String orderBy;
if (TextUtils.isEmpty(sortOrder)) {
orderBy=null;
}
 else {
orderBy=sortOrder;
}
Cursor c=qb.query(db,projection,selection,selectionArgs,groupBy,having,orderBy);
c.setNotificationUri(getContext().getContentResolver(),uri);
if (Constants.DEBUG) {
Log.d(Constants.TAG,""String_Node_Str"" + qb.buildQuery(projection,selection,selectionArgs,null,null,orderBy,null));
Log.d(Constants.TAG,""String_Node_Str"" + DatabaseUtils.dumpCursorToString(c));
}
return c;
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder){
  Log.v(Constants.TAG,""String_Node_Str"" + uri + ""String_Node_Str""+ Arrays.toString(projection)+ ""String_Node_Str"");
  SQLiteQueryBuilder qb=new SQLiteQueryBuilder();
  SQLiteDatabase db=mApgDatabase.getReadableDatabase();
  int match=mUriMatcher.match(uri);
  String groupBy=null, having=null;
  boolean all=false;
switch (match) {
case UNIFIED_KEY_RING:
    qb=buildKeyRingQuery(qb,match);
  groupBy=Tables.KEY_RINGS + ""String_Node_Str"" + KeyRingsColumns.MASTER_KEY_ID;
if (TextUtils.isEmpty(sortOrder)) {
  sortOrder=KeyRings.TYPE + ""String_Node_Str"" + Tables.USER_IDS+ ""String_Node_Str""+ UserIdsColumns.USER_ID+ ""String_Node_Str"";
}
break;
case PUBLIC_KEY_RING:
case SECRET_KEY_RING:
qb=buildKeyRingQuery(qb,match);
if (TextUtils.isEmpty(sortOrder)) {
sortOrder=Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.USER_ID+ ""String_Node_Str"";
}
break;
case PUBLIC_KEY_RING_BY_ROW_ID:
case SECRET_KEY_RING_BY_ROW_ID:
qb=buildKeyRingQuery(qb,match);
qb.appendWhere(""String_Node_Str"" + Tables.KEY_RINGS + ""String_Node_Str""+ BaseColumns._ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
if (TextUtils.isEmpty(sortOrder)) {
sortOrder=Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.USER_ID+ ""String_Node_Str"";
}
break;
case PUBLIC_KEY_RING_BY_MASTER_KEY_ID:
case SECRET_KEY_RING_BY_MASTER_KEY_ID:
qb=buildKeyRingQuery(qb,match);
qb.appendWhere(""String_Node_Str"" + Tables.KEY_RINGS + ""String_Node_Str""+ KeyRingsColumns.MASTER_KEY_ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
if (TextUtils.isEmpty(sortOrder)) {
sortOrder=Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.USER_ID+ ""String_Node_Str"";
}
break;
case SECRET_KEY_RING_BY_KEY_ID:
case PUBLIC_KEY_RING_BY_KEY_ID:
qb=buildKeyRingQueryWithSpecificKey(qb,match);
qb.appendWhere(""String_Node_Str"" + Tables.KEYS + ""String_Node_Str""+ KeysColumns.KEY_ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
if (TextUtils.isEmpty(sortOrder)) {
sortOrder=Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.USER_ID+ ""String_Node_Str"";
}
break;
case SECRET_KEY_RING_BY_EMAILS:
case PUBLIC_KEY_RING_BY_EMAILS:
qb=buildKeyRingQuery(qb,match);
String emails=uri.getLastPathSegment();
String chunks[]=emails.split(""String_Node_Str"");
boolean gotCondition=false;
String emailWhere=""String_Node_Str"";
for (int i=0; i < chunks.length; ++i) {
if (chunks[i].length() == 0) {
continue;
}
if (i != 0) {
emailWhere+=""String_Node_Str"";
}
emailWhere+=""String_Node_Str"" + UserIdsColumns.USER_ID + ""String_Node_Str"";
emailWhere+=DatabaseUtils.sqlEscapeString(""String_Node_Str"" + chunks[i] + ""String_Node_Str"");
gotCondition=true;
}
if (gotCondition) {
qb.appendWhere(""String_Node_Str"" + BaseColumns._ID + ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIdsColumns.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.KEY_RINGS+ ""String_Node_Str""+ BaseColumns._ID+ ""String_Node_Str""+ emailWhere+ ""String_Node_Str"");
}
break;
case SECRET_KEY_RING_BY_LIKE_EMAIL:
case PUBLIC_KEY_RING_BY_LIKE_EMAIL:
qb=buildKeyRingQuery(qb,match);
String likeEmail=uri.getLastPathSegment();
String likeEmailWhere=""String_Node_Str"" + UserIdsColumns.USER_ID + ""String_Node_Str""+ DatabaseUtils.sqlEscapeString(""String_Node_Str"" + likeEmail + ""String_Node_Str"");
qb.appendWhere(""String_Node_Str"" + BaseColumns._ID + ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIdsColumns.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.KEY_RINGS+ ""String_Node_Str""+ BaseColumns._ID+ ""String_Node_Str""+ likeEmailWhere+ ""String_Node_Str"");
break;
case PUBLIC_KEY_RING_KEY:
case SECRET_KEY_RING_KEY:
qb.setTables(Tables.KEYS);
qb.appendWhere(KeysColumns.TYPE + ""String_Node_Str"");
qb.appendWhereEscapeString(Integer.toString(getKeyType(match)));
qb.appendWhere(""String_Node_Str"" + KeysColumns.KEY_RING_ROW_ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
qb.setProjectionMap(getProjectionMapForKeys());
break;
case PUBLIC_KEY_RING_KEY_BY_ROW_ID:
case SECRET_KEY_RING_KEY_BY_ROW_ID:
qb.setTables(Tables.KEYS);
qb.appendWhere(KeysColumns.TYPE + ""String_Node_Str"");
qb.appendWhereEscapeString(Integer.toString(getKeyType(match)));
qb.appendWhere(""String_Node_Str"" + KeysColumns.KEY_RING_ROW_ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
qb.appendWhere(""String_Node_Str"" + BaseColumns._ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
qb.setProjectionMap(getProjectionMapForKeys());
break;
case PUBLIC_KEY_RING_BY_MASTER_KEY_ID_USER_ID:
case PUBLIC_KEY_RING_USER_ID:
case SECRET_KEY_RING_USER_ID:
qb.setTables(Tables.USER_IDS + ""String_Node_Str"" + Tables.KEY_RINGS+ ""String_Node_Str""+ Tables.KEY_RINGS+ ""String_Node_Str""+ BaseColumns._ID+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ KeysColumns.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIds.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIds.RANK+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.RANK+ ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Keys.KEY_ID+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.KEY_ID_CERTIFIER+ ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Keys.TYPE+ ""String_Node_Str""+ KeyTypes.SECRET+ ""String_Node_Str"");
groupBy=Tables.USER_IDS + ""String_Node_Str"" + UserIds.RANK;
qb.setProjectionMap(getProjectionMapForUserIds());
if (match == PUBLIC_KEY_RING_BY_MASTER_KEY_ID_USER_ID) {
qb.appendWhere(Tables.KEY_RINGS + ""String_Node_Str"" + KeyRingsColumns.MASTER_KEY_ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(3));
}
 else {
qb.appendWhere(Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.KEY_RING_ROW_ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
}
break;
case PUBLIC_KEY_RING_USER_ID_BY_ROW_ID:
case SECRET_KEY_RING_USER_ID_BY_ROW_ID:
qb.setTables(Tables.USER_IDS);
qb.appendWhere(UserIdsColumns.KEY_RING_ROW_ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
qb.appendWhere(""String_Node_Str"" + BaseColumns._ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
break;
case CERTS_BY_ROW_ID:
case CERTS_BY_KEY_ROW_ID_ALL:
all=true;
case CERTS_BY_KEY_ROW_ID:
qb.setTables(Tables.CERTS + ""String_Node_Str"" + Tables.USER_IDS+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIds.KEY_RING_ROW_ID+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.RANK+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ UserIds.RANK+ ""String_Node_Str""+ (all ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.KEY_ID_CERTIFIER+ ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Keys.KEY_ID+ ""String_Node_Str""+ Tables.USER_IDS+ ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Keys.KEY_RING_ROW_ID+ ""String_Node_Str""+ ""String_Node_Str""+ UserIds.KEY_RING_ROW_ID+ ""String_Node_Str""+ ""String_Node_Str""+ Keys.RANK+ ""String_Node_Str""+ ""String_Node_Str"");
groupBy=Tables.CERTS + ""String_Node_Str"" + Certs.RANK+ ""String_Node_Str""+ Tables.CERTS+ ""String_Node_Str""+ Certs.KEY_ID_CERTIFIER;
HashMap<String,String> pmap2=new HashMap<String,String>();
pmap2.put(Certs._ID,Tables.CERTS + ""String_Node_Str"" + Certs._ID);
pmap2.put(Certs.KEY_ID,Tables.CERTS + ""String_Node_Str"" + Certs.KEY_ID);
pmap2.put(Certs.RANK,Tables.CERTS + ""String_Node_Str"" + Certs.RANK);
pmap2.put(Certs.CREATION,Tables.CERTS + ""String_Node_Str"" + Certs.CREATION);
pmap2.put(Certs.KEY_ID_CERTIFIER,Tables.CERTS + ""String_Node_Str"" + Certs.KEY_ID_CERTIFIER);
pmap2.put(Certs.KEY_DATA,Tables.CERTS + ""String_Node_Str"" + Certs.KEY_DATA);
pmap2.put(Certs.VERIFIED,Tables.CERTS + ""String_Node_Str"" + Certs.VERIFIED);
pmap2.put(UserIds.USER_ID,Tables.USER_IDS + ""String_Node_Str"" + UserIds.USER_ID);
pmap2.put(""String_Node_Str"",""String_Node_Str"" + UserIds.USER_ID + ""String_Node_Str"");
qb.setProjectionMap(pmap2);
if (match == CERTS_BY_ROW_ID) {
qb.appendWhere(Tables.CERTS + ""String_Node_Str"" + Certs._ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(1));
}
 else {
qb.appendWhere(Tables.CERTS + ""String_Node_Str"" + Certs.KEY_RING_ROW_ID+ ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
}
break;
case API_APPS:
qb.setTables(Tables.API_APPS);
break;
case API_APPS_BY_ROW_ID:
qb.setTables(Tables.API_APPS);
qb.appendWhere(BaseColumns._ID + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getLastPathSegment());
break;
case API_APPS_BY_PACKAGE_NAME:
qb.setTables(Tables.API_APPS);
qb.appendWhere(ApiApps.PACKAGE_NAME + ""String_Node_Str"");
qb.appendWhereEscapeString(uri.getPathSegments().get(2));
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + uri);
}
String orderBy;
if (TextUtils.isEmpty(sortOrder)) {
orderBy=null;
}
 else {
orderBy=sortOrder;
}
Cursor c=qb.query(db,projection,selection,selectionArgs,groupBy,having,orderBy);
c.setNotificationUri(getContext().getContentResolver(),uri);
if (Constants.DEBUG) {
Log.d(Constants.TAG,""String_Node_Str"" + qb.buildQuery(projection,selection,selectionArgs,null,null,orderBy,null));
Log.d(Constants.TAG,""String_Node_Str"" + DatabaseUtils.dumpCursorToString(c));
}
return c;
}",0.8878756476683938
8376,"private HashMap<String,String> getProjectionMapForUserIds(){
  HashMap<String,String> projectionMap=new HashMap<String,String>();
  projectionMap.put(BaseColumns._ID,Tables.USER_IDS + ""String_Node_Str"" + BaseColumns._ID);
  projectionMap.put(UserIdsColumns.USER_ID,Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.USER_ID);
  projectionMap.put(UserIdsColumns.RANK,Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.RANK);
  projectionMap.put(KeyRingsColumns.MASTER_KEY_ID,Tables.KEY_RINGS + ""String_Node_Str"" + KeyRingsColumns.MASTER_KEY_ID);
  return projectionMap;
}","private HashMap<String,String> getProjectionMapForUserIds(){
  HashMap<String,String> projectionMap=new HashMap<String,String>();
  projectionMap.put(BaseColumns._ID,Tables.USER_IDS + ""String_Node_Str"" + BaseColumns._ID);
  projectionMap.put(UserIdsColumns.USER_ID,Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.USER_ID);
  projectionMap.put(UserIdsColumns.RANK,Tables.USER_IDS + ""String_Node_Str"" + UserIdsColumns.RANK);
  projectionMap.put(KeyRingsColumns.MASTER_KEY_ID,Tables.KEY_RINGS + ""String_Node_Str"" + KeyRingsColumns.MASTER_KEY_ID);
  projectionMap.put(""String_Node_Str"",""String_Node_Str"" + Tables.KEYS + ""String_Node_Str""+ Keys._ID+ ""String_Node_Str"");
  return projectionMap;
}",0.8731284475965327
8377,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ActionBar actionBar=getSupportActionBar();
  actionBar.setDisplayHomeAsUpEnabled(true);
  setContentView(R.layout.view_cert_activity);
  mSigneeKey=(TextView)findViewById(R.id.signee_key);
  mSigneeUid=(TextView)findViewById(R.id.signee_uid);
  mRank=(TextView)findViewById(R.id.subkey_rank);
  mAlgorithm=(TextView)findViewById(R.id.algorithm);
  mType=(TextView)findViewById(R.id.signature_type);
  mCreation=(TextView)findViewById(R.id.creation);
  mExpiry=(TextView)findViewById(R.id.expiry);
  mSignerKey=(TextView)findViewById(R.id.signer_key_id);
  mSignerUid=(TextView)findViewById(R.id.signer_uid);
  mDataUri=getIntent().getData();
  if (mDataUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
  getSupportLoaderManager().initLoader(0,null,this);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ActionBar actionBar=getSupportActionBar();
  actionBar.setDisplayHomeAsUpEnabled(true);
  setContentView(R.layout.view_cert_activity);
  mSigneeKey=(TextView)findViewById(R.id.signee_key);
  mSigneeUid=(TextView)findViewById(R.id.signee_uid);
  mAlgorithm=(TextView)findViewById(R.id.algorithm);
  mType=(TextView)findViewById(R.id.signature_type);
  mCreation=(TextView)findViewById(R.id.creation);
  mExpiry=(TextView)findViewById(R.id.expiry);
  mSignerKey=(TextView)findViewById(R.id.signer_key_id);
  mSignerUid=(TextView)findViewById(R.id.signer_uid);
  mDataUri=getIntent().getData();
  if (mDataUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
  getSupportLoaderManager().initLoader(0,null,this);
}",0.9713631156930126
8378,"@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
  if (data.moveToFirst()) {
    String signeeKey=""String_Node_Str"" + PgpKeyHelper.convertKeyIdToHex(data.getLong(1));
    mSigneeKey.setText(signeeKey);
    String signeeUid=data.getString(2);
    mSigneeUid.setText(signeeUid);
    String subkey_rank=Integer.toString(data.getInt(3));
    mRank.setText(subkey_rank);
    Date creationDate=new Date(data.getLong(4) * 1000);
    mCreation.setText(DateFormat.getDateFormat(getApplicationContext()).format(creationDate));
    mSignerKeyId=data.getLong(5);
    String signerKey=""String_Node_Str"" + PgpKeyHelper.convertKeyIdToHex(mSignerKeyId);
    mSignerKey.setText(signerKey);
    String signerUid=data.getString(6);
    if (signerUid != null)     mSignerUid.setText(signerUid);
 else     mSignerUid.setText(R.string.unknown_uid);
    byte[] sigData=data.getBlob(7);
    PGPSignature sig=PgpConversionHelper.BytesToPGPSignature(sigData);
    if (sig != null) {
      String algorithmStr=PgpKeyHelper.getAlgorithmInfo(sig.getKeyAlgorithm(),0);
      mAlgorithm.setText(algorithmStr);
switch (sig.getSignatureType()) {
case PGPSignature.DEFAULT_CERTIFICATION:
        mType.setText(R.string.sig_type_default);
      break;
case PGPSignature.NO_CERTIFICATION:
    mType.setText(R.string.sig_type_none);
  break;
case PGPSignature.CASUAL_CERTIFICATION:
mType.setText(R.string.sig_type_casual);
break;
case PGPSignature.POSITIVE_CERTIFICATION:
mType.setText(R.string.sig_type_positive);
break;
}
long expiry=sig.getHashedSubPackets().getSignatureExpirationTime();
if (expiry == 0) mExpiry.setText(""String_Node_Str"");
 else {
Date expiryDate=new Date(creationDate.getTime() + expiry * 1000);
mExpiry.setText(DateFormat.getDateFormat(getApplicationContext()).format(expiryDate));
}
}
}
}","@Override public void onLoadFinished(Loader<Cursor> loader,Cursor data){
  if (data.moveToFirst()) {
    String signeeKey=""String_Node_Str"" + PgpKeyHelper.convertKeyIdToHex(data.getLong(INDEX_KEY_ID));
    mSigneeKey.setText(signeeKey);
    String signeeUid=data.getString(INDEX_USER_ID);
    mSigneeUid.setText(signeeUid);
    Date creationDate=new Date(data.getLong(INDEX_CREATION) * 1000);
    mCreation.setText(DateFormat.getDateFormat(getApplicationContext()).format(creationDate));
    mSignerKeyId=data.getLong(INDEX_KEY_ID_CERTIFIER);
    String signerKey=""String_Node_Str"" + PgpKeyHelper.convertKeyIdToHex(mSignerKeyId);
    mSignerKey.setText(signerKey);
    String signerUid=data.getString(INDEX_UID_CERTIFIER);
    if (signerUid != null)     mSignerUid.setText(signerUid);
 else     mSignerUid.setText(R.string.unknown_uid);
    byte[] sigData=data.getBlob(INDEX_KEY_DATA);
    PGPSignature sig=PgpConversionHelper.BytesToPGPSignature(sigData);
    if (sig != null) {
      String algorithmStr=PgpKeyHelper.getAlgorithmInfo(sig.getKeyAlgorithm(),0);
      mAlgorithm.setText(algorithmStr);
switch (sig.getSignatureType()) {
case PGPSignature.DEFAULT_CERTIFICATION:
        mType.setText(R.string.sig_type_default);
      break;
case PGPSignature.NO_CERTIFICATION:
    mType.setText(R.string.sig_type_none);
  break;
case PGPSignature.CASUAL_CERTIFICATION:
mType.setText(R.string.sig_type_casual);
break;
case PGPSignature.POSITIVE_CERTIFICATION:
mType.setText(R.string.sig_type_positive);
break;
}
long expiry=sig.getHashedSubPackets().getSignatureExpirationTime();
if (expiry == 0) mExpiry.setText(""String_Node_Str"");
 else {
Date expiryDate=new Date(creationDate.getTime() + expiry * 1000);
mExpiry.setText(DateFormat.getDateFormat(getApplicationContext()).format(expiryDate));
}
}
}
}",0.8930258405112531
8379,"public View getView(int position,View convertView,ViewGroup parent){
  ImportKeysListEntry entry=mData.get(position);
  ViewHolder holder;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=mInflater.inflate(R.layout.import_keys_list_entry,null);
    holder.mMainUserId=(TextView)convertView.findViewById(R.id.mainUserId);
    holder.mMainUserIdRest=(TextView)convertView.findViewById(R.id.mainUserIdRest);
    holder.mKeyId=(TextView)convertView.findViewById(R.id.keyId);
    holder.mFingerprint=(TextView)convertView.findViewById(R.id.fingerprint);
    holder.mAlgorithm=(TextView)convertView.findViewById(R.id.algorithm);
    holder.mStatus=(TextView)convertView.findViewById(R.id.status);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  String userId=entry.userIds.get(0);
  String[] userIdSplit=PgpKeyHelper.splitUserId(userId);
  if (userIdSplit[0] != null) {
    if (entry.secretKey) {
      userIdSplit[0]=mActivity.getString(R.string.secret_key) + ""String_Node_Str"" + userIdSplit[0];
      holder.mMainUserId.setTextColor(Color.RED);
    }
    holder.mMainUserId.setText(userIdSplit[0]);
  }
 else {
    holder.mMainUserId.setText(R.string.user_id_no_name);
  }
  if (userIdSplit[1] != null) {
    holder.mMainUserIdRest.setText(userIdSplit[1]);
    holder.mMainUserIdRest.setVisibility(View.VISIBLE);
  }
 else {
    holder.mMainUserIdRest.setVisibility(View.GONE);
  }
  holder.mKeyId.setText(entry.hexKeyId);
  if (entry.fingerPrint != null) {
    holder.mFingerprint.setText(mActivity.getString(R.string.fingerprint) + ""String_Node_Str"" + entry.fingerPrint);
    holder.mFingerprint.setVisibility(View.VISIBLE);
  }
 else {
    holder.mFingerprint.setVisibility(View.GONE);
  }
  holder.mAlgorithm.setText(""String_Node_Str"" + entry.bitStrength + ""String_Node_Str""+ entry.algorithm);
  if (entry.revoked) {
    holder.mStatus.setText(R.string.revoked);
  }
 else {
    holder.mStatus.setVisibility(View.GONE);
  }
  LinearLayout ll=(LinearLayout)convertView.findViewById(R.id.list);
  if (entry.userIds.size() == 1) {
    ll.setVisibility(View.GONE);
  }
 else {
    boolean first=true;
    boolean second=true;
    for (    String uid : entry.userIds) {
      if (first) {
        first=false;
        continue;
      }
      if (!second) {
        View sep=new View(mActivity);
        sep.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,1));
        sep.setBackgroundResource(android.R.drawable.divider_horizontal_dark);
        ll.addView(sep);
      }
      TextView uidView=(TextView)mInflater.inflate(R.layout.import_keys_list_entry_user_id,null);
      uidView.setText(uid);
      ll.addView(uidView);
      second=false;
    }
  }
  CheckBox cBox=(CheckBox)convertView.findViewById(R.id.selected);
  cBox.setChecked(entry.isSelected());
  return convertView;
}","public View getView(int position,View convertView,ViewGroup parent){
  ImportKeysListEntry entry=mData.get(position);
  ViewHolder holder;
  if (convertView == null) {
    holder=new ViewHolder();
    convertView=mInflater.inflate(R.layout.import_keys_list_entry,null);
    holder.mMainUserId=(TextView)convertView.findViewById(R.id.mainUserId);
    holder.mMainUserIdRest=(TextView)convertView.findViewById(R.id.mainUserIdRest);
    holder.mKeyId=(TextView)convertView.findViewById(R.id.keyId);
    holder.mFingerprint=(TextView)convertView.findViewById(R.id.fingerprint);
    holder.mAlgorithm=(TextView)convertView.findViewById(R.id.algorithm);
    holder.mStatus=(TextView)convertView.findViewById(R.id.status);
    convertView.setTag(holder);
  }
 else {
    holder=(ViewHolder)convertView.getTag();
  }
  String userId=entry.userIds.get(0);
  String[] userIdSplit=PgpKeyHelper.splitUserId(userId);
  if (userIdSplit[0] != null) {
    if (entry.secretKey) {
      userIdSplit[0]=mActivity.getString(R.string.secret_key) + ""String_Node_Str"" + userIdSplit[0];
      holder.mMainUserId.setTextColor(Color.RED);
    }
    holder.mMainUserId.setText(userIdSplit[0]);
  }
 else {
    holder.mMainUserId.setText(R.string.user_id_no_name);
  }
  if (userIdSplit[1] != null) {
    holder.mMainUserIdRest.setText(userIdSplit[1]);
    holder.mMainUserIdRest.setVisibility(View.VISIBLE);
  }
 else {
    holder.mMainUserIdRest.setVisibility(View.GONE);
  }
  holder.mKeyId.setText(entry.hexKeyId);
  if (entry.fingerPrint != null) {
    holder.mFingerprint.setText(mActivity.getString(R.string.fingerprint) + ""String_Node_Str"" + entry.fingerPrint);
    holder.mFingerprint.setVisibility(View.VISIBLE);
  }
 else {
    holder.mFingerprint.setVisibility(View.GONE);
  }
  holder.mAlgorithm.setText(""String_Node_Str"" + entry.bitStrength + ""String_Node_Str""+ entry.algorithm);
  if (entry.revoked) {
    holder.mStatus.setText(R.string.revoked);
  }
 else {
    holder.mStatus.setVisibility(View.GONE);
  }
  LinearLayout ll=(LinearLayout)convertView.findViewById(R.id.list);
  ll.removeAllViews();
  if (entry.userIds.size() == 1) {
    ll.setVisibility(View.GONE);
  }
 else {
    boolean first=true;
    boolean second=true;
    for (    String uid : entry.userIds) {
      if (first) {
        first=false;
        continue;
      }
      if (!second) {
        View sep=new View(mActivity);
        sep.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT,1));
        sep.setBackgroundResource(android.R.drawable.divider_horizontal_dark);
        ll.addView(sep);
      }
      TextView uidView=(TextView)mInflater.inflate(R.layout.import_keys_list_entry_user_id,null);
      uidView.setText(uid);
      ll.addView(uidView);
      second=false;
    }
  }
  CheckBox cBox=(CheckBox)convertView.findViewById(R.id.selected);
  cBox.setChecked(entry.isSelected());
  return convertView;
}",0.995997911954063
8380,"/** 
 * Query keyserver
 */
private void queryServer(String query,String keyServer){
  HkpKeyServer server=new HkpKeyServer(keyServer);
  try {
    ArrayList<ImportKeysListEntry> searchResult=server.search(query);
    mEntryList.addAll(searchResult);
    mEntryListWrapper=new AsyncTaskResultWrapper<ArrayList<ImportKeysListEntry>>(mEntryList,null);
  }
 catch (  KeyServer.InsufficientQuery e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    mEntryListWrapper=new AsyncTaskResultWrapper<ArrayList<ImportKeysListEntry>>(mEntryList,e);
  }
catch (  KeyServer.QueryException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    mEntryListWrapper=new AsyncTaskResultWrapper<ArrayList<ImportKeysListEntry>>(mEntryList,e);
  }
catch (  KeyServer.TooManyResponses e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    mEntryListWrapper=new AsyncTaskResultWrapper<ArrayList<ImportKeysListEntry>>(mEntryList,e);
  }
}","/** 
 * Query keyserver
 */
private void queryServer(String query,String keyServer){
  HkpKeyServer server=new HkpKeyServer(keyServer);
  try {
    ArrayList<ImportKeysListEntry> searchResult=server.search(query);
    mEntryList.clear();
    mEntryList.addAll(searchResult);
    mEntryListWrapper=new AsyncTaskResultWrapper<ArrayList<ImportKeysListEntry>>(mEntryList,null);
  }
 catch (  KeyServer.InsufficientQuery e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    mEntryListWrapper=new AsyncTaskResultWrapper<ArrayList<ImportKeysListEntry>>(mEntryList,e);
  }
catch (  KeyServer.QueryException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    mEntryListWrapper=new AsyncTaskResultWrapper<ArrayList<ImportKeysListEntry>>(mEntryList,e);
  }
catch (  KeyServer.TooManyResponses e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
    mEntryListWrapper=new AsyncTaskResultWrapper<ArrayList<ImportKeysListEntry>>(mEntryList,e);
  }
}",0.9870689655172412
8381,"/** 
 * Export keys
 */
public void exportKeys(Uri dataUri,int keyType){
  Log.d(Constants.TAG,""String_Node_Str"");
  Intent intent=new Intent(activity,KeychainIntentService.class);
  intent.setAction(KeychainIntentService.ACTION_EXPORT_KEYRING);
  Bundle data=new Bundle();
  data.putString(KeychainIntentService.EXPORT_FILENAME,mExportFilename);
  data.putInt(KeychainIntentService.EXPORT_KEY_TYPE,keyType);
  if (dataUri == null) {
    data.putBoolean(KeychainIntentService.EXPORT_ALL,true);
  }
 else {
    long keyRingMasterKeyId=ProviderHelper.getMasterKeyId(activity,dataUri);
    data.putLong(KeychainIntentService.EXPORT_KEY_RING_MASTER_KEY_ID,keyRingMasterKeyId);
  }
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler exportHandler=new KeychainIntentServiceHandler(activity,R.string.progress_exporting,ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Bundle returnData=message.getData();
        int exported=returnData.getInt(KeychainIntentService.RESULT_EXPORT);
        String toastMessage;
        if (exported == 1) {
          toastMessage=activity.getString(R.string.key_exported);
        }
 else         if (exported > 0) {
          toastMessage=activity.getString(R.string.keys_exported,exported);
        }
 else {
          toastMessage=activity.getString(R.string.no_keys_exported);
        }
        Toast.makeText(activity,toastMessage,Toast.LENGTH_SHORT).show();
      }
    }
  }
;
  Messenger messenger=new Messenger(exportHandler);
  intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
  exportHandler.showProgressDialog(activity);
  activity.startService(intent);
}","/** 
 * Export keys
 */
public void exportKeys(Uri dataUri,int keyType){
  Log.d(Constants.TAG,""String_Node_Str"");
  Intent intent=new Intent(activity,KeychainIntentService.class);
  intent.setAction(KeychainIntentService.ACTION_EXPORT_KEYRING);
  Bundle data=new Bundle();
  data.putString(KeychainIntentService.EXPORT_FILENAME,mExportFilename);
  data.putInt(KeychainIntentService.EXPORT_KEY_TYPE,keyType);
  if (dataUri == null) {
    data.putBoolean(KeychainIntentService.EXPORT_ALL,true);
  }
 else {
    long keyRingMasterKeyId=ProviderHelper.getMasterKeyId(activity,dataUri);
    data.putLong(KeychainIntentService.EXPORT_KEY_RING_MASTER_KEY_ID,keyRingMasterKeyId);
  }
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler exportHandler=new KeychainIntentServiceHandler(activity,activity.getString(R.string.progress_exporting),ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Bundle returnData=message.getData();
        int exported=returnData.getInt(KeychainIntentService.RESULT_EXPORT);
        String toastMessage;
        if (exported == 1) {
          toastMessage=activity.getString(R.string.key_exported);
        }
 else         if (exported > 0) {
          toastMessage=activity.getString(R.string.keys_exported,exported);
        }
 else {
          toastMessage=activity.getString(R.string.no_keys_exported);
        }
        Toast.makeText(activity,toastMessage,Toast.LENGTH_SHORT).show();
      }
    }
  }
;
  Messenger messenger=new Messenger(exportHandler);
  intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
  exportHandler.showProgressDialog(activity);
  activity.startService(intent);
}",0.994475138121547
8382,"public KeychainIntentServiceHandler(Activity activity,int progressDialogMessageId,int progressDialogStyle,boolean cancelable,OnCancelListener onCancelListener){
  this.mActivity=activity;
  this.mProgressDialogFragment=ProgressDialogFragment.newInstance(progressDialogMessageId,progressDialogStyle,cancelable,onCancelListener);
}","public KeychainIntentServiceHandler(Activity activity,String progressDialogMessage,int progressDialogStyle,boolean cancelable,OnCancelListener onCancelListener){
  this.mActivity=activity;
  this.mProgressDialogFragment=ProgressDialogFragment.newInstance(progressDialogMessage,progressDialogStyle,cancelable,onCancelListener);
}",0.9802130898021308
8383,"private void uploadKey(){
  Intent intent=new Intent(this,KeychainIntentService.class);
  intent.setAction(KeychainIntentService.ACTION_UPLOAD_KEYRING);
  intent.setData(mDataUri);
  Bundle data=new Bundle();
  Spinner keyServer=(Spinner)findViewById(R.id.sign_key_keyserver);
  String server=(String)keyServer.getSelectedItem();
  data.putString(KeychainIntentService.UPLOAD_KEY_SERVER,server);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,R.string.progress_exporting,ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Toast.makeText(CertifyKeyActivity.this,R.string.key_send_success,Toast.LENGTH_SHORT).show();
        setResult(RESULT_OK);
        finish();
      }
    }
  }
;
  Messenger messenger=new Messenger(saveHandler);
  intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
  saveHandler.showProgressDialog(this);
  startService(intent);
}","private void uploadKey(){
  Intent intent=new Intent(this,KeychainIntentService.class);
  intent.setAction(KeychainIntentService.ACTION_UPLOAD_KEYRING);
  intent.setData(mDataUri);
  Bundle data=new Bundle();
  Spinner keyServer=(Spinner)findViewById(R.id.sign_key_keyserver);
  String server=(String)keyServer.getSelectedItem();
  data.putString(KeychainIntentService.UPLOAD_KEY_SERVER,server);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,getString(R.string.progress_exporting),ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Toast.makeText(CertifyKeyActivity.this,R.string.key_send_success,Toast.LENGTH_SHORT).show();
        setResult(RESULT_OK);
        finish();
      }
    }
  }
;
  Messenger messenger=new Messenger(saveHandler);
  intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
  saveHandler.showProgressDialog(this);
  startService(intent);
}",0.9950606196677144
8384,"/** 
 * kicks off the actual signing process on a background thread
 */
private void startSigning(){
  Intent intent=new Intent(this,KeychainIntentService.class);
  intent.setAction(KeychainIntentService.ACTION_CERTIFY_KEYRING);
  Bundle data=new Bundle();
  data.putLong(KeychainIntentService.CERTIFY_KEY_MASTER_KEY_ID,mMasterKeyId);
  data.putLong(KeychainIntentService.CERTIFY_KEY_PUB_KEY_ID,mPubKeyId);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,R.string.progress_signing,ProgressDialog.STYLE_SPINNER){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Toast.makeText(CertifyKeyActivity.this,R.string.key_sign_success,Toast.LENGTH_SHORT).show();
        if (mUploadKeyCheckbox.isChecked()) {
          uploadKey();
        }
 else {
          setResult(RESULT_OK);
          finish();
        }
      }
    }
  }
;
  Messenger messenger=new Messenger(saveHandler);
  intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
  saveHandler.showProgressDialog(this);
  startService(intent);
}","/** 
 * kicks off the actual signing process on a background thread
 */
private void startSigning(){
  Intent intent=new Intent(this,KeychainIntentService.class);
  intent.setAction(KeychainIntentService.ACTION_CERTIFY_KEYRING);
  Bundle data=new Bundle();
  data.putLong(KeychainIntentService.CERTIFY_KEY_MASTER_KEY_ID,mMasterKeyId);
  data.putLong(KeychainIntentService.CERTIFY_KEY_PUB_KEY_ID,mPubKeyId);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,getString(R.string.progress_signing),ProgressDialog.STYLE_SPINNER){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Toast.makeText(CertifyKeyActivity.this,R.string.key_sign_success,Toast.LENGTH_SHORT).show();
        if (mUploadKeyCheckbox.isChecked()) {
          uploadKey();
        }
 else {
          setResult(RESULT_OK);
          finish();
        }
      }
    }
  }
;
  Messenger messenger=new Messenger(saveHandler);
  intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
  saveHandler.showProgressDialog(this);
  startService(intent);
}",0.995493650143384
8385,"private void decryptStart(){
  Log.d(Constants.TAG,""String_Node_Str"");
  Intent intent=new Intent(this,KeychainIntentService.class);
  Bundle data=new Bundle();
  intent.setAction(KeychainIntentService.ACTION_DECRYPT_VERIFY);
  if (mContentUri != null) {
    data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_STREAM);
    data.putParcelable(KeychainIntentService.ENCRYPT_PROVIDER_URI,mContentUri);
  }
 else   if (mDecryptTarget == Id.target.file) {
    data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_URI);
    Log.d(Constants.TAG,""String_Node_Str"" + mInputFilename + ""String_Node_Str""+ mOutputFilename);
    data.putString(KeychainIntentService.ENCRYPT_INPUT_FILE,mInputFilename);
    data.putString(KeychainIntentService.ENCRYPT_OUTPUT_FILE,mOutputFilename);
  }
 else {
    data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_BYTES);
    String message=mMessage.getText().toString();
    data.putByteArray(KeychainIntentService.DECRYPT_CIPHERTEXT_BYTES,message.getBytes());
  }
  data.putLong(KeychainIntentService.ENCRYPT_SECRET_KEY_ID,mSecretKeyId);
  data.putBoolean(KeychainIntentService.DECRYPT_RETURN_BYTES,mReturnBinary);
  data.putBoolean(KeychainIntentService.DECRYPT_ASSUME_SYMMETRIC,mAssumeSymmetricEncryption);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,R.string.progress_decrypting,ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Bundle returnData=message.getData();
        mSignatureKeyId=0;
        mSignatureLayout.setVisibility(View.GONE);
        AppMsg.makeText(DecryptActivity.this,R.string.decryption_successful,AppMsg.STYLE_INFO).show();
        if (mReturnResult) {
          Intent intent=new Intent();
          intent.putExtras(returnData);
          setResult(RESULT_OK,intent);
          finish();
          return;
        }
switch (mDecryptTarget) {
case Id.target.message:
          String decryptedMessage=returnData.getString(KeychainIntentService.RESULT_DECRYPTED_STRING);
        mMessage.setText(decryptedMessage);
      mMessage.setHorizontallyScrolling(false);
    break;
case Id.target.file:
  if (mDeleteAfter.isChecked()) {
    DeleteFileDialogFragment deleteFileDialog=DeleteFileDialogFragment.newInstance(mInputFilename);
    deleteFileDialog.show(getSupportFragmentManager(),""String_Node_Str"");
  }
break;
default :
break;
}
PgpDecryptVerifyResult decryptVerifyResult=returnData.getParcelable(KeychainIntentService.RESULT_DECRYPT_VERIFY_RESULT);
OpenPgpSignatureResult signatureResult=decryptVerifyResult.getSignatureResult();
if (signatureResult != null) {
String userId=signatureResult.getUserId();
mSignatureKeyId=signatureResult.getKeyId();
mUserIdRest.setText(""String_Node_Str"" + PgpKeyHelper.convertKeyIdToHex(mSignatureKeyId));
if (userId == null) {
userId=getResources().getString(R.string.user_id_no_name);
}
String chunks[]=userId.split(""String_Node_Str"",2);
userId=chunks[0];
if (chunks.length > 1) {
mUserIdRest.setText(""String_Node_Str"" + chunks[1]);
}
mUserId.setText(userId);
switch (signatureResult.getStatus()) {
case OpenPgpSignatureResult.SIGNATURE_SUCCESS_UNCERTIFIED:
{
mSignatureStatusImage.setImageResource(R.drawable.overlay_ok);
mLookupKey.setVisibility(View.GONE);
break;
}
case OpenPgpSignatureResult.SIGNATURE_UNKNOWN_PUB_KEY:
{
mSignatureStatusImage.setImageResource(R.drawable.overlay_error);
mLookupKey.setVisibility(View.VISIBLE);
AppMsg.makeText(DecryptActivity.this,R.string.unknown_signature,AppMsg.STYLE_ALERT).show();
break;
}
default :
{
mSignatureStatusImage.setImageResource(R.drawable.overlay_error);
mLookupKey.setVisibility(View.GONE);
break;
}
}
mSignatureLayout.setVisibility(View.VISIBLE);
}
}
}
}
;
Messenger messenger=new Messenger(saveHandler);
intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
saveHandler.showProgressDialog(this);
startService(intent);
}","private void decryptStart(){
  Log.d(Constants.TAG,""String_Node_Str"");
  Intent intent=new Intent(this,KeychainIntentService.class);
  Bundle data=new Bundle();
  intent.setAction(KeychainIntentService.ACTION_DECRYPT_VERIFY);
  if (mContentUri != null) {
    data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_STREAM);
    data.putParcelable(KeychainIntentService.ENCRYPT_PROVIDER_URI,mContentUri);
  }
 else   if (mDecryptTarget == Id.target.file) {
    data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_URI);
    Log.d(Constants.TAG,""String_Node_Str"" + mInputFilename + ""String_Node_Str""+ mOutputFilename);
    data.putString(KeychainIntentService.ENCRYPT_INPUT_FILE,mInputFilename);
    data.putString(KeychainIntentService.ENCRYPT_OUTPUT_FILE,mOutputFilename);
  }
 else {
    data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_BYTES);
    String message=mMessage.getText().toString();
    data.putByteArray(KeychainIntentService.DECRYPT_CIPHERTEXT_BYTES,message.getBytes());
  }
  data.putLong(KeychainIntentService.ENCRYPT_SECRET_KEY_ID,mSecretKeyId);
  data.putBoolean(KeychainIntentService.DECRYPT_RETURN_BYTES,mReturnBinary);
  data.putBoolean(KeychainIntentService.DECRYPT_ASSUME_SYMMETRIC,mAssumeSymmetricEncryption);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,getString(R.string.progress_decrypting),ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Bundle returnData=message.getData();
        mSignatureKeyId=0;
        mSignatureLayout.setVisibility(View.GONE);
        AppMsg.makeText(DecryptActivity.this,R.string.decryption_successful,AppMsg.STYLE_INFO).show();
        if (mReturnResult) {
          Intent intent=new Intent();
          intent.putExtras(returnData);
          setResult(RESULT_OK,intent);
          finish();
          return;
        }
switch (mDecryptTarget) {
case Id.target.message:
          String decryptedMessage=returnData.getString(KeychainIntentService.RESULT_DECRYPTED_STRING);
        mMessage.setText(decryptedMessage);
      mMessage.setHorizontallyScrolling(false);
    break;
case Id.target.file:
  if (mDeleteAfter.isChecked()) {
    DeleteFileDialogFragment deleteFileDialog=DeleteFileDialogFragment.newInstance(mInputFilename);
    deleteFileDialog.show(getSupportFragmentManager(),""String_Node_Str"");
  }
break;
default :
break;
}
PgpDecryptVerifyResult decryptVerifyResult=returnData.getParcelable(KeychainIntentService.RESULT_DECRYPT_VERIFY_RESULT);
OpenPgpSignatureResult signatureResult=decryptVerifyResult.getSignatureResult();
if (signatureResult != null) {
String userId=signatureResult.getUserId();
mSignatureKeyId=signatureResult.getKeyId();
mUserIdRest.setText(""String_Node_Str"" + PgpKeyHelper.convertKeyIdToHex(mSignatureKeyId));
if (userId == null) {
userId=getResources().getString(R.string.user_id_no_name);
}
String chunks[]=userId.split(""String_Node_Str"",2);
userId=chunks[0];
if (chunks.length > 1) {
mUserIdRest.setText(""String_Node_Str"" + chunks[1]);
}
mUserId.setText(userId);
switch (signatureResult.getStatus()) {
case OpenPgpSignatureResult.SIGNATURE_SUCCESS_UNCERTIFIED:
{
mSignatureStatusImage.setImageResource(R.drawable.overlay_ok);
mLookupKey.setVisibility(View.GONE);
break;
}
case OpenPgpSignatureResult.SIGNATURE_UNKNOWN_PUB_KEY:
{
mSignatureStatusImage.setImageResource(R.drawable.overlay_error);
mLookupKey.setVisibility(View.VISIBLE);
AppMsg.makeText(DecryptActivity.this,R.string.unknown_signature,AppMsg.STYLE_ALERT).show();
break;
}
default :
{
mSignatureStatusImage.setImageResource(R.drawable.overlay_error);
mLookupKey.setVisibility(View.GONE);
break;
}
}
mSignatureLayout.setVisibility(View.VISIBLE);
}
}
}
}
;
Messenger messenger=new Messenger(saveHandler);
intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
saveHandler.showProgressDialog(this);
startService(intent);
}",0.9917982617211408
8386,"/** 
 * Handle intent action to edit existing key
 * @param intent
 */
private void handleActionEditKey(Intent intent){
  ActionBarHelper.setDoneView(getSupportActionBar(),R.string.btn_save,new View.OnClickListener(){
    @Override public void onClick(    View v){
      saveClicked();
    }
  }
);
  mDataUri=intent.getData();
  if (mDataUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
 else {
    Log.d(Constants.TAG,""String_Node_Str"" + mDataUri);
    long keyRingRowId=Long.valueOf(mDataUri.getLastPathSegment());
    long masterKeyId=ProviderHelper.getSecretMasterKeyId(this,keyRingRowId);
    masterCanSign=ProviderHelper.getSecretMasterKeyCanSign(this,keyRingRowId);
    finallyEdit(masterKeyId,masterCanSign);
  }
}","/** 
 * Handle intent action to edit existing key
 * @param intent
 */
private void handleActionEditKey(Intent intent){
  ActionBarHelper.setSaveView(getSupportActionBar(),R.string.btn_save,new View.OnClickListener(){
    @Override public void onClick(    View v){
      saveClicked();
    }
  }
);
  mDataUri=intent.getData();
  if (mDataUri == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    finish();
    return;
  }
 else {
    Log.d(Constants.TAG,""String_Node_Str"" + mDataUri);
    long keyRingRowId=Long.valueOf(mDataUri.getLastPathSegment());
    long masterKeyId=ProviderHelper.getSecretMasterKeyId(this,keyRingRowId);
    masterCanSign=ProviderHelper.getSecretMasterKeyCanSign(this,keyRingRowId);
    finallyEdit(masterKeyId,masterCanSign);
  }
}",0.9960681520314548
8387,"/** 
 * Handle intent action to create new key
 * @param intent
 */
private void handleActionCreateKey(Intent intent){
  ActionBarHelper.setDoneCancelView(getSupportActionBar(),R.string.btn_save,new View.OnClickListener(){
    @Override public void onClick(    View v){
      saveClicked();
    }
  }
,R.string.btn_do_not_save,new View.OnClickListener(){
    @Override public void onClick(    View v){
      cancelClicked();
    }
  }
);
  Bundle extras=intent.getExtras();
  mCurrentPassphrase=""String_Node_Str"";
  if (extras != null) {
    if (extras.containsKey(EXTRA_USER_IDS)) {
      Log.d(Constants.TAG,""String_Node_Str"");
      mUserIds.add(extras.getString(EXTRA_USER_IDS));
    }
    if (extras.containsKey(EXTRA_NO_PASSPHRASE)) {
      boolean noPassphrase=extras.getBoolean(EXTRA_NO_PASSPHRASE);
      if (noPassphrase) {
        mNoPassphrase.setChecked(true);
        mChangePassphrase.setVisibility(View.GONE);
      }
    }
    if (extras.containsKey(EXTRA_GENERATE_DEFAULT_KEYS)) {
      boolean generateDefaultKeys=extras.getBoolean(EXTRA_GENERATE_DEFAULT_KEYS);
      if (generateDefaultKeys) {
        final Intent serviceIntent=new Intent(this,KeychainIntentService.class);
        serviceIntent.setAction(KeychainIntentService.ACTION_GENERATE_DEFAULT_RSA_KEYS);
        Bundle data=new Bundle();
        data.putString(KeychainIntentService.GENERATE_KEY_SYMMETRIC_PASSPHRASE,mCurrentPassphrase);
        serviceIntent.putExtra(KeychainIntentService.EXTRA_DATA,data);
        KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,R.string.progress_generating,ProgressDialog.STYLE_HORIZONTAL,true,new DialogInterface.OnCancelListener(){
          @Override public void onCancel(          DialogInterface dialog){
            stopService(serviceIntent);
            EditKeyActivity.this.setResult(Activity.RESULT_CANCELED);
            EditKeyActivity.this.finish();
          }
        }
){
          @Override public void handleMessage(          Message message){
            super.handleMessage(message);
            if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
              Bundle data=message.getData();
              PGPSecretKey masterKey=(PGPSecretKey)PgpConversionHelper.BytesToPGPSecretKey(data.getByteArray(KeychainIntentService.RESULT_NEW_KEY));
              PGPSecretKey subKey=(PGPSecretKey)PgpConversionHelper.BytesToPGPSecretKey(data.getByteArray(KeychainIntentService.RESULT_NEW_KEY2));
              mKeys.add(masterKey);
              mKeysUsages.add(Id.choice.usage.sign_only);
              mKeys.add(subKey);
              mKeysUsages.add(Id.choice.usage.encrypt_only);
              buildLayout();
            }
          }
        }
;
        Messenger messenger=new Messenger(saveHandler);
        serviceIntent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
        saveHandler.showProgressDialog(this);
        startService(serviceIntent);
      }
    }
  }
 else {
    buildLayout();
  }
}","/** 
 * Handle intent action to create new key
 * @param intent
 */
private void handleActionCreateKey(Intent intent){
  ActionBarHelper.setDoneCancelView(getSupportActionBar(),R.string.btn_save,new View.OnClickListener(){
    @Override public void onClick(    View v){
      saveClicked();
    }
  }
,R.string.btn_do_not_save,new View.OnClickListener(){
    @Override public void onClick(    View v){
      cancelClicked();
    }
  }
);
  Bundle extras=intent.getExtras();
  mCurrentPassphrase=""String_Node_Str"";
  if (extras != null) {
    if (extras.containsKey(EXTRA_USER_IDS)) {
      Log.d(Constants.TAG,""String_Node_Str"");
      mUserIds.add(extras.getString(EXTRA_USER_IDS));
    }
    if (extras.containsKey(EXTRA_NO_PASSPHRASE)) {
      boolean noPassphrase=extras.getBoolean(EXTRA_NO_PASSPHRASE);
      if (noPassphrase) {
        mNoPassphrase.setChecked(true);
        mChangePassphrase.setVisibility(View.GONE);
      }
    }
    if (extras.containsKey(EXTRA_GENERATE_DEFAULT_KEYS)) {
      boolean generateDefaultKeys=extras.getBoolean(EXTRA_GENERATE_DEFAULT_KEYS);
      if (generateDefaultKeys) {
        final Intent serviceIntent=new Intent(this,KeychainIntentService.class);
        serviceIntent.setAction(KeychainIntentService.ACTION_GENERATE_DEFAULT_RSA_KEYS);
        Bundle data=new Bundle();
        data.putString(KeychainIntentService.GENERATE_KEY_SYMMETRIC_PASSPHRASE,mCurrentPassphrase);
        serviceIntent.putExtra(KeychainIntentService.EXTRA_DATA,data);
        KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,getResources().getQuantityString(R.plurals.progress_generating,1),ProgressDialog.STYLE_HORIZONTAL,true,new DialogInterface.OnCancelListener(){
          @Override public void onCancel(          DialogInterface dialog){
            stopService(serviceIntent);
            EditKeyActivity.this.setResult(Activity.RESULT_CANCELED);
            EditKeyActivity.this.finish();
          }
        }
){
          @Override public void handleMessage(          Message message){
            super.handleMessage(message);
            if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
              Bundle data=message.getData();
              PGPSecretKey masterKey=(PGPSecretKey)PgpConversionHelper.BytesToPGPSecretKey(data.getByteArray(KeychainIntentService.RESULT_NEW_KEY));
              PGPSecretKey subKey=(PGPSecretKey)PgpConversionHelper.BytesToPGPSecretKey(data.getByteArray(KeychainIntentService.RESULT_NEW_KEY2));
              mKeys.add(masterKey);
              mKeysUsages.add(Id.choice.usage.sign_only);
              mKeys.add(subKey);
              mKeysUsages.add(Id.choice.usage.encrypt_only);
              buildLayout();
            }
          }
        }
;
        Messenger messenger=new Messenger(saveHandler);
        serviceIntent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
        saveHandler.showProgressDialog(this);
        startService(serviceIntent);
      }
    }
  }
 else {
    buildLayout();
  }
}",0.9855649576903932
8388,"private void finallySaveClicked(){
  try {
    Intent intent=new Intent(this,KeychainIntentService.class);
    intent.setAction(KeychainIntentService.ACTION_SAVE_KEYRING);
    Bundle data=new Bundle();
    data.putString(KeychainIntentService.SAVE_KEYRING_CURRENT_PASSPHRASE,mCurrentPassphrase);
    data.putString(KeychainIntentService.SAVE_KEYRING_NEW_PASSPHRASE,mNewPassPhrase);
    data.putStringArrayList(KeychainIntentService.SAVE_KEYRING_USER_IDS,getUserIds(mUserIdsView));
    ArrayList<PGPSecretKey> keys=getKeys(mKeysView);
    data.putByteArray(KeychainIntentService.SAVE_KEYRING_KEYS,PgpConversionHelper.PGPSecretKeyArrayListToBytes(keys));
    data.putIntegerArrayList(KeychainIntentService.SAVE_KEYRING_KEYS_USAGES,getKeysUsages(mKeysView));
    data.putSerializable(KeychainIntentService.SAVE_KEYRING_KEYS_EXPIRY_DATES,getKeysExpiryDates(mKeysView));
    data.putLong(KeychainIntentService.SAVE_KEYRING_MASTER_KEY_ID,getMasterKeyId());
    data.putBoolean(KeychainIntentService.SAVE_KEYRING_CAN_SIGN,masterCanSign);
    intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
    KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,R.string.progress_saving,ProgressDialog.STYLE_HORIZONTAL){
      public void handleMessage(      Message message){
        super.handleMessage(message);
        if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
          Intent data=new Intent();
          data.putExtra(RESULT_EXTRA_MASTER_KEY_ID,getMasterKeyId());
          ArrayList<String> userIds=null;
          try {
            userIds=getUserIds(mUserIdsView);
          }
 catch (          PgpGeneralException e) {
            Log.e(Constants.TAG,""String_Node_Str"",e);
          }
          data.putExtra(RESULT_EXTRA_USER_ID,userIds.get(0));
          setResult(RESULT_OK,data);
          finish();
        }
      }
    }
;
    Messenger messenger=new Messenger(saveHandler);
    intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
    saveHandler.showProgressDialog(this);
    startService(intent);
  }
 catch (  PgpGeneralException e) {
  }
}","private void finallySaveClicked(){
  try {
    Intent intent=new Intent(this,KeychainIntentService.class);
    intent.setAction(KeychainIntentService.ACTION_SAVE_KEYRING);
    Bundle data=new Bundle();
    data.putString(KeychainIntentService.SAVE_KEYRING_CURRENT_PASSPHRASE,mCurrentPassphrase);
    data.putString(KeychainIntentService.SAVE_KEYRING_NEW_PASSPHRASE,mNewPassPhrase);
    data.putStringArrayList(KeychainIntentService.SAVE_KEYRING_USER_IDS,getUserIds(mUserIdsView));
    ArrayList<PGPSecretKey> keys=getKeys(mKeysView);
    data.putByteArray(KeychainIntentService.SAVE_KEYRING_KEYS,PgpConversionHelper.PGPSecretKeyArrayListToBytes(keys));
    data.putIntegerArrayList(KeychainIntentService.SAVE_KEYRING_KEYS_USAGES,getKeysUsages(mKeysView));
    data.putSerializable(KeychainIntentService.SAVE_KEYRING_KEYS_EXPIRY_DATES,getKeysExpiryDates(mKeysView));
    data.putLong(KeychainIntentService.SAVE_KEYRING_MASTER_KEY_ID,getMasterKeyId());
    data.putBoolean(KeychainIntentService.SAVE_KEYRING_CAN_SIGN,masterCanSign);
    intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
    KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,getString(R.string.progress_saving),ProgressDialog.STYLE_HORIZONTAL){
      public void handleMessage(      Message message){
        super.handleMessage(message);
        if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
          Intent data=new Intent();
          data.putExtra(RESULT_EXTRA_MASTER_KEY_ID,getMasterKeyId());
          ArrayList<String> userIds=null;
          try {
            userIds=getUserIds(mUserIdsView);
          }
 catch (          PgpGeneralException e) {
            Log.e(Constants.TAG,""String_Node_Str"",e);
          }
          data.putExtra(RESULT_EXTRA_USER_ID,userIds.get(0));
          setResult(RESULT_OK,data);
          finish();
        }
      }
    }
;
    Messenger messenger=new Messenger(saveHandler);
    intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
    saveHandler.showProgressDialog(this);
    startService(intent);
  }
 catch (  PgpGeneralException e) {
  }
}",0.9974001418104468
8389,"private void encryptStart(){
  Intent intent=new Intent(this,KeychainIntentService.class);
  Bundle data=new Bundle();
  boolean useAsciiArmor=true;
  long encryptionKeyIds[]=null;
  int compressionId=0;
  boolean signOnly=false;
  long mSecretKeyIdToPass=0;
  if (mMode.getCurrentView().getId() == R.id.modeSymmetric) {
    Log.d(Constants.TAG,""String_Node_Str"");
    String passphrase=mPassphrase.getText().toString();
    if (passphrase.length() == 0) {
      passphrase=null;
    }
    data.putString(KeychainIntentService.GENERATE_KEY_SYMMETRIC_PASSPHRASE,passphrase);
  }
 else {
    mSecretKeyIdToPass=mSecretKeyId;
    encryptionKeyIds=mEncryptionKeyIds;
    signOnly=(mEncryptionKeyIds == null || mEncryptionKeyIds.length == 0);
  }
  intent.setAction(KeychainIntentService.ACTION_ENCRYPT_SIGN);
  if (mEncryptTarget == Id.target.file) {
    useAsciiArmor=mAsciiArmor.isChecked();
    compressionId=((Choice)mFileCompression.getSelectedItem()).getId();
    data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_URI);
    Log.d(Constants.TAG,""String_Node_Str"" + mInputFilename + ""String_Node_Str""+ mOutputFilename);
    data.putString(KeychainIntentService.ENCRYPT_INPUT_FILE,mInputFilename);
    data.putString(KeychainIntentService.ENCRYPT_OUTPUT_FILE,mOutputFilename);
  }
 else {
    useAsciiArmor=true;
    compressionId=Preferences.getPreferences(this).getDefaultMessageCompression();
    data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_BYTES);
    String message=mMessage.getText().toString();
    if (signOnly) {
      fixBadCharactersForGmail(message);
    }
    data.putByteArray(KeychainIntentService.ENCRYPT_MESSAGE_BYTES,message.getBytes());
  }
  if (mOverrideAsciiArmor) {
    useAsciiArmor=mAsciiArmorDemand;
  }
  data.putLong(KeychainIntentService.ENCRYPT_SECRET_KEY_ID,mSecretKeyIdToPass);
  data.putBoolean(KeychainIntentService.ENCRYPT_USE_ASCII_ARMOR,useAsciiArmor);
  data.putLongArray(KeychainIntentService.ENCRYPT_ENCRYPTION_KEYS_IDS,encryptionKeyIds);
  data.putInt(KeychainIntentService.ENCRYPT_COMPRESSION_ID,compressionId);
  data.putBoolean(KeychainIntentService.ENCRYPT_GENERATE_SIGNATURE,mGenerateSignature);
  data.putBoolean(KeychainIntentService.ENCRYPT_SIGN_ONLY,signOnly);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,R.string.progress_encrypting,ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Bundle data=message.getData();
        String output;
switch (mEncryptTarget) {
case Id.target.clipboard:
          output=data.getString(KeychainIntentService.RESULT_ENCRYPTED_STRING);
        Log.d(Constants.TAG,""String_Node_Str"" + output);
      ClipboardReflection.copyToClipboard(EncryptActivity.this,output);
    AppMsg.makeText(EncryptActivity.this,R.string.encryption_to_clipboard_successful,AppMsg.STYLE_INFO).show();
  break;
case Id.target.email:
output=data.getString(KeychainIntentService.RESULT_ENCRYPTED_STRING);
Log.d(Constants.TAG,""String_Node_Str"" + output);
Intent sendIntent=new Intent(Intent.ACTION_SEND);
sendIntent.setType(""String_Node_Str"");
sendIntent.putExtra(Intent.EXTRA_TEXT,output);
startActivity(Intent.createChooser(sendIntent,getString(R.string.title_send_email)));
break;
case Id.target.file:
AppMsg.makeText(EncryptActivity.this,R.string.encryption_successful,AppMsg.STYLE_INFO).show();
if (mDeleteAfter.isChecked()) {
DeleteFileDialogFragment deleteFileDialog=DeleteFileDialogFragment.newInstance(mInputFilename);
deleteFileDialog.show(getSupportFragmentManager(),""String_Node_Str"");
}
if (mShareAfter.isChecked()) {
Intent sendFileIntent=new Intent(Intent.ACTION_SEND);
sendFileIntent.setType(""String_Node_Str"");
sendFileIntent.putExtra(Intent.EXTRA_STREAM,Uri.parse(mOutputFilename));
startActivity(Intent.createChooser(sendFileIntent,getString(R.string.title_send_file)));
}
break;
default :
break;
}
}
}
}
;
Messenger messenger=new Messenger(saveHandler);
intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
saveHandler.showProgressDialog(this);
startService(intent);
}","private void encryptStart(){
  Intent intent=new Intent(this,KeychainIntentService.class);
  Bundle data=new Bundle();
  boolean useAsciiArmor=true;
  long encryptionKeyIds[]=null;
  int compressionId=0;
  boolean signOnly=false;
  long mSecretKeyIdToPass=0;
  if (mMode.getCurrentView().getId() == R.id.modeSymmetric) {
    Log.d(Constants.TAG,""String_Node_Str"");
    String passphrase=mPassphrase.getText().toString();
    if (passphrase.length() == 0) {
      passphrase=null;
    }
    data.putString(KeychainIntentService.GENERATE_KEY_SYMMETRIC_PASSPHRASE,passphrase);
  }
 else {
    mSecretKeyIdToPass=mSecretKeyId;
    encryptionKeyIds=mEncryptionKeyIds;
    signOnly=(mEncryptionKeyIds == null || mEncryptionKeyIds.length == 0);
  }
  intent.setAction(KeychainIntentService.ACTION_ENCRYPT_SIGN);
  if (mEncryptTarget == Id.target.file) {
    useAsciiArmor=mAsciiArmor.isChecked();
    compressionId=((Choice)mFileCompression.getSelectedItem()).getId();
    data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_URI);
    Log.d(Constants.TAG,""String_Node_Str"" + mInputFilename + ""String_Node_Str""+ mOutputFilename);
    data.putString(KeychainIntentService.ENCRYPT_INPUT_FILE,mInputFilename);
    data.putString(KeychainIntentService.ENCRYPT_OUTPUT_FILE,mOutputFilename);
  }
 else {
    useAsciiArmor=true;
    compressionId=Preferences.getPreferences(this).getDefaultMessageCompression();
    data.putInt(KeychainIntentService.TARGET,KeychainIntentService.TARGET_BYTES);
    String message=mMessage.getText().toString();
    if (signOnly) {
      fixBadCharactersForGmail(message);
    }
    data.putByteArray(KeychainIntentService.ENCRYPT_MESSAGE_BYTES,message.getBytes());
  }
  if (mOverrideAsciiArmor) {
    useAsciiArmor=mAsciiArmorDemand;
  }
  data.putLong(KeychainIntentService.ENCRYPT_SECRET_KEY_ID,mSecretKeyIdToPass);
  data.putBoolean(KeychainIntentService.ENCRYPT_USE_ASCII_ARMOR,useAsciiArmor);
  data.putLongArray(KeychainIntentService.ENCRYPT_ENCRYPTION_KEYS_IDS,encryptionKeyIds);
  data.putInt(KeychainIntentService.ENCRYPT_COMPRESSION_ID,compressionId);
  data.putBoolean(KeychainIntentService.ENCRYPT_GENERATE_SIGNATURE,mGenerateSignature);
  data.putBoolean(KeychainIntentService.ENCRYPT_SIGN_ONLY,signOnly);
  intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,getString(R.string.progress_encrypting),ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Bundle data=message.getData();
        String output;
switch (mEncryptTarget) {
case Id.target.clipboard:
          output=data.getString(KeychainIntentService.RESULT_ENCRYPTED_STRING);
        Log.d(Constants.TAG,""String_Node_Str"" + output);
      ClipboardReflection.copyToClipboard(EncryptActivity.this,output);
    AppMsg.makeText(EncryptActivity.this,R.string.encryption_to_clipboard_successful,AppMsg.STYLE_INFO).show();
  break;
case Id.target.email:
output=data.getString(KeychainIntentService.RESULT_ENCRYPTED_STRING);
Log.d(Constants.TAG,""String_Node_Str"" + output);
Intent sendIntent=new Intent(Intent.ACTION_SEND);
sendIntent.setType(""String_Node_Str"");
sendIntent.putExtra(Intent.EXTRA_TEXT,output);
startActivity(Intent.createChooser(sendIntent,getString(R.string.title_send_email)));
break;
case Id.target.file:
AppMsg.makeText(EncryptActivity.this,R.string.encryption_successful,AppMsg.STYLE_INFO).show();
if (mDeleteAfter.isChecked()) {
DeleteFileDialogFragment deleteFileDialog=DeleteFileDialogFragment.newInstance(mInputFilename);
deleteFileDialog.show(getSupportFragmentManager(),""String_Node_Str"");
}
if (mShareAfter.isChecked()) {
Intent sendFileIntent=new Intent(Intent.ACTION_SEND);
sendFileIntent.setType(""String_Node_Str"");
sendFileIntent.putExtra(Intent.EXTRA_STREAM,Uri.parse(mOutputFilename));
startActivity(Intent.createChooser(sendFileIntent,getString(R.string.title_send_file)));
}
break;
default :
break;
}
}
}
}
;
Messenger messenger=new Messenger(saveHandler);
intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
saveHandler.showProgressDialog(this);
startService(intent);
}",0.992124133066886
8390,"/** 
 * Import keys with mImportData
 */
public void importKeys(){
  if (mListFragment.getKeyBytes() != null || mListFragment.getDataUri() != null) {
    Log.d(Constants.TAG,""String_Node_Str"");
    Intent intent=new Intent(this,KeychainIntentService.class);
    intent.setAction(KeychainIntentService.ACTION_IMPORT_KEYRING);
    Bundle data=new Bundle();
    ArrayList<ImportKeysListEntry> selectedEntries=mListFragment.getSelectedData();
    data.putParcelableArrayList(KeychainIntentService.IMPORT_KEY_LIST,selectedEntries);
    intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
    Messenger messenger=new Messenger(saveHandler);
    intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
    saveHandler.showProgressDialog(this);
    startService(intent);
  }
 else   if (mListFragment.getServerQuery() != null) {
    Intent intent=new Intent(this,KeychainIntentService.class);
    intent.setAction(KeychainIntentService.ACTION_DOWNLOAD_AND_IMPORT_KEYS);
    Bundle data=new Bundle();
    data.putString(KeychainIntentService.DOWNLOAD_KEY_SERVER,mListFragment.getKeyServer());
    ArrayList<ImportKeysListEntry> selectedEntries=mListFragment.getSelectedData();
    data.putParcelableArrayList(KeychainIntentService.DOWNLOAD_KEY_LIST,selectedEntries);
    intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
    Messenger messenger=new Messenger(saveHandler);
    intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
    saveHandler.showProgressDialog(this);
    startService(intent);
  }
 else {
    AppMsg.makeText(this,R.string.error_nothing_import,AppMsg.STYLE_ALERT).show();
  }
}","/** 
 * Import keys with mImportData
 */
public void importKeys(){
  KeychainIntentServiceHandler saveHandler=new KeychainIntentServiceHandler(this,getString(R.string.progress_importing),ProgressDialog.STYLE_HORIZONTAL){
    public void handleMessage(    Message message){
      super.handleMessage(message);
      if (message.arg1 == KeychainIntentServiceHandler.MESSAGE_OKAY) {
        Bundle returnData=message.getData();
        int added=returnData.getInt(KeychainIntentService.RESULT_IMPORT_ADDED);
        int updated=returnData.getInt(KeychainIntentService.RESULT_IMPORT_UPDATED);
        int bad=returnData.getInt(KeychainIntentService.RESULT_IMPORT_BAD);
        String toastMessage;
        if (added > 0 && updated > 0) {
          String addedStr=getResources().getQuantityString(R.plurals.keys_added_and_updated_1,added,added);
          String updatedStr=getResources().getQuantityString(R.plurals.keys_added_and_updated_2,updated,updated);
          toastMessage=addedStr + updatedStr;
        }
 else         if (added > 0) {
          toastMessage=getResources().getQuantityString(R.plurals.keys_added,added,added);
        }
 else         if (updated > 0) {
          toastMessage=getResources().getQuantityString(R.plurals.keys_updated,updated,updated);
        }
 else {
          toastMessage=getString(R.string.no_keys_added_or_updated);
        }
        AppMsg.makeText(ImportKeysActivity.this,toastMessage,AppMsg.STYLE_INFO).show();
        if (bad > 0) {
          BadImportKeyDialogFragment badImportKeyDialogFragment=BadImportKeyDialogFragment.newInstance(bad);
          badImportKeyDialogFragment.show(getSupportFragmentManager(),""String_Node_Str"");
        }
      }
    }
  }
;
  if (mListFragment.getKeyBytes() != null || mListFragment.getDataUri() != null) {
    Log.d(Constants.TAG,""String_Node_Str"");
    Intent intent=new Intent(this,KeychainIntentService.class);
    intent.setAction(KeychainIntentService.ACTION_IMPORT_KEYRING);
    Bundle data=new Bundle();
    ArrayList<ImportKeysListEntry> selectedEntries=mListFragment.getSelectedData();
    data.putParcelableArrayList(KeychainIntentService.IMPORT_KEY_LIST,selectedEntries);
    intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
    Messenger messenger=new Messenger(saveHandler);
    intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
    saveHandler.showProgressDialog(this);
    startService(intent);
  }
 else   if (mListFragment.getServerQuery() != null) {
    Intent intent=new Intent(this,KeychainIntentService.class);
    intent.setAction(KeychainIntentService.ACTION_DOWNLOAD_AND_IMPORT_KEYS);
    Bundle data=new Bundle();
    data.putString(KeychainIntentService.DOWNLOAD_KEY_SERVER,mListFragment.getKeyServer());
    ArrayList<ImportKeysListEntry> selectedEntries=mListFragment.getSelectedData();
    data.putParcelableArrayList(KeychainIntentService.DOWNLOAD_KEY_LIST,selectedEntries);
    intent.putExtra(KeychainIntentService.EXTRA_DATA,data);
    Messenger messenger=new Messenger(saveHandler);
    intent.putExtra(KeychainIntentService.EXTRA_MESSENGER,messenger);
    saveHandler.showProgressDialog(this);
    startService(intent);
  }
 else {
    AppMsg.makeText(this,R.string.error_nothing_import,AppMsg.STYLE_ALERT).show();
  }
}",0.6636661211129297
8391,"@Override public void onCreateOptionsMenu(final Menu menu,final MenuInflater inflater){
  MenuItem searchItem=menu.findItem(R.id.menu_key_list_public_search);
  mSearchView=(SearchView)MenuItemCompat.getActionView(searchItem);
  mSearchView.setOnQueryTextListener(this);
  super.onCreateOptionsMenu(menu,inflater);
}","@Override public void onCreateOptionsMenu(final Menu menu,final MenuInflater inflater){
  MenuItem searchItem=menu.findItem(R.id.menu_key_list_public_search);
  mSearchView=(SearchView)MenuItemCompat.getActionView(searchItem);
  mSearchView.setOnQueryTextListener(this);
  MenuItemCompat.setOnActionExpandListener(searchItem,new MenuItemCompat.OnActionExpandListener(){
    @Override public boolean onMenuItemActionExpand(    MenuItem item){
      return true;
    }
    @Override public boolean onMenuItemActionCollapse(    MenuItem item){
      mCurQuery=null;
      getLoaderManager().restartLoader(0,null,KeyListPublicFragment.this);
      return true;
    }
  }
);
  super.onCreateOptionsMenu(menu,inflater);
}",0.5586808923375364
8392,"public void selectKey(long secretKeyId){
  if (secretKeyId == Id.key.none) {
    mKeyUserId.setText(R.string.api_settings_no_key);
    mKeyUserIdRest.setText(""String_Node_Str"");
  }
 else {
    String uid=getResources().getString(R.string.user_id_no_name);
    String uidExtra=""String_Node_Str"";
    PGPSecretKeyRing keyRing=ProviderHelper.getPGPSecretKeyRingByMasterKeyId(getActivity(),secretKeyId);
    if (keyRing != null) {
      PGPSecretKey key=PgpKeyHelper.getMasterKey(keyRing);
      if (key != null) {
        String userId=PgpKeyHelper.getMainUserIdSafe(getActivity(),key);
        String chunks[]=userId.split(""String_Node_Str"",2);
        uid=chunks[0];
        if (chunks.length > 1) {
          uidExtra=""String_Node_Str"" + chunks[1];
        }
      }
    }
    mKeyUserId.setText(uid);
    mKeyUserIdRest.setText(uidExtra);
  }
}","public void selectKey(long secretKeyId){
  if (secretKeyId == Id.key.none) {
    mKeyMasterKeyIdHex.setText(R.string.api_settings_no_key);
    mKeyUserIdRest.setText(""String_Node_Str"");
    mKeyUserId.setVisibility(View.GONE);
    mKeyUserIdRest.setVisibility(View.GONE);
  }
 else {
    String uid=getResources().getString(R.string.user_id_no_name);
    String uidExtra=""String_Node_Str"";
    String masterkeyIdHex=""String_Node_Str"";
    PGPSecretKeyRing keyRing=ProviderHelper.getPGPSecretKeyRingByMasterKeyId(getActivity(),secretKeyId);
    if (keyRing != null) {
      PGPSecretKey key=PgpKeyHelper.getMasterKey(keyRing);
      masterkeyIdHex=PgpKeyHelper.convertKeyIdToHex(secretKeyId);
      if (key != null) {
        String userId=PgpKeyHelper.getMainUserIdSafe(getActivity(),key);
        String[] userIdSplit=PgpKeyHelper.splitUserId(userId);
        String userName, userEmail;
        if (userIdSplit[0] != null) {
          userName=userIdSplit[0];
        }
 else {
          userName=""String_Node_Str"";
        }
        if (userIdSplit[1] != null) {
          userEmail=userIdSplit[1];
        }
 else {
          userEmail=""String_Node_Str"";
        }
        mKeyMasterKeyIdHex.setText(masterkeyIdHex);
        mKeyUserId.setText(userName);
        mKeyUserIdRest.setText(userEmail);
        mKeyUserId.setVisibility(View.VISIBLE);
        mKeyUserIdRest.setVisibility(View.VISIBLE);
      }
 else {
        mKeyMasterKeyIdHex.setText(""String_Node_Str"");
        mKeyUserId.setVisibility(View.GONE);
        mKeyUserIdRest.setVisibility(View.GONE);
      }
    }
 else {
      mKeyMasterKeyIdHex.setText(""String_Node_Str"" + secretKeyId);
      mKeyUserId.setVisibility(View.GONE);
      mKeyUserIdRest.setVisibility(View.GONE);
    }
  }
}",0.549366116019977
8393,"/** 
 * Inflate the layout for this fragment
 */
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.select_secret_key_layout_fragment,container,false);
  mKeyUserId=(TextView)view.findViewById(R.id.select_secret_key_user_id);
  mKeyUserIdRest=(TextView)view.findViewById(R.id.select_secret_key_user_id_rest);
  mSelectKeyButton=(BootstrapButton)view.findViewById(R.id.select_secret_key_select_key_button);
  mFilterCertify=false;
  mSelectKeyButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      startSelectKeyActivity();
    }
  }
);
  return view;
}","/** 
 * Inflate the layout for this fragment
 */
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.select_secret_key_layout_fragment,container,false);
  mKeyUserId=(TextView)view.findViewById(R.id.select_secret_key_user_id);
  mKeyUserIdRest=(TextView)view.findViewById(R.id.select_secret_key_user_id_rest);
  mKeyMasterKeyIdHex=(TextView)view.findViewById(R.id.select_secret_key_master_key_hex);
  mSelectKeyButton=(BootstrapButton)view.findViewById(R.id.select_secret_key_select_key_button);
  mFilterCertify=false;
  mSelectKeyButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      startSelectKeyActivity();
    }
  }
);
  return view;
}",0.9396610169491524
8394,"/** 
 * Show dialog to delete key
 * @param keyRingRowIds
 */
public void showDeleteKeyDialog(final ActionMode mode,long[] keyRingRowIds){
  Handler returnHandler=new Handler(){
    @Override public void handleMessage(    Message message){
      if (message.what == DeleteKeyDialogFragment.MESSAGE_OKAY) {
        Bundle returnData=message.getData();
        if (returnData != null && returnData.containsKey(DeleteKeyDialogFragment.MESSAGE_NOT_DELETED)) {
          ArrayList<String> notDeleted=returnData.getStringArrayList(DeleteKeyDialogFragment.MESSAGE_NOT_DELETED);
          String notDeletedMsg=""String_Node_Str"";
          for (          String userId : notDeleted) {
            notDeletedMsg+=userId + ""String_Node_Str"";
          }
          Toast.makeText(getActivity(),getString(R.string.error_can_not_delete_contacts,notDeletedMsg) + getResources().getQuantityString(R.plurals.error_can_not_delete_info,notDeleted.size()),Toast.LENGTH_LONG).show();
          mode.finish();
        }
      }
    }
  }
;
  Messenger messenger=new Messenger(returnHandler);
  DeleteKeyDialogFragment deleteKeyDialog=DeleteKeyDialogFragment.newInstance(messenger,keyRingRowIds,Id.type.public_key);
  deleteKeyDialog.show(getActivity().getSupportFragmentManager(),""String_Node_Str"");
}","/** 
 * Show dialog to delete key
 * @param keyRingRowIds
 */
@TargetApi(11) public void showDeleteKeyDialog(final ActionMode mode,long[] keyRingRowIds){
  Handler returnHandler=new Handler(){
    @Override public void handleMessage(    Message message){
      if (message.what == DeleteKeyDialogFragment.MESSAGE_OKAY) {
        Bundle returnData=message.getData();
        if (returnData != null && returnData.containsKey(DeleteKeyDialogFragment.MESSAGE_NOT_DELETED)) {
          ArrayList<String> notDeleted=returnData.getStringArrayList(DeleteKeyDialogFragment.MESSAGE_NOT_DELETED);
          String notDeletedMsg=""String_Node_Str"";
          for (          String userId : notDeleted) {
            notDeletedMsg+=userId + ""String_Node_Str"";
          }
          Toast.makeText(getActivity(),getString(R.string.error_can_not_delete_contacts,notDeletedMsg) + getResources().getQuantityString(R.plurals.error_can_not_delete_info,notDeleted.size()),Toast.LENGTH_LONG).show();
          mode.finish();
        }
      }
    }
  }
;
  Messenger messenger=new Messenger(returnHandler);
  DeleteKeyDialogFragment deleteKeyDialog=DeleteKeyDialogFragment.newInstance(messenger,keyRingRowIds,Id.type.public_key);
  deleteKeyDialog.show(getActivity().getSupportFragmentManager(),""String_Node_Str"");
}",0.994170229304314
8395,"public void encrypt(ActionMode mode,long[] keyRingRowIds){
  long[] keyRingIds=new long[keyRingRowIds.length];
  for (int i=0; i < keyRingRowIds.length; i++) {
    keyRingIds[i]=ProviderHelper.getPublicMasterKeyId(getActivity(),keyRingRowIds[i]);
  }
  Intent intent=new Intent(getActivity(),EncryptActivity.class);
  intent.setAction(EncryptActivity.ACTION_ENCRYPT);
  intent.putExtra(EncryptActivity.EXTRA_ENCRYPTION_KEY_IDS,keyRingIds);
  startActivityForResult(intent,0);
  mode.finish();
}","@TargetApi(11) public void encrypt(ActionMode mode,long[] keyRingRowIds){
  long[] keyRingIds=new long[keyRingRowIds.length];
  for (int i=0; i < keyRingRowIds.length; i++) {
    keyRingIds[i]=ProviderHelper.getPublicMasterKeyId(getActivity(),keyRingRowIds[i]);
  }
  Intent intent=new Intent(getActivity(),EncryptActivity.class);
  intent.setAction(EncryptActivity.ACTION_ENCRYPT);
  intent.putExtra(EncryptActivity.EXTRA_ENCRYPTION_KEY_IDS,keyRingIds);
  startActivityForResult(intent,0);
  mode.finish();
}",0.9850448654037888
8396,"/** 
 * Show dialog to delete key
 * @param keyRingRowIds
 */
public void showDeleteKeyDialog(final ActionMode mode,long[] keyRingRowIds){
  Handler returnHandler=new Handler(){
    @Override public void handleMessage(    Message message){
      if (message.what == DeleteKeyDialogFragment.MESSAGE_OKAY) {
        mode.finish();
      }
    }
  }
;
  Messenger messenger=new Messenger(returnHandler);
  DeleteKeyDialogFragment deleteKeyDialog=DeleteKeyDialogFragment.newInstance(messenger,keyRingRowIds,Id.type.secret_key);
  deleteKeyDialog.show(getActivity().getSupportFragmentManager(),""String_Node_Str"");
}","/** 
 * Show dialog to delete key
 * @param keyRingRowIds
 */
@TargetApi(11) public void showDeleteKeyDialog(final ActionMode mode,long[] keyRingRowIds){
  Handler returnHandler=new Handler(){
    @Override public void handleMessage(    Message message){
      if (message.what == DeleteKeyDialogFragment.MESSAGE_OKAY) {
        mode.finish();
      }
    }
  }
;
  Messenger messenger=new Messenger(returnHandler);
  DeleteKeyDialogFragment deleteKeyDialog=DeleteKeyDialogFragment.newInstance(messenger,keyRingRowIds,Id.type.secret_key);
  deleteKeyDialog.show(getActivity().getSupportFragmentManager(),""String_Node_Str"");
}",0.9878542510121456
8397,"@Override public void handleMessage(Message message){
  if (message.what == PassphraseDialogFragment.MESSAGE_OKAY) {
    Intent finishIntent=new Intent();
    finishIntent.putExtra(OpenPgpConstants.PI_RESULT_PARAMS,params);
    setResult(RESULT_OK,finishIntent);
  }
 else {
    setResult(RESULT_CANCELED);
  }
  finish();
}","@Override public void handleMessage(Message message){
  if (message.what == PassphraseDialogFragment.MESSAGE_OKAY) {
    Intent finishIntent=new Intent();
    finishIntent.putExtra(OpenPgpConstants.PI_RESULT_PARAMS,params);
    RemoteServiceActivity.this.setResult(RESULT_OK,finishIntent);
  }
 else {
    RemoteServiceActivity.this.setResult(RESULT_CANCELED);
  }
  RemoteServiceActivity.this.finish();
}",0.8888888888888888
8398,"/** 
 * Shows passphrase dialog to cache a new passphrase the user enters for using it later for encryption. Based on mSecretKeyId it asks for a passphrase to open a private key or it asks for a symmetric passphrase
 */
private void showPassphraseDialog(final Bundle params,long secretKeyId){
  Handler returnHandler=new Handler(){
    @Override public void handleMessage(    Message message){
      if (message.what == PassphraseDialogFragment.MESSAGE_OKAY) {
        Intent finishIntent=new Intent();
        finishIntent.putExtra(OpenPgpConstants.PI_RESULT_PARAMS,params);
        setResult(RESULT_OK,finishIntent);
      }
 else {
        setResult(RESULT_CANCELED);
      }
      finish();
    }
  }
;
  Messenger messenger=new Messenger(returnHandler);
  try {
    PassphraseDialogFragment passphraseDialog=PassphraseDialogFragment.newInstance(this,messenger,secretKeyId);
    passphraseDialog.show(getSupportFragmentManager(),""String_Node_Str"");
  }
 catch (  PgpGeneralException e) {
    Log.d(Constants.TAG,""String_Node_Str"");
    Intent finishIntent=new Intent();
    finishIntent.putExtra(OpenPgpConstants.PI_RESULT_PARAMS,params);
    setResult(RESULT_OK,finishIntent);
    finish();
  }
}","/** 
 * Shows passphrase dialog to cache a new passphrase the user enters for using it later for encryption. Based on mSecretKeyId it asks for a passphrase to open a private key or it asks for a symmetric passphrase
 */
private void showPassphraseDialog(final Bundle params,long secretKeyId){
  Handler returnHandler=new Handler(){
    @Override public void handleMessage(    Message message){
      if (message.what == PassphraseDialogFragment.MESSAGE_OKAY) {
        Intent finishIntent=new Intent();
        finishIntent.putExtra(OpenPgpConstants.PI_RESULT_PARAMS,params);
        RemoteServiceActivity.this.setResult(RESULT_OK,finishIntent);
      }
 else {
        RemoteServiceActivity.this.setResult(RESULT_CANCELED);
      }
      RemoteServiceActivity.this.finish();
    }
  }
;
  Messenger messenger=new Messenger(returnHandler);
  try {
    PassphraseDialogFragment passphraseDialog=PassphraseDialogFragment.newInstance(this,messenger,secretKeyId);
    passphraseDialog.show(getSupportFragmentManager(),""String_Node_Str"");
  }
 catch (  PgpGeneralException e) {
    Log.d(Constants.TAG,""String_Node_Str"");
    Intent finishIntent=new Intent();
    finishIntent.putExtra(OpenPgpConstants.PI_RESULT_PARAMS,params);
    setResult(RESULT_OK,finishIntent);
    finish();
  }
}",0.9673781715666532
8399,"public void signAndEncrypt(Bundle params){
  params.putStringArray(OpenPgpConstants.PARAMS_USER_IDS,mEncryptUserIds.getText().toString().split(""String_Node_Str""));
  params.putBoolean(OpenPgpConstants.PARAMS_REQUEST_ASCII_ARMOR,true);
  InputStream is=getInputstream(false);
  final ByteArrayOutputStream os=new ByteArrayOutputStream();
  OpenPgpApi api=new OpenPgpApi(mCryptoServiceConnection.getService());
  api.signAndEncrypt(params,is,os,new MyCallback(true,os,REQUEST_CODE_SIGN_AND_ENCRYPT));
}","public void signAndEncrypt(Bundle params){
  params.putStringArray(OpenPgpConstants.PARAMS_USER_IDS,mEncryptUserIds.getText().toString().split(""String_Node_Str""));
  params.putBoolean(OpenPgpConstants.PARAMS_REQUEST_ASCII_ARMOR,true);
  InputStream is=getInputstream(false);
  final ByteArrayOutputStream os=new ByteArrayOutputStream();
  OpenPgpApi api=new OpenPgpApi(this,mCryptoServiceConnection.getService());
  api.signAndEncrypt(params,is,os,new MyCallback(true,os,REQUEST_CODE_SIGN_AND_ENCRYPT));
}",0.9950248756218906
8400,"public void sign(Bundle params){
  params.putBoolean(OpenPgpConstants.PARAMS_REQUEST_ASCII_ARMOR,true);
  InputStream is=getInputstream(false);
  final ByteArrayOutputStream os=new ByteArrayOutputStream();
  OpenPgpApi api=new OpenPgpApi(mCryptoServiceConnection.getService());
  api.sign(params,is,os,new MyCallback(true,os,REQUEST_CODE_SIGN));
}","public void sign(Bundle params){
  params.putBoolean(OpenPgpConstants.PARAMS_REQUEST_ASCII_ARMOR,true);
  InputStream is=getInputstream(false);
  final ByteArrayOutputStream os=new ByteArrayOutputStream();
  OpenPgpApi api=new OpenPgpApi(this,mCryptoServiceConnection.getService());
  api.sign(params,is,os,new MyCallback(true,os,REQUEST_CODE_SIGN));
}",0.9928469241773964
8401,"public void decryptAndVerify(Bundle params){
  params.putBoolean(OpenPgpConstants.PARAMS_REQUEST_ASCII_ARMOR,true);
  InputStream is=getInputstream(true);
  final ByteArrayOutputStream os=new ByteArrayOutputStream();
  OpenPgpApi api=new OpenPgpApi(mCryptoServiceConnection.getService());
  api.decryptAndVerify(params,is,os,new MyCallback(true,os,REQUEST_CODE_DECRYPT_AND_VERIFY));
}","public void decryptAndVerify(Bundle params){
  params.putBoolean(OpenPgpConstants.PARAMS_REQUEST_ASCII_ARMOR,true);
  InputStream is=getInputstream(true);
  final ByteArrayOutputStream os=new ByteArrayOutputStream();
  OpenPgpApi api=new OpenPgpApi(this,mCryptoServiceConnection.getService());
  api.decryptAndVerify(params,is,os,new MyCallback(true,os,REQUEST_CODE_DECRYPT_AND_VERIFY));
}",0.9935316946959896
8402,"public void encrypt(Bundle params){
  params.putStringArray(OpenPgpConstants.PARAMS_USER_IDS,mEncryptUserIds.getText().toString().split(""String_Node_Str""));
  params.putBoolean(OpenPgpConstants.PARAMS_REQUEST_ASCII_ARMOR,true);
  InputStream is=getInputstream(false);
  final ByteArrayOutputStream os=new ByteArrayOutputStream();
  OpenPgpApi api=new OpenPgpApi(mCryptoServiceConnection.getService());
  api.encrypt(params,is,os,new MyCallback(true,os,REQUEST_CODE_ENCRYPT));
}","public void encrypt(Bundle params){
  params.putStringArray(OpenPgpConstants.PARAMS_USER_IDS,mEncryptUserIds.getText().toString().split(""String_Node_Str""));
  params.putBoolean(OpenPgpConstants.PARAMS_REQUEST_ASCII_ARMOR,true);
  InputStream is=getInputstream(false);
  final ByteArrayOutputStream os=new ByteArrayOutputStream();
  OpenPgpApi api=new OpenPgpApi(this,mCryptoServiceConnection.getService());
  api.encrypt(params,is,os,new MyCallback(true,os,REQUEST_CODE_ENCRYPT));
}",0.994786235662148
8403,"public void changeSecretKeyPassphrase(PGPSecretKeyRing keyRing,String oldPassPhrase,String newPassPhrase) throws IOException, PGPException, PGPException, NoSuchProviderException {
  updateProgress(R.string.progress_building_key,0,100);
  if (oldPassPhrase == null) {
    oldPassPhrase=""String_Node_Str"";
  }
  if (newPassPhrase == null) {
    newPassPhrase=""String_Node_Str"";
  }
  PGPSecretKeyRing newKeyRing=PGPSecretKeyRing.copyWithNewPassword(keyRing,new JcePBESecretKeyDecryptorBuilder(new JcaPGPDigestCalculatorProviderBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build()).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray()),new JcePBESecretKeyEncryptorBuilder(keyRing.getSecretKey().getKeyEncryptionAlgorithm()).build(newPassPhrase.toCharArray()));
  updateProgress(R.string.progress_saving_key_ring,50,100);
  ProviderHelper.saveKeyRing(mContext,newKeyRing);
  updateProgress(R.string.progress_done,100,100);
}","public void changeSecretKeyPassphrase(PGPSecretKeyRing keyRing,String oldPassPhrase,String newPassPhrase) throws IOException, PGPException {
  updateProgress(R.string.progress_building_key,0,100);
  if (oldPassPhrase == null) {
    oldPassPhrase=""String_Node_Str"";
  }
  if (newPassPhrase == null) {
    newPassPhrase=""String_Node_Str"";
  }
  PGPSecretKeyRing newKeyRing=PGPSecretKeyRing.copyWithNewPassword(keyRing,new JcePBESecretKeyDecryptorBuilder(new JcaPGPDigestCalculatorProviderBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build()).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray()),new JcePBESecretKeyEncryptorBuilder(keyRing.getSecretKey().getKeyEncryptionAlgorithm()).build(newPassPhrase.toCharArray()));
  updateProgress(R.string.progress_saving_key_ring,50,100);
  ProviderHelper.saveKeyRing(mContext,newKeyRing);
  updateProgress(R.string.progress_done,100,100);
}",0.9794412229836584
8404,"public void updateProgress(int current,int total){
  if (mProgress != null) {
    mProgress.setProgress(current,total);
  }
}","void updateProgress(int current,int total){
  if (mProgress != null) {
    mProgress.setProgress(current,total);
  }
}",0.97119341563786
8405,"/** 
 * Creates new secret key.
 * @param algorithmChoice
 * @param keySize
 * @param passPhrase
 * @param isMasterKey
 * @return
 * @throws NoSuchAlgorithmException
 * @throws PGPException
 * @throws NoSuchProviderException
 * @throws PgpGeneralException
 * @throws InvalidAlgorithmParameterException
 */
public PGPSecretKey createKey(int algorithmChoice,int keySize,String passPhrase,boolean isMasterKey) throws NoSuchAlgorithmException, PGPException, NoSuchProviderException, PgpGeneralException, InvalidAlgorithmParameterException {
  if (keySize < 512) {
    throw new PgpGeneralException(mContext.getString(R.string.error_key_size_minimum512bit));
  }
  if (passPhrase == null) {
    passPhrase=""String_Node_Str"";
  }
  int algorithm=0;
  KeyPairGenerator keyGen=null;
switch (algorithmChoice) {
case Id.choice.algorithm.dsa:
{
      keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",Constants.BOUNCY_CASTLE_PROVIDER_NAME);
      keyGen.initialize(keySize,new SecureRandom());
      algorithm=PGPPublicKey.DSA;
      break;
    }
case Id.choice.algorithm.elgamal:
{
    if (isMasterKey) {
      throw new PgpGeneralException(mContext.getString(R.string.error_master_key_must_not_be_el_gamal));
    }
    keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",Constants.BOUNCY_CASTLE_PROVIDER_NAME);
    BigInteger p=Primes.getBestPrime(keySize);
    BigInteger g=new BigInteger(""String_Node_Str"");
    ElGamalParameterSpec elParams=new ElGamalParameterSpec(p,g);
    keyGen.initialize(elParams);
    algorithm=PGPPublicKey.ELGAMAL_ENCRYPT;
    break;
  }
case Id.choice.algorithm.rsa:
{
  keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",Constants.BOUNCY_CASTLE_PROVIDER_NAME);
  keyGen.initialize(keySize,new SecureRandom());
  algorithm=PGPPublicKey.RSA_GENERAL;
  break;
}
default :
{
throw new PgpGeneralException(mContext.getString(R.string.error_unknown_algorithm_choice));
}
}
PGPKeyPair keyPair=new JcaPGPKeyPair(algorithm,keyGen.generateKeyPair(),new Date());
PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(passPhrase.toCharArray());
PGPSecretKey secKey=new PGPSecretKey(keyPair.getPrivateKey(),keyPair.getPublicKey(),sha1Calc,isMasterKey,keyEncryptor);
return secKey;
}","public PGPSecretKey createKey(int algorithmChoice,int keySize,String passPhrase,boolean isMasterKey) throws NoSuchAlgorithmException, PGPException, NoSuchProviderException, PgpGeneralException, InvalidAlgorithmParameterException {
  if (keySize < 512) {
    throw new PgpGeneralException(mContext.getString(R.string.error_key_size_minimum512bit));
  }
  if (passPhrase == null) {
    passPhrase=""String_Node_Str"";
  }
  int algorithm;
  KeyPairGenerator keyGen;
switch (algorithmChoice) {
case Id.choice.algorithm.dsa:
{
      keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",Constants.BOUNCY_CASTLE_PROVIDER_NAME);
      keyGen.initialize(keySize,new SecureRandom());
      algorithm=PGPPublicKey.DSA;
      break;
    }
case Id.choice.algorithm.elgamal:
{
    if (isMasterKey) {
      throw new PgpGeneralException(mContext.getString(R.string.error_master_key_must_not_be_el_gamal));
    }
    keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",Constants.BOUNCY_CASTLE_PROVIDER_NAME);
    BigInteger p=Primes.getBestPrime(keySize);
    BigInteger g=new BigInteger(""String_Node_Str"");
    ElGamalParameterSpec elParams=new ElGamalParameterSpec(p,g);
    keyGen.initialize(elParams);
    algorithm=PGPPublicKey.ELGAMAL_ENCRYPT;
    break;
  }
case Id.choice.algorithm.rsa:
{
  keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",Constants.BOUNCY_CASTLE_PROVIDER_NAME);
  keyGen.initialize(keySize,new SecureRandom());
  algorithm=PGPPublicKey.RSA_GENERAL;
  break;
}
default :
{
throw new PgpGeneralException(mContext.getString(R.string.error_unknown_algorithm_choice));
}
}
PGPKeyPair keyPair=new JcaPGPKeyPair(algorithm,keyGen.generateKeyPair(),new Date());
PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(passPhrase.toCharArray());
return new PGPSecretKey(keyPair.getPrivateKey(),keyPair.getPublicKey(),sha1Calc,isMasterKey,keyEncryptor);
}",0.9209882038726908
8406,"public PGPPublicKeyRing signKey(long masterKeyId,long pubKeyId,String passphrase) throws PgpGeneralException, NoSuchAlgorithmException, NoSuchProviderException, PGPException, SignatureException {
  if (passphrase == null) {
    throw new PgpGeneralException(""String_Node_Str"");
  }
 else {
    PGPPublicKeyRing pubring=ProviderHelper.getPGPPublicKeyRingByKeyId(mContext,pubKeyId);
    PGPSecretKey signingKey=PgpKeyHelper.getCertificationKey(mContext,masterKeyId);
    if (signingKey == null) {
      throw new PgpGeneralException(mContext.getString(R.string.error_signature_failed));
    }
    PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(passphrase.toCharArray());
    PGPPrivateKey signaturePrivateKey=signingKey.extractPrivateKey(keyDecryptor);
    if (signaturePrivateKey == null) {
      throw new PgpGeneralException(mContext.getString(R.string.error_could_not_extract_private_key));
    }
    JcaPGPContentSignerBuilder contentSignerBuilder=new JcaPGPContentSignerBuilder(signingKey.getPublicKey().getAlgorithm(),PGPUtil.SHA256).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
    PGPSignatureGenerator signatureGenerator=new PGPSignatureGenerator(contentSignerBuilder);
    signatureGenerator.init(PGPSignature.DIRECT_KEY,signaturePrivateKey);
    PGPSignatureSubpacketGenerator spGen=new PGPSignatureSubpacketGenerator();
    PGPSignatureSubpacketVector packetVector=spGen.generate();
    signatureGenerator.setHashedSubpackets(packetVector);
    PGPPublicKey signedKey=PGPPublicKey.addCertification(pubring.getPublicKey(pubKeyId),signatureGenerator.generate());
    pubring=PGPPublicKeyRing.insertPublicKey(pubring,signedKey);
    return pubring;
  }
}","public PGPPublicKeyRing signKey(long masterKeyId,long pubKeyId,String passphrase) throws PgpGeneralException, PGPException, SignatureException {
  if (passphrase == null) {
    throw new PgpGeneralException(""String_Node_Str"");
  }
 else {
    PGPPublicKeyRing pubring=ProviderHelper.getPGPPublicKeyRingByKeyId(mContext,pubKeyId);
    PGPSecretKey signingKey=PgpKeyHelper.getCertificationKey(mContext,masterKeyId);
    if (signingKey == null) {
      throw new PgpGeneralException(mContext.getString(R.string.error_signature_failed));
    }
    PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(passphrase.toCharArray());
    PGPPrivateKey signaturePrivateKey=signingKey.extractPrivateKey(keyDecryptor);
    if (signaturePrivateKey == null) {
      throw new PgpGeneralException(mContext.getString(R.string.error_could_not_extract_private_key));
    }
    JcaPGPContentSignerBuilder contentSignerBuilder=new JcaPGPContentSignerBuilder(signingKey.getPublicKey().getAlgorithm(),PGPUtil.SHA256).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
    PGPSignatureGenerator signatureGenerator=new PGPSignatureGenerator(contentSignerBuilder);
    signatureGenerator.init(PGPSignature.DIRECT_KEY,signaturePrivateKey);
    PGPSignatureSubpacketGenerator spGen=new PGPSignatureSubpacketGenerator();
    PGPSignatureSubpacketVector packetVector=spGen.generate();
    signatureGenerator.setHashedSubpackets(packetVector);
    PGPPublicKey signedKey=PGPPublicKey.addCertification(pubring.getPublicKey(pubKeyId),signatureGenerator.generate());
    pubring=PGPPublicKeyRing.insertPublicKey(pubring,signedKey);
    return pubring;
  }
}",0.9852302345786272
8407,"public void buildSecretKey(ArrayList<String> userIds,ArrayList<PGPSecretKey> keys,ArrayList<Integer> keysUsages,ArrayList<GregorianCalendar> keysExpiryDates,long masterKeyId,String oldPassPhrase,String newPassPhrase) throws PgpGeneralException, NoSuchProviderException, PGPException, NoSuchAlgorithmException, SignatureException, IOException {
  Log.d(Constants.TAG,""String_Node_Str"" + userIds.toString());
  updateProgress(R.string.progress_building_key,0,100);
  if (oldPassPhrase == null) {
    oldPassPhrase=""String_Node_Str"";
  }
  if (newPassPhrase == null) {
    newPassPhrase=""String_Node_Str"";
  }
  updateProgress(R.string.progress_preparing_master_key,10,100);
  int usageId=keysUsages.get(0);
  boolean canSign=(usageId & KeyFlags.SIGN_DATA) > 0;
  boolean canEncrypt=(usageId & (KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE)) > 0;
  String mainUserId=userIds.get(0);
  PGPSecretKey masterKey=keys.get(0);
  PGPPublicKey tmpKey=masterKey.getPublicKey();
  PGPPublicKey masterPublicKey=new PGPPublicKey(tmpKey.getAlgorithm(),tmpKey.getKey(new BouncyCastleProvider()),tmpKey.getCreationTime());
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
  PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(keyDecryptor);
  updateProgress(R.string.progress_certifying_master_key,20,100);
  for (  String userId : userIds) {
    PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
    PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
    sGen.init(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
    PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
    masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,userId,certification);
  }
  PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
  PGPSignatureSubpacketGenerator hashedPacketsGen=new PGPSignatureSubpacketGenerator();
  PGPSignatureSubpacketGenerator unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
  hashedPacketsGen.setKeyFlags(true,usageId);
  hashedPacketsGen.setPreferredSymmetricAlgorithms(true,PREFERRED_SYMMETRIC_ALGORITHMS);
  hashedPacketsGen.setPreferredHashAlgorithms(true,PREFERRED_HASH_ALGORITHMS);
  hashedPacketsGen.setPreferredCompressionAlgorithms(true,PREFERRED_COMPRESSION_ALGORITHMS);
  if (keysExpiryDates.get(0) != null) {
    GregorianCalendar creationDate=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
    creationDate.setTime(masterPublicKey.getCreationTime());
    GregorianCalendar expiryDate=keysExpiryDates.get(0);
    long numDays=(expiryDate.getTimeInMillis() / 86400000) - (creationDate.getTimeInMillis() / 86400000);
    if (numDays <= 0)     throw new PgpGeneralException(mContext.getString(R.string.error_expiry_must_come_after_creation));
    hashedPacketsGen.setKeyExpirationTime(false,numDays * 86400);
  }
 else {
    hashedPacketsGen.setKeyExpirationTime(false,0);
  }
  updateProgress(R.string.progress_building_master_key,30,100);
  PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
  PGPContentSignerBuilder certificationSignerBuilder=new JcaPGPContentSignerBuilder(masterKeyPair.getPublicKey().getAlgorithm(),HashAlgorithmTags.SHA1);
  PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(newPassPhrase.toCharArray());
  PGPKeyRingGenerator keyGen=new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION,masterKeyPair,mainUserId,sha1Calc,hashedPacketsGen.generate(),unhashedPacketsGen.generate(),certificationSignerBuilder,keyEncryptor);
  updateProgress(R.string.progress_adding_sub_keys,40,100);
  for (int i=1; i < keys.size(); ++i) {
    updateProgress(40 + 50 * (i - 1) / (keys.size() - 1),100);
    PGPSecretKey subKey=keys.get(i);
    PGPPublicKey subPublicKey=subKey.getPublicKey();
    PBESecretKeyDecryptor keyDecryptor2=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
    PGPPrivateKey subPrivateKey=subKey.extractPrivateKey(keyDecryptor2);
    PGPKeyPair subKeyPair=new PGPKeyPair(subPublicKey,subPrivateKey);
    hashedPacketsGen=new PGPSignatureSubpacketGenerator();
    unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
    usageId=keysUsages.get(i);
    canSign=(usageId & KeyFlags.SIGN_DATA) > 0;
    canEncrypt=(usageId & (KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE)) > 0;
    if (canSign) {
      Date todayDate=new Date();
      hashedPacketsGen.setSignatureCreationTime(false,todayDate);
      PGPSignatureSubpacketGenerator subHashedPacketsGen=new PGPSignatureSubpacketGenerator();
      subHashedPacketsGen.setSignatureCreationTime(false,todayDate);
      PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(subPublicKey.getAlgorithm(),PGPUtil.SHA1).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
      PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
      sGen.init(PGPSignature.PRIMARYKEY_BINDING,subPrivateKey);
      sGen.setHashedSubpackets(subHashedPacketsGen.generate());
      PGPSignature certification=sGen.generateCertification(masterPublicKey,subPublicKey);
      unhashedPacketsGen.setEmbeddedSignature(false,certification);
    }
    hashedPacketsGen.setKeyFlags(false,usageId);
    if (keysExpiryDates.get(i) != null) {
      GregorianCalendar creationDate=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
      creationDate.setTime(subPublicKey.getCreationTime());
      GregorianCalendar expiryDate=keysExpiryDates.get(i);
      long numDays=(expiryDate.getTimeInMillis() / 86400000) - (creationDate.getTimeInMillis() / 86400000);
      if (numDays <= 0)       throw new PgpGeneralException(mContext.getString(R.string.error_expiry_must_come_after_creation));
      hashedPacketsGen.setKeyExpirationTime(false,numDays * 86400);
    }
 else {
      hashedPacketsGen.setKeyExpirationTime(false,0);
    }
    keyGen.addSubKey(subKeyPair,hashedPacketsGen.generate(),unhashedPacketsGen.generate());
  }
  PGPSecretKeyRing secretKeyRing=keyGen.generateSecretKeyRing();
  PGPPublicKeyRing publicKeyRing=keyGen.generatePublicKeyRing();
  updateProgress(R.string.progress_saving_key_ring,90,100);
  ProviderHelper.saveKeyRing(mContext,secretKeyRing);
  ProviderHelper.saveKeyRing(mContext,publicKeyRing);
  updateProgress(R.string.progress_done,100,100);
}","public void buildSecretKey(ArrayList<String> userIds,ArrayList<PGPSecretKey> keys,ArrayList<Integer> keysUsages,ArrayList<GregorianCalendar> keysExpiryDates,String oldPassPhrase,String newPassPhrase) throws PgpGeneralException, PGPException, SignatureException, IOException {
  Log.d(Constants.TAG,""String_Node_Str"" + userIds.toString());
  updateProgress(R.string.progress_building_key,0,100);
  if (oldPassPhrase == null) {
    oldPassPhrase=""String_Node_Str"";
  }
  if (newPassPhrase == null) {
    newPassPhrase=""String_Node_Str"";
  }
  updateProgress(R.string.progress_preparing_master_key,10,100);
  int usageId=keysUsages.get(0);
  boolean canSign;
  String mainUserId=userIds.get(0);
  PGPSecretKey masterKey=keys.get(0);
  PGPPublicKey tmpKey=masterKey.getPublicKey();
  PublicKey tmpPuK=new JcaPGPKeyConverter().setProvider(new BouncyCastleProvider()).getPublicKey(tmpKey);
  PGPPublicKey masterPublicKey=new JcaPGPKeyConverter().getPGPPublicKey(tmpKey.getAlgorithm(),tmpPuK,tmpKey.getCreationTime());
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
  PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(keyDecryptor);
  updateProgress(R.string.progress_certifying_master_key,20,100);
  for (  String userId : userIds) {
    PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
    PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
    sGen.init(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
    PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
    masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,userId,certification);
  }
  PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
  PGPSignatureSubpacketGenerator hashedPacketsGen=new PGPSignatureSubpacketGenerator();
  PGPSignatureSubpacketGenerator unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
  hashedPacketsGen.setKeyFlags(true,usageId);
  hashedPacketsGen.setPreferredSymmetricAlgorithms(true,PREFERRED_SYMMETRIC_ALGORITHMS);
  hashedPacketsGen.setPreferredHashAlgorithms(true,PREFERRED_HASH_ALGORITHMS);
  hashedPacketsGen.setPreferredCompressionAlgorithms(true,PREFERRED_COMPRESSION_ALGORITHMS);
  if (keysExpiryDates.get(0) != null) {
    GregorianCalendar creationDate=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
    creationDate.setTime(masterPublicKey.getCreationTime());
    GregorianCalendar expiryDate=keysExpiryDates.get(0);
    long numDays=(expiryDate.getTimeInMillis() / 86400000) - (creationDate.getTimeInMillis() / 86400000);
    if (numDays <= 0)     throw new PgpGeneralException(mContext.getString(R.string.error_expiry_must_come_after_creation));
    hashedPacketsGen.setKeyExpirationTime(false,numDays * 86400);
  }
 else {
    hashedPacketsGen.setKeyExpirationTime(false,0);
  }
  updateProgress(R.string.progress_building_master_key,30,100);
  PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
  PGPContentSignerBuilder certificationSignerBuilder=new JcaPGPContentSignerBuilder(masterKeyPair.getPublicKey().getAlgorithm(),HashAlgorithmTags.SHA1);
  PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(newPassPhrase.toCharArray());
  PGPKeyRingGenerator keyGen=new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION,masterKeyPair,mainUserId,sha1Calc,hashedPacketsGen.generate(),unhashedPacketsGen.generate(),certificationSignerBuilder,keyEncryptor);
  updateProgress(R.string.progress_adding_sub_keys,40,100);
  for (int i=1; i < keys.size(); ++i) {
    updateProgress(40 + 50 * (i - 1) / (keys.size() - 1),100);
    PGPSecretKey subKey=keys.get(i);
    PGPPublicKey subPublicKey=subKey.getPublicKey();
    PBESecretKeyDecryptor keyDecryptor2=new JcePBESecretKeyDecryptorBuilder().setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
    PGPPrivateKey subPrivateKey=subKey.extractPrivateKey(keyDecryptor2);
    PGPKeyPair subKeyPair=new PGPKeyPair(subPublicKey,subPrivateKey);
    hashedPacketsGen=new PGPSignatureSubpacketGenerator();
    unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
    usageId=keysUsages.get(i);
    canSign=(usageId & KeyFlags.SIGN_DATA) > 0;
    if (canSign) {
      Date todayDate=new Date();
      hashedPacketsGen.setSignatureCreationTime(false,todayDate);
      PGPSignatureSubpacketGenerator subHashedPacketsGen=new PGPSignatureSubpacketGenerator();
      subHashedPacketsGen.setSignatureCreationTime(false,todayDate);
      PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(subPublicKey.getAlgorithm(),PGPUtil.SHA1).setProvider(Constants.BOUNCY_CASTLE_PROVIDER_NAME);
      PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
      sGen.init(PGPSignature.PRIMARYKEY_BINDING,subPrivateKey);
      sGen.setHashedSubpackets(subHashedPacketsGen.generate());
      PGPSignature certification=sGen.generateCertification(masterPublicKey,subPublicKey);
      unhashedPacketsGen.setEmbeddedSignature(false,certification);
    }
    hashedPacketsGen.setKeyFlags(false,usageId);
    if (keysExpiryDates.get(i) != null) {
      GregorianCalendar creationDate=new GregorianCalendar(TimeZone.getTimeZone(""String_Node_Str""));
      creationDate.setTime(subPublicKey.getCreationTime());
      GregorianCalendar expiryDate=keysExpiryDates.get(i);
      long numDays=(expiryDate.getTimeInMillis() / 86400000) - (creationDate.getTimeInMillis() / 86400000);
      if (numDays <= 0)       throw new PgpGeneralException(mContext.getString(R.string.error_expiry_must_come_after_creation));
      hashedPacketsGen.setKeyExpirationTime(false,numDays * 86400);
    }
 else {
      hashedPacketsGen.setKeyExpirationTime(false,0);
    }
    keyGen.addSubKey(subKeyPair,hashedPacketsGen.generate(),unhashedPacketsGen.generate());
  }
  PGPSecretKeyRing secretKeyRing=keyGen.generateSecretKeyRing();
  PGPPublicKeyRing publicKeyRing=keyGen.generatePublicKeyRing();
  updateProgress(R.string.progress_saving_key_ring,90,100);
  ProviderHelper.saveKeyRing(mContext,secretKeyRing);
  ProviderHelper.saveKeyRing(mContext,publicKeyRing);
  updateProgress(R.string.progress_done,100,100);
}",0.9641555285540704
8408,"/** 
 * Constructor based on key object, used for import from NFC, QR Codes, files
 */
@SuppressWarnings(""String_Node_Str"") public ImportKeysListEntry(PGPKeyRing pgpKeyRing){
  try {
    this.bytes=pgpKeyRing.getEncoded();
  }
 catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
  }
  this.selected=true;
  if (pgpKeyRing instanceof PGPSecretKeyRing) {
    secretKey=true;
  }
 else {
    secretKey=false;
  }
  userIds=new ArrayList<String>();
  for (  String userId : new IterableIterator<String>(pgpKeyRing.getPublicKey().getUserIDs())) {
    userIds.add(userId);
  }
  this.keyId=pgpKeyRing.getPublicKey().getKeyID();
  this.revoked=pgpKeyRing.getPublicKey().isRevoked();
  this.fingerPrint=PgpKeyHelper.convertFingerprintToHex(pgpKeyRing.getPublicKey().getFingerprint(),true);
  this.hexKeyId=PgpKeyHelper.convertKeyIdToHex(keyId);
  this.bitStrength=pgpKeyRing.getPublicKey().getBitStrength();
  int algorithm=pgpKeyRing.getPublicKey().getAlgorithm();
  if (algorithm == PGPPublicKey.RSA_ENCRYPT || algorithm == PGPPublicKey.RSA_GENERAL || algorithm == PGPPublicKey.RSA_SIGN) {
    this.algorithm=""String_Node_Str"";
  }
 else   if (algorithm == PGPPublicKey.DSA) {
    this.algorithm=""String_Node_Str"";
  }
 else   if (algorithm == PGPPublicKey.ELGAMAL_ENCRYPT || algorithm == PGPPublicKey.ELGAMAL_GENERAL) {
    this.algorithm=""String_Node_Str"";
  }
 else   if (algorithm == PGPPublicKey.EC || algorithm == PGPPublicKey.ECDSA) {
    this.algorithm=""String_Node_Str"";
  }
 else {
    this.algorithm=""String_Node_Str"";
  }
}","/** 
 * Constructor based on key object, used for import from NFC, QR Codes, files
 */
@SuppressWarnings(""String_Node_Str"") public ImportKeysListEntry(PGPKeyRing pgpKeyRing){
  try {
    this.bytes=pgpKeyRing.getEncoded();
  }
 catch (  IOException e) {
    Log.e(Constants.TAG,""String_Node_Str"",e);
  }
  this.selected=true;
  if (pgpKeyRing instanceof PGPSecretKeyRing) {
    secretKey=true;
  }
 else {
    secretKey=false;
  }
  userIds=new ArrayList<String>();
  for (  String userId : new IterableIterator<String>(pgpKeyRing.getPublicKey().getUserIDs())) {
    userIds.add(userId);
  }
  this.keyId=pgpKeyRing.getPublicKey().getKeyID();
  this.revoked=pgpKeyRing.getPublicKey().isRevoked();
  this.fingerPrint=PgpKeyHelper.convertFingerprintToHex(pgpKeyRing.getPublicKey().getFingerprint(),true);
  this.hexKeyId=""String_Node_Str"" + PgpKeyHelper.convertKeyIdToHex(keyId);
  this.bitStrength=pgpKeyRing.getPublicKey().getBitStrength();
  int algorithm=pgpKeyRing.getPublicKey().getAlgorithm();
  if (algorithm == PGPPublicKey.RSA_ENCRYPT || algorithm == PGPPublicKey.RSA_GENERAL || algorithm == PGPPublicKey.RSA_SIGN) {
    this.algorithm=""String_Node_Str"";
  }
 else   if (algorithm == PGPPublicKey.DSA) {
    this.algorithm=""String_Node_Str"";
  }
 else   if (algorithm == PGPPublicKey.ELGAMAL_ENCRYPT || algorithm == PGPPublicKey.ELGAMAL_GENERAL) {
    this.algorithm=""String_Node_Str"";
  }
 else   if (algorithm == PGPPublicKey.EC || algorithm == PGPPublicKey.ECDSA) {
    this.algorithm=""String_Node_Str"";
  }
 else {
    this.algorithm=""String_Node_Str"";
  }
}",0.9935897435897436
8409,"@Override public Loader<Cursor> onCreateLoader(int id,Bundle args){
  Uri baseUri=KeyRings.buildPublicKeyRingsUri();
  long now=new Date().getTime() / 1000;
  String[] projection=new String[]{KeyRings._ID,KeyRings.MASTER_KEY_ID,UserIds.USER_ID,""String_Node_Str"" + Keys._ID + ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Keys.KEY_RING_ROW_ID+ ""String_Node_Str""+ KeychainDatabase.Tables.KEY_RINGS+ ""String_Node_Str""+ KeyRings._ID+ ""String_Node_Str""+ Keys.IS_REVOKED+ ""String_Node_Str""+ Keys.CAN_SIGN+ ""String_Node_Str""+ SelectKeyCursorAdapter.PROJECTION_ROW_AVAILABLE,""String_Node_Str"" + Keys._ID + ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Keys.KEY_RING_ROW_ID+ ""String_Node_Str""+ KeychainDatabase.Tables.KEY_RINGS+ ""String_Node_Str""+ KeyRings._ID+ ""String_Node_Str""+ Keys.IS_REVOKED+ ""String_Node_Str""+ Keys.CAN_SIGN+ ""String_Node_Str""+ Keys.CREATION+ ""String_Node_Str""+ now+ ""String_Node_Str""+ ""String_Node_Str""+ Keys.EXPIRY+ ""String_Node_Str""+ Keys.EXPIRY+ ""String_Node_Str""+ now+ ""String_Node_Str""+ SelectKeyCursorAdapter.PROJECTION_ROW_VALID};
  String orderBy=UserIds.USER_ID + ""String_Node_Str"";
  return new CursorLoader(getActivity(),baseUri,projection,null,null,orderBy);
}","@Override public Loader<Cursor> onCreateLoader(int id,Bundle args){
  Uri baseUri=KeyRings.buildSecretKeyRingsUri();
  long now=new Date().getTime() / 1000;
  String[] projection=new String[]{KeyRings._ID,KeyRings.MASTER_KEY_ID,UserIds.USER_ID,""String_Node_Str"" + Keys._ID + ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Keys.KEY_RING_ROW_ID+ ""String_Node_Str""+ KeychainDatabase.Tables.KEY_RINGS+ ""String_Node_Str""+ KeyRings._ID+ ""String_Node_Str""+ Keys.IS_REVOKED+ ""String_Node_Str""+ Keys.CAN_SIGN+ ""String_Node_Str""+ SelectKeyCursorAdapter.PROJECTION_ROW_AVAILABLE,""String_Node_Str"" + Keys._ID + ""String_Node_Str""+ Tables.KEYS+ ""String_Node_Str""+ Keys.KEY_RING_ROW_ID+ ""String_Node_Str""+ KeychainDatabase.Tables.KEY_RINGS+ ""String_Node_Str""+ KeyRings._ID+ ""String_Node_Str""+ Keys.IS_REVOKED+ ""String_Node_Str""+ Keys.CAN_SIGN+ ""String_Node_Str""+ Keys.CREATION+ ""String_Node_Str""+ now+ ""String_Node_Str""+ ""String_Node_Str""+ Keys.EXPIRY+ ""String_Node_Str""+ Keys.EXPIRY+ ""String_Node_Str""+ now+ ""String_Node_Str""+ SelectKeyCursorAdapter.PROJECTION_ROW_VALID};
  System.out.println(projection);
  String orderBy=UserIds.USER_ID + ""String_Node_Str"";
  return new CursorLoader(getActivity(),baseUri,projection,null,null,orderBy);
}",0.9818780889621088
8410,"/** 
 * Converts Vector<PGPSecretKey> to a byte[]
 * @param keys
 * @return
 */
public static byte[] PGPSecretKeyListToBytes(Vector<PGPSecretKey> keys){
  ByteArrayOutputStream os=new ByteArrayOutputStream();
  for (  PGPSecretKey key : keys) {
    try {
      key.encode(os);
    }
 catch (    IOException e) {
      Log.e(Constants.TAG,""String_Node_Str"",e);
    }
  }
  byte[] keysBytes=os.toByteArray();
  return keysBytes;
}","/** 
 * Converts Vector<PGPSecretKey> to a byte[]
 * @param keys
 * @return
 */
public static byte[] PGPSecretKeyListToBytes(ArrayList<PGPSecretKey> keys){
  ByteArrayOutputStream os=new ByteArrayOutputStream();
  for (  PGPSecretKey key : keys) {
    try {
      key.encode(os);
    }
 catch (    IOException e) {
      Log.e(Constants.TAG,""String_Node_Str"",e);
    }
  }
  byte[] keysBytes=os.toByteArray();
  return keysBytes;
}",0.9825378346915018
8411,"public static void signText(Context context,InputData data,OutputStream outStream,long signatureKeyId,String signaturePassPhrase,int hashAlgorithm,boolean forceV3Signature,ProgressDialogUpdater progress) throws GeneralException, PGPException, IOException, NoSuchAlgorithmException, SignatureException {
  ArmoredOutputStream armorOut=new ArmoredOutputStream(outStream);
  armorOut.setHeader(""String_Node_Str"",getFullVersion(context));
  PGPSecretKey signingKey=null;
  PGPSecretKeyRing signingKeyRing=null;
  PGPPrivateKey signaturePrivateKey=null;
  if (signatureKeyId == 0) {
    armorOut.close();
    throw new GeneralException(context.getString(R.string.error_noSignatureKey));
  }
  signingKeyRing=getSecretKeyRing(signatureKeyId);
  signingKey=PGPHelper.getSigningKey(signatureKeyId);
  if (signingKey == null) {
    armorOut.close();
    throw new GeneralException(context.getString(R.string.error_signatureFailed));
  }
  if (signaturePassPhrase == null) {
    armorOut.close();
    throw new GeneralException(context.getString(R.string.error_noSignaturePassPhrase));
  }
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(signaturePassPhrase.toCharArray());
  signaturePrivateKey=signingKey.extractPrivateKey(keyDecryptor);
  if (signaturePrivateKey == null) {
    armorOut.close();
    throw new GeneralException(context.getString(R.string.error_couldNotExtractPrivateKey));
  }
  if (progress != null)   progress.setProgress(R.string.progress_preparingStreams,0,100);
  if (progress != null)   progress.setProgress(R.string.progress_preparingSignature,30,100);
  PGPSignatureGenerator signatureGenerator=null;
  PGPV3SignatureGenerator signatureV3Generator=null;
  JcaPGPContentSignerBuilder contentSignerBuilder=new JcaPGPContentSignerBuilder(signingKey.getPublicKey().getAlgorithm(),hashAlgorithm).setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
  if (forceV3Signature) {
    signatureV3Generator=new PGPV3SignatureGenerator(contentSignerBuilder);
    signatureV3Generator.init(PGPSignature.CANONICAL_TEXT_DOCUMENT,signaturePrivateKey);
  }
 else {
    signatureGenerator=new PGPSignatureGenerator(contentSignerBuilder);
    signatureGenerator.init(PGPSignature.CANONICAL_TEXT_DOCUMENT,signaturePrivateKey);
    PGPSignatureSubpacketGenerator spGen=new PGPSignatureSubpacketGenerator();
    String userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(signingKeyRing));
    spGen.setSignerUserID(false,userId);
    signatureGenerator.setHashedSubpackets(spGen.generate());
  }
  if (progress != null)   progress.setProgress(R.string.progress_signing,40,100);
  armorOut.beginClearText(hashAlgorithm);
  InputStream inStream=data.getInputStream();
  final BufferedReader reader=new BufferedReader(new InputStreamReader(inStream));
  final byte[] newline=""String_Node_Str"".getBytes(""String_Node_Str"");
  if (forceV3Signature) {
    processLine(reader.readLine(),armorOut,signatureV3Generator);
  }
 else {
    processLine(reader.readLine(),armorOut,signatureGenerator);
  }
  while (true) {
    final String line=reader.readLine();
    if (line == null) {
      armorOut.write(newline);
      break;
    }
    armorOut.write(newline);
    if (forceV3Signature) {
      signatureV3Generator.update(newline);
      processLine(line,armorOut,signatureV3Generator);
    }
 else {
      signatureGenerator.update(newline);
      processLine(line,armorOut,signatureGenerator);
    }
  }
  armorOut.endClearText();
  BCPGOutputStream bOut=new BCPGOutputStream(armorOut);
  if (forceV3Signature) {
    signatureV3Generator.generate().encode(bOut);
  }
 else {
    signatureGenerator.generate().encode(bOut);
  }
  armorOut.close();
  if (progress != null)   progress.setProgress(R.string.progress_done,100,100);
}","public static void signText(Context context,InputData data,OutputStream outStream,long signatureKeyId,String signaturePassPhrase,int hashAlgorithm,boolean forceV3Signature,ProgressDialogUpdater progress) throws GeneralException, PGPException, IOException, NoSuchAlgorithmException, SignatureException {
  ArmoredOutputStream armorOut=new ArmoredOutputStream(outStream);
  armorOut.setHeader(""String_Node_Str"",getFullVersion(context));
  PGPSecretKey signingKey=null;
  PGPSecretKeyRing signingKeyRing=null;
  PGPPrivateKey signaturePrivateKey=null;
  if (signatureKeyId == 0) {
    armorOut.close();
    throw new GeneralException(context.getString(R.string.error_noSignatureKey));
  }
  signingKeyRing=getSecretKeyRing(signatureKeyId);
  signingKey=PGPHelper.getSigningKey(signatureKeyId);
  if (signingKey == null) {
    armorOut.close();
    throw new GeneralException(context.getString(R.string.error_signatureFailed));
  }
  if (signaturePassPhrase == null) {
    armorOut.close();
    throw new GeneralException(context.getString(R.string.error_noSignaturePassPhrase));
  }
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(signaturePassPhrase.toCharArray());
  signaturePrivateKey=signingKey.extractPrivateKey(keyDecryptor);
  if (signaturePrivateKey == null) {
    armorOut.close();
    throw new GeneralException(context.getString(R.string.error_couldNotExtractPrivateKey));
  }
  updateProgress(progress,R.string.progress_preparingStreams,0,100);
  updateProgress(progress,R.string.progress_preparingSignature,30,100);
  PGPSignatureGenerator signatureGenerator=null;
  PGPV3SignatureGenerator signatureV3Generator=null;
  JcaPGPContentSignerBuilder contentSignerBuilder=new JcaPGPContentSignerBuilder(signingKey.getPublicKey().getAlgorithm(),hashAlgorithm).setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
  if (forceV3Signature) {
    signatureV3Generator=new PGPV3SignatureGenerator(contentSignerBuilder);
    signatureV3Generator.init(PGPSignature.CANONICAL_TEXT_DOCUMENT,signaturePrivateKey);
  }
 else {
    signatureGenerator=new PGPSignatureGenerator(contentSignerBuilder);
    signatureGenerator.init(PGPSignature.CANONICAL_TEXT_DOCUMENT,signaturePrivateKey);
    PGPSignatureSubpacketGenerator spGen=new PGPSignatureSubpacketGenerator();
    String userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(signingKeyRing));
    spGen.setSignerUserID(false,userId);
    signatureGenerator.setHashedSubpackets(spGen.generate());
  }
  updateProgress(progress,R.string.progress_signing,40,100);
  armorOut.beginClearText(hashAlgorithm);
  InputStream inStream=data.getInputStream();
  final BufferedReader reader=new BufferedReader(new InputStreamReader(inStream));
  final byte[] newline=""String_Node_Str"".getBytes(""String_Node_Str"");
  if (forceV3Signature) {
    processLine(reader.readLine(),armorOut,signatureV3Generator);
  }
 else {
    processLine(reader.readLine(),armorOut,signatureGenerator);
  }
  while (true) {
    final String line=reader.readLine();
    if (line == null) {
      armorOut.write(newline);
      break;
    }
    armorOut.write(newline);
    if (forceV3Signature) {
      signatureV3Generator.update(newline);
      processLine(line,armorOut,signatureV3Generator);
    }
 else {
      signatureGenerator.update(newline);
      processLine(line,armorOut,signatureGenerator);
    }
  }
  armorOut.endClearText();
  BCPGOutputStream bOut=new BCPGOutputStream(armorOut);
  if (forceV3Signature) {
    signatureV3Generator.generate().encode(bOut);
  }
 else {
    signatureGenerator.generate().encode(bOut);
  }
  armorOut.close();
  updateProgress(progress,R.string.progress_done,100,100);
}",0.9630917357582242
8412,"public static void encrypt(Context context,InputData data,OutputStream outStream,boolean armored,long encryptionKeyIds[],long signatureKeyId,String signaturePassPhrase,ProgressDialogUpdater progress,int symmetricAlgorithm,int hashAlgorithm,int compression,boolean forceV3Signature,String passPhrase) throws IOException, GeneralException, PGPException, NoSuchProviderException, NoSuchAlgorithmException, SignatureException {
  if (encryptionKeyIds == null) {
    encryptionKeyIds=new long[0];
  }
  ArmoredOutputStream armorOut=null;
  OutputStream out=null;
  OutputStream encryptOut=null;
  if (armored) {
    armorOut=new ArmoredOutputStream(outStream);
    armorOut.setHeader(""String_Node_Str"",getFullVersion(context));
    out=armorOut;
  }
 else {
    out=outStream;
  }
  PGPSecretKey signingKey=null;
  PGPSecretKeyRing signingKeyRing=null;
  PGPPrivateKey signaturePrivateKey=null;
  if (encryptionKeyIds.length == 0 && passPhrase == null) {
    throw new GeneralException(context.getString(R.string.error_noEncryptionKeysOrPassPhrase));
  }
  if (signatureKeyId != Id.key.none) {
    signingKeyRing=getSecretKeyRing(signatureKeyId);
    signingKey=PGPHelper.getSigningKey(signatureKeyId);
    if (signingKey == null) {
      throw new GeneralException(context.getString(R.string.error_signatureFailed));
    }
    if (signaturePassPhrase == null) {
      throw new GeneralException(context.getString(R.string.error_noSignaturePassPhrase));
    }
    if (progress != null)     progress.setProgress(R.string.progress_extractingSignatureKey,0,100);
    PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(signaturePassPhrase.toCharArray());
    signaturePrivateKey=signingKey.extractPrivateKey(keyDecryptor);
    if (signaturePrivateKey == null) {
      throw new GeneralException(context.getString(R.string.error_couldNotExtractPrivateKey));
    }
  }
  if (progress != null)   progress.setProgress(R.string.progress_preparingStreams,5,100);
  JcePGPDataEncryptorBuilder encryptorBuilder=new JcePGPDataEncryptorBuilder(symmetricAlgorithm).setProvider(BOUNCY_CASTLE_PROVIDER_NAME).setWithIntegrityPacket(true);
  PGPEncryptedDataGenerator cPk=new PGPEncryptedDataGenerator(encryptorBuilder);
  if (encryptionKeyIds.length == 0) {
    Log.d(Constants.TAG,""String_Node_Str"");
    JcePBEKeyEncryptionMethodGenerator symmetricEncryptionGenerator=new JcePBEKeyEncryptionMethodGenerator(passPhrase.toCharArray());
    cPk.addMethod(symmetricEncryptionGenerator);
  }
  for (int i=0; i < encryptionKeyIds.length; ++i) {
    PGPPublicKey key=PGPHelper.getEncryptPublicKey(encryptionKeyIds[i]);
    if (key != null) {
      JcePublicKeyKeyEncryptionMethodGenerator pubKeyEncryptionGenerator=new JcePublicKeyKeyEncryptionMethodGenerator(key);
      cPk.addMethod(pubKeyEncryptionGenerator);
    }
  }
  encryptOut=cPk.open(out,new byte[1 << 16]);
  PGPSignatureGenerator signatureGenerator=null;
  PGPV3SignatureGenerator signatureV3Generator=null;
  if (signatureKeyId != Id.key.none) {
    if (progress != null)     progress.setProgress(R.string.progress_preparingSignature,10,100);
    JcaPGPContentSignerBuilder contentSignerBuilder=new JcaPGPContentSignerBuilder(signingKey.getPublicKey().getAlgorithm(),hashAlgorithm).setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
    if (forceV3Signature) {
      signatureV3Generator=new PGPV3SignatureGenerator(contentSignerBuilder);
      signatureV3Generator.init(PGPSignature.BINARY_DOCUMENT,signaturePrivateKey);
    }
 else {
      signatureGenerator=new PGPSignatureGenerator(contentSignerBuilder);
      signatureGenerator.init(PGPSignature.BINARY_DOCUMENT,signaturePrivateKey);
      String userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(signingKeyRing));
      PGPSignatureSubpacketGenerator spGen=new PGPSignatureSubpacketGenerator();
      spGen.setSignerUserID(false,userId);
      signatureGenerator.setHashedSubpackets(spGen.generate());
    }
  }
  PGPCompressedDataGenerator compressGen=null;
  BCPGOutputStream bcpgOut=null;
  if (compression == Id.choice.compression.none) {
    bcpgOut=new BCPGOutputStream(encryptOut);
  }
 else {
    compressGen=new PGPCompressedDataGenerator(compression);
    bcpgOut=new BCPGOutputStream(compressGen.open(encryptOut));
  }
  if (signatureKeyId != Id.key.none) {
    if (forceV3Signature) {
      signatureV3Generator.generateOnePassVersion(false).encode(bcpgOut);
    }
 else {
      signatureGenerator.generateOnePassVersion(false).encode(bcpgOut);
    }
  }
  PGPLiteralDataGenerator literalGen=new PGPLiteralDataGenerator();
  OutputStream pOut=literalGen.open(bcpgOut,PGPLiteralData.BINARY,""String_Node_Str"",new Date(),new byte[1 << 16]);
  if (progress != null)   progress.setProgress(R.string.progress_encrypting,20,100);
  long done=0;
  int n=0;
  byte[] buffer=new byte[1 << 16];
  InputStream in=data.getInputStream();
  while ((n=in.read(buffer)) > 0) {
    pOut.write(buffer,0,n);
    if (signatureKeyId != Id.key.none) {
      if (forceV3Signature) {
        signatureV3Generator.update(buffer,0,n);
      }
 else {
        signatureGenerator.update(buffer,0,n);
      }
    }
    done+=n;
    if (data.getSize() != 0) {
      if (progress != null)       progress.setProgress((int)(20 + (95 - 20) * done / data.getSize()),100);
    }
  }
  literalGen.close();
  if (signatureKeyId != Id.key.none) {
    if (progress != null)     progress.setProgress(R.string.progress_generatingSignature,95,100);
    if (forceV3Signature) {
      signatureV3Generator.generate().encode(pOut);
    }
 else {
      signatureGenerator.generate().encode(pOut);
    }
  }
  if (compressGen != null) {
    compressGen.close();
  }
  encryptOut.close();
  if (armored) {
    armorOut.close();
  }
  if (progress != null)   progress.setProgress(R.string.progress_done,100,100);
}","public static void encrypt(Context context,InputData data,OutputStream outStream,boolean armored,long encryptionKeyIds[],long signatureKeyId,String signaturePassPhrase,ProgressDialogUpdater progress,int symmetricAlgorithm,int hashAlgorithm,int compression,boolean forceV3Signature,String passPhrase) throws IOException, GeneralException, PGPException, NoSuchProviderException, NoSuchAlgorithmException, SignatureException {
  if (encryptionKeyIds == null) {
    encryptionKeyIds=new long[0];
  }
  ArmoredOutputStream armorOut=null;
  OutputStream out=null;
  OutputStream encryptOut=null;
  if (armored) {
    armorOut=new ArmoredOutputStream(outStream);
    armorOut.setHeader(""String_Node_Str"",getFullVersion(context));
    out=armorOut;
  }
 else {
    out=outStream;
  }
  PGPSecretKey signingKey=null;
  PGPSecretKeyRing signingKeyRing=null;
  PGPPrivateKey signaturePrivateKey=null;
  if (encryptionKeyIds.length == 0 && passPhrase == null) {
    throw new GeneralException(context.getString(R.string.error_noEncryptionKeysOrPassPhrase));
  }
  if (signatureKeyId != Id.key.none) {
    signingKeyRing=getSecretKeyRing(signatureKeyId);
    signingKey=PGPHelper.getSigningKey(signatureKeyId);
    if (signingKey == null) {
      throw new GeneralException(context.getString(R.string.error_signatureFailed));
    }
    if (signaturePassPhrase == null) {
      throw new GeneralException(context.getString(R.string.error_noSignaturePassPhrase));
    }
    if (progress != null)     progress.setProgress(R.string.progress_extractingSignatureKey,0,100);
    PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(signaturePassPhrase.toCharArray());
    signaturePrivateKey=signingKey.extractPrivateKey(keyDecryptor);
    if (signaturePrivateKey == null) {
      throw new GeneralException(context.getString(R.string.error_couldNotExtractPrivateKey));
    }
  }
  updateProgress(progress,R.string.progress_preparingStreams,5,100);
  JcePGPDataEncryptorBuilder encryptorBuilder=new JcePGPDataEncryptorBuilder(symmetricAlgorithm).setProvider(BOUNCY_CASTLE_PROVIDER_NAME).setWithIntegrityPacket(true);
  PGPEncryptedDataGenerator cPk=new PGPEncryptedDataGenerator(encryptorBuilder);
  if (encryptionKeyIds.length == 0) {
    Log.d(Constants.TAG,""String_Node_Str"");
    JcePBEKeyEncryptionMethodGenerator symmetricEncryptionGenerator=new JcePBEKeyEncryptionMethodGenerator(passPhrase.toCharArray());
    cPk.addMethod(symmetricEncryptionGenerator);
  }
  for (int i=0; i < encryptionKeyIds.length; ++i) {
    PGPPublicKey key=PGPHelper.getEncryptPublicKey(encryptionKeyIds[i]);
    if (key != null) {
      JcePublicKeyKeyEncryptionMethodGenerator pubKeyEncryptionGenerator=new JcePublicKeyKeyEncryptionMethodGenerator(key);
      cPk.addMethod(pubKeyEncryptionGenerator);
    }
  }
  encryptOut=cPk.open(out,new byte[1 << 16]);
  PGPSignatureGenerator signatureGenerator=null;
  PGPV3SignatureGenerator signatureV3Generator=null;
  if (signatureKeyId != Id.key.none) {
    if (progress != null)     progress.setProgress(R.string.progress_preparingSignature,10,100);
    JcaPGPContentSignerBuilder contentSignerBuilder=new JcaPGPContentSignerBuilder(signingKey.getPublicKey().getAlgorithm(),hashAlgorithm).setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
    if (forceV3Signature) {
      signatureV3Generator=new PGPV3SignatureGenerator(contentSignerBuilder);
      signatureV3Generator.init(PGPSignature.BINARY_DOCUMENT,signaturePrivateKey);
    }
 else {
      signatureGenerator=new PGPSignatureGenerator(contentSignerBuilder);
      signatureGenerator.init(PGPSignature.BINARY_DOCUMENT,signaturePrivateKey);
      String userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(signingKeyRing));
      PGPSignatureSubpacketGenerator spGen=new PGPSignatureSubpacketGenerator();
      spGen.setSignerUserID(false,userId);
      signatureGenerator.setHashedSubpackets(spGen.generate());
    }
  }
  PGPCompressedDataGenerator compressGen=null;
  BCPGOutputStream bcpgOut=null;
  if (compression == Id.choice.compression.none) {
    bcpgOut=new BCPGOutputStream(encryptOut);
  }
 else {
    compressGen=new PGPCompressedDataGenerator(compression);
    bcpgOut=new BCPGOutputStream(compressGen.open(encryptOut));
  }
  if (signatureKeyId != Id.key.none) {
    if (forceV3Signature) {
      signatureV3Generator.generateOnePassVersion(false).encode(bcpgOut);
    }
 else {
      signatureGenerator.generateOnePassVersion(false).encode(bcpgOut);
    }
  }
  PGPLiteralDataGenerator literalGen=new PGPLiteralDataGenerator();
  OutputStream pOut=literalGen.open(bcpgOut,PGPLiteralData.BINARY,""String_Node_Str"",new Date(),new byte[1 << 16]);
  updateProgress(progress,R.string.progress_encrypting,20,100);
  long done=0;
  int n=0;
  byte[] buffer=new byte[1 << 16];
  InputStream in=data.getInputStream();
  while ((n=in.read(buffer)) > 0) {
    pOut.write(buffer,0,n);
    if (signatureKeyId != Id.key.none) {
      if (forceV3Signature) {
        signatureV3Generator.update(buffer,0,n);
      }
 else {
        signatureGenerator.update(buffer,0,n);
      }
    }
    done+=n;
    if (data.getSize() != 0) {
      updateProgress(progress,(int)(20 + (95 - 20) * done / data.getSize()),100);
    }
  }
  literalGen.close();
  if (signatureKeyId != Id.key.none) {
    updateProgress(progress,R.string.progress_generatingSignature,95,100);
    if (forceV3Signature) {
      signatureV3Generator.generate().encode(pOut);
    }
 else {
      signatureGenerator.generate().encode(pOut);
    }
  }
  if (compressGen != null) {
    compressGen.close();
  }
  encryptOut.close();
  if (armored) {
    armorOut.close();
  }
  updateProgress(progress,R.string.progress_done,100,100);
}",0.96962879640045
8413,"public static void generateSignature(Context context,InputData data,OutputStream outStream,boolean armored,boolean binary,long signatureKeyId,String signaturePassPhrase,int hashAlgorithm,boolean forceV3Signature,ProgressDialogUpdater progress) throws GeneralException, PGPException, IOException, NoSuchAlgorithmException, SignatureException {
  OutputStream out=null;
  ArmoredOutputStream armorOut=null;
  if (armored) {
    armorOut=new ArmoredOutputStream(outStream);
    armorOut.setHeader(""String_Node_Str"",getFullVersion(context));
    out=armorOut;
  }
 else {
    out=outStream;
  }
  PGPSecretKey signingKey=null;
  PGPSecretKeyRing signingKeyRing=null;
  PGPPrivateKey signaturePrivateKey=null;
  if (signatureKeyId == 0) {
    throw new GeneralException(context.getString(R.string.error_noSignatureKey));
  }
  signingKeyRing=getSecretKeyRing(signatureKeyId);
  signingKey=PGPHelper.getSigningKey(signatureKeyId);
  if (signingKey == null) {
    throw new GeneralException(context.getString(R.string.error_signatureFailed));
  }
  if (signaturePassPhrase == null) {
    throw new GeneralException(context.getString(R.string.error_noSignaturePassPhrase));
  }
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(signaturePassPhrase.toCharArray());
  signaturePrivateKey=signingKey.extractPrivateKey(keyDecryptor);
  if (signaturePrivateKey == null) {
    throw new GeneralException(context.getString(R.string.error_couldNotExtractPrivateKey));
  }
  if (progress != null)   progress.setProgress(R.string.progress_preparingStreams,0,100);
  if (progress != null)   progress.setProgress(R.string.progress_preparingSignature,30,100);
  PGPSignatureGenerator signatureGenerator=null;
  PGPV3SignatureGenerator signatureV3Generator=null;
  int type=PGPSignature.CANONICAL_TEXT_DOCUMENT;
  if (binary) {
    type=PGPSignature.BINARY_DOCUMENT;
  }
  JcaPGPContentSignerBuilder contentSignerBuilder=new JcaPGPContentSignerBuilder(signingKey.getPublicKey().getAlgorithm(),hashAlgorithm).setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
  if (forceV3Signature) {
    signatureV3Generator=new PGPV3SignatureGenerator(contentSignerBuilder);
    signatureV3Generator.init(type,signaturePrivateKey);
  }
 else {
    signatureGenerator=new PGPSignatureGenerator(contentSignerBuilder);
    signatureGenerator.init(type,signaturePrivateKey);
    PGPSignatureSubpacketGenerator spGen=new PGPSignatureSubpacketGenerator();
    String userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(signingKeyRing));
    spGen.setSignerUserID(false,userId);
    signatureGenerator.setHashedSubpackets(spGen.generate());
  }
  if (progress != null)   progress.setProgress(R.string.progress_signing,40,100);
  InputStream inStream=data.getInputStream();
  if (binary) {
    byte[] buffer=new byte[1 << 16];
    int n=0;
    while ((n=inStream.read(buffer)) > 0) {
      if (forceV3Signature) {
        signatureV3Generator.update(buffer,0,n);
      }
 else {
        signatureGenerator.update(buffer,0,n);
      }
    }
  }
 else {
    final BufferedReader reader=new BufferedReader(new InputStreamReader(inStream));
    final byte[] newline=""String_Node_Str"".getBytes(""String_Node_Str"");
    while (true) {
      final String line=reader.readLine();
      if (line == null) {
        break;
      }
      if (forceV3Signature) {
        processLine(line,null,signatureV3Generator);
        signatureV3Generator.update(newline);
      }
 else {
        processLine(line,null,signatureGenerator);
        signatureGenerator.update(newline);
      }
    }
  }
  BCPGOutputStream bOut=new BCPGOutputStream(out);
  if (forceV3Signature) {
    signatureV3Generator.generate().encode(bOut);
  }
 else {
    signatureGenerator.generate().encode(bOut);
  }
  out.close();
  outStream.close();
  if (progress != null)   progress.setProgress(R.string.progress_done,100,100);
}","public static void generateSignature(Context context,InputData data,OutputStream outStream,boolean armored,boolean binary,long signatureKeyId,String signaturePassPhrase,int hashAlgorithm,boolean forceV3Signature,ProgressDialogUpdater progress) throws GeneralException, PGPException, IOException, NoSuchAlgorithmException, SignatureException {
  OutputStream out=null;
  ArmoredOutputStream armorOut=null;
  if (armored) {
    armorOut=new ArmoredOutputStream(outStream);
    armorOut.setHeader(""String_Node_Str"",getFullVersion(context));
    out=armorOut;
  }
 else {
    out=outStream;
  }
  PGPSecretKey signingKey=null;
  PGPSecretKeyRing signingKeyRing=null;
  PGPPrivateKey signaturePrivateKey=null;
  if (signatureKeyId == 0) {
    throw new GeneralException(context.getString(R.string.error_noSignatureKey));
  }
  signingKeyRing=getSecretKeyRing(signatureKeyId);
  signingKey=PGPHelper.getSigningKey(signatureKeyId);
  if (signingKey == null) {
    throw new GeneralException(context.getString(R.string.error_signatureFailed));
  }
  if (signaturePassPhrase == null) {
    throw new GeneralException(context.getString(R.string.error_noSignaturePassPhrase));
  }
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(signaturePassPhrase.toCharArray());
  signaturePrivateKey=signingKey.extractPrivateKey(keyDecryptor);
  if (signaturePrivateKey == null) {
    throw new GeneralException(context.getString(R.string.error_couldNotExtractPrivateKey));
  }
  updateProgress(progress,R.string.progress_preparingStreams,0,100);
  updateProgress(progress,R.string.progress_preparingSignature,30,100);
  PGPSignatureGenerator signatureGenerator=null;
  PGPV3SignatureGenerator signatureV3Generator=null;
  int type=PGPSignature.CANONICAL_TEXT_DOCUMENT;
  if (binary) {
    type=PGPSignature.BINARY_DOCUMENT;
  }
  JcaPGPContentSignerBuilder contentSignerBuilder=new JcaPGPContentSignerBuilder(signingKey.getPublicKey().getAlgorithm(),hashAlgorithm).setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
  if (forceV3Signature) {
    signatureV3Generator=new PGPV3SignatureGenerator(contentSignerBuilder);
    signatureV3Generator.init(type,signaturePrivateKey);
  }
 else {
    signatureGenerator=new PGPSignatureGenerator(contentSignerBuilder);
    signatureGenerator.init(type,signaturePrivateKey);
    PGPSignatureSubpacketGenerator spGen=new PGPSignatureSubpacketGenerator();
    String userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(signingKeyRing));
    spGen.setSignerUserID(false,userId);
    signatureGenerator.setHashedSubpackets(spGen.generate());
  }
  updateProgress(progress,R.string.progress_signing,40,100);
  InputStream inStream=data.getInputStream();
  if (binary) {
    byte[] buffer=new byte[1 << 16];
    int n=0;
    while ((n=inStream.read(buffer)) > 0) {
      if (forceV3Signature) {
        signatureV3Generator.update(buffer,0,n);
      }
 else {
        signatureGenerator.update(buffer,0,n);
      }
    }
  }
 else {
    final BufferedReader reader=new BufferedReader(new InputStreamReader(inStream));
    final byte[] newline=""String_Node_Str"".getBytes(""String_Node_Str"");
    while (true) {
      final String line=reader.readLine();
      if (line == null) {
        break;
      }
      if (forceV3Signature) {
        processLine(line,null,signatureV3Generator);
        signatureV3Generator.update(newline);
      }
 else {
        processLine(line,null,signatureGenerator);
        signatureGenerator.update(newline);
      }
    }
  }
  BCPGOutputStream bOut=new BCPGOutputStream(out);
  if (forceV3Signature) {
    signatureV3Generator.generate().encode(bOut);
  }
 else {
    signatureGenerator.generate().encode(bOut);
  }
  out.close();
  outStream.close();
  if (progress != null)   progress.setProgress(R.string.progress_done,100,100);
}",0.973293768545994
8414,"public static Bundle verifyText(Context context,InputData data,OutputStream outStream,boolean lookupUnknownKey,ProgressDialogUpdater progress) throws IOException, GeneralException, PGPException, SignatureException {
  Bundle returnData=new Bundle();
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ArmoredInputStream aIn=new ArmoredInputStream(data.getInputStream());
  if (progress != null)   progress.setProgress(R.string.progress_done,0,100);
  ByteArrayOutputStream lineOut=new ByteArrayOutputStream();
  int lookAhead=readInputLine(lineOut,aIn);
  byte[] lineSep=getLineSeparator();
  byte[] line=lineOut.toByteArray();
  out.write(line,0,getLengthWithoutSeparator(line));
  out.write(lineSep);
  while (lookAhead != -1 && aIn.isClearText()) {
    lookAhead=readInputLine(lineOut,lookAhead,aIn);
    line=lineOut.toByteArray();
    out.write(line,0,getLengthWithoutSeparator(line));
    out.write(lineSep);
  }
  out.close();
  byte[] clearText=out.toByteArray();
  outStream.write(clearText);
  returnData.putBoolean(ApgService.RESULT_SIGNATURE,true);
  if (progress != null)   progress.setProgress(R.string.progress_processingSignature,60,100);
  PGPObjectFactory pgpFact=new PGPObjectFactory(aIn);
  PGPSignatureList sigList=(PGPSignatureList)pgpFact.nextObject();
  if (sigList == null) {
    throw new GeneralException(context.getString(R.string.error_corruptData));
  }
  PGPSignature signature=null;
  long signatureKeyId=0;
  PGPPublicKey signatureKey=null;
  for (int i=0; i < sigList.size(); ++i) {
    signature=sigList.get(i);
    signatureKey=getPublicKey(signature.getKeyID());
    if (signatureKeyId == 0) {
      signatureKeyId=signature.getKeyID();
    }
    if (signatureKey == null && lookupUnknownKey) {
      returnData=new Bundle();
      returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
      returnData.putBoolean(ApgService.RESULT_SIGNATURE_LOOKUP_KEY,true);
      return returnData;
    }
    if (signatureKey == null) {
      signature=null;
    }
 else {
      signatureKeyId=signature.getKeyID();
      String userId=null;
      PGPPublicKeyRing sigKeyRing=getPublicKeyRing(signatureKeyId);
      if (sigKeyRing != null) {
        userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(sigKeyRing));
      }
      returnData.putString(ApgService.RESULT_SIGNATURE_USER_ID,userId);
      break;
    }
  }
  returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
  if (signature == null) {
    returnData.putBoolean(ApgService.RESULT_SIGNATURE_UNKNOWN,true);
    if (progress != null)     progress.setProgress(R.string.progress_done,100,100);
    return returnData;
  }
  JcaPGPContentVerifierBuilderProvider contentVerifierBuilderProvider=new JcaPGPContentVerifierBuilderProvider().setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
  signature.init(contentVerifierBuilderProvider,signatureKey);
  InputStream sigIn=new BufferedInputStream(new ByteArrayInputStream(clearText));
  lookAhead=readInputLine(lineOut,sigIn);
  processLine(signature,lineOut.toByteArray());
  if (lookAhead != -1) {
    do {
      lookAhead=readInputLine(lineOut,lookAhead,sigIn);
      signature.update((byte)'\r');
      signature.update((byte)'\n');
      processLine(signature,lineOut.toByteArray());
    }
 while (lookAhead != -1);
  }
  returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,signature.verify());
  if (progress != null)   progress.setProgress(R.string.progress_done,100,100);
  return returnData;
}","public static Bundle verifyText(Context context,InputData data,OutputStream outStream,boolean lookupUnknownKey,ProgressDialogUpdater progress) throws IOException, GeneralException, PGPException, SignatureException {
  Bundle returnData=new Bundle();
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ArmoredInputStream aIn=new ArmoredInputStream(data.getInputStream());
  updateProgress(progress,R.string.progress_done,0,100);
  ByteArrayOutputStream lineOut=new ByteArrayOutputStream();
  int lookAhead=readInputLine(lineOut,aIn);
  byte[] lineSep=getLineSeparator();
  byte[] line=lineOut.toByteArray();
  out.write(line,0,getLengthWithoutSeparator(line));
  out.write(lineSep);
  while (lookAhead != -1 && aIn.isClearText()) {
    lookAhead=readInputLine(lineOut,lookAhead,aIn);
    line=lineOut.toByteArray();
    out.write(line,0,getLengthWithoutSeparator(line));
    out.write(lineSep);
  }
  out.close();
  byte[] clearText=out.toByteArray();
  outStream.write(clearText);
  returnData.putBoolean(ApgService.RESULT_SIGNATURE,true);
  updateProgress(progress,R.string.progress_processingSignature,60,100);
  PGPObjectFactory pgpFact=new PGPObjectFactory(aIn);
  PGPSignatureList sigList=(PGPSignatureList)pgpFact.nextObject();
  if (sigList == null) {
    throw new GeneralException(context.getString(R.string.error_corruptData));
  }
  PGPSignature signature=null;
  long signatureKeyId=0;
  PGPPublicKey signatureKey=null;
  for (int i=0; i < sigList.size(); ++i) {
    signature=sigList.get(i);
    signatureKey=getPublicKey(signature.getKeyID());
    if (signatureKeyId == 0) {
      signatureKeyId=signature.getKeyID();
    }
    if (signatureKey == null && lookupUnknownKey) {
      returnData=new Bundle();
      returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
      returnData.putBoolean(ApgService.RESULT_SIGNATURE_LOOKUP_KEY,true);
      return returnData;
    }
    if (signatureKey == null) {
      signature=null;
    }
 else {
      signatureKeyId=signature.getKeyID();
      String userId=null;
      PGPPublicKeyRing sigKeyRing=getPublicKeyRing(signatureKeyId);
      if (sigKeyRing != null) {
        userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(sigKeyRing));
      }
      returnData.putString(ApgService.RESULT_SIGNATURE_USER_ID,userId);
      break;
    }
  }
  returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
  if (signature == null) {
    returnData.putBoolean(ApgService.RESULT_SIGNATURE_UNKNOWN,true);
    if (progress != null)     progress.setProgress(R.string.progress_done,100,100);
    return returnData;
  }
  JcaPGPContentVerifierBuilderProvider contentVerifierBuilderProvider=new JcaPGPContentVerifierBuilderProvider().setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
  signature.init(contentVerifierBuilderProvider,signatureKey);
  InputStream sigIn=new BufferedInputStream(new ByteArrayInputStream(clearText));
  lookAhead=readInputLine(lineOut,sigIn);
  processLine(signature,lineOut.toByteArray());
  if (lookAhead != -1) {
    do {
      lookAhead=readInputLine(lineOut,lookAhead,sigIn);
      signature.update((byte)'\r');
      signature.update((byte)'\n');
      processLine(signature,lineOut.toByteArray());
    }
 while (lookAhead != -1);
  }
  returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,signature.verify());
  updateProgress(progress,R.string.progress_done,100,100);
  return returnData;
}",0.9699171632030228
8415,"public static void buildSecretKey(Context context,ArrayList<String> userIds,ArrayList<PGPSecretKey> keys,ArrayList<Integer> keysUsages,long masterKeyId,String oldPassPhrase,String newPassPhrase,ProgressDialogUpdater progress) throws PGPMain.GeneralException, NoSuchProviderException, PGPException, NoSuchAlgorithmException, SignatureException, IOException, Database.GeneralException {
  if (progress != null)   progress.setProgress(R.string.progress_buildingKey,0,100);
  if (oldPassPhrase == null || oldPassPhrase.equals(""String_Node_Str"")) {
    oldPassPhrase=""String_Node_Str"";
  }
  if (newPassPhrase == null || newPassPhrase.equals(""String_Node_Str"")) {
    newPassPhrase=""String_Node_Str"";
  }
  if (progress != null)   progress.setProgress(R.string.progress_preparingMasterKey,10,100);
  int usageId=keysUsages.get(0);
  boolean canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
  boolean canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
  String mainUserId=userIds.get(0);
  PGPSecretKey masterKey=keys.get(0);
  PGPPublicKey masterPublicKey=masterKey.getPublicKey();
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
  PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(keyDecryptor);
  if (progress != null)   progress.setProgress(R.string.progress_certifyingMasterKey,20,100);
  for (int i=0; i < userIds.size(); ++i) {
    String userId=userIds.get(i);
    PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1).setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
    PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
    sGen.init(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
    PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
    masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,userId,certification);
  }
  PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
  PGPSignatureSubpacketGenerator hashedPacketsGen=new PGPSignatureSubpacketGenerator();
  PGPSignatureSubpacketGenerator unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
  int keyFlags=KeyFlags.CERTIFY_OTHER | KeyFlags.SIGN_DATA;
  if (canEncrypt) {
    keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
  }
  hashedPacketsGen.setKeyFlags(true,keyFlags);
  hashedPacketsGen.setPreferredSymmetricAlgorithms(true,PREFERRED_SYMMETRIC_ALGORITHMS);
  hashedPacketsGen.setPreferredHashAlgorithms(true,PREFERRED_HASH_ALGORITHMS);
  hashedPacketsGen.setPreferredCompressionAlgorithms(true,PREFERRED_COMPRESSION_ALGORITHMS);
  if (progress != null) {
    progress.setProgress(R.string.progress_buildingMasterKeyRing,30,100);
  }
  PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
  PGPContentSignerBuilder certificationSignerBuilder=new JcaPGPContentSignerBuilder(masterKeyPair.getPublicKey().getAlgorithm(),HashAlgorithmTags.SHA1);
  PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(newPassPhrase.toCharArray());
  PGPKeyRingGenerator keyGen=new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION,masterKeyPair,mainUserId,sha1Calc,hashedPacketsGen.generate(),unhashedPacketsGen.generate(),certificationSignerBuilder,keyEncryptor);
  if (progress != null)   progress.setProgress(R.string.progress_addingSubKeys,40,100);
  for (int i=1; i < keys.size(); ++i) {
    if (progress != null)     progress.setProgress(40 + 50 * (i - 1) / (keys.size() - 1),100);
    PGPSecretKey subKey=keys.get(i);
    PGPPublicKey subPublicKey=subKey.getPublicKey();
    PBESecretKeyDecryptor keyDecryptor2=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
    PGPPrivateKey subPrivateKey=subKey.extractPrivateKey(keyDecryptor2);
    PGPKeyPair subKeyPair=new PGPKeyPair(subPublicKey,subPrivateKey);
    hashedPacketsGen=new PGPSignatureSubpacketGenerator();
    unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
    keyFlags=0;
    usageId=keysUsages.get(i);
    canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
    canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
    if (canSign) {
      keyFlags|=KeyFlags.SIGN_DATA;
    }
    if (canEncrypt) {
      keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
    }
    hashedPacketsGen.setKeyFlags(true,keyFlags);
    keyGen.addSubKey(subKeyPair,hashedPacketsGen.generate(),unhashedPacketsGen.generate());
  }
  PGPSecretKeyRing secretKeyRing=keyGen.generateSecretKeyRing();
  PGPPublicKeyRing publicKeyRing=keyGen.generatePublicKeyRing();
  if (progress != null)   progress.setProgress(R.string.progress_savingKeyRing,90,100);
  mDatabase.saveKeyRing(secretKeyRing);
  mDatabase.saveKeyRing(publicKeyRing);
  if (progress != null)   progress.setProgress(R.string.progress_done,100,100);
}","public static void buildSecretKey(Context context,ArrayList<String> userIds,ArrayList<PGPSecretKey> keys,ArrayList<Integer> keysUsages,long masterKeyId,String oldPassPhrase,String newPassPhrase,ProgressDialogUpdater progress) throws PGPMain.GeneralException, NoSuchProviderException, PGPException, NoSuchAlgorithmException, SignatureException, IOException, Database.GeneralException {
  updateProgress(progress,R.string.progress_buildingKey,0,100);
  if (oldPassPhrase == null || oldPassPhrase.equals(""String_Node_Str"")) {
    oldPassPhrase=""String_Node_Str"";
  }
  if (newPassPhrase == null || newPassPhrase.equals(""String_Node_Str"")) {
    newPassPhrase=""String_Node_Str"";
  }
  updateProgress(progress,R.string.progress_preparingMasterKey,10,100);
  int usageId=keysUsages.get(0);
  boolean canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
  boolean canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
  String mainUserId=userIds.get(0);
  PGPSecretKey masterKey=keys.get(0);
  PGPPublicKey masterPublicKey=masterKey.getPublicKey();
  masterPublicKey=PGPPublicKey.removeCertification(masterPublicKey,""String_Node_Str"");
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
  PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(keyDecryptor);
  updateProgress(progress,R.string.progress_certifyingMasterKey,20,100);
  for (  String userId : userIds) {
    PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1).setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
    PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
    sGen.init(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
    PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
    masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,userId,certification);
  }
  PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
  PGPSignatureSubpacketGenerator hashedPacketsGen=new PGPSignatureSubpacketGenerator();
  PGPSignatureSubpacketGenerator unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
  int keyFlags=KeyFlags.CERTIFY_OTHER | KeyFlags.SIGN_DATA;
  if (canEncrypt) {
    keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
  }
  hashedPacketsGen.setKeyFlags(true,keyFlags);
  hashedPacketsGen.setPreferredSymmetricAlgorithms(true,PREFERRED_SYMMETRIC_ALGORITHMS);
  hashedPacketsGen.setPreferredHashAlgorithms(true,PREFERRED_HASH_ALGORITHMS);
  hashedPacketsGen.setPreferredCompressionAlgorithms(true,PREFERRED_COMPRESSION_ALGORITHMS);
  updateProgress(progress,R.string.progress_buildingMasterKeyRing,30,100);
  PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
  PGPContentSignerBuilder certificationSignerBuilder=new JcaPGPContentSignerBuilder(masterKeyPair.getPublicKey().getAlgorithm(),HashAlgorithmTags.SHA1);
  PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(newPassPhrase.toCharArray());
  PGPKeyRingGenerator keyGen=new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION,masterKeyPair,mainUserId,sha1Calc,hashedPacketsGen.generate(),unhashedPacketsGen.generate(),certificationSignerBuilder,keyEncryptor);
  updateProgress(progress,R.string.progress_addingSubKeys,40,100);
  for (int i=1; i < keys.size(); ++i) {
    updateProgress(progress,40 + 50 * (i - 1) / (keys.size() - 1),100);
    PGPSecretKey subKey=keys.get(i);
    PGPPublicKey subPublicKey=subKey.getPublicKey();
    PBESecretKeyDecryptor keyDecryptor2=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
    PGPPrivateKey subPrivateKey=subKey.extractPrivateKey(keyDecryptor2);
    PGPKeyPair subKeyPair=new PGPKeyPair(subPublicKey,subPrivateKey);
    hashedPacketsGen=new PGPSignatureSubpacketGenerator();
    unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
    keyFlags=0;
    usageId=keysUsages.get(i);
    canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
    canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
    if (canSign) {
      keyFlags|=KeyFlags.SIGN_DATA;
    }
    if (canEncrypt) {
      keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
    }
    hashedPacketsGen.setKeyFlags(true,keyFlags);
    keyGen.addSubKey(subKeyPair,hashedPacketsGen.generate(),unhashedPacketsGen.generate());
  }
  PGPSecretKeyRing secretKeyRing=keyGen.generateSecretKeyRing();
  PGPPublicKeyRing publicKeyRing=keyGen.generatePublicKeyRing();
  updateProgress(progress,R.string.progress_savingKeyRing,90,100);
  mDatabase.saveKeyRing(secretKeyRing);
  mDatabase.saveKeyRing(publicKeyRing);
  updateProgress(progress,R.string.progress_done,100,100);
}",0.9294186272603538
8416,"public static Bundle exportKeyRings(Context context,Vector<Integer> keyRingIds,OutputStream outStream,ProgressDialogUpdater progress) throws GeneralException, FileNotFoundException, PGPException, IOException {
  Bundle returnData=new Bundle();
  if (keyRingIds.size() == 1) {
    if (progress != null)     progress.setProgress(R.string.progress_exportingKey,0,100);
  }
 else {
    if (progress != null)     progress.setProgress(R.string.progress_exportingKeys,0,100);
  }
  if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
    throw new GeneralException(context.getString(R.string.error_externalStorageNotReady));
  }
  ArmoredOutputStream out=new ArmoredOutputStream(outStream);
  out.setHeader(""String_Node_Str"",getFullVersion(context));
  int numKeys=0;
  for (int i=0; i < keyRingIds.size(); ++i) {
    if (progress != null)     progress.setProgress(i * 100 / keyRingIds.size(),100);
    Object obj=mDatabase.getKeyRing(keyRingIds.get(i));
    PGPPublicKeyRing publicKeyRing;
    PGPSecretKeyRing secretKeyRing;
    if (obj instanceof PGPSecretKeyRing) {
      secretKeyRing=(PGPSecretKeyRing)obj;
      secretKeyRing.encode(out);
    }
 else     if (obj instanceof PGPPublicKeyRing) {
      publicKeyRing=(PGPPublicKeyRing)obj;
      publicKeyRing.encode(out);
    }
 else {
      continue;
    }
    ++numKeys;
  }
  out.close();
  returnData.putInt(ApgService.RESULT_EXPORT,numKeys);
  if (progress != null)   progress.setProgress(R.string.progress_done,100,100);
  return returnData;
}","public static Bundle exportKeyRings(Context context,Vector<Integer> keyRingIds,OutputStream outStream,ProgressDialogUpdater progress) throws GeneralException, FileNotFoundException, PGPException, IOException {
  Bundle returnData=new Bundle();
  if (keyRingIds.size() == 1) {
    updateProgress(progress,R.string.progress_exportingKey,0,100);
  }
 else {
    updateProgress(progress,R.string.progress_exportingKeys,0,100);
  }
  if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
    throw new GeneralException(context.getString(R.string.error_externalStorageNotReady));
  }
  ArmoredOutputStream out=new ArmoredOutputStream(outStream);
  out.setHeader(""String_Node_Str"",getFullVersion(context));
  int numKeys=0;
  for (int i=0; i < keyRingIds.size(); ++i) {
    updateProgress(progress,i * 100 / keyRingIds.size(),100);
    Object obj=mDatabase.getKeyRing(keyRingIds.get(i));
    PGPPublicKeyRing publicKeyRing;
    PGPSecretKeyRing secretKeyRing;
    if (obj instanceof PGPSecretKeyRing) {
      secretKeyRing=(PGPSecretKeyRing)obj;
      secretKeyRing.encode(out);
    }
 else     if (obj instanceof PGPPublicKeyRing) {
      publicKeyRing=(PGPPublicKeyRing)obj;
      publicKeyRing.encode(out);
    }
 else {
      continue;
    }
    ++numKeys;
  }
  out.close();
  returnData.putInt(ApgService.RESULT_EXPORT,numKeys);
  updateProgress(progress,R.string.progress_done,100,100);
  return returnData;
}",0.9047297297297298
8417,"public static Bundle decrypt(Context context,InputData data,OutputStream outStream,String passPhrase,ProgressDialogUpdater progress,boolean assumeSymmetric) throws IOException, GeneralException, PGPException, SignatureException {
  if (passPhrase == null) {
    passPhrase=""String_Node_Str"";
  }
  Bundle returnData=new Bundle();
  InputStream in=PGPUtil.getDecoderStream(data.getInputStream());
  PGPObjectFactory pgpF=new PGPObjectFactory(in);
  PGPEncryptedDataList enc;
  Object o=pgpF.nextObject();
  long signatureKeyId=0;
  int currentProgress=0;
  if (progress != null)   progress.setProgress(R.string.progress_readingData,currentProgress,100);
  if (o instanceof PGPEncryptedDataList) {
    enc=(PGPEncryptedDataList)o;
  }
 else {
    enc=(PGPEncryptedDataList)pgpF.nextObject();
  }
  if (enc == null) {
    throw new GeneralException(context.getString(R.string.error_invalidData));
  }
  InputStream clear=null;
  PGPEncryptedData encryptedData=null;
  currentProgress+=5;
  if (assumeSymmetric) {
    PGPPBEEncryptedData pbe=null;
    Iterator<?> it=enc.getEncryptedDataObjects();
    while (it.hasNext()) {
      Object obj=it.next();
      if (obj instanceof PGPPBEEncryptedData) {
        pbe=(PGPPBEEncryptedData)obj;
        break;
      }
    }
    if (pbe == null) {
      throw new GeneralException(context.getString(R.string.error_noSymmetricEncryptionPacket));
    }
    if (progress != null)     progress.setProgress(R.string.progress_preparingStreams,currentProgress,100);
    PGPDigestCalculatorProvider digestCalcProvider=new JcaPGPDigestCalculatorProviderBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build();
    PBEDataDecryptorFactory decryptorFactory=new JcePBEDataDecryptorFactoryBuilder(digestCalcProvider).setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(passPhrase.toCharArray());
    clear=pbe.getDataStream(decryptorFactory);
    encryptedData=pbe;
    currentProgress+=5;
  }
 else {
    if (progress != null)     progress.setProgress(R.string.progress_findingKey,currentProgress,100);
    PGPPublicKeyEncryptedData pbe=null;
    PGPSecretKey secretKey=null;
    Iterator<?> it=enc.getEncryptedDataObjects();
    while (it.hasNext()) {
      Object obj=it.next();
      if (obj instanceof PGPPublicKeyEncryptedData) {
        PGPPublicKeyEncryptedData encData=(PGPPublicKeyEncryptedData)obj;
        secretKey=getSecretKey(encData.getKeyID());
        if (secretKey != null) {
          pbe=encData;
          break;
        }
      }
    }
    if (secretKey == null) {
      throw new GeneralException(context.getString(R.string.error_noSecretKeyFound));
    }
    currentProgress+=5;
    if (progress != null)     progress.setProgress(R.string.progress_extractingKey,currentProgress,100);
    PGPPrivateKey privateKey=null;
    try {
      PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(passPhrase.toCharArray());
      privateKey=secretKey.extractPrivateKey(keyDecryptor);
    }
 catch (    PGPException e) {
      throw new PGPException(context.getString(R.string.error_wrongPassPhrase));
    }
    if (privateKey == null) {
      throw new GeneralException(context.getString(R.string.error_couldNotExtractPrivateKey));
    }
    currentProgress+=5;
    if (progress != null)     progress.setProgress(R.string.progress_preparingStreams,currentProgress,100);
    PublicKeyDataDecryptorFactory decryptorFactory=new JcePublicKeyDataDecryptorFactoryBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(privateKey);
    clear=pbe.getDataStream(decryptorFactory);
    encryptedData=pbe;
    currentProgress+=5;
  }
  PGPObjectFactory plainFact=new PGPObjectFactory(clear);
  Object dataChunk=plainFact.nextObject();
  PGPOnePassSignature signature=null;
  PGPPublicKey signatureKey=null;
  int signatureIndex=-1;
  if (dataChunk instanceof PGPCompressedData) {
    if (progress != null)     progress.setProgress(R.string.progress_decompressingData,currentProgress,100);
    PGPObjectFactory fact=new PGPObjectFactory(((PGPCompressedData)dataChunk).getDataStream());
    dataChunk=fact.nextObject();
    plainFact=fact;
    currentProgress+=10;
  }
  if (dataChunk instanceof PGPOnePassSignatureList) {
    if (progress != null)     progress.setProgress(R.string.progress_processingSignature,currentProgress,100);
    returnData.putBoolean(ApgService.RESULT_SIGNATURE,true);
    PGPOnePassSignatureList sigList=(PGPOnePassSignatureList)dataChunk;
    for (int i=0; i < sigList.size(); ++i) {
      signature=sigList.get(i);
      signatureKey=getPublicKey(signature.getKeyID());
      if (signatureKeyId == 0) {
        signatureKeyId=signature.getKeyID();
      }
      if (signatureKey == null) {
        signature=null;
      }
 else {
        signatureIndex=i;
        signatureKeyId=signature.getKeyID();
        String userId=null;
        PGPPublicKeyRing sigKeyRing=getPublicKeyRing(signatureKeyId);
        if (sigKeyRing != null) {
          userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(sigKeyRing));
        }
        returnData.putString(ApgService.RESULT_SIGNATURE_USER_ID,userId);
        break;
      }
    }
    returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
    if (signature != null) {
      JcaPGPContentVerifierBuilderProvider contentVerifierBuilderProvider=new JcaPGPContentVerifierBuilderProvider().setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
      signature.init(contentVerifierBuilderProvider,signatureKey);
    }
 else {
      returnData.putBoolean(ApgService.RESULT_SIGNATURE_UNKNOWN,true);
    }
    dataChunk=plainFact.nextObject();
    currentProgress+=10;
  }
  if (dataChunk instanceof PGPSignatureList) {
    dataChunk=plainFact.nextObject();
  }
  if (dataChunk instanceof PGPLiteralData) {
    if (progress != null)     progress.setProgress(R.string.progress_decrypting,currentProgress,100);
    PGPLiteralData literalData=(PGPLiteralData)dataChunk;
    OutputStream out=outStream;
    byte[] buffer=new byte[1 << 16];
    InputStream dataIn=literalData.getInputStream();
    int startProgress=currentProgress;
    int endProgress=100;
    if (signature != null) {
      endProgress=90;
    }
 else     if (encryptedData.isIntegrityProtected()) {
      endProgress=95;
    }
    int n=0;
    int done=0;
    long startPos=data.getStreamPosition();
    while ((n=dataIn.read(buffer)) > 0) {
      out.write(buffer,0,n);
      done+=n;
      if (signature != null) {
        try {
          signature.update(buffer,0,n);
        }
 catch (        SignatureException e) {
          returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,false);
          signature=null;
        }
      }
      currentProgress=startProgress + (endProgress - startProgress) * done / (done + 100000);
      if (data.getSize() - startPos == 0) {
        currentProgress=endProgress;
      }
 else {
        currentProgress=(int)(startProgress + (endProgress - startProgress) * (data.getStreamPosition() - startPos) / (data.getSize() - startPos));
      }
      if (progress != null)       progress.setProgress(currentProgress,100);
    }
    if (signature != null) {
      if (progress != null)       progress.setProgress(R.string.progress_verifyingSignature,90,100);
      PGPSignatureList signatureList=(PGPSignatureList)plainFact.nextObject();
      PGPSignature messageSignature=signatureList.get(signatureIndex);
      if (signature.verify(messageSignature)) {
        returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,true);
      }
 else {
        returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,false);
      }
    }
  }
  if (encryptedData.isIntegrityProtected()) {
    if (progress != null)     progress.setProgress(R.string.progress_verifyingIntegrity,95,100);
    if (encryptedData.verify()) {
    }
 else {
    }
  }
 else {
  }
  if (progress != null)   progress.setProgress(R.string.progress_done,100,100);
  return returnData;
}","public static Bundle decrypt(Context context,InputData data,OutputStream outStream,String passPhrase,ProgressDialogUpdater progress,boolean assumeSymmetric) throws IOException, GeneralException, PGPException, SignatureException {
  if (passPhrase == null) {
    passPhrase=""String_Node_Str"";
  }
  Bundle returnData=new Bundle();
  InputStream in=PGPUtil.getDecoderStream(data.getInputStream());
  PGPObjectFactory pgpF=new PGPObjectFactory(in);
  PGPEncryptedDataList enc;
  Object o=pgpF.nextObject();
  long signatureKeyId=0;
  int currentProgress=0;
  if (progress != null)   progress.setProgress(R.string.progress_readingData,currentProgress,100);
  if (o instanceof PGPEncryptedDataList) {
    enc=(PGPEncryptedDataList)o;
  }
 else {
    enc=(PGPEncryptedDataList)pgpF.nextObject();
  }
  if (enc == null) {
    throw new GeneralException(context.getString(R.string.error_invalidData));
  }
  InputStream clear=null;
  PGPEncryptedData encryptedData=null;
  currentProgress+=5;
  if (assumeSymmetric) {
    PGPPBEEncryptedData pbe=null;
    Iterator<?> it=enc.getEncryptedDataObjects();
    while (it.hasNext()) {
      Object obj=it.next();
      if (obj instanceof PGPPBEEncryptedData) {
        pbe=(PGPPBEEncryptedData)obj;
        break;
      }
    }
    if (pbe == null) {
      throw new GeneralException(context.getString(R.string.error_noSymmetricEncryptionPacket));
    }
    updateProgress(progress,R.string.progress_preparingStreams,currentProgress,100);
    PGPDigestCalculatorProvider digestCalcProvider=new JcaPGPDigestCalculatorProviderBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build();
    PBEDataDecryptorFactory decryptorFactory=new JcePBEDataDecryptorFactoryBuilder(digestCalcProvider).setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(passPhrase.toCharArray());
    clear=pbe.getDataStream(decryptorFactory);
    encryptedData=pbe;
    currentProgress+=5;
  }
 else {
    if (progress != null)     progress.setProgress(R.string.progress_findingKey,currentProgress,100);
    PGPPublicKeyEncryptedData pbe=null;
    PGPSecretKey secretKey=null;
    Iterator<?> it=enc.getEncryptedDataObjects();
    while (it.hasNext()) {
      Object obj=it.next();
      if (obj instanceof PGPPublicKeyEncryptedData) {
        PGPPublicKeyEncryptedData encData=(PGPPublicKeyEncryptedData)obj;
        secretKey=getSecretKey(encData.getKeyID());
        if (secretKey != null) {
          pbe=encData;
          break;
        }
      }
    }
    if (secretKey == null) {
      throw new GeneralException(context.getString(R.string.error_noSecretKeyFound));
    }
    currentProgress+=5;
    updateProgress(progress,R.string.progress_extractingKey,currentProgress,100);
    PGPPrivateKey privateKey=null;
    try {
      PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(passPhrase.toCharArray());
      privateKey=secretKey.extractPrivateKey(keyDecryptor);
    }
 catch (    PGPException e) {
      throw new PGPException(context.getString(R.string.error_wrongPassPhrase));
    }
    if (privateKey == null) {
      throw new GeneralException(context.getString(R.string.error_couldNotExtractPrivateKey));
    }
    currentProgress+=5;
    updateProgress(progress,R.string.progress_preparingStreams,currentProgress,100);
    PublicKeyDataDecryptorFactory decryptorFactory=new JcePublicKeyDataDecryptorFactoryBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(privateKey);
    clear=pbe.getDataStream(decryptorFactory);
    encryptedData=pbe;
    currentProgress+=5;
  }
  PGPObjectFactory plainFact=new PGPObjectFactory(clear);
  Object dataChunk=plainFact.nextObject();
  PGPOnePassSignature signature=null;
  PGPPublicKey signatureKey=null;
  int signatureIndex=-1;
  if (dataChunk instanceof PGPCompressedData) {
    if (progress != null)     progress.setProgress(R.string.progress_decompressingData,currentProgress,100);
    PGPObjectFactory fact=new PGPObjectFactory(((PGPCompressedData)dataChunk).getDataStream());
    dataChunk=fact.nextObject();
    plainFact=fact;
    currentProgress+=10;
  }
  if (dataChunk instanceof PGPOnePassSignatureList) {
    if (progress != null)     progress.setProgress(R.string.progress_processingSignature,currentProgress,100);
    returnData.putBoolean(ApgService.RESULT_SIGNATURE,true);
    PGPOnePassSignatureList sigList=(PGPOnePassSignatureList)dataChunk;
    for (int i=0; i < sigList.size(); ++i) {
      signature=sigList.get(i);
      signatureKey=getPublicKey(signature.getKeyID());
      if (signatureKeyId == 0) {
        signatureKeyId=signature.getKeyID();
      }
      if (signatureKey == null) {
        signature=null;
      }
 else {
        signatureIndex=i;
        signatureKeyId=signature.getKeyID();
        String userId=null;
        PGPPublicKeyRing sigKeyRing=getPublicKeyRing(signatureKeyId);
        if (sigKeyRing != null) {
          userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(sigKeyRing));
        }
        returnData.putString(ApgService.RESULT_SIGNATURE_USER_ID,userId);
        break;
      }
    }
    returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
    if (signature != null) {
      JcaPGPContentVerifierBuilderProvider contentVerifierBuilderProvider=new JcaPGPContentVerifierBuilderProvider().setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
      signature.init(contentVerifierBuilderProvider,signatureKey);
    }
 else {
      returnData.putBoolean(ApgService.RESULT_SIGNATURE_UNKNOWN,true);
    }
    dataChunk=plainFact.nextObject();
    currentProgress+=10;
  }
  if (dataChunk instanceof PGPSignatureList) {
    dataChunk=plainFact.nextObject();
  }
  if (dataChunk instanceof PGPLiteralData) {
    if (progress != null)     progress.setProgress(R.string.progress_decrypting,currentProgress,100);
    PGPLiteralData literalData=(PGPLiteralData)dataChunk;
    OutputStream out=outStream;
    byte[] buffer=new byte[1 << 16];
    InputStream dataIn=literalData.getInputStream();
    int startProgress=currentProgress;
    int endProgress=100;
    if (signature != null) {
      endProgress=90;
    }
 else     if (encryptedData.isIntegrityProtected()) {
      endProgress=95;
    }
    int n=0;
    int done=0;
    long startPos=data.getStreamPosition();
    while ((n=dataIn.read(buffer)) > 0) {
      out.write(buffer,0,n);
      done+=n;
      if (signature != null) {
        try {
          signature.update(buffer,0,n);
        }
 catch (        SignatureException e) {
          returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,false);
          signature=null;
        }
      }
      currentProgress=startProgress + (endProgress - startProgress) * done / (done + 100000);
      if (data.getSize() - startPos == 0) {
        currentProgress=endProgress;
      }
 else {
        currentProgress=(int)(startProgress + (endProgress - startProgress) * (data.getStreamPosition() - startPos) / (data.getSize() - startPos));
      }
      updateProgress(progress,currentProgress,100);
    }
    if (signature != null) {
      if (progress != null)       progress.setProgress(R.string.progress_verifyingSignature,90,100);
      PGPSignatureList signatureList=(PGPSignatureList)plainFact.nextObject();
      PGPSignature messageSignature=signatureList.get(signatureIndex);
      if (signature.verify(messageSignature)) {
        returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,true);
      }
 else {
        returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,false);
      }
    }
  }
  if (encryptedData.isIntegrityProtected()) {
    if (progress != null)     progress.setProgress(R.string.progress_verifyingIntegrity,95,100);
    if (encryptedData.verify()) {
    }
 else {
    }
  }
 else {
  }
  updateProgress(progress,R.string.progress_done,100,100);
  return returnData;
}",0.9774359626263268
8418,"public static Bundle importKeyRings(Context context,int type,InputData data,ProgressDialogUpdater progress) throws GeneralException, FileNotFoundException, PGPException, IOException {
  Bundle returnData=new Bundle();
  if (type == Id.type.secret_key) {
    if (progress != null)     progress.setProgress(R.string.progress_importingSecretKeys,0,100);
  }
 else {
    if (progress != null)     progress.setProgress(R.string.progress_importingPublicKeys,0,100);
  }
  if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
    throw new GeneralException(context.getString(R.string.error_externalStorageNotReady));
  }
  PositionAwareInputStream progressIn=new PositionAwareInputStream(data.getInputStream());
  BufferedInputStream bufferedInput=new BufferedInputStream(progressIn);
  int newKeys=0;
  int oldKeys=0;
  int badKeys=0;
  try {
    PGPKeyRing keyring=PGPHelper.decodeKeyRing(bufferedInput);
    while (keyring != null) {
      int status=Integer.MIN_VALUE;
      if ((type == Id.type.secret_key && keyring instanceof PGPSecretKeyRing) || (type == Id.type.public_key && keyring instanceof PGPPublicKeyRing)) {
        status=storeKeyRingInCache(keyring);
      }
      if (status == Id.return_value.error) {
        throw new GeneralException(context.getString(R.string.error_savingKeys));
      }
      if (status == Id.return_value.updated) {
        ++oldKeys;
      }
 else       if (status == Id.return_value.ok) {
        ++newKeys;
      }
 else       if (status == Id.return_value.bad) {
        ++badKeys;
      }
      if (progress != null) {
        progress.setProgress((int)(100 * progressIn.position() / data.getSize()),100);
      }
      keyring=PGPHelper.decodeKeyRing(bufferedInput);
    }
  }
 catch (  EOFException e) {
  }
  returnData.putInt(ApgService.RESULT_IMPORT_ADDED,newKeys);
  returnData.putInt(ApgService.RESULT_IMPORT_UPDATED,oldKeys);
  returnData.putInt(ApgService.RESULT_IMPORT_BAD,badKeys);
  if (progress != null)   progress.setProgress(R.string.progress_done,100,100);
  return returnData;
}","public static Bundle importKeyRings(Context context,int type,InputData data,ProgressDialogUpdater progress) throws GeneralException, FileNotFoundException, PGPException, IOException {
  Bundle returnData=new Bundle();
  if (type == Id.type.secret_key) {
    if (progress != null)     progress.setProgress(R.string.progress_importingSecretKeys,0,100);
  }
 else {
    if (progress != null)     progress.setProgress(R.string.progress_importingPublicKeys,0,100);
  }
  if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
    throw new GeneralException(context.getString(R.string.error_externalStorageNotReady));
  }
  PositionAwareInputStream progressIn=new PositionAwareInputStream(data.getInputStream());
  BufferedInputStream bufferedInput=new BufferedInputStream(progressIn);
  int newKeys=0;
  int oldKeys=0;
  int badKeys=0;
  try {
    PGPKeyRing keyring=PGPHelper.decodeKeyRing(bufferedInput);
    while (keyring != null) {
      int status=Integer.MIN_VALUE;
      if ((type == Id.type.secret_key && keyring instanceof PGPSecretKeyRing) || (type == Id.type.public_key && keyring instanceof PGPPublicKeyRing)) {
        status=storeKeyRingInCache(keyring);
      }
      if (status == Id.return_value.error) {
        throw new GeneralException(context.getString(R.string.error_savingKeys));
      }
      if (status == Id.return_value.updated) {
        ++oldKeys;
      }
 else       if (status == Id.return_value.ok) {
        ++newKeys;
      }
 else       if (status == Id.return_value.bad) {
        ++badKeys;
      }
      updateProgress(progress,(int)(100 * progressIn.position() / data.getSize()),100);
      keyring=PGPHelper.decodeKeyRing(bufferedInput);
    }
  }
 catch (  EOFException e) {
  }
  returnData.putInt(ApgService.RESULT_IMPORT_ADDED,newKeys);
  returnData.putInt(ApgService.RESULT_IMPORT_UPDATED,oldKeys);
  returnData.putInt(ApgService.RESULT_IMPORT_BAD,badKeys);
  updateProgress(progress,R.string.progress_done,100,100);
  return returnData;
}",0.9621621621621622
8419,"/** 
 * The IntentService calls this method from the default worker thread with the intent that started the service. When this method returns, IntentService stops the service, as appropriate.
 */
@Override protected void onHandleIntent(Intent intent){
  Bundle extras=intent.getExtras();
  if (extras == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  if (!(extras.containsKey(EXTRA_MESSENGER) || extras.containsKey(EXTRA_DATA) || extras.containsKey(EXTRA_ACTION))) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  mMessenger=(Messenger)extras.get(EXTRA_MESSENGER);
  Bundle data=extras.getBundle(EXTRA_DATA);
  OtherHelper.logDebugBundle(data,""String_Node_Str"");
  int action=extras.getInt(EXTRA_ACTION);
switch (action) {
case ACTION_ENCRYPT_SIGN:
    try {
      int target=data.getInt(TARGET);
      long secretKeyId=data.getLong(SECRET_KEY_ID);
      String passphrase=data.getString(SYMMETRIC_PASSPHRASE);
      boolean useAsciiArmour=data.getBoolean(USE_ASCII_AMOR);
      long encryptionKeyIds[]=data.getLongArray(ENCRYPTION_KEYS_IDS);
      long signatureKeyId=data.getLong(SIGNATURE_KEY_ID);
      int compressionId=data.getInt(COMPRESSION_ID);
      boolean generateSignature=data.getBoolean(GENERATE_SIGNATURE);
      boolean signOnly=data.getBoolean(SIGN_ONLY);
      InputStream inStream=null;
      long inLength=-1;
      InputData inputData=null;
      OutputStream outStream=null;
      String streamFilename=null;
switch (target) {
case TARGET_BYTES:
        byte[] bytes=data.getByteArray(MESSAGE_BYTES);
      inStream=new ByteArrayInputStream(bytes);
    inLength=bytes.length;
  inputData=new InputData(inStream,inLength);
outStream=new ByteArrayOutputStream();
break;
case TARGET_FILE:
String inputFile=data.getString(INPUT_FILE);
String outputFile=data.getString(OUTPUT_FILE);
if (!FileHelper.isStorageMounted(inputFile) || !FileHelper.isStorageMounted(outputFile)) {
sendErrorToHandler(new GeneralException(getString(R.string.error_externalStorageNotReady)));
return;
}
inStream=new FileInputStream(inputFile);
File file=new File(inputFile);
inLength=file.length();
inputData=new InputData(inStream,inLength);
outStream=new FileOutputStream(outputFile);
break;
case TARGET_STREAM:
Uri providerUri=(Uri)data.getParcelable(PROVIDER_URI);
InputStream in=getContentResolver().openInputStream(providerUri);
inLength=PGPMain.getLengthOfStream(in);
inputData=new InputData(in,inLength);
try {
while (true) {
streamFilename=PGPMain.generateRandomString(32);
if (streamFilename == null) {
throw new PGPMain.GeneralException(""String_Node_Str"");
}
openFileInput(streamFilename).close();
}
}
 catch (FileNotFoundException e) {
}
outStream=openFileOutput(streamFilename,Context.MODE_PRIVATE);
break;
default :
throw new PGPMain.GeneralException(""String_Node_Str"");
}
if (generateSignature) {
Log.d(Constants.TAG,""String_Node_Str"");
PGPMain.generateSignature(this,inputData,outStream,useAsciiArmour,false,secretKeyId,PassphraseCacheService.getCachedPassphrase(this,secretKeyId),Preferences.getPreferences(this).getDefaultHashAlgorithm(),Preferences.getPreferences(this).getForceV3Signatures(),this);
}
 else if (signOnly) {
Log.d(Constants.TAG,""String_Node_Str"");
PGPMain.signText(this,inputData,outStream,secretKeyId,PassphraseCacheService.getCachedPassphrase(this,secretKeyId),Preferences.getPreferences(this).getDefaultHashAlgorithm(),Preferences.getPreferences(this).getForceV3Signatures(),this);
}
 else {
Log.d(Constants.TAG,""String_Node_Str"");
PGPMain.encrypt(this,inputData,outStream,useAsciiArmour,encryptionKeyIds,signatureKeyId,PassphraseCacheService.getCachedPassphrase(this,signatureKeyId),this,Preferences.getPreferences(this).getDefaultEncryptionAlgorithm(),Preferences.getPreferences(this).getDefaultHashAlgorithm(),compressionId,Preferences.getPreferences(this).getForceV3Signatures(),passphrase);
}
outStream.close();
Bundle resultData=new Bundle();
switch (target) {
case TARGET_BYTES:
if (useAsciiArmour) {
String output=new String(((ByteArrayOutputStream)outStream).toByteArray());
if (generateSignature) {
resultData.putString(RESULT_SIGNATURE_TEXT,output);
}
 else {
resultData.putString(RESULT_ENCRYPTED_MESSAGE,output);
}
}
 else {
byte output[]=((ByteArrayOutputStream)outStream).toByteArray();
if (generateSignature) {
resultData.putByteArray(RESULT_SIGNATURE_DATA,output);
}
 else {
resultData.putByteArray(RESULT_ENCRYPTED_DATA,output);
}
}
break;
case TARGET_FILE:
break;
case TARGET_STREAM:
String uri=""String_Node_Str"" + DataProvider.AUTHORITY + ""String_Node_Str""+ streamFilename;
resultData.putString(RESULT_URI,uri);
break;
}
OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_DECRYPT_VERIFY:
try {
int target=data.getInt(TARGET);
long secretKeyId=data.getLong(SECRET_KEY_ID);
byte[] bytes=data.getByteArray(CIPHERTEXT_BYTES);
boolean signedOnly=data.getBoolean(SIGNED_ONLY);
boolean returnBytes=data.getBoolean(RETURN_BYTES);
boolean assumeSymmetricEncryption=data.getBoolean(ASSUME_SYMMETRIC);
boolean lookupUnknownKey=data.getBoolean(LOOKUP_UNKNOWN_KEY);
InputStream inStream=null;
long inLength=-1;
InputData inputData=null;
OutputStream outStream=null;
String streamFilename=null;
switch (target) {
case TARGET_BYTES:
inStream=new ByteArrayInputStream(bytes);
inLength=bytes.length;
inputData=new InputData(inStream,inLength);
outStream=new ByteArrayOutputStream();
break;
case TARGET_FILE:
String inputFile=data.getString(INPUT_FILE);
String outputFile=data.getString(OUTPUT_FILE);
if (!FileHelper.isStorageMounted(inputFile) || !FileHelper.isStorageMounted(outputFile)) {
sendErrorToHandler(new GeneralException(getString(R.string.error_externalStorageNotReady)));
return;
}
inLength=-1;
inStream=new FileInputStream(inputFile);
File file=new File(inputFile);
inLength=file.length();
inputData=new InputData(inStream,inLength);
outStream=new FileOutputStream(outputFile);
break;
case TARGET_STREAM:
Uri providerUri=(Uri)data.getParcelable(PROVIDER_URI);
InputStream in=getContentResolver().openInputStream(providerUri);
inLength=PGPMain.getLengthOfStream(in);
inputData=new InputData(in,inLength);
try {
while (true) {
streamFilename=PGPMain.generateRandomString(32);
if (streamFilename == null) {
throw new PGPMain.GeneralException(""String_Node_Str"");
}
openFileInput(streamFilename).close();
}
}
 catch (FileNotFoundException e) {
}
outStream=openFileOutput(streamFilename,Context.MODE_PRIVATE);
break;
default :
throw new PGPMain.GeneralException(""String_Node_Str"");
}
Bundle resultData=new Bundle();
if (signedOnly) {
resultData=PGPMain.verifyText(this,inputData,outStream,lookupUnknownKey,this);
}
 else {
resultData=PGPMain.decrypt(this,inputData,outStream,PassphraseCacheService.getCachedPassphrase(this,secretKeyId),this,assumeSymmetricEncryption);
}
outStream.close();
switch (target) {
case TARGET_BYTES:
if (returnBytes) {
byte output[]=((ByteArrayOutputStream)outStream).toByteArray();
resultData.putByteArray(RESULT_DECRYPTED_DATA,output);
}
 else {
String output=new String(((ByteArrayOutputStream)outStream).toByteArray());
resultData.putString(RESULT_DECRYPTED_MESSAGE,output);
}
break;
case TARGET_FILE:
break;
case TARGET_STREAM:
String uri=""String_Node_Str"" + DataProvider.AUTHORITY + ""String_Node_Str""+ streamFilename;
resultData.putString(RESULT_URI,uri);
break;
}
OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_SAVE_KEYRING:
try {
String oldPassPhrase=data.getString(CURRENT_PASSPHRASE);
String newPassPhrase=data.getString(NEW_PASSPHRASE);
if (newPassPhrase == null) {
newPassPhrase=oldPassPhrase;
}
@SuppressWarnings(""String_Node_Str"") ArrayList<String> userIds=(ArrayList<String>)data.getSerializable(USER_IDS);
ArrayList<PGPSecretKey> keys=PGPConversionHelper.BytesToPGPSecretKeyList(data.getByteArray(KEYS));
@SuppressWarnings(""String_Node_Str"") ArrayList<Integer> keysUsages=(ArrayList<Integer>)data.getSerializable(KEYS_USAGES);
long masterKeyId=data.getLong(MASTER_KEY_ID);
PGPMain.buildSecretKey(this,userIds,keys,keysUsages,masterKeyId,oldPassPhrase,newPassPhrase,this);
PassphraseCacheService.addCachedPassphrase(this,masterKeyId,newPassPhrase);
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_GENERATE_KEY:
try {
int algorithm=data.getInt(ALGORITHM);
String passphrase=data.getString(SYMMETRIC_PASSPHRASE);
int keysize=data.getInt(KEY_SIZE);
PGPSecretKey masterKey=null;
if (data.containsKey(MASTER_KEY)) {
masterKey=PGPConversionHelper.BytesToPGPSecretKey(data.getByteArray(MASTER_KEY));
}
PGPSecretKeyRing newKeyRing=PGPMain.createKey(this,algorithm,keysize,passphrase,masterKey);
Bundle resultData=new Bundle();
resultData.putByteArray(RESULT_NEW_KEY,PGPConversionHelper.PGPSecretKeyRingToBytes(newKeyRing));
OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_GENERATE_DEFAULT_RSA_KEYS:
try {
String passphrase=data.getString(SYMMETRIC_PASSPHRASE);
PGPSecretKeyRing masterKeyRing=PGPMain.createKey(this,Id.choice.algorithm.rsa,2048,passphrase,null);
PGPSecretKeyRing subKeyRing=PGPMain.createKey(this,Id.choice.algorithm.rsa,2048,passphrase,masterKeyRing.getSecretKey());
Bundle resultData=new Bundle();
resultData.putByteArray(RESULT_NEW_KEY,PGPConversionHelper.PGPSecretKeyRingToBytes(masterKeyRing));
resultData.putByteArray(RESULT_NEW_KEY2,PGPConversionHelper.PGPSecretKeyRingToBytes(subKeyRing));
OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_DELETE_FILE_SECURELY:
try {
String deleteFile=data.getString(DELETE_FILE);
try {
PGPMain.deleteFileSecurely(this,new File(deleteFile),this);
}
 catch (FileNotFoundException e) {
throw new PGPMain.GeneralException(getString(R.string.error_fileNotFound,deleteFile));
}
catch (IOException e) {
throw new PGPMain.GeneralException(getString(R.string.error_fileDeleteFailed,deleteFile));
}
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_IMPORT_KEY:
try {
int target=data.getInt(TARGET);
int keyType=Id.type.public_key;
if (data.containsKey(IMPORT_KEY_TYPE)) {
keyType=data.getInt(IMPORT_KEY_TYPE);
}
InputStream inStream=null;
long inLength=-1;
InputData inputData=null;
switch (target) {
case TARGET_BYTES:
byte[] bytes=data.getByteArray(IMPORT_BYTES);
inStream=new ByteArrayInputStream(bytes);
inLength=bytes.length;
inputData=new InputData(inStream,inLength);
break;
case TARGET_FILE:
String inputFile=data.getString(IMPORT_FILENAME);
inStream=new FileInputStream(inputFile);
File file=new File(inputFile);
inLength=file.length();
inputData=new InputData(inStream,inLength);
break;
case TARGET_STREAM:
break;
}
Bundle resultData=new Bundle();
resultData=PGPMain.importKeyRings(this,keyType,inputData,this);
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_EXPORT_KEY:
try {
int keyType=Id.type.public_key;
if (data.containsKey(EXPORT_KEY_TYPE)) {
keyType=data.getInt(EXPORT_KEY_TYPE);
}
String outputFile=data.getString(EXPORT_FILENAME);
boolean exportAll=data.getBoolean(EXPORT_ALL);
int keyRingId=-1;
if (!exportAll) {
keyRingId=data.getInt(EXPORT_KEY_RING_ID);
}
if (!FileHelper.isStorageMounted(outputFile)) {
sendErrorToHandler(new GeneralException(getString(R.string.error_externalStorageNotReady)));
return;
}
FileOutputStream outStream=new FileOutputStream(outputFile);
Vector<Integer> keyRingIds=new Vector<Integer>();
if (exportAll) {
keyRingIds=PGPMain.getKeyRingIds(keyType == Id.type.public_key ? Id.database.type_public : Id.database.type_secret);
}
 else {
keyRingIds.add(keyRingId);
}
Bundle resultData=new Bundle();
resultData=PGPMain.exportKeyRings(this,keyRingIds,outStream,this);
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_UPLOAD_KEY:
try {
int keyRingId=data.getInt(UPLOAD_KEY_KEYRING_ID);
String keyServer=data.getString(UPLOAD_KEY_SERVER);
HkpKeyServer server=new HkpKeyServer(keyServer);
PGPKeyRing keyring=PGPMain.getKeyRing(keyRingId);
if (keyring != null && keyring instanceof PGPPublicKeyRing) {
boolean uploaded=PGPMain.uploadKeyRingToServer(server,(PGPPublicKeyRing)keyring);
if (!uploaded) {
sendErrorToHandler(new GeneralException(""String_Node_Str""));
return;
}
}
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_QUERY_KEY:
try {
int queryType=data.getInt(QUERY_KEY_TYPE);
String keyServer=data.getString(QUERY_KEY_SERVER);
String queryString=data.getString(QUERY_KEY_STRING);
long keyId=data.getLong(QUERY_KEY_ID);
Bundle resultData=new Bundle();
HkpKeyServer server=new HkpKeyServer(keyServer);
if (queryType == Id.keyserver.search) {
ArrayList<KeyInfo> searchResult=server.search(queryString);
resultData.putParcelableArrayList(RESULT_QUERY_KEY_SEARCH_RESULT,searchResult);
}
 else if (queryType == Id.keyserver.get) {
String keyData=server.get(keyId);
resultData.putString(RESULT_QUERY_KEY_KEY_DATA,keyData);
}
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_SIGN_KEY:
try {
long masterKeyId=data.getLong(SIGN_KEY_MASTER_KEY_ID);
long pubKeyId=data.getLong(SIGN_KEY_PUB_KEY_ID);
String signaturePassPhrase=PassphraseCacheService.getCachedPassphrase(this,masterKeyId);
PGPPublicKeyRing signedPubKeyRing=PGPMain.signKey(this,masterKeyId,pubKeyId,signaturePassPhrase);
int retval=PGPMain.storeKeyRingInCache(signedPubKeyRing);
if (retval != Id.return_value.ok && retval != Id.return_value.updated) {
throw new GeneralException(""String_Node_Str"");
}
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
default :
break;
}
}","/** 
 * The IntentService calls this method from the default worker thread with the intent that started the service. When this method returns, IntentService stops the service, as appropriate.
 */
@Override protected void onHandleIntent(Intent intent){
  Bundle extras=intent.getExtras();
  if (extras == null) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  if (!(extras.containsKey(EXTRA_MESSENGER) || extras.containsKey(EXTRA_DATA) || extras.containsKey(EXTRA_ACTION))) {
    Log.e(Constants.TAG,""String_Node_Str"");
    return;
  }
  mMessenger=(Messenger)extras.get(EXTRA_MESSENGER);
  Bundle data=extras.getBundle(EXTRA_DATA);
  OtherHelper.logDebugBundle(data,""String_Node_Str"");
  int action=extras.getInt(EXTRA_ACTION);
switch (action) {
case ACTION_ENCRYPT_SIGN:
    try {
      int target=data.getInt(TARGET);
      long secretKeyId=data.getLong(SECRET_KEY_ID);
      String passphrase=data.getString(SYMMETRIC_PASSPHRASE);
      boolean useAsciiArmour=data.getBoolean(USE_ASCII_AMOR);
      long encryptionKeyIds[]=data.getLongArray(ENCRYPTION_KEYS_IDS);
      long signatureKeyId=data.getLong(SIGNATURE_KEY_ID);
      int compressionId=data.getInt(COMPRESSION_ID);
      boolean generateSignature=data.getBoolean(GENERATE_SIGNATURE);
      boolean signOnly=data.getBoolean(SIGN_ONLY);
      InputStream inStream=null;
      long inLength=-1;
      InputData inputData=null;
      OutputStream outStream=null;
      String streamFilename=null;
switch (target) {
case TARGET_BYTES:
        byte[] bytes=data.getByteArray(MESSAGE_BYTES);
      inStream=new ByteArrayInputStream(bytes);
    inLength=bytes.length;
  inputData=new InputData(inStream,inLength);
outStream=new ByteArrayOutputStream();
break;
case TARGET_FILE:
String inputFile=data.getString(INPUT_FILE);
String outputFile=data.getString(OUTPUT_FILE);
if (!FileHelper.isStorageMounted(inputFile) || !FileHelper.isStorageMounted(outputFile)) {
sendErrorToHandler(new GeneralException(getString(R.string.error_externalStorageNotReady)));
return;
}
inStream=new FileInputStream(inputFile);
File file=new File(inputFile);
inLength=file.length();
inputData=new InputData(inStream,inLength);
outStream=new FileOutputStream(outputFile);
break;
case TARGET_STREAM:
Uri providerUri=(Uri)data.getParcelable(PROVIDER_URI);
InputStream in=getContentResolver().openInputStream(providerUri);
inLength=PGPMain.getLengthOfStream(in);
inputData=new InputData(in,inLength);
try {
while (true) {
streamFilename=PGPMain.generateRandomString(32);
if (streamFilename == null) {
throw new PGPMain.GeneralException(""String_Node_Str"");
}
openFileInput(streamFilename).close();
}
}
 catch (FileNotFoundException e) {
}
outStream=openFileOutput(streamFilename,Context.MODE_PRIVATE);
break;
default :
throw new PGPMain.GeneralException(""String_Node_Str"");
}
if (generateSignature) {
Log.d(Constants.TAG,""String_Node_Str"");
PGPMain.generateSignature(this,inputData,outStream,useAsciiArmour,false,secretKeyId,PassphraseCacheService.getCachedPassphrase(this,secretKeyId),Preferences.getPreferences(this).getDefaultHashAlgorithm(),Preferences.getPreferences(this).getForceV3Signatures(),this);
}
 else if (signOnly) {
Log.d(Constants.TAG,""String_Node_Str"");
PGPMain.signText(this,inputData,outStream,secretKeyId,PassphraseCacheService.getCachedPassphrase(this,secretKeyId),Preferences.getPreferences(this).getDefaultHashAlgorithm(),Preferences.getPreferences(this).getForceV3Signatures(),this);
}
 else {
Log.d(Constants.TAG,""String_Node_Str"");
PGPMain.encrypt(this,inputData,outStream,useAsciiArmour,encryptionKeyIds,signatureKeyId,PassphraseCacheService.getCachedPassphrase(this,signatureKeyId),this,Preferences.getPreferences(this).getDefaultEncryptionAlgorithm(),Preferences.getPreferences(this).getDefaultHashAlgorithm(),compressionId,Preferences.getPreferences(this).getForceV3Signatures(),passphrase);
}
outStream.close();
Bundle resultData=new Bundle();
switch (target) {
case TARGET_BYTES:
if (useAsciiArmour) {
String output=new String(((ByteArrayOutputStream)outStream).toByteArray());
if (generateSignature) {
resultData.putString(RESULT_SIGNATURE_TEXT,output);
}
 else {
resultData.putString(RESULT_ENCRYPTED_MESSAGE,output);
}
}
 else {
byte output[]=((ByteArrayOutputStream)outStream).toByteArray();
if (generateSignature) {
resultData.putByteArray(RESULT_SIGNATURE_DATA,output);
}
 else {
resultData.putByteArray(RESULT_ENCRYPTED_DATA,output);
}
}
break;
case TARGET_FILE:
break;
case TARGET_STREAM:
String uri=""String_Node_Str"" + DataProvider.AUTHORITY + ""String_Node_Str""+ streamFilename;
resultData.putString(RESULT_URI,uri);
break;
}
OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_DECRYPT_VERIFY:
try {
int target=data.getInt(TARGET);
long secretKeyId=data.getLong(SECRET_KEY_ID);
byte[] bytes=data.getByteArray(CIPHERTEXT_BYTES);
boolean signedOnly=data.getBoolean(SIGNED_ONLY);
boolean returnBytes=data.getBoolean(RETURN_BYTES);
boolean assumeSymmetricEncryption=data.getBoolean(ASSUME_SYMMETRIC);
boolean lookupUnknownKey=data.getBoolean(LOOKUP_UNKNOWN_KEY);
InputStream inStream=null;
long inLength=-1;
InputData inputData=null;
OutputStream outStream=null;
String streamFilename=null;
switch (target) {
case TARGET_BYTES:
inStream=new ByteArrayInputStream(bytes);
inLength=bytes.length;
inputData=new InputData(inStream,inLength);
outStream=new ByteArrayOutputStream();
break;
case TARGET_FILE:
String inputFile=data.getString(INPUT_FILE);
String outputFile=data.getString(OUTPUT_FILE);
if (!FileHelper.isStorageMounted(inputFile) || !FileHelper.isStorageMounted(outputFile)) {
sendErrorToHandler(new GeneralException(getString(R.string.error_externalStorageNotReady)));
return;
}
inLength=-1;
inStream=new FileInputStream(inputFile);
File file=new File(inputFile);
inLength=file.length();
inputData=new InputData(inStream,inLength);
outStream=new FileOutputStream(outputFile);
break;
case TARGET_STREAM:
Uri providerUri=(Uri)data.getParcelable(PROVIDER_URI);
InputStream in=getContentResolver().openInputStream(providerUri);
inLength=PGPMain.getLengthOfStream(in);
inputData=new InputData(in,inLength);
try {
while (true) {
streamFilename=PGPMain.generateRandomString(32);
if (streamFilename == null) {
throw new PGPMain.GeneralException(""String_Node_Str"");
}
openFileInput(streamFilename).close();
}
}
 catch (FileNotFoundException e) {
}
outStream=openFileOutput(streamFilename,Context.MODE_PRIVATE);
break;
default :
throw new PGPMain.GeneralException(""String_Node_Str"");
}
Bundle resultData=new Bundle();
if (signedOnly) {
resultData=PGPMain.verifyText(this,inputData,outStream,lookupUnknownKey,this);
}
 else {
resultData=PGPMain.decrypt(this,inputData,outStream,PassphraseCacheService.getCachedPassphrase(this,secretKeyId),this,assumeSymmetricEncryption);
}
outStream.close();
switch (target) {
case TARGET_BYTES:
if (returnBytes) {
byte output[]=((ByteArrayOutputStream)outStream).toByteArray();
resultData.putByteArray(RESULT_DECRYPTED_DATA,output);
}
 else {
String output=new String(((ByteArrayOutputStream)outStream).toByteArray());
resultData.putString(RESULT_DECRYPTED_MESSAGE,output);
}
break;
case TARGET_FILE:
break;
case TARGET_STREAM:
String uri=""String_Node_Str"" + DataProvider.AUTHORITY + ""String_Node_Str""+ streamFilename;
resultData.putString(RESULT_URI,uri);
break;
}
OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_SAVE_KEYRING:
try {
String oldPassPhrase=data.getString(CURRENT_PASSPHRASE);
String newPassPhrase=data.getString(NEW_PASSPHRASE);
if (newPassPhrase == null) {
newPassPhrase=oldPassPhrase;
}
ArrayList<String> userIds=data.getStringArrayList(USER_IDS);
ArrayList<PGPSecretKey> keys=PGPConversionHelper.BytesToPGPSecretKeyList(data.getByteArray(KEYS));
ArrayList<Integer> keysUsages=data.getIntegerArrayList(KEYS_USAGES);
long masterKeyId=data.getLong(MASTER_KEY_ID);
PGPMain.buildSecretKey(this,userIds,keys,keysUsages,masterKeyId,oldPassPhrase,newPassPhrase,this);
PassphraseCacheService.addCachedPassphrase(this,masterKeyId,newPassPhrase);
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_GENERATE_KEY:
try {
int algorithm=data.getInt(ALGORITHM);
String passphrase=data.getString(SYMMETRIC_PASSPHRASE);
int keysize=data.getInt(KEY_SIZE);
PGPSecretKey masterKey=null;
if (data.containsKey(MASTER_KEY)) {
masterKey=PGPConversionHelper.BytesToPGPSecretKey(data.getByteArray(MASTER_KEY));
}
PGPSecretKeyRing newKeyRing=PGPMain.createKey(this,algorithm,keysize,passphrase,masterKey);
Bundle resultData=new Bundle();
resultData.putByteArray(RESULT_NEW_KEY,PGPConversionHelper.PGPSecretKeyRingToBytes(newKeyRing));
OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_GENERATE_DEFAULT_RSA_KEYS:
try {
String passphrase=data.getString(SYMMETRIC_PASSPHRASE);
PGPSecretKeyRing masterKeyRing=PGPMain.createKey(this,Id.choice.algorithm.rsa,2048,passphrase,null);
PGPSecretKeyRing subKeyRing=PGPMain.createKey(this,Id.choice.algorithm.rsa,2048,passphrase,masterKeyRing.getSecretKey());
Bundle resultData=new Bundle();
resultData.putByteArray(RESULT_NEW_KEY,PGPConversionHelper.PGPSecretKeyRingToBytes(masterKeyRing));
resultData.putByteArray(RESULT_NEW_KEY2,PGPConversionHelper.PGPSecretKeyRingToBytes(subKeyRing));
OtherHelper.logDebugBundle(resultData,""String_Node_Str"");
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_DELETE_FILE_SECURELY:
try {
String deleteFile=data.getString(DELETE_FILE);
try {
PGPMain.deleteFileSecurely(this,new File(deleteFile),this);
}
 catch (FileNotFoundException e) {
throw new PGPMain.GeneralException(getString(R.string.error_fileNotFound,deleteFile));
}
catch (IOException e) {
throw new PGPMain.GeneralException(getString(R.string.error_fileDeleteFailed,deleteFile));
}
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_IMPORT_KEY:
try {
int target=data.getInt(TARGET);
int keyType=Id.type.public_key;
if (data.containsKey(IMPORT_KEY_TYPE)) {
keyType=data.getInt(IMPORT_KEY_TYPE);
}
InputStream inStream=null;
long inLength=-1;
InputData inputData=null;
switch (target) {
case TARGET_BYTES:
byte[] bytes=data.getByteArray(IMPORT_BYTES);
inStream=new ByteArrayInputStream(bytes);
inLength=bytes.length;
inputData=new InputData(inStream,inLength);
break;
case TARGET_FILE:
String inputFile=data.getString(IMPORT_FILENAME);
inStream=new FileInputStream(inputFile);
File file=new File(inputFile);
inLength=file.length();
inputData=new InputData(inStream,inLength);
break;
case TARGET_STREAM:
break;
}
Bundle resultData=new Bundle();
resultData=PGPMain.importKeyRings(this,keyType,inputData,this);
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_EXPORT_KEY:
try {
int keyType=Id.type.public_key;
if (data.containsKey(EXPORT_KEY_TYPE)) {
keyType=data.getInt(EXPORT_KEY_TYPE);
}
String outputFile=data.getString(EXPORT_FILENAME);
boolean exportAll=data.getBoolean(EXPORT_ALL);
int keyRingId=-1;
if (!exportAll) {
keyRingId=data.getInt(EXPORT_KEY_RING_ID);
}
if (!FileHelper.isStorageMounted(outputFile)) {
sendErrorToHandler(new GeneralException(getString(R.string.error_externalStorageNotReady)));
return;
}
FileOutputStream outStream=new FileOutputStream(outputFile);
Vector<Integer> keyRingIds=new Vector<Integer>();
if (exportAll) {
keyRingIds=PGPMain.getKeyRingIds(keyType == Id.type.public_key ? Id.database.type_public : Id.database.type_secret);
}
 else {
keyRingIds.add(keyRingId);
}
Bundle resultData=new Bundle();
resultData=PGPMain.exportKeyRings(this,keyRingIds,outStream,this);
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_UPLOAD_KEY:
try {
int keyRingId=data.getInt(UPLOAD_KEY_KEYRING_ID);
String keyServer=data.getString(UPLOAD_KEY_SERVER);
HkpKeyServer server=new HkpKeyServer(keyServer);
PGPKeyRing keyring=PGPMain.getKeyRing(keyRingId);
if (keyring != null && keyring instanceof PGPPublicKeyRing) {
boolean uploaded=PGPMain.uploadKeyRingToServer(server,(PGPPublicKeyRing)keyring);
if (!uploaded) {
sendErrorToHandler(new GeneralException(""String_Node_Str""));
return;
}
}
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_QUERY_KEY:
try {
int queryType=data.getInt(QUERY_KEY_TYPE);
String keyServer=data.getString(QUERY_KEY_SERVER);
String queryString=data.getString(QUERY_KEY_STRING);
long keyId=data.getLong(QUERY_KEY_ID);
Bundle resultData=new Bundle();
HkpKeyServer server=new HkpKeyServer(keyServer);
if (queryType == Id.keyserver.search) {
ArrayList<KeyInfo> searchResult=server.search(queryString);
resultData.putParcelableArrayList(RESULT_QUERY_KEY_SEARCH_RESULT,searchResult);
}
 else if (queryType == Id.keyserver.get) {
String keyData=server.get(keyId);
resultData.putString(RESULT_QUERY_KEY_KEY_DATA,keyData);
}
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY,resultData);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
case ACTION_SIGN_KEY:
try {
long masterKeyId=data.getLong(SIGN_KEY_MASTER_KEY_ID);
long pubKeyId=data.getLong(SIGN_KEY_PUB_KEY_ID);
String signaturePassPhrase=PassphraseCacheService.getCachedPassphrase(this,masterKeyId);
PGPPublicKeyRing signedPubKeyRing=PGPMain.signKey(this,masterKeyId,pubKeyId,signaturePassPhrase);
int retval=PGPMain.storeKeyRingInCache(signedPubKeyRing);
if (retval != Id.return_value.ok && retval != Id.return_value.updated) {
throw new GeneralException(""String_Node_Str"");
}
sendMessageToHandler(ApgServiceHandler.MESSAGE_OKAY);
}
 catch (Exception e) {
sendErrorToHandler(e);
}
break;
default :
break;
}
}",0.9844983089064262
8420,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.edit_key);
  mActionBar=getSupportActionBar();
  mActionBar.setDisplayShowTitleEnabled(true);
  OtherHelper.setActionBarBackButton(this);
  mChangePassPhrase=(Button)findViewById(R.id.edit_key_btn_change_pass_phrase);
  mNoPassphrase=(CheckBox)findViewById(R.id.edit_key_no_passphrase);
  mUserIds=new Vector<String>();
  mKeys=new Vector<PGPSecretKey>();
  mKeysUsages=new Vector<Integer>();
  mIntent=getIntent();
  Bundle extras=mIntent.getExtras();
  if (ACTION_CREATE_KEY.equals(mIntent.getAction())) {
    mActionBar.setTitle(R.string.title_createKey);
    mCurrentPassPhrase=""String_Node_Str"";
    if (extras != null) {
      if (extras.containsKey(EXTRA_USER_IDS)) {
        Log.d(Constants.TAG,""String_Node_Str"");
        mUserIds.add(extras.getString(EXTRA_USER_IDS));
      }
      if (extras.containsKey(EXTRA_NO_PASSPHRASE)) {
        boolean noPassphrase=extras.getBoolean(EXTRA_NO_PASSPHRASE);
        if (noPassphrase) {
          mNoPassphrase.setChecked(true);
          mChangePassPhrase.setVisibility(View.GONE);
        }
      }
      if (extras.containsKey(EXTRA_GENERATE_DEFAULT_KEYS)) {
        boolean generateDefaultKeys=extras.getBoolean(EXTRA_GENERATE_DEFAULT_KEYS);
        if (generateDefaultKeys) {
          mBuildLayout=false;
          Intent intent=new Intent(this,ApgService.class);
          intent.putExtra(ApgService.EXTRA_ACTION,ApgService.ACTION_GENERATE_DEFAULT_RSA_KEYS);
          Bundle data=new Bundle();
          data.putString(ApgService.SYMMETRIC_PASSPHRASE,mCurrentPassPhrase);
          intent.putExtra(ApgService.EXTRA_DATA,data);
          ApgServiceHandler saveHandler=new ApgServiceHandler(this,R.string.progress_generating,ProgressDialog.STYLE_SPINNER){
            public void handleMessage(            Message message){
              super.handleMessage(message);
              if (message.arg1 == ApgServiceHandler.MESSAGE_OKAY) {
                Bundle data=message.getData();
                PGPSecretKeyRing masterKeyRing=PGPConversionHelper.BytesToPGPSecretKeyRing(data.getByteArray(ApgService.RESULT_NEW_KEY));
                PGPSecretKeyRing subKeyRing=PGPConversionHelper.BytesToPGPSecretKeyRing(data.getByteArray(ApgService.RESULT_NEW_KEY2));
                @SuppressWarnings(""String_Node_Str"") Iterator<PGPSecretKey> masterIt=masterKeyRing.getSecretKeys();
                mKeys.add(masterIt.next());
                mKeysUsages.add(Id.choice.usage.sign_only);
                @SuppressWarnings(""String_Node_Str"") Iterator<PGPSecretKey> subIt=subKeyRing.getSecretKeys();
                subIt.next();
                mKeys.add(subIt.next());
                mKeysUsages.add(Id.choice.usage.encrypt_only);
                buildLayout();
              }
            }
          }
;
          Messenger messenger=new Messenger(saveHandler);
          intent.putExtra(ApgService.EXTRA_MESSENGER,messenger);
          saveHandler.showProgressDialog(this);
          startService(intent);
        }
      }
    }
  }
 else   if (ACTION_EDIT_KEY.equals(mIntent.getAction())) {
    mActionBar.setTitle(R.string.title_editKey);
    mCurrentPassPhrase=PGPMain.getEditPassPhrase();
    if (mCurrentPassPhrase == null) {
      mCurrentPassPhrase=""String_Node_Str"";
    }
    if (mCurrentPassPhrase.equals(""String_Node_Str"")) {
      mNoPassphrase.setChecked(true);
      mChangePassPhrase.setVisibility(View.GONE);
    }
    if (extras != null) {
      if (extras.containsKey(EXTRA_KEY_ID)) {
        long keyId=mIntent.getExtras().getLong(EXTRA_KEY_ID);
        if (keyId != 0) {
          PGPSecretKey masterKey=null;
          mKeyRing=PGPMain.getSecretKeyRing(keyId);
          if (mKeyRing != null) {
            masterKey=PGPHelper.getMasterKey(mKeyRing);
            for (            PGPSecretKey key : new IterableIterator<PGPSecretKey>(mKeyRing.getSecretKeys())) {
              mKeys.add(key);
              mKeysUsages.add(-1);
            }
          }
          if (masterKey != null) {
            for (            String userId : new IterableIterator<String>(masterKey.getUserIDs())) {
              mUserIds.add(userId);
            }
          }
        }
      }
    }
  }
  mChangePassPhrase.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      showSetPassphraseDialog();
    }
  }
);
  mNoPassphrase.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      if (isChecked) {
        mNewPassPhrase=null;
        mChangePassPhrase.setVisibility(View.GONE);
      }
 else {
        mChangePassPhrase.setVisibility(View.VISIBLE);
      }
    }
  }
);
  if (mBuildLayout) {
    buildLayout();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.edit_key);
  mActionBar=getSupportActionBar();
  mActionBar.setDisplayShowTitleEnabled(true);
  OtherHelper.setActionBarBackButton(this);
  mChangePassPhrase=(Button)findViewById(R.id.edit_key_btn_change_pass_phrase);
  mNoPassphrase=(CheckBox)findViewById(R.id.edit_key_no_passphrase);
  mUserIds=new Vector<String>();
  mKeys=new Vector<PGPSecretKey>();
  mKeysUsages=new Vector<Integer>();
  Intent intent=getIntent();
  String action=intent.getAction();
  if (ACTION_CREATE_KEY.equals(action)) {
    handleActionCreateKey(intent);
  }
 else   if (ACTION_EDIT_KEY.equals(action)) {
    handleActionEditKey(intent);
  }
  mChangePassPhrase.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      showSetPassphraseDialog();
    }
  }
);
  mNoPassphrase.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      if (isChecked) {
        mNewPassPhrase=null;
        mChangePassPhrase.setVisibility(View.GONE);
      }
 else {
        mChangePassPhrase.setVisibility(View.VISIBLE);
      }
    }
  }
);
  if (mBuildLayout) {
    buildLayout();
  }
}",0.3928280358598207
8421,"/** 
 * Returns usage selections of keys from the SectionView
 * @param keysView
 * @return
 */
private Vector<Integer> getKeysUsages(SectionView keysView) throws PGPMain.GeneralException {
  Vector<Integer> getKeysUsages=new Vector<Integer>();
  ViewGroup keyEditors=keysView.getEditors();
  if (keyEditors.getChildCount() == 0) {
    throw new PGPMain.GeneralException(getString(R.string.error_keyNeedsMasterKey));
  }
  for (int i=0; i < keyEditors.getChildCount(); ++i) {
    KeyEditor editor=(KeyEditor)keyEditors.getChildAt(i);
    getKeysUsages.add(editor.getUsage());
  }
  return getKeysUsages;
}","/** 
 * Returns usage selections of keys from the SectionView
 * @param keysView
 * @return
 */
private ArrayList<Integer> getKeysUsages(SectionView keysView) throws PGPMain.GeneralException {
  ArrayList<Integer> getKeysUsages=new ArrayList<Integer>();
  ViewGroup keyEditors=keysView.getEditors();
  if (keyEditors.getChildCount() == 0) {
    throw new PGPMain.GeneralException(getString(R.string.error_keyNeedsMasterKey));
  }
  for (int i=0; i < keyEditors.getChildCount(); ++i) {
    KeyEditor editor=(KeyEditor)keyEditors.getChildAt(i);
    getKeysUsages.add(editor.getUsage());
  }
  return getKeysUsages;
}",0.963084495488105
8422,"/** 
 * Returns keys from the SectionView
 * @param keysView
 * @return
 */
private Vector<PGPSecretKey> getKeys(SectionView keysView) throws PGPMain.GeneralException {
  Vector<PGPSecretKey> keys=new Vector<PGPSecretKey>();
  ViewGroup keyEditors=keysView.getEditors();
  if (keyEditors.getChildCount() == 0) {
    throw new PGPMain.GeneralException(getString(R.string.error_keyNeedsMasterKey));
  }
  for (int i=0; i < keyEditors.getChildCount(); ++i) {
    KeyEditor editor=(KeyEditor)keyEditors.getChildAt(i);
    keys.add(editor.getValue());
  }
  return keys;
}","/** 
 * Returns keys from the SectionView
 * @param keysView
 * @return
 */
private ArrayList<PGPSecretKey> getKeys(SectionView keysView) throws PGPMain.GeneralException {
  ArrayList<PGPSecretKey> keys=new ArrayList<PGPSecretKey>();
  ViewGroup keyEditors=keysView.getEditors();
  if (keyEditors.getChildCount() == 0) {
    throw new PGPMain.GeneralException(getString(R.string.error_keyNeedsMasterKey));
  }
  for (int i=0; i < keyEditors.getChildCount(); ++i) {
    KeyEditor editor=(KeyEditor)keyEditors.getChildAt(i);
    keys.add(editor.getValue());
  }
  return keys;
}",0.9606299212598424
8423,"/** 
 * Returns user ids from the SectionView
 * @param userIdsView
 * @return
 */
private Vector<String> getUserIds(SectionView userIdsView) throws PGPMain.GeneralException {
  Vector<String> userIds=new Vector<String>();
  ViewGroup userIdEditors=userIdsView.getEditors();
  boolean gotMainUserId=false;
  for (int i=0; i < userIdEditors.getChildCount(); ++i) {
    UserIdEditor editor=(UserIdEditor)userIdEditors.getChildAt(i);
    String userId=null;
    try {
      userId=editor.getValue();
    }
 catch (    UserIdEditor.NoNameException e) {
      throw new PGPMain.GeneralException(this.getString(R.string.error_userIdNeedsAName));
    }
catch (    UserIdEditor.NoEmailException e) {
      throw new PGPMain.GeneralException(this.getString(R.string.error_userIdNeedsAnEmailAddress));
    }
catch (    UserIdEditor.InvalidEmailException e) {
      throw new PGPMain.GeneralException(e.getMessage());
    }
    if (userId.equals(""String_Node_Str"")) {
      continue;
    }
    if (editor.isMainUserId()) {
      userIds.insertElementAt(userId,0);
      gotMainUserId=true;
    }
 else {
      userIds.add(userId);
    }
  }
  if (userIds.size() == 0) {
    throw new PGPMain.GeneralException(getString(R.string.error_keyNeedsAUserId));
  }
  if (!gotMainUserId) {
    throw new PGPMain.GeneralException(getString(R.string.error_mainUserIdMustNotBeEmpty));
  }
  return userIds;
}","/** 
 * Returns user ids from the SectionView
 * @param userIdsView
 * @return
 */
private ArrayList<String> getUserIds(SectionView userIdsView) throws PGPMain.GeneralException {
  ArrayList<String> userIds=new ArrayList<String>();
  ViewGroup userIdEditors=userIdsView.getEditors();
  boolean gotMainUserId=false;
  for (int i=0; i < userIdEditors.getChildCount(); ++i) {
    UserIdEditor editor=(UserIdEditor)userIdEditors.getChildAt(i);
    String userId=null;
    try {
      userId=editor.getValue();
    }
 catch (    UserIdEditor.NoNameException e) {
      throw new PGPMain.GeneralException(this.getString(R.string.error_userIdNeedsAName));
    }
catch (    UserIdEditor.NoEmailException e) {
      throw new PGPMain.GeneralException(this.getString(R.string.error_userIdNeedsAnEmailAddress));
    }
catch (    UserIdEditor.InvalidEmailException e) {
      throw new PGPMain.GeneralException(e.getMessage());
    }
    if (userId.equals(""String_Node_Str"")) {
      continue;
    }
    if (editor.isMainUserId()) {
      userIds.add(0,userId);
      gotMainUserId=true;
    }
 else {
      userIds.add(userId);
    }
  }
  if (userIds.size() == 0) {
    throw new PGPMain.GeneralException(getString(R.string.error_keyNeedsAUserId));
  }
  if (!gotMainUserId) {
    throw new PGPMain.GeneralException(getString(R.string.error_mainUserIdMustNotBeEmpty));
  }
  return userIds;
}",0.9714492229851824
8424,"private void saveClicked(){
  try {
    if (!isPassphraseSet()) {
      throw new PGPMain.GeneralException(this.getString(R.string.setAPassPhrase));
    }
    Intent intent=new Intent(this,ApgService.class);
    intent.putExtra(ApgService.EXTRA_ACTION,ApgService.ACTION_SAVE_KEYRING);
    Bundle data=new Bundle();
    data.putString(ApgService.CURRENT_PASSPHRASE,mCurrentPassPhrase);
    data.putString(ApgService.NEW_PASSPHRASE,mNewPassPhrase);
    data.putSerializable(ApgService.USER_IDS,getUserIds(mUserIdsView));
    Vector<PGPSecretKey> keys=getKeys(mKeysView);
    data.putByteArray(ApgService.KEYS,PGPConversionHelper.PGPSecretKeyListToBytes(keys));
    data.putSerializable(ApgService.KEYS_USAGES,getKeysUsages(mKeysView));
    data.putLong(ApgService.MASTER_KEY_ID,getMasterKeyId());
    intent.putExtra(ApgService.EXTRA_DATA,data);
    ApgServiceHandler saveHandler=new ApgServiceHandler(this,R.string.progress_saving,ProgressDialog.STYLE_HORIZONTAL){
      public void handleMessage(      Message message){
        super.handleMessage(message);
        if (message.arg1 == ApgServiceHandler.MESSAGE_OKAY) {
          finish();
        }
      }
    }
;
    Messenger messenger=new Messenger(saveHandler);
    intent.putExtra(ApgService.EXTRA_MESSENGER,messenger);
    saveHandler.showProgressDialog(this);
    startService(intent);
  }
 catch (  PGPMain.GeneralException e) {
    Toast.makeText(this,getString(R.string.errorMessage,e.getMessage()),Toast.LENGTH_SHORT).show();
  }
}","private void saveClicked(){
  try {
    if (!isPassphraseSet()) {
      throw new PGPMain.GeneralException(this.getString(R.string.setAPassPhrase));
    }
    Intent intent=new Intent(this,ApgService.class);
    intent.putExtra(ApgService.EXTRA_ACTION,ApgService.ACTION_SAVE_KEYRING);
    Bundle data=new Bundle();
    data.putString(ApgService.CURRENT_PASSPHRASE,mCurrentPassPhrase);
    data.putString(ApgService.NEW_PASSPHRASE,mNewPassPhrase);
    data.putStringArrayList(ApgService.USER_IDS,getUserIds(mUserIdsView));
    ArrayList<PGPSecretKey> keys=getKeys(mKeysView);
    data.putByteArray(ApgService.KEYS,PGPConversionHelper.PGPSecretKeyListToBytes(keys));
    data.putIntegerArrayList(ApgService.KEYS_USAGES,getKeysUsages(mKeysView));
    data.putLong(ApgService.MASTER_KEY_ID,getMasterKeyId());
    intent.putExtra(ApgService.EXTRA_DATA,data);
    ApgServiceHandler saveHandler=new ApgServiceHandler(this,R.string.progress_saving,ProgressDialog.STYLE_HORIZONTAL){
      public void handleMessage(      Message message){
        super.handleMessage(message);
        if (message.arg1 == ApgServiceHandler.MESSAGE_OKAY) {
          finish();
        }
      }
    }
;
    Messenger messenger=new Messenger(saveHandler);
    intent.putExtra(ApgService.EXTRA_MESSENGER,messenger);
    saveHandler.showProgressDialog(this);
    startService(intent);
  }
 catch (  PGPMain.GeneralException e) {
    Toast.makeText(this,getString(R.string.errorMessage,e.getMessage()),Toast.LENGTH_SHORT).show();
  }
}",0.9773182121414276
8425,"public static Bundle verifyText(Context context,InputData data,OutputStream outStream,boolean lookupUnknownKey,ProgressDialogUpdater progress) throws IOException, ApgGeneralException, PGPException, SignatureException {
  Bundle returnData=new Bundle();
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ArmoredInputStream aIn=new ArmoredInputStream(data.getInputStream());
  updateProgress(progress,R.string.progress_done,0,100);
  ByteArrayOutputStream lineOut=new ByteArrayOutputStream();
  int lookAhead=readInputLine(lineOut,aIn);
  byte[] lineSep=getLineSeparator();
  byte[] line=lineOut.toByteArray();
  out.write(line,0,getLengthWithoutSeparator(line));
  out.write(lineSep);
  while (lookAhead != -1 && aIn.isClearText()) {
    lookAhead=readInputLine(lineOut,lookAhead,aIn);
    line=lineOut.toByteArray();
    out.write(line,0,getLengthWithoutSeparator(line));
    out.write(lineSep);
  }
  out.close();
  byte[] clearText=out.toByteArray();
  outStream.write(clearText);
  returnData.putBoolean(ApgService.RESULT_SIGNATURE,true);
  updateProgress(progress,R.string.progress_processingSignature,60,100);
  PGPObjectFactory pgpFact=new PGPObjectFactory(aIn);
  PGPSignatureList sigList=(PGPSignatureList)pgpFact.nextObject();
  if (sigList == null) {
    throw new ApgGeneralException(context.getString(R.string.error_corruptData));
  }
  PGPSignature signature=null;
  long signatureKeyId=0;
  PGPPublicKey signatureKey=null;
  for (int i=0; i < sigList.size(); ++i) {
    signature=sigList.get(i);
    signatureKey=ProviderHelper.getPGPPublicKey(context,signature.getKeyID());
    if (signatureKeyId == 0) {
      signatureKeyId=signature.getKeyID();
    }
    if (signatureKey == null && lookupUnknownKey) {
      returnData=new Bundle();
      returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
      returnData.putBoolean(ApgService.RESULT_SIGNATURE_LOOKUP_KEY,true);
      return returnData;
    }
    if (signatureKey == null) {
      signature=null;
    }
 else {
      signatureKeyId=signature.getKeyID();
      String userId=null;
      PGPPublicKeyRing sigKeyRing=ProviderHelper.getPGPPublicKeyRingByMasterKeyId(context,signatureKeyId);
      if (sigKeyRing != null) {
        userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(sigKeyRing));
      }
      returnData.putString(ApgService.RESULT_SIGNATURE_USER_ID,userId);
      break;
    }
  }
  returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
  if (signature == null) {
    returnData.putBoolean(ApgService.RESULT_SIGNATURE_UNKNOWN,true);
    if (progress != null)     progress.setProgress(R.string.progress_done,100,100);
    return returnData;
  }
  JcaPGPContentVerifierBuilderProvider contentVerifierBuilderProvider=new JcaPGPContentVerifierBuilderProvider().setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
  signature.init(contentVerifierBuilderProvider,signatureKey);
  InputStream sigIn=new BufferedInputStream(new ByteArrayInputStream(clearText));
  lookAhead=readInputLine(lineOut,sigIn);
  processLine(signature,lineOut.toByteArray());
  if (lookAhead != -1) {
    do {
      lookAhead=readInputLine(lineOut,lookAhead,sigIn);
      signature.update((byte)'\r');
      signature.update((byte)'\n');
      processLine(signature,lineOut.toByteArray());
    }
 while (lookAhead != -1);
  }
  returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,signature.verify());
  updateProgress(progress,R.string.progress_done,100,100);
  return returnData;
}","public static Bundle verifyText(Context context,InputData data,OutputStream outStream,boolean lookupUnknownKey,ProgressDialogUpdater progress) throws IOException, ApgGeneralException, PGPException, SignatureException {
  Bundle returnData=new Bundle();
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ArmoredInputStream aIn=new ArmoredInputStream(data.getInputStream());
  updateProgress(progress,R.string.progress_done,0,100);
  ByteArrayOutputStream lineOut=new ByteArrayOutputStream();
  int lookAhead=readInputLine(lineOut,aIn);
  byte[] lineSep=getLineSeparator();
  byte[] line=lineOut.toByteArray();
  out.write(line,0,getLengthWithoutSeparator(line));
  out.write(lineSep);
  while (lookAhead != -1 && aIn.isClearText()) {
    lookAhead=readInputLine(lineOut,lookAhead,aIn);
    line=lineOut.toByteArray();
    out.write(line,0,getLengthWithoutSeparator(line));
    out.write(lineSep);
  }
  out.close();
  byte[] clearText=out.toByteArray();
  outStream.write(clearText);
  returnData.putBoolean(ApgService.RESULT_SIGNATURE,true);
  updateProgress(progress,R.string.progress_processingSignature,60,100);
  PGPObjectFactory pgpFact=new PGPObjectFactory(aIn);
  PGPSignatureList sigList=(PGPSignatureList)pgpFact.nextObject();
  if (sigList == null) {
    throw new ApgGeneralException(context.getString(R.string.error_corruptData));
  }
  PGPSignature signature=null;
  long signatureKeyId=0;
  PGPPublicKey signatureKey=null;
  for (int i=0; i < sigList.size(); ++i) {
    signature=sigList.get(i);
    signatureKey=ProviderHelper.getPGPPublicKey(context,signature.getKeyID());
    if (signatureKeyId == 0) {
      signatureKeyId=signature.getKeyID();
    }
    if (signatureKey == null && lookupUnknownKey) {
      returnData=new Bundle();
      returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
      returnData.putBoolean(ApgService.RESULT_SIGNATURE_LOOKUP_KEY,true);
      return returnData;
    }
    if (signatureKey == null) {
      signature=null;
    }
 else {
      signatureKeyId=signature.getKeyID();
      String userId=null;
      PGPPublicKeyRing signKeyRing=ProviderHelper.getPGPPublicKeyRingByMasterKeyId(context,signatureKeyId);
      if (signKeyRing != null) {
        userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(signKeyRing));
      }
      returnData.putString(ApgService.RESULT_SIGNATURE_USER_ID,userId);
      break;
    }
  }
  returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
  if (signature == null) {
    returnData.putBoolean(ApgService.RESULT_SIGNATURE_UNKNOWN,true);
    if (progress != null)     progress.setProgress(R.string.progress_done,100,100);
    return returnData;
  }
  JcaPGPContentVerifierBuilderProvider contentVerifierBuilderProvider=new JcaPGPContentVerifierBuilderProvider().setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
  signature.init(contentVerifierBuilderProvider,signatureKey);
  InputStream sigIn=new BufferedInputStream(new ByteArrayInputStream(clearText));
  lookAhead=readInputLine(lineOut,sigIn);
  processLine(signature,lineOut.toByteArray());
  if (lookAhead != -1) {
    do {
      lookAhead=readInputLine(lineOut,lookAhead,sigIn);
      signature.update((byte)'\r');
      signature.update((byte)'\n');
      processLine(signature,lineOut.toByteArray());
    }
 while (lookAhead != -1);
  }
  returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,signature.verify());
  updateProgress(progress,R.string.progress_done,100,100);
  return returnData;
}",0.999569151227919
8426,"public static void buildSecretKey(Context context,ArrayList<String> userIds,ArrayList<PGPSecretKey> keys,ArrayList<Integer> keysUsages,long masterKeyId,String oldPassPhrase,String newPassPhrase,ProgressDialogUpdater progress) throws ApgGeneralException, NoSuchProviderException, PGPException, NoSuchAlgorithmException, SignatureException, IOException {
  updateProgress(progress,R.string.progress_buildingKey,0,100);
  if (oldPassPhrase == null || oldPassPhrase.equals(""String_Node_Str"")) {
    oldPassPhrase=""String_Node_Str"";
  }
  if (newPassPhrase == null || newPassPhrase.equals(""String_Node_Str"")) {
    newPassPhrase=""String_Node_Str"";
  }
  updateProgress(progress,R.string.progress_preparingMasterKey,10,100);
  int usageId=keysUsages.get(0);
  boolean canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
  boolean canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
  String mainUserId=userIds.get(0);
  PGPSecretKey masterKey=keys.get(0);
  PGPPublicKey masterPublicKey=masterKey.getPublicKey();
  masterPublicKey=PGPPublicKey.removeCertification(masterPublicKey,""String_Node_Str"");
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
  PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(keyDecryptor);
  updateProgress(progress,R.string.progress_certifyingMasterKey,20,100);
  for (  String userId : userIds) {
    PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1).setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
    PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
    sGen.init(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
    PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
    masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,userId,certification);
  }
  PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
  PGPSignatureSubpacketGenerator hashedPacketsGen=new PGPSignatureSubpacketGenerator();
  PGPSignatureSubpacketGenerator unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
  int keyFlags=KeyFlags.CERTIFY_OTHER | KeyFlags.SIGN_DATA;
  if (canEncrypt) {
    keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
  }
  hashedPacketsGen.setKeyFlags(true,keyFlags);
  hashedPacketsGen.setPreferredSymmetricAlgorithms(true,PREFERRED_SYMMETRIC_ALGORITHMS);
  hashedPacketsGen.setPreferredHashAlgorithms(true,PREFERRED_HASH_ALGORITHMS);
  hashedPacketsGen.setPreferredCompressionAlgorithms(true,PREFERRED_COMPRESSION_ALGORITHMS);
  updateProgress(progress,R.string.progress_buildingMasterKeyRing,30,100);
  PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
  PGPContentSignerBuilder certificationSignerBuilder=new JcaPGPContentSignerBuilder(masterKeyPair.getPublicKey().getAlgorithm(),HashAlgorithmTags.SHA1);
  PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(newPassPhrase.toCharArray());
  PGPKeyRingGenerator keyGen=new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION,masterKeyPair,mainUserId,sha1Calc,hashedPacketsGen.generate(),unhashedPacketsGen.generate(),certificationSignerBuilder,keyEncryptor);
  updateProgress(progress,R.string.progress_addingSubKeys,40,100);
  for (int i=1; i < keys.size(); ++i) {
    updateProgress(progress,40 + 50 * (i - 1) / (keys.size() - 1),100);
    PGPSecretKey subKey=keys.get(i);
    PGPPublicKey subPublicKey=subKey.getPublicKey();
    PBESecretKeyDecryptor keyDecryptor2=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
    PGPPrivateKey subPrivateKey=subKey.extractPrivateKey(keyDecryptor2);
    PGPKeyPair subKeyPair=new PGPKeyPair(subPublicKey,subPrivateKey);
    hashedPacketsGen=new PGPSignatureSubpacketGenerator();
    unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
    keyFlags=0;
    usageId=keysUsages.get(i);
    canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
    canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
    if (canSign) {
      keyFlags|=KeyFlags.SIGN_DATA;
    }
    if (canEncrypt) {
      keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
    }
    hashedPacketsGen.setKeyFlags(true,keyFlags);
    keyGen.addSubKey(subKeyPair,hashedPacketsGen.generate(),unhashedPacketsGen.generate());
  }
  PGPSecretKeyRing secretKeyRing=keyGen.generateSecretKeyRing();
  PGPPublicKeyRing publicKeyRing=keyGen.generatePublicKeyRing();
  updateProgress(progress,R.string.progress_savingKeyRing,90,100);
  ProviderHelper.saveKeyRing(context,secretKeyRing);
  ProviderHelper.saveKeyRing(context,publicKeyRing);
  updateProgress(progress,R.string.progress_done,100,100);
}","public static void buildSecretKey(Context context,ArrayList<String> userIds,ArrayList<PGPSecretKey> keys,ArrayList<Integer> keysUsages,long masterKeyId,String oldPassPhrase,String newPassPhrase,ProgressDialogUpdater progress) throws ApgGeneralException, NoSuchProviderException, PGPException, NoSuchAlgorithmException, SignatureException, IOException {
  updateProgress(progress,R.string.progress_buildingKey,0,100);
  if (oldPassPhrase == null) {
    oldPassPhrase=""String_Node_Str"";
  }
  if (newPassPhrase == null) {
    newPassPhrase=""String_Node_Str"";
  }
  updateProgress(progress,R.string.progress_preparingMasterKey,10,100);
  int usageId=keysUsages.get(0);
  boolean canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
  boolean canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
  String mainUserId=userIds.get(0);
  PGPSecretKey masterKey=keys.get(0);
  PGPPublicKey masterPublicKey=masterKey.getPublicKey();
  PGPPublicKey masterPublicKeyRmCert=PGPPublicKey.removeCertification(masterPublicKey,""String_Node_Str"");
  if (masterPublicKeyRmCert != null) {
    masterPublicKey=masterPublicKeyRmCert;
  }
  PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
  PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(keyDecryptor);
  updateProgress(progress,R.string.progress_certifyingMasterKey,20,100);
  for (  String userId : userIds) {
    PGPContentSignerBuilder signerBuilder=new JcaPGPContentSignerBuilder(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1).setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
    PGPSignatureGenerator sGen=new PGPSignatureGenerator(signerBuilder);
    sGen.init(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
    PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
    masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,userId,certification);
  }
  PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
  PGPSignatureSubpacketGenerator hashedPacketsGen=new PGPSignatureSubpacketGenerator();
  PGPSignatureSubpacketGenerator unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
  int keyFlags=KeyFlags.CERTIFY_OTHER | KeyFlags.SIGN_DATA;
  if (canEncrypt) {
    keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
  }
  hashedPacketsGen.setKeyFlags(true,keyFlags);
  hashedPacketsGen.setPreferredSymmetricAlgorithms(true,PREFERRED_SYMMETRIC_ALGORITHMS);
  hashedPacketsGen.setPreferredHashAlgorithms(true,PREFERRED_HASH_ALGORITHMS);
  hashedPacketsGen.setPreferredCompressionAlgorithms(true,PREFERRED_COMPRESSION_ALGORITHMS);
  updateProgress(progress,R.string.progress_buildingMasterKeyRing,30,100);
  PGPDigestCalculator sha1Calc=new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1);
  PGPContentSignerBuilder certificationSignerBuilder=new JcaPGPContentSignerBuilder(masterKeyPair.getPublicKey().getAlgorithm(),HashAlgorithmTags.SHA1);
  PBESecretKeyEncryptor keyEncryptor=new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5,sha1Calc).setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(newPassPhrase.toCharArray());
  PGPKeyRingGenerator keyGen=new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION,masterKeyPair,mainUserId,sha1Calc,hashedPacketsGen.generate(),unhashedPacketsGen.generate(),certificationSignerBuilder,keyEncryptor);
  updateProgress(progress,R.string.progress_addingSubKeys,40,100);
  for (int i=1; i < keys.size(); ++i) {
    updateProgress(progress,40 + 50 * (i - 1) / (keys.size() - 1),100);
    PGPSecretKey subKey=keys.get(i);
    PGPPublicKey subPublicKey=subKey.getPublicKey();
    PBESecretKeyDecryptor keyDecryptor2=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(oldPassPhrase.toCharArray());
    PGPPrivateKey subPrivateKey=subKey.extractPrivateKey(keyDecryptor2);
    PGPKeyPair subKeyPair=new PGPKeyPair(subPublicKey,subPrivateKey);
    hashedPacketsGen=new PGPSignatureSubpacketGenerator();
    unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
    keyFlags=0;
    usageId=keysUsages.get(i);
    canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
    canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
    if (canSign) {
      keyFlags|=KeyFlags.SIGN_DATA;
    }
    if (canEncrypt) {
      keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
    }
    hashedPacketsGen.setKeyFlags(true,keyFlags);
    keyGen.addSubKey(subKeyPair,hashedPacketsGen.generate(),unhashedPacketsGen.generate());
  }
  PGPSecretKeyRing secretKeyRing=keyGen.generateSecretKeyRing();
  PGPPublicKeyRing publicKeyRing=keyGen.generatePublicKeyRing();
  updateProgress(progress,R.string.progress_savingKeyRing,90,100);
  ProviderHelper.saveKeyRing(context,secretKeyRing);
  ProviderHelper.saveKeyRing(context,publicKeyRing);
  updateProgress(progress,R.string.progress_done,100,100);
}",0.9737230587540596
8427,"public static Bundle decrypt(Context context,InputData data,OutputStream outStream,String passPhrase,ProgressDialogUpdater progress,boolean assumeSymmetric) throws IOException, ApgGeneralException, PGPException, SignatureException {
  if (passPhrase == null) {
    passPhrase=""String_Node_Str"";
  }
  Bundle returnData=new Bundle();
  InputStream in=PGPUtil.getDecoderStream(data.getInputStream());
  PGPObjectFactory pgpF=new PGPObjectFactory(in);
  PGPEncryptedDataList enc;
  Object o=pgpF.nextObject();
  long signatureKeyId=0;
  int currentProgress=0;
  if (progress != null)   progress.setProgress(R.string.progress_readingData,currentProgress,100);
  if (o instanceof PGPEncryptedDataList) {
    enc=(PGPEncryptedDataList)o;
  }
 else {
    enc=(PGPEncryptedDataList)pgpF.nextObject();
  }
  if (enc == null) {
    throw new ApgGeneralException(context.getString(R.string.error_invalidData));
  }
  InputStream clear=null;
  PGPEncryptedData encryptedData=null;
  currentProgress+=5;
  if (assumeSymmetric) {
    PGPPBEEncryptedData pbe=null;
    Iterator<?> it=enc.getEncryptedDataObjects();
    while (it.hasNext()) {
      Object obj=it.next();
      if (obj instanceof PGPPBEEncryptedData) {
        pbe=(PGPPBEEncryptedData)obj;
        break;
      }
    }
    if (pbe == null) {
      throw new ApgGeneralException(context.getString(R.string.error_noSymmetricEncryptionPacket));
    }
    updateProgress(progress,R.string.progress_preparingStreams,currentProgress,100);
    PGPDigestCalculatorProvider digestCalcProvider=new JcaPGPDigestCalculatorProviderBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build();
    PBEDataDecryptorFactory decryptorFactory=new JcePBEDataDecryptorFactoryBuilder(digestCalcProvider).setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(passPhrase.toCharArray());
    clear=pbe.getDataStream(decryptorFactory);
    encryptedData=pbe;
    currentProgress+=5;
  }
 else {
    if (progress != null)     progress.setProgress(R.string.progress_findingKey,currentProgress,100);
    PGPPublicKeyEncryptedData pbe=null;
    PGPSecretKey secretKey=null;
    Iterator<?> it=enc.getEncryptedDataObjects();
    while (it.hasNext()) {
      Object obj=it.next();
      if (obj instanceof PGPPublicKeyEncryptedData) {
        PGPPublicKeyEncryptedData encData=(PGPPublicKeyEncryptedData)obj;
        secretKey=ProviderHelper.getPGPSecretKey(context,encData.getKeyID());
        if (secretKey != null) {
          pbe=encData;
          break;
        }
      }
    }
    if (secretKey == null) {
      throw new ApgGeneralException(context.getString(R.string.error_noSecretKeyFound));
    }
    currentProgress+=5;
    updateProgress(progress,R.string.progress_extractingKey,currentProgress,100);
    PGPPrivateKey privateKey=null;
    try {
      PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(passPhrase.toCharArray());
      privateKey=secretKey.extractPrivateKey(keyDecryptor);
    }
 catch (    PGPException e) {
      throw new PGPException(context.getString(R.string.error_wrongPassPhrase));
    }
    if (privateKey == null) {
      throw new ApgGeneralException(context.getString(R.string.error_couldNotExtractPrivateKey));
    }
    currentProgress+=5;
    updateProgress(progress,R.string.progress_preparingStreams,currentProgress,100);
    PublicKeyDataDecryptorFactory decryptorFactory=new JcePublicKeyDataDecryptorFactoryBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(privateKey);
    clear=pbe.getDataStream(decryptorFactory);
    encryptedData=pbe;
    currentProgress+=5;
  }
  PGPObjectFactory plainFact=new PGPObjectFactory(clear);
  Object dataChunk=plainFact.nextObject();
  PGPOnePassSignature signature=null;
  PGPPublicKey signatureKey=null;
  int signatureIndex=-1;
  if (dataChunk instanceof PGPCompressedData) {
    if (progress != null)     progress.setProgress(R.string.progress_decompressingData,currentProgress,100);
    PGPObjectFactory fact=new PGPObjectFactory(((PGPCompressedData)dataChunk).getDataStream());
    dataChunk=fact.nextObject();
    plainFact=fact;
    currentProgress+=10;
  }
  if (dataChunk instanceof PGPOnePassSignatureList) {
    if (progress != null)     progress.setProgress(R.string.progress_processingSignature,currentProgress,100);
    returnData.putBoolean(ApgService.RESULT_SIGNATURE,true);
    PGPOnePassSignatureList sigList=(PGPOnePassSignatureList)dataChunk;
    for (int i=0; i < sigList.size(); ++i) {
      signature=sigList.get(i);
      signatureKey=ProviderHelper.getPGPPublicKey(context,signature.getKeyID());
      if (signatureKeyId == 0) {
        signatureKeyId=signature.getKeyID();
      }
      if (signatureKey == null) {
        signature=null;
      }
 else {
        signatureIndex=i;
        signatureKeyId=signature.getKeyID();
        String userId=null;
        PGPPublicKeyRing sigKeyRing=ProviderHelper.getPGPPublicKeyRingByMasterKeyId(context,signatureKeyId);
        if (sigKeyRing != null) {
          userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(sigKeyRing));
        }
        returnData.putString(ApgService.RESULT_SIGNATURE_USER_ID,userId);
        break;
      }
    }
    returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
    if (signature != null) {
      JcaPGPContentVerifierBuilderProvider contentVerifierBuilderProvider=new JcaPGPContentVerifierBuilderProvider().setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
      signature.init(contentVerifierBuilderProvider,signatureKey);
    }
 else {
      returnData.putBoolean(ApgService.RESULT_SIGNATURE_UNKNOWN,true);
    }
    dataChunk=plainFact.nextObject();
    currentProgress+=10;
  }
  if (dataChunk instanceof PGPSignatureList) {
    dataChunk=plainFact.nextObject();
  }
  if (dataChunk instanceof PGPLiteralData) {
    if (progress != null)     progress.setProgress(R.string.progress_decrypting,currentProgress,100);
    PGPLiteralData literalData=(PGPLiteralData)dataChunk;
    OutputStream out=outStream;
    byte[] buffer=new byte[1 << 16];
    InputStream dataIn=literalData.getInputStream();
    int startProgress=currentProgress;
    int endProgress=100;
    if (signature != null) {
      endProgress=90;
    }
 else     if (encryptedData.isIntegrityProtected()) {
      endProgress=95;
    }
    int n=0;
    int done=0;
    long startPos=data.getStreamPosition();
    while ((n=dataIn.read(buffer)) > 0) {
      out.write(buffer,0,n);
      done+=n;
      if (signature != null) {
        try {
          signature.update(buffer,0,n);
        }
 catch (        SignatureException e) {
          returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,false);
          signature=null;
        }
      }
      currentProgress=startProgress + (endProgress - startProgress) * done / (done + 100000);
      if (data.getSize() - startPos == 0) {
        currentProgress=endProgress;
      }
 else {
        currentProgress=(int)(startProgress + (endProgress - startProgress) * (data.getStreamPosition() - startPos) / (data.getSize() - startPos));
      }
      updateProgress(progress,currentProgress,100);
    }
    if (signature != null) {
      if (progress != null)       progress.setProgress(R.string.progress_verifyingSignature,90,100);
      PGPSignatureList signatureList=(PGPSignatureList)plainFact.nextObject();
      PGPSignature messageSignature=signatureList.get(signatureIndex);
      if (signature.verify(messageSignature)) {
        returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,true);
      }
 else {
        returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,false);
      }
    }
  }
  if (encryptedData.isIntegrityProtected()) {
    if (progress != null)     progress.setProgress(R.string.progress_verifyingIntegrity,95,100);
    if (encryptedData.verify()) {
    }
 else {
    }
  }
 else {
  }
  updateProgress(progress,R.string.progress_done,100,100);
  return returnData;
}","public static Bundle decrypt(Context context,InputData data,OutputStream outStream,String passPhrase,ProgressDialogUpdater progress,boolean assumeSymmetric) throws IOException, ApgGeneralException, PGPException, SignatureException {
  if (passPhrase == null) {
    passPhrase=""String_Node_Str"";
  }
  Bundle returnData=new Bundle();
  InputStream in=PGPUtil.getDecoderStream(data.getInputStream());
  PGPObjectFactory pgpF=new PGPObjectFactory(in);
  PGPEncryptedDataList enc;
  Object o=pgpF.nextObject();
  long signatureKeyId=0;
  int currentProgress=0;
  if (progress != null)   progress.setProgress(R.string.progress_readingData,currentProgress,100);
  if (o instanceof PGPEncryptedDataList) {
    enc=(PGPEncryptedDataList)o;
  }
 else {
    enc=(PGPEncryptedDataList)pgpF.nextObject();
  }
  if (enc == null) {
    throw new ApgGeneralException(context.getString(R.string.error_invalidData));
  }
  InputStream clear=null;
  PGPEncryptedData encryptedData=null;
  currentProgress+=5;
  if (assumeSymmetric) {
    PGPPBEEncryptedData pbe=null;
    Iterator<?> it=enc.getEncryptedDataObjects();
    while (it.hasNext()) {
      Object obj=it.next();
      if (obj instanceof PGPPBEEncryptedData) {
        pbe=(PGPPBEEncryptedData)obj;
        break;
      }
    }
    if (pbe == null) {
      throw new ApgGeneralException(context.getString(R.string.error_noSymmetricEncryptionPacket));
    }
    updateProgress(progress,R.string.progress_preparingStreams,currentProgress,100);
    PGPDigestCalculatorProvider digestCalcProvider=new JcaPGPDigestCalculatorProviderBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build();
    PBEDataDecryptorFactory decryptorFactory=new JcePBEDataDecryptorFactoryBuilder(digestCalcProvider).setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(passPhrase.toCharArray());
    clear=pbe.getDataStream(decryptorFactory);
    encryptedData=pbe;
    currentProgress+=5;
  }
 else {
    if (progress != null)     progress.setProgress(R.string.progress_findingKey,currentProgress,100);
    PGPPublicKeyEncryptedData pbe=null;
    PGPSecretKey secretKey=null;
    Iterator<?> it=enc.getEncryptedDataObjects();
    while (it.hasNext()) {
      Object obj=it.next();
      if (obj instanceof PGPPublicKeyEncryptedData) {
        PGPPublicKeyEncryptedData encData=(PGPPublicKeyEncryptedData)obj;
        secretKey=ProviderHelper.getPGPSecretKey(context,encData.getKeyID());
        if (secretKey != null) {
          pbe=encData;
          break;
        }
      }
    }
    if (secretKey == null) {
      throw new ApgGeneralException(context.getString(R.string.error_noSecretKeyFound));
    }
    currentProgress+=5;
    updateProgress(progress,R.string.progress_extractingKey,currentProgress,100);
    PGPPrivateKey privateKey=null;
    try {
      PBESecretKeyDecryptor keyDecryptor=new JcePBESecretKeyDecryptorBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(passPhrase.toCharArray());
      privateKey=secretKey.extractPrivateKey(keyDecryptor);
    }
 catch (    PGPException e) {
      throw new PGPException(context.getString(R.string.error_wrongPassPhrase));
    }
    if (privateKey == null) {
      throw new ApgGeneralException(context.getString(R.string.error_couldNotExtractPrivateKey));
    }
    currentProgress+=5;
    updateProgress(progress,R.string.progress_preparingStreams,currentProgress,100);
    PublicKeyDataDecryptorFactory decryptorFactory=new JcePublicKeyDataDecryptorFactoryBuilder().setProvider(BOUNCY_CASTLE_PROVIDER_NAME).build(privateKey);
    clear=pbe.getDataStream(decryptorFactory);
    encryptedData=pbe;
    currentProgress+=5;
  }
  PGPObjectFactory plainFact=new PGPObjectFactory(clear);
  Object dataChunk=plainFact.nextObject();
  PGPOnePassSignature signature=null;
  PGPPublicKey signatureKey=null;
  int signatureIndex=-1;
  if (dataChunk instanceof PGPCompressedData) {
    if (progress != null)     progress.setProgress(R.string.progress_decompressingData,currentProgress,100);
    PGPObjectFactory fact=new PGPObjectFactory(((PGPCompressedData)dataChunk).getDataStream());
    dataChunk=fact.nextObject();
    plainFact=fact;
    currentProgress+=10;
  }
  if (dataChunk instanceof PGPOnePassSignatureList) {
    if (progress != null)     progress.setProgress(R.string.progress_processingSignature,currentProgress,100);
    returnData.putBoolean(ApgService.RESULT_SIGNATURE,true);
    PGPOnePassSignatureList sigList=(PGPOnePassSignatureList)dataChunk;
    for (int i=0; i < sigList.size(); ++i) {
      signature=sigList.get(i);
      signatureKey=ProviderHelper.getPGPPublicKey(context,signature.getKeyID());
      if (signatureKeyId == 0) {
        signatureKeyId=signature.getKeyID();
      }
      if (signatureKey == null) {
        signature=null;
      }
 else {
        signatureIndex=i;
        signatureKeyId=signature.getKeyID();
        String userId=null;
        PGPPublicKeyRing signKeyRing=ProviderHelper.getPGPPublicKeyRingByMasterKeyId(context,signatureKeyId);
        if (signKeyRing != null) {
          userId=PGPHelper.getMainUserId(PGPHelper.getMasterKey(signKeyRing));
        }
        returnData.putString(ApgService.RESULT_SIGNATURE_USER_ID,userId);
        break;
      }
    }
    returnData.putLong(ApgService.RESULT_SIGNATURE_KEY_ID,signatureKeyId);
    if (signature != null) {
      JcaPGPContentVerifierBuilderProvider contentVerifierBuilderProvider=new JcaPGPContentVerifierBuilderProvider().setProvider(BOUNCY_CASTLE_PROVIDER_NAME);
      signature.init(contentVerifierBuilderProvider,signatureKey);
    }
 else {
      returnData.putBoolean(ApgService.RESULT_SIGNATURE_UNKNOWN,true);
    }
    dataChunk=plainFact.nextObject();
    currentProgress+=10;
  }
  if (dataChunk instanceof PGPSignatureList) {
    dataChunk=plainFact.nextObject();
  }
  if (dataChunk instanceof PGPLiteralData) {
    if (progress != null)     progress.setProgress(R.string.progress_decrypting,currentProgress,100);
    PGPLiteralData literalData=(PGPLiteralData)dataChunk;
    OutputStream out=outStream;
    byte[] buffer=new byte[1 << 16];
    InputStream dataIn=literalData.getInputStream();
    int startProgress=currentProgress;
    int endProgress=100;
    if (signature != null) {
      endProgress=90;
    }
 else     if (encryptedData.isIntegrityProtected()) {
      endProgress=95;
    }
    int n=0;
    int done=0;
    long startPos=data.getStreamPosition();
    while ((n=dataIn.read(buffer)) > 0) {
      out.write(buffer,0,n);
      done+=n;
      if (signature != null) {
        try {
          signature.update(buffer,0,n);
        }
 catch (        SignatureException e) {
          returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,false);
          signature=null;
        }
      }
      currentProgress=startProgress + (endProgress - startProgress) * done / (done + 100000);
      if (data.getSize() - startPos == 0) {
        currentProgress=endProgress;
      }
 else {
        currentProgress=(int)(startProgress + (endProgress - startProgress) * (data.getStreamPosition() - startPos) / (data.getSize() - startPos));
      }
      updateProgress(progress,currentProgress,100);
    }
    if (signature != null) {
      if (progress != null)       progress.setProgress(R.string.progress_verifyingSignature,90,100);
      PGPSignatureList signatureList=(PGPSignatureList)plainFact.nextObject();
      PGPSignature messageSignature=signatureList.get(signatureIndex);
      if (signature.verify(messageSignature)) {
        returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,true);
      }
 else {
        returnData.putBoolean(ApgService.RESULT_SIGNATURE_SUCCESS,false);
      }
    }
  }
  if (encryptedData.isIntegrityProtected()) {
    if (progress != null)     progress.setProgress(R.string.progress_verifyingIntegrity,95,100);
    if (encryptedData.verify()) {
    }
 else {
    }
  }
 else {
  }
  updateProgress(progress,R.string.progress_done,100,100);
  return returnData;
}",0.9998105223267858
8428,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case Id.menu.option.key_server:
{
      startActivity(new Intent(this,KeyServerQueryActivity.class));
      return true;
    }
case Id.menu.option.scanQRCode:
{
    Intent intent=new Intent(this,ImportFromQRCodeActivity.class);
    intent.setAction(ImportFromQRCodeActivity.IMPORT_FROM_QR_CODE);
    startActivityForResult(intent,Id.request.import_from_qr_code);
    return true;
  }
default :
{
  return super.onOptionsItemSelected(item);
}
}
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case Id.menu.option.key_server:
{
      startActivityForResult(new Intent(this,KeyServerQueryActivity.class),0);
      return true;
    }
case Id.menu.option.scanQRCode:
{
    Intent intent=new Intent(this,ImportFromQRCodeActivity.class);
    intent.setAction(ImportFromQRCodeActivity.IMPORT_FROM_QR_CODE);
    startActivityForResult(intent,Id.request.import_from_qr_code);
    return true;
  }
default :
{
  return super.onOptionsItemSelected(item);
}
}
}",0.989843028624192
8429,"private void editKey(long keyId){
  Intent intent=new Intent(EditKeyActivity.ACTION_EDIT_KEY);
  intent.putExtra(EditKeyActivity.EXTRA_KEY_ID,keyId);
  startActivityForResult(intent,Id.message.edit_key);
}","private void editKey(long keyId){
  Intent intent=new Intent(EditKeyActivity.ACTION_EDIT_KEY);
  intent.putExtra(EditKeyActivity.EXTRA_KEY_ID,keyId);
  startActivityForResult(intent,0);
}",0.9489795918367347
8430,"private void createKey(){
  PGPMain.setEditPassPhrase(""String_Node_Str"");
  Intent intent=new Intent(EditKeyActivity.ACTION_CREATE_KEY);
  startActivityForResult(intent,Id.message.create_key);
}","private void createKey(){
  PGPMain.setEditPassPhrase(""String_Node_Str"");
  Intent intent=new Intent(EditKeyActivity.ACTION_CREATE_KEY);
  startActivityForResult(intent,0);
}",0.9402173913043478
8431,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion){
  mDb=db;
  for (int version=oldVersion; version < newVersion; ++version) {
switch (version) {
case 1:
{
        db.execSQL(""String_Node_Str"" + KeyRings.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + Keys.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + UserIds.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + KeyRings.TABLE_NAME + ""String_Node_Str""+ KeyRings._ID+ ""String_Node_Str""+ KeyRings._ID_type+ ""String_Node_Str""+ KeyRings.MASTER_KEY_ID+ ""String_Node_Str""+ KeyRings.MASTER_KEY_ID_type+ ""String_Node_Str""+ KeyRings.TYPE+ ""String_Node_Str""+ KeyRings.TYPE_type+ ""String_Node_Str""+ KeyRings.WHO_ID+ ""String_Node_Str""+ KeyRings.WHO_ID_type+ ""String_Node_Str""+ KeyRings.KEY_RING_DATA+ ""String_Node_Str""+ KeyRings.KEY_RING_DATA_type+ ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + Keys.TABLE_NAME + ""String_Node_Str""+ Keys._ID+ ""String_Node_Str""+ Keys._ID_type+ ""String_Node_Str""+ Keys.KEY_ID+ ""String_Node_Str""+ Keys.KEY_ID_type+ ""String_Node_Str""+ Keys.TYPE+ ""String_Node_Str""+ Keys.TYPE_type+ ""String_Node_Str""+ Keys.IS_MASTER_KEY+ ""String_Node_Str""+ Keys.IS_MASTER_KEY_type+ ""String_Node_Str""+ Keys.ALGORITHM+ ""String_Node_Str""+ Keys.ALGORITHM_type+ ""String_Node_Str""+ Keys.KEY_SIZE+ ""String_Node_Str""+ Keys.KEY_SIZE_type+ ""String_Node_Str""+ Keys.CAN_SIGN+ ""String_Node_Str""+ Keys.CAN_SIGN_type+ ""String_Node_Str""+ Keys.CAN_ENCRYPT+ ""String_Node_Str""+ Keys.CAN_ENCRYPT_type+ ""String_Node_Str""+ Keys.IS_REVOKED+ ""String_Node_Str""+ Keys.IS_REVOKED_type+ ""String_Node_Str""+ Keys.CREATION+ ""String_Node_Str""+ Keys.CREATION_type+ ""String_Node_Str""+ Keys.EXPIRY+ ""String_Node_Str""+ Keys.EXPIRY_type+ ""String_Node_Str""+ Keys.KEY_RING_ID+ ""String_Node_Str""+ Keys.KEY_RING_ID_type+ ""String_Node_Str""+ Keys.KEY_DATA+ ""String_Node_Str""+ Keys.KEY_DATA_type+ Keys.RANK+ ""String_Node_Str""+ Keys.RANK_type+ ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + UserIds.TABLE_NAME + ""String_Node_Str""+ UserIds._ID+ ""String_Node_Str""+ UserIds._ID_type+ ""String_Node_Str""+ UserIds.KEY_ID+ ""String_Node_Str""+ UserIds.KEY_ID_type+ ""String_Node_Str""+ UserIds.USER_ID+ ""String_Node_Str""+ UserIds.USER_ID_type+ ""String_Node_Str""+ UserIds.RANK+ ""String_Node_Str""+ UserIds.RANK_type+ ""String_Node_Str"");
        Cursor cursor=db.query(PublicKeys.TABLE_NAME,new String[]{PublicKeys.KEY_DATA},null,null,null,null,null);
        if (cursor != null && cursor.moveToFirst()) {
          do {
            byte[] data=cursor.getBlob(cursor.getColumnIndex(PublicKeys.KEY_DATA));
            try {
              PGPPublicKeyRing keyRing=new PGPPublicKeyRing(data);
              saveKeyRing(keyRing);
              Log.e(""String_Node_Str"",""String_Node_Str"" + keyRing);
            }
 catch (            IOException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            GeneralException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
          }
 while (cursor.moveToNext());
        }
        cursor.close();
        cursor=db.query(SecretKeys.TABLE_NAME,new String[]{SecretKeys.KEY_DATA},null,null,null,null,null);
        if (cursor != null && cursor.moveToFirst()) {
          do {
            byte[] data=cursor.getBlob(cursor.getColumnIndex(SecretKeys.KEY_DATA));
            try {
              PGPSecretKeyRing keyRing=new PGPSecretKeyRing(data);
              saveKeyRing(keyRing);
              Log.e(""String_Node_Str"",""String_Node_Str"" + keyRing);
            }
 catch (            IOException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            PGPException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            GeneralException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
          }
 while (cursor.moveToNext());
        }
        if (cursor != null) {
          cursor.close();
        }
        break;
      }
default :
{
      break;
    }
}
}
mDb=null;
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion){
  mDb=db;
  for (int version=oldVersion; version < newVersion; ++version) {
switch (version) {
case 1:
{
        db.execSQL(""String_Node_Str"" + KeyRings.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + Keys.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + UserIds.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + KeyRings.TABLE_NAME + ""String_Node_Str""+ KeyRings._ID+ ""String_Node_Str""+ KeyRings._ID_type+ ""String_Node_Str""+ KeyRings.MASTER_KEY_ID+ ""String_Node_Str""+ KeyRings.MASTER_KEY_ID_type+ ""String_Node_Str""+ KeyRings.TYPE+ ""String_Node_Str""+ KeyRings.TYPE_type+ ""String_Node_Str""+ KeyRings.WHO_ID+ ""String_Node_Str""+ KeyRings.WHO_ID_type+ ""String_Node_Str""+ KeyRings.KEY_RING_DATA+ ""String_Node_Str""+ KeyRings.KEY_RING_DATA_type+ ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + Keys.TABLE_NAME + ""String_Node_Str""+ Keys._ID+ ""String_Node_Str""+ Keys._ID_type+ ""String_Node_Str""+ Keys.KEY_ID+ ""String_Node_Str""+ Keys.KEY_ID_type+ ""String_Node_Str""+ Keys.TYPE+ ""String_Node_Str""+ Keys.TYPE_type+ ""String_Node_Str""+ Keys.IS_MASTER_KEY+ ""String_Node_Str""+ Keys.IS_MASTER_KEY_type+ ""String_Node_Str""+ Keys.ALGORITHM+ ""String_Node_Str""+ Keys.ALGORITHM_type+ ""String_Node_Str""+ Keys.KEY_SIZE+ ""String_Node_Str""+ Keys.KEY_SIZE_type+ ""String_Node_Str""+ Keys.CAN_SIGN+ ""String_Node_Str""+ Keys.CAN_SIGN_type+ ""String_Node_Str""+ Keys.CAN_ENCRYPT+ ""String_Node_Str""+ Keys.CAN_ENCRYPT_type+ ""String_Node_Str""+ Keys.IS_REVOKED+ ""String_Node_Str""+ Keys.IS_REVOKED_type+ ""String_Node_Str""+ Keys.CREATION+ ""String_Node_Str""+ Keys.CREATION_type+ ""String_Node_Str""+ Keys.EXPIRY+ ""String_Node_Str""+ Keys.EXPIRY_type+ ""String_Node_Str""+ Keys.KEY_RING_ID+ ""String_Node_Str""+ Keys.KEY_RING_ID_type+ ""String_Node_Str""+ Keys.KEY_DATA+ ""String_Node_Str""+ Keys.KEY_DATA_type+ Keys.RANK+ ""String_Node_Str""+ Keys.RANK_type+ ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + UserIds.TABLE_NAME + ""String_Node_Str""+ UserIds._ID+ ""String_Node_Str""+ UserIds._ID_type+ ""String_Node_Str""+ UserIds.KEY_ID+ ""String_Node_Str""+ UserIds.KEY_ID_type+ ""String_Node_Str""+ UserIds.USER_ID+ ""String_Node_Str""+ UserIds.USER_ID_type+ ""String_Node_Str""+ UserIds.RANK+ ""String_Node_Str""+ UserIds.RANK_type+ ""String_Node_Str"");
        Cursor cursor=db.query(PublicKeys.TABLE_NAME,new String[]{PublicKeys.KEY_DATA},null,null,null,null,null);
        if (cursor != null && cursor.moveToFirst()) {
          do {
            byte[] data=cursor.getBlob(cursor.getColumnIndex(PublicKeys.KEY_DATA));
            try {
              PGPPublicKeyRing keyRing=new PGPPublicKeyRing(data);
              saveKeyRing(keyRing);
              Log.e(""String_Node_Str"",""String_Node_Str"" + keyRing);
            }
 catch (            IOException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            GeneralException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
          }
 while (cursor.moveToNext());
        }
        if (cursor != null) {
          cursor.close();
        }
        cursor=db.query(SecretKeys.TABLE_NAME,new String[]{SecretKeys.KEY_DATA},null,null,null,null,null);
        if (cursor != null && cursor.moveToFirst()) {
          do {
            byte[] data=cursor.getBlob(cursor.getColumnIndex(SecretKeys.KEY_DATA));
            try {
              PGPSecretKeyRing keyRing=new PGPSecretKeyRing(data);
              saveKeyRing(keyRing);
              Log.e(""String_Node_Str"",""String_Node_Str"" + keyRing);
            }
 catch (            IOException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            PGPException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            GeneralException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
          }
 while (cursor.moveToNext());
        }
        if (cursor != null) {
          cursor.close();
        }
        break;
      }
default :
{
      break;
    }
}
}
mDb=null;
}",0.9949336550060314
8432,"private long insertOrUpdateKey(ContentValues values){
  Cursor c=mDb.query(Keys.TABLE_NAME,new String[]{Keys._ID},Keys.KEY_ID + ""String_Node_Str"" + Keys.TYPE+ ""String_Node_Str"",new String[]{values.getAsString(Keys.KEY_ID),values.getAsString(Keys.TYPE)},null,null,null);
  long rowId=-1;
  if (c != null && c.moveToFirst()) {
    rowId=c.getLong(0);
    mDb.update(Keys.TABLE_NAME,values,Keys._ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + rowId});
  }
 else {
    rowId=mDb.insert(Keys.TABLE_NAME,Keys.KEY_DATA,values);
  }
  c.close();
  return rowId;
}","private long insertOrUpdateKey(ContentValues values){
  Cursor c=mDb.query(Keys.TABLE_NAME,new String[]{Keys._ID},Keys.KEY_ID + ""String_Node_Str"" + Keys.TYPE+ ""String_Node_Str"",new String[]{values.getAsString(Keys.KEY_ID),values.getAsString(Keys.TYPE)},null,null,null);
  long rowId=-1;
  if (c != null && c.moveToFirst()) {
    rowId=c.getLong(0);
    mDb.update(Keys.TABLE_NAME,values,Keys._ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + rowId});
  }
 else {
    rowId=mDb.insert(Keys.TABLE_NAME,Keys.KEY_DATA,values);
  }
  if (c != null) {
    c.close();
  }
  return rowId;
}",0.9297484822202948
8433,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.decrypt);
  mSource=(ViewFlipper)findViewById(R.id.source);
  mSourceLabel=(TextView)findViewById(R.id.sourceLabel);
  mSourcePrevious=(ImageView)findViewById(R.id.sourcePrevious);
  mSourceNext=(ImageView)findViewById(R.id.sourceNext);
  mSourcePrevious.setClickable(true);
  mSourcePrevious.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_right_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_right_out));
      mSource.showPrevious();
      updateSource();
    }
  }
);
  mSourceNext.setClickable(true);
  OnClickListener nextSourceClickListener=new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_left_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_left_out));
      mSource.showNext();
      updateSource();
    }
  }
;
  mSourceNext.setOnClickListener(nextSourceClickListener);
  mSourceLabel.setClickable(true);
  mSourceLabel.setOnClickListener(nextSourceClickListener);
  mMessage=(EditText)findViewById(R.id.message);
  mDecryptButton=(Button)findViewById(R.id.btn_decrypt);
  mReplyButton=(Button)findViewById(R.id.btn_reply);
  mSignatureLayout=(LinearLayout)findViewById(R.id.signature);
  mSignatureStatusImage=(ImageView)findViewById(R.id.ic_signature_status);
  mUserId=(TextView)findViewById(R.id.mainUserId);
  mUserIdRest=(TextView)findViewById(R.id.mainUserIdRest);
  View tmp=findViewById(R.id.sourceFile);
  tmp.measure(View.MeasureSpec.UNSPECIFIED,View.MeasureSpec.UNSPECIFIED);
  int height=tmp.getMeasuredHeight();
  mMessage.setMinimumHeight(height);
  mFilename=(EditText)findViewById(R.id.filename);
  mBrowse=(ImageButton)findViewById(R.id.btn_browse);
  mBrowse.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      openFile();
    }
  }
);
  mDeleteAfter=(CheckBox)findViewById(R.id.deleteAfterDecryption);
  mSource.setInAnimation(null);
  mSource.setOutAnimation(null);
  while (mSource.getCurrentView().getId() != R.id.sourceMessage) {
    mSource.showNext();
  }
  mIntent=getIntent();
  if (Intent.ACTION_VIEW.equals(mIntent.getAction())) {
    Uri uri=mIntent.getData();
    try {
      InputStream attachment=getContentResolver().openInputStream(uri);
      ByteArrayOutputStream byteOut=new ByteArrayOutputStream();
      byte bytes[]=new byte[1 << 16];
      int length;
      while ((length=attachment.read(bytes)) > 0) {
        byteOut.write(bytes,0,length);
      }
      byteOut.close();
      String data=new String(byteOut.toByteArray());
      mMessage.setText(data);
    }
 catch (    FileNotFoundException e) {
    }
catch (    IOException e) {
    }
  }
 else   if (Intent.ACTION_SEND.equals(mIntent.getAction())) {
    Bundle extras=mIntent.getExtras();
    if (extras == null) {
      extras=new Bundle();
    }
    String data=extras.getString(Intent.EXTRA_TEXT);
    if (data != null) {
      mMessage.setText(data);
    }
    mSubject=extras.getString(Intent.EXTRA_SUBJECT);
    if (mSubject.startsWith(""String_Node_Str"")) {
      mSubject=mSubject.substring(5);
    }
  }
 else   if (Apg.Intent.DECRYPT.equals(mIntent.getAction())) {
    Bundle extras=mIntent.getExtras();
    if (extras == null) {
      extras=new Bundle();
    }
    String data=extras.getString(Apg.EXTRA_DATA);
    if (data != null) {
      Matcher matcher=Apg.PGP_MESSAGE.matcher(data);
      if (matcher.matches()) {
        data=matcher.group(1);
        data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
        mMessage.setText(data);
      }
 else {
        matcher=Apg.PGP_SIGNED_MESSAGE.matcher(data);
        if (matcher.matches()) {
          data=matcher.group(1);
          data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
          mMessage.setText(data);
          mDecryptButton.setText(R.string.btn_verify);
        }
      }
    }
    mReplyTo=extras.getString(Apg.EXTRA_REPLY_TO);
    mSubject=extras.getString(Apg.EXTRA_SUBJECT);
  }
 else   if (Apg.Intent.DECRYPT_FILE.equals(mIntent.getAction())) {
    mSource.setInAnimation(null);
    mSource.setOutAnimation(null);
    while (mSource.getCurrentView().getId() != R.id.sourceFile) {
      mSource.showNext();
    }
  }
 else   if (Apg.Intent.DECRYPT_AND_RETURN.equals(mIntent.getAction())) {
    Bundle extras=mIntent.getExtras();
    if (extras == null) {
      extras=new Bundle();
    }
    String data=extras.getString(Apg.EXTRA_DATA);
    if (data != null) {
      Matcher matcher=Apg.PGP_MESSAGE.matcher(data);
      if (matcher.matches()) {
        data=matcher.group(1);
        data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
        mMessage.setText(data);
      }
 else {
        matcher=Apg.PGP_SIGNED_MESSAGE.matcher(data);
        if (matcher.matches()) {
          data=matcher.group(1);
          data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
          mMessage.setText(data);
          mDecryptButton.setText(R.string.btn_verify);
        }
      }
    }
    mReplyTo=extras.getString(Apg.EXTRA_REPLY_TO);
    mSubject=extras.getString(Apg.EXTRA_SUBJECT);
    mReturnResult=true;
  }
  if (mSource.getCurrentView().getId() == R.id.sourceMessage && mMessage.getText().length() == 0) {
    ClipboardManager clip=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
    String data=""String_Node_Str"";
    Matcher matcher=Apg.PGP_MESSAGE.matcher(clip.getText());
    if (!matcher.matches()) {
      matcher=Apg.PGP_SIGNED_MESSAGE.matcher(clip.getText());
    }
    if (matcher.matches()) {
      data=matcher.group(1);
      mMessage.setText(data);
      Toast.makeText(this,R.string.usingClipboardContent,Toast.LENGTH_SHORT).show();
    }
  }
  mSignatureLayout.setVisibility(View.GONE);
  mDecryptButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      decryptClicked();
    }
  }
);
  mReplyButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      replyClicked();
    }
  }
);
  mReplyButton.setVisibility(View.INVISIBLE);
  if (mReturnResult) {
    mSourcePrevious.setClickable(false);
    mSourcePrevious.setEnabled(false);
    mSourcePrevious.setVisibility(View.INVISIBLE);
    mSourceNext.setClickable(false);
    mSourceNext.setEnabled(false);
    mSourceNext.setVisibility(View.INVISIBLE);
    mSourceLabel.setClickable(false);
    mSourceLabel.setEnabled(false);
  }
  updateSource();
  if (mSource.getCurrentView().getId() == R.id.sourceMessage && mMessage.getText().length() > 0) {
    mDecryptButton.performClick();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.decrypt);
  mSource=(ViewFlipper)findViewById(R.id.source);
  mSourceLabel=(TextView)findViewById(R.id.sourceLabel);
  mSourcePrevious=(ImageView)findViewById(R.id.sourcePrevious);
  mSourceNext=(ImageView)findViewById(R.id.sourceNext);
  mSourcePrevious.setClickable(true);
  mSourcePrevious.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_right_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_right_out));
      mSource.showPrevious();
      updateSource();
    }
  }
);
  mSourceNext.setClickable(true);
  OnClickListener nextSourceClickListener=new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_left_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_left_out));
      mSource.showNext();
      updateSource();
    }
  }
;
  mSourceNext.setOnClickListener(nextSourceClickListener);
  mSourceLabel.setClickable(true);
  mSourceLabel.setOnClickListener(nextSourceClickListener);
  mMessage=(EditText)findViewById(R.id.message);
  mDecryptButton=(Button)findViewById(R.id.btn_decrypt);
  mReplyButton=(Button)findViewById(R.id.btn_reply);
  mSignatureLayout=(LinearLayout)findViewById(R.id.signature);
  mSignatureStatusImage=(ImageView)findViewById(R.id.ic_signature_status);
  mUserId=(TextView)findViewById(R.id.mainUserId);
  mUserIdRest=(TextView)findViewById(R.id.mainUserIdRest);
  View tmp=findViewById(R.id.sourceFile);
  tmp.measure(View.MeasureSpec.UNSPECIFIED,View.MeasureSpec.UNSPECIFIED);
  int height=tmp.getMeasuredHeight();
  mMessage.setMinimumHeight(height);
  mFilename=(EditText)findViewById(R.id.filename);
  mBrowse=(ImageButton)findViewById(R.id.btn_browse);
  mBrowse.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      openFile();
    }
  }
);
  mDeleteAfter=(CheckBox)findViewById(R.id.deleteAfterDecryption);
  mSource.setInAnimation(null);
  mSource.setOutAnimation(null);
  while (mSource.getCurrentView().getId() != R.id.sourceMessage) {
    mSource.showNext();
  }
  mIntent=getIntent();
  if (Intent.ACTION_VIEW.equals(mIntent.getAction())) {
    Uri uri=mIntent.getData();
    try {
      InputStream attachment=getContentResolver().openInputStream(uri);
      ByteArrayOutputStream byteOut=new ByteArrayOutputStream();
      byte bytes[]=new byte[1 << 16];
      int length;
      while ((length=attachment.read(bytes)) > 0) {
        byteOut.write(bytes,0,length);
      }
      byteOut.close();
      String data=new String(byteOut.toByteArray());
      mMessage.setText(data);
    }
 catch (    FileNotFoundException e) {
    }
catch (    IOException e) {
    }
  }
 else   if (Intent.ACTION_SEND.equals(mIntent.getAction())) {
    Bundle extras=mIntent.getExtras();
    if (extras == null) {
      extras=new Bundle();
    }
    String data=extras.getString(Intent.EXTRA_TEXT);
    if (data != null) {
      mMessage.setText(data);
    }
    mSubject=extras.getString(Intent.EXTRA_SUBJECT);
    if (mSubject != null && mSubject.startsWith(""String_Node_Str"")) {
      mSubject=mSubject.substring(5);
    }
  }
 else   if (Apg.Intent.DECRYPT.equals(mIntent.getAction())) {
    Bundle extras=mIntent.getExtras();
    if (extras == null) {
      extras=new Bundle();
    }
    String data=extras.getString(Apg.EXTRA_DATA);
    if (data != null) {
      Matcher matcher=Apg.PGP_MESSAGE.matcher(data);
      if (matcher.matches()) {
        data=matcher.group(1);
        data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
        mMessage.setText(data);
      }
 else {
        matcher=Apg.PGP_SIGNED_MESSAGE.matcher(data);
        if (matcher.matches()) {
          data=matcher.group(1);
          data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
          mMessage.setText(data);
          mDecryptButton.setText(R.string.btn_verify);
        }
      }
    }
    mReplyTo=extras.getString(Apg.EXTRA_REPLY_TO);
    mSubject=extras.getString(Apg.EXTRA_SUBJECT);
  }
 else   if (Apg.Intent.DECRYPT_FILE.equals(mIntent.getAction())) {
    mSource.setInAnimation(null);
    mSource.setOutAnimation(null);
    while (mSource.getCurrentView().getId() != R.id.sourceFile) {
      mSource.showNext();
    }
  }
 else   if (Apg.Intent.DECRYPT_AND_RETURN.equals(mIntent.getAction())) {
    Bundle extras=mIntent.getExtras();
    if (extras == null) {
      extras=new Bundle();
    }
    String data=extras.getString(Apg.EXTRA_DATA);
    if (data != null) {
      Matcher matcher=Apg.PGP_MESSAGE.matcher(data);
      if (matcher.matches()) {
        data=matcher.group(1);
        data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
        mMessage.setText(data);
      }
 else {
        matcher=Apg.PGP_SIGNED_MESSAGE.matcher(data);
        if (matcher.matches()) {
          data=matcher.group(1);
          data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
          mMessage.setText(data);
          mDecryptButton.setText(R.string.btn_verify);
        }
      }
    }
    mReturnResult=true;
  }
  if (mSource.getCurrentView().getId() == R.id.sourceMessage && mMessage.getText().length() == 0) {
    ClipboardManager clip=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
    String data=""String_Node_Str"";
    Matcher matcher=Apg.PGP_MESSAGE.matcher(clip.getText());
    if (!matcher.matches()) {
      matcher=Apg.PGP_SIGNED_MESSAGE.matcher(clip.getText());
    }
    if (matcher.matches()) {
      data=matcher.group(1);
      mMessage.setText(data);
      Toast.makeText(this,R.string.usingClipboardContent,Toast.LENGTH_SHORT).show();
    }
  }
  mSignatureLayout.setVisibility(View.GONE);
  mDecryptButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      decryptClicked();
    }
  }
);
  mReplyButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      replyClicked();
    }
  }
);
  mReplyButton.setVisibility(View.INVISIBLE);
  if (mReturnResult) {
    mSourcePrevious.setClickable(false);
    mSourcePrevious.setEnabled(false);
    mSourcePrevious.setVisibility(View.INVISIBLE);
    mSourceNext.setClickable(false);
    mSourceNext.setEnabled(false);
    mSourceNext.setVisibility(View.INVISIBLE);
    mSourceLabel.setClickable(false);
    mSourceLabel.setEnabled(false);
  }
  updateSource();
  if (mSource.getCurrentView().getId() == R.id.sourceMessage && mMessage.getText().length() > 0) {
    mDecryptButton.performClick();
  }
}",0.9911723936674692
8434,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.encrypt);
  mSource=(ViewFlipper)findViewById(R.id.source);
  mSourceLabel=(TextView)findViewById(R.id.sourceLabel);
  mSourcePrevious=(ImageView)findViewById(R.id.sourcePrevious);
  mSourceNext=(ImageView)findViewById(R.id.sourceNext);
  mSourcePrevious.setClickable(true);
  mSourcePrevious.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_right_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_right_out));
      mSource.showPrevious();
      updateSource();
    }
  }
);
  mSourceNext.setClickable(true);
  OnClickListener nextSourceClickListener=new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_left_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_left_out));
      mSource.showNext();
      updateSource();
    }
  }
;
  mSourceNext.setOnClickListener(nextSourceClickListener);
  mSourceLabel.setClickable(true);
  mSourceLabel.setOnClickListener(nextSourceClickListener);
  mMode=(ViewFlipper)findViewById(R.id.mode);
  mModeLabel=(TextView)findViewById(R.id.modeLabel);
  mModePrevious=(ImageView)findViewById(R.id.modePrevious);
  mModeNext=(ImageView)findViewById(R.id.modeNext);
  mModePrevious.setClickable(true);
  mModePrevious.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mMode.setInAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_right_in));
      mMode.setOutAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_right_out));
      mMode.showPrevious();
      updateMode();
    }
  }
);
  OnClickListener nextModeClickListener=new OnClickListener(){
    @Override public void onClick(    View v){
      mMode.setInAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_left_in));
      mMode.setOutAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_left_out));
      mMode.showNext();
      updateMode();
    }
  }
;
  mModeNext.setOnClickListener(nextModeClickListener);
  mModeLabel.setClickable(true);
  mModeLabel.setOnClickListener(nextModeClickListener);
  mMessage=(EditText)findViewById(R.id.message);
  mSelectKeysButton=(Button)findViewById(R.id.btn_selectEncryptKeys);
  mEncryptButton=(Button)findViewById(R.id.btn_encrypt);
  mEncryptToClipboardButton=(Button)findViewById(R.id.btn_encryptToClipboard);
  mSign=(CheckBox)findViewById(R.id.sign);
  mMainUserId=(TextView)findViewById(R.id.mainUserId);
  mMainUserIdRest=(TextView)findViewById(R.id.mainUserIdRest);
  mPassPhrase=(EditText)findViewById(R.id.passPhrase);
  mPassPhraseAgain=(EditText)findViewById(R.id.passPhraseAgain);
  View tmp=findViewById(R.id.sourceFile);
  tmp.measure(View.MeasureSpec.UNSPECIFIED,View.MeasureSpec.UNSPECIFIED);
  int height=tmp.getMeasuredHeight();
  mMessage.setMinimumHeight(height);
  mFilename=(EditText)findViewById(R.id.filename);
  mBrowse=(ImageButton)findViewById(R.id.btn_browse);
  mBrowse.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      openFile();
    }
  }
);
  mFileCompression=(Spinner)findViewById(R.id.fileCompression);
  Choice[] choices=new Choice[]{new Choice(Id.choice.compression.none,getString(R.string.choice_none)),new Choice(Id.choice.compression.zip,""String_Node_Str""),new Choice(Id.choice.compression.bzip2,""String_Node_Str""),new Choice(Id.choice.compression.zlib,""String_Node_Str"")};
  ArrayAdapter<Choice> adapter=new ArrayAdapter<Choice>(this,android.R.layout.simple_spinner_item,choices);
  adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  mFileCompression.setAdapter(adapter);
  int defaultFileCompression=getDefaultFileCompression();
  for (int i=0; i < choices.length; ++i) {
    if (choices[i].getId() == defaultFileCompression) {
      mFileCompression.setSelection(i);
      break;
    }
  }
  mDeleteAfter=(CheckBox)findViewById(R.id.deleteAfterEncryption);
  mAsciiArmour=(CheckBox)findViewById(R.id.asciiArmour);
  mAsciiArmour.setChecked(getDefaultAsciiArmour());
  mAsciiArmour.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      guessOutputFilename();
    }
  }
);
  mEncryptToClipboardButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      encryptToClipboardClicked();
    }
  }
);
  mEncryptButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      encryptClicked();
    }
  }
);
  mSelectKeysButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      selectPublicKeys();
    }
  }
);
  mSign.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      CheckBox checkBox=(CheckBox)v;
      if (checkBox.isChecked()) {
        selectSecretKey();
      }
 else {
        setSecretKeyId(Id.key.none);
        updateView();
      }
    }
  }
);
  mIntent=getIntent();
  if (Apg.Intent.ENCRYPT.equals(mIntent.getAction()) || Apg.Intent.ENCRYPT_FILE.equals(mIntent.getAction()) || Apg.Intent.ENCRYPT_AND_RETURN.equals(mIntent.getAction())) {
    Bundle extras=mIntent.getExtras();
    if (extras == null) {
      extras=new Bundle();
    }
    if (Apg.Intent.ENCRYPT_AND_RETURN.equals(mIntent.getAction())) {
      mReturnResult=true;
    }
    String data=extras.getString(Apg.EXTRA_DATA);
    mSendTo=extras.getString(Apg.EXTRA_SEND_TO);
    mSubject=extras.getString(Apg.EXTRA_SUBJECT);
    long signatureKeyId=extras.getLong(Apg.EXTRA_SIGNATURE_KEY_ID);
    long encryptionKeyIds[]=extras.getLongArray(Apg.EXTRA_ENCRYPTION_KEY_IDS);
    if (signatureKeyId != 0) {
      PGPSecretKeyRing keyRing=Apg.getSecretKeyRing(signatureKeyId);
      PGPSecretKey masterKey=null;
      if (keyRing != null) {
        masterKey=Apg.getMasterKey(keyRing);
        if (masterKey != null) {
          Vector<PGPSecretKey> signKeys=Apg.getUsableSigningKeys(keyRing);
          if (signKeys.size() > 0) {
            setSecretKeyId(masterKey.getKeyID());
          }
        }
      }
    }
    if (encryptionKeyIds != null) {
      Vector<Long> goodIds=new Vector<Long>();
      for (int i=0; i < encryptionKeyIds.length; ++i) {
        PGPPublicKeyRing keyRing=Apg.getPublicKeyRing(encryptionKeyIds[i]);
        PGPPublicKey masterKey=null;
        if (keyRing == null) {
          continue;
        }
        masterKey=Apg.getMasterKey(keyRing);
        if (masterKey == null) {
          continue;
        }
        Vector<PGPPublicKey> encryptKeys=Apg.getUsableEncryptKeys(keyRing);
        if (encryptKeys.size() == 0) {
          continue;
        }
        goodIds.add(masterKey.getKeyID());
      }
      if (goodIds.size() > 0) {
        mEncryptionKeyIds=new long[goodIds.size()];
        for (int i=0; i < goodIds.size(); ++i) {
          mEncryptionKeyIds[i]=goodIds.get(i);
        }
      }
    }
    if (Apg.Intent.ENCRYPT.equals(mIntent.getAction()) || Apg.Intent.ENCRYPT_AND_RETURN.equals(mIntent.getAction())) {
      if (data != null) {
        mMessage.setText(data);
      }
      mSource.setInAnimation(null);
      mSource.setOutAnimation(null);
      while (mSource.getCurrentView().getId() != R.id.sourceMessage) {
        mSource.showNext();
      }
    }
 else     if (Apg.Intent.ENCRYPT_FILE.equals(mIntent.getAction())) {
      mSource.setInAnimation(null);
      mSource.setOutAnimation(null);
      while (mSource.getCurrentView().getId() != R.id.sourceFile) {
        mSource.showNext();
      }
    }
  }
  updateView();
  updateSource();
  updateMode();
  if (mReturnResult) {
    mSourcePrevious.setClickable(false);
    mSourcePrevious.setEnabled(false);
    mSourcePrevious.setVisibility(View.INVISIBLE);
    mSourceNext.setClickable(false);
    mSourceNext.setEnabled(false);
    mSourceNext.setVisibility(View.INVISIBLE);
    mSourceLabel.setClickable(false);
    mSourceLabel.setEnabled(false);
    mEncryptToClipboardButton.setEnabled(false);
    mEncryptToClipboardButton.setVisibility(View.INVISIBLE);
    mEncryptButton.setText(R.string.btn_encrypt);
  }
  if (mMessage.getText().length() > 0 && ((mEncryptionKeyIds != null && mEncryptionKeyIds.length > 0) || getSecretKeyId() != 0)) {
    encryptClicked();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.encrypt);
  mSource=(ViewFlipper)findViewById(R.id.source);
  mSourceLabel=(TextView)findViewById(R.id.sourceLabel);
  mSourcePrevious=(ImageView)findViewById(R.id.sourcePrevious);
  mSourceNext=(ImageView)findViewById(R.id.sourceNext);
  mSourcePrevious.setClickable(true);
  mSourcePrevious.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_right_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_right_out));
      mSource.showPrevious();
      updateSource();
    }
  }
);
  mSourceNext.setClickable(true);
  OnClickListener nextSourceClickListener=new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_left_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_left_out));
      mSource.showNext();
      updateSource();
    }
  }
;
  mSourceNext.setOnClickListener(nextSourceClickListener);
  mSourceLabel.setClickable(true);
  mSourceLabel.setOnClickListener(nextSourceClickListener);
  mMode=(ViewFlipper)findViewById(R.id.mode);
  mModeLabel=(TextView)findViewById(R.id.modeLabel);
  mModePrevious=(ImageView)findViewById(R.id.modePrevious);
  mModeNext=(ImageView)findViewById(R.id.modeNext);
  mModePrevious.setClickable(true);
  mModePrevious.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mMode.setInAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_right_in));
      mMode.setOutAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_right_out));
      mMode.showPrevious();
      updateMode();
    }
  }
);
  OnClickListener nextModeClickListener=new OnClickListener(){
    @Override public void onClick(    View v){
      mMode.setInAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_left_in));
      mMode.setOutAnimation(AnimationUtils.loadAnimation(EncryptActivity.this,R.anim.push_left_out));
      mMode.showNext();
      updateMode();
    }
  }
;
  mModeNext.setOnClickListener(nextModeClickListener);
  mModeLabel.setClickable(true);
  mModeLabel.setOnClickListener(nextModeClickListener);
  mMessage=(EditText)findViewById(R.id.message);
  mSelectKeysButton=(Button)findViewById(R.id.btn_selectEncryptKeys);
  mEncryptButton=(Button)findViewById(R.id.btn_encrypt);
  mEncryptToClipboardButton=(Button)findViewById(R.id.btn_encryptToClipboard);
  mSign=(CheckBox)findViewById(R.id.sign);
  mMainUserId=(TextView)findViewById(R.id.mainUserId);
  mMainUserIdRest=(TextView)findViewById(R.id.mainUserIdRest);
  mPassPhrase=(EditText)findViewById(R.id.passPhrase);
  mPassPhraseAgain=(EditText)findViewById(R.id.passPhraseAgain);
  View tmp=findViewById(R.id.sourceFile);
  tmp.measure(View.MeasureSpec.UNSPECIFIED,View.MeasureSpec.UNSPECIFIED);
  int height=tmp.getMeasuredHeight();
  mMessage.setMinimumHeight(height);
  mFilename=(EditText)findViewById(R.id.filename);
  mBrowse=(ImageButton)findViewById(R.id.btn_browse);
  mBrowse.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      openFile();
    }
  }
);
  mFileCompression=(Spinner)findViewById(R.id.fileCompression);
  Choice[] choices=new Choice[]{new Choice(Id.choice.compression.none,getString(R.string.choice_none)),new Choice(Id.choice.compression.zip,""String_Node_Str""),new Choice(Id.choice.compression.bzip2,""String_Node_Str""),new Choice(Id.choice.compression.zlib,""String_Node_Str"")};
  ArrayAdapter<Choice> adapter=new ArrayAdapter<Choice>(this,android.R.layout.simple_spinner_item,choices);
  adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  mFileCompression.setAdapter(adapter);
  int defaultFileCompression=getDefaultFileCompression();
  for (int i=0; i < choices.length; ++i) {
    if (choices[i].getId() == defaultFileCompression) {
      mFileCompression.setSelection(i);
      break;
    }
  }
  mDeleteAfter=(CheckBox)findViewById(R.id.deleteAfterEncryption);
  mAsciiArmour=(CheckBox)findViewById(R.id.asciiArmour);
  mAsciiArmour.setChecked(getDefaultAsciiArmour());
  mAsciiArmour.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      guessOutputFilename();
    }
  }
);
  mEncryptToClipboardButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      encryptToClipboardClicked();
    }
  }
);
  mEncryptButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      encryptClicked();
    }
  }
);
  mSelectKeysButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      selectPublicKeys();
    }
  }
);
  mSign.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      CheckBox checkBox=(CheckBox)v;
      if (checkBox.isChecked()) {
        selectSecretKey();
      }
 else {
        setSecretKeyId(Id.key.none);
        updateView();
      }
    }
  }
);
  mIntent=getIntent();
  if (Apg.Intent.ENCRYPT.equals(mIntent.getAction()) || Apg.Intent.ENCRYPT_FILE.equals(mIntent.getAction()) || Apg.Intent.ENCRYPT_AND_RETURN.equals(mIntent.getAction())) {
    Bundle extras=mIntent.getExtras();
    if (extras == null) {
      extras=new Bundle();
    }
    if (Apg.Intent.ENCRYPT_AND_RETURN.equals(mIntent.getAction())) {
      mReturnResult=true;
    }
    String data=extras.getString(Apg.EXTRA_DATA);
    mSendTo=extras.getString(Apg.EXTRA_SEND_TO);
    mSubject=extras.getString(Apg.EXTRA_SUBJECT);
    long signatureKeyId=extras.getLong(Apg.EXTRA_SIGNATURE_KEY_ID);
    long encryptionKeyIds[]=extras.getLongArray(Apg.EXTRA_ENCRYPTION_KEY_IDS);
    if (signatureKeyId != 0) {
      PGPSecretKeyRing keyRing=Apg.getSecretKeyRing(signatureKeyId);
      PGPSecretKey masterKey=null;
      if (keyRing != null) {
        masterKey=Apg.getMasterKey(keyRing);
        if (masterKey != null) {
          Vector<PGPSecretKey> signKeys=Apg.getUsableSigningKeys(keyRing);
          if (signKeys.size() > 0) {
            setSecretKeyId(masterKey.getKeyID());
          }
        }
      }
    }
    if (encryptionKeyIds != null) {
      Vector<Long> goodIds=new Vector<Long>();
      for (int i=0; i < encryptionKeyIds.length; ++i) {
        PGPPublicKeyRing keyRing=Apg.getPublicKeyRing(encryptionKeyIds[i]);
        PGPPublicKey masterKey=null;
        if (keyRing == null) {
          continue;
        }
        masterKey=Apg.getMasterKey(keyRing);
        if (masterKey == null) {
          continue;
        }
        Vector<PGPPublicKey> encryptKeys=Apg.getUsableEncryptKeys(keyRing);
        if (encryptKeys.size() == 0) {
          continue;
        }
        goodIds.add(masterKey.getKeyID());
      }
      if (goodIds.size() > 0) {
        mEncryptionKeyIds=new long[goodIds.size()];
        for (int i=0; i < goodIds.size(); ++i) {
          mEncryptionKeyIds[i]=goodIds.get(i);
        }
      }
    }
    if (Apg.Intent.ENCRYPT.equals(mIntent.getAction()) || Apg.Intent.ENCRYPT_AND_RETURN.equals(mIntent.getAction())) {
      if (data != null) {
        mMessage.setText(data);
      }
      mSource.setInAnimation(null);
      mSource.setOutAnimation(null);
      while (mSource.getCurrentView().getId() != R.id.sourceMessage) {
        mSource.showNext();
      }
    }
 else     if (Apg.Intent.ENCRYPT_FILE.equals(mIntent.getAction())) {
      mSource.setInAnimation(null);
      mSource.setOutAnimation(null);
      while (mSource.getCurrentView().getId() != R.id.sourceFile) {
        mSource.showNext();
      }
    }
  }
  updateView();
  updateSource();
  updateMode();
  if (mReturnResult) {
    mSourcePrevious.setClickable(false);
    mSourcePrevious.setEnabled(false);
    mSourcePrevious.setVisibility(View.INVISIBLE);
    mSourceNext.setClickable(false);
    mSourceNext.setEnabled(false);
    mSourceNext.setVisibility(View.INVISIBLE);
    mSourceLabel.setClickable(false);
    mSourceLabel.setEnabled(false);
    mEncryptToClipboardButton.setEnabled(false);
    mEncryptToClipboardButton.setVisibility(View.INVISIBLE);
    mEncryptButton.setText(R.string.btn_encrypt);
  }
  if (mReturnResult && mMessage.getText().length() > 0 && ((mEncryptionKeyIds != null && mEncryptionKeyIds.length > 0) || getSecretKeyId() != 0)) {
    encryptClicked();
  }
}",0.9955271565495208
8435,"@Override public void doneCallback(Message msg){
  super.doneCallback(msg);
  removeDialog(Id.dialog.encrypting);
  Bundle data=msg.getData();
  String error=data.getString(Apg.EXTRA_ERROR);
  if (error != null) {
    Toast.makeText(EncryptActivity.this,getString(R.string.errorMessage,error),Toast.LENGTH_SHORT).show();
    return;
  }
  String message=Strings.fromUTF8ByteArray(data.getByteArray(Apg.EXTRA_ENCRYPTED_MESSAGE));
switch (mEncryptTarget) {
case Id.target.clipboard:
{
      ClipboardManager clip=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
      clip.setText(message);
      Toast.makeText(this,R.string.encryptionToClipboardSuccessful,Toast.LENGTH_SHORT).show();
      break;
    }
case Id.target.email:
{
    if (mReturnResult) {
      Intent intent=new Intent();
      intent.putExtras(data);
      setResult(RESULT_OK,intent);
      finish();
      return;
    }
    Intent emailIntent=new Intent(android.content.Intent.ACTION_SEND);
    emailIntent.setType(""String_Node_Str"");
    emailIntent.putExtra(android.content.Intent.EXTRA_TEXT,message);
    if (mSubject != null) {
      emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT,mSubject);
    }
    if (mSendTo != null) {
      emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL,new String[]{mSendTo});
    }
    EncryptActivity.this.startActivity(Intent.createChooser(emailIntent,getString(R.string.title_sendEmail)));
    break;
  }
case Id.target.file:
{
  Toast.makeText(this,R.string.encryptionSuccessful,Toast.LENGTH_SHORT).show();
  if (mDeleteAfter.isChecked()) {
    setDeleteFile(mInputFilename);
    showDialog(Id.dialog.delete_file);
  }
  break;
}
default :
{
break;
}
}
}","@Override public void doneCallback(Message msg){
  super.doneCallback(msg);
  removeDialog(Id.dialog.encrypting);
  Bundle data=msg.getData();
  String error=data.getString(Apg.EXTRA_ERROR);
  if (error != null) {
    Toast.makeText(EncryptActivity.this,getString(R.string.errorMessage,error),Toast.LENGTH_SHORT).show();
    return;
  }
switch (mEncryptTarget) {
case Id.target.clipboard:
{
      String message=new String(data.getByteArray(Apg.EXTRA_ENCRYPTED_MESSAGE));
      ClipboardManager clip=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
      clip.setText(message);
      Toast.makeText(this,R.string.encryptionToClipboardSuccessful,Toast.LENGTH_SHORT).show();
      break;
    }
case Id.target.email:
{
    if (mReturnResult) {
      Intent intent=new Intent();
      intent.putExtras(data);
      setResult(RESULT_OK,intent);
      finish();
      return;
    }
    String message=new String(data.getByteArray(Apg.EXTRA_ENCRYPTED_MESSAGE));
    Intent emailIntent=new Intent(android.content.Intent.ACTION_SEND);
    emailIntent.setType(""String_Node_Str"");
    emailIntent.putExtra(android.content.Intent.EXTRA_TEXT,message);
    if (mSubject != null) {
      emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT,mSubject);
    }
    if (mSendTo != null) {
      emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL,new String[]{mSendTo});
    }
    EncryptActivity.this.startActivity(Intent.createChooser(emailIntent,getString(R.string.title_sendEmail)));
    break;
  }
case Id.target.file:
{
  Toast.makeText(this,R.string.encryptionSuccessful,Toast.LENGTH_SHORT).show();
  if (mDeleteAfter.isChecked()) {
    setDeleteFile(mInputFilename);
    showDialog(Id.dialog.delete_file);
  }
  break;
}
default :
{
break;
}
}
}",0.9341107871720116
8436,"public static Vector<Integer> getKeyRingIds(int type){
  SQLiteDatabase db=mDatabase.db();
  Vector<Integer> keyIds=new Vector<Integer>();
  Cursor c=db.query(KeyRings.TABLE_NAME,new String[]{KeyRings._ID},KeyRings.TYPE + ""String_Node_Str"",new String[]{""String_Node_Str"" + type},null,null,null);
  if (c != null && c.moveToFirst()) {
    do {
      keyIds.add(c.getInt(0));
    }
 while (c.moveToNext());
  }
  c.close();
  return keyIds;
}","public static Vector<Integer> getKeyRingIds(int type){
  SQLiteDatabase db=mDatabase.db();
  Vector<Integer> keyIds=new Vector<Integer>();
  Cursor c=db.query(KeyRings.TABLE_NAME,new String[]{KeyRings._ID},KeyRings.TYPE + ""String_Node_Str"",new String[]{""String_Node_Str"" + type},null,null,null);
  if (c != null && c.moveToFirst()) {
    do {
      keyIds.add(c.getInt(0));
    }
 while (c.moveToNext());
  }
  if (c != null) {
    c.close();
  }
  return keyIds;
}",0.9502762430939228
8437,"@Override public void doneCallback(Message msg){
  super.doneCallback(msg);
  removeDialog(Id.dialog.encrypting);
  Bundle data=msg.getData();
  String error=data.getString(""String_Node_Str"");
  if (error != null) {
    Toast.makeText(EncryptActivity.this,getString(R.string.errorMessage,data.getString(""String_Node_Str"")),Toast.LENGTH_SHORT).show();
    return;
  }
 else {
    String message=data.getString(""String_Node_Str"");
switch (mEncryptTarget) {
case Id.target.clipboard:
{
        ClipboardManager clip=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
        clip.setText(message);
        Toast.makeText(this,R.string.encryptionToClipboardSuccessful,Toast.LENGTH_SHORT).show();
        break;
      }
case Id.target.email:
{
      Intent emailIntent=new Intent(android.content.Intent.ACTION_SEND);
      emailIntent.setType(""String_Node_Str"");
      emailIntent.putExtra(android.content.Intent.EXTRA_TEXT,message);
      if (mSubject != null) {
        emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT,mSubject);
      }
      if (mSendTo != null) {
        emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL,new String[]{mSendTo});
      }
      EncryptActivity.this.startActivity(Intent.createChooser(emailIntent,getString(R.string.title_sendEmail)));
    }
case Id.target.file:
{
    Toast.makeText(this,R.string.encryptionSuccessful,Toast.LENGTH_SHORT).show();
    if (mDeleteAfter.isChecked()) {
      setDeleteFile(mInputFilename);
      showDialog(Id.dialog.delete_file);
    }
    break;
  }
default :
{
  break;
}
}
}
}","@Override public void doneCallback(Message msg){
  super.doneCallback(msg);
  removeDialog(Id.dialog.encrypting);
  Bundle data=msg.getData();
  String error=data.getString(""String_Node_Str"");
  if (error != null) {
    Toast.makeText(EncryptActivity.this,getString(R.string.errorMessage,data.getString(""String_Node_Str"")),Toast.LENGTH_SHORT).show();
    return;
  }
 else {
    String message=data.getString(""String_Node_Str"");
switch (mEncryptTarget) {
case Id.target.clipboard:
{
        ClipboardManager clip=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
        clip.setText(message);
        Toast.makeText(this,R.string.encryptionToClipboardSuccessful,Toast.LENGTH_SHORT).show();
        break;
      }
case Id.target.email:
{
      Intent emailIntent=new Intent(android.content.Intent.ACTION_SEND);
      emailIntent.setType(""String_Node_Str"");
      emailIntent.putExtra(android.content.Intent.EXTRA_TEXT,message);
      if (mSubject != null) {
        emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT,mSubject);
      }
      if (mSendTo != null) {
        emailIntent.putExtra(android.content.Intent.EXTRA_EMAIL,new String[]{mSendTo});
      }
      EncryptActivity.this.startActivity(Intent.createChooser(emailIntent,getString(R.string.title_sendEmail)));
      break;
    }
case Id.target.file:
{
    Toast.makeText(this,R.string.encryptionSuccessful,Toast.LENGTH_SHORT).show();
    if (mDeleteAfter.isChecked()) {
      setDeleteFile(mInputFilename);
      showDialog(Id.dialog.delete_file);
    }
    break;
  }
default :
{
  break;
}
}
}
}",0.995850622406639
8438,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion){
  mDb=db;
  for (int version=oldVersion; version < newVersion; ++version) {
switch (version) {
case 1:
{
        db.execSQL(""String_Node_Str"" + KeyRings.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + Keys.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + UserIds.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + KeyRings.TABLE_NAME + ""String_Node_Str""+ KeyRings._ID+ ""String_Node_Str""+ KeyRings._ID_type+ ""String_Node_Str""+ KeyRings.MASTER_KEY_ID+ ""String_Node_Str""+ KeyRings.MASTER_KEY_ID_type+ ""String_Node_Str""+ KeyRings.TYPE+ ""String_Node_Str""+ KeyRings.TYPE_type+ ""String_Node_Str""+ KeyRings.WHO_ID+ ""String_Node_Str""+ KeyRings.WHO_ID_type+ ""String_Node_Str""+ KeyRings.KEY_RING_DATA+ ""String_Node_Str""+ KeyRings.KEY_RING_DATA_type+ ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + Keys.TABLE_NAME + ""String_Node_Str""+ Keys._ID+ ""String_Node_Str""+ Keys._ID_type+ ""String_Node_Str""+ Keys.KEY_ID+ ""String_Node_Str""+ Keys.KEY_ID_type+ ""String_Node_Str""+ Keys.TYPE+ ""String_Node_Str""+ Keys.TYPE_type+ ""String_Node_Str""+ Keys.IS_MASTER_KEY+ ""String_Node_Str""+ Keys.IS_MASTER_KEY_type+ ""String_Node_Str""+ Keys.ALGORITHM+ ""String_Node_Str""+ Keys.ALGORITHM_type+ ""String_Node_Str""+ Keys.KEY_SIZE+ ""String_Node_Str""+ Keys.KEY_SIZE_type+ ""String_Node_Str""+ Keys.CAN_SIGN+ ""String_Node_Str""+ Keys.CAN_SIGN_type+ ""String_Node_Str""+ Keys.CAN_ENCRYPT+ ""String_Node_Str""+ Keys.CAN_ENCRYPT_type+ ""String_Node_Str""+ Keys.IS_REVOKED+ ""String_Node_Str""+ Keys.IS_REVOKED_type+ ""String_Node_Str""+ Keys.CREATION+ ""String_Node_Str""+ Keys.CREATION_type+ ""String_Node_Str""+ Keys.EXPIRY+ ""String_Node_Str""+ Keys.EXPIRY_type+ ""String_Node_Str""+ Keys.KEY_RING_ID+ ""String_Node_Str""+ Keys.KEY_RING_ID_type+ ""String_Node_Str""+ Keys.KEY_DATA+ ""String_Node_Str""+ Keys.KEY_DATA_type+ Keys.RANK+ ""String_Node_Str""+ Keys.RANK_type+ ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + UserIds.TABLE_NAME + ""String_Node_Str""+ UserIds._ID+ ""String_Node_Str""+ UserIds._ID_type+ ""String_Node_Str""+ UserIds.KEY_ID+ ""String_Node_Str""+ UserIds.KEY_ID_type+ ""String_Node_Str""+ UserIds.USER_ID+ ""String_Node_Str""+ UserIds.USER_ID_type+ ""String_Node_Str""+ UserIds.RANK+ ""String_Node_Str""+ UserIds.RANK_type+ ""String_Node_Str"");
        Cursor cursor=db.query(PublicKeys.TABLE_NAME,new String[]{PublicKeys.KEY_DATA},null,null,null,null,null);
        if (cursor != null && cursor.moveToFirst()) {
          do {
            byte[] data=cursor.getBlob(cursor.getColumnIndex(PublicKeys.KEY_DATA));
            try {
              PGPPublicKeyRing keyRing=new PGPPublicKeyRing(data);
              saveKeyRing(keyRing);
              Log.e(""String_Node_Str"",""String_Node_Str"" + keyRing);
            }
 catch (            IOException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            GeneralException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
          }
 while (cursor.moveToNext());
        }
        cursor.close();
        cursor=db.query(SecretKeys.TABLE_NAME,new String[]{SecretKeys.KEY_DATA},null,null,null,null,null);
        if (cursor != null && cursor.moveToFirst()) {
          do {
            byte[] data=cursor.getBlob(cursor.getColumnIndex(SecretKeys.KEY_DATA));
            try {
              PGPSecretKeyRing keyRing=new PGPSecretKeyRing(data);
              saveKeyRing(keyRing);
              Log.e(""String_Node_Str"",""String_Node_Str"" + keyRing);
            }
 catch (            IOException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            PGPException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            GeneralException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
          }
 while (cursor.moveToNext());
        }
        cursor.close();
        break;
      }
default :
{
      break;
    }
}
}
mDb=null;
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion){
  mDb=db;
  for (int version=oldVersion; version < newVersion; ++version) {
switch (version) {
case 1:
{
        db.execSQL(""String_Node_Str"" + KeyRings.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + Keys.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + UserIds.TABLE_NAME + ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + KeyRings.TABLE_NAME + ""String_Node_Str""+ KeyRings._ID+ ""String_Node_Str""+ KeyRings._ID_type+ ""String_Node_Str""+ KeyRings.MASTER_KEY_ID+ ""String_Node_Str""+ KeyRings.MASTER_KEY_ID_type+ ""String_Node_Str""+ KeyRings.TYPE+ ""String_Node_Str""+ KeyRings.TYPE_type+ ""String_Node_Str""+ KeyRings.WHO_ID+ ""String_Node_Str""+ KeyRings.WHO_ID_type+ ""String_Node_Str""+ KeyRings.KEY_RING_DATA+ ""String_Node_Str""+ KeyRings.KEY_RING_DATA_type+ ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + Keys.TABLE_NAME + ""String_Node_Str""+ Keys._ID+ ""String_Node_Str""+ Keys._ID_type+ ""String_Node_Str""+ Keys.KEY_ID+ ""String_Node_Str""+ Keys.KEY_ID_type+ ""String_Node_Str""+ Keys.TYPE+ ""String_Node_Str""+ Keys.TYPE_type+ ""String_Node_Str""+ Keys.IS_MASTER_KEY+ ""String_Node_Str""+ Keys.IS_MASTER_KEY_type+ ""String_Node_Str""+ Keys.ALGORITHM+ ""String_Node_Str""+ Keys.ALGORITHM_type+ ""String_Node_Str""+ Keys.KEY_SIZE+ ""String_Node_Str""+ Keys.KEY_SIZE_type+ ""String_Node_Str""+ Keys.CAN_SIGN+ ""String_Node_Str""+ Keys.CAN_SIGN_type+ ""String_Node_Str""+ Keys.CAN_ENCRYPT+ ""String_Node_Str""+ Keys.CAN_ENCRYPT_type+ ""String_Node_Str""+ Keys.IS_REVOKED+ ""String_Node_Str""+ Keys.IS_REVOKED_type+ ""String_Node_Str""+ Keys.CREATION+ ""String_Node_Str""+ Keys.CREATION_type+ ""String_Node_Str""+ Keys.EXPIRY+ ""String_Node_Str""+ Keys.EXPIRY_type+ ""String_Node_Str""+ Keys.KEY_RING_ID+ ""String_Node_Str""+ Keys.KEY_RING_ID_type+ ""String_Node_Str""+ Keys.KEY_DATA+ ""String_Node_Str""+ Keys.KEY_DATA_type+ Keys.RANK+ ""String_Node_Str""+ Keys.RANK_type+ ""String_Node_Str"");
        db.execSQL(""String_Node_Str"" + UserIds.TABLE_NAME + ""String_Node_Str""+ UserIds._ID+ ""String_Node_Str""+ UserIds._ID_type+ ""String_Node_Str""+ UserIds.KEY_ID+ ""String_Node_Str""+ UserIds.KEY_ID_type+ ""String_Node_Str""+ UserIds.USER_ID+ ""String_Node_Str""+ UserIds.USER_ID_type+ ""String_Node_Str""+ UserIds.RANK+ ""String_Node_Str""+ UserIds.RANK_type+ ""String_Node_Str"");
        Cursor cursor=db.query(PublicKeys.TABLE_NAME,new String[]{PublicKeys.KEY_DATA},null,null,null,null,null);
        if (cursor != null && cursor.moveToFirst()) {
          do {
            byte[] data=cursor.getBlob(cursor.getColumnIndex(PublicKeys.KEY_DATA));
            try {
              PGPPublicKeyRing keyRing=new PGPPublicKeyRing(data);
              saveKeyRing(keyRing);
              Log.e(""String_Node_Str"",""String_Node_Str"" + keyRing);
            }
 catch (            IOException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            GeneralException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
          }
 while (cursor.moveToNext());
        }
        cursor.close();
        cursor=db.query(SecretKeys.TABLE_NAME,new String[]{SecretKeys.KEY_DATA},null,null,null,null,null);
        if (cursor != null && cursor.moveToFirst()) {
          do {
            byte[] data=cursor.getBlob(cursor.getColumnIndex(SecretKeys.KEY_DATA));
            try {
              PGPSecretKeyRing keyRing=new PGPSecretKeyRing(data);
              saveKeyRing(keyRing);
              Log.e(""String_Node_Str"",""String_Node_Str"" + keyRing);
            }
 catch (            IOException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            PGPException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
catch (            GeneralException e) {
              Log.e(""String_Node_Str"",""String_Node_Str"" + e);
            }
          }
 while (cursor.moveToNext());
        }
        if (cursor != null) {
          cursor.close();
        }
        break;
      }
default :
{
      break;
    }
}
}
mDb=null;
}",0.9948817938094078
8439,"private long insertOrUpdateKeyRing(ContentValues values){
  Cursor c=mDb.query(KeyRings.TABLE_NAME,new String[]{KeyRings._ID},KeyRings.MASTER_KEY_ID + ""String_Node_Str"" + KeyRings.TYPE+ ""String_Node_Str"",new String[]{values.getAsString(KeyRings.MASTER_KEY_ID),values.getAsString(KeyRings.TYPE)},null,null,null);
  long rowId=-1;
  if (c != null && c.moveToFirst()) {
    rowId=c.getLong(0);
    mDb.update(KeyRings.TABLE_NAME,values,KeyRings._ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + rowId});
    mStatus=Id.return_value.updated;
  }
 else {
    rowId=mDb.insert(KeyRings.TABLE_NAME,KeyRings.WHO_ID,values);
    mStatus=Id.return_value.ok;
  }
  c.close();
  return rowId;
}","private long insertOrUpdateKeyRing(ContentValues values){
  Cursor c=mDb.query(KeyRings.TABLE_NAME,new String[]{KeyRings._ID},KeyRings.MASTER_KEY_ID + ""String_Node_Str"" + KeyRings.TYPE+ ""String_Node_Str"",new String[]{values.getAsString(KeyRings.MASTER_KEY_ID),values.getAsString(KeyRings.TYPE)},null,null,null);
  long rowId=-1;
  if (c != null && c.moveToFirst()) {
    rowId=c.getLong(0);
    mDb.update(KeyRings.TABLE_NAME,values,KeyRings._ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + rowId});
    mStatus=Id.return_value.updated;
  }
 else {
    rowId=mDb.insert(KeyRings.TABLE_NAME,KeyRings.WHO_ID,values);
    mStatus=Id.return_value.ok;
  }
  if (c != null) {
    c.close();
  }
  return rowId;
}",0.9707769066286528
8440,"public Object getKeyRing(int keyRingId){
  Cursor c=mDb.query(KeyRings.TABLE_NAME,new String[]{KeyRings.KEY_RING_DATA,KeyRings.TYPE},KeyRings._ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + keyRingId},null,null,null);
  byte[] data=null;
  Object keyRing=null;
  if (c != null && c.moveToFirst()) {
    data=c.getBlob(0);
    if (data != null) {
      try {
        if (c.getInt(1) == Id.database.type_public) {
          keyRing=new PGPPublicKeyRing(data);
        }
 else {
          keyRing=new PGPSecretKeyRing(data);
        }
      }
 catch (      IOException e) {
      }
catch (      PGPException e) {
      }
    }
  }
  c.close();
  return keyRing;
}","public Object getKeyRing(int keyRingId){
  Cursor c=mDb.query(KeyRings.TABLE_NAME,new String[]{KeyRings.KEY_RING_DATA,KeyRings.TYPE},KeyRings._ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + keyRingId},null,null,null);
  byte[] data=null;
  Object keyRing=null;
  if (c != null && c.moveToFirst()) {
    data=c.getBlob(0);
    if (data != null) {
      try {
        if (c.getInt(1) == Id.database.type_public) {
          keyRing=new PGPPublicKeyRing(data);
        }
 else {
          keyRing=new PGPSecretKeyRing(data);
        }
      }
 catch (      IOException e) {
      }
catch (      PGPException e) {
      }
    }
  }
  if (c != null) {
    c.close();
  }
  return keyRing;
}",0.966984592809978
8441,"public void deleteKeyRing(int keyRingId){
  mDb.beginTransaction();
  mDb.delete(KeyRings.TABLE_NAME,KeyRings._ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + keyRingId});
  Cursor c=mDb.query(Keys.TABLE_NAME,new String[]{Keys._ID},Keys.KEY_RING_ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + keyRingId},null,null,null);
  if (c != null && c.moveToFirst()) {
    do {
      int keyId=c.getInt(0);
      deleteKey(keyId);
    }
 while (c.moveToNext());
  }
  c.close();
  mDb.setTransactionSuccessful();
  mDb.endTransaction();
}","public void deleteKeyRing(int keyRingId){
  mDb.beginTransaction();
  mDb.delete(KeyRings.TABLE_NAME,KeyRings._ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + keyRingId});
  Cursor c=mDb.query(Keys.TABLE_NAME,new String[]{Keys._ID},Keys.KEY_RING_ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + keyRingId},null,null,null);
  if (c != null && c.moveToFirst()) {
    do {
      int keyId=c.getInt(0);
      deleteKey(keyId);
    }
 while (c.moveToNext());
  }
  if (c != null) {
    c.close();
  }
  mDb.setTransactionSuccessful();
  mDb.endTransaction();
}",0.9596412556053812
8442,"private long insertOrUpdateUserId(ContentValues values){
  Cursor c=mDb.query(UserIds.TABLE_NAME,new String[]{UserIds._ID},UserIds.KEY_ID + ""String_Node_Str"" + UserIds.USER_ID+ ""String_Node_Str"",new String[]{values.getAsString(UserIds.KEY_ID),values.getAsString(UserIds.USER_ID)},null,null,null);
  long rowId=-1;
  if (c != null && c.moveToFirst()) {
    rowId=c.getLong(0);
    mDb.update(UserIds.TABLE_NAME,values,UserIds._ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + rowId});
  }
 else {
    rowId=mDb.insert(UserIds.TABLE_NAME,UserIds.USER_ID,values);
  }
  c.close();
  return rowId;
}","private long insertOrUpdateUserId(ContentValues values){
  Cursor c=mDb.query(UserIds.TABLE_NAME,new String[]{UserIds._ID},UserIds.KEY_ID + ""String_Node_Str"" + UserIds.USER_ID+ ""String_Node_Str"",new String[]{values.getAsString(UserIds.KEY_ID),values.getAsString(UserIds.USER_ID)},null,null,null);
  long rowId=-1;
  if (c != null && c.moveToFirst()) {
    rowId=c.getLong(0);
    mDb.update(UserIds.TABLE_NAME,values,UserIds._ID + ""String_Node_Str"",new String[]{""String_Node_Str"" + rowId});
  }
 else {
    rowId=mDb.insert(UserIds.TABLE_NAME,UserIds.USER_ID,values);
  }
  if (c != null) {
    c.close();
  }
  return rowId;
}",0.9780309194467046
8443,"public byte[] getKeyDataFromKeyId(int type,long keyId){
  Cursor c=mDb.query(Keys.TABLE_NAME,new String[]{Keys.KEY_DATA},Keys.KEY_ID + ""String_Node_Str"" + Keys.TYPE+ ""String_Node_Str"",new String[]{""String_Node_Str"" + keyId,""String_Node_Str"" + type},null,null,null);
  byte[] data=null;
  if (c != null && c.moveToFirst()) {
    data=c.getBlob(0);
  }
  c.close();
  return data;
}","public byte[] getKeyDataFromKeyId(int type,long keyId){
  Cursor c=mDb.query(Keys.TABLE_NAME,new String[]{Keys.KEY_DATA},Keys.KEY_ID + ""String_Node_Str"" + Keys.TYPE+ ""String_Node_Str"",new String[]{""String_Node_Str"" + keyId,""String_Node_Str"" + type},null,null,null);
  byte[] data=null;
  if (c != null && c.moveToFirst()) {
    data=c.getBlob(0);
  }
  if (c != null) {
    c.close();
  }
  return data;
}",0.9681528662420382
8444,"public byte[] getKeyRingDataFromKeyId(int type,long keyId){
  Cursor c=mDb.query(Keys.TABLE_NAME + ""String_Node_Str"" + KeyRings.TABLE_NAME+ ""String_Node_Str""+ KeyRings.TABLE_NAME+ ""String_Node_Str""+ KeyRings._ID+ ""String_Node_Str""+ Keys.TABLE_NAME+ ""String_Node_Str""+ Keys.KEY_RING_ID+ ""String_Node_Str"",new String[]{KeyRings.TABLE_NAME + ""String_Node_Str"" + KeyRings.KEY_RING_DATA},Keys.TABLE_NAME + ""String_Node_Str"" + Keys.KEY_ID+ ""String_Node_Str""+ KeyRings.TABLE_NAME+ ""String_Node_Str""+ KeyRings.TYPE+ ""String_Node_Str"",new String[]{""String_Node_Str"" + keyId,""String_Node_Str"" + type},null,null,null);
  byte[] data=null;
  if (c != null && c.moveToFirst()) {
    data=c.getBlob(0);
  }
  c.close();
  return data;
}","public byte[] getKeyRingDataFromKeyId(int type,long keyId){
  Cursor c=mDb.query(Keys.TABLE_NAME + ""String_Node_Str"" + KeyRings.TABLE_NAME+ ""String_Node_Str""+ KeyRings.TABLE_NAME+ ""String_Node_Str""+ KeyRings._ID+ ""String_Node_Str""+ Keys.TABLE_NAME+ ""String_Node_Str""+ Keys.KEY_RING_ID+ ""String_Node_Str"",new String[]{KeyRings.TABLE_NAME + ""String_Node_Str"" + KeyRings.KEY_RING_DATA},Keys.TABLE_NAME + ""String_Node_Str"" + Keys.KEY_ID+ ""String_Node_Str""+ KeyRings.TABLE_NAME+ ""String_Node_Str""+ KeyRings.TYPE+ ""String_Node_Str"",new String[]{""String_Node_Str"" + keyId,""String_Node_Str"" + type},null,null,null);
  byte[] data=null;
  if (c != null && c.moveToFirst()) {
    data=c.getBlob(0);
  }
  if (c != null) {
    c.close();
  }
  return data;
}",0.9829816201497618
8445,"public static Bundle verifyText(InputStream inStream,OutputStream outStream,ProgressDialogUpdater progress) throws IOException, GeneralException, PGPException, SignatureException {
  Bundle returnData=new Bundle();
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ArmoredInputStream aIn=new ArmoredInputStream(inStream);
  progress.setProgress(""String_Node_Str"",0,100);
  ByteArrayOutputStream lineOut=new ByteArrayOutputStream();
  int lookAhead=readInputLine(lineOut,aIn);
  byte[] lineSep=getLineSeparator();
  if (lookAhead != -1 && aIn.isClearText()) {
    byte[] line=lineOut.toByteArray();
    out.write(line,0,getLengthWithoutSeparator(line));
    out.write(lineSep);
    while (lookAhead != -1 && aIn.isClearText()) {
      lookAhead=readInputLine(lineOut,lookAhead,aIn);
      line=lineOut.toByteArray();
      out.write(line,0,getLengthWithoutSeparator(line));
      out.write(lineSep);
    }
  }
  out.close();
  byte[] clearText=out.toByteArray();
  outStream.write(clearText);
  returnData.putBoolean(""String_Node_Str"",true);
  progress.setProgress(""String_Node_Str"",60,100);
  PGPObjectFactory pgpFact=new PGPObjectFactory(aIn);
  PGPSignatureList sigList=(PGPSignatureList)pgpFact.nextObject();
  if (sigList == null) {
    throw new GeneralException(""String_Node_Str"");
  }
  PGPSignature signature=null;
  long signatureKeyId=0;
  PGPPublicKey signatureKey=null;
  for (int i=0; i < sigList.size(); ++i) {
    signature=sigList.get(i);
    signatureKey=findPublicKey(signature.getKeyID());
    if (signatureKeyId == 0) {
      signatureKeyId=signature.getKeyID();
    }
    if (signatureKey == null) {
      signature=null;
    }
 else {
      signatureKeyId=signature.getKeyID();
      String userId=null;
      PGPPublicKeyRing sigKeyRing=findPublicKeyRing(signatureKeyId);
      if (sigKeyRing != null) {
        userId=getMainUserId(getMasterKey(sigKeyRing));
      }
      returnData.putString(""String_Node_Str"",userId);
      break;
    }
  }
  returnData.putLong(""String_Node_Str"",signatureKeyId);
  if (signature == null) {
    returnData.putBoolean(""String_Node_Str"",true);
    progress.setProgress(""String_Node_Str"",100,100);
    return returnData;
  }
  signature.initVerify(signatureKey,new BouncyCastleProvider());
  InputStream sigIn=new BufferedInputStream(new ByteArrayInputStream(clearText));
  lookAhead=readInputLine(lineOut,sigIn);
  processLine(signature,lineOut.toByteArray());
  if (lookAhead != -1) {
    do {
      lookAhead=readInputLine(lineOut,lookAhead,sigIn);
      signature.update((byte)'\r');
      signature.update((byte)'\n');
      processLine(signature,lineOut.toByteArray());
    }
 while (lookAhead != -1);
  }
  returnData.putBoolean(""String_Node_Str"",signature.verify());
  progress.setProgress(""String_Node_Str"",100,100);
  return returnData;
}","public static Bundle verifyText(InputStream inStream,OutputStream outStream,ProgressDialogUpdater progress) throws IOException, GeneralException, PGPException, SignatureException {
  Bundle returnData=new Bundle();
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  ArmoredInputStream aIn=new ArmoredInputStream(inStream);
  progress.setProgress(""String_Node_Str"",0,100);
  ByteArrayOutputStream lineOut=new ByteArrayOutputStream();
  int lookAhead=readInputLine(lineOut,aIn);
  byte[] lineSep=getLineSeparator();
  byte[] line=lineOut.toByteArray();
  out.write(line,0,getLengthWithoutSeparator(line));
  out.write(lineSep);
  while (lookAhead != -1 && aIn.isClearText()) {
    lookAhead=readInputLine(lineOut,lookAhead,aIn);
    line=lineOut.toByteArray();
    out.write(line,0,getLengthWithoutSeparator(line));
    out.write(lineSep);
  }
  out.close();
  byte[] clearText=out.toByteArray();
  outStream.write(clearText);
  returnData.putBoolean(""String_Node_Str"",true);
  progress.setProgress(""String_Node_Str"",60,100);
  PGPObjectFactory pgpFact=new PGPObjectFactory(aIn);
  PGPSignatureList sigList=(PGPSignatureList)pgpFact.nextObject();
  if (sigList == null) {
    throw new GeneralException(""String_Node_Str"");
  }
  PGPSignature signature=null;
  long signatureKeyId=0;
  PGPPublicKey signatureKey=null;
  for (int i=0; i < sigList.size(); ++i) {
    signature=sigList.get(i);
    signatureKey=findPublicKey(signature.getKeyID());
    if (signatureKeyId == 0) {
      signatureKeyId=signature.getKeyID();
    }
    if (signatureKey == null) {
      signature=null;
    }
 else {
      signatureKeyId=signature.getKeyID();
      String userId=null;
      PGPPublicKeyRing sigKeyRing=findPublicKeyRing(signatureKeyId);
      if (sigKeyRing != null) {
        userId=getMainUserId(getMasterKey(sigKeyRing));
      }
      returnData.putString(""String_Node_Str"",userId);
      break;
    }
  }
  returnData.putLong(""String_Node_Str"",signatureKeyId);
  if (signature == null) {
    returnData.putBoolean(""String_Node_Str"",true);
    progress.setProgress(""String_Node_Str"",100,100);
    return returnData;
  }
  signature.initVerify(signatureKey,new BouncyCastleProvider());
  InputStream sigIn=new BufferedInputStream(new ByteArrayInputStream(clearText));
  lookAhead=readInputLine(lineOut,sigIn);
  processLine(signature,lineOut.toByteArray());
  if (lookAhead != -1) {
    do {
      lookAhead=readInputLine(lineOut,lookAhead,sigIn);
      signature.update((byte)'\r');
      signature.update((byte)'\n');
      processLine(signature,lineOut.toByteArray());
    }
 while (lookAhead != -1);
  }
  returnData.putBoolean(""String_Node_Str"",signature.verify());
  progress.setProgress(""String_Node_Str"",100,100);
  return returnData;
}",0.9262589928057554
8446,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.decrypt);
  mSource=(ViewFlipper)findViewById(R.id.source);
  mSourceLabel=(TextView)findViewById(R.id.source_label);
  mSourcePrevious=(ImageView)findViewById(R.id.source_previous);
  mSourceNext=(ImageView)findViewById(R.id.source_next);
  mSourcePrevious.setClickable(true);
  mSourcePrevious.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_right_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_right_out));
      mSource.showPrevious();
      updateSource();
    }
  }
);
  mSourceNext.setClickable(true);
  OnClickListener nextSourceClickListener=new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_left_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_left_out));
      mSource.showNext();
      updateSource();
    }
  }
;
  mSourceNext.setOnClickListener(nextSourceClickListener);
  mSourceLabel.setClickable(true);
  mSourceLabel.setOnClickListener(nextSourceClickListener);
  mMessage=(EditText)findViewById(R.id.message);
  mDecryptButton=(Button)findViewById(R.id.btn_decrypt);
  mReplyButton=(Button)findViewById(R.id.btn_reply);
  mSignatureLayout=(LinearLayout)findViewById(R.id.layout_signature);
  mSignatureStatusImage=(ImageView)findViewById(R.id.ic_signature_status);
  mUserId=(TextView)findViewById(R.id.main_user_id);
  mUserIdRest=(TextView)findViewById(R.id.main_user_id_rest);
  View tmp=findViewById(R.id.source_file);
  tmp.measure(View.MeasureSpec.UNSPECIFIED,View.MeasureSpec.UNSPECIFIED);
  int height=tmp.getMeasuredHeight();
  mMessage.setMinimumHeight(height);
  mFilename=(EditText)findViewById(R.id.filename);
  mBrowse=(ImageButton)findViewById(R.id.btn_browse);
  mBrowse.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      openFile();
    }
  }
);
  mDeleteAfter=(CheckBox)findViewById(R.id.delete_after_decryption);
  Intent intent=getIntent();
  if (intent.getAction() != null && intent.getAction().equals(Intent.ACTION_VIEW)) {
    Uri uri=intent.getData();
    try {
      InputStream attachment=getContentResolver().openInputStream(uri);
      ByteArrayOutputStream byteOut=new ByteArrayOutputStream();
      byte bytes[]=new byte[1 << 16];
      int length;
      while ((length=attachment.read(bytes)) > 0) {
        byteOut.write(bytes,0,length);
      }
      byteOut.close();
      String data=Strings.fromUTF8ByteArray(byteOut.toByteArray());
      mMessage.setText(data);
    }
 catch (    FileNotFoundException e) {
    }
catch (    IOException e) {
    }
  }
 else   if (intent.getAction() != null && intent.getAction().equals(Apg.Intent.DECRYPT)) {
    Bundle extras=intent.getExtras();
    if (extras == null) {
      extras=new Bundle();
    }
    String data=extras.getString(""String_Node_Str"");
    if (data != null) {
      Matcher matcher=Apg.PGP_MESSAGE.matcher(data);
      if (matcher.matches()) {
        data=matcher.group(1);
        data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
        mMessage.setText(data);
      }
 else {
        matcher=Apg.PGP_SIGNED_MESSAGE.matcher(data);
        if (matcher.matches()) {
          data=matcher.group(1);
          data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
          mMessage.setText(data);
          mDecryptButton.setText(R.string.btn_verify);
        }
      }
    }
    mReplyTo=extras.getString(""String_Node_Str"");
    mSubject=extras.getString(""String_Node_Str"");
  }
  if (mMessage.getText().length() == 0) {
    ClipboardManager clip=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
    String data=""String_Node_Str"";
    Matcher matcher=Apg.PGP_MESSAGE.matcher(clip.getText());
    if (matcher.matches()) {
      data=matcher.group(1);
      mMessage.setText(data);
      Toast.makeText(this,R.string.using_clipboard_content,Toast.LENGTH_SHORT).show();
    }
  }
  mSignatureLayout.setVisibility(View.GONE);
  mDecryptButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      decryptClicked();
    }
  }
);
  mReplyButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      replyClicked();
    }
  }
);
  mReplyButton.setVisibility(View.INVISIBLE);
  if (mMessage.getText().length() > 0) {
    mDecryptButton.performClick();
  }
  updateSource();
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.decrypt);
  mSource=(ViewFlipper)findViewById(R.id.source);
  mSourceLabel=(TextView)findViewById(R.id.source_label);
  mSourcePrevious=(ImageView)findViewById(R.id.source_previous);
  mSourceNext=(ImageView)findViewById(R.id.source_next);
  mSourcePrevious.setClickable(true);
  mSourcePrevious.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_right_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_right_out));
      mSource.showPrevious();
      updateSource();
    }
  }
);
  mSourceNext.setClickable(true);
  OnClickListener nextSourceClickListener=new OnClickListener(){
    @Override public void onClick(    View v){
      mSource.setInAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_left_in));
      mSource.setOutAnimation(AnimationUtils.loadAnimation(DecryptActivity.this,R.anim.push_left_out));
      mSource.showNext();
      updateSource();
    }
  }
;
  mSourceNext.setOnClickListener(nextSourceClickListener);
  mSourceLabel.setClickable(true);
  mSourceLabel.setOnClickListener(nextSourceClickListener);
  mMessage=(EditText)findViewById(R.id.message);
  mDecryptButton=(Button)findViewById(R.id.btn_decrypt);
  mReplyButton=(Button)findViewById(R.id.btn_reply);
  mSignatureLayout=(LinearLayout)findViewById(R.id.layout_signature);
  mSignatureStatusImage=(ImageView)findViewById(R.id.ic_signature_status);
  mUserId=(TextView)findViewById(R.id.main_user_id);
  mUserIdRest=(TextView)findViewById(R.id.main_user_id_rest);
  View tmp=findViewById(R.id.source_file);
  tmp.measure(View.MeasureSpec.UNSPECIFIED,View.MeasureSpec.UNSPECIFIED);
  int height=tmp.getMeasuredHeight();
  mMessage.setMinimumHeight(height);
  mFilename=(EditText)findViewById(R.id.filename);
  mBrowse=(ImageButton)findViewById(R.id.btn_browse);
  mBrowse.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      openFile();
    }
  }
);
  mDeleteAfter=(CheckBox)findViewById(R.id.delete_after_decryption);
  mSource.setInAnimation(null);
  mSource.setOutAnimation(null);
  while (mSource.getCurrentView().getId() != R.id.source_message) {
    mSource.showNext();
  }
  Intent intent=getIntent();
  if (intent.getAction() != null && intent.getAction().equals(Intent.ACTION_VIEW)) {
    Uri uri=intent.getData();
    try {
      InputStream attachment=getContentResolver().openInputStream(uri);
      ByteArrayOutputStream byteOut=new ByteArrayOutputStream();
      byte bytes[]=new byte[1 << 16];
      int length;
      while ((length=attachment.read(bytes)) > 0) {
        byteOut.write(bytes,0,length);
      }
      byteOut.close();
      String data=Strings.fromUTF8ByteArray(byteOut.toByteArray());
      mMessage.setText(data);
    }
 catch (    FileNotFoundException e) {
    }
catch (    IOException e) {
    }
  }
 else   if (intent.getAction() != null && intent.getAction().equals(Apg.Intent.DECRYPT)) {
    Bundle extras=intent.getExtras();
    if (extras == null) {
      extras=new Bundle();
    }
    String data=extras.getString(""String_Node_Str"");
    if (data != null) {
      Matcher matcher=Apg.PGP_MESSAGE.matcher(data);
      if (matcher.matches()) {
        data=matcher.group(1);
        data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
        mMessage.setText(data);
      }
 else {
        matcher=Apg.PGP_SIGNED_MESSAGE.matcher(data);
        if (matcher.matches()) {
          data=matcher.group(1);
          data=data.replaceAll(""String_Node_Str"",""String_Node_Str"");
          mMessage.setText(data);
          mDecryptButton.setText(R.string.btn_verify);
        }
      }
    }
    mReplyTo=extras.getString(""String_Node_Str"");
    mSubject=extras.getString(""String_Node_Str"");
  }
 else   if (intent.getAction() != null && intent.getAction().equals(Apg.Intent.DECRYPT_FILE)) {
    mSource.setInAnimation(null);
    mSource.setOutAnimation(null);
    while (mSource.getCurrentView().getId() != R.id.source_file) {
      mSource.showNext();
    }
  }
  Log.e(""String_Node_Str"",""String_Node_Str"" + mSource.getCurrentView().getId() + ""String_Node_Str""+ R.id.source_message+ ""String_Node_Str""+ mMessage.getText().length());
  if (mSource.getCurrentView().getId() == R.id.source_message && mMessage.getText().length() == 0) {
    ClipboardManager clip=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
    String data=""String_Node_Str"";
    Matcher matcher=Apg.PGP_MESSAGE.matcher(clip.getText());
    if (!matcher.matches()) {
      matcher=Apg.PGP_SIGNED_MESSAGE.matcher(clip.getText());
    }
    if (matcher.matches()) {
      data=matcher.group(1);
      mMessage.setText(data);
      Toast.makeText(this,R.string.using_clipboard_content,Toast.LENGTH_SHORT).show();
    }
  }
  mSignatureLayout.setVisibility(View.GONE);
  mDecryptButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      decryptClicked();
    }
  }
);
  mReplyButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      replyClicked();
    }
  }
);
  mReplyButton.setVisibility(View.INVISIBLE);
  if (mSource.getCurrentView().getId() == R.id.source_message && mMessage.getText().length() > 0) {
    mDecryptButton.performClick();
  }
  updateSource();
}",0.9202153695545766
8447,"public static PGPSecretKey createKey(int algorithmChoice,int keySize,String passPhrase) throws NoSuchAlgorithmException, PGPException, NoSuchProviderException, GeneralException, InvalidAlgorithmParameterException {
  if (keySize < 512) {
    throw new GeneralException(""String_Node_Str"");
  }
  Security.addProvider(new BouncyCastleProvider());
  if (passPhrase == null) {
    passPhrase=""String_Node_Str"";
  }
  int algorithm=0;
  KeyPairGenerator keyGen=null;
switch (algorithmChoice) {
case Id.choice.algorithm.dsa:
{
      keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",new BouncyCastleProvider());
      keyGen.initialize(keySize,new SecureRandom());
      algorithm=PGPPublicKey.DSA;
      break;
    }
case Id.choice.algorithm.elgamal:
{
    if (keySize != 2048) {
      throw new GeneralException(""String_Node_Str"");
    }
    keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",new BouncyCastleProvider());
    BigInteger p=new BigInteger(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",16);
    ElGamalParameterSpec elParams=new ElGamalParameterSpec(p,new BigInteger(""String_Node_Str""));
    keyGen.initialize(elParams);
    algorithm=PGPPublicKey.ELGAMAL_GENERAL;
    break;
  }
case Id.choice.algorithm.rsa:
{
  keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",new BouncyCastleProvider());
  keyGen.initialize(keySize,new SecureRandom());
  algorithm=PGPPublicKey.RSA_GENERAL;
  break;
}
default :
{
throw new GeneralException(""String_Node_Str"");
}
}
PGPKeyPair keyPair=new PGPKeyPair(algorithm,keyGen.generateKeyPair(),new Date());
PGPSecretKey secretKey=new PGPSecretKey(PGPSignature.DEFAULT_CERTIFICATION,keyPair,""String_Node_Str"",PGPEncryptedData.CAST5,passPhrase.toCharArray(),null,null,new SecureRandom(),new BouncyCastleProvider().getName());
return secretKey;
}","public static PGPSecretKey createKey(int algorithmChoice,int keySize,String passPhrase,PGPSecretKey masterKey) throws NoSuchAlgorithmException, PGPException, NoSuchProviderException, GeneralException, InvalidAlgorithmParameterException {
  if (keySize < 512) {
    throw new GeneralException(""String_Node_Str"");
  }
  Security.addProvider(new BouncyCastleProvider());
  if (passPhrase == null) {
    passPhrase=""String_Node_Str"";
  }
  int algorithm=0;
  KeyPairGenerator keyGen=null;
switch (algorithmChoice) {
case Id.choice.algorithm.dsa:
{
      keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",new BouncyCastleProvider());
      keyGen.initialize(keySize,new SecureRandom());
      algorithm=PGPPublicKey.DSA;
      break;
    }
case Id.choice.algorithm.elgamal:
{
    if (masterKey == null) {
      throw new GeneralException(""String_Node_Str"");
    }
    keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",new BouncyCastleProvider());
    BigInteger p=Primes.getBestPrime(keySize);
    BigInteger g=new BigInteger(""String_Node_Str"");
    ElGamalParameterSpec elParams=new ElGamalParameterSpec(p,g);
    keyGen.initialize(elParams);
    algorithm=PGPPublicKey.ELGAMAL_ENCRYPT;
    break;
  }
case Id.choice.algorithm.rsa:
{
  keyGen=KeyPairGenerator.getInstance(""String_Node_Str"",new BouncyCastleProvider());
  keyGen.initialize(keySize,new SecureRandom());
  algorithm=PGPPublicKey.RSA_GENERAL;
  break;
}
default :
{
throw new GeneralException(""String_Node_Str"");
}
}
PGPKeyPair keyPair=new PGPKeyPair(algorithm,keyGen.generateKeyPair(),new Date());
PGPSecretKey secretKey=null;
if (masterKey == null) {
secretKey=new PGPSecretKey(PGPSignature.DEFAULT_CERTIFICATION,keyPair,""String_Node_Str"",PGPEncryptedData.CAST5,passPhrase.toCharArray(),null,null,new SecureRandom(),new BouncyCastleProvider().getName());
}
 else {
PGPPublicKey tmpKey=masterKey.getPublicKey();
PGPPublicKey masterPublicKey=new PGPPublicKey(tmpKey.getAlgorithm(),tmpKey.getKey(new BouncyCastleProvider()),tmpKey.getCreationTime());
PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(passPhrase.toCharArray(),new BouncyCastleProvider());
PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
PGPKeyRingGenerator ringGen=new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION,masterKeyPair,""String_Node_Str"",PGPEncryptedData.CAST5,passPhrase.toCharArray(),null,null,new SecureRandom(),new BouncyCastleProvider().getName());
ringGen.addSubKey(keyPair);
PGPSecretKeyRing secKeyRing=ringGen.generateSecretKeyRing();
Iterator it=secKeyRing.getSecretKeys();
it.next();
secretKey=(PGPSecretKey)it.next();
}
return secretKey;
}",0.5980522355024347
8448,"public static void buildSecretKey(Activity context,SectionView userIdsView,SectionView keysView,String oldPassPhrase,String newPassPhrase,ProgressDialogUpdater progress) throws Apg.GeneralException, NoSuchProviderException, PGPException, NoSuchAlgorithmException, SignatureException {
  progress.setProgress(""String_Node_Str"",0,100);
  Security.addProvider(new BouncyCastleProvider());
  if (oldPassPhrase == null || oldPassPhrase.equals(""String_Node_Str"")) {
    oldPassPhrase=""String_Node_Str"";
  }
  if (newPassPhrase == null || newPassPhrase.equals(""String_Node_Str"")) {
    newPassPhrase=""String_Node_Str"";
  }
  Vector<String> userIds=new Vector<String>();
  Vector<PGPSecretKey> keys=new Vector<PGPSecretKey>();
  ViewGroup userIdEditors=userIdsView.getEditors();
  ViewGroup keyEditors=keysView.getEditors();
  boolean gotMainUserId=false;
  for (int i=0; i < userIdEditors.getChildCount(); ++i) {
    UserIdEditor editor=(UserIdEditor)userIdEditors.getChildAt(i);
    String userId=null;
    try {
      userId=editor.getValue();
    }
 catch (    UserIdEditor.NoNameException e) {
      throw new Apg.GeneralException(""String_Node_Str"");
    }
catch (    UserIdEditor.NoEmailException e) {
      throw new Apg.GeneralException(""String_Node_Str"");
    }
catch (    UserIdEditor.InvalidEmailException e) {
      throw new Apg.GeneralException(e.getMessage());
    }
    if (userId.equals(""String_Node_Str"")) {
      continue;
    }
    if (editor.isMainUserId()) {
      userIds.insertElementAt(userId,0);
      gotMainUserId=true;
    }
 else {
      userIds.add(userId);
    }
  }
  if (userIds.size() == 0) {
    throw new Apg.GeneralException(""String_Node_Str"");
  }
  if (!gotMainUserId) {
    throw new Apg.GeneralException(""String_Node_Str"");
  }
  if (keyEditors.getChildCount() == 0) {
    throw new Apg.GeneralException(""String_Node_Str"");
  }
  for (int i=0; i < keyEditors.getChildCount(); ++i) {
    KeyEditor editor=(KeyEditor)keyEditors.getChildAt(i);
    keys.add(editor.getValue());
  }
  progress.setProgress(""String_Node_Str"",10,100);
  KeyEditor keyEditor=(KeyEditor)keyEditors.getChildAt(0);
  int usageId=keyEditor.getUsage();
  boolean canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
  boolean canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
  String mainUserId=userIds.get(0);
  PGPSecretKey masterKey=keys.get(0);
  PGPPublicKey tmpKey=masterKey.getPublicKey();
  PGPPublicKey masterPublicKey=new PGPPublicKey(tmpKey.getAlgorithm(),tmpKey.getKey(new BouncyCastleProvider()),tmpKey.getCreationTime());
  PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(oldPassPhrase.toCharArray(),new BouncyCastleProvider());
  progress.setProgress(""String_Node_Str"",20,100);
  for (int i=0; i < userIds.size(); ++i) {
    String userId=userIds.get(i);
    PGPSignatureGenerator sGen=new PGPSignatureGenerator(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1,new BouncyCastleProvider());
    sGen.initSign(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
    PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
    masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,userId,certification);
  }
  PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
  PGPSignatureSubpacketGenerator hashedPacketsGen=new PGPSignatureSubpacketGenerator();
  PGPSignatureSubpacketGenerator unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
  int keyFlags=KeyFlags.CERTIFY_OTHER | KeyFlags.SIGN_DATA;
  if (canEncrypt) {
    keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
  }
  hashedPacketsGen.setKeyFlags(true,keyFlags);
  hashedPacketsGen.setPreferredSymmetricAlgorithms(true,PREFERRED_SYMMETRIC_ALGORITHMS);
  hashedPacketsGen.setPreferredHashAlgorithms(true,PREFERRED_HASH_ALGORITHMS);
  hashedPacketsGen.setPreferredCompressionAlgorithms(true,PREFERRED_COMPRESSION_ALGORITHMS);
  if (keyEditor.getExpiryDate() != null) {
    GregorianCalendar creationDate=new GregorianCalendar();
    creationDate.setTime(getCreationDate(masterKey));
    GregorianCalendar expiryDate=keyEditor.getExpiryDate();
    long numDays=getNumDatesBetween(creationDate,expiryDate);
    if (numDays <= 0) {
      throw new GeneralException(""String_Node_Str"");
    }
    hashedPacketsGen.setKeyExpirationTime(true,numDays * 86400);
  }
  progress.setProgress(""String_Node_Str"",30,100);
  PGPKeyRingGenerator keyGen=new PGPKeyRingGenerator(PGPSignature.DEFAULT_CERTIFICATION,masterKeyPair,mainUserId,PGPEncryptedData.CAST5,newPassPhrase.toCharArray(),hashedPacketsGen.generate(),unhashedPacketsGen.generate(),new SecureRandom(),new BouncyCastleProvider().getName());
  progress.setProgress(""String_Node_Str"",40,100);
  for (int i=1; i < keys.size(); ++i) {
    progress.setProgress(40 + 50 * (i - 1) / (keys.size() - 1),100);
    PGPSecretKey subKey=keys.get(i);
    keyEditor=(KeyEditor)keyEditors.getChildAt(i);
    PGPPublicKey subPublicKey=subKey.getPublicKey();
    PGPPrivateKey subPrivateKey=subKey.extractPrivateKey(oldPassPhrase.toCharArray(),new BouncyCastleProvider());
    PGPKeyPair subKeyPair=new PGPKeyPair(subPublicKey.getAlgorithm(),subPublicKey.getKey(new BouncyCastleProvider()),subPrivateKey.getKey(),subPublicKey.getCreationTime());
    hashedPacketsGen=new PGPSignatureSubpacketGenerator();
    unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
    keyFlags=0;
    usageId=keyEditor.getUsage();
    canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
    canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
    if (canSign) {
      keyFlags|=KeyFlags.SIGN_DATA;
    }
    if (canEncrypt) {
      keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
    }
    hashedPacketsGen.setKeyFlags(true,keyFlags);
    if (keyEditor.getExpiryDate() != null) {
      GregorianCalendar creationDate=new GregorianCalendar();
      creationDate.setTime(getCreationDate(masterKey));
      GregorianCalendar expiryDate=keyEditor.getExpiryDate();
      long numDays=getNumDatesBetween(creationDate,expiryDate);
      if (numDays <= 0) {
        throw new GeneralException(""String_Node_Str"");
      }
      hashedPacketsGen.setKeyExpirationTime(true,numDays * 86400);
    }
    keyGen.addSubKey(subKeyPair,hashedPacketsGen.generate(),unhashedPacketsGen.generate());
  }
  PGPSecretKeyRing secretKeyRing=keyGen.generateSecretKeyRing();
  PGPPublicKeyRing publicKeyRing=keyGen.generatePublicKeyRing();
  progress.setProgress(""String_Node_Str"",90,100);
  saveKeyRing(context,secretKeyRing);
  saveKeyRing(context,publicKeyRing);
  loadKeyRings(context,Id.type.public_key);
  loadKeyRings(context,Id.type.secret_key);
  progress.setProgress(""String_Node_Str"",100,100);
}","public static void buildSecretKey(Activity context,SectionView userIdsView,SectionView keysView,String oldPassPhrase,String newPassPhrase,ProgressDialogUpdater progress) throws Apg.GeneralException, NoSuchProviderException, PGPException, NoSuchAlgorithmException, SignatureException {
  progress.setProgress(""String_Node_Str"",0,100);
  Security.addProvider(new BouncyCastleProvider());
  if (oldPassPhrase == null || oldPassPhrase.equals(""String_Node_Str"")) {
    oldPassPhrase=""String_Node_Str"";
  }
  if (newPassPhrase == null || newPassPhrase.equals(""String_Node_Str"")) {
    newPassPhrase=""String_Node_Str"";
  }
  Vector<String> userIds=new Vector<String>();
  Vector<PGPSecretKey> keys=new Vector<PGPSecretKey>();
  ViewGroup userIdEditors=userIdsView.getEditors();
  ViewGroup keyEditors=keysView.getEditors();
  boolean gotMainUserId=false;
  for (int i=0; i < userIdEditors.getChildCount(); ++i) {
    UserIdEditor editor=(UserIdEditor)userIdEditors.getChildAt(i);
    String userId=null;
    try {
      userId=editor.getValue();
    }
 catch (    UserIdEditor.NoNameException e) {
      throw new Apg.GeneralException(""String_Node_Str"");
    }
catch (    UserIdEditor.NoEmailException e) {
      throw new Apg.GeneralException(""String_Node_Str"");
    }
catch (    UserIdEditor.InvalidEmailException e) {
      throw new Apg.GeneralException(e.getMessage());
    }
    if (userId.equals(""String_Node_Str"")) {
      continue;
    }
    if (editor.isMainUserId()) {
      userIds.insertElementAt(userId,0);
      gotMainUserId=true;
    }
 else {
      userIds.add(userId);
    }
  }
  if (userIds.size() == 0) {
    throw new Apg.GeneralException(""String_Node_Str"");
  }
  if (!gotMainUserId) {
    throw new Apg.GeneralException(""String_Node_Str"");
  }
  if (keyEditors.getChildCount() == 0) {
    throw new Apg.GeneralException(""String_Node_Str"");
  }
  for (int i=0; i < keyEditors.getChildCount(); ++i) {
    KeyEditor editor=(KeyEditor)keyEditors.getChildAt(i);
    keys.add(editor.getValue());
  }
  progress.setProgress(""String_Node_Str"",10,100);
  KeyEditor keyEditor=(KeyEditor)keyEditors.getChildAt(0);
  int usageId=keyEditor.getUsage();
  boolean canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
  boolean canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
  String mainUserId=userIds.get(0);
  PGPSecretKey masterKey=keys.get(0);
  PGPPublicKey tmpKey=masterKey.getPublicKey();
  PGPPublicKey masterPublicKey=new PGPPublicKey(tmpKey.getAlgorithm(),tmpKey.getKey(new BouncyCastleProvider()),tmpKey.getCreationTime());
  PGPPrivateKey masterPrivateKey=masterKey.extractPrivateKey(oldPassPhrase.toCharArray(),new BouncyCastleProvider());
  progress.setProgress(""String_Node_Str"",20,100);
  for (int i=0; i < userIds.size(); ++i) {
    String userId=userIds.get(i);
    PGPSignatureGenerator sGen=new PGPSignatureGenerator(masterPublicKey.getAlgorithm(),HashAlgorithmTags.SHA1,new BouncyCastleProvider());
    sGen.initSign(PGPSignature.POSITIVE_CERTIFICATION,masterPrivateKey);
    PGPSignature certification=sGen.generateCertification(userId,masterPublicKey);
    masterPublicKey=PGPPublicKey.addCertification(masterPublicKey,userId,certification);
  }
  PGPKeyPair masterKeyPair=new PGPKeyPair(masterPublicKey,masterPrivateKey);
  PGPSignatureSubpacketGenerator hashedPacketsGen=new PGPSignatureSubpacketGenerator();
  PGPSignatureSubpacketGenerator unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
  int keyFlags=KeyFlags.CERTIFY_OTHER | KeyFlags.SIGN_DATA;
  if (canEncrypt) {
    keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
  }
  hashedPacketsGen.setKeyFlags(true,keyFlags);
  hashedPacketsGen.setPreferredSymmetricAlgorithms(true,PREFERRED_SYMMETRIC_ALGORITHMS);
  hashedPacketsGen.setPreferredHashAlgorithms(true,PREFERRED_HASH_ALGORITHMS);
  hashedPacketsGen.setPreferredCompressionAlgorithms(true,PREFERRED_COMPRESSION_ALGORITHMS);
  if (keyEditor.getExpiryDate() != null) {
    GregorianCalendar creationDate=new GregorianCalendar();
    creationDate.setTime(getCreationDate(masterKey));
    GregorianCalendar expiryDate=keyEditor.getExpiryDate();
    long numDays=getNumDatesBetween(creationDate,expiryDate);
    if (numDays <= 0) {
      throw new GeneralException(""String_Node_Str"");
    }
    hashedPacketsGen.setKeyExpirationTime(true,numDays * 86400);
  }
  progress.setProgress(""String_Node_Str"",30,100);
  PGPKeyRingGenerator keyGen=new PGPKeyRingGenerator(PGPSignature.POSITIVE_CERTIFICATION,masterKeyPair,mainUserId,PGPEncryptedData.CAST5,newPassPhrase.toCharArray(),hashedPacketsGen.generate(),unhashedPacketsGen.generate(),new SecureRandom(),new BouncyCastleProvider().getName());
  progress.setProgress(""String_Node_Str"",40,100);
  for (int i=1; i < keys.size(); ++i) {
    progress.setProgress(40 + 50 * (i - 1) / (keys.size() - 1),100);
    PGPSecretKey subKey=keys.get(i);
    keyEditor=(KeyEditor)keyEditors.getChildAt(i);
    PGPPublicKey subPublicKey=subKey.getPublicKey();
    PGPPrivateKey subPrivateKey=subKey.extractPrivateKey(oldPassPhrase.toCharArray(),new BouncyCastleProvider());
    PGPKeyPair subKeyPair=new PGPKeyPair(subPublicKey.getAlgorithm(),subPublicKey.getKey(new BouncyCastleProvider()),subPrivateKey.getKey(),subPublicKey.getCreationTime());
    hashedPacketsGen=new PGPSignatureSubpacketGenerator();
    unhashedPacketsGen=new PGPSignatureSubpacketGenerator();
    keyFlags=0;
    usageId=keyEditor.getUsage();
    canSign=(usageId == Id.choice.usage.sign_only || usageId == Id.choice.usage.sign_and_encrypt);
    canEncrypt=(usageId == Id.choice.usage.encrypt_only || usageId == Id.choice.usage.sign_and_encrypt);
    if (canSign) {
      keyFlags|=KeyFlags.SIGN_DATA;
    }
    if (canEncrypt) {
      keyFlags|=KeyFlags.ENCRYPT_COMMS | KeyFlags.ENCRYPT_STORAGE;
    }
    hashedPacketsGen.setKeyFlags(true,keyFlags);
    if (keyEditor.getExpiryDate() != null) {
      GregorianCalendar creationDate=new GregorianCalendar();
      creationDate.setTime(getCreationDate(masterKey));
      GregorianCalendar expiryDate=keyEditor.getExpiryDate();
      long numDays=getNumDatesBetween(creationDate,expiryDate);
      if (numDays <= 0) {
        throw new GeneralException(""String_Node_Str"");
      }
      hashedPacketsGen.setKeyExpirationTime(true,numDays * 86400);
    }
    keyGen.addSubKey(subKeyPair,hashedPacketsGen.generate(),unhashedPacketsGen.generate());
  }
  PGPSecretKeyRing secretKeyRing=keyGen.generateSecretKeyRing();
  PGPPublicKeyRing publicKeyRing=keyGen.generatePublicKeyRing();
  progress.setProgress(""String_Node_Str"",90,100);
  saveKeyRing(context,secretKeyRing);
  saveKeyRing(context,publicKeyRing);
  loadKeyRings(context,Id.type.public_key);
  loadKeyRings(context,Id.type.secret_key);
  progress.setProgress(""String_Node_Str"",100,100);
}",0.9990511641486024
8449,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.edit_key);
  Vector<String> userIds=new Vector<String>();
  Vector<PGPSecretKey> keys=new Vector<PGPSecretKey>();
  Intent intent=getIntent();
  long keyId=0;
  if (intent.getExtras() != null) {
    keyId=intent.getExtras().getLong(""String_Node_Str"");
  }
  if (keyId != 0) {
    PGPSecretKey masterKey=null;
    mKeyRing=Apg.getSecretKeyRing(keyId);
    if (mKeyRing != null) {
      masterKey=Apg.getMasterKey(mKeyRing);
      for (      PGPSecretKey key : new IterableIterator<PGPSecretKey>(mKeyRing.getSecretKeys())) {
        keys.add(key);
      }
    }
    if (masterKey != null) {
      for (      String userId : new IterableIterator<String>(masterKey.getUserIDs())) {
        userIds.add(userId);
      }
    }
  }
  if (Apg.getPassPhrase() == null) {
    Apg.setPassPhrase(""String_Node_Str"");
  }
  mSaveButton=(Button)findViewById(R.id.btn_save);
  mDiscardButton=(Button)findViewById(R.id.btn_discard);
  mSaveButton.setOnClickListener(this);
  mDiscardButton.setOnClickListener(this);
  LayoutInflater inflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  LinearLayout container=(LinearLayout)findViewById(R.id.container);
  mUserIds=(SectionView)inflater.inflate(R.layout.edit_key_section,container,false);
  mUserIds.setType(SectionView.TYPE_USER_ID);
  mUserIds.setUserIds(userIds);
  container.addView(mUserIds);
  mKeys=(SectionView)inflater.inflate(R.layout.edit_key_section,container,false);
  mKeys.setType(SectionView.TYPE_KEY);
  mKeys.setKeys(keys);
  container.addView(mKeys);
  Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.edit_key);
  Vector<String> userIds=new Vector<String>();
  Vector<PGPSecretKey> keys=new Vector<PGPSecretKey>();
  Intent intent=getIntent();
  long keyId=0;
  if (intent.getExtras() != null) {
    keyId=intent.getExtras().getLong(""String_Node_Str"");
  }
  if (keyId == 0) {
    Apg.setPassPhrase(null);
  }
 else {
    PGPSecretKey masterKey=null;
    mKeyRing=Apg.getSecretKeyRing(keyId);
    if (mKeyRing != null) {
      masterKey=Apg.getMasterKey(mKeyRing);
      for (      PGPSecretKey key : new IterableIterator<PGPSecretKey>(mKeyRing.getSecretKeys())) {
        keys.add(key);
      }
    }
    if (masterKey != null) {
      for (      String userId : new IterableIterator<String>(masterKey.getUserIDs())) {
        userIds.add(userId);
      }
    }
  }
  if (Apg.getPassPhrase() == null) {
    Apg.setPassPhrase(""String_Node_Str"");
  }
  mSaveButton=(Button)findViewById(R.id.btn_save);
  mDiscardButton=(Button)findViewById(R.id.btn_discard);
  mSaveButton.setOnClickListener(this);
  mDiscardButton.setOnClickListener(this);
  LayoutInflater inflater=(LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  LinearLayout container=(LinearLayout)findViewById(R.id.container);
  mUserIds=(SectionView)inflater.inflate(R.layout.edit_key_section,container,false);
  mUserIds.setType(SectionView.TYPE_USER_ID);
  mUserIds.setUserIds(userIds);
  container.addView(mUserIds);
  mKeys=(SectionView)inflater.inflate(R.layout.edit_key_section,container,false);
  mKeys.setType(SectionView.TYPE_KEY);
  mKeys.setKeys(keys);
  container.addView(mKeys);
  Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
}",0.9876330169686512
8450,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
switch (requestCode) {
case Id.request.public_keys:
{
      if (resultCode == RESULT_OK) {
        Bundle bundle=data.getExtras();
        mEncryptionKeyIds=bundle.getLongArray(""String_Node_Str"");
        updateView();
      }
      break;
    }
default :
{
    break;
  }
}
super.onActivityResult(requestCode,resultCode,data);
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
switch (requestCode) {
case Id.request.secret_keys:
{
      if (resultCode == RESULT_OK) {
        super.onActivityResult(requestCode,resultCode,data);
        updateView();
      }
      break;
    }
case Id.request.public_keys:
{
    if (resultCode == RESULT_OK) {
      Bundle bundle=data.getExtras();
      mEncryptionKeyIds=bundle.getLongArray(""String_Node_Str"");
      updateView();
    }
    break;
  }
default :
{
  break;
}
}
super.onActivityResult(requestCode,resultCode,data);
}",0.7943548387096774
8451,"@Override protected Dialog onCreateDialog(int id){
switch (id) {
case Id.dialog.new_account:
{
      AlertDialog.Builder alert=new AlertDialog.Builder(this);
      alert.setTitle(""String_Node_Str"");
      alert.setMessage(""String_Node_Str"");
      final EditText input=new EditText(this);
      alert.setView(input);
      alert.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int id){
          MainActivity.this.removeDialog(Id.dialog.new_account);
          String accountName=""String_Node_Str"" + input.getText();
          Cursor testCursor=managedQuery(Uri.parse(""String_Node_Str"" + accountName),null,null,null,null);
          if (testCursor == null) {
            Toast.makeText(MainActivity.this,""String_Node_Str"" + accountName + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
            return;
          }
          ContentValues values=new ContentValues();
          values.put(Accounts.NAME,accountName);
          try {
            MainActivity.this.getContentResolver().insert(Accounts.CONTENT_URI,values);
          }
 catch (          SQLException e) {
            Toast.makeText(MainActivity.this,""String_Node_Str"" + accountName + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
          }
        }
      }
);
      alert.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int id){
          MainActivity.this.removeDialog(Id.dialog.new_account);
        }
      }
);
      return alert.create();
    }
case Id.dialog.about:
{
    AlertDialog.Builder alert=new AlertDialog.Builder(this);
    alert.setTitle(""String_Node_Str"" + Apg.FULL_VERSION);
    ScrollView scrollView=new ScrollView(this);
    TextView message=new TextView(this);
    SpannableString info=new SpannableString(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Linkify.addLinks(info,Linkify.WEB_URLS | Linkify.EMAIL_ADDRESSES);
    message.setMovementMethod(LinkMovementMethod.getInstance());
    message.setText(info);
    int padding=(int)(10 * getResources().getDisplayMetrics().densityDpi / 160);
    message.setPadding(padding,padding,padding,padding);
    message.setTextAppearance(this,android.R.style.TextAppearance_Medium);
    scrollView.addView(message);
    alert.setView(scrollView);
    alert.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int id){
        MainActivity.this.removeDialog(Id.dialog.about);
      }
    }
);
    return alert.create();
  }
case Id.dialog.change_log:
{
  AlertDialog.Builder alert=new AlertDialog.Builder(this);
  alert.setTitle(""String_Node_Str"" + Apg.FULL_VERSION);
  ScrollView scrollView=new ScrollView(this);
  TextView message=new TextView(this);
  SpannableString info=new SpannableString(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  message.setText(info);
  int padding=(int)(10 * getResources().getDisplayMetrics().densityDpi / 160);
  message.setPadding(padding,padding,padding,padding);
  message.setTextAppearance(this,android.R.style.TextAppearance_Medium);
  scrollView.addView(message);
  alert.setView(scrollView);
  alert.setCancelable(false);
  alert.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      MainActivity.this.removeDialog(Id.dialog.change_log);
      SharedPreferences prefs=getPreferences(MODE_PRIVATE);
      SharedPreferences.Editor editor=prefs.edit();
      editor.putBoolean(Constants.pref.has_seen_change_log,true);
      editor.commit();
    }
  }
);
  return alert.create();
}
default :
{
break;
}
}
return super.onCreateDialog(id);
}","@Override protected Dialog onCreateDialog(int id){
switch (id) {
case Id.dialog.new_account:
{
      AlertDialog.Builder alert=new AlertDialog.Builder(this);
      alert.setTitle(""String_Node_Str"");
      alert.setMessage(""String_Node_Str"");
      final EditText input=new EditText(this);
      alert.setView(input);
      alert.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int id){
          MainActivity.this.removeDialog(Id.dialog.new_account);
          String accountName=""String_Node_Str"" + input.getText();
          Cursor testCursor=managedQuery(Uri.parse(""String_Node_Str"" + accountName),null,null,null,null);
          if (testCursor == null) {
            Toast.makeText(MainActivity.this,""String_Node_Str"" + accountName + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
            return;
          }
          ContentValues values=new ContentValues();
          values.put(Accounts.NAME,accountName);
          try {
            MainActivity.this.getContentResolver().insert(Accounts.CONTENT_URI,values);
          }
 catch (          SQLException e) {
            Toast.makeText(MainActivity.this,""String_Node_Str"" + accountName + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
          }
        }
      }
);
      alert.setNegativeButton(android.R.string.cancel,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int id){
          MainActivity.this.removeDialog(Id.dialog.new_account);
        }
      }
);
      return alert.create();
    }
case Id.dialog.about:
{
    AlertDialog.Builder alert=new AlertDialog.Builder(this);
    alert.setTitle(""String_Node_Str"" + Apg.FULL_VERSION);
    ScrollView scrollView=new ScrollView(this);
    TextView message=new TextView(this);
    SpannableString info=new SpannableString(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    Linkify.addLinks(info,Linkify.WEB_URLS | Linkify.EMAIL_ADDRESSES);
    message.setMovementMethod(LinkMovementMethod.getInstance());
    message.setText(info);
    int padding=(int)(10 * getResources().getDisplayMetrics().densityDpi / 160);
    message.setPadding(padding,padding,padding,padding);
    message.setTextAppearance(this,android.R.style.TextAppearance_Medium);
    scrollView.addView(message);
    alert.setView(scrollView);
    alert.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int id){
        MainActivity.this.removeDialog(Id.dialog.about);
      }
    }
);
    return alert.create();
  }
case Id.dialog.change_log:
{
  AlertDialog.Builder alert=new AlertDialog.Builder(this);
  alert.setTitle(""String_Node_Str"" + Apg.FULL_VERSION);
  ScrollView scrollView=new ScrollView(this);
  TextView message=new TextView(this);
  SpannableString info=new SpannableString(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  message.setText(info);
  int padding=(int)(10 * getResources().getDisplayMetrics().densityDpi / 160);
  message.setPadding(padding,padding,padding,padding);
  message.setTextAppearance(this,android.R.style.TextAppearance_Medium);
  scrollView.addView(message);
  alert.setView(scrollView);
  alert.setCancelable(false);
  alert.setPositiveButton(android.R.string.ok,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      MainActivity.this.removeDialog(Id.dialog.change_log);
      SharedPreferences prefs=getPreferences(MODE_PRIVATE);
      SharedPreferences.Editor editor=prefs.edit();
      editor.putBoolean(Constants.pref.has_seen_change_log,true);
      editor.commit();
    }
  }
);
  return alert.create();
}
default :
{
break;
}
}
return super.onCreateDialog(id);
}",0.9954686382065348
8452,"public ValidationErrors(String name,Object entity,PersistentEntity<?,?> persistentEntity){
  this.name=name;
  this.entity=entity;
  this.persistentEntity=persistentEntity;
}","/** 
 * Creates a new   {@link ValidationErrors} instance for the given source object and {@link PersistentEntity}.
 * @param source the source object to gather validation errors on, must not be {@literal null}.
 * @param entity the {@link PersistentEntity} for the given source instance, must not be {@literal null}.
 */
public ValidationErrors(Object source,PersistentEntity<?,?> entity){
  super(source.getClass().getSimpleName());
  Assert.notNull(source,""String_Node_Str"");
  Assert.notNull(entity,""String_Node_Str"");
  Assert.isTrue(entity.getType().isInstance(source),""String_Node_Str"");
  this.entity=entity;
  this.accessor=entity.getPropertyAccessor(source);
}",0.1990521327014218
8453,"@Override public Object getFieldValue(String field){
  PersistentProperty<?> prop=persistentEntity != null ? persistentEntity.getPersistentProperty(field) : null;
  if (null == prop) {
    return null;
  }
  Method getter=prop.getGetter();
  if (null != getter) {
    return invokeMethod(getter,entity);
  }
  Field fld=prop.getField();
  if (null != fld) {
    return getField(fld,entity);
  }
  return null;
}","@Override public Object getFieldValue(String field){
  if (field.contains(""String_Node_Str"")) {
    return super.getFieldValue(field);
  }
  return accessor.getProperty(entity.getPersistentProperty(field));
}",0.2197092084006462
8454,"private Errors validate(String event,Object entity){
  if (entity == null) {
    return null;
  }
  Class<?> domainType=entity.getClass();
  PersistentEntities persistentEntities=persistentEntitiesFactory.getObject();
  Errors errors=new ValidationErrors(domainType.getSimpleName(),entity,persistentEntities.getPersistentEntity(domainType));
  for (  Validator v : getValidatorsForEvent(event)) {
    if (v.supports(domainType)) {
      LOGGER.debug(""String_Node_Str"",event,entity,v);
      ValidationUtils.invokeValidator(v,entity,errors);
    }
  }
  if (errors.hasErrors()) {
    throw new RepositoryConstraintViolationException(errors);
  }
  return errors;
}","private Errors validate(String event,Object entity){
  if (entity == null) {
    return null;
  }
  Class<?> domainType=entity.getClass();
  PersistentEntities persistentEntities=persistentEntitiesFactory.getObject();
  PersistentEntity<?,?> persistentEntity=persistentEntities.getPersistentEntity(domainType);
  Errors errors=persistentEntity == null ? new DirectFieldBindingResult(entity,domainType.getSimpleName()) : new ValidationErrors(entity,persistentEntity);
  for (  Validator v : getValidatorsForEvent(event)) {
    if (v.supports(domainType)) {
      LOGGER.debug(""String_Node_Str"",event,entity,v);
      ValidationUtils.invokeValidator(v,entity,errors);
    }
  }
  if (errors.hasErrors()) {
    throw new RepositoryConstraintViolationException(errors);
  }
  return errors;
}",0.7801516195727085
8455,"@Test(expected=RepositoryConstraintViolationException.class) public void shouldValidateLastName() throws Exception {
  context.publishEvent(new BeforeSaveEvent(new Person(""String_Node_Str"",""String_Node_Str"")));
}","@Test(expected=RepositoryConstraintViolationException.class) public void shouldValidateLastName() throws Exception {
  mappingContext.getPersistentEntity(Person.class);
  context.publishEvent(new BeforeSaveEvent(new Person(""String_Node_Str"",""String_Node_Str"")));
}",0.8907563025210085
8456,"public <T extends Throwable>ResponseEntity<ExceptionMessage> errorResponse(HttpHeaders headers,T throwable,HttpStatus status){
  LOG.error(throwable.getMessage(),throwable);
  return response(headers,new ExceptionMessage(throwable),status);
}","public <T extends Throwable>ResponseEntity<ExceptionMessage> errorResponse(HttpHeaders headers,T throwable,HttpStatus status){
  if (null != throwable && null != throwable.getMessage()) {
    LOG.error(throwable.getMessage(),throwable);
    return response(headers,new ExceptionMessage(throwable),status);
  }
 else {
    return response(headers,null,status);
  }
}",0.7973640856672158
8457,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseBody public ResponseEntity<?> deleteEntity(final RepositoryRestRequest repoRequest,@PathVariable final String id) throws ResourceNotFoundException {
  final RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (null == repoMethodInvoker || (!repoMethodInvoker.hasFindOne() && !(repoMethodInvoker.hasDeleteOne() || repoMethodInvoker.hasDeleteOneById()))) {
    throw new NoSuchMethodError();
  }
  final Object domainObj=domainClassConverter.convert(id,STRING_TYPE,TypeDescriptor.valueOf(repoRequest.getPersistentEntity().getType()));
  if (null == domainObj) {
    throw new ResourceNotFoundException();
  }
  applicationContext.publishEvent(new BeforeDeleteEvent(domainObj));
  TransactionCallbackWithoutResult callback=new TransactionCallbackWithoutResult(){
    @Override protected void doInTransactionWithoutResult(    TransactionStatus status){
      if (repoMethodInvoker.hasDeleteOneById()) {
        Class<? extends Serializable> idType=(Class<? extends Serializable>)repoRequest.getPersistentEntity().getIdProperty().getType();
        final Serializable idVal=conversionService.convert(id,idType);
        repoMethodInvoker.delete(idVal);
      }
 else       if (repoMethodInvoker.hasDeleteOne()) {
        repoMethodInvoker.delete(domainObj);
      }
    }
  }
;
  if (null != txTmpl) {
    txTmpl.execute(callback);
  }
 else {
    callback.doInTransaction(null);
  }
  applicationContext.publishEvent(new AfterDeleteEvent(domainObj));
  return new ResponseEntity<Object>(HttpStatus.NO_CONTENT);
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseBody public ResponseEntity<?> deleteEntity(final RepositoryRestRequest repoRequest,@PathVariable final String id) throws ResourceNotFoundException, HttpRequestMethodNotSupportedException {
  final RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (null == repoMethodInvoker || (!repoMethodInvoker.hasFindOne() && !(repoMethodInvoker.hasDeleteOne() || repoMethodInvoker.hasDeleteOneById()))) {
    throw new HttpRequestMethodNotSupportedException(""String_Node_Str"");
  }
  ResourceMapping methodMapping=repoRequest.getRepositoryResourceMapping().getResourceMappingFor(""String_Node_Str"");
  if (null != methodMapping && !methodMapping.isExported()) {
    throw new HttpRequestMethodNotSupportedException(""String_Node_Str"");
  }
  final Object domainObj=domainClassConverter.convert(id,STRING_TYPE,TypeDescriptor.valueOf(repoRequest.getPersistentEntity().getType()));
  if (null == domainObj) {
    throw new ResourceNotFoundException();
  }
  applicationContext.publishEvent(new BeforeDeleteEvent(domainObj));
  TransactionCallbackWithoutResult callback=new TransactionCallbackWithoutResult(){
    @Override protected void doInTransactionWithoutResult(    TransactionStatus status){
      if (repoMethodInvoker.hasDeleteOneById()) {
        Class<? extends Serializable> idType=(Class<? extends Serializable>)repoRequest.getPersistentEntity().getIdProperty().getType();
        final Serializable idVal=conversionService.convert(id,idType);
        repoMethodInvoker.delete(idVal);
      }
 else       if (repoMethodInvoker.hasDeleteOne()) {
        repoMethodInvoker.delete(domainObj);
      }
    }
  }
;
  if (null != txTmpl) {
    txTmpl.execute(callback);
  }
 else {
    callback.doInTransaction(null);
  }
  applicationContext.publishEvent(new AfterDeleteEvent(domainObj));
  return new ResponseEntity<Object>(HttpStatus.NO_CONTENT);
}",0.9010388190267906
8458,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @ResponseBody public ResponseEntity<Resource<?>> followPropertyReference(final RepositoryRestRequest repoRequest,@PathVariable String id,@PathVariable String property,final @PathVariable String propertyId) throws ResourceNotFoundException, NoSuchMethodException {
  final HttpHeaders headers=new HttpHeaders();
  Function<ReferencedProperty,Resource<?>> handler=new Function<ReferencedProperty,Resource<?>>(){
    @Override public Resource<?> apply(    ReferencedProperty prop){
      if (prop.property.isCollectionLike()) {
        PersistentEntity entity=repositories.getPersistentEntity(prop.propertyType);
        for (        Object obj : ((Iterable)prop.propertyValue)) {
          BeanWrapper propValWrapper=BeanWrapper.create(obj,conversionService);
          String sId=propValWrapper.getProperty(prop.entity.getIdProperty()).toString();
          if (propertyId.equals(sId)) {
            PersistentEntityResource per=PersistentEntityResource.wrap(entity,obj,repoRequest.getBaseUri());
            Link selfLink=entityLinks.linkForSingleResource(entity.getType(),sId).withSelfRel();
            per.add(selfLink);
            headers.set(""String_Node_Str"",selfLink.getHref());
            return per;
          }
        }
      }
 else       if (prop.property.isMap()) {
        PersistentEntity entity=repositories.getPersistentEntity(prop.propertyType);
        for (        Map.Entry<Object,Object> entry : ((Map<Object,Object>)prop.propertyValue).entrySet()) {
          BeanWrapper propValWrapper=BeanWrapper.create(entry.getValue(),conversionService);
          String sId=propValWrapper.getProperty(prop.entity.getIdProperty()).toString();
          if (propertyId.equals(sId)) {
            PersistentEntityResource per=PersistentEntityResource.wrap(entity,entry.getValue(),repoRequest.getBaseUri());
            Link selfLink=entityLinks.linkForSingleResource(entity.getType(),sId).withSelfRel();
            per.add(selfLink);
            headers.set(""String_Node_Str"",selfLink.getHref());
            return per;
          }
        }
      }
 else {
        return new Resource<Object>(prop.propertyValue);
      }
      throw new IllegalArgumentException(new ResourceNotFoundException());
    }
  }
;
  Resource<?> responseResource=doWithReferencedProperty(repoRequest,id,property,handler);
  return resourceResponse(headers,responseResource,HttpStatus.OK);
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @ResponseBody public ResponseEntity<Resource<?>> followPropertyReference(final RepositoryRestRequest repoRequest,@PathVariable String id,@PathVariable String property,final @PathVariable String propertyId) throws ResourceNotFoundException, NoSuchMethodException {
  final HttpHeaders headers=new HttpHeaders();
  Function<ReferencedProperty,Resource<?>> handler=new Function<ReferencedProperty,Resource<?>>(){
    @Override public Resource<?> apply(    ReferencedProperty prop){
      if (null == prop.propertyValue) {
        throw new ResourceNotFoundException();
      }
      if (prop.property.isCollectionLike()) {
        PersistentEntity entity=repositories.getPersistentEntity(prop.propertyType);
        for (        Object obj : ((Iterable)prop.propertyValue)) {
          BeanWrapper propValWrapper=BeanWrapper.create(obj,conversionService);
          String sId=propValWrapper.getProperty(prop.entity.getIdProperty()).toString();
          if (propertyId.equals(sId)) {
            PersistentEntityResource per=PersistentEntityResource.wrap(entity,obj,repoRequest.getBaseUri());
            Link selfLink=entityLinks.linkForSingleResource(entity.getType(),sId).withSelfRel();
            per.add(selfLink);
            headers.set(""String_Node_Str"",selfLink.getHref());
            return per;
          }
        }
      }
 else       if (prop.property.isMap()) {
        PersistentEntity entity=repositories.getPersistentEntity(prop.propertyType);
        for (        Map.Entry<Object,Object> entry : ((Map<Object,Object>)prop.propertyValue).entrySet()) {
          BeanWrapper propValWrapper=BeanWrapper.create(entry.getValue(),conversionService);
          String sId=propValWrapper.getProperty(prop.entity.getIdProperty()).toString();
          if (propertyId.equals(sId)) {
            PersistentEntityResource per=PersistentEntityResource.wrap(entity,entry.getValue(),repoRequest.getBaseUri());
            Link selfLink=entityLinks.linkForSingleResource(entity.getType(),sId).withSelfRel();
            per.add(selfLink);
            headers.set(""String_Node_Str"",selfLink.getHref());
            return per;
          }
        }
      }
 else {
        return new Resource<Object>(prop.propertyValue);
      }
      throw new IllegalArgumentException(new ResourceNotFoundException());
    }
  }
;
  Resource<?> responseResource=doWithReferencedProperty(repoRequest,id,property,handler);
  return resourceResponse(headers,responseResource,HttpStatus.OK);
}",0.9818598434218064
8459,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseBody public ResponseEntity<Resource<?>> deletePropertyReference(final RepositoryRestRequest repoRequest,@PathVariable String id,@PathVariable String property,final @PathVariable String propertyId) throws ResourceNotFoundException, NoSuchMethodException {
  final RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (!repoMethodInvoker.hasDeleteOne()) {
    throw new NoSuchMethodException();
  }
  Function<ReferencedProperty,Resource<?>> handler=new Function<ReferencedProperty,Resource<?>>(){
    @Override public Resource<?> apply(    ReferencedProperty prop){
      if (null == prop.propertyValue) {
        return null;
      }
      if (prop.property.isCollectionLike()) {
        Collection coll=new ArrayList();
        for (        Object obj : (Collection)prop.propertyValue) {
          BeanWrapper propValWrapper=BeanWrapper.create(obj,conversionService);
          String s=(String)propValWrapper.getProperty(prop.entity.getIdProperty(),String.class,false);
          if (!propertyId.equals(s)) {
            coll.add(obj);
          }
        }
        prop.wrapper.setProperty(prop.property,coll);
      }
 else       if (prop.property.isMap()) {
        Map m=new HashMap();
        for (        Map.Entry<Object,Object> entry : ((Map<Object,Object>)prop.propertyValue).entrySet()) {
          BeanWrapper propValWrapper=BeanWrapper.create(entry.getValue(),conversionService);
          String s=(String)propValWrapper.getProperty(prop.entity.getIdProperty(),String.class,false);
          if (!propertyId.equals(s)) {
            m.put(entry.getKey(),entry.getValue());
          }
        }
        prop.wrapper.setProperty(prop.property,m);
      }
 else {
        prop.wrapper.setProperty(prop.property,null);
      }
      applicationContext.publishEvent(new BeforeLinkDeleteEvent(prop.wrapper.getBean(),prop.propertyValue));
      Object result=repoMethodInvoker.save(prop.wrapper.getBean());
      applicationContext.publishEvent(new AfterLinkDeleteEvent(result,prop.propertyValue));
      return null;
    }
  }
;
  doWithReferencedProperty(repoRequest,id,property,handler);
  return resourceResponse(null,EMPTY_RESOURCE,HttpStatus.NO_CONTENT);
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(method=RequestMethod.DELETE) @ResponseBody public ResponseEntity<Resource<?>> deletePropertyReference(final RepositoryRestRequest repoRequest,@PathVariable String id,@PathVariable String property) throws ResourceNotFoundException, NoSuchMethodException, HttpRequestMethodNotSupportedException {
  final RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (!repoMethodInvoker.hasDeleteOne()) {
    throw new NoSuchMethodException();
  }
  Function<ReferencedProperty,Resource<?>> handler=new Function<ReferencedProperty,Resource<?>>(){
    @Override public Resource<?> apply(    ReferencedProperty prop){
      if (null == prop.propertyValue) {
        return null;
      }
      if (prop.property.isCollectionLike()) {
        throw new IllegalArgumentException(new HttpRequestMethodNotSupportedException(""String_Node_Str""));
      }
 else       if (prop.property.isMap()) {
        throw new IllegalArgumentException(new HttpRequestMethodNotSupportedException(""String_Node_Str""));
      }
 else {
        prop.wrapper.setProperty(prop.property,null);
      }
      applicationContext.publishEvent(new BeforeLinkDeleteEvent(prop.wrapper.getBean(),prop.propertyValue));
      Object result=repoMethodInvoker.save(prop.wrapper.getBean());
      applicationContext.publishEvent(new AfterLinkDeleteEvent(result,prop.propertyValue));
      return null;
    }
  }
;
  try {
    doWithReferencedProperty(repoRequest,id,property,handler);
  }
 catch (  IllegalArgumentException iae) {
    if (iae.getCause() instanceof HttpRequestMethodNotSupportedException) {
      throw (HttpRequestMethodNotSupportedException)iae.getCause();
    }
  }
  return resourceResponse(null,EMPTY_RESOURCE,HttpStatus.NO_CONTENT);
}",0.4235065565808645
8460,"@SuppressWarnings({""String_Node_Str""}) private Resource<?> doWithReferencedProperty(RepositoryRestRequest repoRequest,String id,String propertyPath,Function<ReferencedProperty,Resource<?>> handler) throws ResourceNotFoundException, NoSuchMethodException {
  RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (!repoMethodInvoker.hasFindOne()) {
    throw new NoSuchMethodException();
  }
  Object domainObj=domainClassConverter.convert(id,STRING_TYPE,TypeDescriptor.valueOf(repoRequest.getPersistentEntity().getType()));
  if (null == domainObj) {
    throw new ResourceNotFoundException();
  }
  String propertyName=repoRequest.getPersistentEntityResourceMapping().getNameForPath(propertyPath);
  PersistentProperty prop=repoRequest.getPersistentEntity().getPersistentProperty(propertyName);
  if (null == prop) {
    throw new ResourceNotFoundException();
  }
  BeanWrapper wrapper=BeanWrapper.create(domainObj,conversionService);
  Object propVal=wrapper.getProperty(prop);
  if (null == propVal) {
    throw new ResourceNotFoundException();
  }
  return handler.apply(new ReferencedProperty(prop,propVal,wrapper));
}","@SuppressWarnings({""String_Node_Str""}) private Resource<?> doWithReferencedProperty(RepositoryRestRequest repoRequest,String id,String propertyPath,Function<ReferencedProperty,Resource<?>> handler) throws ResourceNotFoundException, NoSuchMethodException {
  RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (!repoMethodInvoker.hasFindOne()) {
    throw new NoSuchMethodException();
  }
  Object domainObj=domainClassConverter.convert(id,STRING_TYPE,TypeDescriptor.valueOf(repoRequest.getPersistentEntity().getType()));
  if (null == domainObj) {
    throw new ResourceNotFoundException();
  }
  String propertyName=repoRequest.getPersistentEntityResourceMapping().getNameForPath(propertyPath);
  PersistentProperty prop=repoRequest.getPersistentEntity().getPersistentProperty(propertyName);
  if (null == prop) {
    throw new ResourceNotFoundException();
  }
  BeanWrapper wrapper=BeanWrapper.create(domainObj,conversionService);
  Object propVal=wrapper.getProperty(prop);
  return handler.apply(new ReferencedProperty(prop,propVal,wrapper));
}",0.9679144385026738
8461,"@SuppressWarnings({""String_Node_Str""}) @Override protected HandlerMethod lookupHandlerMethod(String lookupPath,HttpServletRequest origRequest) throws Exception {
  String acceptType=origRequest.getHeader(""String_Node_Str"");
  if (null == acceptType) {
    acceptType=config.getDefaultMediaType().toString();
  }
  List<MediaType> acceptHeaderTypes=MediaType.parseMediaTypes(acceptType);
  List<MediaType> acceptableTypes=new ArrayList<MediaType>();
  for (  MediaType mt : acceptHeaderTypes) {
    if ((""String_Node_Str"".equals(mt.getType()) && (""String_Node_Str"".equals(mt.getSubtype())) || (""String_Node_Str"".equals(mt.getType()) && ""String_Node_Str"".equals(mt.getSubtype())))) {
      mt=config.getDefaultMediaType();
    }
    if (!acceptableTypes.contains(mt)) {
      acceptableTypes.add(mt);
    }
  }
  if (acceptableTypes.size() > 1) {
    acceptType=collectionToDelimitedString(acceptableTypes,""String_Node_Str"");
  }
 else   if (acceptableTypes.size() == 1) {
    acceptType=acceptableTypes.get(0).toString();
  }
 else {
    acceptType=config.getDefaultMediaType().toString();
  }
  HttpServletRequest request=new DefaultAcceptTypeHttpServletRequest(origRequest,acceptType);
  if (acceptType.contains(""String_Node_Str"")) {
    if (null != request.getParameter(config.getJsonpParamName()) || null != request.getParameter(config.getJsonpOnErrParamName())) {
      return super.lookupHandlerMethod(lookupPath,request);
    }
 else {
      return null;
    }
  }
  String requestUri=lookupPath;
  if (requestUri.startsWith(""String_Node_Str"")) {
    requestUri=requestUri.substring(1);
  }
  if (!hasText(requestUri)) {
    return super.lookupHandlerMethod(lookupPath,request);
  }
  String[] parts=requestUri.split(""String_Node_Str"");
  if (parts.length == 0) {
    return super.lookupHandlerMethod(lookupPath,request);
  }
  for (  Class<?> domainType : repositories) {
    RepositoryInformation repoInfo=repositories.getRepositoryInformationFor(domainType);
    ResourceMapping mapping=getResourceMapping(config,repoInfo);
    if (mapping.getPath().equals(parts[0]) && mapping.isExported()) {
      return super.lookupHandlerMethod(lookupPath,request);
    }
  }
  return null;
}","@SuppressWarnings({""String_Node_Str""}) @Override protected HandlerMethod lookupHandlerMethod(String lookupPath,HttpServletRequest origRequest) throws Exception {
  String acceptType=origRequest.getHeader(""String_Node_Str"");
  if (null == acceptType) {
    acceptType=config.getDefaultMediaType().toString();
  }
  List<MediaType> acceptHeaderTypes=MediaType.parseMediaTypes(acceptType);
  List<MediaType> acceptableTypes=new ArrayList<MediaType>();
  for (  MediaType mt : acceptHeaderTypes) {
    if ((""String_Node_Str"".equals(mt.getType()) && (""String_Node_Str"".equals(mt.getSubtype())) || (""String_Node_Str"".equals(mt.getType()) && ""String_Node_Str"".equals(mt.getSubtype())))) {
      mt=config.getDefaultMediaType();
    }
    if (!acceptableTypes.contains(mt)) {
      acceptableTypes.add(mt);
    }
  }
  if (acceptableTypes.size() > 1) {
    acceptType=collectionToDelimitedString(acceptableTypes,""String_Node_Str"");
  }
 else   if (acceptableTypes.size() == 1) {
    acceptType=acceptableTypes.get(0).toString();
  }
 else {
    acceptType=config.getDefaultMediaType().toString();
  }
  HttpServletRequest request=new DefaultAcceptTypeHttpServletRequest(origRequest,acceptType);
  String requestUri=lookupPath;
  if (requestUri.startsWith(""String_Node_Str"")) {
    requestUri=requestUri.substring(1);
  }
  if (!hasText(requestUri)) {
    return super.lookupHandlerMethod(lookupPath,request);
  }
  String[] parts=requestUri.split(""String_Node_Str"");
  if (parts.length == 0) {
    return super.lookupHandlerMethod(lookupPath,request);
  }
  for (  Class<?> domainType : repositories) {
    RepositoryInformation repoInfo=repositories.getRepositoryInformationFor(domainType);
    ResourceMapping mapping=getResourceMapping(config,repoInfo);
    if (mapping.getPath().equals(parts[0]) && mapping.isExported()) {
      return super.lookupHandlerMethod(lookupPath,request);
    }
  }
  return null;
}",0.930630190522716
8462,"@SuppressWarnings({""String_Node_Str""}) public RepositoryMethodInvoker(Object repository,RepositoryInformation repoInfo){
  this.repository=repository;
  Class<?> repoType=repoInfo.getRepositoryInterface();
  doWithMethods(repoType,new MethodCallback(){
    @Override public void doWith(    Method method) throws IllegalArgumentException, IllegalAccessException {
      boolean exported=ResourceMappingUtils.findExported(method);
      if (!exported) {
        return;
      }
      String name=method.getName();
      int cardinality=method.getParameterTypes().length;
      Class<?> paramType=(cardinality == 1 ? method.getParameterTypes()[0] : null);
      boolean someMethod=(null != paramType && Iterable.class.isAssignableFrom(paramType));
      boolean byIdMethod=(null != paramType && paramType == Serializable.class);
      boolean sortable=(null != paramType && Sort.class.isAssignableFrom(paramType));
      boolean pageable=(null != paramType && Pageable.class.isAssignableFrom(paramType));
      RepositoryMethod repoMethod=new RepositoryMethod(method);
      if (""String_Node_Str"".equals(name) && someMethod) {
        saveSome=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        saveOne=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        findOne=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        exists=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name) && someMethod) {
        findSome=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name) && sortable) {
        findAllSorted=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name) && pageable) {
        findAllPaged=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        findAll=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        count=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name) && byIdMethod) {
        deleteOneById=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name) && someMethod) {
        deleteSome=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        deleteOne=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        deleteAll=repoMethod;
      }
 else {
        queryMethods.put(name,repoMethod);
      }
    }
  }
);
}","@SuppressWarnings({""String_Node_Str""}) public RepositoryMethodInvoker(Object repository,RepositoryInformation repoInfo){
  this.repository=repository;
  Class<?> repoType=repoInfo.getRepositoryInterface();
  doWithMethods(repoType,new MethodCallback(){
    @Override public void doWith(    Method method) throws IllegalArgumentException, IllegalAccessException {
      boolean exported=ResourceMappingUtils.findExported(method);
      if (!exported) {
        return;
      }
      String name=method.getName();
      int cardinality=method.getParameterTypes().length;
      Class<?> paramType=(cardinality == 1 ? method.getParameterTypes()[0] : null);
      boolean someMethod=(null != paramType && Iterable.class.isAssignableFrom(paramType));
      boolean byIdMethod=(null != paramType && paramType == Serializable.class);
      boolean sortable=(null != paramType && Sort.class.isAssignableFrom(paramType));
      boolean pageable=(null != paramType && Pageable.class.isAssignableFrom(paramType));
      RepositoryMethod repoMethod=new RepositoryMethod(method);
      if (""String_Node_Str"".equals(name) && someMethod) {
        saveSome=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        saveOne=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        findOne=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        exists=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name) && sortable) {
        findAllSorted=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name) && someMethod) {
        findSome=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name) && pageable) {
        findAllPaged=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        findAll=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        count=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name) && byIdMethod) {
        deleteOneById=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name) && someMethod) {
        deleteSome=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        deleteOne=repoMethod;
      }
 else       if (""String_Node_Str"".equals(name)) {
        deleteAll=repoMethod;
      }
 else {
        queryMethods.put(name,repoMethod);
      }
    }
  }
);
}",0.9885301614273576
8463,"@Override public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
  boolean exported=ResourceMappingUtils.findExported(method);
  if (!exported) {
    return;
  }
  String name=method.getName();
  int cardinality=method.getParameterTypes().length;
  Class<?> paramType=(cardinality == 1 ? method.getParameterTypes()[0] : null);
  boolean someMethod=(null != paramType && Iterable.class.isAssignableFrom(paramType));
  boolean byIdMethod=(null != paramType && paramType == Serializable.class);
  boolean sortable=(null != paramType && Sort.class.isAssignableFrom(paramType));
  boolean pageable=(null != paramType && Pageable.class.isAssignableFrom(paramType));
  RepositoryMethod repoMethod=new RepositoryMethod(method);
  if (""String_Node_Str"".equals(name) && someMethod) {
    saveSome=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    saveOne=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    findOne=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    exists=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name) && someMethod) {
    findSome=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name) && sortable) {
    findAllSorted=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name) && pageable) {
    findAllPaged=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    findAll=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    count=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name) && byIdMethod) {
    deleteOneById=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name) && someMethod) {
    deleteSome=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    deleteOne=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    deleteAll=repoMethod;
  }
 else {
    queryMethods.put(name,repoMethod);
  }
}","@Override public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
  boolean exported=ResourceMappingUtils.findExported(method);
  if (!exported) {
    return;
  }
  String name=method.getName();
  int cardinality=method.getParameterTypes().length;
  Class<?> paramType=(cardinality == 1 ? method.getParameterTypes()[0] : null);
  boolean someMethod=(null != paramType && Iterable.class.isAssignableFrom(paramType));
  boolean byIdMethod=(null != paramType && paramType == Serializable.class);
  boolean sortable=(null != paramType && Sort.class.isAssignableFrom(paramType));
  boolean pageable=(null != paramType && Pageable.class.isAssignableFrom(paramType));
  RepositoryMethod repoMethod=new RepositoryMethod(method);
  if (""String_Node_Str"".equals(name) && someMethod) {
    saveSome=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    saveOne=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    findOne=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    exists=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name) && sortable) {
    findAllSorted=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name) && someMethod) {
    findSome=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name) && pageable) {
    findAllPaged=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    findAll=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    count=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name) && byIdMethod) {
    deleteOneById=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name) && someMethod) {
    deleteSome=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    deleteOne=repoMethod;
  }
 else   if (""String_Node_Str"".equals(name)) {
    deleteAll=repoMethod;
  }
 else {
    queryMethods.put(name,repoMethod);
  }
}",0.9855460385438972
8464,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.PUT,consumes={""String_Node_Str""},produces={""String_Node_Str"",""String_Node_Str""}) @ResponseBody public ResponseEntity<Resource<?>> updateEntity(RepositoryRestRequest repoRequest,PersistentEntityResource<?> incoming,@PathVariable String id) throws ResourceNotFoundException {
  RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (null == repoMethodInvoker || !repoMethodInvoker.hasSaveOne() || !repoMethodInvoker.hasFindOne()) {
    throw new NoSuchMethodError();
  }
  Object domainObj=domainClassConverter.convert(id,STRING_TYPE,TypeDescriptor.valueOf(repoRequest.getPersistentEntity().getType()));
  if (null == domainObj) {
    BeanWrapper incomingWrapper=BeanWrapper.create(incoming.getContent(),conversionService);
    PersistentProperty idProp=incoming.getPersistentEntity().getIdProperty();
    incomingWrapper.setProperty(idProp,conversionService.convert(id,idProp.getType()));
    return createNewEntity(repoRequest,incoming);
  }
  domainObjectMerger.merge(incoming.getContent(),domainObj);
  applicationContext.publishEvent(new BeforeSaveEvent(incoming.getContent()));
  Object obj=repoMethodInvoker.save(domainObj);
  applicationContext.publishEvent(new AfterSaveEvent(obj));
  if (config.isReturnBodyOnUpdate()) {
    PersistentEntityResource per=PersistentEntityResource.wrap(repoRequest.getPersistentEntity(),obj,repoRequest.getBaseUri());
    BeanWrapper wrapper=BeanWrapper.create(obj,conversionService);
    Link selfLink=entityLinks.linkForSingleResource(repoRequest.getPersistentEntity().getType(),wrapper.getProperty(repoRequest.getPersistentEntity().getIdProperty())).withSelfRel();
    per.add(selfLink);
    return resourceResponse(null,per,HttpStatus.OK);
  }
 else {
    return resourceResponse(null,null,HttpStatus.NO_CONTENT);
  }
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.PUT,consumes={""String_Node_Str""},produces={""String_Node_Str"",""String_Node_Str""}) @ResponseBody @Transactional public ResponseEntity<Resource<?>> updateEntity(RepositoryRestRequest repoRequest,PersistentEntityResource<?> incoming,@PathVariable String id) throws ResourceNotFoundException {
  RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (null == repoMethodInvoker || !repoMethodInvoker.hasSaveOne() || !repoMethodInvoker.hasFindOne()) {
    throw new NoSuchMethodError();
  }
  Object domainObj=domainClassConverter.convert(id,STRING_TYPE,TypeDescriptor.valueOf(repoRequest.getPersistentEntity().getType()));
  if (null == domainObj) {
    BeanWrapper incomingWrapper=BeanWrapper.create(incoming.getContent(),conversionService);
    PersistentProperty idProp=incoming.getPersistentEntity().getIdProperty();
    incomingWrapper.setProperty(idProp,conversionService.convert(id,idProp.getType()));
    return createNewEntity(repoRequest,incoming);
  }
  domainObjectMerger.merge(incoming.getContent(),domainObj);
  applicationContext.publishEvent(new BeforeSaveEvent(incoming.getContent()));
  Object obj=repoMethodInvoker.save(domainObj);
  applicationContext.publishEvent(new AfterSaveEvent(obj));
  if (config.isReturnBodyOnUpdate()) {
    PersistentEntityResource per=PersistentEntityResource.wrap(repoRequest.getPersistentEntity(),obj,repoRequest.getBaseUri());
    BeanWrapper wrapper=BeanWrapper.create(obj,conversionService);
    Link selfLink=entityLinks.linkForSingleResource(repoRequest.getPersistentEntity().getType(),wrapper.getProperty(repoRequest.getPersistentEntity().getIdProperty())).withSelfRel();
    per.add(selfLink);
    return resourceResponse(null,per,HttpStatus.OK);
  }
 else {
    return resourceResponse(null,null,HttpStatus.NO_CONTENT);
  }
}",0.9960619585192964
8465,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(method=RequestMethod.GET,produces={""String_Node_Str"",""String_Node_Str""}) @ResponseBody public Resources<Resource<?>> listEntities(RepositoryRestRequest repoRequest) throws ResourceNotFoundException {
  List<Resource<?>> resources=new ArrayList<Resource<?>>();
  List<Link> links=new ArrayList<Link>();
  Iterable<?> results;
  RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (null == repoMethodInvoker) {
    throw new ResourceNotFoundException();
  }
  boolean hasPagingParams=(null != repoRequest.getRequest().getParameter(config.getPageParamName()));
  boolean hasSortParams=(null != repoRequest.getRequest().getParameter(config.getSortParamName()));
  if (repoMethodInvoker.hasFindAllPageable() && hasPagingParams) {
    results=repoMethodInvoker.findAll(new PageRequest(repoRequest.getPagingAndSorting().getPageNumber(),repoRequest.getPagingAndSorting().getPageSize(),repoRequest.getPagingAndSorting().getSort()));
  }
 else   if (repoMethodInvoker.hasFindAllSorted() && hasSortParams) {
    results=repoMethodInvoker.findAll(repoRequest.getPagingAndSorting().getSort());
  }
 else   if (repoMethodInvoker.hasFindAll()) {
    results=repoMethodInvoker.findAll();
  }
 else {
    throw new ResourceNotFoundException();
  }
  for (  Object o : results) {
    BeanWrapper wrapper=BeanWrapper.create(o,conversionService);
    Link selfLink=entityLinks.linkForSingleResource(repoRequest.getPersistentEntity().getType(),wrapper.getProperty(repoRequest.getPersistentEntity().getIdProperty())).withSelfRel();
    resources.add(new PersistentEntityResource<Object>(repoRequest.getPersistentEntity(),o,selfLink).setBaseUri(repoRequest.getBaseUri()));
  }
  if (!repoMethodInvoker.getQueryMethods().isEmpty()) {
    ResourceMapping repoMapping=repoRequest.getRepositoryResourceMapping();
    links.add(new Link(buildUri(repoRequest.getBaseUri(),repoMapping.getPath(),""String_Node_Str"").toString(),repoMapping.getRel() + ""String_Node_Str""));
  }
  return new Resources<Resource<?>>(resources,links);
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(method=RequestMethod.GET,produces={""String_Node_Str"",""String_Node_Str""}) @ResponseBody public Resources<Resource<?>> listEntities(final RepositoryRestRequest repoRequest) throws ResourceNotFoundException {
  List<Resource<?>> resources=new ArrayList<Resource<?>>();
  List<Link> links=new ArrayList<Link>();
  Iterable<?> results;
  RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (null == repoMethodInvoker) {
    throw new ResourceNotFoundException();
  }
  boolean hasPagingParams=(null != repoRequest.getRequest().getParameter(config.getPageParamName()));
  boolean hasSortParams=(null != repoRequest.getRequest().getParameter(config.getSortParamName()));
  if (repoMethodInvoker.hasFindAllPageable() && hasPagingParams) {
    results=repoMethodInvoker.findAll(new PageRequest(repoRequest.getPagingAndSorting().getPageNumber(),repoRequest.getPagingAndSorting().getPageSize(),repoRequest.getPagingAndSorting().getSort()));
  }
 else   if (repoMethodInvoker.hasFindAllSorted() && hasSortParams) {
    results=repoMethodInvoker.findAll(repoRequest.getPagingAndSorting().getSort());
  }
 else   if (repoMethodInvoker.hasFindAll()) {
    results=repoMethodInvoker.findAll();
  }
 else {
    throw new ResourceNotFoundException();
  }
  for (  Object o : results) {
    BeanWrapper wrapper=BeanWrapper.create(o,conversionService);
    Link selfLink=entityLinks.linkForSingleResource(repoRequest.getPersistentEntity().getType(),wrapper.getProperty(repoRequest.getPersistentEntity().getIdProperty())).withSelfRel();
    resources.add(new PersistentEntityResource<Object>(repoRequest.getPersistentEntity(),o,selfLink).setBaseUri(repoRequest.getBaseUri()));
  }
  if (!repoMethodInvoker.getQueryMethods().isEmpty()) {
    ResourceMapping repoMapping=repoRequest.getRepositoryResourceMapping();
    links.add(new Link(buildUri(repoRequest.getBaseUri(),repoMapping.getPath(),""String_Node_Str"").toString(),repoMapping.getRel() + ""String_Node_Str""));
  }
  if (hasPagingParams || hasSortParams) {
    PageRequest pr=new PageRequest(repoRequest.getPagingAndSorting().getPageNumber() + 1,repoRequest.getPagingAndSorting().getPageSize(),repoRequest.getPagingAndSorting().getSort()){
      @Override public int getOffset(){
        return super.getOffset() - repoRequest.getPagingAndSorting().getPageSize();
      }
    }
;
    return new PageableResources<Resource<?>>(resources,pr,links);
  }
 else {
    return new Resources<Resource<?>>(resources,links);
  }
}",0.8986194995685937
8466,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(method=RequestMethod.GET,produces={""String_Node_Str"",""String_Node_Str""}) @ResponseBody public Resources<Resource<?>> listEntitiesCompact(RepositoryRestRequest repoRequest) throws ResourceNotFoundException {
  Resources<Resource<?>> resources=listEntities(repoRequest);
  List<Link> links=new ArrayList<Link>(resources.getLinks());
  for (  Resource<?> resource : resources.getContent()) {
    PersistentEntityResource<?> persistentEntityResource=(PersistentEntityResource<?>)resource;
    links.add(resourceLink(repoRequest,persistentEntityResource));
  }
  return new Resources<Resource<?>>(EMPTY_RESOURCE_LIST,links);
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(method=RequestMethod.GET,produces={""String_Node_Str"",""String_Node_Str""}) @ResponseBody public Resources<Resource<?>> listEntitiesCompact(RepositoryRestRequest repoRequest) throws ResourceNotFoundException {
  Resources<Resource<?>> resources=listEntities(repoRequest);
  List<Link> links=new ArrayList<Link>(resources.getLinks());
  for (  Resource<?> resource : resources.getContent()) {
    PersistentEntityResource<?> persistentEntityResource=(PersistentEntityResource<?>)resource;
    links.add(resourceLink(repoRequest,persistentEntityResource));
  }
  boolean hasPagingParams=(null != repoRequest.getRequest().getParameter(config.getPageParamName()));
  boolean hasSortParams=(null != repoRequest.getRequest().getParameter(config.getSortParamName()));
  if (hasPagingParams || hasSortParams) {
    return new PageableResources<Resource<?>>(EMPTY_RESOURCE_LIST,repoRequest.getPagingAndSorting(),links);
  }
 else {
    return new Resources<Resource<?>>(EMPTY_RESOURCE_LIST,links);
  }
}",0.7851335656213705
8467,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(method=RequestMethod.POST,consumes={""String_Node_Str""},produces={""String_Node_Str"",""String_Node_Str""}) @ResponseBody public ResponseEntity<Resource<?>> createNewEntity(RepositoryRestRequest repoRequest,PersistentEntityResource<?> incoming){
  RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (null == repoMethodInvoker || !repoMethodInvoker.hasSaveOne()) {
    throw new NoSuchMethodError();
  }
  applicationContext.publishEvent(new BeforeCreateEvent(incoming.getContent()));
  Object obj=repoMethodInvoker.save(incoming.getContent());
  applicationContext.publishEvent(new AfterCreateEvent(obj));
  BeanWrapper wrapper=BeanWrapper.create(obj,conversionService);
  Link selfLink=entityLinks.linkForSingleResource(repoRequest.getPersistentEntity().getType(),wrapper.getProperty(repoRequest.getPersistentEntity().getIdProperty())).withSelfRel();
  HttpHeaders headers=new HttpHeaders();
  headers.setLocation(URI.create(selfLink.getHref()));
  if (config.isReturnBodyOnCreate()) {
    return resourceResponse(headers,new PersistentEntityResource<Object>(repoRequest.getPersistentEntity(),obj,selfLink).setBaseUri(repoRequest.getBaseUri()),HttpStatus.CREATED);
  }
 else {
    return resourceResponse(headers,null,HttpStatus.CREATED);
  }
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(method=RequestMethod.POST,consumes={""String_Node_Str""},produces={""String_Node_Str"",""String_Node_Str""}) @ResponseBody @Transactional public ResponseEntity<Resource<?>> createNewEntity(RepositoryRestRequest repoRequest,PersistentEntityResource<?> incoming){
  RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (null == repoMethodInvoker || !repoMethodInvoker.hasSaveOne()) {
    throw new NoSuchMethodError();
  }
  applicationContext.publishEvent(new BeforeCreateEvent(incoming.getContent()));
  Object obj=repoMethodInvoker.save(incoming.getContent());
  applicationContext.publishEvent(new AfterCreateEvent(obj));
  BeanWrapper wrapper=BeanWrapper.create(obj,conversionService);
  Link selfLink=entityLinks.linkForSingleResource(repoRequest.getPersistentEntity().getType(),wrapper.getProperty(repoRequest.getPersistentEntity().getIdProperty())).withSelfRel();
  HttpHeaders headers=new HttpHeaders();
  headers.setLocation(URI.create(selfLink.getHref()));
  if (config.isReturnBodyOnCreate()) {
    return resourceResponse(headers,new PersistentEntityResource<Object>(repoRequest.getPersistentEntity(),obj,selfLink).setBaseUri(repoRequest.getBaseUri()),HttpStatus.CREATED);
  }
 else {
    return resourceResponse(headers,null,HttpStatus.CREATED);
  }
}",0.9944050727340544
8468,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseBody public ResponseEntity<?> deleteEntity(RepositoryRestRequest repoRequest,@PathVariable String id) throws ResourceNotFoundException {
  RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (null == repoMethodInvoker || (!repoMethodInvoker.hasFindOne() && !(repoMethodInvoker.hasDeleteOne() || repoMethodInvoker.hasDeleteOneById()))) {
    throw new NoSuchMethodError();
  }
  Object domainObj=domainClassConverter.convert(id,STRING_TYPE,TypeDescriptor.valueOf(repoRequest.getPersistentEntity().getType()));
  if (null == domainObj) {
    throw new ResourceNotFoundException();
  }
  applicationContext.publishEvent(new BeforeDeleteEvent(domainObj));
  if (repoMethodInvoker.hasDeleteOneById()) {
    Class<? extends Serializable> idType=(Class<? extends Serializable>)repoRequest.getPersistentEntity().getIdProperty().getType();
    Object idVal=conversionService.convert(id,idType);
    repoMethodInvoker.delete((Serializable)idVal);
  }
 else   if (repoMethodInvoker.hasDeleteOne()) {
    repoMethodInvoker.delete(domainObj);
  }
  applicationContext.publishEvent(new AfterDeleteEvent(domainObj));
  return new ResponseEntity<Object>(HttpStatus.NO_CONTENT);
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseBody @Transactional public ResponseEntity<?> deleteEntity(RepositoryRestRequest repoRequest,@PathVariable String id) throws ResourceNotFoundException {
  RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (null == repoMethodInvoker || (!repoMethodInvoker.hasFindOne() && !(repoMethodInvoker.hasDeleteOne() || repoMethodInvoker.hasDeleteOneById()))) {
    throw new NoSuchMethodError();
  }
  Object domainObj=domainClassConverter.convert(id,STRING_TYPE,TypeDescriptor.valueOf(repoRequest.getPersistentEntity().getType()));
  if (null == domainObj) {
    throw new ResourceNotFoundException();
  }
  applicationContext.publishEvent(new BeforeDeleteEvent(domainObj));
  if (repoMethodInvoker.hasDeleteOneById()) {
    Class<? extends Serializable> idType=(Class<? extends Serializable>)repoRequest.getPersistentEntity().getIdProperty().getType();
    Object idVal=conversionService.convert(id,idType);
    repoMethodInvoker.delete((Serializable)idVal);
  }
 else   if (repoMethodInvoker.hasDeleteOne()) {
    repoMethodInvoker.delete(domainObj);
  }
  applicationContext.publishEvent(new AfterDeleteEvent(domainObj));
  return new ResponseEntity<Object>(HttpStatus.NO_CONTENT);
}",0.9943374858437146
8469,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseBody public ResponseEntity<Resource<?>> deletePropertyReference(final RepositoryRestRequest repoRequest,@PathVariable String id,@PathVariable String property,final @PathVariable String propertyId) throws ResourceNotFoundException, NoSuchMethodException {
  final RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (!repoMethodInvoker.hasDeleteOne()) {
    throw new NoSuchMethodException();
  }
  Function<ReferencedProperty,Resource<?>> handler=new Function<ReferencedProperty,Resource<?>>(){
    @Override public Resource<?> apply(    ReferencedProperty prop){
      if (null == prop.propertyValue) {
        return null;
      }
      if (prop.property.isCollectionLike()) {
        Collection coll=new ArrayList();
        for (        Object obj : (Collection)prop.propertyValue) {
          BeanWrapper propValWrapper=BeanWrapper.create(obj,conversionService);
          String s=(String)propValWrapper.getProperty(prop.entity.getIdProperty(),String.class,false);
          if (!propertyId.equals(s)) {
            coll.add(obj);
          }
        }
        prop.wrapper.setProperty(prop.property,coll);
      }
 else       if (prop.property.isMap()) {
        Map m=new HashMap();
        for (        Map.Entry<Object,Object> entry : ((Map<Object,Object>)prop.propertyValue).entrySet()) {
          BeanWrapper propValWrapper=BeanWrapper.create(entry.getValue(),conversionService);
          String s=(String)propValWrapper.getProperty(prop.entity.getIdProperty(),String.class,false);
          if (!propertyId.equals(s)) {
            m.put(entry.getKey(),entry.getValue());
          }
        }
        prop.wrapper.setProperty(prop.property,m);
      }
 else {
        prop.wrapper.setProperty(prop.property,null);
      }
      applicationContext.publishEvent(new BeforeLinkDeleteEvent(prop.wrapper.getBean(),prop.propertyValue));
      Object result=repoMethodInvoker.save(prop.wrapper.getBean());
      applicationContext.publishEvent(new AfterLinkDeleteEvent(result,prop.propertyValue));
      return null;
    }
  }
;
  doWithReferencedProperty(repoRequest,id,property,handler);
  return resourceResponse(null,EMPTY_RESOURCE,HttpStatus.NO_CONTENT);
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseBody @Transactional public ResponseEntity<Resource<?>> deletePropertyReference(final RepositoryRestRequest repoRequest,@PathVariable String id,@PathVariable String property,final @PathVariable String propertyId) throws ResourceNotFoundException, NoSuchMethodException {
  final RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (!repoMethodInvoker.hasDeleteOne()) {
    throw new NoSuchMethodException();
  }
  Function<ReferencedProperty,Resource<?>> handler=new Function<ReferencedProperty,Resource<?>>(){
    @Override public Resource<?> apply(    ReferencedProperty prop){
      if (null == prop.propertyValue) {
        return null;
      }
      if (prop.property.isCollectionLike()) {
        Collection coll=new ArrayList();
        for (        Object obj : (Collection)prop.propertyValue) {
          BeanWrapper propValWrapper=BeanWrapper.create(obj,conversionService);
          String s=(String)propValWrapper.getProperty(prop.entity.getIdProperty(),String.class,false);
          if (!propertyId.equals(s)) {
            coll.add(obj);
          }
        }
        prop.wrapper.setProperty(prop.property,coll);
      }
 else       if (prop.property.isMap()) {
        Map m=new HashMap();
        for (        Map.Entry<Object,Object> entry : ((Map<Object,Object>)prop.propertyValue).entrySet()) {
          BeanWrapper propValWrapper=BeanWrapper.create(entry.getValue(),conversionService);
          String s=(String)propValWrapper.getProperty(prop.entity.getIdProperty(),String.class,false);
          if (!propertyId.equals(s)) {
            m.put(entry.getKey(),entry.getValue());
          }
        }
        prop.wrapper.setProperty(prop.property,m);
      }
 else {
        prop.wrapper.setProperty(prop.property,null);
      }
      applicationContext.publishEvent(new BeforeLinkDeleteEvent(prop.wrapper.getBean(),prop.propertyValue));
      Object result=repoMethodInvoker.save(prop.wrapper.getBean());
      applicationContext.publishEvent(new AfterLinkDeleteEvent(result,prop.propertyValue));
      return null;
    }
  }
;
  doWithReferencedProperty(repoRequest,id,property,handler);
  return resourceResponse(null,EMPTY_RESOURCE,HttpStatus.NO_CONTENT);
}",0.9967831867896204
8470,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(method={RequestMethod.POST,RequestMethod.PUT},consumes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @ResponseBody public ResponseEntity<Resource<?>> createPropertyReference(final RepositoryRestRequest repoRequest,final @RequestBody Resource<Object> incoming,@PathVariable String id,@PathVariable String property) throws ResourceNotFoundException, NoSuchMethodException {
  final RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (!repoMethodInvoker.hasSaveOne()) {
    throw new NoSuchMethodException();
  }
  Function<ReferencedProperty,Resource<?>> handler=new Function<ReferencedProperty,Resource<?>>(){
    @Override public Resource<?> apply(    ReferencedProperty prop){
      if (prop.property.isCollectionLike()) {
        Collection coll=new ArrayList();
        if (""String_Node_Str"".equals(repoRequest.getRequest().getMethod())) {
          coll.addAll((Collection)prop.propertyValue);
        }
        for (        Link l : incoming.getLinks()) {
          Object propVal=loadPropertyValue(prop.propertyType,l.getHref());
          coll.add(propVal);
        }
        prop.wrapper.setProperty(prop.property,coll);
      }
 else       if (prop.property.isMap()) {
        Map m=new HashMap();
        if (""String_Node_Str"".equals(repoRequest.getRequest().getMethod())) {
          m.putAll((Map)prop.propertyValue);
        }
        for (        Link l : incoming.getLinks()) {
          Object propVal=loadPropertyValue(prop.propertyType,l.getHref());
          m.put(l.getRel(),propVal);
        }
        prop.wrapper.setProperty(prop.property,m);
      }
 else {
        if (""String_Node_Str"".equals(repoRequest.getRequest().getMethod())) {
          throw new IllegalStateException(""String_Node_Str"");
        }
        if (incoming.getLinks().size() != 1) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        Object propVal=loadPropertyValue(prop.propertyType,incoming.getLinks().get(0).getHref());
        prop.wrapper.setProperty(prop.property,propVal);
      }
      applicationContext.publishEvent(new BeforeLinkSaveEvent(prop.wrapper.getBean(),prop.propertyValue));
      Object result=repoMethodInvoker.save(prop.wrapper.getBean());
      applicationContext.publishEvent(new AfterLinkSaveEvent(result,prop.propertyValue));
      return null;
    }
  }
;
  doWithReferencedProperty(repoRequest,id,property,handler);
  return resourceResponse(null,EMPTY_RESOURCE,HttpStatus.CREATED);
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(method={RequestMethod.POST,RequestMethod.PUT},consumes={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) @ResponseBody @Transactional public ResponseEntity<Resource<?>> createPropertyReference(final RepositoryRestRequest repoRequest,final @RequestBody Resource<Object> incoming,@PathVariable String id,@PathVariable String property) throws ResourceNotFoundException, NoSuchMethodException {
  final RepositoryMethodInvoker repoMethodInvoker=repoRequest.getRepositoryMethodInvoker();
  if (!repoMethodInvoker.hasSaveOne()) {
    throw new NoSuchMethodException();
  }
  Function<ReferencedProperty,Resource<?>> handler=new Function<ReferencedProperty,Resource<?>>(){
    @Override public Resource<?> apply(    ReferencedProperty prop){
      if (prop.property.isCollectionLike()) {
        Collection coll=new ArrayList();
        if (""String_Node_Str"".equals(repoRequest.getRequest().getMethod())) {
          coll.addAll((Collection)prop.propertyValue);
        }
        for (        Link l : incoming.getLinks()) {
          Object propVal=loadPropertyValue(prop.propertyType,l.getHref());
          coll.add(propVal);
        }
        prop.wrapper.setProperty(prop.property,coll);
      }
 else       if (prop.property.isMap()) {
        Map m=new HashMap();
        if (""String_Node_Str"".equals(repoRequest.getRequest().getMethod())) {
          m.putAll((Map)prop.propertyValue);
        }
        for (        Link l : incoming.getLinks()) {
          Object propVal=loadPropertyValue(prop.propertyType,l.getHref());
          m.put(l.getRel(),propVal);
        }
        prop.wrapper.setProperty(prop.property,m);
      }
 else {
        if (""String_Node_Str"".equals(repoRequest.getRequest().getMethod())) {
          throw new IllegalStateException(""String_Node_Str"");
        }
        if (incoming.getLinks().size() != 1) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        Object propVal=loadPropertyValue(prop.propertyType,incoming.getLinks().get(0).getHref());
        prop.wrapper.setProperty(prop.property,propVal);
      }
      applicationContext.publishEvent(new BeforeLinkSaveEvent(prop.wrapper.getBean(),prop.propertyValue));
      Object result=repoMethodInvoker.save(prop.wrapper.getBean());
      applicationContext.publishEvent(new AfterLinkSaveEvent(result,prop.propertyValue));
      return null;
    }
  }
;
  doWithReferencedProperty(repoRequest,id,property,handler);
  return resourceResponse(null,EMPTY_RESOURCE,HttpStatus.CREATED);
}",0.9970628549050324
8471,"@Override public Object resolveArgument(MethodParameter parameter,ModelAndViewContainer mavContainer,NativeWebRequest webRequest,WebDataBinderFactory binderFactory) throws Exception {
  HttpServletRequest request=(HttpServletRequest)webRequest.getNativeRequest();
  PageRequest pr=null;
  for (  Annotation annotation : parameter.getParameterAnnotations()) {
    if (annotation instanceof PageableDefaults) {
      PageableDefaults defaults=(PageableDefaults)annotation;
      pr=new PageRequest(defaults.pageNumber(),defaults.value());
      break;
    }
  }
  if (null == pr) {
    int page=DEFAULT_PAGE;
    String sPage=request.getParameter(config.getPageParamName());
    if (StringUtils.hasText(sPage)) {
      try {
        page=Integer.parseInt(sPage);
      }
 catch (      NumberFormatException ignored) {
      }
    }
    int limit=config.getDefaultPageSize();
    String sLimit=request.getParameter(config.getLimitParamName());
    if (StringUtils.hasText(sLimit)) {
      try {
        limit=Math.min(Integer.parseInt(sLimit),config.getMaxPageSize());
      }
 catch (      NumberFormatException ignored) {
      }
    }
    Sort sort=null;
    List<Sort.Order> orders=new ArrayList<Sort.Order>();
    String[] orderValues=request.getParameterValues(config.getSortParamName());
    if (null != orderValues) {
      for (      String orderParam : orderValues) {
        String sortDir=request.getParameter(orderParam + ""String_Node_Str"");
        Sort.Direction dir=(null != sortDir ? Sort.Direction.valueOf(sortDir.toUpperCase()) : Sort.Direction.ASC);
        orders.add(new Sort.Order(dir,orderParam));
      }
      if (!orders.isEmpty()) {
        sort=new Sort(orders);
      }
    }
    if (null != sort) {
      pr=new PageRequest(page - 1,limit,sort);
    }
 else {
      pr=new PageRequest(page - 1,limit);
    }
  }
  return new PagingAndSorting(config,pr);
}","@Override public Object resolveArgument(MethodParameter parameter,ModelAndViewContainer mavContainer,NativeWebRequest webRequest,WebDataBinderFactory binderFactory) throws Exception {
  RepositoryInformation repoInfo=(RepositoryInformation)repoInfoResolver.resolveArgument(parameter,mavContainer,webRequest,binderFactory);
  ResourceMapping repoMapping=config.getResourceMappingForDomainType(repoInfo.getDomainType());
  HttpServletRequest request=(HttpServletRequest)webRequest.getNativeRequest();
  PageRequest pr=null;
  for (  Annotation annotation : parameter.getParameterAnnotations()) {
    if (annotation instanceof PageableDefaults) {
      PageableDefaults defaults=(PageableDefaults)annotation;
      pr=new PageRequest(defaults.pageNumber(),defaults.value());
      break;
    }
  }
  if (null == pr) {
    int page=DEFAULT_PAGE;
    String sPage=request.getParameter(config.getPageParamName());
    if (StringUtils.hasText(sPage)) {
      try {
        page=Integer.parseInt(sPage);
      }
 catch (      NumberFormatException ignored) {
      }
    }
    int limit=config.getDefaultPageSize();
    String sLimit=request.getParameter(config.getLimitParamName());
    if (StringUtils.hasText(sLimit)) {
      try {
        limit=Math.min(Integer.parseInt(sLimit),config.getMaxPageSize());
      }
 catch (      NumberFormatException ignored) {
      }
    }
    Sort sort=null;
    List<Sort.Order> orders=new ArrayList<Sort.Order>();
    String[] orderValues=request.getParameterValues(config.getSortParamName());
    if (null != orderValues) {
      for (      String orderParam : orderValues) {
        String name=repoMapping.getNameForPath(orderParam);
        String sortDir=request.getParameter(orderParam + ""String_Node_Str"");
        Sort.Direction dir=(null != sortDir ? Sort.Direction.valueOf(sortDir.toUpperCase()) : Sort.Direction.ASC);
        orders.add(new Sort.Order(dir,name));
      }
      if (!orders.isEmpty()) {
        sort=new Sort(orders);
      }
    }
    if (null != sort) {
      pr=new PageRequest(page - 1,limit,sort);
    }
 else {
      pr=new PageRequest(page - 1,limit);
    }
  }
  return new PagingAndSorting(config,pr);
}",0.9237977805178792
8472,"/** 
 * Retrieve a linked entity from a parent entity.
 * @param request
 * @param baseUri
 * @param repository
 * @param id
 * @param property
 * @param linkedId
 * @return
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method={RequestMethod.GET}) @ResponseBody public ResponseEntity<?> linkedEntity(ServletServerHttpRequest request,URI baseUri,@PathVariable String repository,@PathVariable String id,@PathVariable String property,@PathVariable String linkedId) throws IOException {
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  CrudRepository repo=repoMeta.repository();
  Serializable serId=stringToSerializable(id,(Class<? extends Serializable>)repoMeta.entityMetadata().idAttribute().type());
  if (!repo.exists(serId)) {
    return notFoundResponse(request);
  }
  AttributeMetadata attrMeta;
  if (null == (attrMeta=repoMeta.entityMetadata().attribute(property))) {
    return notFoundResponse(request);
  }
  RepositoryMetadata linkedRepoMeta;
  if (null == (linkedRepoMeta=repositoryMetadataFor(attrMeta))) {
    return notFoundResponse(request);
  }
  if (!linkedRepoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  CrudRepository linkedRepo=linkedRepoMeta.repository();
  Serializable sChildId=stringToSerializable(linkedId,(Class<? extends Serializable>)linkedRepoMeta.entityMetadata().idAttribute().type());
  Object linkedEntity;
  if (null == (linkedEntity=linkedRepo.findOne(sChildId))) {
    return notFoundResponse(request);
  }
  String propertyRel=repository + ""String_Node_Str"" + repoMeta.entityMetadata().type().getSimpleName()+ ""String_Node_Str""+ property;
  URI propertyPath=buildUri(baseUri,repository,id,property,linkedId);
  URI selfUri=buildUri(baseUri,linkedRepoMeta.name(),linkedId);
  Resource<?> r;
  if (conversionService.canConvert(linkedEntity.getClass(),Resource.class)) {
    r=conversionService.convert(linkedEntity,Resource.class);
  }
 else {
    r=new Resource<Object>(linkedEntity);
  }
  r.add(new Link(propertyPath.toString(),propertyRel));
  HttpHeaders headers=new HttpHeaders();
  headers.add(""String_Node_Str"",selfUri.toString());
  return negotiateResponse(request,HttpStatus.OK,headers,r);
}","/** 
 * Retrieve a linked entity from a parent entity.
 * @param request
 * @param baseUri
 * @param repository
 * @param id
 * @param property
 * @param linkedId
 * @return
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method={RequestMethod.GET}) @ResponseBody public ResponseEntity<?> linkedEntity(ServletServerHttpRequest request,URI baseUri,@PathVariable String repository,@PathVariable String id,@PathVariable String property,@PathVariable String linkedId) throws IOException {
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  CrudRepository repo=repoMeta.repository();
  Serializable serId=stringToSerializable(id,(Class<? extends Serializable>)repoMeta.entityMetadata().idAttribute().type());
  if (!repo.exists(serId)) {
    return notFoundResponse(request);
  }
  AttributeMetadata attrMeta;
  if (null == (attrMeta=repoMeta.entityMetadata().attribute(property))) {
    return notFoundResponse(request);
  }
  RepositoryMetadata linkedRepoMeta;
  if (null == (linkedRepoMeta=repositoryMetadataFor(attrMeta))) {
    return notFoundResponse(request);
  }
  if (!linkedRepoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  CrudRepository linkedRepo=linkedRepoMeta.repository();
  Serializable sChildId=stringToSerializable(linkedId,(Class<? extends Serializable>)linkedRepoMeta.entityMetadata().idAttribute().type());
  Object linkedEntity;
  if (null == (linkedEntity=linkedRepo.findOne(sChildId))) {
    return notFoundResponse(request);
  }
  String propertyRel=repoMeta.rel() + ""String_Node_Str"" + repoMeta.entityMetadata().type().getSimpleName()+ ""String_Node_Str""+ property;
  URI propertyPath=buildUri(baseUri,repository,id,property,linkedId);
  URI selfUri=buildUri(baseUri,linkedRepoMeta.name(),linkedId);
  Resource<?> r;
  if (conversionService.canConvert(linkedEntity.getClass(),Resource.class)) {
    r=conversionService.convert(linkedEntity,Resource.class);
  }
 else {
    r=new Resource<Object>(linkedEntity);
  }
  r.add(new Link(propertyPath.toString(),propertyRel));
  HttpHeaders headers=new HttpHeaders();
  headers.add(""String_Node_Str"",selfUri.toString());
  return negotiateResponse(request,HttpStatus.OK,headers,r);
}",0.9967545638945232
8473,"@SuppressWarnings({""String_Node_Str""}) private ResourceDeserializer(PersistentEntity persistentEntity){
  super(persistentEntity.getType());
  this.persistentEntity=persistentEntity;
  this.defaultObject=instantiateClass(getValueClass());
  final BeanWrapper wrapper=BeanWrapper.create(defaultObject,conversionService);
  persistentEntity.doWithProperties(new PropertyHandler(){
    @Override public void doWithPersistentProperty(    PersistentProperty prop){
      Object defaultValue=wrapper.getProperty(prop);
      if (null != defaultValue) {
        defaultValues.put(prop.getName(),defaultValue);
      }
    }
  }
);
}","@SuppressWarnings({""String_Node_Str""}) private ResourceDeserializer(final PersistentEntity persistentEntity){
  super(persistentEntity.getType());
  this.persistentEntity=persistentEntity;
}",0.4515337423312883
8474,"@SuppressWarnings({""String_Node_Str""}) @Override public T deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException, JsonProcessingException {
  Object entity=instantiateClass(getValueClass());
  BeanWrapper wrapper=BeanWrapper.create(entity,conversionService);
  ResourceMapping domainMapping=config.getResourceMappingForDomainType(getValueClass());
  for (JsonToken tok=jp.nextToken(); tok != JsonToken.END_OBJECT; tok=jp.nextToken()) {
    String name=jp.getCurrentName();
switch (tok) {
case FIELD_NAME:
{
        if (""String_Node_Str"".equals(name)) {
          URI uri=URI.create(jp.nextTextValue());
          TypeDescriptor entityType=TypeDescriptor.forObject(entity);
          if (uriDomainClassConverter.matches(URI_TYPE,entityType)) {
            entity=uriDomainClassConverter.convert(uri,URI_TYPE,entityType);
          }
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          continue;
        }
        PersistentProperty persistentProperty=persistentEntity.getPersistentProperty(name);
        if (null == persistentProperty) {
          String errMsg=""String_Node_Str"" + name + ""String_Node_Str""+ getValueClass().getName();
          if (null == domainMapping) {
            throw new HttpMessageNotReadableException(errMsg);
          }
          String propertyName=domainMapping.getNameForPath(name);
          if (null == propertyName) {
            throw new HttpMessageNotReadableException(errMsg);
          }
          persistentProperty=persistentEntity.getPersistentProperty(propertyName);
          if (null == persistentProperty) {
            throw new HttpMessageNotReadableException(errMsg);
          }
        }
        Object val=null;
        if (""String_Node_Str"".equals(name)) {
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
            }
          }
 else           if (tok == JsonToken.VALUE_NULL) {
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"");
          }
          continue;
        }
        if (null == persistentProperty) {
          continue;
        }
        if (persistentProperty.isCollectionLike()) {
          Class<? extends Collection> ctype=(Class<? extends Collection>)persistentProperty.getType();
          Collection c=(Collection)wrapper.getProperty(persistentProperty,ctype,false);
          if (null == c || c == Collections.EMPTY_LIST || c == Collections.EMPTY_SET) {
            if (Collection.class.isAssignableFrom(ctype)) {
              c=new ArrayList();
            }
 else             if (Set.class.isAssignableFrom(ctype)) {
              c=new HashSet();
            }
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
              Object cval=jp.readValueAs(persistentProperty.getComponentType());
              c.add(cval);
            }
            val=c;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (persistentProperty.isMap()) {
          Class<? extends Map> mtype=(Class<? extends Map>)persistentProperty.getType();
          Map m=(Map)wrapper.getProperty(persistentProperty,mtype,false);
          if (null == m || m == Collections.EMPTY_MAP) {
            m=new HashMap();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_OBJECT) {
            do {
              name=jp.getCurrentName();
              tok=jp.nextToken();
              Object mval=jp.readValueAs(persistentProperty.getMapValueType());
              m.put(name,mval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_OBJECT);
            val=m;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else {
          if ((tok=jp.nextToken()) != JsonToken.VALUE_NULL) {
            val=jp.readValueAs(persistentProperty.getType());
          }
        }
        if (null != val) {
          Object defaultValue=defaultValues.get(persistentProperty.getName());
          if (null == defaultValue || defaultValue != val) {
            wrapper.setProperty(persistentProperty,val,false);
          }
        }
        break;
      }
  }
}
return (T)entity;
}","@SuppressWarnings({""String_Node_Str""}) @Override public T deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException, JsonProcessingException {
  Object entity=instantiateClass(getValueClass());
  BeanWrapper wrapper=BeanWrapper.create(entity,conversionService);
  ResourceMapping domainMapping=config.getResourceMappingForDomainType(getValueClass());
  for (JsonToken tok=jp.nextToken(); tok != JsonToken.END_OBJECT; tok=jp.nextToken()) {
    String name=jp.getCurrentName();
switch (tok) {
case FIELD_NAME:
{
        if (""String_Node_Str"".equals(name)) {
          URI uri=URI.create(jp.nextTextValue());
          TypeDescriptor entityType=TypeDescriptor.forObject(entity);
          if (uriDomainClassConverter.matches(URI_TYPE,entityType)) {
            entity=uriDomainClassConverter.convert(uri,URI_TYPE,entityType);
          }
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          continue;
        }
        PersistentProperty persistentProperty=persistentEntity.getPersistentProperty(name);
        if (null == persistentProperty) {
          String errMsg=""String_Node_Str"" + name + ""String_Node_Str""+ getValueClass().getName();
          if (null == domainMapping) {
            throw new HttpMessageNotReadableException(errMsg);
          }
          String propertyName=domainMapping.getNameForPath(name);
          if (null == propertyName) {
            throw new HttpMessageNotReadableException(errMsg);
          }
          persistentProperty=persistentEntity.getPersistentProperty(propertyName);
          if (null == persistentProperty) {
            throw new HttpMessageNotReadableException(errMsg);
          }
        }
        Object val=null;
        if (""String_Node_Str"".equals(name)) {
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
            }
          }
 else           if (tok == JsonToken.VALUE_NULL) {
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"");
          }
          continue;
        }
        if (null == persistentProperty) {
          continue;
        }
        if (persistentProperty.isCollectionLike()) {
          Class<? extends Collection> ctype=(Class<? extends Collection>)persistentProperty.getType();
          Collection c=(Collection)wrapper.getProperty(persistentProperty,ctype,false);
          if (null == c || c == Collections.EMPTY_LIST || c == Collections.EMPTY_SET) {
            if (Collection.class.isAssignableFrom(ctype)) {
              c=new ArrayList();
            }
 else             if (Set.class.isAssignableFrom(ctype)) {
              c=new HashSet();
            }
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
              Object cval=jp.readValueAs(persistentProperty.getComponentType());
              c.add(cval);
            }
            val=c;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (persistentProperty.isMap()) {
          Class<? extends Map> mtype=(Class<? extends Map>)persistentProperty.getType();
          Map m=(Map)wrapper.getProperty(persistentProperty,mtype,false);
          if (null == m || m == Collections.EMPTY_MAP) {
            m=new HashMap();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_OBJECT) {
            do {
              name=jp.getCurrentName();
              tok=jp.nextToken();
              Object mval=jp.readValueAs(persistentProperty.getMapValueType());
              m.put(name,mval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_OBJECT);
            val=m;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else {
          if ((tok=jp.nextToken()) != JsonToken.VALUE_NULL) {
            val=jp.readValueAs(persistentProperty.getType());
          }
        }
        wrapper.setProperty(persistentProperty,val,false);
        break;
      }
  }
}
return (T)entity;
}",0.9719772245171374
8475,"@SuppressWarnings({""String_Node_Str""}) public void merge(Object from,Object target){
  if (null == from || null == target) {
    return;
  }
  final BeanWrapper fromWrapper=BeanWrapper.create(from,conversionService);
  final BeanWrapper targetWrapper=BeanWrapper.create(target,conversionService);
  PersistentEntity entity=getPerisistentEntity(target.getClass());
  Class<?> clazz=entity.getType();
  final String clazzName=clazz.getSimpleName();
  entity.doWithProperties(new PropertyHandler(){
    @Override public void doWithPersistentProperty(    PersistentProperty persistentProperty){
      String mapKey=clazzName + ""String_Node_Str"" + persistentProperty.getName();
      Object fromVal=fromWrapper.getProperty(persistentProperty);
      Object defaultVal=defaultValues.get(mapKey);
      if (null != fromVal && !fromVal.equals(defaultVal)) {
        targetWrapper.setProperty(persistentProperty,fromVal);
      }
    }
  }
);
  entity.doWithAssociations(new AssociationHandler(){
    @Override public void doWithAssociation(    Association association){
      PersistentProperty persistentProperty=association.getInverse();
      String mapKey=clazzName + ""String_Node_Str"" + persistentProperty.getName();
      Object fromVal=fromWrapper.getProperty(persistentProperty);
      Object defaultVal=defaultValues.get(mapKey);
      if (null != fromVal && !fromVal.equals(defaultVal)) {
        targetWrapper.setProperty(persistentProperty,fromVal);
      }
    }
  }
);
}","@SuppressWarnings({""String_Node_Str""}) public void merge(Object from,Object target){
  if (null == from || null == target) {
    return;
  }
  final BeanWrapper fromWrapper=BeanWrapper.create(from,conversionService);
  final BeanWrapper targetWrapper=BeanWrapper.create(target,conversionService);
  PersistentEntity entity=repositories.getPersistentEntity(target.getClass());
  entity.doWithProperties(new PropertyHandler(){
    @Override public void doWithPersistentProperty(    PersistentProperty persistentProperty){
      Object fromVal=fromWrapper.getProperty(persistentProperty);
      if (null != fromVal && !fromVal.equals(targetWrapper.getProperty(persistentProperty))) {
        targetWrapper.setProperty(persistentProperty,fromVal);
      }
    }
  }
);
  entity.doWithAssociations(new AssociationHandler(){
    @Override public void doWithAssociation(    Association association){
      PersistentProperty persistentProperty=association.getInverse();
      Object fromVal=fromWrapper.getProperty(persistentProperty);
      if (null != fromVal && !fromVal.equals(targetWrapper.getProperty(persistentProperty))) {
        targetWrapper.setProperty(persistentProperty,fromVal);
      }
    }
  }
);
}",0.492364990689013
8476,"@Override public void doWithPersistentProperty(PersistentProperty persistentProperty){
  Object val=wrapper.getProperty(persistentProperty);
  if (null != val) {
    defaultValues.put(clazzName + ""String_Node_Str"" + persistentProperty.getName(),val);
  }
}","@Override public void doWithPersistentProperty(PersistentProperty persistentProperty){
  Object fromVal=fromWrapper.getProperty(persistentProperty);
  if (null != fromVal && !fromVal.equals(targetWrapper.getProperty(persistentProperty))) {
    targetWrapper.setProperty(persistentProperty,fromVal);
  }
}",0.6071428571428571
8477,"@Override public void doWithAssociation(Association association){
  PersistentProperty persistentProperty=association.getInverse();
  Object val=wrapper.getProperty(persistentProperty);
  if (null != val) {
    defaultValues.put(clazzName + ""String_Node_Str"" + persistentProperty.getName(),val);
  }
}","@Override public void doWithAssociation(Association association){
  PersistentProperty persistentProperty=association.getInverse();
  Object fromVal=fromWrapper.getProperty(persistentProperty);
  if (null != fromVal && !fromVal.equals(targetWrapper.getProperty(persistentProperty))) {
    targetWrapper.setProperty(persistentProperty,fromVal);
  }
}",0.6676923076923077
8478,"@Override protected boolean supportsInternal(HandlerMethod handlerMethod){
  Class<?> controllerType=handlerMethod.getBeanType();
  return super.supportsInternal(handlerMethod) && (RepositoryController.class.isAssignableFrom(controllerType) || RepositoryEntityController.class.isAssignableFrom(controllerType) || RepositoryPropertyReferenceController.class.isAssignableFrom(controllerType)|| RepositorySearchController.class.isAssignableFrom(controllerType));
}","@Override protected boolean supportsInternal(HandlerMethod handlerMethod){
  Class<?> controllerType=handlerMethod.getBeanType();
  return (RepositoryController.class.isAssignableFrom(controllerType) || RepositoryEntityController.class.isAssignableFrom(controllerType) || RepositoryPropertyReferenceController.class.isAssignableFrom(controllerType)|| RepositorySearchController.class.isAssignableFrom(controllerType));
}",0.9534619750283768
8479,"@SuppressWarnings({""String_Node_Str""}) @Override protected HandlerMethod lookupHandlerMethod(String lookupPath,HttpServletRequest origRequest) throws Exception {
  String acceptType=origRequest.getHeader(""String_Node_Str"");
  List<MediaType> acceptHeaderTypes=MediaType.parseMediaTypes(acceptType);
  List<MediaType> acceptableTypes=new ArrayList<MediaType>();
  for (  MediaType mt : acceptHeaderTypes) {
    if ((""String_Node_Str"".equals(mt.getType()) && (""String_Node_Str"".equals(mt.getSubtype())) || (""String_Node_Str"".equals(mt.getType()) && ""String_Node_Str"".equals(mt.getSubtype())))) {
      mt=config.getDefaultMediaType();
    }
    if (!acceptableTypes.contains(mt)) {
      acceptableTypes.add(mt);
    }
  }
  if (acceptableTypes.size() > 1) {
    acceptType=collectionToDelimitedString(acceptableTypes,""String_Node_Str"");
  }
 else   if (acceptableTypes.size() == 1) {
    acceptType=acceptableTypes.get(0).toString();
  }
 else {
    acceptType=config.getDefaultMediaType().toString();
  }
  HttpServletRequest request=new DefaultAcceptTypeHttpServletRequest(origRequest,acceptType);
  if (acceptType.contains(""String_Node_Str"")) {
    if (null != request.getParameter(config.getJsonpParamName()) || null != request.getParameter(config.getJsonpOnErrParamName())) {
      return super.lookupHandlerMethod(lookupPath,request);
    }
 else {
      return null;
    }
  }
  String requestUri=lookupPath;
  if (requestUri.startsWith(""String_Node_Str"")) {
    requestUri=requestUri.substring(1);
  }
  if (!hasText(requestUri)) {
    return super.lookupHandlerMethod(lookupPath,request);
  }
  String[] parts=requestUri.split(""String_Node_Str"");
  if (parts.length == 0) {
    return super.lookupHandlerMethod(lookupPath,request);
  }
  for (  Class<?> domainType : repositories) {
    RepositoryInformation repoInfo=repositories.getRepositoryInformationFor(domainType);
    ResourceMapping mapping=getResourceMapping(config,repoInfo);
    if (mapping.getPath().equals(parts[0]) && mapping.isExported()) {
      return super.lookupHandlerMethod(lookupPath,request);
    }
  }
  return null;
}","@SuppressWarnings({""String_Node_Str""}) @Override protected HandlerMethod lookupHandlerMethod(String lookupPath,HttpServletRequest origRequest) throws Exception {
  String acceptType=origRequest.getHeader(""String_Node_Str"");
  if (null == acceptType) {
    acceptType=config.getDefaultMediaType().toString();
  }
  List<MediaType> acceptHeaderTypes=MediaType.parseMediaTypes(acceptType);
  List<MediaType> acceptableTypes=new ArrayList<MediaType>();
  for (  MediaType mt : acceptHeaderTypes) {
    if ((""String_Node_Str"".equals(mt.getType()) && (""String_Node_Str"".equals(mt.getSubtype())) || (""String_Node_Str"".equals(mt.getType()) && ""String_Node_Str"".equals(mt.getSubtype())))) {
      mt=config.getDefaultMediaType();
    }
    if (!acceptableTypes.contains(mt)) {
      acceptableTypes.add(mt);
    }
  }
  if (acceptableTypes.size() > 1) {
    acceptType=collectionToDelimitedString(acceptableTypes,""String_Node_Str"");
  }
 else   if (acceptableTypes.size() == 1) {
    acceptType=acceptableTypes.get(0).toString();
  }
 else {
    acceptType=config.getDefaultMediaType().toString();
  }
  HttpServletRequest request=new DefaultAcceptTypeHttpServletRequest(origRequest,acceptType);
  if (acceptType.contains(""String_Node_Str"")) {
    if (null != request.getParameter(config.getJsonpParamName()) || null != request.getParameter(config.getJsonpOnErrParamName())) {
      return super.lookupHandlerMethod(lookupPath,request);
    }
 else {
      return null;
    }
  }
  String requestUri=lookupPath;
  if (requestUri.startsWith(""String_Node_Str"")) {
    requestUri=requestUri.substring(1);
  }
  if (!hasText(requestUri)) {
    return super.lookupHandlerMethod(lookupPath,request);
  }
  String[] parts=requestUri.split(""String_Node_Str"");
  if (parts.length == 0) {
    return super.lookupHandlerMethod(lookupPath,request);
  }
  for (  Class<?> domainType : repositories) {
    RepositoryInformation repoInfo=repositories.getRepositoryInformationFor(domainType);
    ResourceMapping mapping=getResourceMapping(config,repoInfo);
    if (mapping.getPath().equals(parts[0]) && mapping.isExported()) {
      return super.lookupHandlerMethod(lookupPath,request);
    }
  }
  return null;
}",0.9794871794871794
8480,"@SuppressWarnings({""String_Node_Str""}) @Override public Resource convert(Object source){
  if (null == repositoryMetadata || null == source) {
    return new Resource<Object>(source);
  }
  Serializable id=(Serializable)repositoryMetadata.entityMetadata().idAttribute().get(source);
  URI selfUri=buildUri(config.getBaseUri(),repositoryMetadata.name(),id.toString());
  Set<Link> links=new HashSet<Link>();
  for (  Object attrName : entityMetadata.linkedAttributes().keySet()) {
    URI uri=buildUri(selfUri,attrName.toString());
    String rel=repositoryMetadata.rel() + ""String_Node_Str"" + source.getClass().getSimpleName()+ ""String_Node_Str""+ attrName;
    links.add(new Link(uri.toString(),rel));
  }
  links.add(new Link(selfUri.toString(),""String_Node_Str""));
  Map<String,Object> entityDto=new HashMap<String,Object>();
  for (  Map.Entry<String,AttributeMetadata> attrMeta : ((Map<String,AttributeMetadata>)entityMetadata.embeddedAttributes()).entrySet()) {
    String name=attrMeta.getKey();
    Object val;
    if (null != (val=attrMeta.getValue().get(source))) {
      entityDto.put(name,val);
    }
  }
  return new EntityResource(entityDto,links);
}","@SuppressWarnings({""String_Node_Str""}) @Override public Resource convert(Object source){
  if (null == repositoryMetadata || null == source) {
    return new Resource<Object>(source);
  }
  Serializable id=(Serializable)repositoryMetadata.entityMetadata().idAttribute().get(source);
  URI selfUri=buildUri(config.getBaseUri(),repositoryMetadata.name(),String.format(""String_Node_Str"",id));
  Set<Link> links=new HashSet<Link>();
  for (  Object attrName : entityMetadata.linkedAttributes().keySet()) {
    URI uri=buildUri(selfUri,attrName.toString());
    String rel=repositoryMetadata.rel() + ""String_Node_Str"" + source.getClass().getSimpleName()+ ""String_Node_Str""+ attrName;
    links.add(new Link(uri.toString(),rel));
  }
  links.add(new Link(selfUri.toString(),""String_Node_Str""));
  Map<String,Object> entityDto=new HashMap<String,Object>();
  for (  Map.Entry<String,AttributeMetadata> attrMeta : ((Map<String,AttributeMetadata>)entityMetadata.embeddedAttributes()).entrySet()) {
    String name=attrMeta.getKey();
    Object val;
    if (null != (val=attrMeta.getValue().get(source))) {
      entityDto.put(name,val);
    }
  }
  return new EntityResource(entityDto,links);
}",0.9804088586030664
8481,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public ResponseEntity<?> schemaForRepository(ServletServerHttpRequest request,URI baseUri,@PathVariable String repository) throws IOException {
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (null == repoMeta) {
    throw new IllegalArgumentException(""String_Node_Str"" + repository + ""String_Node_Str"");
  }
  JsonSchema schema=mapper.generateJsonSchema(repoMeta.domainType());
  URI requestUri=UriComponentsBuilder.fromUri(baseUri).path(repository).build().toUri();
  Resource<JsonSchema> resource=new Resource<JsonSchema>(schema,new Link(request.getURI().toString(),""String_Node_Str""),new Link(requestUri.toString(),repoMeta.rel()));
  String output=mapper.writeValueAsString(resource);
  return new ResponseEntity<String>(output,HttpStatus.OK);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public ResponseEntity<?> schemaForRepository(URI baseUri,@PathVariable String repository) throws IOException {
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (null == repoMeta) {
    return new ResponseEntity<Object>(HttpStatus.NOT_FOUND);
  }
  JsonSchema schema=mapper.generateJsonSchema(repoMeta.domainType());
  URI schemaUri=UriComponentsBuilder.fromUri(baseUri).pathSegment(repository,""String_Node_Str"").build().toUri();
  URI requestUri=UriComponentsBuilder.fromUri(baseUri).pathSegment(repository).build().toUri();
  Resource<JsonSchema> resource=new Resource<JsonSchema>(schema,new Link(schemaUri.toString(),""String_Node_Str""),new Link(requestUri.toString(),repoMeta.rel()));
  String output=mapper.writeValueAsString(resource);
  return new ResponseEntity<String>(output,HttpStatus.OK);
}",0.5688987271721084
8482,"private Errors validate(String event,Object o){
  Errors errors=null;
  if (null != o) {
    Class<?> domainType=o.getClass();
    errors=new ValidationErrors(domainType.getSimpleName(),o,repositoryMetadataFor(domainType).entityMetadata());
    String eventName=null;
    if (""String_Node_Str"".equals(event)) {
      eventName=""String_Node_Str"" + domainType.getSimpleName() + ""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(event)) {
      eventName=""String_Node_Str"" + domainType.getSimpleName() + ""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(event)) {
      eventName=""String_Node_Str"" + domainType.getSimpleName() + ""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(event)) {
      eventName=""String_Node_Str"" + domainType.getSimpleName() + ""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(event)) {
      eventName=""String_Node_Str"" + domainType.getSimpleName() + ""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(event)) {
      eventName=""String_Node_Str"" + domainType.getSimpleName() + ""String_Node_Str"";
    }
    if (null == eventName) {
      return errors;
    }
    Collection<Validator> validators=this.validators.get(eventName);
    if (null != validators) {
      for (      Validator v : validators) {
        if (v.supports(o.getClass())) {
          LOG.debug(event + ""String_Node_Str"" + o+ ""String_Node_Str""+ v);
          ValidationUtils.invokeValidator(v,o,errors);
        }
      }
    }
    if (errors.getErrorCount() > 0) {
      throw new RepositoryConstraintViolationException(errors);
    }
  }
  return errors;
}","private Errors validate(String event,Object o){
  Errors errors=null;
  if (null != o) {
    Class<?> domainType=o.getClass();
    errors=new ValidationErrors(domainType.getSimpleName(),o,repositoryMetadataFor(domainType).entityMetadata());
    Collection<Validator> validators=this.validators.get(event);
    if (null != validators) {
      for (      Validator v : validators) {
        if (v.supports(o.getClass())) {
          LOG.debug(event + ""String_Node_Str"" + o+ ""String_Node_Str""+ v);
          ValidationUtils.invokeValidator(v,o,errors);
        }
      }
    }
    if (errors.getErrorCount() > 0) {
      throw new RepositoryConstraintViolationException(errors);
    }
  }
  return errors;
}",0.6061127851915626
8483,"@SuppressWarnings({""String_Node_Str""}) @Override public Object deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException, JsonProcessingException {
  Object entity=BeanUtils.instantiateClass(getValueClass());
  for (JsonToken tok=jp.nextToken(); tok != JsonToken.END_OBJECT; tok=jp.nextToken()) {
    String name=jp.getCurrentName();
switch (tok) {
case FIELD_NAME:
{
        AttributeMetadata attrMeta=repoMeta.entityMetadata().attribute(name);
        Object val=null;
        if (name.startsWith(""String_Node_Str"")) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1)));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(jp.nextTextValue()));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          continue;
        }
        if (null == attrMeta) {
          continue;
        }
        if (attrMeta.isCollectionLike()) {
          Collection c=attrMeta.asCollection(entity);
          if (null == c || c == Collections.emptyList()) {
            c=new ArrayList();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            do {
              Object cval=jp.readValueAs(attrMeta.elementType());
              c.add(cval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_ARRAY);
            val=c;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isSetLike()) {
          Set s=attrMeta.asSet(entity);
          if (null == s || s == Collections.emptySet()) {
            s=new HashSet();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            do {
              Object sval=jp.readValueAs(attrMeta.elementType());
              s.add(sval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_ARRAY);
            val=s;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isMapLike()) {
          Map m=attrMeta.asMap(entity);
          if (null == m || m == Collections.emptyMap()) {
            m=new HashMap();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_OBJECT) {
            do {
              name=jp.getCurrentName();
              Object mkey=(name.startsWith(""String_Node_Str"") ? domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1))) : name);
              tok=jp.nextToken();
              Object mval=jp.readValueAs(attrMeta.elementType());
              m.put(mkey,mval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_OBJECT);
            val=m;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else {
          if ((tok=jp.nextToken()) != JsonToken.VALUE_NULL) {
            val=jp.readValueAs(attrMeta.type());
          }
        }
        if (null != val) {
          attrMeta.set(val,entity);
        }
        break;
      }
  }
}
return entity;
}","@SuppressWarnings({""String_Node_Str""}) @Override public Object deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException, JsonProcessingException {
  Object entity=BeanUtils.instantiateClass(getValueClass());
  for (JsonToken tok=jp.nextToken(); tok != JsonToken.END_OBJECT; tok=jp.nextToken()) {
    String name=jp.getCurrentName();
switch (tok) {
case FIELD_NAME:
{
        AttributeMetadata attrMeta=repoMeta.entityMetadata().attribute(name);
        Object val=null;
        if (name.startsWith(""String_Node_Str"")) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1)));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(jp.nextTextValue()));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
          }
          continue;
        }
        if (null == attrMeta) {
          continue;
        }
        if (attrMeta.isCollectionLike()) {
          Collection c=attrMeta.asCollection(entity);
          if (null == c || c == Collections.emptyList()) {
            c=new ArrayList();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            do {
              Object cval=jp.readValueAs(attrMeta.elementType());
              c.add(cval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_ARRAY);
            val=c;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isSetLike()) {
          Set s=attrMeta.asSet(entity);
          if (null == s || s == Collections.emptySet()) {
            s=new HashSet();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            do {
              Object sval=jp.readValueAs(attrMeta.elementType());
              s.add(sval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_ARRAY);
            val=s;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isMapLike()) {
          Map m=attrMeta.asMap(entity);
          if (null == m || m == Collections.emptyMap()) {
            m=new HashMap();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_OBJECT) {
            do {
              name=jp.getCurrentName();
              Object mkey=(name.startsWith(""String_Node_Str"") ? domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1))) : name);
              tok=jp.nextToken();
              Object mval=jp.readValueAs(attrMeta.elementType());
              m.put(mkey,mval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_OBJECT);
            val=m;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else {
          if ((tok=jp.nextToken()) != JsonToken.VALUE_NULL) {
            val=jp.readValueAs(attrMeta.type());
          }
        }
        if (null != val) {
          attrMeta.set(val,entity);
        }
        break;
      }
  }
}
return entity;
}",0.9790575916230366
8484,"@SuppressWarnings({""String_Node_Str""}) @Override public Object deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException, JsonProcessingException {
  Object entity=BeanUtils.instantiateClass(getValueClass());
  for (JsonToken tok=jp.nextToken(); tok != JsonToken.END_OBJECT; tok=jp.nextToken()) {
    String name=jp.getCurrentName();
switch (tok) {
case FIELD_NAME:
{
        AttributeMetadata attrMeta=repoMeta.entityMetadata().attribute(name);
        Object val=null;
        if (name.startsWith(""String_Node_Str"")) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1)));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(jp.nextTextValue()));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
            }
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"");
          }
          continue;
        }
        if (null == attrMeta) {
          continue;
        }
        if (attrMeta.isCollectionLike()) {
          Collection c=attrMeta.asCollection(entity);
          if (null == c || c == Collections.emptyList()) {
            c=new ArrayList();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            jp.nextToken();
            do {
              Object cval=jp.readValueAs(attrMeta.elementType());
              c.add(cval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_ARRAY);
            val=c;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isSetLike()) {
          Set s=attrMeta.asSet(entity);
          if (null == s || s == Collections.emptySet()) {
            s=new HashSet();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            jp.nextToken();
            do {
              Object sval=jp.readValueAs(attrMeta.elementType());
              s.add(sval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_ARRAY);
            val=s;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isMapLike()) {
          Map m=attrMeta.asMap(entity);
          if (null == m || m == Collections.emptyMap()) {
            m=new HashMap();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_OBJECT) {
            do {
              name=jp.getCurrentName();
              Object mkey=(name.startsWith(""String_Node_Str"") ? domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1))) : name);
              tok=jp.nextToken();
              Object mval=jp.readValueAs(attrMeta.elementType());
              m.put(mkey,mval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_OBJECT);
            val=m;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else {
          if ((tok=jp.nextToken()) != JsonToken.VALUE_NULL) {
            val=jp.readValueAs(attrMeta.type());
          }
        }
        if (null != val) {
          attrMeta.set(val,entity);
        }
        break;
      }
  }
}
return entity;
}","@SuppressWarnings({""String_Node_Str""}) @Override public Object deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException, JsonProcessingException {
  Object entity=BeanUtils.instantiateClass(getValueClass());
  for (JsonToken tok=jp.nextToken(); tok != JsonToken.END_OBJECT; tok=jp.nextToken()) {
    String name=jp.getCurrentName();
switch (tok) {
case FIELD_NAME:
{
        AttributeMetadata attrMeta=repoMeta.entityMetadata().attribute(name);
        Object val=null;
        if (name.startsWith(""String_Node_Str"")) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1)));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(jp.nextTextValue()));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
            }
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"");
          }
          continue;
        }
        if (null == attrMeta) {
          continue;
        }
        if (attrMeta.isCollectionLike()) {
          Collection c=attrMeta.asCollection(entity);
          if (null == c || c == Collections.emptyList()) {
            c=new ArrayList();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
              Object cval=jp.readValueAs(attrMeta.elementType());
              c.add(cval);
            }
            val=c;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isSetLike()) {
          Set s=attrMeta.asSet(entity);
          if (null == s || s == Collections.emptySet()) {
            s=new HashSet();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
              Object sval=jp.readValueAs(attrMeta.elementType());
              s.add(sval);
            }
            val=s;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isMapLike()) {
          Map m=attrMeta.asMap(entity);
          if (null == m || m == Collections.emptyMap()) {
            m=new HashMap();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_OBJECT) {
            do {
              name=jp.getCurrentName();
              Object mkey=(name.startsWith(""String_Node_Str"") ? domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1))) : name);
              tok=jp.nextToken();
              Object mval=jp.readValueAs(attrMeta.elementType());
              m.put(mkey,mval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_OBJECT);
            val=m;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else {
          if ((tok=jp.nextToken()) != JsonToken.VALUE_NULL) {
            val=jp.readValueAs(attrMeta.type());
          }
        }
        if (null != val) {
          attrMeta.set(val,entity);
        }
        break;
      }
  }
}
return entity;
}",0.9356575237118688
8485,"@SuppressWarnings({""String_Node_Str""}) private ResponseEntity<byte[]> negotiateResponse(final ServletServerHttpRequest request,final HttpStatus status,final HttpHeaders headers,final Object resource) throws IOException {
  String jsonpParam=request.getServletRequest().getParameter(config.getJsonpParamName());
  String jsonpOnErrParam=null;
  if (null != config.getJsonpOnErrParamName()) {
    jsonpOnErrParam=request.getServletRequest().getParameter(config.getJsonpOnErrParamName());
  }
  if (null == resource) {
    return maybeWrapJsonp(status,jsonpParam,jsonpOnErrParam,headers,null);
  }
  MediaType acceptType=config.getDefaultMediaType();
  HttpMessageConverter converter=findWriteConverter(resource.getClass(),acceptType);
  if (!MediaTypes.ACCEPT_ALL_TYPES.equals(request.getHeaders().getAccept())) {
    for (    MediaType mt : request.getHeaders().getAccept()) {
      if (null != (converter=findWriteConverter(resource.getClass(),mt))) {
        if (!""String_Node_Str"".equals(mt.getSubtype())) {
          acceptType=mt;
        }
        break;
      }
    }
  }
  headers.setContentType(acceptType);
  if (null == converter) {
    converter=mappingHttpMessageConverter;
  }
  final ByteArrayOutputStream bout=new ByteArrayOutputStream();
  converter.write(resource,headers.getContentType(),new HttpOutputMessage(){
    @Override public OutputStream getBody() throws IOException {
      return bout;
    }
    @Override public HttpHeaders getHeaders(){
      return headers;
    }
  }
);
  return maybeWrapJsonp(status,jsonpParam,jsonpOnErrParam,headers,bout.toByteArray());
}","@SuppressWarnings({""String_Node_Str""}) private ResponseEntity<byte[]> negotiateResponse(final ServletServerHttpRequest request,final HttpStatus status,final HttpHeaders headers,final Object resource) throws IOException {
  String jsonpParam=request.getServletRequest().getParameter(config.getJsonpParamName());
  String jsonpOnErrParam=null;
  if (null != config.getJsonpOnErrParamName()) {
    jsonpOnErrParam=request.getServletRequest().getParameter(config.getJsonpOnErrParamName());
  }
  if (null == resource) {
    return maybeWrapJsonp(status,jsonpParam,jsonpOnErrParam,headers,null);
  }
  MediaType acceptType=config.getDefaultMediaType();
  HttpMessageConverter converter=findWriteConverter(resource.getClass(),acceptType);
  if (null == converter) {
    for (    MediaType mt : request.getHeaders().getAccept()) {
      if (MediaType.ALL.equals(mt)) {
        continue;
      }
      HttpMessageConverter hmc;
      if (null == (hmc=findWriteConverter(resource.getClass(),mt))) {
        continue;
      }
      if (!""String_Node_Str"".equals(mt.getSubtype())) {
        acceptType=mt;
        headers.setContentType(acceptType);
        converter=hmc;
      }
      break;
    }
  }
  if (null == converter) {
    converter=mappingHttpMessageConverter;
    headers.setContentType(MediaType.APPLICATION_JSON);
  }
  final ByteArrayOutputStream bout=new ByteArrayOutputStream();
  converter.write(resource,headers.getContentType(),new HttpOutputMessage(){
    @Override public OutputStream getBody() throws IOException {
      return bout;
    }
    @Override public HttpHeaders getHeaders(){
      return headers;
    }
  }
);
  return maybeWrapJsonp(status,jsonpParam,jsonpOnErrParam,headers,bout.toByteArray());
}",0.7981900452488688
8486,"@SuppressWarnings({""String_Node_Str""}) @Override public Object deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException, JsonProcessingException {
  Object entity=BeanUtils.instantiateClass(getValueClass());
  for (JsonToken tok=jp.nextToken(); tok != JsonToken.END_OBJECT; tok=jp.nextToken()) {
    String name=jp.getCurrentName();
switch (tok) {
case FIELD_NAME:
{
        AttributeMetadata attrMeta=repoMeta.entityMetadata().attribute(name);
        Object val=null;
        if (name.startsWith(""String_Node_Str"")) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1)));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(jp.nextTextValue()));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
            }
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"");
          }
          continue;
        }
        if (null == attrMeta) {
          continue;
        }
        if (attrMeta.isCollectionLike()) {
          Collection c=attrMeta.asCollection(entity);
          if (null == c || c == Collections.emptyList()) {
            c=new ArrayList();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            do {
              Object cval=jp.readValueAs(attrMeta.elementType());
              c.add(cval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_ARRAY);
            val=c;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isSetLike()) {
          Set s=attrMeta.asSet(entity);
          if (null == s || s == Collections.emptySet()) {
            s=new HashSet();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            do {
              Object sval=jp.readValueAs(attrMeta.elementType());
              s.add(sval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_ARRAY);
            val=s;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isMapLike()) {
          Map m=attrMeta.asMap(entity);
          if (null == m || m == Collections.emptyMap()) {
            m=new HashMap();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_OBJECT) {
            do {
              name=jp.getCurrentName();
              Object mkey=(name.startsWith(""String_Node_Str"") ? domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1))) : name);
              tok=jp.nextToken();
              Object mval=jp.readValueAs(attrMeta.elementType());
              m.put(mkey,mval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_OBJECT);
            val=m;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else {
          if ((tok=jp.nextToken()) != JsonToken.VALUE_NULL) {
            val=jp.readValueAs(attrMeta.type());
          }
        }
        if (null != val) {
          attrMeta.set(val,entity);
        }
        break;
      }
  }
}
return entity;
}","@SuppressWarnings({""String_Node_Str""}) @Override public Object deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException, JsonProcessingException {
  Object entity=BeanUtils.instantiateClass(getValueClass());
  for (JsonToken tok=jp.nextToken(); tok != JsonToken.END_OBJECT; tok=jp.nextToken()) {
    String name=jp.getCurrentName();
switch (tok) {
case FIELD_NAME:
{
        AttributeMetadata attrMeta=repoMeta.entityMetadata().attribute(name);
        Object val=null;
        if (name.startsWith(""String_Node_Str"")) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1)));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          entity=domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(jp.nextTextValue()));
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          continue;
        }
        if (""String_Node_Str"".equals(name)) {
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            while ((tok=jp.nextToken()) != JsonToken.END_ARRAY) {
            }
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"");
          }
          continue;
        }
        if (null == attrMeta) {
          continue;
        }
        if (attrMeta.isCollectionLike()) {
          Collection c=attrMeta.asCollection(entity);
          if (null == c || c == Collections.emptyList()) {
            c=new ArrayList();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            jp.nextToken();
            do {
              Object cval=jp.readValueAs(attrMeta.elementType());
              c.add(cval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_ARRAY);
            val=c;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isSetLike()) {
          Set s=attrMeta.asSet(entity);
          if (null == s || s == Collections.emptySet()) {
            s=new HashSet();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_ARRAY) {
            jp.nextToken();
            do {
              Object sval=jp.readValueAs(attrMeta.elementType());
              s.add(sval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_ARRAY);
            val=s;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else         if (attrMeta.isMapLike()) {
          Map m=attrMeta.asMap(entity);
          if (null == m || m == Collections.emptyMap()) {
            m=new HashMap();
          }
          if ((tok=jp.nextToken()) == JsonToken.START_OBJECT) {
            do {
              name=jp.getCurrentName();
              Object mkey=(name.startsWith(""String_Node_Str"") ? domainObjectResolver.resolve(RepositoryRestController.BASE_URI.get(),URI.create(name.substring(1))) : name);
              tok=jp.nextToken();
              Object mval=jp.readValueAs(attrMeta.elementType());
              m.put(mkey,mval);
            }
 while ((tok=jp.nextToken()) != JsonToken.END_OBJECT);
            val=m;
          }
 else           if (tok == JsonToken.VALUE_NULL) {
            val=null;
          }
 else {
            throw new HttpMessageNotReadableException(""String_Node_Str"" + tok + ""String_Node_Str"");
          }
        }
 else {
          if ((tok=jp.nextToken()) != JsonToken.VALUE_NULL) {
            val=jp.readValueAs(attrMeta.type());
          }
        }
        if (null != val) {
          attrMeta.set(val,entity);
        }
        break;
      }
  }
}
return entity;
}",0.992831541218638
8487,"@SuppressWarnings({""String_Node_Str""}) @Override public Object resolve(URI baseUri,URI uri){
  URI relativeUri=baseUri.relativize(uri);
  Stack<URI> uris=UriUtils.explode(baseUri,relativeUri);
  if (uris.size() < 1) {
    return null;
  }
  String repoName=UriUtils.path(uris.get(0));
  String sId=UriUtils.path(uris.get(1));
  RepositoryMetadata repoMeta=repositoryMetadataFor(repoName);
  CrudRepository repo;
  if (null == (repo=repoMeta.repository())) {
    return null;
  }
  EntityMetadata entityMeta;
  if (null == (entityMeta=repoMeta.entityMetadata())) {
    return null;
  }
  Class<? extends Serializable> idType=(Class<? extends Serializable>)entityMeta.idAttribute().type();
  Serializable serId;
  if (ClassUtils.isAssignable(idType,String.class)) {
    serId=sId;
  }
 else {
    serId=conversionService.convert(sId,idType);
  }
  return repo.findOne(serId);
}","@SuppressWarnings({""String_Node_Str""}) @Override public Object resolve(URI baseUri,URI uri){
  URI relativeUri=baseUri.relativize(uri);
  Stack<URI> uris=UriUtils.explode(baseUri,relativeUri);
  if (uris.size() < 1) {
    return null;
  }
  String repoName=UriUtils.path(uris.get(0));
  String sId=UriUtils.path(uris.get(1));
  RepositoryMetadata repoMeta=repositoryMetadataFor(repoName);
  CrudRepository repo;
  if (null == (repo=repoMeta.repository())) {
    return null;
  }
  EntityMetadata entityMeta;
  if (null == (entityMeta=repoMeta.entityMetadata())) {
    return null;
  }
  Class<? extends Serializable> idType=(Class<? extends Serializable>)entityMeta.idAttribute().type();
  Serializable serId=null;
  if (ClassUtils.isAssignable(idType,String.class)) {
    serId=sId;
  }
 else {
    for (    ConversionService cs : conversionServices) {
      if (cs.canConvert(String.class,idType)) {
        serId=cs.convert(sId,idType);
        break;
      }
    }
  }
  return repo.findOne(serId);
}",0.912187333688132
8488,"@Override public void serialize(Object value,JsonGenerator jgen,SerializerProvider provider) throws IOException, JsonGenerationException {
  if (null == value) {
    provider.defaultSerializeNull(jgen);
    return;
  }
  if (null == repoMeta) {
    provider.defaultSerializeValue(value,jgen);
    return;
  }
  Serializable serId=(Serializable)idAttr.get(value);
  String sId=conversionService.convert(serId,String.class);
  if (null == sId) {
    sId=serId.toString();
  }
  URI href=buildUri(RepositoryRestController.BASE_URI.get(),repoMeta.name(),sId);
  jgen.writeString(""String_Node_Str"" + href.toString());
}","@Override public void serialize(Object value,JsonGenerator jgen,SerializerProvider provider) throws IOException, JsonGenerationException {
  if (null == value) {
    provider.defaultSerializeNull(jgen);
    return;
  }
  if (null == repoMeta) {
    provider.defaultSerializeValue(value,jgen);
    return;
  }
  Serializable serId=(Serializable)idAttr.get(value);
  String sId=null;
  for (  ConversionService cs : conversionServices) {
    if (cs.canConvert(idAttr.type(),String.class)) {
      sId=cs.convert(serId,String.class);
      break;
    }
  }
  if (null == sId) {
    sId=serId.toString();
  }
  URI href=buildUri(RepositoryRestController.BASE_URI.get(),repoMeta.name(),sId);
  jgen.writeString(""String_Node_Str"" + href.toString());
}",0.8565121412803532
8489,"/** 
 * Invoke a custom query method on a repository and page the results based on URL parameters supplied by the user or the default page size.
 * @param request
 * @param pageSort
 * @param uriBuilder
 * @param repository
 * @param query
 * @return
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity<?> query(ServletServerHttpRequest request,PagingAndSorting pageSort,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String query) throws InvocationTargetException, IllegalAccessException, IOException {
  URI baseUri=uriBuilder.build().toUri();
  BASE_URI.set(baseUri);
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  Repository repo=repoMeta.repository();
  RepositoryQueryMethod queryMethod=repoMeta.queryMethod(query);
  if (null == queryMethod) {
    return notFoundResponse(request);
  }
  Annotation[][] annotations=queryMethod.method().getParameterAnnotations();
  Class<?>[] paramTypes=queryMethod.paramTypes();
  String[] paramNames=queryMethod.paramNames();
  Object[] paramVals=new Object[paramTypes.length];
  for (int i=0; i < paramVals.length; i++) {
    if (Pageable.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=pageSort;
      continue;
    }
 else     if (Sort.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=(null != pageSort ? pageSort.getSort() : null);
      continue;
    }
    String[] queryVals;
    if (null == (queryVals=request.getServletRequest().getParameterValues(paramNames[i]))) {
      continue;
    }
    Class<? extends Converter<String[],?>> converter=null;
    for (    Annotation anno : annotations[i]) {
      if (ConvertWith.class.isAssignableFrom(anno.getClass())) {
        converter=((ConvertWith)anno).value();
        break;
      }
    }
    String firstVal=(queryVals.length > 0 ? queryVals[0] : null);
    if (hasRepositoryMetadataFor(paramTypes[i])) {
      RepositoryMetadata paramRepoMeta=repositoryMetadataFor(paramTypes[i]);
      Serializable id=stringToSerializable(firstVal,(Class<Serializable>)paramRepoMeta.entityMetadata().idAttribute().type());
      Object o=paramRepoMeta.repository().findOne(id);
      if (null == o) {
        return notFoundResponse(request);
      }
      paramVals[i]=o;
    }
 else     if (null != converter) {
      try {
        paramVals[i]=converter.newInstance().convert(queryVals);
      }
 catch (      InstantiationException e) {
        throw new IllegalArgumentException(e);
      }
    }
 else     if (String.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=firstVal;
    }
 else     if (conversionService.canConvert(String.class,paramTypes[i])) {
      paramVals[i]=conversionService.convert(firstVal,paramTypes[i]);
    }
 else {
      try {
        paramVals[i]=objectMapper.readValue(firstVal,paramTypes[i]);
      }
 catch (      IOException e) {
        throw new IllegalArgumentException(e);
      }
    }
  }
  Object result;
  if (null == (result=queryMethod.method().invoke(repo,paramVals))) {
    return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),new ResourceSet());
  }
  ResourceSet resources=new ResourceSet();
  Iterator entities=Collections.emptyList().iterator();
  if (result instanceof Collection) {
    entities=((Collection)result).iterator();
  }
 else   if (result instanceof Page) {
    Page page=(Page)result;
    if (page.hasContent()) {
      entities=page.iterator();
    }
    PageableResourceSet pr=new PageableResourceSet();
    pr.setPaging(new PagingMetadata(page.getNumber() + 1,page.getSize(),page.getTotalPages(),page.getTotalElements()));
    UriComponentsBuilder selfUri=UriComponentsBuilder.fromUri(baseUri).pathSegment(repository,""String_Node_Str"",query);
    for (    String name : request.getServletRequest().getParameterMap().keySet()) {
      if (notPagingParam(name)) {
        selfUri.queryParam(name,request.getServletRequest().getParameter(name));
      }
    }
    URI nextPrevBase=selfUri.build().toUri();
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isFirstPage() && page.hasPreviousPage(),page.getNumber(),""String_Node_Str"",pr.getLinks());
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isLastPage() && page.hasNextPage(),page.getNumber() + 2,""String_Node_Str"",pr.getLinks());
    resources=pr;
  }
 else {
    entities=Collections.singletonList(result).iterator();
  }
  while (entities.hasNext()) {
    Object obj=entities.next();
    RepositoryMetadata elemRepoMeta;
    if (null == (elemRepoMeta=repositoryMetadataFor(obj.getClass()))) {
      resources.addResource(new Resource(obj));
      continue;
    }
    String id=elemRepoMeta.entityMetadata().idAttribute().get(obj).toString();
    if (shouldReturnLinks(request.getServletRequest().getHeader(""String_Node_Str""))) {
      String rel=elemRepoMeta.rel() + ""String_Node_Str"" + elemRepoMeta.entityMetadata().type().getSimpleName();
      URI path=buildUri(baseUri,repository,id);
      resources.addLink(new ResourceLink(rel,path));
    }
 else {
      URI selfUri=buildUri(baseUri,repository,id);
      MapResource res=createResource(repoMeta.rel(),obj,repoMeta.entityMetadata(),selfUri);
      res.addLink(new ResourceLink(SELF,selfUri));
      resources.addResource(res);
    }
  }
  publishEvent(new BeforeRenderResourcesEvent(request,repoMeta,resources));
  return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),resources);
}","/** 
 * Invoke a custom query method on a repository and page the results based on URL parameters supplied by the user or the default page size.
 * @param request
 * @param pageSort
 * @param uriBuilder
 * @param repository
 * @param query
 * @return
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity<?> query(ServletServerHttpRequest request,PagingAndSorting pageSort,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String query) throws InvocationTargetException, IllegalAccessException, IOException {
  URI baseUri=uriBuilder.build().toUri();
  BASE_URI.set(baseUri);
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  Repository repo=repoMeta.repository();
  RepositoryQueryMethod queryMethod=repoMeta.queryMethod(query);
  if (null == queryMethod) {
    return notFoundResponse(request);
  }
  Annotation[][] annotations=queryMethod.method().getParameterAnnotations();
  Class<?>[] paramTypes=queryMethod.paramTypes();
  String[] paramNames=queryMethod.paramNames();
  Object[] paramVals=new Object[paramTypes.length];
  for (int i=0; i < paramVals.length; i++) {
    if (Pageable.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=pageSort;
      continue;
    }
 else     if (Sort.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=(null != pageSort ? pageSort.getSort() : null);
      continue;
    }
    String[] queryVals;
    if (null == (queryVals=request.getServletRequest().getParameterValues(paramNames[i]))) {
      continue;
    }
    TypeDescriptor stringTypeDesc=TypeDescriptor.valueOf(String[].class);
    MethodParameter methodParam=new MethodParameter(queryMethod.method(),i);
    TypeDescriptor targetTypeDesc=new TypeDescriptor(methodParam);
    Class<? extends Converter<String[],?>> converter=null;
    for (    Annotation anno : annotations[i]) {
      if (ConvertWith.class.isAssignableFrom(anno.getClass())) {
        converter=((ConvertWith)anno).value();
        break;
      }
    }
    String firstVal=(queryVals.length > 0 ? queryVals[0] : null);
    if (hasRepositoryMetadataFor(paramTypes[i])) {
      RepositoryMetadata paramRepoMeta=repositoryMetadataFor(paramTypes[i]);
      Serializable id=stringToSerializable(firstVal,(Class<Serializable>)paramRepoMeta.entityMetadata().idAttribute().type());
      Object o=paramRepoMeta.repository().findOne(id);
      if (null == o) {
        return notFoundResponse(request);
      }
      paramVals[i]=o;
    }
 else     if (null != converter) {
      try {
        paramVals[i]=converter.newInstance().convert(queryVals);
      }
 catch (      InstantiationException e) {
        throw new IllegalArgumentException(e);
      }
    }
 else     if (String.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=firstVal;
    }
 else     if (conversionService.canConvert(stringTypeDesc,targetTypeDesc)) {
      paramVals[i]=conversionService.convert(queryVals,stringTypeDesc,targetTypeDesc);
    }
 else {
      try {
        paramVals[i]=objectMapper.readValue(firstVal,paramTypes[i]);
      }
 catch (      IOException e) {
        throw new IllegalArgumentException(e);
      }
    }
  }
  Object result;
  if (null == (result=queryMethod.method().invoke(repo,paramVals))) {
    return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),new ResourceSet());
  }
  ResourceSet resources=new ResourceSet();
  Iterator entities=Collections.emptyList().iterator();
  if (result instanceof Collection) {
    entities=((Collection)result).iterator();
  }
 else   if (result instanceof Page) {
    Page page=(Page)result;
    if (page.hasContent()) {
      entities=page.iterator();
    }
    PageableResourceSet pr=new PageableResourceSet();
    pr.setPaging(new PagingMetadata(page.getNumber() + 1,page.getSize(),page.getTotalPages(),page.getTotalElements()));
    UriComponentsBuilder selfUri=UriComponentsBuilder.fromUri(baseUri).pathSegment(repository,""String_Node_Str"",query);
    for (    String name : request.getServletRequest().getParameterMap().keySet()) {
      if (notPagingParam(name)) {
        selfUri.queryParam(name,request.getServletRequest().getParameter(name));
      }
    }
    URI nextPrevBase=selfUri.build().toUri();
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isFirstPage() && page.hasPreviousPage(),page.getNumber(),""String_Node_Str"",pr.getLinks());
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isLastPage() && page.hasNextPage(),page.getNumber() + 2,""String_Node_Str"",pr.getLinks());
    resources=pr;
  }
 else {
    entities=Collections.singletonList(result).iterator();
  }
  while (entities.hasNext()) {
    Object obj=entities.next();
    RepositoryMetadata elemRepoMeta;
    if (null == (elemRepoMeta=repositoryMetadataFor(obj.getClass()))) {
      resources.addResource(new Resource(obj));
      continue;
    }
    String id=elemRepoMeta.entityMetadata().idAttribute().get(obj).toString();
    if (shouldReturnLinks(request.getServletRequest().getHeader(""String_Node_Str""))) {
      String rel=elemRepoMeta.rel() + ""String_Node_Str"" + elemRepoMeta.entityMetadata().type().getSimpleName();
      URI path=buildUri(baseUri,repository,id);
      resources.addLink(new ResourceLink(rel,path));
    }
 else {
      URI selfUri=buildUri(baseUri,repository,id);
      MapResource res=createResource(repoMeta.rel(),obj,repoMeta.entityMetadata(),selfUri);
      res.addLink(new ResourceLink(SELF,selfUri));
      resources.addResource(res);
    }
  }
  publishEvent(new BeforeRenderResourcesEvent(request,repoMeta,resources));
  return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),resources);
}",0.9729777153886648
8490,"/** 
 * Get the   {@link ConversionService} in use by the controller.
 * @return The internal {@link ConversionService}.
 */
public ConversionService getConversionService(){
  return conversionService;
}","/** 
 * Get the   {@link ConversionService} in use by the controller.
 * @return The internal {@link ConversionService}s.
 */
public ConversionService getConversionService(){
  return conversionService;
}",0.9975429975429976
8491,"/** 
 * @param conversionService
 * @return @this
 * @see RepositoryRestController#setConversionService(org.springframework.core.convert.ConversionService)
 */
public RepositoryRestController conversionService(ConversionService conversionService){
  setConversionService(conversionService);
  return this;
}","/** 
 * @return The internal {@link ConversionService}.
 * @see org.springframework.data.rest.webmvc.RepositoryRestController#getConversionService()
 */
public ConversionService conversionService(){
  return conversionService;
}",0.3663551401869159
8492,"@Query(""String_Node_Str"") @RestResource(path=""String_Node_Str"") Page<Person> findById(@Param(""String_Node_Str"") @ConvertWith(StringToListOfLongsConverter.class) List<Long> ids,Pageable pageable);","@Query(""String_Node_Str"") @RestResource(path=""String_Node_Str"") Page<Person> findById(@Param(""String_Node_Str"") List<Long> ids,Pageable pageable);",0.8563049853372434
8493,"/** 
 * Invoke a custom query method on a repository and page the results based on URL parameters supplied by the user or the default page size.
 * @param request
 * @param pageSort
 * @param uriBuilder
 * @param repository
 * @param query
 * @return
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity<?> query(ServletServerHttpRequest request,PagingAndSorting pageSort,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String query) throws InvocationTargetException, IllegalAccessException, IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  Repository repo=repoMeta.repository();
  RepositoryQueryMethod queryMethod=repoMeta.queryMethod(query);
  if (null == queryMethod) {
    return notFoundResponse(request);
  }
  Class<?>[] paramTypes=queryMethod.paramTypes();
  String[] paramNames=queryMethod.paramNames();
  Object[] paramVals=new Object[paramTypes.length];
  for (int i=0; i < paramVals.length; i++) {
    if (Pageable.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=pageSort;
      continue;
    }
 else     if (Sort.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=(null != pageSort ? pageSort.getSort() : null);
      continue;
    }
    String queryVal;
    if (null == (queryVal=request.getServletRequest().getParameter(paramNames[i]))) {
      continue;
    }
    RepositoryMetadata paramRepoMeta;
    if (String.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=queryVal;
    }
 else     if (null != (paramRepoMeta=repositoryMetadataFor(paramTypes[i]))) {
      Serializable id=stringToSerializable(queryVal,(Class<Serializable>)paramRepoMeta.entityMetadata().idAttribute().type());
      Object o=paramRepoMeta.repository().findOne(id);
      if (null == o) {
        return notFoundResponse(request);
      }
      paramVals[i]=o;
    }
 else     if (conversionService.canConvert(String.class,paramTypes[i])) {
      paramVals[i]=conversionService.convert(queryVal,paramTypes[i]);
    }
 else {
      try {
        paramVals[i]=objectMapper.readValue(queryVal,paramTypes[i]);
      }
 catch (      IOException e) {
        throw new IllegalArgumentException(e);
      }
    }
  }
  RepositoryMethodResponse response=new RepositoryMethodResponse();
  Object result;
  if (null == (result=queryMethod.method().invoke(repo,paramVals))) {
    return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),response);
  }
  Iterator entities=Collections.emptyList().iterator();
  if (result instanceof Collection) {
    entities=((Collection)result).iterator();
    response.setTotalCount(((Collection)result).size());
  }
 else   if (result instanceof Page) {
    Page page=(Page)result;
    if (page.hasContent()) {
      entities=page.iterator();
    }
    response.setTotalCount(page.getTotalElements());
    response.setTotalPages(page.getTotalPages());
    response.setCurrentPage(page.getNumber() + 1);
    UriComponentsBuilder selfUri=UriComponentsBuilder.fromUri(baseUri).pathSegment(repository,""String_Node_Str"",query);
    for (    String name : request.getServletRequest().getParameterMap().keySet()) {
      if (notPagingParam(name)) {
        selfUri.queryParam(name,request.getServletRequest().getParameter(name));
      }
    }
    URI nextPrevBase=selfUri.build().toUri();
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isFirstPage() && page.hasPreviousPage(),page.getNumber(),""String_Node_Str"",response.getLinks());
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isLastPage() && page.hasNextPage(),page.getNumber() + 2,""String_Node_Str"",response.getLinks());
  }
 else {
    entities=Collections.singletonList(result).iterator();
  }
  while (entities.hasNext()) {
    Object obj=entities.next();
    RepositoryMetadata elemRepoMeta;
    if (null == (elemRepoMeta=repositoryMetadataFor(obj.getClass()))) {
      response.addResult(obj);
      continue;
    }
    String id=elemRepoMeta.entityMetadata().idAttribute().get(obj).toString();
    if (shouldReturnLinks(request.getServletRequest().getHeader(""String_Node_Str""))) {
      String rel=elemRepoMeta.rel() + ""String_Node_Str"" + elemRepoMeta.entityMetadata().type().getSimpleName();
      URI path=buildUri(baseUri,repository,id);
      response.addLink(new SimpleLink(rel,path));
    }
 else {
      Map<String,Object> entityDto=extractPropertiesLinkAware(repoMeta.rel(),obj,repoMeta.entityMetadata(),buildUri(baseUri,repository,id));
      addSelfLink(baseUri,entityDto,repository,id);
      response.addResult(entityDto);
    }
  }
  return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),response);
}","/** 
 * Invoke a custom query method on a repository and page the results based on URL parameters supplied by the user or the default page size.
 * @param request
 * @param pageSort
 * @param uriBuilder
 * @param repository
 * @param query
 * @return
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity<?> query(ServletServerHttpRequest request,PagingAndSorting pageSort,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String query) throws InvocationTargetException, IllegalAccessException, IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  Repository repo=repoMeta.repository();
  RepositoryQueryMethod queryMethod=repoMeta.queryMethod(query);
  if (null == queryMethod) {
    return notFoundResponse(request);
  }
  Class<?>[] paramTypes=queryMethod.paramTypes();
  String[] paramNames=queryMethod.paramNames();
  Object[] paramVals=new Object[paramTypes.length];
  for (int i=0; i < paramVals.length; i++) {
    if (Pageable.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=pageSort;
      continue;
    }
 else     if (Sort.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=(null != pageSort ? pageSort.getSort() : null);
      continue;
    }
    String queryVal;
    if (null == (queryVal=request.getServletRequest().getParameter(paramNames[i]))) {
      continue;
    }
    if (String.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=queryVal;
    }
 else     if (hasRepositoryMetadataFor(paramTypes[i])) {
      RepositoryMetadata paramRepoMeta=repositoryMetadataFor(paramTypes[i]);
      Serializable id=stringToSerializable(queryVal,(Class<Serializable>)paramRepoMeta.entityMetadata().idAttribute().type());
      Object o=paramRepoMeta.repository().findOne(id);
      if (null == o) {
        return notFoundResponse(request);
      }
      paramVals[i]=o;
    }
 else     if (conversionService.canConvert(String.class,paramTypes[i])) {
      paramVals[i]=conversionService.convert(queryVal,paramTypes[i]);
    }
 else {
      try {
        paramVals[i]=objectMapper.readValue(queryVal,paramTypes[i]);
      }
 catch (      IOException e) {
        throw new IllegalArgumentException(e);
      }
    }
  }
  RepositoryMethodResponse response=new RepositoryMethodResponse();
  Object result;
  if (null == (result=queryMethod.method().invoke(repo,paramVals))) {
    return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),response);
  }
  Iterator entities=Collections.emptyList().iterator();
  if (result instanceof Collection) {
    entities=((Collection)result).iterator();
    response.setTotalCount(((Collection)result).size());
  }
 else   if (result instanceof Page) {
    Page page=(Page)result;
    if (page.hasContent()) {
      entities=page.iterator();
    }
    response.setTotalCount(page.getTotalElements());
    response.setTotalPages(page.getTotalPages());
    response.setCurrentPage(page.getNumber() + 1);
    UriComponentsBuilder selfUri=UriComponentsBuilder.fromUri(baseUri).pathSegment(repository,""String_Node_Str"",query);
    for (    String name : request.getServletRequest().getParameterMap().keySet()) {
      if (notPagingParam(name)) {
        selfUri.queryParam(name,request.getServletRequest().getParameter(name));
      }
    }
    URI nextPrevBase=selfUri.build().toUri();
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isFirstPage() && page.hasPreviousPage(),page.getNumber(),""String_Node_Str"",response.getLinks());
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isLastPage() && page.hasNextPage(),page.getNumber() + 2,""String_Node_Str"",response.getLinks());
  }
 else {
    entities=Collections.singletonList(result).iterator();
  }
  while (entities.hasNext()) {
    Object obj=entities.next();
    RepositoryMetadata elemRepoMeta;
    if (null == (elemRepoMeta=repositoryMetadataFor(obj.getClass()))) {
      response.addResult(obj);
      continue;
    }
    String id=elemRepoMeta.entityMetadata().idAttribute().get(obj).toString();
    if (shouldReturnLinks(request.getServletRequest().getHeader(""String_Node_Str""))) {
      String rel=elemRepoMeta.rel() + ""String_Node_Str"" + elemRepoMeta.entityMetadata().type().getSimpleName();
      URI path=buildUri(baseUri,repository,id);
      response.addLink(new SimpleLink(rel,path));
    }
 else {
      Map<String,Object> entityDto=extractPropertiesLinkAware(repoMeta.rel(),obj,repoMeta.entityMetadata(),buildUri(baseUri,repository,id));
      addSelfLink(baseUri,entityDto,repository,id);
      response.addResult(entityDto);
    }
  }
  return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),response);
}",0.9829673712292224
8494,"@Override public final void onApplicationEvent(RepositoryEvent event){
  if (event instanceof BeforeSaveEvent) {
    onBeforeSave(event.getSource());
  }
 else   if (event instanceof AfterSaveEvent) {
    onAfterSave(event.getSource());
  }
 else   if (event instanceof BeforeLinkSaveEvent) {
    onBeforeLinkSave(event.getSource(),((BeforeLinkSaveEvent)event).getLinked());
  }
 else   if (event instanceof AfterLinkSaveEvent) {
    onAfterLinkSave(event.getSource(),((AfterLinkSaveEvent)event).getLinked());
  }
 else   if (event instanceof BeforeDeleteEvent) {
    onBeforeDelete(event.getSource());
  }
 else   if (event instanceof AfterDeleteEvent) {
    onAfterDelete(event.getSource());
  }
}","@Override public final void onApplicationEvent(RepositoryEvent event){
  if (event instanceof BeforeSaveEvent) {
    onBeforeSave(event.getSource());
  }
 else   if (event instanceof AfterSaveEvent) {
    onAfterSave(event.getSource());
  }
 else   if (event instanceof BeforeLinkSaveEvent) {
    onBeforeLinkSave(event.getSource(),((BeforeLinkSaveEvent)event).getLinked());
  }
 else   if (event instanceof AfterLinkSaveEvent) {
    onAfterLinkSave(event.getSource(),((AfterLinkSaveEvent)event).getLinked());
  }
 else   if (event instanceof BeforeLinkDeleteEvent) {
    onBeforeLinkDelete(event.getSource(),((BeforeLinkDeleteEvent)event).getLinked());
  }
 else   if (event instanceof AfterLinkDeleteEvent) {
    onAfterLinkDelete(event.getSource(),((BeforeLinkDeleteEvent)event).getLinked());
  }
 else   if (event instanceof BeforeDeleteEvent) {
    onBeforeDelete(event.getSource());
  }
 else   if (event instanceof AfterDeleteEvent) {
    onAfterDelete(event.getSource());
  }
}",0.830166270783848
8495,"public RepositoryMethod(Method method){
  this.method=method;
  paramTypes=method.getParameterTypes();
  for (  Class<?> type : paramTypes) {
    if (Pageable.class.isAssignableFrom(type)) {
      pageable=true;
    }
    if (Sort.class.isAssignableFrom(type)) {
      sortable=true;
    }
  }
  paramNames=NAME_DISCOVERER.getParameterNames(method);
  if (null == paramNames) {
    paramNames=new String[paramTypes.length];
  }
  Annotation[][] paramAnnos=method.getParameterAnnotations();
  for (int i=0; i < paramAnnos.length; i++) {
    if (paramAnnos[i].length > 0) {
      for (      Annotation anno : paramAnnos[i]) {
        if (Param.class.isAssignableFrom(anno.getClass())) {
          Param p=(Param)anno;
          paramNames[i]=p.value();
          break;
        }
      }
    }
    if (null == paramNames[i]) {
      paramNames[i]=""String_Node_Str"" + i;
    }
  }
}","public RepositoryMethod(Method method){
  this.method=method;
  paramTypes=method.getParameterTypes();
  for (  Class<?> type : paramTypes) {
    if (Pageable.class.isAssignableFrom(type)) {
      pageable=true;
    }
    if (Sort.class.isAssignableFrom(type)) {
      sortable=true;
    }
  }
  paramNames=Methods.NAME_DISCOVERER.getParameterNames(method);
  if (null == paramNames) {
    paramNames=new String[paramTypes.length];
  }
  Annotation[][] paramAnnos=method.getParameterAnnotations();
  for (int i=0; i < paramAnnos.length; i++) {
    if (paramAnnos[i].length > 0) {
      for (      Annotation anno : paramAnnos[i]) {
        if (Param.class.isAssignableFrom(anno.getClass())) {
          Param p=(Param)anno;
          paramNames[i]=p.value();
          break;
        }
      }
    }
    if (null == paramNames[i]) {
      paramNames[i]=""String_Node_Str"" + i;
    }
  }
}",0.9954699886749716
8496,"@SuppressWarnings({""String_Node_Str""}) public JpaEntityMetadata(Repositories repositories,EntityType<?> entityType){
  type=entityType.getJavaType();
  idAttribute=new JpaAttributeMetadata(entityType,entityType.getId(entityType.getIdType().getJavaType()));
  if (null != entityType.getVersion(Long.class)) {
    versionAttribute=new JpaAttributeMetadata(entityType,entityType.getVersion(Long.class));
  }
  for (  Attribute attr : entityType.getAttributes()) {
    boolean exported=true;
    Field field=ReflectionUtils.findField(type,attr.getJavaMember().getName());
    if (null != field) {
      RestResource fieldResourceAnno=field.getAnnotation(RestResource.class);
      if (null != fieldResourceAnno) {
        exported=fieldResourceAnno.exported();
      }
    }
    if (exported) {
      Class<?> attrType=(attr instanceof PluralAttribute ? ((PluralAttribute)attr).getElementType().getJavaType() : attr.getJavaType());
      if (repositories.hasRepositoryFor(attrType)) {
        linkedAttributes.put(attr.getName(),new JpaAttributeMetadata(entityType,attr));
      }
 else {
        if (!(attr instanceof SingularAttribute && ((SingularAttribute)attr).isId()) && !(attr instanceof SingularAttribute && ((SingularAttribute)attr).isVersion())) {
          embeddedAttributes.put(attr.getName(),new JpaAttributeMetadata(entityType,attr));
        }
      }
    }
  }
}","@SuppressWarnings({""String_Node_Str""}) public JpaEntityMetadata(Repositories repositories,EntityType<?> entityType){
  type=entityType.getJavaType();
  idAttribute=new JpaAttributeMetadata(entityType,entityType.getId(entityType.getIdType().getJavaType()));
  if (null != entityType.getVersion(Long.class)) {
    versionAttribute=new JpaAttributeMetadata(entityType,entityType.getVersion(Long.class));
  }
  for (  Attribute attr : entityType.getAttributes()) {
    boolean exported=true;
    Field field=ReflectionUtils.findField(type,attr.getJavaMember().getName());
    if (null == field) {
      continue;
    }
    RestResource fieldResourceAnno=field.getAnnotation(RestResource.class);
    if (null != fieldResourceAnno) {
      exported=fieldResourceAnno.exported();
    }
    if (exported) {
      String name=attr.getName();
      if (null != fieldResourceAnno && StringUtils.hasText(fieldResourceAnno.path())) {
        name=fieldResourceAnno.path();
      }
      Class<?> attrType=(attr instanceof PluralAttribute ? ((PluralAttribute)attr).getElementType().getJavaType() : attr.getJavaType());
      if (repositories.hasRepositoryFor(attrType)) {
        linkedAttributes.put(name,new JpaAttributeMetadata(entityType,attr));
      }
 else {
        if (!(attr instanceof SingularAttribute && ((SingularAttribute)attr).isId()) && !(attr instanceof SingularAttribute && ((SingularAttribute)attr).isVersion())) {
          embeddedAttributes.put(name,new JpaAttributeMetadata(entityType,attr));
        }
      }
    }
  }
}",0.8572411420708634
8497,"/** 
 * Create a new entity by reading the incoming data and calling   {@link CrudRepository#save(Object)} and letting theID be auto-generated. <p/> To get the entity back in the body of the response, simpy add the URL parameter <pre>returnBody=true</pre>.
 * @param request
 * @param uriBuilder
 * @param repository
 * @return
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public ResponseEntity<?> create(ServletServerHttpRequest request,UriComponentsBuilder uriBuilder,@PathVariable String repository) throws IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.SAVE_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  CrudRepository repo=repoMeta.repository();
  MediaType incomingMediaType=request.getHeaders().getContentType();
  Object incoming=readIncoming(request,incomingMediaType,repoMeta.entityMetadata().type());
  if (null == incoming) {
    throw new HttpMessageNotReadableException(""String_Node_Str"" + repoMeta.entityMetadata().type().getSimpleName() + ""String_Node_Str"");
  }
  publishEvent(new BeforeSaveEvent(incoming));
  Object savedEntity=repo.save(incoming);
  publishEvent(new AfterSaveEvent(savedEntity));
  String sId=repoMeta.entityMetadata().idAttribute().get(savedEntity).toString();
  URI selfUri=buildUri(baseUri,repository,sId);
  HttpHeaders headers=new HttpHeaders();
  headers.set(LOCATION,selfUri.toString());
  Resource<?> body=null;
  if (returnBody(request)) {
    MapResource resource=createResource(repoMeta.rel(),savedEntity,repoMeta.entityMetadata(),buildUri(baseUri,repository,sId));
    resource.addLink(new SimpleLink(SELF,selfUri));
    body=resource;
  }
  publishEvent(new BeforeRenderResourceEvent(request,repoMeta,body));
  return negotiateResponse(request,HttpStatus.CREATED,headers,body);
}","/** 
 * Create a new entity by reading the incoming data and calling   {@link CrudRepository#save(Object)} and letting theID be auto-generated. <p/> To get the entity back in the body of the response, simpy add the URL parameter <pre>returnBody=true</pre>.
 * @param request
 * @param uriBuilder
 * @param repository
 * @return
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) @ResponseBody public ResponseEntity<?> create(ServletServerHttpRequest request,UriComponentsBuilder uriBuilder,@PathVariable String repository) throws IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.SAVE_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  CrudRepository repo=repoMeta.repository();
  MediaType incomingMediaType=request.getHeaders().getContentType();
  Object incoming=readIncoming(request,incomingMediaType,repoMeta.entityMetadata().type());
  if (null == incoming) {
    throw new HttpMessageNotReadableException(""String_Node_Str"" + repoMeta.entityMetadata().type().getSimpleName() + ""String_Node_Str"");
  }
  publishEvent(new BeforeSaveEvent(incoming));
  Object savedEntity=repo.save(incoming);
  publishEvent(new AfterSaveEvent(savedEntity));
  String sId=repoMeta.entityMetadata().idAttribute().get(savedEntity).toString();
  URI selfUri=buildUri(baseUri,repository,sId);
  HttpHeaders headers=new HttpHeaders();
  headers.set(LOCATION,selfUri.toString());
  Resource<?> body=null;
  if (returnBody(request)) {
    MapResource resource=createResource(repoMeta.rel(),savedEntity,repoMeta.entityMetadata(),selfUri);
    resource.addLink(new SimpleLink(SELF,selfUri));
    publishEvent(new BeforeRenderResourceEvent(request,repoMeta,body));
    body=resource;
  }
  return negotiateResponse(request,HttpStatus.CREATED,headers,body);
}",0.9561293557282527
8498,"/** 
 * Create an entity with a specific ID or update an existing entity.
 * @param request
 * @param uriBuilder
 * @param repository
 * @param id
 * @return
 * @throws IOException
 * @throws IllegalAccessException
 * @throws InstantiationException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method={RequestMethod.PUT}) @ResponseBody public ResponseEntity<?> createOrUpdate(ServletServerHttpRequest request,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String id) throws IOException, IllegalAccessException, InstantiationException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.SAVE_ONE) || !repoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  Serializable serId=stringToSerializable(id,(Class<? extends Serializable>)repoMeta.entityMetadata().idAttribute().type());
  CrudRepository repo=repoMeta.repository();
  Class<?> domainType=repoMeta.entityMetadata().type();
  MediaType incomingMediaType=request.getHeaders().getContentType();
  Object incoming;
  if (null == (incoming=readIncoming(request,incomingMediaType,domainType))) {
    throw new HttpMessageNotReadableException(""String_Node_Str"" + domainType.getSimpleName() + ""String_Node_Str"");
  }
  repoMeta.entityMetadata().idAttribute().set(serId,incoming);
  boolean isUpdate=false;
  Object entity;
  if (null != (entity=repo.findOne(serId))) {
    isUpdate=true;
    for (    AttributeMetadata attrMeta : (Collection<AttributeMetadata>)repoMeta.entityMetadata().embeddedAttributes().values()) {
      Object incomingVal;
      if (null != (incomingVal=attrMeta.get(incoming))) {
        attrMeta.set(incomingVal,entity);
      }
    }
  }
 else {
    entity=incoming;
  }
  publishEvent(new BeforeSaveEvent(entity));
  Object savedEntity=repo.save(entity);
  publishEvent(new AfterSaveEvent(savedEntity));
  URI selfUri=buildUri(baseUri,repository,id);
  Object body=null;
  if (returnBody(request)) {
    MapResource res=createResource(repoMeta.rel(),savedEntity,repoMeta.entityMetadata(),baseUri);
    res.addLink(new SimpleLink(SELF,selfUri));
    publishEvent(new BeforeRenderResourceEvent(request,repoMeta,body));
    body=res;
  }
  if (!isUpdate) {
    HttpHeaders headers=new HttpHeaders();
    headers.set(LOCATION,selfUri.toString());
    return negotiateResponse(request,HttpStatus.CREATED,headers,body);
  }
 else {
    return negotiateResponse(request,(null != body ? HttpStatus.OK : HttpStatus.NO_CONTENT),new HttpHeaders(),body);
  }
}","/** 
 * Create an entity with a specific ID or update an existing entity.
 * @param request
 * @param uriBuilder
 * @param repository
 * @param id
 * @return
 * @throws IOException
 * @throws IllegalAccessException
 * @throws InstantiationException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method={RequestMethod.PUT}) @ResponseBody public ResponseEntity<?> createOrUpdate(ServletServerHttpRequest request,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String id) throws IOException, IllegalAccessException, InstantiationException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.SAVE_ONE) || !repoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  Serializable serId=stringToSerializable(id,(Class<? extends Serializable>)repoMeta.entityMetadata().idAttribute().type());
  CrudRepository repo=repoMeta.repository();
  Class<?> domainType=repoMeta.entityMetadata().type();
  MediaType incomingMediaType=request.getHeaders().getContentType();
  Object incoming;
  if (null == (incoming=readIncoming(request,incomingMediaType,domainType))) {
    throw new HttpMessageNotReadableException(""String_Node_Str"" + domainType.getSimpleName() + ""String_Node_Str"");
  }
  repoMeta.entityMetadata().idAttribute().set(serId,incoming);
  boolean isUpdate=false;
  Object entity;
  if (null != (entity=repo.findOne(serId))) {
    isUpdate=true;
    for (    AttributeMetadata attrMeta : (Collection<AttributeMetadata>)repoMeta.entityMetadata().embeddedAttributes().values()) {
      Object incomingVal;
      if (null != (incomingVal=attrMeta.get(incoming))) {
        attrMeta.set(incomingVal,entity);
      }
    }
  }
 else {
    entity=incoming;
  }
  publishEvent(new BeforeSaveEvent(entity));
  Object savedEntity=repo.save(entity);
  publishEvent(new AfterSaveEvent(savedEntity));
  URI selfUri=buildUri(baseUri,repository,id);
  Object body=null;
  if (returnBody(request)) {
    MapResource res=createResource(repoMeta.rel(),savedEntity,repoMeta.entityMetadata(),selfUri);
    res.addLink(new SimpleLink(SELF,selfUri));
    publishEvent(new BeforeRenderResourceEvent(request,repoMeta,body));
    body=res;
  }
  if (!isUpdate) {
    HttpHeaders headers=new HttpHeaders();
    headers.set(LOCATION,selfUri.toString());
    return negotiateResponse(request,HttpStatus.CREATED,headers,body);
  }
 else {
    return negotiateResponse(request,(null != body ? HttpStatus.OK : HttpStatus.NO_CONTENT),new HttpHeaders(),body);
  }
}",0.9985074626865672
8499,"/** 
 * Invoke a custom query method on a repository and page the results based on URL parameters supplied by the user or the default page size.
 * @param request
 * @param pageSort
 * @param uriBuilder
 * @param repository
 * @param query
 * @return
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity<?> query(ServletServerHttpRequest request,PagingAndSorting pageSort,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String query) throws InvocationTargetException, IllegalAccessException, IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  Repository repo=repoMeta.repository();
  RepositoryQueryMethod queryMethod=repoMeta.queryMethod(query);
  if (null == queryMethod) {
    return notFoundResponse(request);
  }
  Class<?>[] paramTypes=queryMethod.paramTypes();
  String[] paramNames=queryMethod.paramNames();
  Object[] paramVals=new Object[paramTypes.length];
  for (int i=0; i < paramVals.length; i++) {
    if (Pageable.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=pageSort;
      continue;
    }
 else     if (Sort.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=(null != pageSort ? pageSort.getSort() : null);
      continue;
    }
    String queryVal;
    if (null == (queryVal=request.getServletRequest().getParameter(paramNames[i]))) {
      continue;
    }
    if (String.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=queryVal;
    }
 else     if (hasRepositoryMetadataFor(paramTypes[i])) {
      RepositoryMetadata paramRepoMeta=repositoryMetadataFor(paramTypes[i]);
      Serializable id=stringToSerializable(queryVal,(Class<Serializable>)paramRepoMeta.entityMetadata().idAttribute().type());
      Object o=paramRepoMeta.repository().findOne(id);
      if (null == o) {
        return notFoundResponse(request);
      }
      paramVals[i]=o;
    }
 else     if (conversionService.canConvert(String.class,paramTypes[i])) {
      paramVals[i]=conversionService.convert(queryVal,paramTypes[i]);
    }
 else {
      try {
        paramVals[i]=objectMapper.readValue(queryVal,paramTypes[i]);
      }
 catch (      IOException e) {
        throw new IllegalArgumentException(e);
      }
    }
  }
  Object result;
  if (null == (result=queryMethod.method().invoke(repo,paramVals))) {
    return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),new Resources());
  }
  Resources resources=new Resources();
  Iterator entities=Collections.emptyList().iterator();
  if (result instanceof Collection) {
    entities=((Collection)result).iterator();
  }
 else   if (result instanceof Page) {
    Page page=(Page)result;
    if (page.hasContent()) {
      entities=page.iterator();
    }
    PageableResources pr=new PageableResources();
    pr.setResourceCount(page.getTotalElements());
    pr.setPaging(new PagingMetadata(page.getNumber() + 1,page.getTotalPages()));
    UriComponentsBuilder selfUri=UriComponentsBuilder.fromUri(baseUri).pathSegment(repository,""String_Node_Str"",query);
    for (    String name : request.getServletRequest().getParameterMap().keySet()) {
      if (notPagingParam(name)) {
        selfUri.queryParam(name,request.getServletRequest().getParameter(name));
      }
    }
    URI nextPrevBase=selfUri.build().toUri();
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isFirstPage() && page.hasPreviousPage(),page.getNumber(),""String_Node_Str"",pr.getLinks());
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isLastPage() && page.hasNextPage(),page.getNumber() + 2,""String_Node_Str"",pr.getLinks());
    resources=pr;
  }
 else {
    entities=Collections.singletonList(result).iterator();
  }
  while (entities.hasNext()) {
    Object obj=entities.next();
    RepositoryMetadata elemRepoMeta;
    if (null == (elemRepoMeta=repositoryMetadataFor(obj.getClass()))) {
      resources.addResource(new Resource(obj));
      continue;
    }
    String id=elemRepoMeta.entityMetadata().idAttribute().get(obj).toString();
    if (shouldReturnLinks(request.getServletRequest().getHeader(""String_Node_Str""))) {
      String rel=elemRepoMeta.rel() + ""String_Node_Str"" + elemRepoMeta.entityMetadata().type().getSimpleName();
      URI path=buildUri(baseUri,repository,id);
      resources.addLink(new SimpleLink(rel,path));
    }
 else {
      MapResource res=createResource(repoMeta.rel(),obj,repoMeta.entityMetadata(),buildUri(baseUri,repository,id));
      URI selfUri=buildUri(baseUri,repository,id);
      res.addLink(new SimpleLink(SELF,selfUri));
      resources.addResource(res);
    }
  }
  publishEvent(new BeforeRenderResourcesEvent(request,repoMeta,resources));
  return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),resources);
}","/** 
 * Invoke a custom query method on a repository and page the results based on URL parameters supplied by the user or the default page size.
 * @param request
 * @param pageSort
 * @param uriBuilder
 * @param repository
 * @param query
 * @return
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity<?> query(ServletServerHttpRequest request,PagingAndSorting pageSort,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String query) throws InvocationTargetException, IllegalAccessException, IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  Repository repo=repoMeta.repository();
  RepositoryQueryMethod queryMethod=repoMeta.queryMethod(query);
  if (null == queryMethod) {
    return notFoundResponse(request);
  }
  Class<?>[] paramTypes=queryMethod.paramTypes();
  String[] paramNames=queryMethod.paramNames();
  Object[] paramVals=new Object[paramTypes.length];
  for (int i=0; i < paramVals.length; i++) {
    if (Pageable.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=pageSort;
      continue;
    }
 else     if (Sort.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=(null != pageSort ? pageSort.getSort() : null);
      continue;
    }
    String queryVal;
    if (null == (queryVal=request.getServletRequest().getParameter(paramNames[i]))) {
      continue;
    }
    if (String.class.isAssignableFrom(paramTypes[i])) {
      paramVals[i]=queryVal;
    }
 else     if (hasRepositoryMetadataFor(paramTypes[i])) {
      RepositoryMetadata paramRepoMeta=repositoryMetadataFor(paramTypes[i]);
      Serializable id=stringToSerializable(queryVal,(Class<Serializable>)paramRepoMeta.entityMetadata().idAttribute().type());
      Object o=paramRepoMeta.repository().findOne(id);
      if (null == o) {
        return notFoundResponse(request);
      }
      paramVals[i]=o;
    }
 else     if (conversionService.canConvert(String.class,paramTypes[i])) {
      paramVals[i]=conversionService.convert(queryVal,paramTypes[i]);
    }
 else {
      try {
        paramVals[i]=objectMapper.readValue(queryVal,paramTypes[i]);
      }
 catch (      IOException e) {
        throw new IllegalArgumentException(e);
      }
    }
  }
  Object result;
  if (null == (result=queryMethod.method().invoke(repo,paramVals))) {
    return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),new Resources());
  }
  Resources resources=new Resources();
  Iterator entities=Collections.emptyList().iterator();
  if (result instanceof Collection) {
    entities=((Collection)result).iterator();
  }
 else   if (result instanceof Page) {
    Page page=(Page)result;
    if (page.hasContent()) {
      entities=page.iterator();
    }
    PageableResources pr=new PageableResources();
    pr.setResourceCount(page.getTotalElements());
    pr.setPaging(new PagingMetadata(page.getNumber() + 1,page.getTotalPages()));
    UriComponentsBuilder selfUri=UriComponentsBuilder.fromUri(baseUri).pathSegment(repository,""String_Node_Str"",query);
    for (    String name : request.getServletRequest().getParameterMap().keySet()) {
      if (notPagingParam(name)) {
        selfUri.queryParam(name,request.getServletRequest().getParameter(name));
      }
    }
    URI nextPrevBase=selfUri.build().toUri();
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isFirstPage() && page.hasPreviousPage(),page.getNumber(),""String_Node_Str"",pr.getLinks());
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isLastPage() && page.hasNextPage(),page.getNumber() + 2,""String_Node_Str"",pr.getLinks());
    resources=pr;
  }
 else {
    entities=Collections.singletonList(result).iterator();
  }
  while (entities.hasNext()) {
    Object obj=entities.next();
    RepositoryMetadata elemRepoMeta;
    if (null == (elemRepoMeta=repositoryMetadataFor(obj.getClass()))) {
      resources.addResource(new Resource(obj));
      continue;
    }
    String id=elemRepoMeta.entityMetadata().idAttribute().get(obj).toString();
    if (shouldReturnLinks(request.getServletRequest().getHeader(""String_Node_Str""))) {
      String rel=elemRepoMeta.rel() + ""String_Node_Str"" + elemRepoMeta.entityMetadata().type().getSimpleName();
      URI path=buildUri(baseUri,repository,id);
      resources.addLink(new SimpleLink(rel,path));
    }
 else {
      URI selfUri=buildUri(baseUri,repository,id);
      MapResource res=createResource(repoMeta.rel(),obj,repoMeta.entityMetadata(),selfUri);
      res.addLink(new SimpleLink(SELF,selfUri));
      resources.addResource(res);
    }
  }
  publishEvent(new BeforeRenderResourcesEvent(request,repoMeta,resources));
  return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),resources);
}",0.9872443814537356
8500,"/** 
 * List entities of a   {@link CrudRepository} by invoking{@link org.springframework.data.repository.CrudRepository#findAll()}and applying any available paging parameters.
 * @param request
 * @param pageSort
 * @param uriBuilder
 * @param repository
 * @return
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity<?> listEntities(ServletServerHttpRequest request,PagingAndSorting pageSort,UriComponentsBuilder uriBuilder,@PathVariable String repository) throws IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.FIND_ALL)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  Iterator allEntities=Collections.emptyList().iterator();
  final Resources resources;
  if (repoMeta.repository() instanceof PagingAndSortingRepository) {
    PageableResources pr=new PageableResources();
    Page page=((PagingAndSortingRepository)repoMeta.repository()).findAll(pageSort);
    if (page.hasContent()) {
      allEntities=page.iterator();
    }
    pr.setPaging(new PagingMetadata(page.getNumber() + 1,page.getTotalPages()));
    pr.setResourceCount(page.getTotalElements());
    UriComponentsBuilder selfUri=UriComponentsBuilder.fromUri(baseUri).pathSegment(repository);
    for (    String name : request.getServletRequest().getParameterMap().keySet()) {
      if (notPagingParam(name)) {
        selfUri.queryParam(name,request.getServletRequest().getParameter(name));
      }
    }
    URI nextPrevBase=selfUri.build().toUri();
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isFirstPage() && page.hasPreviousPage(),page.getNumber(),""String_Node_Str"",pr.getLinks());
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isLastPage() && page.hasNextPage(),page.getNumber() + 2,""String_Node_Str"",pr.getLinks());
    resources=pr;
  }
 else {
    Iterable it=repoMeta.repository().findAll();
    if (null != it) {
      allEntities=it.iterator();
    }
    resources=new Resources();
  }
  while (allEntities.hasNext()) {
    Object o=allEntities.next();
    Serializable id=(Serializable)repoMeta.entityMetadata().idAttribute().get(o);
    if (shouldReturnLinks(request.getServletRequest().getHeader(""String_Node_Str""))) {
      resources.addLink(new SimpleLink(repoMeta.rel() + ""String_Node_Str"" + o.getClass().getSimpleName(),buildUri(baseUri,repository,id.toString())));
    }
 else {
      MapResource res=createResource(repoMeta.rel(),o,repoMeta.entityMetadata(),buildUri(baseUri,repository,id.toString()));
      URI selfUri=buildUri(baseUri,repository,id.toString());
      res.addLink(new SimpleLink(SELF,selfUri));
      resources.addResource(res);
    }
  }
  if (!repoMeta.queryMethods().isEmpty()) {
    resources.addLink(new SimpleLink(repoMeta.rel() + ""String_Node_Str"",buildUri(baseUri,repository,""String_Node_Str"")));
  }
  publishEvent(new BeforeRenderResourcesEvent(request,repoMeta,resources));
  return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),resources);
}","/** 
 * List entities of a   {@link CrudRepository} by invoking{@link org.springframework.data.repository.CrudRepository#findAll()}and applying any available paging parameters.
 * @param request
 * @param pageSort
 * @param uriBuilder
 * @param repository
 * @return
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity<?> listEntities(ServletServerHttpRequest request,PagingAndSorting pageSort,UriComponentsBuilder uriBuilder,@PathVariable String repository) throws IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.FIND_ALL)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  Iterator allEntities=Collections.emptyList().iterator();
  final Resources resources;
  if (repoMeta.repository() instanceof PagingAndSortingRepository) {
    PageableResources pr=new PageableResources();
    Page page=((PagingAndSortingRepository)repoMeta.repository()).findAll(pageSort);
    if (page.hasContent()) {
      allEntities=page.iterator();
    }
    pr.setPaging(new PagingMetadata(page.getNumber() + 1,page.getTotalPages()));
    pr.setResourceCount(page.getTotalElements());
    UriComponentsBuilder selfUri=UriComponentsBuilder.fromUri(baseUri).pathSegment(repository);
    for (    String name : request.getServletRequest().getParameterMap().keySet()) {
      if (notPagingParam(name)) {
        selfUri.queryParam(name,request.getServletRequest().getParameter(name));
      }
    }
    URI nextPrevBase=selfUri.build().toUri();
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isFirstPage() && page.hasPreviousPage(),page.getNumber(),""String_Node_Str"",pr.getLinks());
    maybeAddPrevNextLink(nextPrevBase,repoMeta,pageSort,page,!page.isLastPage() && page.hasNextPage(),page.getNumber() + 2,""String_Node_Str"",pr.getLinks());
    resources=pr;
  }
 else {
    Iterable it=repoMeta.repository().findAll();
    if (null != it) {
      allEntities=it.iterator();
    }
    resources=new Resources();
  }
  while (allEntities.hasNext()) {
    Object o=allEntities.next();
    Serializable id=(Serializable)repoMeta.entityMetadata().idAttribute().get(o);
    if (shouldReturnLinks(request.getServletRequest().getHeader(""String_Node_Str""))) {
      resources.addLink(new SimpleLink(repoMeta.rel() + ""String_Node_Str"" + o.getClass().getSimpleName(),buildUri(baseUri,repository,id.toString())));
    }
 else {
      URI selfUri=buildUri(baseUri,repository,id.toString());
      MapResource res=createResource(repoMeta.rel(),o,repoMeta.entityMetadata(),selfUri);
      res.addLink(new SimpleLink(SELF,selfUri));
      resources.addResource(res);
    }
  }
  if (!repoMeta.queryMethods().isEmpty()) {
    resources.addLink(new SimpleLink(repoMeta.rel() + ""String_Node_Str"",buildUri(baseUri,repository,""String_Node_Str"")));
  }
  publishEvent(new BeforeRenderResourcesEvent(request,repoMeta,resources));
  return negotiateResponse(request,HttpStatus.OK,new HttpHeaders(),resources);
}",0.9662109068049662
8501,"/** 
 * Retrieve a linked entity from a parent entity.
 * @param request
 * @param uriBuilder
 * @param repository
 * @param id
 * @param property
 * @param linkedId
 * @return
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method={RequestMethod.GET}) @ResponseBody public ResponseEntity<?> linkedEntity(ServletServerHttpRequest request,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String id,@PathVariable String property,@PathVariable String linkedId) throws IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  CrudRepository repo=repoMeta.repository();
  Serializable serId=stringToSerializable(id,(Class<? extends Serializable>)repoMeta.entityMetadata().idAttribute().type());
  if (!repo.exists(serId)) {
    return notFoundResponse(request);
  }
  AttributeMetadata attrMeta;
  if (null == (attrMeta=repoMeta.entityMetadata().attribute(property))) {
    return notFoundResponse(request);
  }
  RepositoryMetadata linkedRepoMeta;
  if (null == (linkedRepoMeta=repositoryMetadataFor(attrMeta))) {
    return notFoundResponse(request);
  }
  if (!linkedRepoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  CrudRepository linkedRepo=linkedRepoMeta.repository();
  Serializable sChildId=stringToSerializable(linkedId,(Class<? extends Serializable>)linkedRepoMeta.entityMetadata().idAttribute().type());
  Object linkedEntity;
  if (null == (linkedEntity=linkedRepo.findOne(sChildId))) {
    return notFoundResponse(request);
  }
  MapResource res=createResource(linkedRepoMeta.rel(),linkedEntity,linkedRepoMeta.entityMetadata(),baseUri);
  URI selfUri=buildUri(baseUri,linkedRepoMeta.name(),linkedId);
  res.addLink(new SimpleLink(SELF,selfUri));
  publishEvent(new BeforeRenderResourcesEvent(request,repoMeta,res));
  HttpHeaders headers=new HttpHeaders();
  headers.add(""String_Node_Str"",selfUri.toString());
  return negotiateResponse(request,HttpStatus.OK,headers,res);
}","/** 
 * Retrieve a linked entity from a parent entity.
 * @param request
 * @param uriBuilder
 * @param repository
 * @param id
 * @param property
 * @param linkedId
 * @return
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method={RequestMethod.GET}) @ResponseBody public ResponseEntity<?> linkedEntity(ServletServerHttpRequest request,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String id,@PathVariable String property,@PathVariable String linkedId) throws IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  CrudRepository repo=repoMeta.repository();
  Serializable serId=stringToSerializable(id,(Class<? extends Serializable>)repoMeta.entityMetadata().idAttribute().type());
  if (!repo.exists(serId)) {
    return notFoundResponse(request);
  }
  AttributeMetadata attrMeta;
  if (null == (attrMeta=repoMeta.entityMetadata().attribute(property))) {
    return notFoundResponse(request);
  }
  RepositoryMetadata linkedRepoMeta;
  if (null == (linkedRepoMeta=repositoryMetadataFor(attrMeta))) {
    return notFoundResponse(request);
  }
  if (!linkedRepoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  CrudRepository linkedRepo=linkedRepoMeta.repository();
  Serializable sChildId=stringToSerializable(linkedId,(Class<? extends Serializable>)linkedRepoMeta.entityMetadata().idAttribute().type());
  Object linkedEntity;
  if (null == (linkedEntity=linkedRepo.findOne(sChildId))) {
    return notFoundResponse(request);
  }
  URI selfUri=buildUri(baseUri,linkedRepoMeta.name(),linkedId);
  MapResource res=createResource(linkedRepoMeta.rel(),linkedEntity,linkedRepoMeta.entityMetadata(),selfUri);
  res.addLink(new SimpleLink(SELF,selfUri));
  publishEvent(new BeforeRenderResourcesEvent(request,repoMeta,res));
  HttpHeaders headers=new HttpHeaders();
  headers.add(""String_Node_Str"",selfUri.toString());
  return negotiateResponse(request,HttpStatus.OK,headers,res);
}",0.9719298245614036
8502,"/** 
 * Retrieve a specific entity.
 * @param request
 * @param uriBuilder
 * @param repository
 * @param id
 * @return
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity<?> entity(ServletServerHttpRequest request,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String id) throws IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  Serializable serId=stringToSerializable(id,(Class<? extends Serializable>)repoMeta.entityMetadata().idAttribute().type());
  CrudRepository repo=repoMeta.repository();
  Object entity=repo.findOne(serId);
  if (null == entity) {
    return notFoundResponse(request);
  }
  HttpHeaders headers=new HttpHeaders();
  if (null != repoMeta.entityMetadata().versionAttribute()) {
    Object version=repoMeta.entityMetadata().versionAttribute().get(entity);
    if (null != version) {
      List<String> etags=request.getHeaders().getIfNoneMatch();
      for (      String etag : etags) {
        if ((""String_Node_Str"" + version.toString() + ""String_Node_Str"").equals(etag)) {
          return negotiateResponse(request,HttpStatus.NOT_MODIFIED,new HttpHeaders(),null);
        }
      }
      headers.set(""String_Node_Str"",""String_Node_Str"" + version.toString() + ""String_Node_Str"");
    }
  }
  MapResource res=createResource(repoMeta.rel(),entity,repoMeta.entityMetadata(),baseUri);
  URI selfUri=buildUri(baseUri,repository,id);
  res.addLink(new SimpleLink(SELF,selfUri));
  publishEvent(new BeforeRenderResourceEvent(request,repoMeta,res));
  return negotiateResponse(request,HttpStatus.OK,headers,res);
}","/** 
 * Retrieve a specific entity.
 * @param request
 * @param uriBuilder
 * @param repository
 * @param id
 * @return
 * @throws IOException
 */
@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseBody public ResponseEntity<?> entity(ServletServerHttpRequest request,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String id) throws IOException {
  URI baseUri=uriBuilder.build().toUri();
  RepositoryMetadata repoMeta=repositoryMetadataFor(repository);
  if (!repoMeta.exportsMethod(CrudMethod.FIND_ONE)) {
    return negotiateResponse(request,HttpStatus.METHOD_NOT_ALLOWED,new HttpHeaders(),null);
  }
  Serializable serId=stringToSerializable(id,(Class<? extends Serializable>)repoMeta.entityMetadata().idAttribute().type());
  CrudRepository repo=repoMeta.repository();
  Object entity=repo.findOne(serId);
  if (null == entity) {
    return notFoundResponse(request);
  }
  HttpHeaders headers=new HttpHeaders();
  if (null != repoMeta.entityMetadata().versionAttribute()) {
    Object version=repoMeta.entityMetadata().versionAttribute().get(entity);
    if (null != version) {
      List<String> etags=request.getHeaders().getIfNoneMatch();
      for (      String etag : etags) {
        if ((""String_Node_Str"" + version.toString() + ""String_Node_Str"").equals(etag)) {
          return negotiateResponse(request,HttpStatus.NOT_MODIFIED,new HttpHeaders(),null);
        }
      }
      headers.set(""String_Node_Str"",""String_Node_Str"" + version.toString() + ""String_Node_Str"");
    }
  }
  URI selfUri=buildUri(baseUri,repository,id);
  MapResource res=createResource(repoMeta.rel(),entity,repoMeta.entityMetadata(),selfUri);
  res.addLink(new SimpleLink(SELF,selfUri));
  publishEvent(new BeforeRenderResourceEvent(request,repoMeta,res));
  return negotiateResponse(request,HttpStatus.OK,headers,res);
}",0.9522058823529412
8503,"/** 
 * Set the List of   {@link RepositoryExporter}s.
 * @param repositoryExporters Export this {@link List} of {@link RepositoryExporter}s.
 * @return @this
 */
@SuppressWarnings({""String_Node_Str""}) public S repositoryExporters(List<RepositoryExporter> repositoryExporters){
  setRepositoryExporters(repositoryExporters);
  return (S)this;
}","/** 
 * Set the   {@link RepositoryExporter}s to use.
 * @param repositoryExporter
 * @return
 */
@SuppressWarnings({""String_Node_Str""}) public S repositoryExporters(RepositoryExporter... repositoryExporter){
  setRepositoryExporters(Arrays.asList(repositoryExporter));
  return (S)this;
}",0.5497630331753555
8504,"@Override protected void extendInterceptors(List<Object> interceptors){
  OpenEntityManagerInViewInterceptor omivi=new OpenEntityManagerInViewInterceptor();
  omivi.setEntityManagerFactory(entityManagerFactory);
  interceptors.add(omivi);
}","@Override protected void extendInterceptors(List<Object> interceptors){
  if (null != entityManagerFactory) {
    OpenEntityManagerInViewInterceptor omivi=new OpenEntityManagerInViewInterceptor();
    omivi.setEntityManagerFactory(entityManagerFactory);
    interceptors.add(omivi);
  }
}",0.9090909090909092
8505,"public RepositoryExporterHandlerMapping(EntityManagerFactory entityManagerFactory){
  this.entityManagerFactory=entityManagerFactory;
  setOrder(Ordered.HIGHEST_PRECEDENCE);
}","public RepositoryExporterHandlerMapping(){
  setOrder(Ordered.HIGHEST_PRECEDENCE);
}",0.6486486486486487
8506,"public RepositoryRestController httpMessageConverters(List<HttpMessageConverter<?>> httpMessageConverters){
  setHttpMessageConverters(httpMessageConverters);
  return this;
}","public RepositoryRestController httpMessageConverters(List<HttpMessageConverter> httpMessageConverters){
  setHttpMessageConverters(httpMessageConverters);
  return this;
}",0.9913544668587896
8507,"public void setHttpMessageConverters(List<HttpMessageConverter<?>> httpMessageConverters){
  Assert.notNull(httpMessageConverters);
  this.httpMessageConverters=httpMessageConverters;
}","public void setHttpMessageConverters(List<HttpMessageConverter> httpMessageConverters){
  Assert.notNull(httpMessageConverters);
  this.httpMessageConverters=httpMessageConverters;
}",0.9918256130790192
8508,"public List<HttpMessageConverter<?>> getHttpMessageConverters(){
  return httpMessageConverters;
}","public List<HttpMessageConverter> getHttpMessageConverters(){
  return httpMessageConverters;
}",0.9844559585492229
8509,"@Bean RepositoryExporterHandlerMapping repositoryExporterHandlerMapping(){
  if (null == repositoryExporterHandlerMapping) {
    repositoryExporterHandlerMapping=new RepositoryExporterHandlerMapping(entityManagerFactory);
  }
  return repositoryExporterHandlerMapping;
}","@Bean RepositoryExporterHandlerMapping repositoryExporterHandlerMapping(){
  return new RepositoryExporterHandlerMapping();
}",0.6278481012658228
8510,"@Bean ContentNegotiatingViewResolver contentNegotiatingViewResolver(){
  if (null == viewResolver) {
    viewResolver=new ContentNegotiatingViewResolver();
    viewResolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
    Map<String,String> mediaTypes=new HashMap<String,String>(){
{
        put(""String_Node_Str"",""String_Node_Str"");
        put(""String_Node_Str"",""String_Node_Str"");
      }
    }
;
    viewResolver.setMediaTypes(mediaTypes);
    RepositoryRestViewResolver jsonvr=new RepositoryRestViewResolver(jsonView());
    RepositoryRestViewResolver urilistvr=new RepositoryRestViewResolver(urilistView());
    viewResolver.setViewResolvers(Arrays.<ViewResolver>asList(jsonvr,urilistvr));
  }
  return viewResolver;
}","@Bean ContentNegotiatingViewResolver contentNegotiatingViewResolver(){
  ContentNegotiatingViewResolver viewResolver=new ContentNegotiatingViewResolver();
  viewResolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
  Map<String,String> mediaTypes=new HashMap<String,String>(){
{
      put(""String_Node_Str"",""String_Node_Str"");
      put(""String_Node_Str"",""String_Node_Str"");
    }
  }
;
  viewResolver.setMediaTypes(mediaTypes);
  RepositoryRestViewResolver jsonvr=new RepositoryRestViewResolver(jsonView());
  RepositoryRestViewResolver urilistvr=new RepositoryRestViewResolver(urilistView());
  viewResolver.setViewResolvers(Arrays.<ViewResolver>asList(jsonvr,urilistvr));
  return viewResolver;
}",0.8914123491838183
8511,"@Bean RepositoryRestController repositoryRestController() throws Exception {
  if (null == repositoryRestController) {
    this.repositoryRestController=new RepositoryRestController().repositoryExporters(Arrays.<RepositoryExporter>asList(jpaRepositoryExporter())).httpMessageConverters(repositoryExporterHandlerAdapter().getMessageConverters()).jsonMediaType(""String_Node_Str"");
  }
  return repositoryRestController;
}","@Bean RepositoryRestController repositoryRestController() throws Exception {
  return new RepositoryRestController();
}",0.4386617100371747
8512,"@Bean RepositoryExporterHandlerAdapter repositoryExporterHandlerAdapter(){
  if (null == repositoryExporterHandlerAdapter) {
    repositoryExporterHandlerAdapter=new RepositoryExporterHandlerAdapter();
  }
  return repositoryExporterHandlerAdapter;
}","@Bean RepositoryExporterHandlerAdapter repositoryExporterHandlerAdapter(){
  return new RepositoryExporterHandlerAdapter();
}",0.6613333333333333
8513,"@SuppressWarnings({""String_Node_Str""}) public JpaEntityMetadata(Repositories repositories,EntityType<?> entityType){
  type=entityType.getJavaType();
  idAttribute=new JpaAttributeMetadata(entityType,entityType.getId(entityType.getIdType().getJavaType()));
  if (null != entityType.getVersion(Long.class)) {
    versionAttribute=new JpaAttributeMetadata(entityType,entityType.getVersion(Long.class));
  }
  for (  Attribute attr : entityType.getAttributes()) {
    Class<?> attrType=(attr instanceof PluralAttribute ? ((PluralAttribute)attr).getElementType().getJavaType() : attr.getJavaType());
    if (repositories.hasRepositoryFor(attrType)) {
      linkedAttributes.put(attr.getName(),new JpaAttributeMetadata(entityType,attr));
    }
 else {
      if (attr != idAttribute && attr != versionAttribute) {
        embeddedAttributes.put(attr.getName(),new JpaAttributeMetadata(entityType,attr));
      }
    }
  }
}","@SuppressWarnings({""String_Node_Str""}) public JpaEntityMetadata(Repositories repositories,EntityType<?> entityType){
  type=entityType.getJavaType();
  idAttribute=new JpaAttributeMetadata(entityType,entityType.getId(entityType.getIdType().getJavaType()));
  if (null != entityType.getVersion(Long.class)) {
    versionAttribute=new JpaAttributeMetadata(entityType,entityType.getVersion(Long.class));
  }
  for (  Attribute attr : entityType.getAttributes()) {
    Class<?> attrType=(attr instanceof PluralAttribute ? ((PluralAttribute)attr).getElementType().getJavaType() : attr.getJavaType());
    if (repositories.hasRepositoryFor(attrType)) {
      linkedAttributes.put(attr.getName(),new JpaAttributeMetadata(entityType,attr));
    }
 else {
      if (!(attr instanceof SingularAttribute && ((SingularAttribute)attr).isId()) && !(attr instanceof SingularAttribute && ((SingularAttribute)attr).isVersion())) {
        embeddedAttributes.put(attr.getName(),new JpaAttributeMetadata(entityType,attr));
      }
    }
  }
}",0.91340206185567
8514,"@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method={RequestMethod.PUT,RequestMethod.POST},consumes={""String_Node_Str""},produces={""String_Node_Str""}) public void createOrUpdate(ServerHttpRequest request,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String id,Model model){
  URI baseUri=uriBuilder.build().toUri();
  CrudRepository repo=repositoryMetadata.repositoryFor(repository);
  if (null == repo) {
    model.addAttribute(STATUS,HttpStatus.NOT_IMPLEMENTED);
    return;
  }
  final TypeMetaCacheEntry typeMeta=typeMetaEntry(repo);
  Serializable serId=stringToSerializable(id,typeMeta.idType);
  Object entity=null;
switch (request.getMethod()) {
case POST:
    try {
      entity=typeMeta.domainClass.newInstance();
    }
 catch (    InstantiationException e) {
      model.addAttribute(STATUS,HttpStatus.INTERNAL_SERVER_ERROR);
      LOG.error(e.getMessage(),e);
      return;
    }
catch (    IllegalAccessException e) {
      model.addAttribute(STATUS,HttpStatus.INTERNAL_SERVER_ERROR);
      LOG.error(e.getMessage(),e);
      return;
    }
  break;
case PUT:
entity=repo.findOne(serId);
break;
}
if (null == entity) {
model.addAttribute(STATUS,HttpStatus.NOT_FOUND);
}
 else {
final MediaType incomingMediaType=request.getHeaders().getContentType();
try {
if (request.getMethod() == HttpMethod.POST) {
final Object incoming=readIncoming(request,incomingMediaType,typeMeta.domainClass);
if (null == incoming) {
  model.addAttribute(STATUS,HttpStatus.BAD_REQUEST);
}
 else {
  typeMeta.entityMetadata.id(serId,incoming);
  Object savedEntity=repo.save(entity);
  String savedId=typeMeta.entityInfo.getId(savedEntity).toString();
  URI selfUri=buildUri(baseUri,repository,savedId);
  HttpHeaders headers=new HttpHeaders();
  headers.set(LOCATION,selfUri.toString());
  model.addAttribute(HEADERS,headers);
  model.addAttribute(STATUS,HttpStatus.CREATED);
}
}
 else {
final Map incoming=readIncoming(request,incomingMediaType,Map.class);
if (null == incoming) {
  model.addAttribute(STATUS,HttpStatus.BAD_REQUEST);
}
 else {
  for (  Map.Entry<String,Attribute> entry : typeMeta.entityMetadata.embeddedAttributes().entrySet()) {
    String name=entry.getKey();
    if (incoming.containsKey(name)) {
      typeMeta.entityMetadata.set(name,incoming.get(name),entity);
    }
  }
  repo.save(entity);
  model.addAttribute(STATUS,HttpStatus.NO_CONTENT);
}
}
}
 catch (IOException e) {
model.addAttribute(STATUS,HttpStatus.BAD_REQUEST);
LOG.error(e.getMessage(),e);
}
}
}","@SuppressWarnings({""String_Node_Str""}) @RequestMapping(value=""String_Node_Str"",method={RequestMethod.PUT,RequestMethod.POST},consumes={""String_Node_Str""},produces={""String_Node_Str""}) public void createOrUpdate(ServerHttpRequest request,UriComponentsBuilder uriBuilder,@PathVariable String repository,@PathVariable String id,Model model){
  URI baseUri=uriBuilder.build().toUri();
  CrudRepository repo=repositoryMetadata.repositoryFor(repository);
  if (null == repo) {
    model.addAttribute(STATUS,HttpStatus.NOT_IMPLEMENTED);
    return;
  }
  final TypeMetaCacheEntry typeMeta=typeMetaEntry(repo);
  Serializable serId=stringToSerializable(id,typeMeta.idType);
  Object entity=null;
switch (request.getMethod()) {
case POST:
    try {
      entity=typeMeta.domainClass.newInstance();
    }
 catch (    InstantiationException e) {
      model.addAttribute(STATUS,HttpStatus.INTERNAL_SERVER_ERROR);
      LOG.error(e.getMessage(),e);
      return;
    }
catch (    IllegalAccessException e) {
      model.addAttribute(STATUS,HttpStatus.INTERNAL_SERVER_ERROR);
      LOG.error(e.getMessage(),e);
      return;
    }
  break;
case PUT:
entity=repo.findOne(serId);
break;
}
if (null == entity) {
model.addAttribute(STATUS,HttpStatus.NOT_FOUND);
}
 else {
final MediaType incomingMediaType=request.getHeaders().getContentType();
try {
final Object incoming=readIncoming(request,incomingMediaType,typeMeta.domainClass);
if (null == incoming) {
model.addAttribute(STATUS,HttpStatus.BAD_REQUEST);
}
 else {
if (request.getMethod() == HttpMethod.POST) {
  typeMeta.entityMetadata.id(serId,incoming);
  Object savedEntity=repo.save(entity);
  String savedId=typeMeta.entityInfo.getId(savedEntity).toString();
  URI selfUri=buildUri(baseUri,repository,savedId);
  HttpHeaders headers=new HttpHeaders();
  headers.set(LOCATION,selfUri.toString());
  model.addAttribute(HEADERS,headers);
  model.addAttribute(STATUS,HttpStatus.CREATED);
}
 else {
  for (  Map.Entry<String,Attribute> entry : typeMeta.entityMetadata.embeddedAttributes().entrySet()) {
    String name=entry.getKey();
    Object o=typeMeta.entityMetadata.get(name,incoming);
    if (null != o) {
      typeMeta.entityMetadata.set(name,o,entity);
    }
  }
  repo.save(entity);
  model.addAttribute(STATUS,HttpStatus.NO_CONTENT);
}
}
}
 catch (IOException e) {
model.addAttribute(STATUS,HttpStatus.BAD_REQUEST);
LOG.error(e.getMessage(),e);
}
}
}",0.8186234817813766
8515,"public Principal getUser(final HttpServletRequest request,final HttpServletResponse response){
  final HttpSession session=request.getSession();
  if (session.getAttribute(LOGGED_IN_KEY) != null) {
    LOGGER.debug(""String_Node_Str"");
    return (Principal)session.getAttribute(LOGGED_IN_KEY);
  }
  final Assertion assertion=(Assertion)session.getAttribute(AbstractCasFilter.CONST_CAS_ASSERTION);
  if (assertion != null) {
    final Principal p=getUser(assertion.getPrincipal().getName());
    if (p == null) {
      LOGGER.error(""String_Node_Str"",assertion.getPrincipal().getName());
    }
    LOGGER.debug(""String_Node_Str"",p.getName());
    session.setAttribute(LOGGED_IN_KEY,p);
    session.setAttribute(LOGGED_OUT_KEY,null);
    return p;
  }
  return super.getUser(request,response);
}","public Principal getUser(final HttpServletRequest request,final HttpServletResponse response){
  final HttpSession session=request.getSession();
  if (session.getAttribute(LOGGED_IN_KEY) != null) {
    LOGGER.debug(""String_Node_Str"");
    return (Principal)session.getAttribute(LOGGED_IN_KEY);
  }
  final Assertion assertion=(Assertion)session.getAttribute(AbstractCasFilter.CONST_CAS_ASSERTION);
  if (assertion != null) {
    final Principal p=getUser(assertion.getPrincipal().getName());
    if (p == null) {
      LOGGER.error(""String_Node_Str"",assertion.getPrincipal().getName());
      return null;
    }
    LOGGER.debug(""String_Node_Str"",p.getName());
    session.setAttribute(LOGGED_IN_KEY,p);
    session.setAttribute(LOGGED_OUT_KEY,null);
    return p;
  }
  return super.getUser(request,response);
}",0.9881619937694704
8516,"protected void initInternal(final FilterConfig filterConfig) throws ServletException {
  if (!isIgnoreInitConfiguration()) {
    super.initInternal(filterConfig);
    setCasServerLoginUrl(getPropertyFromInitParams(filterConfig,""String_Node_Str"",null));
    logger.trace(""String_Node_Str"",this.casServerLoginUrl);
    setRenew(parseBoolean(getPropertyFromInitParams(filterConfig,""String_Node_Str"",""String_Node_Str"")));
    logger.trace(""String_Node_Str"",this.renew);
    setGateway(parseBoolean(getPropertyFromInitParams(filterConfig,""String_Node_Str"",""String_Node_Str"")));
    logger.trace(""String_Node_Str"",this.gateway);
    final String ignorePattern=getPropertyFromInitParams(filterConfig,""String_Node_Str"",null);
    logger.trace(""String_Node_Str"",ignorePattern);
    final String ignoreUrlPatternType=getPropertyFromInitParams(filterConfig,""String_Node_Str"",""String_Node_Str"");
    logger.trace(""String_Node_Str"",ignoreUrlPatternType);
    if (ignorePattern != null) {
      final Class<? extends UrlPatternMatcherStrategy> ignoreUrlMatcherClass=this.PATTERN_MATCHER_TYPES.get(ignoreUrlPatternType);
      if (ignoreUrlMatcherClass != null) {
        this.ignoreUrlPatternMatcherStrategyClass=ReflectUtils.newInstance(ignoreUrlMatcherClass.getName());
      }
 else {
        try {
          logger.trace(""String_Node_Str"",ignoreUrlPatternType);
          this.ignoreUrlPatternMatcherStrategyClass=ReflectUtils.newInstance(ignoreUrlPatternType);
        }
 catch (        final IllegalArgumentException e) {
          logger.warn(""String_Node_Str"",ignoreUrlPatternType,e.getMessage());
        }
      }
      if (this.ignoreUrlPatternMatcherStrategyClass != null) {
        this.ignoreUrlPatternMatcherStrategyClass.setPattern(ignorePattern);
      }
    }
    final String gatewayStorageClass=getPropertyFromInitParams(filterConfig,""String_Node_Str"",null);
    if (gatewayStorageClass != null) {
      this.gatewayStorage=ReflectUtils.newInstance(gatewayStorageClass);
    }
    final String authenticationRedirectStrategyClass=getPropertyFromInitParams(filterConfig,""String_Node_Str"",null);
    if (authenticationRedirectStrategyClass != null) {
      this.authenticationRedirectStrategy=ReflectUtils.newInstance(authenticationRedirectStrategyClass);
    }
  }
}","protected void initInternal(final FilterConfig filterConfig) throws ServletException {
  if (!isIgnoreInitConfiguration()) {
    super.initInternal(filterConfig);
    setCasServerLoginUrl(getPropertyFromInitParams(filterConfig,""String_Node_Str"",null));
    logger.trace(""String_Node_Str"",this.casServerLoginUrl);
    setRenew(parseBoolean(getPropertyFromInitParams(filterConfig,""String_Node_Str"",""String_Node_Str"")));
    logger.trace(""String_Node_Str"",this.renew);
    setGateway(parseBoolean(getPropertyFromInitParams(filterConfig,""String_Node_Str"",""String_Node_Str"")));
    logger.trace(""String_Node_Str"",this.gateway);
    final String ignorePattern=getPropertyFromInitParams(filterConfig,""String_Node_Str"",null);
    logger.trace(""String_Node_Str"",ignorePattern);
    final String ignoreUrlPatternType=getPropertyFromInitParams(filterConfig,""String_Node_Str"",""String_Node_Str"");
    logger.trace(""String_Node_Str"",ignoreUrlPatternType);
    if (ignorePattern != null) {
      final Class<? extends UrlPatternMatcherStrategy> ignoreUrlMatcherClass=PATTERN_MATCHER_TYPES.get(ignoreUrlPatternType);
      if (ignoreUrlMatcherClass != null) {
        this.ignoreUrlPatternMatcherStrategyClass=ReflectUtils.newInstance(ignoreUrlMatcherClass.getName());
      }
 else {
        try {
          logger.trace(""String_Node_Str"",ignoreUrlPatternType);
          this.ignoreUrlPatternMatcherStrategyClass=ReflectUtils.newInstance(ignoreUrlPatternType);
        }
 catch (        final IllegalArgumentException e) {
          logger.error(""String_Node_Str"",ignoreUrlPatternType,e);
        }
      }
      if (this.ignoreUrlPatternMatcherStrategyClass != null) {
        this.ignoreUrlPatternMatcherStrategyClass.setPattern(ignorePattern);
      }
    }
    final String gatewayStorageClass=getPropertyFromInitParams(filterConfig,""String_Node_Str"",null);
    if (gatewayStorageClass != null) {
      this.gatewayStorage=ReflectUtils.newInstance(gatewayStorageClass);
    }
    final String authenticationRedirectStrategyClass=getPropertyFromInitParams(filterConfig,""String_Node_Str"",null);
    if (authenticationRedirectStrategyClass != null) {
      this.authenticationRedirectStrategy=ReflectUtils.newInstance(authenticationRedirectStrategyClass);
    }
  }
}",0.9940331491712708
8517,"/** 
 * Configures the connection with specific settings for secure http connections If the connection instance is not a   {@link HttpsURLConnection}, no additional changes will be made and the connection itself is simply returned.
 * @param conn the http connection
 */
private URLConnection configureHttpsConnectionIfNeeded(final URLConnection conn){
  if (conn instanceof HttpsURLConnection) {
    final HttpsURLConnection httpsConnection=(HttpsURLConnection)conn;
    final SSLSocketFactory socketFactory=this.createSSLSocketFactory();
    if (socketFactory != null) {
      httpsConnection.setSSLSocketFactory(socketFactory);
    }
    if (this.hostnameVerifier != null) {
      httpsConnection.setHostnameVerifier(this.hostnameVerifier);
    }
  }
  return conn;
}","/** 
 * Configures the connection with specific settings for secure http connections If the connection instance is not a   {@link HttpsURLConnection}, no additional changes will be made and the connection itself is simply returned.
 * @param conn the http connection
 */
private HttpURLConnection configureHttpsConnectionIfNeeded(final URLConnection conn){
  if (conn instanceof HttpsURLConnection) {
    final HttpsURLConnection httpsConnection=(HttpsURLConnection)conn;
    final SSLSocketFactory socketFactory=this.createSSLSocketFactory();
    if (socketFactory != null) {
      httpsConnection.setSSLSocketFactory(socketFactory);
    }
    if (this.hostnameVerifier != null) {
      httpsConnection.setHostnameVerifier(this.hostnameVerifier);
    }
  }
  return (HttpURLConnection)conn;
}",0.9852847088931542
8518,"/** 
 * Contacts the remote URL and returns the response.
 * @param url the url to contact.
 * @param encoding the encoding to use.
 * @return the response.
 */
public static String getResponseFromServer(final String url,String encoding){
  try {
    return getResponseFromServer(new URL(url),new HttpsURLConnectionFactory(),encoding);
  }
 catch (  final MalformedURLException e) {
    throw new IllegalArgumentException(e);
  }
}","/** 
 * Contacts the remote URL and returns the response.
 * @param url the url to contact.
 * @param encoding the encoding to use.
 * @return the response.
 */
public static String getResponseFromServer(final String url,String encoding){
  try {
    return getResponseFromServer(new URL(url),HttpsURLConnectionFactory.INSTANCE,encoding);
  }
 catch (  final MalformedURLException e) {
    throw new IllegalArgumentException(e);
  }
}",0.9826589595375722
8519,"protected String retrieveResponseFromServer(final URL validationUrl,final String ticket){
  final String MESSAGE_TO_SEND=""String_Node_Str"" + this.identifierGenerator.generateIdentifier() + ""String_Node_Str""+ CommonUtils.formatForUtcTime(new Date())+ ""String_Node_Str""+ ""String_Node_Str""+ ticket+ ""String_Node_Str"";
  HttpURLConnection conn=null;
  DataOutputStream out=null;
  BufferedReader in=null;
  try {
    conn=(HttpURLConnection)this.getURLConnectionFactory().getURLConnection(validationUrl.openConnection());
    conn.setRequestMethod(""String_Node_Str"");
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    conn.setRequestProperty(""String_Node_Str"",Integer.toString(MESSAGE_TO_SEND.length()));
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    conn.setUseCaches(false);
    conn.setDoInput(true);
    conn.setDoOutput(true);
    out=new DataOutputStream(conn.getOutputStream());
    out.writeBytes(MESSAGE_TO_SEND);
    out.flush();
    in=new BufferedReader(CommonUtils.isNotBlank(getEncoding()) ? new InputStreamReader(conn.getInputStream(),Charset.forName(getEncoding())) : new InputStreamReader(conn.getInputStream()));
    final StringBuilder buffer=new StringBuilder(256);
    String line;
    while ((line=in.readLine()) != null) {
      buffer.append(line);
    }
    return buffer.toString();
  }
 catch (  final IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    CommonUtils.closeQuietly(out);
    CommonUtils.closeQuietly(in);
    if (conn != null) {
      conn.disconnect();
    }
  }
}","protected String retrieveResponseFromServer(final URL validationUrl,final String ticket){
  final String MESSAGE_TO_SEND=""String_Node_Str"" + this.identifierGenerator.generateIdentifier() + ""String_Node_Str""+ CommonUtils.formatForUtcTime(new Date())+ ""String_Node_Str""+ ""String_Node_Str""+ ticket+ ""String_Node_Str"";
  HttpURLConnection conn=null;
  DataOutputStream out=null;
  BufferedReader in=null;
  try {
    conn=this.getURLConnectionFactory().buildHttpURLConnection(validationUrl.openConnection());
    conn.setRequestMethod(""String_Node_Str"");
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    conn.setRequestProperty(""String_Node_Str"",Integer.toString(MESSAGE_TO_SEND.length()));
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    conn.setUseCaches(false);
    conn.setDoInput(true);
    conn.setDoOutput(true);
    out=new DataOutputStream(conn.getOutputStream());
    out.writeBytes(MESSAGE_TO_SEND);
    out.flush();
    in=new BufferedReader(CommonUtils.isNotBlank(getEncoding()) ? new InputStreamReader(conn.getInputStream(),Charset.forName(getEncoding())) : new InputStreamReader(conn.getInputStream()));
    final StringBuilder buffer=new StringBuilder(256);
    String line;
    while ((line=in.readLine()) != null) {
      buffer.append(line);
    }
    return buffer.toString();
  }
 catch (  final IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    CommonUtils.closeQuietly(out);
    CommonUtils.closeQuietly(in);
    if (conn != null) {
      conn.disconnect();
    }
  }
}",0.9785049727301892
8520,"public String getProxyTicketIdFor(final String proxyGrantingTicketId,final String targetService){
  try {
    final String url=constructUrl(proxyGrantingTicketId,targetService);
    final String response=CommonUtils.getResponseFromServer(new URL(url),this.urlConnectionFactory,this.encoding);
    final String error=XmlUtils.getTextForElement(response,""String_Node_Str"");
    if (CommonUtils.isNotEmpty(error)) {
      logger.debug(error);
      return null;
    }
    return XmlUtils.getTextForElement(response,""String_Node_Str"");
  }
 catch (  final MalformedURLException ex) {
    throw new RuntimeException(ex);
  }
}","public String getProxyTicketIdFor(final String proxyGrantingTicketId,final String targetService){
  CommonUtils.assertNotNull(proxyGrantingTicketId,""String_Node_Str"");
  CommonUtils.assertNotNull(targetService,""String_Node_Str"");
  final URL url=constructUrl(proxyGrantingTicketId,targetService);
  final String response=CommonUtils.getResponseFromServer(url,this.urlConnectionFactory,this.encoding);
  final String error=XmlUtils.getTextForElement(response,""String_Node_Str"");
  if (CommonUtils.isNotEmpty(error)) {
    logger.debug(error);
    return null;
  }
  return XmlUtils.getTextForElement(response,""String_Node_Str"");
}",0.7248
8521,"private String constructUrl(final String proxyGrantingTicketId,final String targetService){
  try {
    return this.casServerUrl + (this.casServerUrl.endsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ proxyGrantingTicketId+ ""String_Node_Str""+ URLEncoder.encode(targetService,""String_Node_Str"");
  }
 catch (  final UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
}","private URL constructUrl(final String proxyGrantingTicketId,final String targetService){
  try {
    return new URL(this.casServerUrl + (this.casServerUrl.endsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ proxyGrantingTicketId+ ""String_Node_Str""+ URLEncoder.encode(targetService,""String_Node_Str""));
  }
 catch (  final Exception e) {
    throw new RuntimeException(e);
  }
}",0.9580022701475596
8522,"public boolean commitUpdates(){
  throw new SecurityException(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") public boolean commitUpdates(){
  throw new SecurityException(""String_Node_Str"");
}",0.8177339901477833
8523,"public boolean deleteRow(){
  throw new SecurityException(""String_Node_Str"");
}","@SuppressWarnings(""String_Node_Str"") public boolean deleteRow(){
  throw new SecurityException(""String_Node_Str"");
}",0.8102564102564103
8524,"private static String chooseFullPath(Context context,String url,String hint,String contentDisposition,String contentLocation,String mimeType,int destination,long contentLength) throws GenerateSaveFileError {
  File base=locateDestinationDirectory(context,mimeType,destination,contentLength);
  String filename=chooseFilename(url,hint,contentDisposition,contentLocation,destination);
  String extension=null;
  int dotIndex=filename.indexOf('.');
  if (dotIndex < 0) {
    extension=chooseExtensionFromMimeType(mimeType,true);
  }
 else {
    extension=chooseExtensionFromFilename(mimeType,destination,filename,dotIndex);
    filename=filename.substring(0,dotIndex);
  }
  boolean recoveryDir=Constants.RECOVERY_DIRECTORY.equalsIgnoreCase(filename + extension);
  filename=base.getPath() + File.separator + filename;
  if (Constants.LOGVV) {
    Log.v(Constants.TAG,""String_Node_Str"" + filename + extension);
  }
  return chooseUniqueFilename(destination,filename,extension,recoveryDir);
}","private static String chooseFullPath(Context context,String url,String hint,String contentDisposition,String contentLocation,String mimeType,int destination,long contentLength) throws GenerateSaveFileError {
  File base=locateDestinationDirectory(context,mimeType,destination,contentLength);
  return generateFilePath(base.getPath(),url,contentDisposition,contentLocation,mimeType,destination,contentLength);
}",0.5207439198855508
8525,"private static String getPathForFileUri(String hint,long contentLength) throws GenerateSaveFileError {
  if (!isExternalMediaMounted()) {
    throw new GenerateSaveFileError(Downloads.STATUS_DEVICE_NOT_FOUND_ERROR,""String_Node_Str"");
  }
  String path=Uri.parse(hint).getPath();
  if (new File(path).exists()) {
    Log.d(Constants.TAG,""String_Node_Str"" + path);
    throw new GenerateSaveFileError(Downloads.STATUS_FILE_ALREADY_EXISTS_ERROR,""String_Node_Str"");
  }
  if (getAvailableBytes(getFilesystemRoot(path)) < contentLength) {
    throw new GenerateSaveFileError(Downloads.STATUS_INSUFFICIENT_SPACE_ERROR,""String_Node_Str"");
  }
  return path;
}","private static String getPathForFileUri(String url,String hint,String contentDisposition,String contentLocation,String mimeType,int destination,long contentLength) throws GenerateSaveFileError {
  if (!isExternalMediaMounted()) {
    throw new GenerateSaveFileError(Downloads.STATUS_DEVICE_NOT_FOUND_ERROR,""String_Node_Str"");
  }
  String path=Uri.parse(hint).getPath();
  if (path.endsWith(""String_Node_Str"")) {
    String basePath=path.substring(0,path.length() - 1);
    path=generateFilePath(basePath,url,contentDisposition,contentLocation,mimeType,destination,contentLength);
  }
 else   if (new File(path).exists()) {
    Log.d(Constants.TAG,""String_Node_Str"" + path);
    throw new GenerateSaveFileError(Downloads.STATUS_FILE_ALREADY_EXISTS_ERROR,""String_Node_Str"");
  }
  if (getAvailableBytes(getFilesystemRoot(path)) < contentLength) {
    throw new GenerateSaveFileError(Downloads.STATUS_INSUFFICIENT_SPACE_ERROR,""String_Node_Str"");
  }
  return path;
}",0.801980198019802
8526,"/** 
 * Creates a filename (where the file should be saved) from info about a download.
 */
public static String generateSaveFile(Context context,String url,String hint,String contentDisposition,String contentLocation,String mimeType,int destination,long contentLength,boolean isPublicApi) throws GenerateSaveFileError {
  checkCanHandleDownload(context,mimeType,destination,isPublicApi);
  if (destination == Downloads.DESTINATION_FILE_URI && !hint.trim().endsWith(""String_Node_Str"")) {
    return getPathForFileUri(hint,contentLength);
  }
 else {
    return chooseFullPath(context,url,hint,contentDisposition,contentLocation,mimeType,destination,contentLength);
  }
}","/** 
 * Creates a filename (where the file should be saved) from info about a download.
 */
public static String generateSaveFile(Context context,String url,String hint,String contentDisposition,String contentLocation,String mimeType,int destination,long contentLength,boolean isPublicApi) throws GenerateSaveFileError {
  checkCanHandleDownload(context,mimeType,destination,isPublicApi);
  if (destination == Downloads.DESTINATION_FILE_URI) {
    return getPathForFileUri(url,hint,contentDisposition,contentLocation,mimeType,destination,contentLength);
  }
 else {
    return chooseFullPath(context,url,hint,contentDisposition,contentLocation,mimeType,destination,contentLength);
  }
}",0.8702064896755162
8527,"private ServiceMethodDefinition buildServiceMethodDefinition(ServiceMethodBean serviceMethodBean,ServiceMethod serviceMethod){
  ServiceMethodDefinition definition=new ServiceMethodDefinition();
  definition.setMethodGroup(serviceMethodBean.group());
  definition.setMethodGroupTitle(serviceMethodBean.groupTitle());
  definition.setTags(serviceMethodBean.tags());
  definition.setTimeout(serviceMethodBean.timeout());
  definition.setIgnoreSign(IgnoreSignType.isIgnoreSign(serviceMethodBean.ignoreSign()));
  definition.setVersion(serviceMethodBean.version());
  definition.setNeedInSession(NeedInSessionType.isNeedInSession(serviceMethodBean.needInSession()));
  definition.setHttpAction(serviceMethodBean.httpAction());
  definition.setObsoleted(ObsoletedType.isObsoleted(serviceMethodBean.obsoleted()));
  definition.setMethod(serviceMethod.method());
  definition.setMethodTitle(serviceMethod.title());
  if (!ServiceMethodDefinition.DEFAULT_GROUP.equals(serviceMethod.group())) {
    definition.setMethodGroup(serviceMethod.group());
  }
  if (!ServiceMethodDefinition.DEFAULT_GROUP_TITLE.equals(serviceMethod.groupTitle())) {
    definition.setMethodGroupTitle(serviceMethod.groupTitle());
  }
  if (serviceMethod.tags() != null && serviceMethod.tags().length > 0) {
    definition.setTags(serviceMethod.tags());
  }
  if (serviceMethod.timeout() != definition.getTimeout()) {
    definition.setTimeout(serviceMethod.timeout());
  }
  if (serviceMethod.ignoreSign() != IgnoreSignType.DEFAULT) {
    definition.setIgnoreSign(IgnoreSignType.isIgnoreSign(serviceMethod.ignoreSign()));
  }
  if (StringUtils.hasText(serviceMethod.version())) {
    definition.setVersion(serviceMethod.version());
  }
  if (serviceMethod.needInSession() != NeedInSessionType.DEFAULT) {
    definition.setNeedInSession(NeedInSessionType.isNeedInSession(serviceMethod.needInSession()));
  }
  if (serviceMethod.obsoleted() != ObsoletedType.DEFAULT) {
    definition.setObsoleted(ObsoletedType.isObsoleted(serviceMethod.obsoleted()));
  }
  if (serviceMethod.httpAction().length > 0) {
    definition.setHttpAction(serviceMethod.httpAction());
  }
  return definition;
}","private ServiceMethodDefinition buildServiceMethodDefinition(ServiceMethodBean serviceMethodBean,ServiceMethod serviceMethod){
  ServiceMethodDefinition definition=new ServiceMethodDefinition();
  definition.setMethodGroup(serviceMethodBean.group());
  definition.setMethodGroupTitle(serviceMethodBean.groupTitle());
  definition.setTags(serviceMethodBean.tags());
  definition.setTimeout(serviceMethodBean.timeout());
  definition.setIgnoreSign(IgnoreSignType.isIgnoreSign(serviceMethodBean.ignoreSign()));
  definition.setVersion(serviceMethodBean.version());
  definition.setNeedInSession(NeedInSessionType.isNeedInSession(serviceMethodBean.needInSession()));
  definition.setHttpAction(serviceMethodBean.httpAction());
  definition.setObsoleted(ObsoletedType.isObsoleted(serviceMethodBean.obsoleted()));
  definition.setMethod(serviceMethod.method());
  definition.setMethodTitle(serviceMethod.title());
  if (!ServiceMethodDefinition.DEFAULT_GROUP.equals(serviceMethod.group())) {
    definition.setMethodGroup(serviceMethod.group());
  }
  if (!ServiceMethodDefinition.DEFAULT_GROUP_TITLE.equals(serviceMethod.groupTitle())) {
    definition.setMethodGroupTitle(serviceMethod.groupTitle());
  }
  if (serviceMethod.tags() != null && serviceMethod.tags().length > 0) {
    definition.setTags(serviceMethod.tags());
  }
  if (serviceMethod.timeout() > 0) {
    definition.setTimeout(serviceMethod.timeout());
  }
  if (serviceMethod.ignoreSign() != IgnoreSignType.DEFAULT) {
    definition.setIgnoreSign(IgnoreSignType.isIgnoreSign(serviceMethod.ignoreSign()));
  }
  if (StringUtils.hasText(serviceMethod.version())) {
    definition.setVersion(serviceMethod.version());
  }
  if (serviceMethod.needInSession() != NeedInSessionType.DEFAULT) {
    definition.setNeedInSession(NeedInSessionType.isNeedInSession(serviceMethod.needInSession()));
  }
  if (serviceMethod.obsoleted() != ObsoletedType.DEFAULT) {
    definition.setObsoleted(ObsoletedType.isObsoleted(serviceMethod.obsoleted()));
  }
  if (serviceMethod.httpAction().length > 0) {
    definition.setHttpAction(serviceMethod.httpAction());
  }
  return definition;
}",0.993225881803317
8528,"@Test public void testIngoreSignField(){
  ApplicationContext context=mock(ApplicationContext.class);
  when(context.getBeanNamesForType(Object.class)).thenReturn(new String[]{""String_Node_Str""});
  Class serviceClass=IgnoreSignRopRequestService.class;
  when(context.getType(""String_Node_Str"")).thenReturn(serviceClass);
  RopContext ropContext=new DefaultRopContext(context);
  ServiceMethodHandler method1=ropContext.getServiceMethodHandler(""String_Node_Str"",""String_Node_Str"");
  List<String> ignoreSignFieldNames=method1.getIgnoreSignFieldNames();
  assertNotNull(ignoreSignFieldNames);
  assertEquals(ignoreSignFieldNames.size(),3);
  assertTrue(ignoreSignFieldNames.contains(""String_Node_Str""));
  assertTrue(ignoreSignFieldNames.contains(""String_Node_Str""));
  assertTrue(ignoreSignFieldNames.contains(""String_Node_Str""));
}","@Test public void testIngoreSignField(){
  ApplicationContext context=mock(ApplicationContext.class);
  when(context.getBeanNamesForType(Object.class)).thenReturn(new String[]{""String_Node_Str""});
  Class serviceClass=IgnoreSignRopRequestService.class;
  when(context.getType(""String_Node_Str"")).thenReturn(serviceClass);
  RopContext ropContext=new DefaultRopContext(context);
  ServiceMethodHandler method1=ropContext.getServiceMethodHandler(""String_Node_Str"",""String_Node_Str"");
  List<String> ignoreSignFieldNames=method1.getIgnoreSignFieldNames();
  assertNotNull(ignoreSignFieldNames);
  assertEquals(ignoreSignFieldNames.size(),4);
  assertTrue(ignoreSignFieldNames.contains(""String_Node_Str""));
  assertTrue(ignoreSignFieldNames.contains(""String_Node_Str""));
  assertTrue(ignoreSignFieldNames.contains(""String_Node_Str""));
}",0.9987980769230768
8529,"@Override public void run(){
  if (threadFerry != null) {
    threadFerry.doInDestThread();
  }
  RopRequestContext ropRequestContext=null;
  try {
    ropRequestContext=requestContextBuilder.buildBySysParams(ropContext,servletRequest,servletResponse);
    MainError mainError=securityManager.validateSystemParameters(ropRequestContext);
    if (mainError != null) {
      ropRequestContext.setRopResponse(new ErrorResponse(mainError));
    }
 else {
      requestContextBuilder.bindBusinessParams(ropRequestContext);
      mainError=securityManager.validateOther(ropRequestContext);
      if (mainError != null) {
        ropRequestContext.setRopResponse(new ErrorResponse(mainError));
      }
 else {
        firePreDoServiceEvent(ropRequestContext);
        invokeBeforceServiceOfInterceptors(ropRequestContext);
        if (ropRequestContext.getRopResponse() == null) {
          ropRequestContext.setRopResponse(doService(ropRequestContext));
          invokeBeforceResponseOfInterceptors(ropRequestContext);
        }
      }
    }
    writeResponse(ropRequestContext.getRopResponse(),servletResponse,ropRequestContext.getMessageFormat(),jsonpCallback);
  }
 catch (  Throwable e) {
    String method=ropRequestContext.getMethod();
    Locale locale=ropRequestContext.getLocale();
    ServiceUnavailableErrorResponse ropResponse=new ServiceUnavailableErrorResponse(method,locale,e);
    invokeBeforceResponseOfInterceptors(ropRequestContext);
    writeResponse(ropResponse,servletResponse,ropRequestContext.getMessageFormat(),jsonpCallback);
  }
 finally {
    if (ropRequestContext != null) {
      ropRequestContext.setServiceEndTime(System.currentTimeMillis());
      invokeTimesController.caculateInvokeTimes(ropRequestContext.getAppKey(),ropRequestContext.getSession());
      fireAfterDoServiceEvent(ropRequestContext);
    }
  }
}","@Override public void run(){
  if (threadFerry != null) {
    threadFerry.doInDestThread();
  }
  RopRequestContext ropRequestContext=null;
  try {
    ropRequestContext=requestContextBuilder.buildBySysParams(ropContext,servletRequest,servletResponse);
    MainError mainError=securityManager.validateSystemParameters(ropRequestContext);
    if (mainError != null) {
      ropRequestContext.setRopResponse(new ErrorResponse(mainError));
    }
 else {
      requestContextBuilder.bindBusinessParams(ropRequestContext);
      mainError=securityManager.validateOther(ropRequestContext);
      if (mainError != null) {
        ropRequestContext.setRopResponse(new ErrorResponse(mainError));
      }
 else {
        firePreDoServiceEvent(ropRequestContext);
        invokeBeforceServiceOfInterceptors(ropRequestContext);
        if (ropRequestContext.getRopResponse() == null) {
          ropRequestContext.setRopResponse(doService(ropRequestContext));
          invokeBeforceResponseOfInterceptors(ropRequestContext);
        }
      }
    }
    writeResponse(ropRequestContext.getRopResponse(),servletResponse,ropRequestContext.getMessageFormat(),jsonpCallback);
  }
 catch (  Throwable e) {
    if (ropRequestContext != null) {
      String method=ropRequestContext.getMethod();
      Locale locale=ropRequestContext.getLocale();
      ServiceUnavailableErrorResponse ropResponse=new ServiceUnavailableErrorResponse(method,locale,e);
      invokeBeforceResponseOfInterceptors(ropRequestContext);
      writeResponse(ropResponse,servletResponse,ropRequestContext.getMessageFormat(),jsonpCallback);
    }
 else {
      throw new RopException(""String_Node_Str"",e);
    }
  }
 finally {
    if (ropRequestContext != null) {
      ropRequestContext.setServiceEndTime(System.currentTimeMillis());
      invokeTimesController.caculateInvokeTimes(ropRequestContext.getAppKey(),ropRequestContext.getSession());
      fireAfterDoServiceEvent(ropRequestContext);
    }
  }
}",0.9689800210304942
8530,"@Override public void beforeService(RequestContext methodContext){
  System.out.println(""String_Node_Str"");
  if (""String_Node_Str"".equals(methodContext.getParamValue(""String_Node_Str""))) {
    InterceptorResponse response=new InterceptorResponse();
    response.setTestField(""String_Node_Str"");
    methodContext.setRopResponse(response);
  }
}","/** 
 * 在数据绑定后，服务方法调用前执行该拦截方法
 * @param methodContext
 */
@Override public void beforeService(RequestContext methodContext){
  System.out.println(""String_Node_Str"");
  if (""String_Node_Str"".equals(methodContext.getParamValue(""String_Node_Str""))) {
    InterceptorResponse response=new InterceptorResponse();
    response.setTestField(""String_Node_Str"");
    methodContext.setRopResponse(response);
  }
}",0.9224598930481284
8531,"@Override public boolean isMatch(RequestContext methodContext){
  return ""String_Node_Str"".equals(methodContext.getMethod());
}","/** 
 * 对method为user.add的方法进行拦截，你可以通过methodContext中的信息制定拦截方案
 * @param methodContext
 * @return
 */
@Override public boolean isMatch(RequestContext methodContext){
  return ""String_Node_Str"".equals(methodContext.getMethod());
}",0.7175141242937854
8532,"@Override public void beforeResponse(RequestContext methodContext){
  System.out.println(""String_Node_Str"");
}","/** 
 * 在服务执行完成后，响应返回前执行该拦截方法
 * @param methodContext
 */
@Override public void beforeResponse(RequestContext methodContext){
  System.out.println(""String_Node_Str"");
}",0.7913669064748201
8533,"@Override public boolean isGranted(RequestContext methodContext){
  return aclMap.get(methodContext.getSessionId());
}","@Override public boolean isGranted(RequestContext methodContext){
  if (methodContext.getSessionId() != null) {
    return aclMap.get(methodContext.getSessionId());
  }
 else {
    return true;
  }
}",0.7444794952681388
8534,"/** 
 * 在进行服务之前调用
 * @param methodContext
 */
void beforeService(RequestContext methodContext);","/** 
 * 在进行服务之前调用,如果在方法中往  {@link RequestContext}设置了  {@link RopResponse}（相当于已经产生了响应了）, 所以服务将直接返回，不往下继续执行，反之服务会继续往下执行直到返回响应
 * @param methodContext
 */
void beforeService(RequestContext methodContext);",0.6418918918918919
8535,"private void writeResponse(RopResponse ropResponse,HttpServletResponse httpServletResponse,MessageFormat messageFormat){
  try {
    httpServletResponse.setCharacterEncoding(UTF_8);
    if (messageFormat == MessageFormat.xml) {
      httpServletResponse.setContentType(APPLICATION_XML);
      xmlMarshallerRop.marshaller(ropResponse,httpServletResponse.getOutputStream());
    }
 else {
      httpServletResponse.setContentType(APPLICATION_JSON);
      jsonMarshallerRop.marshaller(ropResponse,httpServletResponse.getOutputStream());
    }
  }
 catch (  IOException e) {
    throw new RopException(e);
  }
}","private void writeResponse(RopResponse ropResponse,HttpServletResponse httpServletResponse,MessageFormat messageFormat){
  try {
    httpServletResponse.setCharacterEncoding(Constants.UTF8);
    if (messageFormat == MessageFormat.xml) {
      httpServletResponse.setContentType(APPLICATION_XML);
      xmlMarshallerRop.marshaller(ropResponse,httpServletResponse.getOutputStream());
    }
 else {
      httpServletResponse.setContentType(APPLICATION_JSON);
      jsonMarshallerRop.marshaller(ropResponse,httpServletResponse.getOutputStream());
    }
  }
 catch (  IOException e) {
    throw new RopException(e);
  }
}",0.9910057236304172
8536,"@Override public SimpleRequestContext buildBySysParams(RopContext ropContext,Object request){
  if (!(request instanceof HttpServletRequest)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HttpServletRequest servletRequest=(HttpServletRequest)request;
  SimpleRequestContext requestContext=new SimpleRequestContext(ropContext);
  requestContext.setRawRequestObject(servletRequest);
  requestContext.setAllParams(getRequestParams(servletRequest));
  requestContext.setIp(servletRequest.getRemoteAddr());
  requestContext.setAppKey(servletRequest.getParameter(SystemParameterNames.getAppKey()));
  requestContext.setSessionId(servletRequest.getParameter(SystemParameterNames.getSessionId()));
  requestContext.setMethod(servletRequest.getParameter(SystemParameterNames.getMethod()));
  requestContext.setVersion(servletRequest.getParameter(SystemParameterNames.getVersion()));
  requestContext.setLocale(getLocale(servletRequest));
  requestContext.setFormat(getFormat(servletRequest));
  requestContext.setMessageFormat(getResponseFormat(servletRequest));
  requestContext.setSign(servletRequest.getParameter(SystemParameterNames.getSign()));
  requestContext.setHttpAction(HttpAction.fromValue(servletRequest.getMethod()));
  ServiceMethodHandler serviceMethodHandler=ropContext.getServiceMethodHandler(requestContext.getMethod(),requestContext.getVersion());
  requestContext.setServiceMethodHandler(serviceMethodHandler);
  return requestContext;
}","@Override public SimpleRequestContext buildBySysParams(RopContext ropContext,Object request){
  if (!(request instanceof HttpServletRequest)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HttpServletRequest servletRequest=(HttpServletRequest)request;
  SimpleRequestContext requestContext=new SimpleRequestContext(ropContext);
  requestContext.setRawRequestObject(servletRequest);
  requestContext.setAllParams(getRequestParams(servletRequest));
  requestContext.setIp(getRemoteAddr(servletRequest));
  requestContext.setAppKey(servletRequest.getParameter(SystemParameterNames.getAppKey()));
  requestContext.setSessionId(servletRequest.getParameter(SystemParameterNames.getSessionId()));
  requestContext.setMethod(servletRequest.getParameter(SystemParameterNames.getMethod()));
  requestContext.setVersion(servletRequest.getParameter(SystemParameterNames.getVersion()));
  requestContext.setLocale(getLocale(servletRequest));
  requestContext.setFormat(getFormat(servletRequest));
  requestContext.setMessageFormat(getResponseFormat(servletRequest));
  requestContext.setSign(servletRequest.getParameter(SystemParameterNames.getSign()));
  requestContext.setHttpAction(HttpAction.fromValue(servletRequest.getMethod()));
  ServiceMethodHandler serviceMethodHandler=ropContext.getServiceMethodHandler(requestContext.getMethod(),requestContext.getVersion());
  requestContext.setServiceMethodHandler(serviceMethodHandler);
  return requestContext;
}",0.9901326981966656
8537,"/** 
 * 正常情况下的系统参数绑定
 * @throws Exception
 */
@Test public void testBuildBySysParams1() throws Exception {
  FormattingConversionService conversionService=mock(FormattingConversionService.class);
  ServletRequestContextBuilder requestContextBuilder=new ServletRequestContextBuilder(conversionService);
  RopContext ropContext=mock(RopContext.class);
  ServiceMethodHandler methodHandler=mock(ServiceMethodHandler.class);
  when(ropContext.getServiceMethodHandler(""String_Node_Str"",""String_Node_Str"")).thenReturn(methodHandler);
  MockHttpServletRequest servletRequest=new MockHttpServletRequest();
  servletRequest.setRemoteAddr(""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getAppKey(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getSessionId(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getMethod(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getVersion(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getLocale(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getFormat(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getSign(),""String_Node_Str"");
  servletRequest.setParameter(""String_Node_Str"",""String_Node_Str"");
  servletRequest.setParameter(""String_Node_Str"",""String_Node_Str"");
  servletRequest.setParameter(""String_Node_Str"",""String_Node_Str"");
  SimpleRequestContext requestContext=requestContextBuilder.buildBySysParams(ropContext,servletRequest);
  assertEquals(requestContext.getIp(),""String_Node_Str"");
  assertEquals(requestContext.getAllParams().size(),10);
  assertEquals(requestContext.getParamValue(""String_Node_Str""),""String_Node_Str"");
  assertEquals(requestContext.getRawRequestObject(),servletRequest);
  assertEquals(requestContext.getAppKey(),""String_Node_Str"");
  assertEquals(requestContext.getSessionId(),""String_Node_Str"");
  assertEquals(requestContext.getMethod(),""String_Node_Str"");
  assertEquals(requestContext.getVersion(),""String_Node_Str"");
  assertEquals(requestContext.getLocale(),new Locale(""String_Node_Str"",""String_Node_Str""));
  assertEquals(requestContext.getFormat(),""String_Node_Str"");
  assertEquals(requestContext.getMessageFormat(),MessageFormat.xml);
  assertEquals(requestContext.getSign(),""String_Node_Str"");
  assertEquals(requestContext.getServiceMethodHandler(),methodHandler);
}","/** 
 * 正常情况下的系统参数绑定
 * @throws Exception
 */
@Test public void testBuildBySysParams1() throws Exception {
  FormattingConversionService conversionService=mock(FormattingConversionService.class);
  ServletRequestContextBuilder requestContextBuilder=new ServletRequestContextBuilder(conversionService);
  RopContext ropContext=mock(RopContext.class);
  ServiceMethodHandler methodHandler=mock(ServiceMethodHandler.class);
  when(ropContext.getServiceMethodHandler(""String_Node_Str"",""String_Node_Str"")).thenReturn(methodHandler);
  MockHttpServletRequest servletRequest=new MockHttpServletRequest();
  servletRequest.setParameter(SystemParameterNames.getAppKey(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getSessionId(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getMethod(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getVersion(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getLocale(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getFormat(),""String_Node_Str"");
  servletRequest.setParameter(SystemParameterNames.getSign(),""String_Node_Str"");
  servletRequest.setParameter(""String_Node_Str"",""String_Node_Str"");
  servletRequest.setParameter(""String_Node_Str"",""String_Node_Str"");
  servletRequest.setParameter(""String_Node_Str"",""String_Node_Str"");
  SimpleRequestContext requestContext=requestContextBuilder.buildBySysParams(ropContext,servletRequest);
  assertEquals(requestContext.getAllParams().size(),10);
  assertEquals(requestContext.getParamValue(""String_Node_Str""),""String_Node_Str"");
  assertEquals(requestContext.getRawRequestObject(),servletRequest);
  assertEquals(requestContext.getAppKey(),""String_Node_Str"");
  assertEquals(requestContext.getSessionId(),""String_Node_Str"");
  assertEquals(requestContext.getMethod(),""String_Node_Str"");
  assertEquals(requestContext.getVersion(),""String_Node_Str"");
  assertEquals(requestContext.getLocale(),new Locale(""String_Node_Str"",""String_Node_Str""));
  assertEquals(requestContext.getFormat(),""String_Node_Str"");
  assertEquals(requestContext.getMessageFormat(),MessageFormat.xml);
  assertEquals(requestContext.getSign(),""String_Node_Str"");
  assertEquals(requestContext.getServiceMethodHandler(),methodHandler);
}",0.9769214482320558
8538,"private Map<String,String> getRequestForm(RopRequest ropRequest,String methodName,String version,String sessionId){
  Map<String,String> form=new LinkedHashMap<String,String>(16);
  form.put(SystemParameterNames.getAppKey(),appKey);
  form.put(SystemParameterNames.getMethod(),methodName);
  form.put(SystemParameterNames.getVersion(),version);
  form.put(SystemParameterNames.getFormat(),format);
  form.put(SystemParameterNames.getLocale(),locale);
  if (sessionId != null) {
    form.put(SystemParameterNames.getSessionId(),sessionId);
  }
  form.putAll(getParamFields(ropRequest));
  String signValue=sign(RopRequest.class,appSecret,form);
  form.put(""String_Node_Str"",signValue);
  return form;
}","private Map<String,String> getRequestForm(RopRequest ropRequest,String methodName,String version,String sessionId){
  Map<String,String> form=new LinkedHashMap<String,String>(16);
  form.put(SystemParameterNames.getAppKey(),appKey);
  form.put(SystemParameterNames.getMethod(),methodName);
  form.put(SystemParameterNames.getVersion(),version);
  form.put(SystemParameterNames.getFormat(),format);
  form.put(SystemParameterNames.getLocale(),locale);
  if (sessionId != null) {
    form.put(SystemParameterNames.getSessionId(),sessionId);
  }
  form.putAll(getParamFields(ropRequest));
  String signValue=sign(ropRequest.getClass(),appSecret,form);
  form.put(""String_Node_Str"",signValue);
  return form;
}",0.976545842217484
8539,"private boolean isIgoreSignField(Field field){
  Annotation[] declaredAnnotations=field.getDeclaredAnnotations();
  if (declaredAnnotations != null) {
    for (    Annotation declaredAnnotation : declaredAnnotations) {
      if (declaredAnnotation.equals(IgnoreSign.class)) {
        return true;
      }
    }
  }
  return false;
}","private boolean isIgoreSignField(Field field){
  Annotation[] declaredAnnotations=field.getDeclaredAnnotations();
  if (declaredAnnotations != null) {
    for (    Annotation declaredAnnotation : declaredAnnotations) {
      if (ClassUtils.isAssignableValue(IgnoreSign.class,declaredAnnotation)) {
        return true;
      }
    }
  }
  return false;
}",0.8979591836734694
8540,"private Map<String,String> getParamFields(RopRequest ropRequest){
  if (!requestAllFields.containsKey(ropRequest.getClass())) {
    final ArrayList<Field> allFields=new ArrayList<Field>();
    final ArrayList<String> ignoreSignFieldNames=new ArrayList<String>();
    ReflectionUtils.doWithFields(ropRequest.getClass(),new ReflectionUtils.FieldCallback(){
      @Override public void doWith(      Field field) throws IllegalArgumentException, IllegalAccessException {
        ReflectionUtils.makeAccessible(field);
        if (!isTemporaryField(field)) {
          allFields.add(field);
        }
        if (isIgoreSignField(field)) {
          ignoreSignFieldNames.add(field.getName());
        }
      }
      private boolean isTemporaryField(      Field field){
        Annotation[] declaredAnnotations=field.getDeclaredAnnotations();
        if (declaredAnnotations != null) {
          for (          Annotation declaredAnnotation : declaredAnnotations) {
            if (declaredAnnotation.equals(Temporary.class)) {
              return true;
            }
          }
        }
        return false;
      }
      private boolean isIgoreSignField(      Field field){
        Annotation[] declaredAnnotations=field.getDeclaredAnnotations();
        if (declaredAnnotations != null) {
          for (          Annotation declaredAnnotation : declaredAnnotations) {
            if (declaredAnnotation.equals(IgnoreSign.class)) {
              return true;
            }
          }
        }
        return false;
      }
    }
);
    requestAllFields.put(ropRequest.getClass(),allFields);
    requestIgnoreSignFieldNames.put(ropRequest.getClass(),ignoreSignFieldNames);
  }
  List<Field> fields=requestAllFields.get(ropRequest.getClass());
  Map<String,String> params=new HashMap<String,String>();
  for (  Field field : fields) {
    Object fieldValue=ReflectionUtils.getField(field,ropRequest);
    if (fieldValue != null) {
      params.put(field.getName(),fieldValue.toString());
    }
  }
  return params;
}","private Map<String,String> getParamFields(RopRequest ropRequest){
  if (!requestAllFields.containsKey(ropRequest.getClass())) {
    final ArrayList<Field> allFields=new ArrayList<Field>();
    final ArrayList<String> ignoreSignFieldNames=new ArrayList<String>();
    ReflectionUtils.doWithFields(ropRequest.getClass(),new ReflectionUtils.FieldCallback(){
      @Override public void doWith(      Field field) throws IllegalArgumentException, IllegalAccessException {
        ReflectionUtils.makeAccessible(field);
        if (!isTemporaryField(field)) {
          allFields.add(field);
          if (isIgoreSignField(field)) {
            ignoreSignFieldNames.add(field.getName());
          }
        }
      }
      private boolean isTemporaryField(      Field field){
        Annotation[] declaredAnnotations=field.getDeclaredAnnotations();
        if (declaredAnnotations != null) {
          for (          Annotation declaredAnnotation : declaredAnnotations) {
            if (declaredAnnotation.equals(Temporary.class)) {
              return true;
            }
          }
        }
        return false;
      }
      private boolean isIgoreSignField(      Field field){
        Annotation[] declaredAnnotations=field.getDeclaredAnnotations();
        if (declaredAnnotations != null) {
          for (          Annotation declaredAnnotation : declaredAnnotations) {
            if (ClassUtils.isAssignableValue(IgnoreSign.class,declaredAnnotation)) {
              return true;
            }
          }
        }
        return false;
      }
    }
);
    requestAllFields.put(ropRequest.getClass(),allFields);
    requestIgnoreSignFieldNames.put(ropRequest.getClass(),ignoreSignFieldNames);
  }
  List<Field> fields=requestAllFields.get(ropRequest.getClass());
  Map<String,String> params=new HashMap<String,String>();
  for (  Field field : fields) {
    Object fieldValue=ReflectionUtils.getField(field,ropRequest);
    if (fieldValue != null) {
      params.put(field.getName(),fieldValue.toString());
    }
  }
  return params;
}",0.935531496062992
8541,"private String buildGetUrl(Map<String,String> form){
  StringBuilder requestUrl=new StringBuilder();
  requestUrl.append(serverUrl);
  requestUrl.append(""String_Node_Str"");
  for (  Map.Entry<String,String> entry : form.entrySet()) {
    requestUrl.append(entry.getKey());
    requestUrl.append(""String_Node_Str"");
    requestUrl.append(entry.getValue());
  }
  return requestUrl.toString();
}","private String buildGetUrl(Map<String,String> form){
  StringBuilder requestUrl=new StringBuilder();
  requestUrl.append(serverUrl);
  requestUrl.append(""String_Node_Str"");
  String joinChar=""String_Node_Str"";
  for (  Map.Entry<String,String> entry : form.entrySet()) {
    requestUrl.append(joinChar);
    requestUrl.append(entry.getKey());
    requestUrl.append(""String_Node_Str"");
    requestUrl.append(entry.getValue());
    joinChar=""String_Node_Str"";
  }
  return requestUrl.toString();
}",0.8851351351351351
8542,"@Override public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {
  ReflectionUtils.makeAccessible(field);
  if (!isTemporaryField(field)) {
    allFields.add(field);
  }
  if (isIgoreSignField(field)) {
    ignoreSignFieldNames.add(field.getName());
  }
}","@Override public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {
  ReflectionUtils.makeAccessible(field);
  if (!isTemporaryField(field)) {
    allFields.add(field);
    if (isIgoreSignField(field)) {
      ignoreSignFieldNames.add(field.getName());
    }
  }
}",0.7167235494880546
8543,"private boolean isValidSession(RequestContext smc){
  if (sessionManager.getSession(smc.getSessionId()) != null) {
    if (logger.isDebugEnabled()) {
      logger.debug(smc.getSessionId() + ""String_Node_Str"");
    }
    return true;
  }
 else {
    return false;
  }
}","private boolean isValidSession(RequestContext smc){
  if (sessionManager.getSession(smc.getSessionId()) == null) {
    if (logger.isDebugEnabled()) {
      logger.debug(smc.getSessionId() + ""String_Node_Str"");
    }
    return false;
  }
 else {
    return true;
  }
}",0.9701492537313432
8544,"/** 
 * 是否是合法的会话
 * @param sessionId
 * @return
 */
private MainError checkSession(RequestContext smc){
  if (smc.getServiceMethodHandler() != null && smc.getServiceMethodHandler().getServiceMethodDefinition().isNeedInSession()) {
    if (smc.getSessionId() == null) {
      return MainErrors.getError(MainErrorType.MISSING_SESSION,null);
    }
 else {
      if (isValidSession(smc)) {
        return MainErrors.getError(MainErrorType.INVALID_SESSION,null);
      }
 else {
        return null;
      }
    }
  }
 else {
    return null;
  }
}","/** 
 * 是否是合法的会话
 * @param sessionId
 * @return
 */
private MainError checkSession(RequestContext smc){
  if (smc.getServiceMethodHandler() != null && smc.getServiceMethodHandler().getServiceMethodDefinition().isNeedInSession()) {
    if (smc.getSessionId() == null) {
      return MainErrors.getError(MainErrorType.MISSING_SESSION,null);
    }
 else {
      if (!isValidSession(smc)) {
        return MainErrors.getError(MainErrorType.INVALID_SESSION,null);
      }
    }
  }
  return null;
}",0.9324324324324323
8545,"private void fireAfterDoServiceEvent(RequestContext requestContext){
  this.ropEventMulticaster.multicastEvent(new PreDoServiceEvent(this,requestContext));
}","private void fireAfterDoServiceEvent(RequestContext requestContext){
  this.ropEventMulticaster.multicastEvent(new AfterDoServiceEvent(this,requestContext));
}",0.981012658227848
8546,"private void firePreDoServiceEvent(RequestContext requestContext){
  this.ropEventMulticaster.multicastEvent(new AfterDoServiceEvent(this,requestContext));
}","private void firePreDoServiceEvent(RequestContext requestContext){
  this.ropEventMulticaster.multicastEvent(new PreDoServiceEvent(this,requestContext));
}",0.9807692307692308
8547,"protected final ResponseMessage wrapMessage(AtmosphereResponse res,String message){
  Response.Builder builder=new Response.Builder();
  builder.body(message).status(res.getStatus(),res.getStatusMessage());
  Map<String,String> headers=res.headers();
  for (  String s : headers.keySet()) {
    builder.header(new Header(s,headers.get(s)));
  }
  Request swaggerSocketRequest=(Request)res.request().getAttribute(""String_Node_Str"");
  builder.uuid(swaggerSocketRequest.getUuid()).method(swaggerSocketRequest.getMethod()).path(swaggerSocketRequest.getPath());
  String identity=(String)getContextValue(res.request(),IDENTITY);
  AtomicInteger expectedResponseCount=(AtomicInteger)getContextValue(res.request(),transactionIdentity.get() + RESPONSE_COUNTER);
  ResponseMessage m=null;
  if (expectedResponseCount != null && res.resource().transport() != AtmosphereResource.TRANSPORT.WEBSOCKET) {
    m=(ResponseMessage)getContextValue(res.request(),transactionIdentity.get() + ResponseMessage.class.getName());
    if (m != null) {
      m.response(builder.build());
    }
 else {
      m=new ResponseMessage(identity,builder.build());
    }
    if (expectedResponseCount.decrementAndGet() <= 0) {
      return m;
    }
 else {
      addContextValue(res.request(),transactionIdentity.get() + ResponseMessage.class.getName(),m);
      return null;
    }
  }
  if (m == null) {
    m=new ResponseMessage(identity,builder.build());
  }
  return m;
}","protected final ResponseMessage wrapMessage(AtmosphereResponse res,String message){
  Response.Builder builder=new Response.Builder();
  builder.body(message).status(res.getStatus(),res.getStatusMessage());
  Map<String,String> headers=res.headers();
  for (  String s : headers.keySet()) {
    builder.header(new Header(s,headers.get(s)));
  }
  Request swaggerSocketRequest=ssRequest.get();
  if (swaggerSocketRequest == null) {
    swaggerSocketRequest=(Request)res.request().getAttribute(""String_Node_Str"");
  }
  builder.uuid(swaggerSocketRequest.getUuid()).method(swaggerSocketRequest.getMethod()).path(swaggerSocketRequest.getPath());
  String identity=(String)getContextValue(res.request(),IDENTITY);
  AtomicInteger expectedResponseCount=(AtomicInteger)getContextValue(res.request(),transactionIdentity.get() + RESPONSE_COUNTER);
  ResponseMessage m=null;
  if (expectedResponseCount != null && res.resource().transport() != AtmosphereResource.TRANSPORT.WEBSOCKET) {
    m=(ResponseMessage)getContextValue(res.request(),transactionIdentity.get() + ResponseMessage.class.getName());
    if (m != null) {
      m.response(builder.build());
    }
 else {
      m=new ResponseMessage(identity,builder.build());
    }
    if (expectedResponseCount.decrementAndGet() <= 0) {
      return m;
    }
 else {
      addContextValue(res.request(),transactionIdentity.get() + ResponseMessage.class.getName(),m);
      return null;
    }
  }
  if (m == null) {
    m=new ResponseMessage(identity,builder.build());
  }
  return m;
}",0.9716981132075472
8548,"@Override public Action inspect(AtmosphereResource r){
  final AtmosphereRequest request=r.getRequest();
  if (request.getHeader(""String_Node_Str"") != null && request.getAttribute(SWAGGER_SOCKET_DISPATCHED) == null) {
    AtmosphereResponse response=r.getResponse();
    response.setContentType(""String_Node_Str"");
    logger.debug(""String_Node_Str"",request.getMethod(),r.transport());
    if (request.getMethod() == ""String_Node_Str"" && r.transport().equals(AtmosphereResource.TRANSPORT.LONG_POLLING)) {
      BlockingQueue<AtmosphereResource> queue=(BlockingQueue<AtmosphereResource>)getContextValue(request,SUSPENDED_RESPONSE);
      if (queue == null) {
        queue=new LinkedBlockingQueue<AtmosphereResource>();
        request.getSession().setAttribute(SUSPENDED_RESPONSE,queue);
      }
      queue.offer(r);
      r.suspend();
      return Action.SUSPEND;
    }
    AtmosphereFramework framework=r.getAtmosphereConfig().framework();
    StringBuilder d=new StringBuilder();
    try {
      InputStreamReader isr=new InputStreamReader(request.getInputStream());
      BufferedReader bufReader=new BufferedReader(isr);
      char[] charBuffer=new char[8192];
      for (int readCount=bufReader.read(charBuffer); readCount > -1; readCount=bufReader.read(charBuffer)) {
        d.append(charBuffer,0,readCount);
      }
      String data=d.toString();
      if (data.length() == 0) {
        return Action.CANCELLED;
      }
      String message=data.substring(0,20).replaceAll(""String_Node_Str"",""String_Node_Str"");
      logger.debug(data);
      if (message.startsWith(""String_Node_Str"")) {
        HandshakeMessage handshakeMessage=mapper.readValue(data,HandshakeMessage.class);
        String identity=(String)getContextValue(request,IDENTITY);
        if (identity == null) {
          identity=UUID.randomUUID().toString();
        }
 else {
          logger.debug(""String_Node_Str"",identity);
          try {
            Enumeration<String> e=request.getSession().getAttributeNames();
            while (e.hasMoreElements()) {
              request.getSession().removeAttribute(e.nextElement());
            }
          }
 catch (          Exception ex) {
            logger.warn(""String_Node_Str"",ex);
          }
        }
        addContextValue(request,IDENTITY,identity);
        StatusMessage statusMessage=new StatusMessage.Builder().status(new StatusMessage.Status(200,""String_Node_Str"")).identity(identity).build();
        response.getOutputStream().write(mapper.writeValueAsBytes(statusMessage));
        if (!delegateHandshake) {
          return Action.CANCELLED;
        }
      }
 else       if (message.startsWith(""String_Node_Str"")) {
        Close c=mapper.readValue(data,Close.class);
        logger.debug(""String_Node_Str"",c.getCloseMessage().getIdentity(),c.getCloseMessage().getReason());
        try {
          request.getSession().invalidate();
        }
 catch (        Exception ex) {
          logger.warn(""String_Node_Str"",ex);
        }
      }
 else {
        Message swaggerSocketMessage=mapper.readValue(data,Message.class);
        swaggerSocketMessage.transactionID(UUID.randomUUID().toString());
        String identity=(String)getContextValue(request,IDENTITY);
        if (!swaggerSocketMessage.getIdentity().equals(identity)) {
          StatusMessage statusMessage=new StatusMessage.Builder().status(new StatusMessage.Status(503,""String_Node_Str"")).identity(identity).build();
          response.getOutputStream().write(mapper.writeValueAsBytes(statusMessage));
          return Action.CANCELLED;
        }
        transactionIdentity.set(swaggerSocketMessage.transactionID());
        List<Request> requests=swaggerSocketMessage.getRequests();
        addContextValue(request,swaggerSocketMessage.transactionID() + RESPONSE_COUNTER,new AtomicInteger(requests.size()));
        AtmosphereRequest ar;
        for (        Request req : requests) {
          ar=toAtmosphereRequest(request,req);
          try {
            ar.setAttribute(SWAGGER_SOCKET_DISPATCHED,""String_Node_Str"");
            request.removeAttribute(INJECTED_ATMOSPHERE_RESOURCE);
            response.request(ar);
            attachWriter(r);
            request.setAttribute(""String_Node_Str"",req);
            framework.doCometSupport(ar,response);
          }
 catch (          ServletException e) {
            logger.warn(""String_Node_Str"",e);
            return Action.CANCELLED;
          }
        }
      }
      return Action.CANCELLED;
    }
 catch (    IOException e) {
      logger.warn(""String_Node_Str"",e);
      return Action.CONTINUE;
    }
  }
 else {
    request.setAttribute(SWAGGER_SOCKET_DISPATCHED,null);
  }
  return Action.CONTINUE;
}","@Override public Action inspect(AtmosphereResource r){
  final AtmosphereRequest request=r.getRequest();
  if (request.getHeader(""String_Node_Str"") != null && request.getAttribute(SWAGGER_SOCKET_DISPATCHED) == null) {
    AtmosphereResponse response=r.getResponse();
    response.setContentType(""String_Node_Str"");
    logger.debug(""String_Node_Str"",request.getMethod(),r.transport());
    if (request.getMethod() == ""String_Node_Str"" && r.transport().equals(AtmosphereResource.TRANSPORT.LONG_POLLING)) {
      BlockingQueue<AtmosphereResource> queue=(BlockingQueue<AtmosphereResource>)getContextValue(request,SUSPENDED_RESPONSE);
      if (queue == null) {
        queue=new LinkedBlockingQueue<AtmosphereResource>();
        request.getSession().setAttribute(SUSPENDED_RESPONSE,queue);
      }
      queue.offer(r);
      r.suspend();
      return Action.SUSPEND;
    }
    AtmosphereFramework framework=r.getAtmosphereConfig().framework();
    StringBuilder d=new StringBuilder();
    try {
      InputStreamReader isr=new InputStreamReader(request.getInputStream());
      BufferedReader bufReader=new BufferedReader(isr);
      char[] charBuffer=new char[8192];
      for (int readCount=bufReader.read(charBuffer); readCount > -1; readCount=bufReader.read(charBuffer)) {
        d.append(charBuffer,0,readCount);
      }
      String data=d.toString();
      if (data.length() == 0) {
        return Action.CANCELLED;
      }
      String message=data.substring(0,20).replaceAll(""String_Node_Str"",""String_Node_Str"");
      logger.debug(data);
      if (message.startsWith(""String_Node_Str"")) {
        HandshakeMessage handshakeMessage=mapper.readValue(data,HandshakeMessage.class);
        String identity=(String)getContextValue(request,IDENTITY);
        if (identity == null) {
          identity=UUID.randomUUID().toString();
        }
 else {
          logger.debug(""String_Node_Str"",identity);
          try {
            Enumeration<String> e=request.getSession().getAttributeNames();
            while (e.hasMoreElements()) {
              request.getSession().removeAttribute(e.nextElement());
            }
          }
 catch (          Exception ex) {
            logger.warn(""String_Node_Str"",ex);
          }
        }
        addContextValue(request,IDENTITY,identity);
        StatusMessage statusMessage=new StatusMessage.Builder().status(new StatusMessage.Status(200,""String_Node_Str"")).identity(identity).build();
        response.getOutputStream().write(mapper.writeValueAsBytes(statusMessage));
        if (!delegateHandshake) {
          return Action.CANCELLED;
        }
      }
 else       if (message.startsWith(""String_Node_Str"")) {
        Close c=mapper.readValue(data,Close.class);
        logger.debug(""String_Node_Str"",c.getCloseMessage().getIdentity(),c.getCloseMessage().getReason());
        try {
          request.getSession().invalidate();
        }
 catch (        Exception ex) {
          logger.warn(""String_Node_Str"",ex);
        }
      }
 else {
        Message swaggerSocketMessage=mapper.readValue(data,Message.class);
        swaggerSocketMessage.transactionID(UUID.randomUUID().toString());
        String identity=(String)getContextValue(request,IDENTITY);
        if (!swaggerSocketMessage.getIdentity().equals(identity)) {
          StatusMessage statusMessage=new StatusMessage.Builder().status(new StatusMessage.Status(503,""String_Node_Str"")).identity(identity).build();
          response.getOutputStream().write(mapper.writeValueAsBytes(statusMessage));
          return Action.CANCELLED;
        }
        transactionIdentity.set(swaggerSocketMessage.transactionID());
        List<Request> requests=swaggerSocketMessage.getRequests();
        addContextValue(request,swaggerSocketMessage.transactionID() + RESPONSE_COUNTER,new AtomicInteger(requests.size()));
        AtmosphereRequest ar;
        for (        Request req : requests) {
          ar=toAtmosphereRequest(request,req);
          try {
            ar.setAttribute(SWAGGER_SOCKET_DISPATCHED,""String_Node_Str"");
            request.removeAttribute(INJECTED_ATMOSPHERE_RESOURCE);
            response.request(ar);
            attachWriter(r);
            ssRequest.set(req);
            request.setAttribute(""String_Node_Str"",req);
            framework.doCometSupport(ar,response);
          }
 catch (          ServletException e) {
            logger.warn(""String_Node_Str"",e);
            return Action.CANCELLED;
          }
        }
      }
      return Action.CANCELLED;
    }
 catch (    IOException e) {
      logger.warn(""String_Node_Str"",e);
      return Action.CONTINUE;
    }
  }
 else {
    request.setAttribute(SWAGGER_SOCKET_DISPATCHED,null);
  }
  return Action.CONTINUE;
}",0.9965950202170676
8549,"@Override public byte[] error(AtmosphereResponse response,int statusCode,String reasonPhrase){
  Request swaggerSocketRequest=(Request)response.request().getAttribute(""String_Node_Str"");
  if (swaggerSocketRequest == null) {
    logger.debug(""String_Node_Str"",response.getStatus(),response.getStatusMessage());
    return new byte[0];
  }
  logger.debug(""String_Node_Str"",response.getStatus(),response.getStatusMessage());
  StatusMessage statusMessage=new StatusMessage.Builder().status(new StatusMessage.Status(response.getStatus(),response.getStatusMessage())).identity(swaggerSocketRequest.getUuid()).build();
  try {
    return mapper.writeValueAsBytes(statusMessage);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","@Override public byte[] error(AtmosphereResponse response,int statusCode,String reasonPhrase){
  Request swaggerSocketRequest=ssRequest.get();
  if (swaggerSocketRequest == null) {
    swaggerSocketRequest=(Request)response.request().getAttribute(""String_Node_Str"");
  }
  if (swaggerSocketRequest == null) {
    logger.debug(""String_Node_Str"",response.getStatus(),response.getStatusMessage());
    return new byte[0];
  }
  logger.debug(""String_Node_Str"",response.getStatus(),response.getStatusMessage());
  StatusMessage statusMessage=new StatusMessage.Builder().status(new StatusMessage.Status(response.getStatus(),response.getStatusMessage())).identity(swaggerSocketRequest.getUuid()).build();
  try {
    return mapper.writeValueAsBytes(statusMessage);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9466327827191868
8550,"@Override public byte[] filter(AtmosphereResponse r,byte[] message,int offset,int length){
  if (r.request() == null || r.request().getAttribute(""String_Node_Str"") != null) {
    return message;
  }
  if (invalidState((Request)r.request().getAttribute(SWAGGERSOCKET_REQUEST))) {
    logger.error(""String_Node_Str"",message);
    return null;
  }
  try {
    AtmosphereResource ar=(AtmosphereResource)r.request().getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);
    if (ar.transport().equals(AtmosphereResource.TRANSPORT.LONG_POLLING)) {
      String m=""String_Node_Str"";
      try {
        m=new String(message,offset,length,r.getCharacterEncoding());
      }
 catch (      UnsupportedEncodingException e) {
        logger.trace(""String_Node_Str"",e);
      }
      if (!m.endsWith(END_MESSAGE)) {
        StringBuffer cummulatedMessage=(StringBuffer)ar.getRequest().getAttribute(""String_Node_Str"");
        if (cummulatedMessage == null) {
          ar.getRequest().setAttribute(""String_Node_Str"",new StringBuffer(m));
        }
 else {
          cummulatedMessage.append(m);
        }
        return null;
      }
 else {
        m=m.substring(0,m.indexOf(END_MESSAGE));
        StringBuffer cummulatedMessage=(StringBuffer)ar.getRequest().getAttribute(""String_Node_Str"");
        ResponseMessage rm;
        if (cummulatedMessage == null) {
          rm=wrapMessage(r,m);
        }
 else {
          cummulatedMessage.append(m);
          rm=wrapMessage(r,cummulatedMessage.toString());
        }
        ar.getRequest().removeAttribute(""String_Node_Str"");
        return mapper.writeValueAsBytes(rm);
      }
    }
    ResponseMessage m=wrapMessage(r,new String(message,offset,length,r.request().getCharacterEncoding()));
    if (m != null) {
      return mapper.writeValueAsBytes(m);
    }
 else {
      return null;
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","@Override public byte[] filter(AtmosphereResponse r,byte[] message,int offset,int length){
  if (r.request() == null || r.request().getAttribute(""String_Node_Str"") != null) {
    return message;
  }
  if (invalidState((Request)r.request().getAttribute(SWAGGERSOCKET_REQUEST))) {
    logger.error(""String_Node_Str"",message);
    return null;
  }
  try {
    AtmosphereResource ar=(AtmosphereResource)r.request().getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);
    if (ar.transport().equals(AtmosphereResource.TRANSPORT.LONG_POLLING)) {
      String m=""String_Node_Str"";
      try {
        m=new String(message,offset,length,r.getCharacterEncoding());
      }
 catch (      UnsupportedEncodingException e) {
        logger.trace(""String_Node_Str"",e);
      }
      if (ar.isSuspended()) {
        if (!m.endsWith(END_MESSAGE)) {
          StringBuffer cumulatedMessage=(StringBuffer)ar.getRequest().getAttribute(""String_Node_Str"");
          if (cumulatedMessage == null) {
            ar.getRequest().setAttribute(""String_Node_Str"",new StringBuffer(m));
          }
 else {
            cumulatedMessage.append(m);
          }
          return null;
        }
 else {
          m=m.substring(0,m.indexOf(END_MESSAGE));
          StringBuffer cumulatedMessage=(StringBuffer)ar.getRequest().getAttribute(""String_Node_Str"");
          ResponseMessage rm;
          if (cumulatedMessage == null) {
            rm=wrapMessage(r,m);
          }
 else {
            cumulatedMessage.append(m);
            rm=wrapMessage(r,cumulatedMessage.toString());
          }
          ar.getRequest().removeAttribute(""String_Node_Str"");
          return mapper.writeValueAsBytes(rm);
        }
      }
 else {
        ResponseMessage rm=wrapMessage(r,m);
        if (rm != null) {
          return mapper.writeValueAsBytes(rm);
        }
 else {
          return null;
        }
      }
    }
    ResponseMessage m=wrapMessage(r,new String(message,offset,length,r.request().getCharacterEncoding()));
    if (m != null) {
      return mapper.writeValueAsBytes(m);
    }
 else {
      return null;
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9186791522917692
8551,"protected final static ResponseMessage wrapMessage(AtmosphereResponse res,String message){
  Response.Builder builder=new Response.Builder();
  builder.body(message).status(res.getStatus(),res.getStatusMessage());
  Map<String,String> headers=res.headers();
  for (  String s : headers.keySet()) {
    builder.header(new Header(s,headers.get(s)));
  }
  Request swaggerSocketRequest=Request.class.cast(res.request().getAttribute(SWAGGERSOCKET_REQUEST));
  builder.uuid(swaggerSocketRequest.getUuid()).method(swaggerSocketRequest.getMethod()).path(swaggerSocketRequest.getPath());
  String identity=(String)res.request().getAttribute(""String_Node_Str"");
  AtomicInteger expectedResponseCount=(AtomicInteger)res.request().getAttribute(""String_Node_Str"");
  ResponseMessage m=null;
  if (expectedResponseCount != null) {
    m=(ResponseMessage)res.request().getAttribute(ResponseMessage.class.getName());
    if (m != null) {
      m.response(builder.build());
    }
 else {
      m=new ResponseMessage(identity,builder.build());
    }
    if (expectedResponseCount.decrementAndGet() == 0) {
      return m;
    }
 else {
      res.request().setAttribute(ResponseMessage.class.getName(),m);
      return null;
    }
  }
  if (m == null) {
    m=new ResponseMessage(identity,builder.build());
  }
  return m;
}","protected final static ResponseMessage wrapMessage(AtmosphereResponse res,String message){
  Response.Builder builder=new Response.Builder();
  builder.body(message).status(res.getStatus(),res.getStatusMessage());
  Map<String,String> headers=res.headers();
  for (  String s : headers.keySet()) {
    builder.header(new Header(s,headers.get(s)));
  }
  Request swaggerSocketRequest=Request.class.cast(res.request().getAttribute(SWAGGERSOCKET_REQUEST));
  builder.uuid(swaggerSocketRequest.getUuid()).method(swaggerSocketRequest.getMethod()).path(swaggerSocketRequest.getPath());
  String identity=(String)res.request().getAttribute(""String_Node_Str"");
  AtomicInteger expectedResponseCount=(AtomicInteger)res.request().getAttribute(""String_Node_Str"");
  ResponseMessage m=null;
  if (expectedResponseCount != null) {
    m=(ResponseMessage)res.request().getAttribute(ResponseMessage.class.getName());
    if (m != null) {
      m.response(builder.build());
    }
 else {
      m=new ResponseMessage(identity,builder.build());
    }
    if (expectedResponseCount.decrementAndGet() <= 0) {
      return m;
    }
 else {
      res.request().setAttribute(ResponseMessage.class.getName(),m);
      return null;
    }
  }
  if (m == null) {
    m=new ResponseMessage(identity,builder.build());
  }
  return m;
}",0.889739663093415
8552,"@Override protected void doFilter(HttpServletRequest request,HttpServletResponse response,FilterChain chain) throws Exception {
  if (request.getHeader(""String_Node_Str"").equals(""String_Node_Str"")) {
    IeRefreshWrapper requestIE=new IeRefreshWrapper(request);
    chain.doFilter(requestIE,response);
  }
 else {
    chain.doFilter(request,response);
  }
}","@Override protected void doFilter(HttpServletRequest request,HttpServletResponse response,FilterChain chain) throws Exception {
  if (""String_Node_Str"".equals(request.getHeader(""String_Node_Str""))) {
    IeRefreshWrapper requestIE=new IeRefreshWrapper(request);
    chain.doFilter(requestIE,response);
  }
 else {
    chain.doFilter(request,response);
  }
}",0.9467787114845938
8553,"/** 
 * GET  /account/preferences -> get account's preferences
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,produces=""String_Node_Str"") @ResponseBody @Timed public UserPassword setPassword(@RequestBody UserPassword userPassword,HttpServletResponse response){
  this.log.debug(""String_Node_Str"");
  try {
    User currentUser=authenticationService.getCurrentUser();
    StandardPasswordEncoder encoder=new StandardPasswordEncoder();
    if (!encoder.matches(userPassword.getOldPassword(),currentUser.getPassword())) {
      log.debug(""String_Node_Str"",userPassword.getOldPassword());
      throw new Exception(""String_Node_Str"");
    }
    if (!userPassword.getNewPassword().equals(userPassword.getNewPasswordConfirmation())) {
      throw new Exception(""String_Node_Str"");
    }
    currentUser.setPassword(userPassword.getNewPassword());
    userService.updatePassword(currentUser);
    log.debug(""String_Node_Str"",currentUser);
    return new UserPassword();
  }
 catch (  Exception e) {
    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    return null;
  }
}","/** 
 * GET  /account/preferences -> get account's preferences
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,produces=""String_Node_Str"") @ResponseBody @Timed public UserPassword setPassword(@RequestBody UserPassword userPassword,HttpServletResponse response){
  log.debug(""String_Node_Str"");
  try {
    User currentUser=authenticationService.getCurrentUser();
    StandardPasswordEncoder encoder=new StandardPasswordEncoder();
    if (!encoder.matches(userPassword.getOldPassword(),currentUser.getPassword())) {
      log.debug(""String_Node_Str"",userPassword.getOldPassword());
      throw new Exception(""String_Node_Str"");
    }
    if (!userPassword.getNewPassword().equals(userPassword.getNewPasswordConfirmation())) {
      throw new Exception(""String_Node_Str"");
    }
    currentUser.setPassword(userPassword.getNewPassword());
    userService.updatePassword(currentUser);
    log.debug(""String_Node_Str"",currentUser);
    return new UserPassword();
  }
 catch (  Exception e) {
    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    return null;
  }
}",0.9977365323675872
8554,"/** 
 * GET  /account/preferences -> get account's preferences
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody @Timed public Preferences getPreferences(){
  this.log.debug(""String_Node_Str"");
  User currentUser=authenticationService.getCurrentUser();
  User user=userService.getUserByLogin(currentUser.getLogin());
  Preferences preferences=new Preferences(user);
  return preferences;
}","/** 
 * GET  /account/preferences -> get account's preferences
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody @Timed public Preferences getPreferences(){
  log.debug(""String_Node_Str"");
  User currentUser=authenticationService.getCurrentUser();
  User user=userService.getUserByLogin(currentUser.getLogin());
  return new Preferences(user);
}",0.9228971962616822
8555,"/** 
 * POST  /account/preferences -> update account's preferences
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,produces=""String_Node_Str"") @ResponseBody @Timed public Preferences updatePreferences(@RequestBody Preferences newPreferences,HttpServletResponse response){
  this.log.debug(""String_Node_Str"");
  Preferences preferences=null;
  try {
    User currentUser=authenticationService.getCurrentUser();
    currentUser.setPreferencesMentionEmail(newPreferences.getMentionEmail());
    currentUser.setDailyDigestSubscription(newPreferences.getDailyDigest());
    currentUser.setWeeklyDigestSubscription(newPreferences.getWeeklyDigest());
    String rssUid=userService.updateRssTimelinePreferences(newPreferences.getRssUidActive());
    currentUser.setRssUid(rssUid);
    preferences=new Preferences(currentUser);
    userService.updateUser(currentUser);
    userService.updateDailyDigestRegistration(newPreferences.getDailyDigest());
    userService.updateWeeklyDigestRegistration(newPreferences.getWeeklyDigest());
    org.springframework.security.core.userdetails.User securityUser=(org.springframework.security.core.userdetails.User)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    log.debug(""String_Node_Str"",securityUser);
    Authentication authentication=new UsernamePasswordAuthenticationToken(securityUser,securityUser.getPassword(),securityUser.getAuthorities());
    SecurityContextHolder.getContext().setAuthentication(authentication);
    log.debug(""String_Node_Str"",currentUser);
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",e);
    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
  }
 finally {
    return preferences;
  }
}","/** 
 * POST  /account/preferences -> update account's preferences
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,produces=""String_Node_Str"") @ResponseBody @Timed public Preferences updatePreferences(@RequestBody Preferences newPreferences,HttpServletResponse response){
  log.debug(""String_Node_Str"");
  Preferences preferences=null;
  try {
    User currentUser=authenticationService.getCurrentUser();
    currentUser.setPreferencesMentionEmail(newPreferences.getMentionEmail());
    currentUser.setDailyDigestSubscription(newPreferences.getDailyDigest());
    currentUser.setWeeklyDigestSubscription(newPreferences.getWeeklyDigest());
    String rssUid=userService.updateRssTimelinePreferences(newPreferences.getRssUidActive());
    currentUser.setRssUid(rssUid);
    preferences=new Preferences(currentUser);
    userService.updateUser(currentUser);
    userService.updateDailyDigestRegistration(newPreferences.getDailyDigest());
    userService.updateWeeklyDigestRegistration(newPreferences.getWeeklyDigest());
    org.springframework.security.core.userdetails.User securityUser=(org.springframework.security.core.userdetails.User)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    log.debug(""String_Node_Str"",securityUser);
    Authentication authentication=new UsernamePasswordAuthenticationToken(securityUser,securityUser.getPassword(),securityUser.getAuthorities());
    SecurityContextHolder.getContext().setAuthentication(authentication);
    log.debug(""String_Node_Str"",currentUser);
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",e);
    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
  }
  return preferences;
}",0.9813519813519812
8556,"/** 
 * GET  /account/profile -> get account's profile
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody @Timed public User getProfile(){
  this.log.debug(""String_Node_Str"");
  User currentUser=authenticationService.getCurrentUser();
  return userService.getUserByLogin(currentUser.getLogin());
}","/** 
 * GET  /account/profile -> get account's profile
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody @Timed public User getProfile(){
  log.debug(""String_Node_Str"");
  User currentUser=authenticationService.getCurrentUser();
  return userService.getUserByLogin(currentUser.getLogin());
}",0.9929478138222848
8557,"/** 
 * GET /account/admin -> Determines if the current account is an admin
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody @Timed public String isAdmin(){
  this.log.debug(""String_Node_Str"");
  org.springframework.security.core.userdetails.User securityUser=(org.springframework.security.core.userdetails.User)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
  return ""String_Node_Str"" + securityUser.getAuthorities().toString() + ""String_Node_Str"";
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody @Timed public String isAdmin(){
  log.debug(""String_Node_Str"");
  org.springframework.security.core.userdetails.User securityUser=(org.springframework.security.core.userdetails.User)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
  return ""String_Node_Str"" + securityUser.getAuthorities().toString() + ""String_Node_Str"";
}",0.9140546006066734
8558,"public Preferences(User user){
  this.mentionEmail=user.getPreferencesMentionEmail();
  this.weeklyDigest=user.getWeeklyDigestSubscription();
  this.dailyDigest=user.getDailyDigestSubscription();
  if (!StringUtils.isEmpty(user.getRssUid())) {
    this.rssUidActive=true;
    this.rssUid=user.getRssUid();
  }
}","public Preferences(User user){
  this.mentionEmail=user.getPreferencesMentionEmail() || false;
  this.weeklyDigest=user.getWeeklyDigestSubscription() || false;
  this.dailyDigest=user.getDailyDigestSubscription() || false;
  if (!StringUtils.isEmpty(user.getRssUid())) {
    this.rssUidActive=true;
    this.rssUid=user.getRssUid();
  }
}",0.9583975346687212
8559,"public void deleteAttachment(Attachment attachment){
  log.debug(""String_Node_Str"",attachment);
  User currentUser=authenticationService.getCurrentUser();
  for (  String attachmentIdTest : userAttachmentRepository.findAttachmentIds(currentUser.getLogin())) {
    if (attachmentIdTest.equals(attachment.getAttachmentId())) {
      userAttachmentRepository.removeAttachmentId(currentUser.getLogin(),attachment.getAttachmentId());
      attachmentRepository.deleteAttachment(attachment);
      long newAttachmentsSize=currentUser.getAttachmentsSize() - attachment.getSize();
      currentUser.setAttachmentsSize(newAttachmentsSize);
      userRepository.updateUser(currentUser);
      break;
    }
  }
}","public void deleteAttachment(Attachment attachment){
  log.debug(""String_Node_Str"",attachment);
  User currentUser=authenticationService.getCurrentUser();
  for (  String attachmentIdTest : userAttachmentRepository.findAttachmentIds(currentUser.getLogin())) {
    if (attachmentIdTest.equals(attachment.getAttachmentId())) {
      userAttachmentRepository.removeAttachmentId(currentUser.getLogin(),attachment.getAttachmentId());
      attachmentRepository.deleteAttachment(attachment);
      currentUser=authenticationService.getCurrentUser();
      long newAttachmentsSize=currentUser.getAttachmentsSize() - attachment.getSize();
      if (newAttachmentsSize < 0) {
        newAttachmentsSize=0;
      }
      currentUser.setAttachmentsSize(newAttachmentsSize);
      userRepository.updateUser(currentUser);
      break;
    }
  }
}",0.8930899608865711
8560,"public Group buildGroup(User user,Group group){
  if (group != null) {
    if (isGroupManagedByCurrentUser(group)) {
      group.setAdministrator(true);
      group.setMember(true);
    }
 else     if (group.isPublicGroup()) {
      Group result=getGroupFromUser(user,group.getGroupId());
      if (result != null) {
        group.setMember(true);
      }
    }
 else {
      Group result=getGroupFromUser(user,group.getGroupId());
      if (result == null) {
        log.info(""String_Node_Str"",user.getLogin(),group.getGroupId());
        return null;
      }
 else {
        group.setMember(true);
      }
    }
    long counter=0;
    for (    UserGroupDTO userGroup : getMembersForGroup(group.getGroupId(),authenticationService.getCurrentUser().getLogin())) {
      if (userGroup.isActivated()) {
        counter++;
      }
    }
    group.setCounter(counter);
  }
  return group;
}","public Group buildGroup(User user,Group group){
  if (group != null) {
    if (isGroupManagedByCurrentUser(group)) {
      group.setAdministrator(true);
      group.setMember(true);
    }
 else     if (group.isPublicGroup()) {
      Group result=getGroupFromUser(user,group.getGroupId());
      group.setAdministrator(false);
      if (result != null) {
        group.setMember(true);
      }
 else {
        group.setMember(false);
      }
    }
 else {
      Group result=getGroupFromUser(user,group.getGroupId());
      if (result == null) {
        log.info(""String_Node_Str"",user.getLogin(),group.getGroupId());
        group.setMember(false);
        group.setAdministrator(false);
        return null;
      }
 else {
        group.setMember(true);
      }
    }
    long counter=0;
    for (    UserGroupDTO userGroup : getMembersForGroup(group.getGroupId(),authenticationService.getCurrentUser().getLogin())) {
      if (userGroup.isActivated()) {
        counter++;
      }
    }
    group.setCounter(counter);
  }
  return group;
}",0.9190871369294604
8561,"/** 
 * GET  /search/groups"" -> search groups<br>
 * @return a Collection of groups matching the query
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody @Timed public Collection<Group> searchGroups(@RequestParam(""String_Node_Str"") String query){
  String prefix=query.toLowerCase();
  String currentLogin=authenticationService.getCurrentUser().getLogin();
  String domain=DomainUtil.getDomainFromLogin(currentLogin);
  Collection<Group> groups;
  if (query != null && !query.equals(""String_Node_Str"")) {
    this.log.debug(""String_Node_Str"",prefix);
    groups=searchService.searchGroupByPrefix(domain,prefix,5);
  }
 else {
    groups=new ArrayList<Group>();
  }
  return groupService.buildGroupList(groups);
}","/** 
 * GET  /search/groups"" -> search groups<br>
 * @return a Collection of groups matching the query
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody @Timed public Collection<Group> searchGroups(@RequestParam(""String_Node_Str"") String query){
  String prefix=query.toLowerCase();
  String currentLogin=authenticationService.getCurrentUser().getLogin();
  String domain=DomainUtil.getDomainFromLogin(currentLogin);
  Collection<Group> groups;
  if (query != null && !query.equals(""String_Node_Str"")) {
    this.log.debug(""String_Node_Str"",prefix);
    this.log.debug(""String_Node_Str"",currentLogin);
    groups=searchService.searchGroupByPrefix(domain,prefix,5);
  }
 else {
    groups=new ArrayList<Group>();
  }
  return groupService.buildGroupList(groups);
}",0.9674185463659148
8562,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.PATCH) @ResponseBody public StatusDTO updateStatus(@RequestBody ActionStatus action,@PathVariable(""String_Node_Str"") String statusId){
  try {
    StatusDTO status=timelineService.getStatus(statusId);
    if (action.isFavorite() != null && status.isFavorite() != action.isFavorite()) {
      if (action.isFavorite()) {
        timelineService.addFavoriteStatus(statusId);
      }
 else {
        timelineService.removeFavoriteStatus(statusId);
      }
      status.setFavorite(action.isFavorite());
    }
    if (action.isShared() != null && action.isShared()) {
      timelineService.shareStatus(statusId);
    }
    if (action.isAnnounced() != null && action.isAnnounced()) {
      timelineService.announceStatus(statusId);
    }
    return status;
  }
 catch (  Exception e) {
    StringWriter stack=new StringWriter();
    PrintWriter pw=new PrintWriter(stack);
    e.printStackTrace(pw);
    log.debug(""String_Node_Str"",stack.toString());
    return null;
  }
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.PATCH) @ResponseBody public StatusDTO updateStatus(@RequestBody ActionStatus action,@PathVariable(""String_Node_Str"") String statusId){
  try {
    StatusDTO status=timelineService.getStatus(statusId);
    if (action.isFavorite() != null && status.isFavorite() != action.isFavorite()) {
      if (action.isFavorite()) {
        timelineService.addFavoriteStatus(statusId);
      }
 else {
        timelineService.removeFavoriteStatus(statusId);
      }
      status.setFavorite(action.isFavorite());
    }
    if (action.isShared() != null && action.isShared()) {
      timelineService.shareStatus(statusId);
      status.setShareByMe(action.isShared());
    }
    if (action.isAnnounced() != null && action.isAnnounced()) {
      timelineService.announceStatus(statusId);
    }
    return status;
  }
 catch (  Exception e) {
    StringWriter stack=new StringWriter();
    PrintWriter pw=new PrintWriter(stack);
    e.printStackTrace(pw);
    log.debug(""String_Node_Str"",stack.toString());
    return null;
  }
}",0.978095238095238
8563,"/** 
 * POST  /account/preferences -> update account's preferences
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,produces=""String_Node_Str"") @ResponseBody public Preferences updatePreferences(@RequestBody Preferences newPreferences,HttpServletResponse response){
  if (this.log.isDebugEnabled()) {
    this.log.debug(""String_Node_Str"");
  }
  Preferences preferences=null;
  try {
    User currentUser=authenticationService.getCurrentUser();
    if (newPreferences.getTheme().isEmpty()) {
      throw new Exception(""String_Node_Str"");
    }
    currentUser.setTheme((String)newPreferences.getTheme());
    currentUser.setPreferencesMentionEmail((Boolean)newPreferences.getMentionEmail());
    currentUser.setDailyDigestSubscription((Boolean)newPreferences.getDailyDigest());
    currentUser.setWeeklyDigestSubscription((Boolean)newPreferences.getWeeklyDigest());
    String rssUid=userService.updateRssTimelinePreferences(newPreferences.getRssUidActive());
    currentUser.setRssUid(rssUid);
    preferences=new Preferences(currentUser);
    userService.updateUser(currentUser);
    userService.updateThemePreferences(newPreferences.getTheme());
    TatamiUserDetails userDetails=(TatamiUserDetails)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    userDetails.setTheme(newPreferences.getTheme());
    Authentication authentication=new UsernamePasswordAuthenticationToken(userDetails,userDetails.getPassword(),userDetails.getAuthorities());
    SecurityContextHolder.getContext().setAuthentication(authentication);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + currentUser);
    }
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",e);
    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
  }
 finally {
    String themes=env.getProperty(""String_Node_Str"");
    preferences.setThemesList(themes);
    return preferences;
  }
}","/** 
 * POST  /account/preferences -> update account's preferences
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,produces=""String_Node_Str"") @ResponseBody public Preferences updatePreferences(@RequestBody Preferences newPreferences,HttpServletResponse response){
  if (this.log.isDebugEnabled()) {
    this.log.debug(""String_Node_Str"");
  }
  Preferences preferences=null;
  try {
    User currentUser=authenticationService.getCurrentUser();
    if (newPreferences.getTheme().isEmpty()) {
      throw new Exception(""String_Node_Str"");
    }
    currentUser.setTheme((String)newPreferences.getTheme());
    currentUser.setPreferencesMentionEmail((Boolean)newPreferences.getMentionEmail());
    currentUser.setDailyDigestSubscription((Boolean)newPreferences.getDailyDigest());
    currentUser.setWeeklyDigestSubscription((Boolean)newPreferences.getWeeklyDigest());
    String rssUid=userService.updateRssTimelinePreferences(newPreferences.getRssUidActive());
    currentUser.setRssUid(rssUid);
    preferences=new Preferences(currentUser);
    userService.updateUser(currentUser);
    userService.updateDailyDigestRegistration(newPreferences.getDailyDigest());
    userService.updateWeeklyDigestRegistration(newPreferences.getWeeklyDigest());
    userService.updateThemePreferences(newPreferences.getTheme());
    TatamiUserDetails userDetails=(TatamiUserDetails)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    userDetails.setTheme(newPreferences.getTheme());
    Authentication authentication=new UsernamePasswordAuthenticationToken(userDetails,userDetails.getPassword(),userDetails.getAuthorities());
    SecurityContextHolder.getContext().setAuthentication(authentication);
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + currentUser);
    }
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"",e);
    response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
  }
 finally {
    String themes=env.getProperty(""String_Node_Str"");
    preferences.setThemesList(themes);
    return preferences;
  }
}",0.9596009975062344
8564,"@Override public Group getGroupDetails(String groupId){
  Group group=new Group();
  group.setGroupId(groupId);
  group.setPublicGroup(false);
  ColumnSlice<String,String> result=createSliceQuery(keyspaceOperator,StringSerializer.get(),StringSerializer.get(),StringSerializer.get()).setColumnFamily(GROUP_DETAILS_CF).setKey(groupId).setRange(null,null,false,3).execute().get();
  for (  HColumn<String,String> column : result.getColumns()) {
    if (column.getName().equals(NAME)) {
      group.setName(column.getValue());
    }
 else     if (column.getName().equals(DESCRIPTION)) {
      group.setDescription(column.getValue());
    }
 else     if (column.getName().equals(PUBLIC_GROUP)) {
      if (column.getValue().equals(Boolean.TRUE.toString())) {
        group.setPublicGroup(true);
      }
    }
 else     if (column.getName().equals(ARCHIVED_GROUP)) {
      if (column.getValue().equals(Boolean.TRUE.toString())) {
        group.setArchivedGroup(true);
      }
    }
  }
  return group;
}","@Override public Group getGroupDetails(String groupId){
  Group group=new Group();
  group.setGroupId(groupId);
  group.setPublicGroup(false);
  ColumnSlice<String,String> result=createSliceQuery(keyspaceOperator,StringSerializer.get(),StringSerializer.get(),StringSerializer.get()).setColumnFamily(GROUP_DETAILS_CF).setKey(groupId).setRange(null,null,false,4).execute().get();
  for (  HColumn<String,String> column : result.getColumns()) {
    if (column.getName().equals(NAME)) {
      group.setName(column.getValue());
    }
 else     if (column.getName().equals(DESCRIPTION)) {
      group.setDescription(column.getValue());
    }
 else     if (column.getName().equals(PUBLIC_GROUP)) {
      if (column.getValue().equals(Boolean.TRUE.toString())) {
        group.setPublicGroup(true);
      }
    }
 else     if (column.getName().equals(ARCHIVED_GROUP)) {
      if (column.getValue().equals(Boolean.TRUE.toString())) {
        group.setArchivedGroup(true);
      }
    }
  }
  return group;
}",0.9989969909729188
8565,"public void replyToStatus(String content,String replyTo) throws ArchivedGroupException {
  Status originalStatus=statusRepository.findStatusById(replyTo);
  Group group=null;
  if (originalStatus.getGroupId() != null) {
    group=groupService.getGroupById(originalStatus.getDomain(),originalStatus.getGroupId());
  }
  if (group.isArchivedGroup()) {
    throw new ArchivedGroupException();
  }
  if (!originalStatus.getReplyTo().equals(""String_Node_Str"")) {
    Status realOriginalStatus=statusRepository.findStatusById(originalStatus.getDiscussionId());
    Status replyStatus=createStatus(content,realOriginalStatus.getStatusPrivate(),group,realOriginalStatus.getStatusId(),originalStatus.getStatusId(),originalStatus.getUsername());
    discussionRepository.addReplyToDiscussion(realOriginalStatus.getStatusId(),replyStatus.getStatusId());
  }
 else {
    Status replyStatus=createStatus(content,originalStatus.getStatusPrivate(),group,replyTo,replyTo,originalStatus.getUsername());
    discussionRepository.addReplyToDiscussion(originalStatus.getStatusId(),replyStatus.getStatusId());
  }
}","public void replyToStatus(String content,String replyTo) throws ArchivedGroupException {
  Status originalStatus=statusRepository.findStatusById(replyTo);
  Group group=null;
  if (originalStatus.getGroupId() != null) {
    group=groupService.getGroupById(originalStatus.getDomain(),originalStatus.getGroupId());
    if (group.isArchivedGroup()) {
      throw new ArchivedGroupException();
    }
  }
  if (!originalStatus.getReplyTo().equals(""String_Node_Str"")) {
    Status realOriginalStatus=statusRepository.findStatusById(originalStatus.getDiscussionId());
    Status replyStatus=createStatus(content,realOriginalStatus.getStatusPrivate(),group,realOriginalStatus.getStatusId(),originalStatus.getStatusId(),originalStatus.getUsername());
    discussionRepository.addReplyToDiscussion(realOriginalStatus.getStatusId(),replyStatus.getStatusId());
  }
 else {
    Status replyStatus=createStatus(content,originalStatus.getStatusPrivate(),group,replyTo,replyTo,originalStatus.getUsername());
    discussionRepository.addReplyToDiscussion(originalStatus.getStatusId(),replyStatus.getStatusId());
  }
}",0.9954421148587056
8566,"public Collection<Long> getDomainQuota(){
  User currentUser=authenticationService.getCurrentUser();
  DomainConfiguration domainConfiguration=domainConfigurationRepository.findDomainConfigurationByDomain(currentUser.getDomain());
  Long domainQuota=domainConfiguration.getStorageSizeAsLong();
  Long userQuota=currentUser.getAttachmentsSize();
  Collection<Long> globalDomainQuota=new ArrayList<Long>();
  globalDomainQuota.add(userQuota);
  globalDomainQuota.add(domainQuota);
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + domainQuota);
  }
  return globalDomainQuota;
}","public Collection<Integer> getDomainQuota(){
  User currentUser=authenticationService.getCurrentUser();
  DomainConfiguration domainConfiguration=domainConfigurationRepository.findDomainConfigurationByDomain(currentUser.getDomain());
  Long domainQuota=domainConfiguration.getStorageSizeAsLong();
  Long userQuota=currentUser.getAttachmentsSize();
  int quota=Math.round((userQuota * 100) / domainQuota);
  Collection<Integer> taux=new ArrayList<Integer>();
  taux.add(quota);
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + quota);
  }
  return taux;
}",0.814495254529767
8567,"/** 
 * GET /attachment/quota -> get quota for the domain
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public Collection<Long> getDomainQuota(){
  return attachmentService.getDomainQuota();
}","/** 
 * GET /attachment/quota -> get quota in % for the domain
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public Collection<Integer> getDomainQuota(){
  return attachmentService.getDomainQuota();
}",0.9693486590038314
8568,"/** 
 * POST /attachment/destroy -> delete a specific attachment
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE,produces=""String_Node_Str"") @ResponseBody public void DeleteAttachment(@PathVariable(""String_Node_Str"") String attachmentId){
  Attachment attachment=attachmentService.getAttachmentById(attachmentId);
  attachmentService.deleteAttachment(attachment);
}","/** 
 * POST /attachment/{attachmentId} -> delete a specific attachment
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE,produces=""String_Node_Str"") @ResponseBody public void DeleteAttachment(@PathVariable(""String_Node_Str"") String attachmentId){
  Attachment attachment=attachmentService.getAttachmentById(attachmentId);
  attachmentService.deleteAttachment(attachment);
}",0.973248407643312
8569,"/** 
 * GET  /users/suggestions -> suggest users to follow
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public Collection<User> suggestions(){
  User currentUser=authenticationService.getCurrentUser();
  String currentLogin=currentUser.getLogin();
  String currentUsername=DomainUtil.getUsernameFromLogin(currentLogin);
  if (this.log.isDebugEnabled()) {
    this.log.debug(""String_Node_Str"" + currentUsername + ""String_Node_Str"");
  }
  Collection<String> exceptions=userService.getFriendIdsForUser(currentUsername);
  exceptions.add(currentLogin);
  Collection<UserStatusStat> stats=timelineService.getDayline();
  Map<String,User> users=new HashMap<String,User>();
  for (  UserStatusStat stat : stats) {
    User potentialFriend=userService.getUserProfileByUsername(stat.getUsername());
    if (exceptions.contains(potentialFriend.getLogin())) {
      continue;
    }
    users.put(potentialFriend.getUsername(),potentialFriend);
    if (users.size() == 3) {
      break;
    }
  }
  return users.values();
}","/** 
 * GET  /users/suggestions -> suggest users to follow
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public Collection<User> suggestions(){
  User currentUser=authenticationService.getCurrentUser();
  String currentLogin=currentUser.getLogin();
  String currentUsername=DomainUtil.getUsernameFromLogin(currentLogin);
  if (this.log.isDebugEnabled()) {
    this.log.debug(""String_Node_Str"" + currentUsername + ""String_Node_Str"");
  }
  Collection<String> exceptions=userService.getFriendIdsForUser(currentLogin);
  exceptions.add(currentLogin);
  Collection<UserStatusStat> stats=timelineService.getDayline();
  Map<String,User> users=new HashMap<String,User>();
  for (  UserStatusStat stat : stats) {
    User potentialFriend=userService.getUserProfileByUsername(stat.getUsername());
    if (exceptions.contains(potentialFriend.getLogin())) {
      continue;
    }
    users.put(potentialFriend.getUsername(),potentialFriend);
    if (users.size() == 3) {
      break;
    }
  }
  return users.values();
}",0.9939619136089178
8570,"public FaunusTitanGraph(final Configuration configuration,boolean autoTx){
  super(new GraphDatabaseConfiguration(configuration));
  this.tx=(autoTx) ? newTransaction(new TransactionConfig(this.getConfiguration(),false)) : null;
}","public FaunusTitanGraph(final Configuration configuration,boolean autoTx){
  super(new GraphDatabaseConfiguration(configuration));
  this.tx=(autoTx) ? newTransaction(new StandardTransactionBuilder(this.getConfiguration(),this)) : null;
}",0.8504273504273504
8571,"public void completeSequence(){
  if (this.mapSequenceClasses.size() > 0) {
    this.getConf().setStrings(MapSequence.MAP_CLASSES,toStringMapSequenceClasses());
    final Job job;
    try {
      job=new Job(this.getConf(),this.toStringOfJob(MapSequence.class));
    }
 catch (    IOException e) {
      throw new RuntimeException(e.getMessage(),e);
    }
    job.setJarByClass(FaunusCompiler.class);
    job.setMapperClass(MapSequence.Map.class);
    if (null != this.reduceClass) {
      job.setReducerClass(this.reduceClass);
      if (null != this.combinerClass)       job.setCombinerClass(this.combinerClass);
      job.getConfiguration().setBoolean(""String_Node_Str"",true);
      job.getConfiguration().setClass(""String_Node_Str"",DefaultCodec.class,CompressionCodec.class);
    }
 else {
      job.setNumReduceTasks(0);
    }
    job.setMapOutputKeyClass(this.mapOutputKey);
    job.setMapOutputValueClass(this.mapOutputValue);
    if (null != this.comparatorClass)     job.setSortComparatorClass(this.comparatorClass);
    job.setOutputKeyClass(this.outputKey);
    job.setOutputValueClass(this.outputValue);
    this.jobs.add(job);
    this.setConf(new Configuration());
    this.addConfiguration(this.graph.getConfiguration());
    this.mapSequenceClasses.clear();
    this.combinerClass=null;
    this.reduceClass=null;
    this.comparatorClass=null;
  }
}","public void completeSequence(){
  if (this.mapSequenceClasses.size() > 0) {
    this.addConfiguration(this.graph.getConfiguration());
    this.getConf().setStrings(MapSequence.MAP_CLASSES,toStringMapSequenceClasses());
    final Job job;
    try {
      job=new Job(this.getConf(),this.toStringOfJob(MapSequence.class));
    }
 catch (    IOException e) {
      throw new RuntimeException(e.getMessage(),e);
    }
    job.setJarByClass(FaunusCompiler.class);
    job.setMapperClass(MapSequence.Map.class);
    if (null != this.reduceClass) {
      job.setReducerClass(this.reduceClass);
      if (null != this.combinerClass)       job.setCombinerClass(this.combinerClass);
      job.getConfiguration().setBoolean(""String_Node_Str"",true);
      job.getConfiguration().setClass(""String_Node_Str"",DefaultCodec.class,CompressionCodec.class);
    }
 else {
      job.setNumReduceTasks(0);
    }
    job.setMapOutputKeyClass(this.mapOutputKey);
    job.setMapOutputValueClass(this.mapOutputValue);
    if (null != this.comparatorClass)     job.setSortComparatorClass(this.comparatorClass);
    job.setOutputKeyClass(this.outputKey);
    job.setOutputValueClass(this.outputValue);
    this.jobs.add(job);
    this.setConf(new Configuration());
    this.mapSequenceClasses.clear();
    this.combinerClass=null;
    this.reduceClass=null;
    this.comparatorClass=null;
  }
}",0.8982430453879942
8572,"public FaunusCompiler(final FaunusGraph graph){
  this.graph=graph;
  this.setConf(new Configuration());
  this.addConfiguration(this.graph.getConfiguration());
}","public FaunusCompiler(final FaunusGraph graph){
  this.graph=graph;
  this.setConf(new Configuration());
}",0.7910447761194029
8573,"private FaunusPipeline done(){
  if (!this.state.isLocked()) {
    final Pair<String,Class<? extends WritableComparable>> pair=this.state.popProperty();
    if (null != pair) {
      this.compiler.addMap(PropertyMap.Map.class,LongWritable.class,pair.getB(),PropertyMap.createConfiguration(this.state.getElementType(),pair.getA(),pair.getB()));
      makeMapReduceString(PropertyMap.class,pair.getA());
    }
    this.state.lock();
  }
  this.compiler.completeSequence();
  return this;
}","private FaunusPipeline done(){
  if (!this.state.isLocked()) {
    final Pair<String,Class<? extends WritableComparable>> pair=this.state.popProperty();
    if (null != pair) {
      this.compiler.addMap(PropertyMap.Map.class,LongWritable.class,pair.getB(),PropertyMap.createConfiguration(this.state.getElementType(),pair.getA(),pair.getB()));
      makeMapReduceString(PropertyMap.class,pair.getA());
      this.state.lock();
    }
  }
  return this;
}",0.8787234042553191
8574,"/** 
 * Submit the FaunusPipeline to the Hadoop cluster and ensure that a header is emitted in the logs.
 * @param script     the Gremlin script
 * @param showHeader the Faunus header
 * @throws Exception
 */
public void submit(final String script,final Boolean showHeader) throws Exception {
  this.done();
  if (MapReduceFormat.class.isAssignableFrom(this.graph.getGraphOutputFormat())) {
    this.state.checkLocked();
    ((Class<? extends MapReduceFormat>)this.graph.getGraphOutputFormat()).getConstructor().newInstance().addMapReduceJobs(this.compiler);
  }
  ToolRunner.run(this.compiler,new String[]{script,showHeader.toString()});
}","/** 
 * Submit the FaunusPipeline to the Hadoop cluster and ensure that a header is emitted in the logs.
 * @param script     the Gremlin script
 * @param showHeader the Faunus header
 * @throws Exception
 */
public void submit(final String script,final Boolean showHeader) throws Exception {
  this.done();
  if (MapReduceFormat.class.isAssignableFrom(this.graph.getGraphOutputFormat())) {
    this.state.checkLocked();
    ((Class<? extends MapReduceFormat>)this.graph.getGraphOutputFormat()).getConstructor().newInstance().addMapReduceJobs(this.compiler);
  }
  this.compiler.completeSequence();
  ToolRunner.run(this.compiler,new String[]{script,showHeader.toString()});
}",0.972644376899696
8575,"public static Graph generateGraph(final Configuration config,final String prefix){
  return TitanFactory.open(generateTitanConfiguration(config,prefix));
}","public synchronized static Graph generateGraph(final Configuration config,final String prefix){
  if (null == graph)   graph=TitanFactory.open(generateTitanConfiguration(config,prefix));
  return graph;
}",0.8245125348189415
8576,"@Override public void addMapReduceJobs(final FaunusCompiler compiler){
  if (compiler.getConf().getBoolean(FAUNUS_GRAPH_OUTPUT_TITAN_INFER_SCHEMA,true)) {
    compiler.addMapReduce(SchemaInferencerMapReduce.Map.class,null,SchemaInferencerMapReduce.Reduce.class,LongWritable.class,FaunusVertex.class,NullWritable.class,FaunusVertex.class,new Configuration());
  }
  compiler.addMapReduce(BlueprintsGraphOutputMapReduce.Map.class,null,BlueprintsGraphOutputMapReduce.Reduce.class,LongWritable.class,Holder.class,NullWritable.class,FaunusVertex.class,new Configuration());
}","@Override public void addMapReduceJobs(final FaunusCompiler compiler){
  if (compiler.getConf().getBoolean(FAUNUS_GRAPH_OUTPUT_TITAN_INFER_SCHEMA,true)) {
    compiler.addMapReduce(SchemaInferencerMapReduce.Map.class,null,SchemaInferencerMapReduce.Reduce.class,LongWritable.class,FaunusVertex.class,NullWritable.class,FaunusVertex.class,new Configuration());
  }
  compiler.addMapReduce(BlueprintsGraphOutputMapReduce.Map.class,null,BlueprintsGraphOutputMapReduce.Reduce.class,LongWritable.class,Holder.class,NullWritable.class,FaunusVertex.class,BlueprintsGraphOutputMapReduce.createConfiguration());
}",0.9650468883205456
8577,"public void completeSequence(){
  if (this.mapSequenceClasses.size() > 0) {
    this.getConf().setStrings(MapSequence.MAP_CLASSES,toStringMapSequenceClasses());
    final Job job;
    try {
      job=new Job(this.getConf(),this.toStringOfJob(MapSequence.class));
    }
 catch (    IOException e) {
      throw new RuntimeException(e.getMessage(),e);
    }
    for (    final Map.Entry<String,String> entry : this.graph.getConfiguration()) {
      job.getConfiguration().set(entry.getKey(),entry.getValue());
    }
    job.setJarByClass(FaunusCompiler.class);
    job.setMapperClass(MapSequence.Map.class);
    if (null != this.reduceClass) {
      job.setReducerClass(this.reduceClass);
      if (null != this.combinerClass)       job.setCombinerClass(this.combinerClass);
      job.getConfiguration().setBoolean(""String_Node_Str"",true);
      job.getConfiguration().setClass(""String_Node_Str"",DefaultCodec.class,CompressionCodec.class);
    }
 else {
      job.setNumReduceTasks(0);
    }
    if (this.mapSequenceClasses.contains(BlueprintsGraphOutputMapReduce.Map.class)) {
      job.setMapSpeculativeExecution(false);
      job.setReduceSpeculativeExecution(false);
    }
    job.setMapOutputKeyClass(this.mapOutputKey);
    job.setMapOutputValueClass(this.mapOutputValue);
    job.setOutputKeyClass(this.outputKey);
    job.setOutputValueClass(this.outputValue);
    if (null != this.comparatorClass)     job.setSortComparatorClass(this.comparatorClass);
    this.jobs.add(job);
    this.setConf(new Configuration());
    this.addConfiguration(this.graph.getConfiguration());
    this.mapSequenceClasses.clear();
    this.combinerClass=null;
    this.reduceClass=null;
    this.comparatorClass=null;
  }
}","public void completeSequence(){
  if (this.mapSequenceClasses.size() > 0) {
    this.getConf().setStrings(MapSequence.MAP_CLASSES,toStringMapSequenceClasses());
    final Job job;
    try {
      job=new Job(this.getConf(),this.toStringOfJob(MapSequence.class));
    }
 catch (    IOException e) {
      throw new RuntimeException(e.getMessage(),e);
    }
    job.setJarByClass(FaunusCompiler.class);
    job.setMapperClass(MapSequence.Map.class);
    if (null != this.reduceClass) {
      job.setReducerClass(this.reduceClass);
      if (null != this.combinerClass)       job.setCombinerClass(this.combinerClass);
      job.getConfiguration().setBoolean(""String_Node_Str"",true);
      job.getConfiguration().setClass(""String_Node_Str"",DefaultCodec.class,CompressionCodec.class);
    }
 else {
      job.setNumReduceTasks(0);
    }
    job.setMapOutputKeyClass(this.mapOutputKey);
    job.setMapOutputValueClass(this.mapOutputValue);
    job.setOutputKeyClass(this.outputKey);
    job.setOutputValueClass(this.outputValue);
    if (null != this.comparatorClass)     job.setSortComparatorClass(this.comparatorClass);
    this.jobs.add(job);
    this.setConf(new Configuration());
    this.addConfiguration(this.graph.getConfiguration());
    this.mapSequenceClasses.clear();
    this.combinerClass=null;
    this.reduceClass=null;
    this.comparatorClass=null;
  }
}",0.8884552845528455
8578,"public void composeJobs() throws IOException {
  if (this.jobs.size() == 0) {
    return;
  }
  final String hadoopFileJar;
  if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists())   hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
 else   if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists())   hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
 else   if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists())   hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
 else   if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists())   hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
 else   throw new IllegalStateException(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR);
  if (this.pathEnabled)   logger.warn(""String_Node_Str"");
  for (  final Job job : this.jobs) {
    job.getConfiguration().setBoolean(PATH_ENABLED,this.pathEnabled);
    job.getConfiguration().set(""String_Node_Str"",hadoopFileJar);
  }
  final FileSystem hdfs=FileSystem.get(this.graph.getConfiguration());
  final String outputJobPrefix=this.graph.getOutputLocation().toString() + ""String_Node_Str"" + Tokens.JOB;
  hdfs.mkdirs(this.graph.getOutputLocation());
  if (FileInputFormat.class.isAssignableFrom(this.graph.getGraphInputFormat())) {
    FileInputFormat.setInputPaths(this.jobs.get(0),this.graph.getInputLocation());
    FileInputFormat.setInputPathFilter(this.jobs.get(0),NoSideEffectFilter.class);
  }
  for (int i=0; i < this.jobs.size(); i++) {
    final Job job=this.jobs.get(i);
    final Path path=new Path(outputJobPrefix + ""String_Node_Str"" + i);
    FileOutputFormat.setOutputPath(job,path);
    if (i == 0) {
      job.setInputFormatClass(this.graph.getGraphInputFormat());
    }
 else {
      job.setInputFormatClass(INTERMEDIATE_INPUT_FORMAT);
      FileInputFormat.setInputPathFilter(job,GraphFilter.class);
      FileInputFormat.addInputPath(job,new Path(outputJobPrefix + ""String_Node_Str"" + (i - 1)));
    }
    if (i == this.jobs.size() - 1) {
      LazyOutputFormat.setOutputFormatClass(job,this.graph.getGraphOutputFormat());
      MultipleOutputs.addNamedOutput(job,Tokens.SIDEEFFECT,this.graph.getSideEffectOutputFormat(),job.getOutputKeyClass(),job.getOutputKeyClass());
      MultipleOutputs.addNamedOutput(job,Tokens.GRAPH,this.graph.getGraphOutputFormat(),NullWritable.class,FaunusVertex.class);
    }
 else {
      LazyOutputFormat.setOutputFormatClass(job,INTERMEDIATE_OUTPUT_FORMAT);
      MultipleOutputs.addNamedOutput(job,Tokens.SIDEEFFECT,this.graph.getSideEffectOutputFormat(),job.getOutputKeyClass(),job.getOutputKeyClass());
      MultipleOutputs.addNamedOutput(job,Tokens.GRAPH,INTERMEDIATE_OUTPUT_FORMAT,NullWritable.class,FaunusVertex.class);
    }
  }
}","public void composeJobs() throws IOException {
  if (this.jobs.size() == 0) {
    return;
  }
  String hadoopFileJar=null;
  if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists()) {
    logger.warn(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR);
    hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
  }
 else   if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists()) {
    logger.warn(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR);
    hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
  }
 else {
    final String faunusHome=System.getProperty(Tokens.FAUNUS_HOME);
    if (null == faunusHome || faunusHome.isEmpty())     throw new IllegalStateException(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR);
    if (new File(faunusHome + ""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists()) {
      hadoopFileJar=faunusHome + ""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
    }
  }
  if (null == hadoopFileJar)   throw new IllegalStateException(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR);
  if (this.pathEnabled)   logger.warn(""String_Node_Str"");
  for (  final Job job : this.jobs) {
    job.getConfiguration().setBoolean(PATH_ENABLED,this.pathEnabled);
    job.getConfiguration().set(""String_Node_Str"",hadoopFileJar);
  }
  final FileSystem hdfs=FileSystem.get(this.graph.getConfiguration());
  final String outputJobPrefix=this.graph.getOutputLocation().toString() + ""String_Node_Str"" + Tokens.JOB;
  hdfs.mkdirs(this.graph.getOutputLocation());
  if (FileInputFormat.class.isAssignableFrom(this.graph.getGraphInputFormat())) {
    FileInputFormat.setInputPaths(this.jobs.get(0),this.graph.getInputLocation());
    FileInputFormat.setInputPathFilter(this.jobs.get(0),NoSideEffectFilter.class);
  }
  for (int i=0; i < this.jobs.size(); i++) {
    final Job job=this.jobs.get(i);
    final Path path=new Path(outputJobPrefix + ""String_Node_Str"" + i);
    FileOutputFormat.setOutputPath(job,path);
    if (i == 0) {
      job.setInputFormatClass(this.graph.getGraphInputFormat());
    }
 else {
      job.setInputFormatClass(INTERMEDIATE_INPUT_FORMAT);
      FileInputFormat.setInputPathFilter(job,GraphFilter.class);
      FileInputFormat.addInputPath(job,new Path(outputJobPrefix + ""String_Node_Str"" + (i - 1)));
    }
    if (i == this.jobs.size() - 1) {
      LazyOutputFormat.setOutputFormatClass(job,this.graph.getGraphOutputFormat());
      MultipleOutputs.addNamedOutput(job,Tokens.SIDEEFFECT,this.graph.getSideEffectOutputFormat(),job.getOutputKeyClass(),job.getOutputKeyClass());
      MultipleOutputs.addNamedOutput(job,Tokens.GRAPH,this.graph.getGraphOutputFormat(),NullWritable.class,FaunusVertex.class);
    }
 else {
      LazyOutputFormat.setOutputFormatClass(job,INTERMEDIATE_OUTPUT_FORMAT);
      MultipleOutputs.addNamedOutput(job,Tokens.SIDEEFFECT,this.graph.getSideEffectOutputFormat(),job.getOutputKeyClass(),job.getOutputKeyClass());
      MultipleOutputs.addNamedOutput(job,Tokens.GRAPH,INTERMEDIATE_OUTPUT_FORMAT,NullWritable.class,FaunusVertex.class);
    }
  }
}",0.8904372060616618
8579,"@Override public void reduce(final LongWritable key,final Iterable<Holder> values,final Reducer<LongWritable,Holder,NullWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  final FaunusVertex vertex=new FaunusVertex(key.get());
  for (  final Holder holder : values) {
    if (holder.getTag() == 'o') {
      vertex.addEdge(OUT,(FaunusEdge)holder.get());
      context.getCounter(Counters.OUT_EDGES_CREATED).increment(1l);
    }
 else     if (holder.getTag() == 'i') {
      vertex.addEdge(IN,(FaunusEdge)holder.get());
      context.getCounter(Counters.IN_EDGES_CREATED).increment(1l);
    }
 else {
      final FaunusVertex temp=(FaunusVertex)holder.get();
      for (      final String property : temp.getPropertyKeys()) {
        vertex.setProperty(property,temp.getProperty(property));
      }
      vertex.addEdges(BOTH,temp);
    }
  }
  context.write(NullWritable.get(),vertex);
  context.getCounter(Counters.VERTICES_CREATED).increment(1l);
}","@Override public void reduce(final LongWritable key,final Iterable<Holder> values,final Reducer<LongWritable,Holder,NullWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  final FaunusVertex vertex=new FaunusVertex(key.get());
  for (  final Holder holder : values) {
    if (holder.getTag() == 'o') {
      vertex.addEdge(OUT,(FaunusEdge)holder.get());
      context.getCounter(Counters.OUT_EDGES_CREATED).increment(1l);
    }
 else     if (holder.getTag() == 'i') {
      vertex.addEdge(IN,(FaunusEdge)holder.get());
      context.getCounter(Counters.IN_EDGES_CREATED).increment(1l);
    }
 else {
      final FaunusVertex temp=(FaunusVertex)holder.get();
      for (      final String property : temp.getPropertyKeys()) {
        vertex.setProperty(property,temp.getProperty(property));
      }
      vertex.addEdges(BOTH,temp);
      context.getCounter(Counters.OUT_EDGES_CREATED).increment(((List)temp.getEdges(OUT)).size());
      context.getCounter(Counters.IN_EDGES_CREATED).increment(((List)temp.getEdges(IN)).size());
    }
  }
  context.write(NullWritable.get(),vertex);
  context.getCounter(Counters.VERTICES_CREATED).increment(1l);
}",0.9093432007400556
8580,"@Override public void reduce(final LongWritable key,final Iterable<FaunusVertex> values,final Reducer<LongWritable,FaunusVertex,NullWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  this.vertex.reuse(key.get());
  for (  final FaunusVertex value : values) {
    this.vertex.addEdges(BOTH,value);
    this.vertex.getProperties().putAll(value.getProperties());
  }
  context.write(NullWritable.get(),this.vertex);
  context.getCounter(Counters.VERTICES_CREATED).increment(1l);
  context.getCounter(Counters.VERTEX_PROPERTIES_CREATED).increment(this.vertex.getProperties().size());
  context.getCounter(Counters.OUT_EDGES_CREATED).increment(((List)this.vertex.getEdges(OUT)).size());
  context.getCounter(Counters.IN_EDGES_CREATED).increment(((List)this.vertex.getEdges(IN)).size());
  context.write(NullWritable.get(),this.vertex);
}","@Override public void reduce(final LongWritable key,final Iterable<FaunusVertex> values,final Reducer<LongWritable,FaunusVertex,NullWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  this.vertex.reuse(key.get());
  for (  final FaunusVertex value : values) {
    this.vertex.addEdges(BOTH,value);
    this.vertex.getProperties().putAll(value.getProperties());
  }
  context.getCounter(Counters.VERTICES_CREATED).increment(1l);
  context.getCounter(Counters.VERTEX_PROPERTIES_CREATED).increment(this.vertex.getProperties().size());
  context.getCounter(Counters.OUT_EDGES_CREATED).increment(((List)this.vertex.getEdges(OUT)).size());
  context.getCounter(Counters.IN_EDGES_CREATED).increment(((List)this.vertex.getEdges(IN)).size());
  context.write(NullWritable.get(),this.vertex);
}",0.9708853238265004
8581,"@Override public void map(final NullWritable key,final FaunusElement value,final Mapper<NullWritable,FaunusElement,LongWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  if (value instanceof FaunusEdge) {
    final long outId=((FaunusEdge)value).getVertexId(OUT);
    final long inId=((FaunusEdge)value).getVertexId(IN);
    FaunusVertex vertex=this.map.get(outId);
    if (null == vertex) {
      vertex=new FaunusVertex(outId);
      this.map.put(outId,vertex);
    }
    vertex.addEdge(OUT,(FaunusEdge)value);
    vertex=this.map.get(inId);
    if (null == vertex) {
      vertex=new FaunusVertex(inId);
      this.map.put(inId,vertex);
    }
    vertex.addEdge(IN,(FaunusEdge)value);
    context.getCounter(Counters.EDGES_PROCESSED).increment(1l);
    this.counter++;
  }
 else {
    final long id=value.getIdAsLong();
    FaunusVertex vertex=this.map.get(id);
    if (null == vertex) {
      vertex=new FaunusVertex(id);
      this.map.put(id,vertex);
    }
    vertex.getProperties().putAll(value.getProperties());
    vertex.addEdges(BOTH,(FaunusVertex)value);
    this.counter++;
  }
  if (this.counter > MAX_MAP_SIZE)   this.flush(context);
}","@Override public void map(final NullWritable key,final FaunusElement value,final Mapper<NullWritable,FaunusElement,LongWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  if (value instanceof FaunusEdge) {
    final long outId=((FaunusEdge)value).getVertexId(OUT);
    final long inId=((FaunusEdge)value).getVertexId(IN);
    FaunusVertex vertex=this.map.get(outId);
    if (null == vertex) {
      vertex=new FaunusVertex(outId);
      this.map.put(outId,vertex);
    }
    vertex.addEdge(OUT,(FaunusEdge)value);
    this.counter++;
    vertex=this.map.get(inId);
    if (null == vertex) {
      vertex=new FaunusVertex(inId);
      this.map.put(inId,vertex);
    }
    vertex.addEdge(IN,(FaunusEdge)value);
    context.getCounter(Counters.EDGES_PROCESSED).increment(1l);
    this.counter++;
  }
 else {
    final long id=value.getIdAsLong();
    FaunusVertex vertex=this.map.get(id);
    if (null == vertex) {
      vertex=new FaunusVertex(id);
      this.map.put(id,vertex);
    }
    vertex.getProperties().putAll(value.getProperties());
    vertex.addEdges(BOTH,(FaunusVertex)value);
    this.counter++;
  }
  if (this.counter > MAX_MAP_SIZE)   this.flush(context);
}",0.99163179916318
8582,"@Override public void map(final NullWritable key,final FaunusVertex value,final Mapper<NullWritable,FaunusVertex,NullWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  if (this.isVertex) {
    if (value.hasPaths()) {
      for (int i=0; i < value.pathCount(); i++) {
        this.closure.call(value);
      }
      context.getCounter(Counters.VERTICES_PROCESSED).increment(1);
    }
  }
 else {
    long edgesProcessed=0;
    for (    final Edge e : value.getEdges(Direction.OUT)) {
      final FaunusEdge edge=(FaunusEdge)e;
      if (edge.hasPaths()) {
        edgesProcessed++;
        for (int i=0; i < edge.pathCount(); i++) {
          this.closure.call(edge);
        }
      }
    }
    context.getCounter(Counters.OUT_EDGES_PROCESSED).increment(edgesProcessed);
  }
  context.write(NullWritable.get(),value);
}","@Override public void map(final NullWritable key,final FaunusVertex value,final Mapper<NullWritable,FaunusVertex,NullWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  if (this.isVertex) {
    if (value.hasPaths()) {
      this.closure.call(value);
      context.getCounter(Counters.VERTICES_PROCESSED).increment(1);
    }
  }
 else {
    long edgesProcessed=0;
    for (    final Edge e : value.getEdges(Direction.OUT)) {
      final FaunusEdge edge=(FaunusEdge)e;
      if (edge.hasPaths()) {
        edgesProcessed++;
        this.closure.call(edge);
      }
    }
    context.getCounter(Counters.OUT_EDGES_PROCESSED).increment(edgesProcessed);
  }
  context.write(NullWritable.get(),value);
}",0.8629185091598232
8583,"public void setInputLocation(final Path path){
  this.configuration.set(INPUT_LOCATION,path.toString());
}","public void setInputLocation(final String path){
  this.setInputLocation(new Path(path));
}",0.700507614213198
8584,"public void setOutputLocation(final Path path){
  this.configuration.set(OUTPUT_LOCATION,path.toString());
}","public void setOutputLocation(final String path){
  this.setOutputLocation(new Path(path));
}",0.6965174129353234
8585,"public void composeJobs() throws IOException {
  if (this.jobs.size() == 0) {
    return;
  }
  final String hadoopFileJar;
  if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists())   hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
 else   if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists())   hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
 else   if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists())   hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
 else   throw new IllegalStateException(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR);
  if (this.pathEnabled)   logger.warn(""String_Node_Str"");
  for (  final Job job : this.jobs) {
    job.getConfiguration().setBoolean(PATH_ENABLED,this.pathEnabled);
    job.getConfiguration().set(""String_Node_Str"",hadoopFileJar);
  }
  final FileSystem hdfs=FileSystem.get(this.graph.getConfiguration());
  final String outputJobPrefix=this.graph.getOutputLocation().getName() + ""String_Node_Str"" + Tokens.JOB;
  hdfs.mkdirs(new Path(this.graph.getOutputLocation().getName()));
  if (FileInputFormat.class.isAssignableFrom(this.graph.getGraphInputFormat())) {
    FileInputFormat.setInputPaths(this.jobs.get(0),this.graph.getInputLocation());
    FileInputFormat.setInputPathFilter(this.jobs.get(0),GraphFilter.class);
  }
 else   if (this.graph.getGraphInputFormat().equals(RexsterInputFormat.class)) {
  }
 else   if (this.graph.getGraphInputFormat().equals(TitanCassandraInputFormat.class)) {
    ConfigHelper.setInputColumnFamily(this.jobs.get(0).getConfiguration(),ConfigHelper.getInputKeyspace(this.graph.getConfiguration()),""String_Node_Str"");
    final SlicePredicate predicate=new SlicePredicate();
    final SliceRange sliceRange=new SliceRange();
    sliceRange.setStart(new byte[0]);
    sliceRange.setFinish(new byte[0]);
    predicate.setSlice_range(sliceRange);
    ConfigHelper.setInputSlicePredicate(this.jobs.get(0).getConfiguration(),predicate);
  }
 else   throw new IOException(this.graph.getGraphInputFormat().getName() + ""String_Node_Str"");
  for (int i=0; i < this.jobs.size(); i++) {
    final Job job=this.jobs.get(i);
    final Path path=new Path(outputJobPrefix + ""String_Node_Str"" + i);
    FileOutputFormat.setOutputPath(job,path);
    if (i == 0) {
      job.setInputFormatClass(this.graph.getGraphInputFormat());
    }
 else {
      job.setInputFormatClass(INTERMEDIATE_INPUT_FORMAT);
      FileInputFormat.setInputPathFilter(job,GraphFilter.class);
      FileInputFormat.addInputPath(job,new Path(outputJobPrefix + ""String_Node_Str"" + (i - 1)));
    }
    if (i == this.jobs.size() - 1) {
      MultipleOutputs.addNamedOutput(job,Tokens.SIDEEFFECT,this.graph.getSideEffectOutputFormat(),job.getOutputKeyClass(),job.getOutputKeyClass());
      MultipleOutputs.addNamedOutput(job,Tokens.GRAPH,this.graph.getGraphOutputFormat(),NullWritable.class,FaunusVertex.class);
      LazyOutputFormat.setOutputFormatClass(job,this.graph.getGraphOutputFormat());
    }
 else {
      MultipleOutputs.addNamedOutput(job,Tokens.SIDEEFFECT,this.graph.getSideEffectOutputFormat(),job.getOutputKeyClass(),job.getOutputKeyClass());
      MultipleOutputs.addNamedOutput(job,Tokens.GRAPH,INTERMEDIATE_OUTPUT_FORMAT,NullWritable.class,FaunusVertex.class);
      LazyOutputFormat.setOutputFormatClass(job,INTERMEDIATE_OUTPUT_FORMAT);
    }
    SequenceFileOutputFormat.setCompressOutput(job,true);
    SequenceFileOutputFormat.setOutputCompressorClass(job,BZip2Codec.class);
    SequenceFileOutputFormat.setOutputCompressionType(job,SequenceFile.CompressionType.BLOCK);
  }
}","public void composeJobs() throws IOException {
  if (this.jobs.size() == 0) {
    return;
  }
  final String hadoopFileJar;
  if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists())   hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
 else   if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists())   hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
 else   if (new File(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR).exists())   hadoopFileJar=""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR;
 else   throw new IllegalStateException(""String_Node_Str"" + Tokens.FAUNUS_JOB_JAR);
  if (this.pathEnabled)   logger.warn(""String_Node_Str"");
  for (  final Job job : this.jobs) {
    job.getConfiguration().setBoolean(PATH_ENABLED,this.pathEnabled);
    job.getConfiguration().set(""String_Node_Str"",hadoopFileJar);
  }
  final FileSystem hdfs=FileSystem.get(this.graph.getConfiguration());
  final String outputJobPrefix=this.graph.getOutputLocation().getName() + ""String_Node_Str"" + Tokens.JOB;
  hdfs.mkdirs(new Path(this.graph.getOutputLocation().getName()));
  if (FileInputFormat.class.isAssignableFrom(this.graph.getGraphInputFormat())) {
    FileInputFormat.setInputPaths(this.jobs.get(0),this.graph.getInputLocation());
    FileInputFormat.setInputPathFilter(this.jobs.get(0),NoSideEffectFilter.class);
  }
 else   if (this.graph.getGraphInputFormat().equals(RexsterInputFormat.class)) {
  }
 else   if (this.graph.getGraphInputFormat().equals(TitanCassandraInputFormat.class)) {
    ConfigHelper.setInputColumnFamily(this.jobs.get(0).getConfiguration(),ConfigHelper.getInputKeyspace(this.graph.getConfiguration()),""String_Node_Str"");
    final SlicePredicate predicate=new SlicePredicate();
    final SliceRange sliceRange=new SliceRange();
    sliceRange.setStart(new byte[0]);
    sliceRange.setFinish(new byte[0]);
    predicate.setSlice_range(sliceRange);
    ConfigHelper.setInputSlicePredicate(this.jobs.get(0).getConfiguration(),predicate);
  }
 else   throw new IOException(this.graph.getGraphInputFormat().getName() + ""String_Node_Str"");
  for (int i=0; i < this.jobs.size(); i++) {
    final Job job=this.jobs.get(i);
    final Path path=new Path(outputJobPrefix + ""String_Node_Str"" + i);
    FileOutputFormat.setOutputPath(job,path);
    if (i == 0) {
      job.setInputFormatClass(this.graph.getGraphInputFormat());
    }
 else {
      job.setInputFormatClass(INTERMEDIATE_INPUT_FORMAT);
      FileInputFormat.setInputPathFilter(job,GraphFilter.class);
      FileInputFormat.addInputPath(job,new Path(outputJobPrefix + ""String_Node_Str"" + (i - 1)));
    }
    if (i == this.jobs.size() - 1) {
      MultipleOutputs.addNamedOutput(job,Tokens.SIDEEFFECT,this.graph.getSideEffectOutputFormat(),job.getOutputKeyClass(),job.getOutputKeyClass());
      MultipleOutputs.addNamedOutput(job,Tokens.GRAPH,this.graph.getGraphOutputFormat(),NullWritable.class,FaunusVertex.class);
      LazyOutputFormat.setOutputFormatClass(job,this.graph.getGraphOutputFormat());
    }
 else {
      MultipleOutputs.addNamedOutput(job,Tokens.SIDEEFFECT,this.graph.getSideEffectOutputFormat(),job.getOutputKeyClass(),job.getOutputKeyClass());
      MultipleOutputs.addNamedOutput(job,Tokens.GRAPH,INTERMEDIATE_OUTPUT_FORMAT,NullWritable.class,FaunusVertex.class);
      LazyOutputFormat.setOutputFormatClass(job,INTERMEDIATE_OUTPUT_FORMAT);
    }
    SequenceFileOutputFormat.setCompressOutput(job,true);
    SequenceFileOutputFormat.setOutputCompressorClass(job,BZip2Codec.class);
    SequenceFileOutputFormat.setOutputCompressionType(job,SequenceFile.CompressionType.BLOCK);
  }
}",0.997631322279504
8586,"@Override public void map(final NullWritable key,final FaunusVertex value,final Mapper<NullWritable,FaunusVertex,Text,LongWritable>.Context context) throws IOException, InterruptedException {
  if (this.isVertex) {
    if (value.hasPaths()) {
      final Object object=(null == this.keyClosure) ? value : this.keyClosure.call(value);
      final Number number=(null == this.valueClosure) ? 1 : (Number)this.valueClosure.call(value);
      this.map.incr(object,number.longValue() * value.pathCount());
      context.getCounter(Counters.VERTICES_PROCESSED).increment(1l);
    }
  }
 else {
    long edgesProcessed=0;
    for (    final Edge e : value.getEdges(Direction.OUT)) {
      final FaunusEdge edge=(FaunusEdge)e;
      if (edge.hasPaths()) {
        final Object object=(null == this.keyClosure) ? edge : this.keyClosure.call(edge);
        final Number number=(null == this.valueClosure) ? 1 : (Number)this.valueClosure.call(edge);
        this.map.incr(object,number.longValue() * edge.pathCount());
        edgesProcessed++;
      }
    }
    context.getCounter(Counters.OUT_EDGES_PROCESSED).increment(edgesProcessed);
  }
  if (this.map.size() > 1000) {
    this.cleanup(context);
  }
  this.outputs.write(Tokens.GRAPH,NullWritable.get(),value);
}","@Override public void map(final NullWritable key,final FaunusVertex value,final Mapper<NullWritable,FaunusVertex,Text,LongWritable>.Context context) throws IOException, InterruptedException {
  if (this.isVertex) {
    if (value.hasPaths()) {
      final Object object=(null == this.keyClosure) ? new MicroVertex(value.getIdAsLong()) : this.keyClosure.call(value);
      final Number number=(null == this.valueClosure) ? 1 : (Number)this.valueClosure.call(value);
      this.map.incr(object,number.longValue() * value.pathCount());
      context.getCounter(Counters.VERTICES_PROCESSED).increment(1l);
    }
  }
 else {
    long edgesProcessed=0;
    for (    final Edge e : value.getEdges(Direction.OUT)) {
      final FaunusEdge edge=(FaunusEdge)e;
      if (edge.hasPaths()) {
        final Object object=(null == this.keyClosure) ? new MicroEdge(edge.getIdAsLong()) : this.keyClosure.call(edge);
        final Number number=(null == this.valueClosure) ? 1 : (Number)this.valueClosure.call(edge);
        this.map.incr(object,number.longValue() * edge.pathCount());
        edgesProcessed++;
      }
    }
    context.getCounter(Counters.OUT_EDGES_PROCESSED).increment(edgesProcessed);
  }
  if (this.map.size() > 1000) {
    this.cleanup(context);
  }
  this.outputs.write(Tokens.GRAPH,NullWritable.get(),value);
}",0.9735819735819736
8587,"/** 
 * Restart from survivable exceptions by creating a new scanner.
 * @param firstRow  The first row to start at.
 * @throws IOException When restarting fails.
 */
public void restart(byte[] firstRow) throws IOException {
  Scan newScan=new Scan(scan);
  newScan.setStartRow(firstRow);
  this.scanner=this.htable.getScanner(newScan);
}","/** 
 * Restart from survivable exceptions by creating a new scanner.
 * @param firstRow The first row to start at.
 * @throws IOException When restarting fails.
 */
public void restart(byte[] firstRow) throws IOException {
  Scan newScan=new Scan(scan);
  newScan.setStartRow(firstRow);
  this.scanner=this.htable.getScanner(newScan);
}",0.9985185185185184
8588,"/** 
 * Positions the record reader to the next record.
 * @return <code>true</code> if there was another record.
 * @throws IOException When reading the record failed.
 * @throws InterruptedException When the job was aborted.
 */
public boolean nextKeyValue() throws IOException, InterruptedException {
  Result result=null;
  while (true) {
    try {
      result=this.scanner.next();
    }
 catch (    IOException e) {
      logger.debug(""String_Node_Str"" + StringUtils.stringifyException(e));
      if (lastRow == null) {
        logger.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        lastRow=scan.getStartRow();
      }
      restart(lastRow);
      scanner.next();
      result=scanner.next();
    }
    if (result != null && result.size() > 0) {
      lastRow=result.getRow();
      final NavigableMap<byte[],NavigableMap<Long,byte[]>> rowMap=result.getMap().get(TitanHBaseInputFormat.EDGE_STORE_FAMILY);
      if (rowMap != null) {
        currentVertex=graph.readFaunusVertex(lastRow,rowMap);
        if (this.pathEnabled)         currentVertex.enablePath(true);
        if (null != currentVertex)         return true;
      }
    }
 else {
      return false;
    }
  }
}","/** 
 * Positions the record reader to the next record.
 * @return <code>true</code> if there was another record.
 * @throws IOException          When reading the record failed.
 * @throws InterruptedException When the job was aborted.
 */
public boolean nextKeyValue() throws IOException, InterruptedException {
  Result result=null;
  while (true) {
    try {
      result=this.scanner.next();
    }
 catch (    IOException e) {
      logger.debug(""String_Node_Str"" + StringUtils.stringifyException(e));
      if (lastRow == null) {
        logger.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        lastRow=scan.getStartRow();
      }
      restart(lastRow);
      scanner.next();
      result=scanner.next();
    }
    if (result != null && result.size() > 0) {
      lastRow=result.getRow();
      final NavigableMap<byte[],NavigableMap<Long,byte[]>> rowMap=result.getMap().get(TitanHBaseInputFormat.EDGE_STORE_FAMILY);
      if (rowMap != null) {
        currentVertex=graph.readFaunusVertex(lastRow,rowMap);
        if (null != currentVertex) {
          if (this.pathEnabled)           currentVertex.enablePath(true);
          return true;
        }
      }
    }
 else {
      return false;
    }
  }
}",0.9156237383932176
8589,"/** 
 * Returns the current value.
 * @return The current value.
 * @throws IOException When the value is faulty.
 * @throws InterruptedException When the job is aborted.
 */
public FaunusVertex getCurrentValue() throws IOException, InterruptedException {
  return currentVertex;
}","/** 
 * Returns the current value.
 * @return The current value.
 * @throws IOException          When the value is faulty.
 * @throws InterruptedException When the job is aborted.
 */
public FaunusVertex getCurrentValue() throws IOException, InterruptedException {
  return currentVertex;
}",0.9842381786339754
8590,"@Override public void reduce(final LongWritable key,final Iterable<Holder> values,final Reducer<LongWritable,Holder,NullWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  final FaunusVertex vertex=new FaunusVertex(key.get());
  for (  final Holder holder : values) {
    if (holder.getTag() == 'v') {
      vertex.addAll((FaunusVertex)holder.get());
    }
 else {
      vertex.getPaths(holder.get(),true);
    }
  }
  context.write(NullWritable.get(),vertex);
}","@Override public void reduce(final LongWritable key,final Iterable<Holder> values,final Reducer<LongWritable,Holder,NullWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  final FaunusVertex vertex=new FaunusVertex(key.get());
  vertex.enablePath(true);
  for (  final Holder holder : values) {
    if (holder.getTag() == 'v') {
      vertex.addAll((FaunusVertex)holder.get());
    }
 else {
      vertex.getPaths(holder.get(),true);
    }
  }
  context.write(NullWritable.get(),vertex);
}",0.9734513274336284
8591,"private static void writeEdges(final Vertex vertex,final Direction direction,final DataOutput out) throws IOException {
  final CounterMap<String> map=new CounterMap<String>();
  for (  final Edge edge : vertex.getEdges(direction)) {
    map.incr(edge.getLabel(),1);
  }
  out.writeShort(map.size());
  for (  final Map.Entry<String,Long> entry : map.entrySet()) {
    out.writeUTF(entry.getKey());
    out.writeInt(entry.getValue().intValue());
    for (    final Edge edge : vertex.getEdges(direction,entry.getKey())) {
      writeId(edge.getId(),out);
      out.writeBoolean(false);
      out.writeLong(0);
      writeId(edge.getVertex(direction.opposite()).getId(),out);
      writeProperties(edge,out);
    }
  }
}","private static void writeEdges(final Vertex vertex,final Direction direction,final DataOutput out) throws IOException {
  final CounterMap<String> map=new CounterMap<String>();
  for (  final Edge edge : vertex.getEdges(direction)) {
    map.incr(edge.getLabel(),1);
  }
  out.writeShort(map.size());
  for (  final Map.Entry<String,Long> entry : map.entrySet()) {
    out.writeUTF(entry.getKey());
    out.writeInt(entry.getValue().intValue());
    for (    final Edge edge : vertex.getEdges(direction,entry.getKey())) {
      writeId(edge.getId(),out);
      out.writeBoolean(false);
      out.writeLong(0);
      writeProperties(edge,out);
      writeId(edge.getVertex(direction.opposite()).getId(),out);
    }
  }
}",0.9541029207232268
8592,"public static void write(final Vertex vertex,final DataOutput out) throws IOException {
  writeId(vertex.getId(),out);
  out.writeBoolean(false);
  out.writeLong(0);
  writeEdges(vertex,Direction.IN,out);
  writeEdges(vertex,Direction.OUT,out);
  writeProperties(vertex,out);
}","public static void write(final Vertex vertex,final DataOutput out) throws IOException {
  writeId(vertex.getId(),out);
  out.writeBoolean(false);
  out.writeLong(0);
  writeProperties(vertex,out);
  writeEdges(vertex,Direction.IN,out);
  writeEdges(vertex,Direction.OUT,out);
}",0.8880866425992779
8593,"public void testVerticesBiasedStart() throws IOException {
  Configuration config=new Configuration();
  config.setClass(BackFilterMapReduce.CLASS,Vertex.class,Element.class);
  config.setInt(BackFilterMapReduce.STEP,0);
  mapReduceDriver.withConfiguration(config);
  Map<Long,FaunusVertex> results=generateIndexedGraph(BaseTest.ExampleGraph.TINKERGRAPH);
  for (  FaunusVertex v : results.values()) {
    v.enablePath(true);
  }
  results.get(1l).addPath((List)Arrays.asList(new MicroVertex(1l),new MicroVertex(1l)),false);
  results.get(2l).addPath((List)Arrays.asList(new MicroVertex(1l),new MicroVertex(2l)),false);
  results.get(3l).addPath((List)Arrays.asList(new MicroVertex(2l),new MicroVertex(3l)),false);
  results.get(4l).addPath((List)Arrays.asList(new MicroVertex(3l),new MicroVertex(4l)),false);
  results.get(5l).addPath((List)Arrays.asList(new MicroVertex(3l),new MicroVertex(5l)),false);
  results=runWithGraph(results.values(),mapReduceDriver);
  assertEquals(results.size(),6);
  assertEquals(results.get(1l).pathCount(),2);
  assertEquals(results.get(2l).pathCount(),1);
  assertEquals(results.get(3l).pathCount(),2);
  assertEquals(results.get(4l).pathCount(),0);
  assertEquals(results.get(5l).pathCount(),0);
  assertEquals(results.get(6l).pathCount(),0);
  assertEquals(mapReduceDriver.getCounters().findCounter(FilterMap.Counters.VERTICES_FILTERED).getValue(),0);
  assertEquals(mapReduceDriver.getCounters().findCounter(FilterMap.Counters.EDGES_FILTERED).getValue(),0);
  identicalStructure(results,ExampleGraph.TINKERGRAPH);
}","public void testVerticesBiasedStart() throws IOException {
  Configuration config=new Configuration();
  config.setClass(BackFilterMapReduce.CLASS,Vertex.class,Element.class);
  config.setInt(BackFilterMapReduce.STEP,0);
  config.setBoolean(FaunusCompiler.PATH_ENABLED,true);
  mapReduceDriver.withConfiguration(config);
  Map<Long,FaunusVertex> results=generateIndexedGraph(BaseTest.ExampleGraph.TINKERGRAPH);
  for (  FaunusVertex v : results.values()) {
    v.enablePath(true);
  }
  results.get(1l).addPath((List)Arrays.asList(new MicroVertex(1l),new MicroVertex(1l)),false);
  results.get(2l).addPath((List)Arrays.asList(new MicroVertex(1l),new MicroVertex(2l)),false);
  results.get(3l).addPath((List)Arrays.asList(new MicroVertex(2l),new MicroVertex(3l)),false);
  results.get(4l).addPath((List)Arrays.asList(new MicroVertex(3l),new MicroVertex(4l)),false);
  results.get(5l).addPath((List)Arrays.asList(new MicroVertex(3l),new MicroVertex(5l)),false);
  results=runWithGraph(results.values(),mapReduceDriver);
  assertEquals(results.size(),6);
  assertEquals(results.get(1l).pathCount(),2);
  assertEquals(results.get(2l).pathCount(),1);
  assertEquals(results.get(3l).pathCount(),2);
  assertEquals(results.get(4l).pathCount(),0);
  assertEquals(results.get(5l).pathCount(),0);
  assertEquals(results.get(6l).pathCount(),0);
  assertEquals(mapReduceDriver.getCounters().findCounter(FilterMap.Counters.VERTICES_FILTERED).getValue(),0);
  assertEquals(mapReduceDriver.getCounters().findCounter(FilterMap.Counters.EDGES_FILTERED).getValue(),0);
  identicalStructure(results,ExampleGraph.TINKERGRAPH);
}",0.9826004428978172
8594,"public void testVerticesFullStart() throws IOException {
  Configuration config=new Configuration();
  config.setClass(BackFilterMapReduce.CLASS,Vertex.class,Element.class);
  config.setInt(BackFilterMapReduce.STEP,0);
  mapReduceDriver.withConfiguration(config);
  Map<Long,FaunusVertex> results=runWithGraph(startPath(generateGraph(BaseTest.ExampleGraph.TINKERGRAPH),Vertex.class,true),mapReduceDriver);
  assertEquals(results.size(),6);
  assertEquals(results.get(1l).pathCount(),1);
  assertEquals(results.get(2l).pathCount(),1);
  assertEquals(results.get(3l).pathCount(),1);
  assertEquals(results.get(4l).pathCount(),1);
  assertEquals(results.get(5l).pathCount(),1);
  assertEquals(results.get(6l).pathCount(),1);
  assertEquals(mapReduceDriver.getCounters().findCounter(FilterMap.Counters.VERTICES_FILTERED).getValue(),0);
  assertEquals(mapReduceDriver.getCounters().findCounter(FilterMap.Counters.EDGES_FILTERED).getValue(),0);
  identicalStructure(results,ExampleGraph.TINKERGRAPH);
}","public void testVerticesFullStart() throws IOException {
  Configuration config=new Configuration();
  config.setClass(BackFilterMapReduce.CLASS,Vertex.class,Element.class);
  config.setInt(BackFilterMapReduce.STEP,0);
  config.setBoolean(FaunusCompiler.PATH_ENABLED,true);
  mapReduceDriver.withConfiguration(config);
  Map<Long,FaunusVertex> results=runWithGraph(startPath(generateGraph(BaseTest.ExampleGraph.TINKERGRAPH),Vertex.class,true),mapReduceDriver);
  assertEquals(results.size(),6);
  assertEquals(results.get(1l).pathCount(),1);
  assertEquals(results.get(2l).pathCount(),1);
  assertEquals(results.get(3l).pathCount(),1);
  assertEquals(results.get(4l).pathCount(),1);
  assertEquals(results.get(5l).pathCount(),1);
  assertEquals(results.get(6l).pathCount(),1);
  assertEquals(mapReduceDriver.getCounters().findCounter(FilterMap.Counters.VERTICES_FILTERED).getValue(),0);
  assertEquals(mapReduceDriver.getCounters().findCounter(FilterMap.Counters.EDGES_FILTERED).getValue(),0);
  identicalStructure(results,ExampleGraph.TINKERGRAPH);
}",0.9731314118221788
8595,"public void testKnowsCreatedTraversal2() throws IOException {
  Configuration config=new Configuration();
  config.set(VerticesVerticesMapReduce.DIRECTION,Direction.OUT.name());
  config.setStrings(VerticesVerticesMapReduce.LABELS,""String_Node_Str"");
  mapReduceDriver.withConfiguration(config);
  Map<Long,FaunusVertex> results=runWithGraph(startPath(generateGraph(ExampleGraph.TINKERGRAPH),Vertex.class,true),mapReduceDriver);
  assertEquals(results.size(),6);
  assertEquals(results.get(1l).pathCount(),0);
  assertEquals(results.get(2l).pathCount(),0);
  assertEquals(results.get(3l).pathCount(),3);
  assertEquals(results.get(4l).pathCount(),0);
  assertEquals(results.get(5l).pathCount(),1);
  assertEquals(results.get(6l).pathCount(),0);
}","public void testKnowsCreatedTraversal2() throws IOException {
  Configuration config=new Configuration();
  config.set(VerticesVerticesMapReduce.DIRECTION,Direction.OUT.name());
  config.setStrings(VerticesVerticesMapReduce.LABELS,""String_Node_Str"");
  config.setBoolean(FaunusCompiler.PATH_ENABLED,false);
  mapReduceDriver.withConfiguration(config);
  Map<Long,FaunusVertex> results=runWithGraph(startPath(generateGraph(ExampleGraph.TINKERGRAPH),Vertex.class),mapReduceDriver);
  assertEquals(results.size(),6);
  assertEquals(results.get(1l).pathCount(),0);
  assertEquals(results.get(2l).pathCount(),0);
  assertEquals(results.get(3l).pathCount(),3);
  assertEquals(results.get(4l).pathCount(),0);
  assertEquals(results.get(5l).pathCount(),1);
  assertEquals(results.get(6l).pathCount(),0);
}",0.9604666234607908
8596,"public static void main(String[] args) throws Exception {
  if (args.length < 1 || args.length > 3 || (args.length == 1 && args[0].contains(""String_Node_Str""))) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.exit(-1);
  }
  final String script;
  final String file;
  final Properties fileConfiguration=new Properties();
  final Properties commandLineConfiguration=new Properties();
  if (args.length == 1) {
    script=args[0];
    file=""String_Node_Str"";
  }
 else   if (args.length == 2) {
    if (args[1].startsWith(""String_Node_Str"")) {
      script=args[0];
      file=""String_Node_Str"";
      for (      final String property : args[1].substring(2).trim().split(""String_Node_Str"")) {
        final String key=property.split(""String_Node_Str"")[0];
        final String value=property.split(""String_Node_Str"")[1];
        commandLineConfiguration.put(key,value);
      }
    }
 else {
      file=args[0];
      script=args[1];
    }
  }
 else {
    file=args[0];
    script=args[1];
    for (    final String property : args[2].substring(2).trim().split(""String_Node_Str"")) {
      final String key=property.split(""String_Node_Str"")[0];
      final String value=property.split(""String_Node_Str"")[1];
      commandLineConfiguration.put(key,value);
    }
  }
  fileConfiguration.load(new FileInputStream(file));
  final Configuration conf=new Configuration();
  for (  Map.Entry<Object,Object> entry : fileConfiguration.entrySet()) {
    conf.set(entry.getKey().toString(),entry.getValue().toString());
  }
  for (  Map.Entry<Object,Object> entry : commandLineConfiguration.entrySet()) {
    conf.set(entry.getKey().toString(),entry.getValue().toString());
  }
  final FaunusPipeline faunusPipeline=new FaunusPipeline(script,conf);
  final GroovyScriptEngineImpl scriptEngine=new GroovyScriptEngineImpl();
  scriptEngine.eval(""String_Node_Str"" + Direction.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Direction.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Direction.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Tokens.Order.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Tokens.Order.class.getName() + ""String_Node_Str"");
  scriptEngine.put(""String_Node_Str"",faunusPipeline);
  final FaunusPipeline pipeline=((FaunusPipeline)scriptEngine.eval(script)).done();
  final FaunusCompiler compiler=pipeline.compiler;
  compiler.completeSequence();
  int result=ToolRunner.run(compiler,args);
  System.exit(result);
}","public static void main(String[] args) throws Exception {
  if (args.length < 1 || args.length > 3 || (args.length == 1 && args[0].contains(""String_Node_Str""))) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.exit(-1);
  }
  final String script;
  final String file;
  final Properties fileConfiguration=new Properties();
  final Properties commandLineConfiguration=new Properties();
  if (args.length == 1) {
    script=args[0];
    file=""String_Node_Str"";
  }
 else   if (args.length == 2) {
    if (args[1].startsWith(""String_Node_Str"")) {
      script=args[0];
      file=""String_Node_Str"";
      for (      final String property : args[1].substring(2).trim().split(""String_Node_Str"")) {
        commandLineConfiguration.put(property.split(""String_Node_Str"")[0],property.split(""String_Node_Str"")[1]);
      }
    }
 else {
      file=args[0];
      script=args[1];
    }
  }
 else {
    file=args[0];
    script=args[1];
    for (    final String property : args[2].substring(2).trim().split(""String_Node_Str"")) {
      commandLineConfiguration.put(property.split(""String_Node_Str"")[0],property.split(""String_Node_Str"")[1]);
    }
  }
  fileConfiguration.load(new FileInputStream(file));
  final Configuration conf=new Configuration();
  for (  Map.Entry<Object,Object> entry : fileConfiguration.entrySet()) {
    conf.set(entry.getKey().toString(),entry.getValue().toString());
  }
  for (  Map.Entry<Object,Object> entry : commandLineConfiguration.entrySet()) {
    conf.set(entry.getKey().toString(),entry.getValue().toString());
  }
  final FaunusPipeline faunusPipeline=new FaunusPipeline(script,conf);
  final GroovyScriptEngineImpl scriptEngine=new GroovyScriptEngineImpl();
  scriptEngine.eval(""String_Node_Str"" + Direction.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Direction.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Direction.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Query.Compare.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Tokens.Order.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + Tokens.Order.class.getName() + ""String_Node_Str"");
  scriptEngine.put(""String_Node_Str"",faunusPipeline);
  final FaunusPipeline pipeline=((FaunusPipeline)scriptEngine.eval(script)).done();
  final FaunusCompiler compiler=pipeline.compiler;
  compiler.completeSequence();
  int result=ToolRunner.run(compiler,args);
  System.exit(result);
}",0.9620410703173616
8597,"public void completeSequence() throws IOException {
  if (this.mapSequenceClasses.size() > 0) {
    this.mapSequenceConfiguration.setStrings(MapSequence.MAP_CLASSES,toStringMapSequenceClasses());
    final Job job=new Job(this.mapSequenceConfiguration,this.toStringOfJob(MapSequence.class));
    job.setJarByClass(FaunusCompiler.class);
    job.setMapperClass(MapSequence.Map.class);
    if (this.reduceClass != null)     job.setReducerClass(this.reduceClass);
    if (this.combinerClass != null)     job.setCombinerClass(this.combinerClass);
    job.setMapOutputKeyClass(this.mapOutputKey);
    job.setMapOutputValueClass(this.mapOutputValue);
    job.setOutputKeyClass(this.outputKey);
    job.setOutputValueClass(this.outputValue);
    if (null != this.comparator)     job.setSortComparatorClass(this.comparator);
    if (!(this.outputKey.equals(NullWritable.class) && this.outputValue.equals(FaunusVertex.class)))     this.derivationJob=false;
    this.jobs.add(job);
    this.mapSequenceConfiguration.clear();
    this.mapSequenceClasses.clear();
    this.combinerClass=null;
    this.reduceClass=null;
    this.comparator=null;
  }
}","public void completeSequence() throws IOException {
  if (this.mapSequenceClasses.size() > 0) {
    this.mapSequenceConfiguration.setStrings(MapSequence.MAP_CLASSES,toStringMapSequenceClasses());
    final Job job=new Job(this.mapSequenceConfiguration,this.toStringOfJob(MapSequence.class));
    job.setJarByClass(FaunusCompiler.class);
    job.setMapperClass(MapSequence.Map.class);
    if (this.reduceClass != null) {
      job.setReducerClass(this.reduceClass);
      if (this.combinerClass != null)       job.setCombinerClass(this.combinerClass);
    }
 else {
      job.setNumReduceTasks(0);
    }
    job.setMapOutputKeyClass(this.mapOutputKey);
    job.setMapOutputValueClass(this.mapOutputValue);
    job.setOutputKeyClass(this.outputKey);
    job.setOutputValueClass(this.outputValue);
    if (null != this.comparator)     job.setSortComparatorClass(this.comparator);
    if (!(this.outputKey.equals(NullWritable.class) && this.outputValue.equals(FaunusVertex.class)))     this.derivationJob=false;
    this.jobs.add(job);
    this.mapSequenceConfiguration.clear();
    this.mapSequenceClasses.clear();
    this.combinerClass=null;
    this.reduceClass=null;
    this.comparator=null;
  }
}",0.9392643284858854
8598,"public void verticesEdgesMapReduce(final Direction direction,final String... labels) throws IOException {
  this.mapSequenceConfiguration.set(VerticesEdgesMapReduce.DIRECTION + ""String_Node_Str"" + this.mapSequenceClasses.size(),direction.name());
  this.mapSequenceConfiguration.setStrings(VerticesEdgesMapReduce.LABELS + ""String_Node_Str"" + this.mapSequenceClasses.size(),labels);
  this.mapSequenceClasses.add(VerticesEdgesMapReduce.Map.class);
  this.reduceClass=VerticesEdgesMapReduce.Reduce.class;
  this.setKeyValueClasses(LongWritable.class,Holder.class,NullWritable.class,FaunusVertex.class);
  this.completeSequence();
}","public void verticesEdgesMapReduce(final Direction direction,final String... labels) throws IOException {
  this.mapSequenceConfiguration.set(VerticesEdgesMapReduce.DIRECTION + ""String_Node_Str"" + this.mapSequenceClasses.size(),direction.name());
  this.mapSequenceConfiguration.setStrings(VerticesEdgesMapReduce.LABELS + ""String_Node_Str"" + this.mapSequenceClasses.size(),labels);
  this.mapSequenceClasses.add(VerticesEdgesMapReduce.Map.class);
  this.mapSequenceConfiguration.set(VerticesEdgesMapReduce.DIRECTION,direction.name());
  this.mapSequenceConfiguration.setStrings(VerticesEdgesMapReduce.LABELS,labels);
  this.reduceClass=VerticesEdgesMapReduce.Reduce.class;
  this.setKeyValueClasses(LongWritable.class,Holder.class,NullWritable.class,FaunusVertex.class);
  this.completeSequence();
}",0.8809523809523809
8599,"public void linkMapReduce(final int step,final Direction direction,final String label,final String mergeWeightKey) throws IOException {
  this.mapSequenceConfiguration.setInt(LinkMapReduce.STEP + ""String_Node_Str"" + this.mapSequenceClasses.size(),step);
  this.mapSequenceConfiguration.set(LinkMapReduce.DIRECTION + ""String_Node_Str"" + this.mapSequenceClasses.size(),direction.name());
  this.mapSequenceConfiguration.set(LinkMapReduce.LABEL + ""String_Node_Str"" + this.mapSequenceClasses.size(),label);
  if (null == mergeWeightKey) {
    this.mapSequenceConfiguration.setBoolean(LinkMapReduce.MERGE_DUPLICATES + ""String_Node_Str"" + this.mapSequenceClasses.size(),false);
    this.mapSequenceConfiguration.set(LinkMapReduce.MERGE_WEIGHT_KEY + ""String_Node_Str"" + this.mapSequenceClasses.size(),LinkMapReduce.NO_WEIGHT_KEY);
  }
 else {
    this.mapSequenceConfiguration.setBoolean(LinkMapReduce.MERGE_DUPLICATES + ""String_Node_Str"" + this.mapSequenceClasses.size(),true);
    this.mapSequenceConfiguration.set(LinkMapReduce.MERGE_WEIGHT_KEY + ""String_Node_Str"" + this.mapSequenceClasses.size(),mergeWeightKey);
  }
  this.mapSequenceClasses.add(LinkMapReduce.Map.class);
  this.reduceClass=LinkMapReduce.Reduce.class;
  this.setKeyValueClasses(LongWritable.class,Holder.class,NullWritable.class,FaunusVertex.class);
  this.completeSequence();
}","public void linkMapReduce(final int step,final Direction direction,final String label,final String mergeWeightKey) throws IOException {
  this.mapSequenceConfiguration.setInt(LinkMapReduce.STEP + ""String_Node_Str"" + this.mapSequenceClasses.size(),step);
  this.mapSequenceConfiguration.set(LinkMapReduce.DIRECTION + ""String_Node_Str"" + this.mapSequenceClasses.size(),direction.name());
  this.mapSequenceConfiguration.set(LinkMapReduce.LABEL + ""String_Node_Str"" + this.mapSequenceClasses.size(),label);
  if (null == mergeWeightKey) {
    this.mapSequenceConfiguration.setBoolean(LinkMapReduce.MERGE_DUPLICATES + ""String_Node_Str"" + this.mapSequenceClasses.size(),false);
    this.mapSequenceConfiguration.set(LinkMapReduce.MERGE_WEIGHT_KEY + ""String_Node_Str"" + this.mapSequenceClasses.size(),LinkMapReduce.NO_WEIGHT_KEY);
  }
 else {
    this.mapSequenceConfiguration.setBoolean(LinkMapReduce.MERGE_DUPLICATES + ""String_Node_Str"" + this.mapSequenceClasses.size(),true);
    this.mapSequenceConfiguration.set(LinkMapReduce.MERGE_WEIGHT_KEY + ""String_Node_Str"" + this.mapSequenceClasses.size(),mergeWeightKey);
  }
  this.mapSequenceClasses.add(LinkMapReduce.Map.class);
  this.mapSequenceConfiguration.set(LinkMapReduce.DIRECTION,direction.name());
  this.reduceClass=LinkMapReduce.Reduce.class;
  this.setKeyValueClasses(LongWritable.class,Holder.class,NullWritable.class,FaunusVertex.class);
  this.completeSequence();
}",0.9714492229851824
8600,"@Override public void reduce(final LongWritable key,final Iterable<Holder> values,final Reducer<LongWritable,Holder,NullWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  final FaunusVertex vertex=new FaunusVertex(key.get());
  for (  final Holder holder : values) {
    final char tag=holder.getTag();
    final FaunusVertex temp=(FaunusVertex)holder.get();
    if (tag == 'v') {
      vertex.setProperties(temp.getProperties());
      vertex.addEdges(Direction.BOTH,temp);
    }
 else {
      vertex.addPaths(temp.getPaths(),true);
    }
  }
  context.write(NullWritable.get(),vertex);
}","@Override public void reduce(final LongWritable key,final Iterable<Holder> values,final Reducer<LongWritable,Holder,NullWritable,FaunusVertex>.Context context) throws IOException, InterruptedException {
  this.vertex.reuse(key.get());
  for (  final Holder holder : values) {
    final char tag=holder.getTag();
    final FaunusVertex temp=(FaunusVertex)holder.get();
    if (tag == 'v') {
      vertex.setProperties(temp.getProperties());
      vertex.addEdges(Direction.BOTH,temp);
    }
 else {
      vertex.addPaths(temp.getPaths(),true);
    }
  }
  context.write(NullWritable.get(),vertex);
}",0.9516789516789516
8601,"public boolean isLegal(final FaunusElement element){
  Object elementValue=ElementPicker.getProperty(element,this.key);
  if (elementValue instanceof Number)   elementValue=((Number)elementValue).floatValue();
switch (this.compare) {
case EQUAL:
    if (null == elementValue) {
      for (      final Object value : values) {
        if (null == value)         return true;
      }
      return false;
    }
 else {
      for (      final Object value : values) {
        if (elementValue.equals(value))         return true;
      }
      return false;
    }
case NOT_EQUAL:
  if (null == elementValue) {
    for (    final Object value : values) {
      if (null != value)       return true;
    }
    return false;
  }
 else {
    for (    final Object value : values) {
      if (!elementValue.equals(value))       return true;
    }
    return false;
  }
case GREATER_THAN:
if (null == elementValue) {
  return this.nullIsWildcard;
}
 else {
  for (  final Object value : values) {
    if (((Comparable)elementValue).compareTo(value) >= 1)     return true;
  }
  return false;
}
case LESS_THAN:
if (null == elementValue) {
return this.nullIsWildcard;
}
 else {
for (final Object value : values) {
  if (((Comparable)elementValue).compareTo(value) <= -1)   return true;
}
return false;
}
case GREATER_THAN_EQUAL:
if (null == elementValue) {
return this.nullIsWildcard;
}
 else {
for (final Object value : values) {
if (((Comparable)elementValue).compareTo(value) >= 0) return true;
}
return false;
}
case LESS_THAN_EQUAL:
if (null == elementValue) {
return this.nullIsWildcard;
}
 else {
for (final Object value : values) {
if (((Comparable)elementValue).compareTo(value) <= 0) return true;
}
return false;
}
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}","public boolean isLegal(final FaunusElement element){
  Object elementValue=ElementPicker.getProperty(element,this.key);
  if (elementValue instanceof Number)   elementValue=((Number)elementValue).floatValue();
switch (this.compare) {
case EQUAL:
    if (null == elementValue) {
      if (this.nullIsWildcard)       return true;
 else {
        for (        final Object value : values) {
          if (null == value)           return true;
        }
      }
      return false;
    }
 else {
      for (      final Object value : values) {
        if (elementValue.equals(value))         return true;
      }
      return false;
    }
case NOT_EQUAL:
  if (null == elementValue) {
    if (this.nullIsWildcard)     return true;
 else {
      for (      final Object value : values) {
        if (null != value)         return true;
      }
    }
    return false;
  }
 else {
    for (    final Object value : values) {
      if (!elementValue.equals(value))       return true;
    }
    return false;
  }
case GREATER_THAN:
if (null == elementValue) {
  return this.nullIsWildcard;
}
 else {
  for (  final Object value : values) {
    if (((Comparable)elementValue).compareTo(value) >= 1)     return true;
  }
  return false;
}
case LESS_THAN:
if (null == elementValue) {
return this.nullIsWildcard;
}
 else {
for (final Object value : values) {
  if (((Comparable)elementValue).compareTo(value) <= -1)   return true;
}
return false;
}
case GREATER_THAN_EQUAL:
if (null == elementValue) {
return this.nullIsWildcard;
}
 else {
for (final Object value : values) {
if (((Comparable)elementValue).compareTo(value) >= 0) return true;
}
return false;
}
case LESS_THAN_EQUAL:
if (null == elementValue) {
return this.nullIsWildcard;
}
 else {
for (final Object value : values) {
if (((Comparable)elementValue).compareTo(value) <= 0) return true;
}
return false;
}
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}",0.9276848354020508
8602,"public FaunusVertex readFaunusVertex(final Pair<ByteBuffer,SortedMap<ByteBuffer,IColumn>> row){
  FaunusVertexRelationLoader loader=new FaunusVertexRelationLoader(row.left.duplicate());
  loadRelations(new CassandraMapIterable(row.right),loader,tx);
  return loader.getVertex();
}","public FaunusVertex readFaunusVertex(final Pair<ByteBuffer,SortedMap<ByteBuffer,IColumn>> row){
  FaunusVertexRelationLoader loader=new FaunusVertexRelationLoader(IDHandler.getKeyID(row.left.duplicate()));
  loadRelations(new CassandraMapIterable(row.right),loader,tx);
  return loader.getVertex();
}",0.9655172413793104
8603,"@Override public void reduce(final IntWritable key,final Iterable<IntWritable> values,final Reducer<IntWritable,IntWritable,IntWritable,IntWritable>.Context context) throws IOException, InterruptedException {
  int totalDegree=0;
  for (  final IntWritable token : values) {
    totalDegree++;
  }
  context.write(key,new IntWritable(totalDegree));
}","@Override public void reduce(final IntWritable key,final Iterable<IntWritable> values,final Reducer<IntWritable,IntWritable,IntWritable,IntWritable>.Context context) throws IOException, InterruptedException {
  int totalDegree=0;
  for (  final IntWritable token : values) {
    totalDegree=totalDegree + token.get();
  }
  context.write(key,new IntWritable(totalDegree));
}",0.9640883977900552
8604,"@Override public void reduce(final Text key,final Iterable<IntWritable> values,final Reducer<Text,IntWritable,Text,IntWritable>.Context context) throws IOException, InterruptedException {
  int totalNumberOfEdges=0;
  for (  final IntWritable token : values) {
    totalNumberOfEdges++;
  }
  context.write(key,new IntWritable(totalNumberOfEdges));
}","@Override public void reduce(final Text key,final Iterable<IntWritable> values,final Reducer<Text,IntWritable,Text,IntWritable>.Context context) throws IOException, InterruptedException {
  int totalNumberOfEdges=0;
  for (  final IntWritable token : values) {
    totalNumberOfEdges=totalNumberOfEdges + token.get();
  }
  context.write(key,new IntWritable(totalNumberOfEdges));
}",0.9548563611491108
8605,"public void removeEdges(final Tokens.Action action,final Direction direction,final String... labels){
  if (action.equals(Tokens.Action.KEEP)) {
    final Set<String> keep=new HashSet<String>(Arrays.asList(labels));
    if (direction.equals(OUT) || direction.equals(BOTH)) {
      if (labels.length == 0) {
        this.outEdges.clear();
      }
 else {
        for (        final String label : this.outEdges.keySet()) {
          if (!keep.contains(label))           this.outEdges.remove(label);
        }
      }
    }
 else     if (direction.equals(IN) || direction.equals(BOTH)) {
      if (labels.length == 0) {
        this.inEdges.clear();
      }
 else {
        for (        final String label : this.inEdges.keySet()) {
          if (!keep.contains(label))           this.inEdges.remove(label);
        }
      }
    }
  }
 else {
    if (direction.equals(OUT) || direction.equals(BOTH)) {
      if (labels.length == 0) {
        this.outEdges.clear();
      }
 else {
        for (        final String label : labels) {
          this.outEdges.remove(label);
        }
      }
    }
 else     if (direction.equals(IN) || direction.equals(BOTH)) {
      if (labels.length == 0) {
        this.inEdges.clear();
      }
 else {
        for (        final String label : labels) {
          this.inEdges.remove(label);
        }
      }
    }
  }
}","public void removeEdges(final Tokens.Action action,final Direction direction,final String... labels){
  if (action.equals(Tokens.Action.KEEP)) {
    final Set<String> keep=new HashSet<String>(Arrays.asList(labels));
    if (direction.equals(BOTH) || direction.equals(OUT)) {
      if (labels.length > 0) {
        for (        final String label : new ArrayList<String>(this.outEdges.keySet())) {
          if (!keep.contains(label))           this.outEdges.remove(label);
        }
      }
    }
    if (direction.equals(BOTH) || direction.equals(IN)) {
      if (labels.length > 0) {
        for (        final String label : new ArrayList<String>(this.inEdges.keySet())) {
          if (!keep.contains(label))           this.inEdges.remove(label);
        }
      }
    }
  }
 else {
    if (direction.equals(BOTH) || direction.equals(OUT)) {
      if (labels.length == 0) {
        this.outEdges.clear();
      }
 else {
        for (        final String label : labels) {
          this.outEdges.remove(label);
        }
      }
    }
    if (direction.equals(BOTH) || direction.equals(IN)) {
      if (labels.length == 0) {
        this.inEdges.clear();
      }
 else {
        for (        final String label : labels) {
          this.inEdges.remove(label);
        }
      }
    }
  }
}",0.8562806488117691
8606,"public FaunusGraph edgeLabelDistribution(final Direction direction) throws IOException {
  this.completeSequence();
  Configuration conf=new Configuration();
  conf.set(EdgeLabelDistribution.DIRECTION,direction.name());
  final Job job=new Job(conf,EdgeLabelDistribution.class.getCanonicalName());
  job.setMapperClass(EdgeLabelDistribution.Map.class);
  job.setReducerClass(EdgeLabelDistribution.Reduce.class);
  job.setCombinerClass(EdgeLabelDistribution.Reduce.class);
  job.setJarByClass(FaunusGraph.class);
  job.setMapOutputKeyClass(Text.class);
  job.setMapOutputValueClass(IntWritable.class);
  job.setOutputKeyClass(Text.class);
  job.setOutputKeyClass(IntWritable.class);
  this.outputFormat=this.statisticsOutputFormat;
  this.jobs.add(job);
  return this;
}","public FaunusGraph edgeLabelDistribution(final Direction direction) throws IOException {
  this.completeSequence();
  Configuration conf=new Configuration();
  conf.set(EdgeLabelDistribution.DIRECTION,direction.name());
  final Job job=new Job(conf,EdgeLabelDistribution.class.getCanonicalName());
  job.setMapperClass(EdgeLabelDistribution.Map.class);
  job.setReducerClass(EdgeLabelDistribution.Reduce.class);
  job.setCombinerClass(EdgeLabelDistribution.Reduce.class);
  job.setJarByClass(FaunusGraph.class);
  job.setMapOutputKeyClass(Text.class);
  job.setMapOutputValueClass(LongWritable.class);
  job.setOutputKeyClass(Text.class);
  job.setOutputKeyClass(LongWritable.class);
  this.outputFormat=this.statisticsOutputFormat;
  this.jobs.add(job);
  return this;
}",0.990909090909091
8607,"@Override public void map(final NullWritable key,final FaunusVertex value,final Mapper<NullWritable,FaunusVertex,Text,LongWritable>.Context context) throws IOException, InterruptedException {
  long counter=0;
  for (  final Edge edge : value.getEdges(this.direction)) {
    counter++;
    final String label=edge.getLabel();
    final Long count=this.map.get(label);
    if (null == count)     this.map.put(label,1l);
 else     this.map.put(label,count + 1l);
  }
  context.getCounter(Counters.VERTICES_COUNTED).increment(1);
  context.getCounter(Counters.EDGES_COUNTED).increment(counter);
}","@Override public void map(final NullWritable key,final FaunusVertex value,final Mapper<NullWritable,FaunusVertex,Text,LongWritable>.Context context) throws IOException, InterruptedException {
  long counter=0;
  for (  final Edge edge : value.getEdges(this.direction)) {
    counter++;
    final String label=edge.getLabel();
    final Long count=this.map.get(label);
    if (null == count)     this.map.put(label,1l);
 else     this.map.put(label,count + 1l);
  }
  context.getCounter(Counters.VERTICES_COUNTED).increment(1);
  context.getCounter(Counters.EDGES_COUNTED).increment(counter);
  if (this.map.size() > 10000) {
    this.cleanup(context);
    this.map.clear();
  }
}",0.9323899371069182
8608,"public Iterable<Edge> getEdges(final Direction direction,final String... labels){
  final List<List<Edge>> edges=new ArrayList<List<Edge>>();
  if (direction.equals(OUT) || direction.equals(BOTH)) {
    if (labels.length == 0) {
      for (      final List<Edge> temp : this.outEdges.values()) {
        edges.add(temp);
      }
    }
 else {
      for (      final String label : labels) {
        final List<Edge> temp=this.outEdges.get(label);
        if (null != temp)         edges.add(temp);
      }
    }
  }
  if (direction.equals(IN) || direction.equals(BOTH)) {
    if (labels.length == 0) {
      for (      final List<Edge> temp : this.inEdges.values()) {
        edges.add(temp);
      }
    }
 else {
      for (      final String label : labels) {
        final List<Edge> temp=this.inEdges.get(label);
        if (null != temp)         edges.add(temp);
      }
    }
  }
  return new EdgeList(edges);
}","public Iterable<Edge> getEdges(final Direction direction,final String... labels){
  final List<List<Edge>> edges=new ArrayList<List<Edge>>();
  if (direction.equals(OUT) || direction.equals(BOTH)) {
    if (null == labels || labels.length == 0) {
      for (      final List<Edge> temp : this.outEdges.values()) {
        edges.add(temp);
      }
    }
 else {
      for (      final String label : labels) {
        final List<Edge> temp=this.outEdges.get(label);
        if (null != temp)         edges.add(temp);
      }
    }
  }
  if (direction.equals(IN) || direction.equals(BOTH)) {
    if (null == labels || labels.length == 0) {
      for (      final List<Edge> temp : this.inEdges.values()) {
        edges.add(temp);
      }
    }
 else {
      for (      final String label : labels) {
        final List<Edge> temp=this.inEdges.get(label);
        if (null != temp)         edges.add(temp);
      }
    }
  }
  return new EdgeList(edges);
}",0.9807692307692308
8609,"@Override public void setup(final Mapper.Context context) throws IOException, InterruptedException {
  this.direction=Direction.valueOf(context.getConfiguration().get(DIRECTION));
  this.labels=context.getConfiguration().getStrings(LABELS);
}","@Override public void setup(final Mapper.Context context) throws IOException, InterruptedException {
  this.direction=Direction.valueOf(context.getConfiguration().get(DIRECTION));
  this.labels=context.getConfiguration().getStrings(LABELS,new String[0]);
}",0.9718875502008032
8610,"@Override public void map(final NullWritable key,final FaunusVertex value,final Mapper<NullWritable,FaunusVertex,Text,LongWritable>.Context context) throws IOException, InterruptedException {
  long counter=0;
  for (  final Edge edge : value.getEdges(this.direction)) {
    counter++;
    final String label=edge.getLabel();
    final Long count=map.get(label);
    if (null == count)     map.put(label,1l);
 else     map.put(label,count + 1l);
  }
  context.getCounter(Counters.VERTICES_COUNTED).increment(1);
  context.getCounter(Counters.EDGES_COUNTED).increment(counter);
}","@Override public void map(final NullWritable key,final FaunusVertex value,final Mapper<NullWritable,FaunusVertex,Text,LongWritable>.Context context) throws IOException, InterruptedException {
  long counter=0;
  for (  final Edge edge : value.getEdges(this.direction)) {
    counter++;
    final String label=edge.getLabel();
    final Long count=this.map.get(label);
    if (null == count)     this.map.put(label,1l);
 else     this.map.put(label,count + 1l);
  }
  context.getCounter(Counters.VERTICES_COUNTED).increment(1);
  context.getCounter(Counters.EDGES_COUNTED).increment(counter);
}",0.987190435525192
8611,"public void testMapReduce1() throws IOException {
  Configuration config=new Configuration();
  config.setStrings(EdgeLabelDistribution.DIRECTION,""String_Node_Str"");
  this.mapReduceDriver.withConfiguration(config);
  final List<Pair<Text,LongWritable>> results=runWithToyGraphNoFormatting(ExampleGraph.GRAPH_OF_THE_GODS,this.mapReduceDriver);
  assertEquals(results.size(),6);
  for (  final Pair<Text,LongWritable> result : results) {
    if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),4l);
    }
 else     if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),3l);
    }
 else     if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),6l);
    }
 else     if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),1l);
    }
 else     if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),1l);
    }
 else     if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),2l);
    }
 else {
      assertTrue(false);
    }
    assertEquals(17,this.mapReduceDriver.getCounters().findCounter(EdgeLabelDistribution.Counters.EDGES_COUNTED).getValue());
    assertEquals(12,this.mapReduceDriver.getCounters().findCounter(EdgeLabelDistribution.Counters.VERTICES_COUNTED).getValue());
  }
}","public void testMapReduce1() throws IOException {
  Configuration config=new Configuration();
  config.setStrings(EdgeLabelDistribution.DIRECTION,""String_Node_Str"");
  this.mapReduceDriver.withConfiguration(config);
  final List<Pair<Text,LongWritable>> results=runWithToyGraphNoFormatting(ExampleGraph.GRAPH_OF_THE_GODS,this.mapReduceDriver);
  assertEquals(results.size(),6);
  for (  final Pair<Text,LongWritable> result : results) {
    if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),4l);
    }
 else     if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),3l);
    }
 else     if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),6l);
    }
 else     if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),1l);
    }
 else     if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),1l);
    }
 else     if (result.getFirst().toString().equals(""String_Node_Str"")) {
      assertEquals(result.getSecond().get(),2l);
    }
 else {
      assertTrue(false);
    }
  }
  assertEquals(17,this.mapReduceDriver.getCounters().findCounter(EdgeLabelDistribution.Counters.EDGES_COUNTED).getValue());
  assertEquals(12,this.mapReduceDriver.getCounters().findCounter(EdgeLabelDistribution.Counters.VERTICES_COUNTED).getValue());
}",0.9973154362416108
8612,"public static void main(String[] args) throws Exception {
  if (args.length != 4) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.exit(-1);
  }
  final FaunusGraph faunusGraph=new FaunusGraph(JSONInputFormat.class,new Path(args[0]),JSONOutputFormat.class,new Path(args[1]),args[3]);
  final GroovyScriptEngineImpl scriptEngine=new GroovyScriptEngineImpl();
  scriptEngine.eval(""String_Node_Str"" + com.tinkerpop.blueprints.Direction.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + com.tinkerpop.blueprints.Direction.class.getName() + ""String_Node_Str"");
  scriptEngine.put(""String_Node_Str"",faunusGraph);
  ((FaunusGraph)scriptEngine.eval(args[3])).completeMapSequence();
  int result=ToolRunner.run(faunusGraph,args);
  System.exit(result);
}","public static void main(String[] args) throws Exception {
  if (args.length != 4) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.exit(-1);
  }
  final FaunusGraph faunusGraph=new FaunusGraph(JSONInputFormat.class,new Path(args[0]),JSONOutputFormat.class,new Path(args[1]),args[3]);
  final GroovyScriptEngineImpl scriptEngine=new GroovyScriptEngineImpl();
  scriptEngine.eval(""String_Node_Str"" + com.tinkerpop.blueprints.Direction.class.getName() + ""String_Node_Str"");
  scriptEngine.eval(""String_Node_Str"" + com.tinkerpop.blueprints.Direction.class.getName() + ""String_Node_Str"");
  scriptEngine.put(""String_Node_Str"",faunusGraph);
  ((FaunusGraph)scriptEngine.eval(args[3])).completeSequence();
  int result=ToolRunner.run(faunusGraph,args);
  System.exit(result);
}",0.9985528219971056
8613,"public FaunusGraph traverse(final Direction firstDirection,final String firstLabel,final Direction secondDirection,final String secondLabel,final String newLabel) throws IOException {
  this.completeMapSequence();
  final Configuration conf=new Configuration();
  conf.set(Traverse.FIRST_DIRECTION,firstDirection.toString());
  conf.set(Traverse.FIRST_LABEL,firstLabel);
  conf.set(Traverse.SECOND_DIRECTION,secondDirection.toString());
  conf.set(Traverse.SECOND_LABEL,secondLabel);
  conf.set(Traverse.NEW_LABEL,newLabel);
  final Job job=new Job(conf,Traverse.class.getName());
  this.configureMapReduceJob(job);
  job.setMapperClass(Traverse.Map.class);
  job.setReducerClass(Traverse.Reduce.class);
  this.jobs.add(job);
  return this;
}","public FaunusGraph traverse(final Direction firstDirection,final String firstLabel,final Direction secondDirection,final String secondLabel,final String newLabel) throws IOException {
  this.mapSequenceConfiguration.set(Traverse.FIRST_DIRECTION,firstDirection.toString());
  this.mapSequenceConfiguration.set(Traverse.FIRST_LABEL,firstLabel);
  this.mapSequenceConfiguration.set(Traverse.SECOND_DIRECTION,secondDirection.toString());
  this.mapSequenceConfiguration.set(Traverse.SECOND_LABEL,secondLabel);
  this.mapSequenceConfiguration.set(Traverse.NEW_LABEL,newLabel);
  this.mapRClass=Traverse.Map.class;
  this.reduceClass=Traverse.Reduce.class;
  this.completeSequence();
  return this;
}",0.649025069637883
8614,"public FaunusGraph exceptEdgeLabels(final String... labels) throws IOException {
  this.addMapSequenceClass(ExceptEdgeLabels.Map.class.getName());
  this.mapSequenceConfiguration.setStrings(ExceptEdgeLabels.LABELS + ""String_Node_Str"" + this.currentSequenceStep++,labels);
  return this;
}","public FaunusGraph exceptEdgeLabels(final String... labels) throws IOException {
  this.mapSequenceConfiguration.setStrings(ExceptEdgeLabels.LABELS + ""String_Node_Str"" + this.mapSequenceClasses.size(),labels);
  this.mapSequenceClasses.add(ExceptEdgeLabels.Map.class);
  return this;
}",0.6910994764397905
8615,"public FaunusGraph retainEdgeLabels(final String... labels) throws IOException {
  this.addMapSequenceClass(RetainEdgeLabels.Map.class.getName());
  this.mapSequenceConfiguration.setStrings(RetainEdgeLabels.LABELS + ""String_Node_Str"" + this.currentSequenceStep++,labels);
  return this;
}","public FaunusGraph retainEdgeLabels(final String... labels) throws IOException {
  this.mapSequenceConfiguration.setStrings(RetainEdgeLabels.LABELS + ""String_Node_Str"" + this.mapSequenceClasses.size(),labels);
  this.mapSequenceClasses.add(RetainEdgeLabels.Map.class);
  return this;
}",0.6910994764397905
8616,"public FaunusGraph self(final boolean allow) throws IOException {
  this.addMapSequenceClass(Self.Map.class.getName());
  this.mapSequenceConfiguration.setBoolean(Self.ALLOW + ""String_Node_Str"" + this.currentSequenceStep++,allow);
  return this;
}","public FaunusGraph self(final boolean allow) throws IOException {
  this.mapSequenceConfiguration.setBoolean(Self.ALLOW + ""String_Node_Str"" + this.mapSequenceClasses.size(),allow);
  this.mapSequenceClasses.add(Self.Map.class);
  return this;
}",0.6883910386965377
8617,"public FaunusGraph transpose(final String label,final String newLabel) throws IOException {
  this.completeMapSequence();
  final Configuration conf=new Configuration();
  conf.set(Transpose.LABEL,label);
  conf.set(Transpose.NEW_LABEL,newLabel);
  final Job job=new Job(conf,Transpose.class.getName());
  this.configureMapReduceJob(job);
  job.setMapperClass(Transpose.Map.class);
  job.setReducerClass(Transpose.Reduce.class);
  this.jobs.add(job);
  return this;
}","public FaunusGraph transpose(final String label,final String newLabel) throws IOException {
  this.mapSequenceConfiguration.set(Transpose.LABEL,label);
  this.mapSequenceConfiguration.set(Transpose.NEW_LABEL,newLabel);
  this.mapRClass=Transpose.Map.class;
  this.reduceClass=Transpose.Reduce.class;
  this.completeSequence();
  return this;
}",0.5555555555555556
8618,"public FaunusGraph _() throws IOException {
  this.addMapSequenceClass(Identity.Map.class.getName());
  this.currentSequenceStep++;
  return this;
}","public FaunusGraph _() throws IOException {
  this.mapSequenceClasses.add(Identity.Map.class);
  return this;
}",0.803088803088803
8619,"public void selectDay(int dayOfMonth){
  clearSelectedDay();
  selectedDay=dayOfMonth + 6 + startingDayOfWeek;
  if (Utils.isWeekOfYearEnabled()) {
    selectedDay=selectedDay + selectedDay / 7 + 1;
  }
  notifyItemChanged(selectedDay);
}","public void selectDay(int dayOfMonth){
  int prevDay=selectedDay;
  selectedDay=-1;
  notifyItemChanged(prevDay);
  if (dayOfMonth == -1) {
    return;
  }
  selectedDay=dayOfMonth + 6 + startingDayOfWeek;
  if (Utils.isWeekOfYearEnabled()) {
    selectedDay=selectedDay + selectedDay / 7 + 1;
  }
  notifyItemChanged(selectedDay);
}",0.2276707530647986
8620,"@Override public void onPageSelected(int position){
  Intent intent=new Intent(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT);
  intent.putExtra(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT,CalendarAdapter.positionToOffset(position));
  intent.putExtra(Constants.BROADCAST_FIELD_SELECT_DAY,-1);
  LocalBroadcastManager.getInstance(getContext()).sendBroadcast(intent);
  today.setVisibility(View.VISIBLE);
  todayIcon.setVisibility(View.VISIBLE);
}","@Override public void onPageSelected(int position){
  Intent intent=new Intent(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT);
  intent.putExtra(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT,CalendarAdapter.positionToOffset(position));
  intent.putExtra(Constants.BROADCAST_FIELD_SELECT_DAY_JDN,lastSelectedJdn);
  LocalBroadcastManager.getInstance(getContext()).sendBroadcast(intent);
  today.setVisibility(View.VISIBLE);
  todayIcon.setVisibility(View.VISIBLE);
}",0.9768467475192943
8621,"public void bringDate(long jdn){
  CalendarType mainCalendar=Utils.getMainCalendar();
  AbstractDate today=Utils.getTodayOfCalendar(mainCalendar);
  AbstractDate date=Utils.getDateFromJdnOfCalendar(mainCalendar,jdn);
  viewPagerPosition=(today.getYear() - date.getYear()) * 12 + today.getMonth() - date.getMonth();
  CalendarAdapter.gotoOffset(monthViewPager,viewPagerPosition);
  Intent intent=new Intent(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT);
  intent.putExtra(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT,viewPagerPosition);
  intent.putExtra(Constants.BROADCAST_FIELD_SELECT_DAY,date.getDayOfMonth());
  LocalBroadcastManager.getInstance(getContext()).sendBroadcast(intent);
  selectDay(jdn);
}","public void bringDate(long jdn){
  CalendarType mainCalendar=Utils.getMainCalendar();
  AbstractDate today=Utils.getTodayOfCalendar(mainCalendar);
  AbstractDate date=Utils.getDateFromJdnOfCalendar(mainCalendar,jdn);
  viewPagerPosition=(today.getYear() - date.getYear()) * 12 + today.getMonth() - date.getMonth();
  CalendarAdapter.gotoOffset(monthViewPager,viewPagerPosition);
  LocalBroadcastManager.getInstance(getContext()).sendBroadcast(new Intent(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT).putExtra(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT,viewPagerPosition).putExtra(Constants.BROADCAST_FIELD_SELECT_DAY_JDN,jdn));
  selectDay(jdn);
}",0.8366592756836659
8622,"private void bringTodayYearMonth(){
  Intent intent=new Intent(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT);
  intent.putExtra(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT,Constants.BROADCAST_TO_MONTH_FRAGMENT_RESET_DAY);
  intent.putExtra(Constants.BROADCAST_FIELD_SELECT_DAY,-1);
  LocalBroadcastManager.getInstance(getContext()).sendBroadcast(intent);
  CalendarAdapter.gotoOffset(monthViewPager,0);
  selectDay(Utils.getTodayJdn());
}","private void bringTodayYearMonth(){
  LocalBroadcastManager.getInstance(getContext()).sendBroadcast(new Intent(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT).putExtra(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT,Constants.BROADCAST_TO_MONTH_FRAGMENT_RESET_DAY).putExtra(Constants.BROADCAST_FIELD_SELECT_DAY_JDN,-1));
  CalendarAdapter.gotoOffset(monthViewPager,0);
  selectDay(Utils.getTodayJdn());
}",0.7942583732057417
8623,"void selectDay(long jdn){
  lastSelectedJdn=jdn;
  PersianDate persianDate=DateConverter.jdnToPersian(jdn);
  weekDayName.setText(Utils.getWeekDayName(persianDate));
  CivilDate civilDate=DateConverter.persianToCivil(persianDate);
  IslamicDate hijriDate=DateConverter.civilToIslamic(civilDate,Utils.getIslamicOffset());
  shamsiDateLinear.setText(Utils.toLinearDate(persianDate));
  shamsiDateDay.setText(Utils.formatNumber(persianDate.getDayOfMonth()));
  shamsiDate.setText(Utils.getMonthName(persianDate) + ""String_Node_Str"" + Utils.formatNumber(persianDate.getYear()));
  gregorianDateLinear.setText(Utils.toLinearDate(civilDate));
  gregorianDateDay.setText(Utils.formatNumber(civilDate.getDayOfMonth()));
  gregorianDate.setText(Utils.getMonthName(civilDate) + ""String_Node_Str"" + Utils.formatNumber(civilDate.getYear()));
  islamicDateLinear.setText(Utils.toLinearDate(hijriDate));
  islamicDateDay.setText(Utils.formatNumber(hijriDate.getDayOfMonth()));
  islamicDate.setText(Utils.getMonthName(hijriDate) + ""String_Node_Str"" + Utils.formatNumber(hijriDate.getYear()));
  boolean isToday=Utils.getTodayJdn() == jdn;
  if (isToday) {
    today.setVisibility(View.GONE);
    todayIcon.setVisibility(View.GONE);
    if (Utils.isIranTime())     weekDayName.setText(weekDayName.getText() + ""String_Node_Str"" + getString(R.string.iran_time)+ ""String_Node_Str"");
  }
 else {
    today.setVisibility(View.VISIBLE);
    todayIcon.setVisibility(View.VISIBLE);
  }
  setOwghat(civilDate,isToday);
  showEvent(jdn);
}","void selectDay(long jdn){
  lastSelectedJdn=jdn;
  PersianDate persianDate=DateConverter.jdnToPersian(jdn);
  weekDayName.setText(Utils.getWeekDayName(persianDate));
  CivilDate civilDate=DateConverter.persianToCivil(persianDate);
  IslamicDate hijriDate=DateConverter.civilToIslamic(civilDate,Utils.getIslamicOffset());
  shamsiDateLinear.setText(Utils.toLinearDate(persianDate));
  shamsiDateDay.setText(Utils.formatNumber(persianDate.getDayOfMonth()));
  shamsiDate.setText(Utils.getMonthName(persianDate) + ""String_Node_Str"" + Utils.formatNumber(persianDate.getYear()));
  gregorianDateLinear.setText(Utils.toLinearDate(civilDate));
  gregorianDateDay.setText(Utils.formatNumber(civilDate.getDayOfMonth()));
  gregorianDate.setText(Utils.getMonthName(civilDate) + ""String_Node_Str"" + Utils.formatNumber(civilDate.getYear()));
  islamicDateLinear.setText(Utils.toLinearDate(hijriDate));
  islamicDateDay.setText(Utils.formatNumber(hijriDate.getDayOfMonth()));
  islamicDate.setText(Utils.getMonthName(hijriDate) + ""String_Node_Str"" + Utils.formatNumber(hijriDate.getYear()));
  boolean isToday=Utils.getTodayJdn() == jdn;
  if (isToday) {
    today.setVisibility(View.GONE);
    todayIcon.setVisibility(View.GONE);
    if (Utils.isIranTime()) {
      weekDayName.setText(weekDayName.getText() + ""String_Node_Str"" + getString(R.string.iran_time)+ ""String_Node_Str"");
    }
    lastSelectedJdn=-1;
  }
 else {
    today.setVisibility(View.VISIBLE);
    todayIcon.setVisibility(View.VISIBLE);
  }
  setOwghat(civilDate,isToday);
  showEvent(jdn);
}",0.9888961463096017
8624,"@Nullable @Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  setHasOptionsMenu(true);
  View view=inflater.inflate(R.layout.fragment_calendar,container,false);
  viewPagerPosition=0;
  imsakLayout=view.findViewById(R.id.imsakLayout);
  fajrLayout=view.findViewById(R.id.fajrLayout);
  sunriseLayout=view.findViewById(R.id.sunriseLayout);
  dhuhrLayout=view.findViewById(R.id.dhuhrLayout);
  asrLayout=view.findViewById(R.id.asrLayout);
  sunsetLayout=view.findViewById(R.id.sunsetLayout);
  maghribLayout=view.findViewById(R.id.maghribLayout);
  ishaLayout=view.findViewById(R.id.ishaLayout);
  midnightLayout=view.findViewById(R.id.midnightLayout);
  gregorianDate=view.findViewById(R.id.gregorian_date);
  gregorianDateDay=view.findViewById(R.id.gregorian_date_day);
  gregorianDateLinear=view.findViewById(R.id.gregorian_date_linear);
  islamicDate=view.findViewById(R.id.islamic_date);
  islamicDateDay=view.findViewById(R.id.islamic_date_day);
  islamicDateLinear=view.findViewById(R.id.islamic_date_linear);
  shamsiDate=view.findViewById(R.id.shamsi_date);
  shamsiDateDay=view.findViewById(R.id.shamsi_date_day);
  shamsiDateLinear=view.findViewById(R.id.shamsi_date_linear);
  weekDayName=view.findViewById(R.id.week_day_name);
  today=view.findViewById(R.id.today);
  todayIcon=view.findViewById(R.id.today_icon);
  warnUserIcon=view.findViewById(R.id.warn_user_icon);
  today.setVisibility(View.GONE);
  todayIcon.setVisibility(View.GONE);
  imsakTextView=view.findViewById(R.id.imsak);
  fajrTextView=view.findViewById(R.id.fajr);
  dhuhrTextView=view.findViewById(R.id.dhuhr);
  asrTextView=view.findViewById(R.id.asr);
  maghribTextView=view.findViewById(R.id.maghrib);
  ishaTextView=view.findViewById(R.id.isgha);
  sunriseTextView=view.findViewById(R.id.sunrise);
  sunsetTextView=view.findViewById(R.id.sunset);
  midnightTextView=view.findViewById(R.id.midnight);
  moreCalendar=view.findViewById(R.id.more_calendar);
  moreOwghat=view.findViewById(R.id.more_owghat);
  deviceEventTitle=view.findViewById(R.id.device_event_title);
  eventTitle=view.findViewById(R.id.event_title);
  eventMessage=view.findViewById(R.id.event_message);
  holidayTitle=view.findViewById(R.id.holiday_title);
  owghat=view.findViewById(R.id.owghat);
  owghatIcon=view.findViewById(R.id.owghat_icon);
  event=view.findViewById(R.id.cardEvent);
  monthViewPager=view.findViewById(R.id.calendar_pager);
  coordinate=Utils.getCoordinate(getContext());
  prayTimesCalculator=new PrayTimesCalculator(Utils.getCalculationMethod());
  monthViewPager.setAdapter(new CalendarAdapter(getChildFragmentManager(),Utils.isRTL(getContext())));
  CalendarAdapter.gotoOffset(monthViewPager,0);
  monthViewPager.addOnPageChangeListener(this);
  owghat.setOnClickListener(this);
  today.setOnClickListener(this);
  todayIcon.setOnClickListener(this);
  gregorianDate.setOnClickListener(this);
  gregorianDateDay.setOnClickListener(this);
  gregorianDateLinear.setOnClickListener(this);
  islamicDate.setOnClickListener(this);
  islamicDateDay.setOnClickListener(this);
  islamicDateLinear.setOnClickListener(this);
  shamsiDate.setOnClickListener(this);
  shamsiDateDay.setOnClickListener(this);
  shamsiDateLinear.setOnClickListener(this);
  view.findViewById(R.id.calendars_card).setOnClickListener(this);
  warnUserIcon.setVisibility(View.GONE);
  gregorianDateLinear.setVisibility(View.GONE);
  islamicDateLinear.setVisibility(View.GONE);
  shamsiDateLinear.setVisibility(View.GONE);
  String cityName=Utils.getCityName(getContext(),false);
  if (!TextUtils.isEmpty(cityName)) {
    ((TextView)view.findViewById(R.id.owghat_text)).append(""String_Node_Str"" + cityName + ""String_Node_Str"");
  }
  AbstractDate today=Utils.getTodayOfCalendar(Utils.getMainCalendar());
  Utils.setActivityTitleAndSubtitle(getActivity(),Utils.getMonthName(today),Utils.formatNumber(today.getYear()));
  owghatIcon.setOnLongClickListener(v -> {
    Utils.startAthan(getContext(),""String_Node_Str"");
    return true;
  }
);
  return view;
}","@Nullable @Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  setHasOptionsMenu(true);
  View view=inflater.inflate(R.layout.fragment_calendar,container,false);
  viewPagerPosition=0;
  imsakLayout=view.findViewById(R.id.imsakLayout);
  fajrLayout=view.findViewById(R.id.fajrLayout);
  sunriseLayout=view.findViewById(R.id.sunriseLayout);
  dhuhrLayout=view.findViewById(R.id.dhuhrLayout);
  asrLayout=view.findViewById(R.id.asrLayout);
  sunsetLayout=view.findViewById(R.id.sunsetLayout);
  maghribLayout=view.findViewById(R.id.maghribLayout);
  ishaLayout=view.findViewById(R.id.ishaLayout);
  midnightLayout=view.findViewById(R.id.midnightLayout);
  gregorianDate=view.findViewById(R.id.gregorian_date);
  gregorianDateDay=view.findViewById(R.id.gregorian_date_day);
  gregorianDateLinear=view.findViewById(R.id.gregorian_date_linear);
  islamicDate=view.findViewById(R.id.islamic_date);
  islamicDateDay=view.findViewById(R.id.islamic_date_day);
  islamicDateLinear=view.findViewById(R.id.islamic_date_linear);
  shamsiDate=view.findViewById(R.id.shamsi_date);
  shamsiDateDay=view.findViewById(R.id.shamsi_date_day);
  shamsiDateLinear=view.findViewById(R.id.shamsi_date_linear);
  weekDayName=view.findViewById(R.id.week_day_name);
  today=view.findViewById(R.id.today);
  todayIcon=view.findViewById(R.id.today_icon);
  warnUserIcon=view.findViewById(R.id.warn_user_icon);
  today.setVisibility(View.GONE);
  todayIcon.setVisibility(View.GONE);
  imsakTextView=view.findViewById(R.id.imsak);
  fajrTextView=view.findViewById(R.id.fajr);
  dhuhrTextView=view.findViewById(R.id.dhuhr);
  asrTextView=view.findViewById(R.id.asr);
  maghribTextView=view.findViewById(R.id.maghrib);
  ishaTextView=view.findViewById(R.id.isgha);
  sunriseTextView=view.findViewById(R.id.sunrise);
  sunsetTextView=view.findViewById(R.id.sunset);
  midnightTextView=view.findViewById(R.id.midnight);
  moreCalendar=view.findViewById(R.id.more_calendar);
  moreOwghat=view.findViewById(R.id.more_owghat);
  deviceEventTitle=view.findViewById(R.id.device_event_title);
  eventTitle=view.findViewById(R.id.event_title);
  eventMessage=view.findViewById(R.id.event_message);
  holidayTitle=view.findViewById(R.id.holiday_title);
  owghat=view.findViewById(R.id.owghat);
  owghatIcon=view.findViewById(R.id.owghat_icon);
  event=view.findViewById(R.id.cardEvent);
  monthViewPager=view.findViewById(R.id.calendar_pager);
  coordinate=Utils.getCoordinate(getContext());
  prayTimesCalculator=new PrayTimesCalculator(Utils.getCalculationMethod());
  monthViewPager.setAdapter(new CalendarAdapter(getChildFragmentManager(),Utils.isRTL(getContext())));
  CalendarAdapter.gotoOffset(monthViewPager,0);
  monthViewPager.addOnPageChangeListener(changeListener);
  owghat.setOnClickListener(this);
  today.setOnClickListener(this);
  todayIcon.setOnClickListener(this);
  gregorianDate.setOnClickListener(this);
  gregorianDateDay.setOnClickListener(this);
  gregorianDateLinear.setOnClickListener(this);
  islamicDate.setOnClickListener(this);
  islamicDateDay.setOnClickListener(this);
  islamicDateLinear.setOnClickListener(this);
  shamsiDate.setOnClickListener(this);
  shamsiDateDay.setOnClickListener(this);
  shamsiDateLinear.setOnClickListener(this);
  view.findViewById(R.id.calendars_card).setOnClickListener(this);
  warnUserIcon.setVisibility(View.GONE);
  gregorianDateLinear.setVisibility(View.GONE);
  islamicDateLinear.setVisibility(View.GONE);
  shamsiDateLinear.setVisibility(View.GONE);
  String cityName=Utils.getCityName(getContext(),false);
  if (!TextUtils.isEmpty(cityName)) {
    ((TextView)view.findViewById(R.id.owghat_text)).append(""String_Node_Str"" + cityName + ""String_Node_Str"");
  }
  AbstractDate today=Utils.getTodayOfCalendar(Utils.getMainCalendar());
  Utils.setActivityTitleAndSubtitle(getActivity(),Utils.getMonthName(today),Utils.formatNumber(today.getYear()));
  owghatIcon.setOnLongClickListener(v -> {
    Utils.startAthan(getContext(),""String_Node_Str"");
    return true;
  }
);
  return view;
}",0.9977951984321412
8625,"private void fillTheFields(){
  CalendarType mainCalendar=Utils.getMainCalendar();
  List<DayEntity> days=new ArrayList<>();
  typedDate=Utils.getTodayOfCalendar(mainCalendar);
  int month=typedDate.getMonth() - offset;
  month-=1;
  int year=typedDate.getYear();
  year=year + (month / 12);
  month=month % 12;
  if (month < 0) {
    year-=1;
    month+=12;
  }
  month+=1;
  typedDate=Utils.getDateOfCalendar(mainCalendar,year,month,1);
  long baseJdn=Utils.getJdnDate(typedDate);
  int monthLength=(int)(Utils.getJdnOfCalendar(mainCalendar,month == 12 ? year + 1 : year,month == 12 ? 1 : month + 1,1) - baseJdn);
  int dayOfWeek=Utils.getDayOfWeekFromJdn(baseJdn);
  long todayJdn=Utils.getTodayJdn();
  for (int i=0; i < monthLength; i++) {
    DayEntity dayEntity=new DayEntity();
    dayEntity.setJdn(baseJdn + i);
    if (baseJdn + i == todayJdn) {
      dayEntity.setToday(true);
    }
    dayEntity.setDayOfWeek(dayOfWeek);
    days.add(dayEntity);
    dayOfWeek++;
    if (dayOfWeek == 7) {
      dayOfWeek=0;
    }
  }
  this.days=days;
  long startOfYearJdn=Utils.getJdnOfCalendar(mainCalendar,year,1,1);
  weekOfYearStart=calculateWeekOfYear(baseJdn,startOfYearJdn);
  weeksCount=1 + calculateWeekOfYear(baseJdn + monthLength - 1,startOfYearJdn) - weekOfYearStart;
  startingDayOfWeek=Utils.getDayOfWeekFromJdn(baseJdn);
}","private void fillTheFields(){
  CalendarType mainCalendar=Utils.getMainCalendar();
  List<DayEntity> days=new ArrayList<>();
  typedDate=Utils.getTodayOfCalendar(mainCalendar);
  int month=typedDate.getMonth() - offset;
  month-=1;
  int year=typedDate.getYear();
  year=year + (month / 12);
  month=month % 12;
  if (month < 0) {
    year-=1;
    month+=12;
  }
  month+=1;
  typedDate=Utils.getDateOfCalendar(mainCalendar,year,month,1);
  baseJdn=Utils.getJdnDate(typedDate);
  monthLength=(int)(Utils.getJdnOfCalendar(mainCalendar,month == 12 ? year + 1 : year,month == 12 ? 1 : month + 1,1) - baseJdn);
  int dayOfWeek=Utils.getDayOfWeekFromJdn(baseJdn);
  long todayJdn=Utils.getTodayJdn();
  for (int i=0; i < monthLength; i++) {
    DayEntity dayEntity=new DayEntity();
    dayEntity.setJdn(baseJdn + i);
    if (baseJdn + i == todayJdn) {
      dayEntity.setToday(true);
    }
    dayEntity.setDayOfWeek(dayOfWeek);
    days.add(dayEntity);
    dayOfWeek++;
    if (dayOfWeek == 7) {
      dayOfWeek=0;
    }
  }
  this.days=days;
  long startOfYearJdn=Utils.getJdnOfCalendar(mainCalendar,year,1,1);
  weekOfYearStart=calculateWeekOfYear(baseJdn,startOfYearJdn);
  weeksCount=1 + calculateWeekOfYear(baseJdn + monthLength - 1,startOfYearJdn) - weekOfYearStart;
  startingDayOfWeek=Utils.getDayOfWeekFromJdn(baseJdn);
}",0.9966178128523112
8626,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_month,container,false);
  offset=getArguments().getInt(Constants.OFFSET_ARGUMENT);
  AppCompatImageView prev=view.findViewById(R.id.prev);
  AppCompatImageView next=view.findViewById(R.id.next);
  prev.setOnClickListener(this);
  next.setOnClickListener(this);
  RecyclerView recyclerView=view.findViewById(R.id.RecyclerView);
  recyclerView.setHasFixedSize(true);
  RecyclerView.LayoutManager layoutManager=new GridLayoutManager(getContext(),Utils.isWeekOfYearEnabled() ? 8 : 7);
  recyclerView.setLayoutManager(layoutManager);
  fillTheFields();
  adapter=new MonthAdapter(getContext(),this,days,startingDayOfWeek,weekOfYearStart,weeksCount);
  recyclerView.setAdapter(adapter);
  recyclerView.setItemAnimator(null);
  calendarFragment=(CalendarFragment)getActivity().getSupportFragmentManager().findFragmentByTag(CalendarFragment.class.getName());
  if (offset == 0 && calendarFragment.getViewPagerPosition() == offset) {
    calendarFragment.selectDay(Utils.getTodayJdn());
    updateTitle();
  }
  LocalBroadcastManager.getInstance(getContext()).registerReceiver(setCurrentMonthReceiver,new IntentFilter(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT));
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_month,container,false);
  offset=getArguments().getInt(Constants.OFFSET_ARGUMENT);
  AppCompatImageView prev=view.findViewById(R.id.prev);
  AppCompatImageView next=view.findViewById(R.id.next);
  prev.setOnClickListener(this);
  next.setOnClickListener(this);
  RecyclerView recyclerView=view.findViewById(R.id.RecyclerView);
  recyclerView.setHasFixedSize(true);
  RecyclerView.LayoutManager layoutManager=new GridLayoutManager(getContext(),Utils.isWeekOfYearEnabled() ? 8 : 7);
  recyclerView.setLayoutManager(layoutManager);
  fillTheFields();
  adapter=new MonthAdapter(getContext(),this,days,startingDayOfWeek,weekOfYearStart,weeksCount);
  recyclerView.setAdapter(adapter);
  recyclerView.setItemAnimator(null);
  calendarFragment=(CalendarFragment)getActivity().getSupportFragmentManager().findFragmentByTag(CalendarFragment.class.getName());
  if (calendarFragment.firstTime && offset == 0 && calendarFragment.getViewPagerPosition() == offset) {
    calendarFragment.firstTime=false;
    calendarFragment.selectDay(Utils.getTodayJdn());
    updateTitle();
  }
  LocalBroadcastManager.getInstance(getContext()).registerReceiver(setCurrentMonthReceiver,new IntentFilter(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT));
  return view;
}",0.9750183688464364
8627,"@Override public void onReceive(Context context,Intent intent){
  int value=intent.getExtras().getInt(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT);
  if (value == offset) {
    updateTitle();
    int day=intent.getExtras().getInt(Constants.BROADCAST_FIELD_SELECT_DAY);
    if (day != -1) {
      adapter.selectDay(day);
    }
  }
 else   if (value == Constants.BROADCAST_TO_MONTH_FRAGMENT_RESET_DAY) {
    adapter.clearSelectedDay();
  }
}","@Override public void onReceive(Context context,Intent intent){
  int value=intent.getExtras().getInt(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT);
  if (value == offset) {
    updateTitle();
    long jdn=intent.getExtras().getLong(Constants.BROADCAST_FIELD_SELECT_DAY_JDN);
    long selectedDay=1 + jdn - baseJdn;
    if (jdn != -1 && jdn >= baseJdn && selectedDay <= monthLength) {
      adapter.selectDay((int)(1 + jdn - baseJdn));
    }
  }
 else {
    adapter.selectDay(-1);
  }
}",0.6645021645021645
8628,"@Override public void onClick(){
  try {
    startActivityAndCollapse(new Intent(this,MainActivity.class));
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
  }
}","@Override public void onClick(){
  try {
    startActivityAndCollapse(new Intent(this,MainActivity.class).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
  }
}",0.9056603773584906
8629,"@Override public void onClick(View v){
  int position=getAdapterPosition();
  if (Utils.isWeekOfYearEnabled()) {
    if (position % 8 == 0) {
      return;
    }
    position=fixForWeekOfYearNumber(position);
  }
  if (totalDays < position - 6 - startingDayOfWeek) {
    return;
  }
  if (position - 7 - startingDayOfWeek >= 0) {
    monthFragment.onClickItem(days.get(position - 7 - startingDayOfWeek).getJdn());
    MonthAdapter.this.selectDay(1 + position - 7 - startingDayOfWeek);
  }
}","@Override public void onClick(View v){
  int position=getAdapterPosition();
  if (Utils.isWeekOfYearEnabled()) {
    if (position % 8 == 0) {
      return;
    }
    position=fixForWeekOfYearNumber(position);
  }
  if (totalDays < position - 6 - startingDayOfWeek || position - 7 - startingDayOfWeek < 0) {
    return;
  }
  monthFragment.onClickItem(days.get(position - 7 - startingDayOfWeek).getJdn());
  MonthAdapter.this.selectDay(1 + position - 7 - startingDayOfWeek);
}",0.9015544041450776
8630,"@Override public boolean onLongClick(View v){
  int position=getAdapterPosition();
  if (Utils.isWeekOfYearEnabled()) {
    if (position % 8 == 0) {
      return false;
    }
    position=fixForWeekOfYearNumber(position);
  }
  if (totalDays < position - 6 - startingDayOfWeek) {
    return false;
  }
  monthFragment.onLongClickItem(days.get(position - 7 - startingDayOfWeek).getJdn());
  onClick(v);
  return false;
}","@Override public boolean onLongClick(View v){
  int position=getAdapterPosition();
  if (Utils.isWeekOfYearEnabled()) {
    if (position % 8 == 0) {
      return false;
    }
    position=fixForWeekOfYearNumber(position);
  }
  if (totalDays < position - 6 - startingDayOfWeek || position - 7 - startingDayOfWeek < 0) {
    return false;
  }
  monthFragment.onLongClickItem(days.get(position - 7 - startingDayOfWeek).getJdn());
  onClick(v);
  return false;
}",0.9544419134396356
8631,"@Override public void onBindViewHolder(MonthAdapter.ViewHolder holder,int position){
  int originalPosition=position;
  if (Utils.isWeekOfYearEnabled()) {
    if (position % 8 == 0) {
      int row=position / 8;
      if (row > 0 && row <= weeksCount) {
        holder.num.setText(Utils.formatNumber(weekOfYearStart + row - 1));
        holder.num.setTextColor(ContextCompat.getColor(context,colorDayName.resourceId));
        holder.num.setTextSize(12);
        holder.num.setBackgroundResource(0);
        holder.num.setVisibility(View.VISIBLE);
      }
 else       setEmpty(holder);
      return;
    }
    position=fixForWeekOfYearNumber(position);
  }
  if (totalDays < position - 6 - startingDayOfWeek) {
    setEmpty(holder);
  }
 else   if (isPositionHeader(position)) {
    holder.num.setText(Utils.getInitialOfWeekDay(Utils.fixDayOfWeek(position)));
    holder.num.setTextColor(ContextCompat.getColor(context,colorDayName.resourceId));
    holder.num.setTextSize(20);
    holder.today.setVisibility(View.GONE);
    holder.num.setBackgroundResource(0);
    holder.event.setVisibility(View.GONE);
    holder.num.setVisibility(View.VISIBLE);
  }
 else {
    if (position - 7 - startingDayOfWeek >= 0) {
      holder.num.setText(Utils.formatNumber(1 + position - 7 - startingDayOfWeek));
      holder.num.setVisibility(View.VISIBLE);
      DayEntity day=days.get(position - 7 - startingDayOfWeek);
      holder.num.setTextSize(isArabicDigit ? 20 : 25);
      List<AbstractEvent> events=Utils.getEvents(day.getJdn());
      boolean isEvent=false, isHoliday=false;
      if (Utils.isWeekEnd(day.getDayOfWeek()) || !TextUtils.isEmpty(Utils.getEventsTitle(events,true))) {
        isHoliday=false;
      }
      if (events.size() > 0) {
        isEvent=true;
      }
      holder.event.setVisibility(isEvent ? View.VISIBLE : View.GONE);
      holder.today.setVisibility(day.isToday() ? View.VISIBLE : View.GONE);
      if (originalPosition == selectedDay) {
        holder.num.setBackgroundResource(shapeSelectDay.resourceId);
        holder.num.setTextColor(ContextCompat.getColor(context,isHoliday ? colorTextHoliday.resourceId : colorPrimary.resourceId));
      }
 else {
        holder.num.setBackgroundResource(0);
        holder.num.setTextColor(ContextCompat.getColor(context,isHoliday ? colorHoliday.resourceId : colorTextDay.resourceId));
      }
    }
 else {
      setEmpty(holder);
    }
  }
}","@Override public void onBindViewHolder(MonthAdapter.ViewHolder holder,int position){
  int originalPosition=position;
  if (Utils.isWeekOfYearEnabled()) {
    if (position % 8 == 0) {
      int row=position / 8;
      if (row > 0 && row <= weeksCount) {
        holder.num.setText(Utils.formatNumber(weekOfYearStart + row - 1));
        holder.num.setTextColor(ContextCompat.getColor(context,colorDayName.resourceId));
        holder.num.setTextSize(12);
        holder.num.setBackgroundResource(0);
        holder.num.setVisibility(View.VISIBLE);
      }
 else       setEmpty(holder);
      return;
    }
    position=fixForWeekOfYearNumber(position);
  }
  if (totalDays < position - 6 - startingDayOfWeek) {
    setEmpty(holder);
  }
 else   if (isPositionHeader(position)) {
    holder.num.setText(Utils.getInitialOfWeekDay(Utils.fixDayOfWeek(position)));
    holder.num.setTextColor(ContextCompat.getColor(context,colorDayName.resourceId));
    holder.num.setTextSize(20);
    holder.today.setVisibility(View.GONE);
    holder.num.setBackgroundResource(0);
    holder.event.setVisibility(View.GONE);
    holder.num.setVisibility(View.VISIBLE);
  }
 else {
    if (position - 7 - startingDayOfWeek >= 0) {
      holder.num.setText(Utils.formatNumber(1 + position - 7 - startingDayOfWeek));
      holder.num.setVisibility(View.VISIBLE);
      DayEntity day=days.get(position - 7 - startingDayOfWeek);
      holder.num.setTextSize(isArabicDigit ? 20 : 25);
      List<AbstractEvent> events=Utils.getEvents(day.getJdn());
      boolean isEvent=false, isHoliday=false;
      if (Utils.isWeekEnd(day.getDayOfWeek()) || !TextUtils.isEmpty(Utils.getEventsTitle(events,true))) {
        isHoliday=true;
      }
      if (events.size() > 0) {
        isEvent=true;
      }
      holder.event.setVisibility(isEvent ? View.VISIBLE : View.GONE);
      holder.today.setVisibility(day.isToday() ? View.VISIBLE : View.GONE);
      if (originalPosition == selectedDay) {
        holder.num.setBackgroundResource(shapeSelectDay.resourceId);
        holder.num.setTextColor(ContextCompat.getColor(context,isHoliday ? colorTextHoliday.resourceId : colorPrimary.resourceId));
      }
 else {
        holder.num.setBackgroundResource(0);
        holder.num.setTextColor(ContextCompat.getColor(context,isHoliday ? colorHoliday.resourceId : colorTextDay.resourceId));
      }
    }
 else {
      setEmpty(holder);
    }
  }
}",0.9985456056513607
8632,"public static void update(Context context,boolean updateDate){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Calendar calendar=Utils.makeCalendarFromDate(new Date());
  CalendarTypeEnum mainCalendar=Utils.getMainCalendar();
  AbstractDate date=Utils.getTodayOfCalendar(mainCalendar);
  long jdn=Utils.getJdnDate(date);
  Intent intent=new Intent(context,MainActivity.class);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  String colorInt=Utils.getSelectedWidgetTextColor();
  int color=Color.parseColor(colorInt);
  ComponentName widget1x1=new ComponentName(context,Widget1x1.class), widget4x1=new ComponentName(context,Widget4x1.class), widget2x2=new ComponentName(context,Widget2x2.class);
  if (manager.getAppWidgetIds(widget1x1).length != 0) {
    RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
    remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
    remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
    remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,Utils.formatNumber(date.getDayOfMonth()));
    remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,Utils.getMonthName(date));
    remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
    manager.updateAppWidget(widget1x1,remoteViews1);
  }
  if (pastDate == null || !pastDate.equals(date) || updateDate) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    pastDate=date;
    Utils.initUtils(context);
    updateDate=true;
  }
  String weekDayName=Utils.getWeekDayName(date);
  String status=Utils.getMonthName(date);
  String title=Utils.dayTitleSummary(date);
  String subtitle=Utils.dateStringOfOtherCalendar(mainCalendar,jdn);
  if (manager.getAppWidgetIds(widget4x1).length != 0 || manager.getAppWidgetIds(widget2x2).length != 0) {
    RemoteViews remoteViews4, remoteViews2;
    boolean enableClock=Utils.isWidgetClock() && Build.VERSION.SDK_INT > Build.VERSION_CODES.JELLY_BEAN_MR1;
    if (enableClock) {
      if (!Utils.isIranTime()) {
        remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1_clock);
        remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2_clock);
      }
 else {
        remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1_clock_iran);
        remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2_clock_iran);
      }
    }
 else {
      remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
      remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2);
    }
    String mainDateString=Utils.dateToString(date);
{
      remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
      remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
      remoteViews4.setTextColor(R.id.textPlaceholder3_4x1,color);
      String text2;
      String text3=""String_Node_Str"";
      if (enableClock) {
        text2=title;
        if (Utils.isIranTime()) {
          text3=""String_Node_Str"" + context.getString(R.string.iran_time) + ""String_Node_Str"";
        }
      }
 else {
        remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,weekDayName);
        text2=mainDateString;
      }
      text2+=Utils.getComma() + ""String_Node_Str"" + subtitle;
      remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,text2);
      remoteViews4.setTextViewText(R.id.textPlaceholder3_4x1,text3);
      remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
      manager.updateAppWidget(widget4x1,remoteViews4);
    }
{
      String text2;
      remoteViews2.setTextColor(R.id.time_2x2,color);
      remoteViews2.setTextColor(R.id.date_2x2,color);
      remoteViews2.setTextColor(R.id.event_2x2,color);
      remoteViews2.setTextColor(R.id.owghat_2x2,color);
      if (enableClock) {
        text2=title;
      }
 else {
        remoteViews2.setTextViewText(R.id.time_2x2,weekDayName);
        text2=mainDateString;
      }
      Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
      String owghat;
      if (updateDate) {
        owghat=Utils.getNextOghatTime(context,currentClock,true);
        List<AbstractEvent> events=Utils.getEvents(jdn);
        String holidays=Utils.getEventsTitle(events,true);
        if (!TextUtils.isEmpty(holidays)) {
          remoteViews2.setTextViewText(R.id.holiday_2x2,holidays);
          remoteViews2.setViewVisibility(R.id.holiday_2x2,View.VISIBLE);
        }
 else {
          remoteViews2.setViewVisibility(R.id.holiday_2x2,View.GONE);
        }
        String nonHolidays=Utils.getEventsTitle(events,false);
        if (!TextUtils.isEmpty(nonHolidays)) {
          remoteViews2.setTextViewText(R.id.event_2x2,nonHolidays);
          remoteViews2.setViewVisibility(R.id.event_2x2,View.VISIBLE);
        }
 else {
          remoteViews2.setViewVisibility(R.id.event_2x2,View.GONE);
        }
      }
 else {
        owghat=Utils.getNextOghatTime(context,currentClock,false);
      }
      if (owghat != null) {
        remoteViews2.setTextViewText(R.id.owghat_2x2,owghat);
        remoteViews2.setViewVisibility(R.id.owghat_2x2,View.VISIBLE);
      }
 else {
        remoteViews2.setViewVisibility(R.id.owghat_2x2,View.GONE);
      }
      remoteViews2.setTextViewText(R.id.date_2x2,text2);
      remoteViews2.setOnClickPendingIntent(R.id.widget_layout2x2,launchAppPendingIntent);
      manager.updateAppWidget(widget2x2,remoteViews2);
    }
  }
  if ((Build.VERSION.SDK_INT > Build.VERSION_CODES.JELLY_BEAN) && (Build.VERSION.SDK_INT < Build.VERSION_CODES.N)) {
    title=Constants.RLM + title;
    subtitle=Constants.RLM + subtitle;
  }
  int icon=Utils.getDayIconResource(date.getDayOfMonth());
  if (Utils.isNotifyDate()) {
    NotificationManager notificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
      int importance=NotificationManager.IMPORTANCE_LOW;
      NotificationChannel channel=new NotificationChannel(String.valueOf(NOTIFICATION_ID),context.getString(R.string.app_name),importance);
      channel.setShowBadge(false);
      if (notificationManager != null) {
        notificationManager.createNotificationChannel(channel);
      }
    }
    NotificationCompat.Builder builder=new NotificationCompat.Builder(context,String.valueOf(NOTIFICATION_ID)).setPriority(NotificationCompat.PRIORITY_LOW).setSmallIcon(icon).setOngoing(true).setWhen(0).setContentIntent(launchAppPendingIntent).setVisibility(Utils.isNotifyDateOnLockScreen() ? NotificationCompat.VISIBILITY_PUBLIC : NotificationCompat.VISIBILITY_SECRET).setColor(0xFF607D8B).setContentTitle(title).setContentText(subtitle);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N || BuildConfig.DEBUG) {
      RemoteViews cv=new RemoteViews(context.getPackageName(),R.layout.custom_notification);
      cv.setTextViewText(R.id.title,title);
      cv.setTextViewText(R.id.body,subtitle);
      RemoteViews bcv=new RemoteViews(context.getPackageName(),R.layout.custom_notification_big);
      bcv.setTextViewText(R.id.title,title);
      bcv.setTextViewText(R.id.body,subtitle);
      List<AbstractEvent> events=Utils.getEvents(jdn);
      String holidays=Utils.getEventsTitle(events,true,true);
      if (!TextUtils.isEmpty(holidays))       bcv.setTextViewText(R.id.holidays,holidays);
 else       bcv.setViewVisibility(R.id.holidays,View.GONE);
      String nonHolidays=Utils.getEventsTitle(events,false,true);
      if (!TextUtils.isEmpty(nonHolidays))       bcv.setTextViewText(R.id.nonholidays,nonHolidays);
 else       bcv.setViewVisibility(R.id.nonholidays,View.GONE);
      Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
      String owghat=Utils.getNextOghatTime(context,currentClock,true);
      if (!TextUtils.isEmpty(owghat))       bcv.setTextViewText(R.id.owghat,owghat);
 else       bcv.setViewVisibility(R.id.owghat,View.GONE);
      builder=builder.setCustomContentView(cv).setCustomBigContentView(bcv).setStyle(new NotificationCompat.DecoratedCustomViewStyle());
    }
    if (BuildConfig.DEBUG) {
      builder=builder.setShowWhen(true);
    }
    notificationManager.notify(NOTIFICATION_ID,builder.build());
  }
  mExtensionData=new ExtensionData().visible(true).icon(icon).status(status).expandedTitle(title).expandedBody(subtitle).clickIntent(intent);
}","public static void update(Context context,boolean updateDate){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Calendar calendar=Utils.makeCalendarFromDate(new Date());
  CalendarTypeEnum mainCalendar=Utils.getMainCalendar();
  AbstractDate date=Utils.getTodayOfCalendar(mainCalendar);
  long jdn=Utils.getJdnDate(date);
  Intent intent=new Intent(context,MainActivity.class);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  String colorInt=Utils.getSelectedWidgetTextColor();
  int color=Color.parseColor(colorInt);
  ComponentName widget1x1=new ComponentName(context,Widget1x1.class), widget4x1=new ComponentName(context,Widget4x1.class), widget2x2=new ComponentName(context,Widget2x2.class);
  if (manager.getAppWidgetIds(widget1x1).length != 0) {
    RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
    remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
    remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
    remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,Utils.formatNumber(date.getDayOfMonth()));
    remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,Utils.getMonthName(date));
    remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
    manager.updateAppWidget(widget1x1,remoteViews1);
  }
  if (pastDate == null || !pastDate.equals(date) || updateDate) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    pastDate=date;
    Utils.initUtils(context);
    updateDate=true;
  }
  String weekDayName=Utils.getWeekDayName(date);
  String status=Utils.getMonthName(date);
  String title=Utils.dayTitleSummary(date);
  String subtitle=Utils.dateStringOfOtherCalendar(mainCalendar,jdn);
  if (manager.getAppWidgetIds(widget4x1).length != 0 || manager.getAppWidgetIds(widget2x2).length != 0) {
    RemoteViews remoteViews4, remoteViews2;
    boolean enableClock=Utils.isWidgetClock() && Build.VERSION.SDK_INT > Build.VERSION_CODES.JELLY_BEAN_MR1;
    if (enableClock) {
      if (!Utils.isIranTime()) {
        remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1_clock);
        remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2_clock);
      }
 else {
        remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1_clock_iran);
        remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2_clock_iran);
      }
    }
 else {
      remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
      remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2);
    }
    String mainDateString=Utils.dateToString(date);
{
      remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
      remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
      remoteViews4.setTextColor(R.id.textPlaceholder3_4x1,color);
      String text2;
      String text3=""String_Node_Str"";
      if (enableClock) {
        text2=title;
        if (Utils.isIranTime()) {
          text3=""String_Node_Str"" + context.getString(R.string.iran_time) + ""String_Node_Str"";
        }
      }
 else {
        remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,weekDayName);
        text2=mainDateString;
      }
      text2+=Utils.getComma() + ""String_Node_Str"" + subtitle;
      remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,text2);
      remoteViews4.setTextViewText(R.id.textPlaceholder3_4x1,text3);
      remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
      manager.updateAppWidget(widget4x1,remoteViews4);
    }
{
      String text2;
      remoteViews2.setTextColor(R.id.time_2x2,color);
      remoteViews2.setTextColor(R.id.date_2x2,color);
      remoteViews2.setTextColor(R.id.event_2x2,color);
      remoteViews2.setTextColor(R.id.owghat_2x2,color);
      if (enableClock) {
        text2=title;
      }
 else {
        remoteViews2.setTextViewText(R.id.time_2x2,weekDayName);
        text2=mainDateString;
      }
      Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
      String owghat;
      if (updateDate) {
        owghat=Utils.getNextOghatTime(context,currentClock,true);
        List<AbstractEvent> events=Utils.getEvents(jdn);
        String holidays=Utils.getEventsTitle(events,true);
        if (!TextUtils.isEmpty(holidays)) {
          remoteViews2.setTextViewText(R.id.holiday_2x2,holidays);
          remoteViews2.setViewVisibility(R.id.holiday_2x2,View.VISIBLE);
        }
 else {
          remoteViews2.setViewVisibility(R.id.holiday_2x2,View.GONE);
        }
        String nonHolidays=Utils.getEventsTitle(events,false);
        if (!TextUtils.isEmpty(nonHolidays)) {
          remoteViews2.setTextViewText(R.id.event_2x2,nonHolidays);
          remoteViews2.setViewVisibility(R.id.event_2x2,View.VISIBLE);
        }
 else {
          remoteViews2.setViewVisibility(R.id.event_2x2,View.GONE);
        }
      }
 else {
        owghat=Utils.getNextOghatTime(context,currentClock,false);
      }
      if (owghat != null) {
        remoteViews2.setTextViewText(R.id.owghat_2x2,owghat);
        remoteViews2.setViewVisibility(R.id.owghat_2x2,View.VISIBLE);
      }
 else {
        remoteViews2.setViewVisibility(R.id.owghat_2x2,View.GONE);
      }
      remoteViews2.setTextViewText(R.id.date_2x2,text2);
      remoteViews2.setOnClickPendingIntent(R.id.widget_layout2x2,launchAppPendingIntent);
      manager.updateAppWidget(widget2x2,remoteViews2);
    }
  }
  if ((Build.VERSION.SDK_INT > Build.VERSION_CODES.JELLY_BEAN) && (Build.VERSION.SDK_INT < Build.VERSION_CODES.N)) {
    title=Constants.RLM + title;
    subtitle=Constants.RLM + subtitle;
  }
  int icon=Utils.getDayIconResource(date.getDayOfMonth());
  if (Utils.isNotifyDate()) {
    NotificationManager notificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
      int importance=NotificationManager.IMPORTANCE_LOW;
      NotificationChannel channel=new NotificationChannel(String.valueOf(NOTIFICATION_ID),context.getString(R.string.app_name),importance);
      channel.setShowBadge(false);
      if (notificationManager != null) {
        notificationManager.createNotificationChannel(channel);
      }
    }
    NotificationCompat.Builder builder=new NotificationCompat.Builder(context,String.valueOf(NOTIFICATION_ID)).setPriority(NotificationCompat.PRIORITY_LOW).setSmallIcon(icon).setOngoing(true).setWhen(0).setContentIntent(launchAppPendingIntent).setVisibility(Utils.isNotifyDateOnLockScreen() ? NotificationCompat.VISIBILITY_PUBLIC : NotificationCompat.VISIBILITY_SECRET).setColor(0xFF607D8B).setContentTitle(title).setContentText(subtitle);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N || BuildConfig.DEBUG) {
      RemoteViews cv=new RemoteViews(context.getPackageName(),R.layout.custom_notification);
      cv.setTextViewText(R.id.title,title);
      cv.setTextViewText(R.id.body,subtitle);
      RemoteViews bcv=new RemoteViews(context.getPackageName(),R.layout.custom_notification_big);
      bcv.setTextViewText(R.id.title,title);
      bcv.setTextViewText(R.id.body,subtitle);
      List<AbstractEvent> events=Utils.getEvents(jdn);
      String holidays=Utils.getEventsTitle(events,true,true);
      if (!TextUtils.isEmpty(holidays))       bcv.setTextViewText(R.id.holidays,holidays);
 else       bcv.setViewVisibility(R.id.holidays,View.GONE);
      String nonHolidays=Utils.getEventsTitle(events,false,true);
      if (!TextUtils.isEmpty(nonHolidays))       bcv.setTextViewText(R.id.nonholidays,nonHolidays);
 else       bcv.setViewVisibility(R.id.nonholidays,View.GONE);
      Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
      String owghat=Utils.getNextOghatTime(context,currentClock,true);
      if (!TextUtils.isEmpty(owghat))       bcv.setTextViewText(R.id.owghat,owghat);
 else       bcv.setViewVisibility(R.id.owghat,View.GONE);
      builder=builder.setCustomContentView(cv).setCustomBigContentView(bcv).setStyle(new NotificationCompat.DecoratedCustomViewStyle());
    }
    if (BuildConfig.DEBUG) {
      builder=builder.setWhen(Calendar.getInstance().getTimeInMillis());
    }
    notificationManager.notify(NOTIFICATION_ID,builder.build());
  }
  mExtensionData=new ExtensionData().visible(true).icon(icon).status(status).expandedTitle(title).expandedBody(subtitle).clickIntent(intent);
}",0.9972089777881148
8633,"@Override public void onClick(View v){
  int position=fixRtlPosition(getAdapterPosition());
  if (Utils.isWeekOfYearEnabled()) {
    position=fixForWeekOfYearNumber(position);
  }
  if (totalDays < position - 6 - firstDayDayOfWeek) {
    return;
  }
  if (position - 7 - firstDayDayOfWeek >= 0) {
    monthFragment.onClickItem(days.get(position - 7 - firstDayDayOfWeek).getJdn());
    selectedDay=position;
    notifyItemChanged(prevDay);
    notifyItemChanged(getAdapterPosition());
    prevDay=getAdapterPosition();
  }
}","@Override public void onClick(View v){
  int position=fixRtlPosition(getAdapterPosition());
  if (Utils.isWeekOfYearEnabled()) {
    position=fixForWeekOfYearNumber(position);
    if (position % 8 == 0) {
      return;
    }
  }
  if (totalDays < position - 6 - firstDayDayOfWeek) {
    return;
  }
  if (position - 7 - firstDayDayOfWeek >= 0) {
    monthFragment.onClickItem(days.get(position - 7 - firstDayDayOfWeek).getJdn());
    selectedDay=position;
    notifyItemChanged(prevDay);
    notifyItemChanged(getAdapterPosition());
    prevDay=getAdapterPosition();
  }
}",0.9552511415525116
8634,"@Override public boolean onLongClick(View v){
  int position=fixRtlPosition(getAdapterPosition());
  if (Utils.isWeekOfYearEnabled()) {
    position=fixForWeekOfYearNumber(position);
  }
  if (totalDays < position - 6 - firstDayDayOfWeek) {
    return false;
  }
  try {
    monthFragment.onLongClickItem(days.get(position - 7 - firstDayDayOfWeek).getJdn());
  }
 catch (  Exception e) {
  }
  return false;
}","@Override public boolean onLongClick(View v){
  int position=fixRtlPosition(getAdapterPosition());
  if (Utils.isWeekOfYearEnabled()) {
    position=fixForWeekOfYearNumber(position);
    if (position % 8 == 0) {
      return false;
    }
  }
  if (totalDays < position - 6 - firstDayDayOfWeek) {
    return false;
  }
  try {
    monthFragment.onLongClickItem(days.get(position - 7 - firstDayDayOfWeek).getJdn());
  }
 catch (  Exception e) {
  }
  return false;
}",0.9369988545246276
8635,"public void drawTrueNorthArrow(Canvas canvas,float drawnAngle){
  trueNorthArrowPaint.reset();
  trueNorthArrowPaint.setColor(Color.RED);
  trueNorthArrowPaint.setStyle(Paint.Style.FILL);
  trueNorthArrowPaint.setAlpha(100);
  int r=Radius / 12;
  mPath.reset();
  mPath.moveTo(px,py - px);
  mPath.lineTo(px - r,py);
  mPath.lineTo(px,py + r);
  mPath.lineTo(px + r,py);
  mPath.addCircle(px,py,r,Path.Direction.CCW);
  mPath.close();
  canvas.drawPath(mPath,trueNorthArrowPaint);
  dashedPaint.setColor(Color.RED);
  canvas.drawLine(px,py - px,px,py + Radius,dashedPaint);
  canvas.drawCircle(px,py,5,dashedPaint);
  canvas.restore();
}","public void drawTrueNorthArrow(Canvas canvas,float drawnAngle){
  trueNorthArrowPaint.reset();
  trueNorthArrowPaint.setColor(Color.RED);
  trueNorthArrowPaint.setStyle(Paint.Style.FILL);
  trueNorthArrowPaint.setAlpha(100);
  int r=Radius / 12;
  mPath.reset();
  mPath.moveTo(px,py - Radius);
  mPath.lineTo(px - r,py);
  mPath.lineTo(px,py + r);
  mPath.lineTo(px + r,py);
  mPath.addCircle(px,py,r,Path.Direction.CCW);
  mPath.close();
  canvas.drawPath(mPath,trueNorthArrowPaint);
  dashedPaint.setColor(Color.RED);
  canvas.drawLine(px,py - px,px,py + Radius,dashedPaint);
  canvas.drawCircle(px,py,5,dashedPaint);
  canvas.restore();
}",0.99375
8636,"public void drawDial(Canvas canvas){
  circlePaint.reset();
  circlePaint.setColor(ContextCompat.getColor(getContext(),R.color.qibla_color));
  circlePaint.setStrokeWidth(1);
  circlePaint.setStyle(Paint.Style.STROKE);
  int textHeight=(int)textPaint.measureText(""String_Node_Str"");
  markerPaint.reset();
  markerPaint.setColor(ContextCompat.getColor(getContext(),R.color.qibla_color));
  canvas.drawCircle(px,py,Radius,circlePaint);
  canvas.drawCircle(px,py,Radius - 20,circlePaint);
  int textWidth=(int)textPaint.measureText(""String_Node_Str"");
  int cardinalX=px - textWidth / 2;
  int cardinalY=py - Radius + textHeight;
  for (int i=0; i < 24; i++) {
    canvas.drawLine(px,py - Radius,px,py - Radius + 10,markerPaint);
    canvas.save();
    canvas.translate(0,textHeight);
    if (i % 6 == 0) {
      String dirString=""String_Node_Str"";
switch (i) {
case (0):
{
          dirString=northString;
          break;
        }
case (6):
      dirString=eastString;
    break;
case (12):
  dirString=southString;
break;
case (18):
dirString=westString;
break;
}
canvas.drawText(dirString,cardinalX,cardinalY,textPaint);
}
 else if (i % 3 == 0) {
String angle=String.valueOf(i * 15);
float angleTextWidth=textPaint.measureText(angle);
int angleTextX=(int)(px - angleTextWidth / 2);
int angleTextY=py - Radius + textHeight;
canvas.drawText(angle,angleTextX,angleTextY,textPaint);
}
canvas.restore();
canvas.rotate(15,px,py);
}
}","public void drawDial(Canvas canvas){
  circlePaint.reset();
  circlePaint.setColor(ContextCompat.getColor(getContext(),R.color.qibla_color));
  circlePaint.setStrokeWidth(1);
  circlePaint.setStyle(Paint.Style.STROKE);
  int textHeight=(int)textPaint.measureText(""String_Node_Str"");
  markerPaint.reset();
  markerPaint.setColor(ContextCompat.getColor(getContext(),R.color.qibla_color));
  canvas.drawCircle(px,py,Radius,circlePaint);
  canvas.drawCircle(px,py,Radius - 20,circlePaint);
  int textWidth=(int)textPaint.measureText(""String_Node_Str"");
  int cardinalX=px - textWidth / 2;
  int cardinalY=py - Radius + textHeight;
  for (int i=0; i < 24; i++) {
    canvas.drawLine(px,py - Radius,px,py - Radius + 10,markerPaint);
    canvas.save();
    canvas.translate(0,textHeight);
    if (i % 6 == 0) {
      String dirString=""String_Node_Str"";
switch (i) {
case 0:
        dirString=northString;
      break;
case 6:
    dirString=eastString;
  break;
case 12:
dirString=southString;
break;
case 18:
dirString=westString;
break;
}
canvas.drawText(dirString,cardinalX,cardinalY,textPaint);
}
 else if (i % 3 == 0) {
String angle=String.valueOf(i * 15);
float angleTextWidth=textPaint.measureText(angle);
int angleTextX=(int)(px - angleTextWidth / 2);
int angleTextY=py - Radius + textHeight;
canvas.drawText(angle,angleTextX,angleTextY,textPaint);
}
canvas.restore();
canvas.rotate(15,px,py);
}
}",0.9695898161244696
8637,"@Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  setHasOptionsMenu(true);
  View view=inflater.inflate(R.layout.fragment_compass,container,false);
  Context context=getContext();
  Coordinate coordinate=Utils.getCoordinate(getContext());
  if (coordinate == null) {
    Utils.setActivityTitleAndSubtitle(getActivity(),getString(R.string.compass),""String_Node_Str"");
  }
 else {
    Utils.setActivityTitleAndSubtitle(getActivity(),getString(R.string.qibla_compass),Utils.getCityName(context,true));
  }
  compassListener=new SensorEventListener(){
    static final float ALPHA=0.15f;
    float azimuth;
    @Override public void onAccuracyChanged(    Sensor sensor,    int accuracy){
    }
    @Override public void onSensorChanged(    SensorEvent event){
      float angle=event.values[0];
      if (stop)       angle=0;
      azimuth=lowPass(angle,azimuth);
      compassView.setBearing(azimuth);
      compassView.invalidate();
    }
    /** 
 * https://en.wikipedia.org/wiki/Low-pass_filter#Algorithmic_implementation http://developer.android.com/reference/android/hardware/SensorEvent.html#values
 */
    private float lowPass(    float input,    float output){
      if (Math.abs(180 - input) > 170) {
        return input;
      }
      return output + ALPHA * (input - output);
    }
  }
;
  compassView=view.findViewById(R.id.compass_view);
  DisplayMetrics displayMetrics=new DisplayMetrics();
  getActivity().getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
  int width=displayMetrics.widthPixels;
  int height=displayMetrics.heightPixels;
  compassView.setScreenResolution(width,height - 2 * height / 8);
  if (coordinate != null) {
    compassView.setLongitude(coordinate.getLongitude());
    compassView.setLatitude(coordinate.getLatitude());
    compassView.initCompassView();
    compassView.invalidate();
  }
  sensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
  sensor=sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);
  if (sensor != null) {
    sensorManager.registerListener(compassListener,sensor,SensorManager.SENSOR_DELAY_FASTEST);
  }
 else {
    Toast.makeText(context,getString(R.string.compass_not_found),Toast.LENGTH_SHORT).show();
  }
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  setHasOptionsMenu(true);
  View view=inflater.inflate(R.layout.fragment_compass,container,false);
  Context context=getContext();
  Coordinate coordinate=Utils.getCoordinate(getContext());
  if (coordinate == null) {
    Utils.setActivityTitleAndSubtitle(getActivity(),getString(R.string.compass),""String_Node_Str"");
  }
 else {
    Utils.setActivityTitleAndSubtitle(getActivity(),getString(R.string.qibla_compass),Utils.getCityName(context,true));
  }
  compassListener=new SensorEventListener(){
    static final float ALPHA=0.15f;
    float azimuth;
    @Override public void onAccuracyChanged(    Sensor sensor,    int accuracy){
    }
    @Override public void onSensorChanged(    SensorEvent event){
      float angle=event.values[0];
      if (stop)       angle=0;
      azimuth=lowPass(angle,azimuth);
      compassView.setBearing(azimuth);
      compassView.invalidate();
    }
    /** 
 * https://en.wikipedia.org/wiki/Low-pass_filter#Algorithmic_implementation http://developer.android.com/reference/android/hardware/SensorEvent.html#values
 */
    private float lowPass(    float input,    float output){
      if (Math.abs(180 - input) > 170) {
        return input;
      }
      return output + ALPHA * (input - output);
    }
  }
;
  compassView=view.findViewById(R.id.compass_view);
  setCompassMetrics();
  if (coordinate != null) {
    compassView.setLongitude(coordinate.getLongitude());
    compassView.setLatitude(coordinate.getLatitude());
    compassView.initCompassView();
    compassView.invalidate();
  }
  sensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
  sensor=sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);
  if (sensor != null) {
    sensorManager.registerListener(compassListener,sensor,SensorManager.SENSOR_DELAY_FASTEST);
  }
 else {
    Toast.makeText(context,getString(R.string.compass_not_found),Toast.LENGTH_SHORT).show();
  }
  return view;
}",0.9351005484460696
8638,"@Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  Utils.setActivityTitleAndSubtitle(getActivity(),getString(R.string.date_converter),""String_Node_Str"");
  View view=inflater.inflate(R.layout.fragment_converter,container,false);
  AppCompatImageView iv=view.findViewById(R.id.calendars_card_icon);
  iv.setImageResource(R.drawable.ic_swap_vertical_circle);
  todayText=view.findViewById(R.id.today);
  todayIcon=view.findViewById(R.id.today_icon);
  todayText.setVisibility(View.GONE);
  todayIcon.setVisibility(View.GONE);
  todayText.setOnClickListener(this);
  todayIcon.setOnClickListener(this);
  calendarTypeSpinner=view.findViewById(R.id.calendarTypeSpinner);
  yearSpinner=view.findViewById(R.id.yearSpinner);
  monthSpinner=view.findViewById(R.id.monthSpinner);
  daySpinner=view.findViewById(R.id.daySpinner);
  weekDayName=view.findViewById(R.id.week_day_name);
  shamsiDateDay=view.findViewById(R.id.shamsi_date_day);
  shamsiDate=view.findViewById(R.id.shamsi_date);
  gregorianDateDay=view.findViewById(R.id.gregorian_date_day);
  gregorianDate=view.findViewById(R.id.gregorian_date);
  islamicDateDay=view.findViewById(R.id.islamic_date_day);
  islamicDate=view.findViewById(R.id.islamic_date);
  calendarsCard=view.findViewById(R.id.calendars_card);
  diffDate=view.findViewById(R.id.diff_date);
  calendarTypeSpinner.setAdapter(new ArrayAdapter<>(getContext(),android.R.layout.simple_spinner_dropdown_item,getResources().getStringArray(R.array.calendar_type)));
  calendarTypeSpinner.setSelection(0);
  startingYearOnYearSpinner=Utils.fillYearMonthDaySpinners(getContext(),calendarTypeSpinner,yearSpinner,monthSpinner,daySpinner);
  calendarTypeSpinner.setOnItemSelectedListener(this);
  yearSpinner.setOnItemSelectedListener(this);
  monthSpinner.setOnItemSelectedListener(this);
  daySpinner.setOnItemSelectedListener(this);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  Utils.setActivityTitleAndSubtitle(getActivity(),getString(R.string.date_converter),""String_Node_Str"");
  View view=inflater.inflate(R.layout.fragment_converter,container,false);
  AppCompatImageView iv=view.findViewById(R.id.calendars_card_icon);
  iv.setImageResource(R.drawable.ic_swap_vertical_circle);
  todayText=view.findViewById(R.id.today);
  todayIcon=view.findViewById(R.id.today_icon);
  todayText.setVisibility(View.GONE);
  todayIcon.setVisibility(View.GONE);
  todayText.setOnClickListener(this);
  todayIcon.setOnClickListener(this);
  calendarTypeSpinner=view.findViewById(R.id.calendarTypeSpinner);
  yearSpinner=view.findViewById(R.id.yearSpinner);
  monthSpinner=view.findViewById(R.id.monthSpinner);
  daySpinner=view.findViewById(R.id.daySpinner);
  weekDayName=view.findViewById(R.id.week_day_name);
  shamsiDateDay=view.findViewById(R.id.shamsi_date_day);
  shamsiDate=view.findViewById(R.id.shamsi_date);
  gregorianDateDay=view.findViewById(R.id.gregorian_date_day);
  gregorianDate=view.findViewById(R.id.gregorian_date);
  islamicDateDay=view.findViewById(R.id.islamic_date_day);
  islamicDate=view.findViewById(R.id.islamic_date);
  shamsiDateDay.setOnClickListener(this);
  shamsiDate.setOnClickListener(this);
  gregorianDateDay.setOnClickListener(this);
  gregorianDate.setOnClickListener(this);
  islamicDateDay.setOnClickListener(this);
  islamicDate.setOnClickListener(this);
  calendarsCard=view.findViewById(R.id.calendars_card);
  diffDate=view.findViewById(R.id.diff_date);
  calendarTypeSpinner.setAdapter(new ArrayAdapter<>(getContext(),android.R.layout.simple_spinner_dropdown_item,getResources().getStringArray(R.array.calendar_type)));
  calendarTypeSpinner.setSelection(0);
  startingYearOnYearSpinner=Utils.fillYearMonthDaySpinners(getContext(),calendarTypeSpinner,yearSpinner,monthSpinner,daySpinner);
  calendarTypeSpinner.setOnItemSelectedListener(this);
  yearSpinner.setOnItemSelectedListener(this);
  monthSpinner.setOnItemSelectedListener(this);
  daySpinner.setOnItemSelectedListener(this);
  return view;
}",0.939181003149988
8639,"public static void update(Context context,boolean updateDate){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Utils.changeAppLanguage(context);
  if (firstTime) {
    Utils.loadLanguageResource(context);
    firstTime=false;
  }
  Calendar calendar=Utils.makeCalendarFromDate(new Date());
  CivilDate civil=new CivilDate(calendar);
  PersianDate persian=Utils.getToday();
  Intent intent=new Intent(context,MainActivity.class);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
  RemoteViews remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
  RemoteViews remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2);
  String colorInt=Utils.getSelectedWidgetTextColor(context);
  int color=Color.parseColor(colorInt);
  ComponentName widget1x1=new ComponentName(context,Widget1x1.class), widget4x1=new ComponentName(context,Widget4x1.class), widget2x2=new ComponentName(context,Widget2x2.class);
  if (manager.getAppWidgetIds(widget1x1).length != 0) {
    remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
    remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
    remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,Utils.formatNumber(persian.getDayOfMonth()));
    remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,Utils.getMonthName(context,persian));
    remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
    manager.updateAppWidget(widget1x1,remoteViews1);
  }
  if (manager.getAppWidgetIds(widget2x2).length != 0 || manager.getAppWidgetIds(widget2x2).length != 0) {
    remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
    remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
    remoteViews4.setTextColor(R.id.textPlaceholder3_4x1,color);
    String text1;
    String text2;
    String text3=""String_Node_Str"";
    String weekDayName=Utils.getWeekDayName(context,civil);
    String persianDate=Utils.dateToString(context,persian);
    String civilDate=Utils.dateToString(context,civil);
    String date=persianDate + Constants.PERSIAN_COMMA + ""String_Node_Str""+ civilDate;
    String time=Utils.getPersianFormattedClock(calendar);
    boolean enableClock=Utils.isWidgetClock(context);
    if (enableClock) {
      text2=weekDayName + ""String_Node_Str"" + date;
      text1=time;
      if (Utils.isIranTime()) {
        text3=""String_Node_Str"" + context.getString(R.string.iran_time) + ""String_Node_Str"";
      }
    }
 else {
      text1=weekDayName;
      text2=date;
    }
    remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,text1);
    remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,text2);
    remoteViews4.setTextViewText(R.id.textPlaceholder3_4x1,text3);
    remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
    manager.updateAppWidget(widget4x1,remoteViews4);
    remoteViews2.setTextColor(R.id.time_2x2,color);
    remoteViews2.setTextColor(R.id.date_2x2,color);
    remoteViews2.setTextColor(R.id.event_2x2,color);
    remoteViews2.setTextColor(R.id.owghat_2x2,color);
    if (enableClock) {
      text2=weekDayName + ""String_Node_Str"" + persianDate;
      text1=time;
    }
 else {
      text1=weekDayName;
      text2=persianDate;
    }
    Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
    String owghat;
    if (pastDate == null || !pastDate.equals(persian) || updateDate) {
      Log.d(""String_Node_Str"",""String_Node_Str"");
      pastDate=persian;
      Utils.loadAlarms(context);
      owghat=Utils.getNextOghatTime(context,currentClock,true);
      String holidays=Utils.getEventsTitle(context,persian,true);
      if (!TextUtils.isEmpty(holidays)) {
        remoteViews2.setTextViewText(R.id.holiday_2x2,holidays);
        remoteViews2.setViewVisibility(R.id.holiday_2x2,View.VISIBLE);
      }
 else {
        remoteViews2.setViewVisibility(R.id.holiday_2x2,View.GONE);
      }
      String events=Utils.getEventsTitle(context,persian,false);
      if (!TextUtils.isEmpty(events)) {
        remoteViews2.setTextViewText(R.id.event_2x2,events);
        remoteViews2.setViewVisibility(R.id.event_2x2,View.VISIBLE);
      }
 else {
        remoteViews2.setViewVisibility(R.id.event_2x2,View.GONE);
      }
    }
 else {
      owghat=Utils.getNextOghatTime(context,currentClock,false);
    }
    if (owghat != null) {
      remoteViews2.setTextViewText(R.id.owghat_2x2,owghat);
      remoteViews2.setViewVisibility(R.id.owghat_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.owghat_2x2,View.GONE);
    }
    remoteViews2.setTextViewText(R.id.time_2x2,text1);
    remoteViews2.setTextViewText(R.id.date_2x2,text2);
    remoteViews2.setOnClickPendingIntent(R.id.widget_layout2x2,launchAppPendingIntent);
    manager.updateAppWidget(widget2x2,remoteViews2);
  }
  String status=Utils.getMonthName(context,persian);
  String title=Utils.getWeekDayName(context,civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ Utils.dateToString(context,persian);
  String body=Utils.dateToString(context,civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ Utils.dateToString(context,DateConverter.civilToIslamic(civil,Utils.getIslamicOffset(context)));
  if (Build.VERSION.SDK_INT > Build.VERSION_CODES.JELLY_BEAN) {
    title=Constants.RLM + title;
    body=Constants.RLM + body;
  }
  int icon=Utils.getDayIconResource(persian.getDayOfMonth());
  ApplicationService applicationService=ApplicationService.getInstance();
  if (applicationService != null && Utils.isNotifyDate(context)) {
    NotificationManager notificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
      int importance=NotificationManager.IMPORTANCE_LOW;
      NotificationChannel mChannel=new NotificationChannel(String.valueOf(NOTIFICATION_ID),context.getString(R.string.app_name),importance);
      mChannel.setShowBadge(false);
      if (notificationManager != null) {
        notificationManager.createNotificationChannel(mChannel);
      }
    }
    NotificationCompat.Builder builder=new NotificationCompat.Builder(context,String.valueOf(NOTIFICATION_ID)).setPriority(NotificationCompat.PRIORITY_LOW).setSmallIcon(icon).setOngoing(true).setWhen(0).setContentIntent(launchAppPendingIntent).setContentText(body).setContentTitle(title).setColor(0xFF607D8B);
    applicationService.startForeground(NOTIFICATION_ID,builder.build());
  }
  mExtensionData=new ExtensionData().visible(true).icon(icon).status(status).expandedTitle(title).expandedBody(body).clickIntent(intent);
}","public static void update(Context context,boolean updateDate){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Utils.changeAppLanguage(context);
  if (firstTime) {
    Utils.loadLanguageResource(context);
    firstTime=false;
  }
  Calendar calendar=Utils.makeCalendarFromDate(new Date());
  CivilDate civil=new CivilDate(calendar);
  PersianDate persian=Utils.getToday();
  Intent intent=new Intent(context,MainActivity.class);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
  RemoteViews remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
  RemoteViews remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2);
  String colorInt=Utils.getSelectedWidgetTextColor(context);
  int color=Color.parseColor(colorInt);
  ComponentName widget1x1=new ComponentName(context,Widget1x1.class), widget4x1=new ComponentName(context,Widget4x1.class), widget2x2=new ComponentName(context,Widget2x2.class);
  if (manager.getAppWidgetIds(widget1x1).length != 0) {
    remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
    remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
    remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,Utils.formatNumber(persian.getDayOfMonth()));
    remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,Utils.getMonthName(context,persian));
    remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
    manager.updateAppWidget(widget1x1,remoteViews1);
  }
  if (manager.getAppWidgetIds(widget4x1).length != 0 || manager.getAppWidgetIds(widget2x2).length != 0) {
    remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
    remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
    remoteViews4.setTextColor(R.id.textPlaceholder3_4x1,color);
    String text1;
    String text2;
    String text3=""String_Node_Str"";
    String weekDayName=Utils.getWeekDayName(context,civil);
    String persianDate=Utils.dateToString(context,persian);
    String civilDate=Utils.dateToString(context,civil);
    String date=persianDate + Constants.PERSIAN_COMMA + ""String_Node_Str""+ civilDate;
    String time=Utils.getPersianFormattedClock(calendar);
    boolean enableClock=Utils.isWidgetClock(context);
    if (enableClock) {
      text2=weekDayName + ""String_Node_Str"" + date;
      text1=time;
      if (Utils.isIranTime()) {
        text3=""String_Node_Str"" + context.getString(R.string.iran_time) + ""String_Node_Str"";
      }
    }
 else {
      text1=weekDayName;
      text2=date;
    }
    remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,text1);
    remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,text2);
    remoteViews4.setTextViewText(R.id.textPlaceholder3_4x1,text3);
    remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
    manager.updateAppWidget(widget4x1,remoteViews4);
    remoteViews2.setTextColor(R.id.time_2x2,color);
    remoteViews2.setTextColor(R.id.date_2x2,color);
    remoteViews2.setTextColor(R.id.event_2x2,color);
    remoteViews2.setTextColor(R.id.owghat_2x2,color);
    if (enableClock) {
      text2=weekDayName + ""String_Node_Str"" + persianDate;
      text1=time;
    }
 else {
      text1=weekDayName;
      text2=persianDate;
    }
    Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
    String owghat;
    if (pastDate == null || !pastDate.equals(persian) || updateDate) {
      Log.d(""String_Node_Str"",""String_Node_Str"");
      pastDate=persian;
      Utils.loadAlarms(context);
      owghat=Utils.getNextOghatTime(context,currentClock,true);
      String holidays=Utils.getEventsTitle(context,persian,true);
      if (!TextUtils.isEmpty(holidays)) {
        remoteViews2.setTextViewText(R.id.holiday_2x2,holidays);
        remoteViews2.setViewVisibility(R.id.holiday_2x2,View.VISIBLE);
      }
 else {
        remoteViews2.setViewVisibility(R.id.holiday_2x2,View.GONE);
      }
      String events=Utils.getEventsTitle(context,persian,false);
      if (!TextUtils.isEmpty(events)) {
        remoteViews2.setTextViewText(R.id.event_2x2,events);
        remoteViews2.setViewVisibility(R.id.event_2x2,View.VISIBLE);
      }
 else {
        remoteViews2.setViewVisibility(R.id.event_2x2,View.GONE);
      }
    }
 else {
      owghat=Utils.getNextOghatTime(context,currentClock,false);
    }
    if (owghat != null) {
      remoteViews2.setTextViewText(R.id.owghat_2x2,owghat);
      remoteViews2.setViewVisibility(R.id.owghat_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.owghat_2x2,View.GONE);
    }
    remoteViews2.setTextViewText(R.id.time_2x2,text1);
    remoteViews2.setTextViewText(R.id.date_2x2,text2);
    remoteViews2.setOnClickPendingIntent(R.id.widget_layout2x2,launchAppPendingIntent);
    manager.updateAppWidget(widget2x2,remoteViews2);
  }
  String status=Utils.getMonthName(context,persian);
  String title=Utils.getWeekDayName(context,civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ Utils.dateToString(context,persian);
  String body=Utils.dateToString(context,civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ Utils.dateToString(context,DateConverter.civilToIslamic(civil,Utils.getIslamicOffset(context)));
  if (Build.VERSION.SDK_INT > Build.VERSION_CODES.JELLY_BEAN) {
    title=Constants.RLM + title;
    body=Constants.RLM + body;
  }
  int icon=Utils.getDayIconResource(persian.getDayOfMonth());
  ApplicationService applicationService=ApplicationService.getInstance();
  if (applicationService != null && Utils.isNotifyDate(context)) {
    NotificationManager notificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
      int importance=NotificationManager.IMPORTANCE_LOW;
      NotificationChannel mChannel=new NotificationChannel(String.valueOf(NOTIFICATION_ID),context.getString(R.string.app_name),importance);
      mChannel.setShowBadge(false);
      if (notificationManager != null) {
        notificationManager.createNotificationChannel(mChannel);
      }
    }
    NotificationCompat.Builder builder=new NotificationCompat.Builder(context,String.valueOf(NOTIFICATION_ID)).setPriority(NotificationCompat.PRIORITY_LOW).setSmallIcon(icon).setOngoing(true).setWhen(0).setContentIntent(launchAppPendingIntent).setContentText(body).setContentTitle(title).setColor(0xFF607D8B);
    applicationService.startForeground(NOTIFICATION_ID,builder.build());
  }
  mExtensionData=new ExtensionData().visible(true).icon(icon).status(status).expandedTitle(title).expandedBody(body).clickIntent(intent);
}",0.9995615957913196
8640,"static public int fillYearMonthDaySpinners(Context context,Spinner calendarTypeSpinner,Spinner yearSpinner,Spinner monthSpinner,Spinner daySpinner){
  AbstractDate date;
  PersianDate newDatePersian=getToday();
  CivilDate newDateCivil=DateConverter.persianToCivil(newDatePersian);
  IslamicDate newDateIslamic=DateConverter.persianToIslamic(newDatePersian);
  date=newDateCivil;
switch (calendarTypeFromPosition(calendarTypeSpinner.getSelectedItemPosition())) {
case GREGORIAN:
    date=newDateCivil;
  break;
case ISLAMIC:
date=newDateIslamic;
break;
case SHAMSI:
date=newDatePersian;
break;
}
String[] years=new String[200];
int startingYearOnYearSpinner=date.getYear() - years.length / 2;
for (int i=0; i < years.length; ++i) {
years[i]=formatNumber(i + startingYearOnYearSpinner);
}
yearSpinner.setAdapter(new ShapedArrayAdapter<>(context,DROPDOWN_LAYOUT,years));
yearSpinner.setSelection(years.length / 2);
String[] months=monthsNamesOfCalendar(context,date);
for (int i=0; i < months.length; ++i) {
months[i]=months[i] + ""String_Node_Str"" + formatNumber(i + 1);
}
monthSpinner.setAdapter(new ShapedArrayAdapter<>(context,DROPDOWN_LAYOUT,months));
monthSpinner.setSelection(date.getMonth() - 1);
String[] days=new String[31];
for (int i=0; i < days.length; ++i) {
days[i]=formatNumber(i + 1);
}
daySpinner.setAdapter(new ShapedArrayAdapter<>(context,DROPDOWN_LAYOUT,days));
daySpinner.setSelection(date.getDayOfMonth() - 1);
return startingYearOnYearSpinner;
}","static public int fillYearMonthDaySpinners(Context context,Spinner calendarTypeSpinner,Spinner yearSpinner,Spinner monthSpinner,Spinner daySpinner){
  AbstractDate date;
  PersianDate newDatePersian=getToday();
  CivilDate newDateCivil=DateConverter.persianToCivil(newDatePersian);
  IslamicDate newDateIslamic=DateConverter.persianToIslamic(newDatePersian);
  date=newDateCivil;
switch (calendarTypeFromPosition(calendarTypeSpinner.getSelectedItemPosition())) {
case GREGORIAN:
    date=newDateCivil;
  break;
case ISLAMIC:
date=newDateIslamic;
break;
case SHAMSI:
date=newDatePersian;
break;
}
String[] years=new String[200];
int startingYearOnYearSpinner=date.getYear() - years.length / 2;
for (int i=0; i < years.length; ++i) {
years[i]=formatNumber(i + startingYearOnYearSpinner);
}
yearSpinner.setAdapter(new ShapedArrayAdapter<>(context,DROPDOWN_LAYOUT,years));
yearSpinner.setSelection(years.length / 2);
String[] months=monthsNamesOfCalendar(context,date).clone();
for (int i=0; i < months.length; ++i) {
months[i]=months[i] + ""String_Node_Str"" + formatNumber(i + 1);
}
monthSpinner.setAdapter(new ShapedArrayAdapter<>(context,DROPDOWN_LAYOUT,months));
monthSpinner.setSelection(date.getMonth() - 1);
String[] days=new String[31];
for (int i=0; i < days.length; ++i) {
days[i]=formatNumber(i + 1);
}
daySpinner.setAdapter(new ShapedArrayAdapter<>(context,DROPDOWN_LAYOUT,days));
daySpinner.setSelection(date.getDayOfMonth() - 1);
return startingYearOnYearSpinner;
}",0.997278911564626
8641,"@Override protected void onCreate(Bundle savedInstanceState){
  Utils.setTheme(getApplicationContext());
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  Utils.updateStoredPreference(this);
  Utils.changeAppLanguage(this);
  Utils.loadLanguageResource(this);
  lastLocale=Utils.getAppLanguage();
  lastTheme=Utils.getTheme(this);
  TypeFaceUtil.overrideFont(getApplicationContext(),""String_Node_Str"",""String_Node_Str"");
  if (!Utils.isServiceRunning(this,ApplicationService.class)) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)     startForegroundService(new Intent(this,ApplicationService.class));
    startService(new Intent(this,ApplicationService.class));
  }
  UpdateUtils.update(getApplicationContext(),true);
  setContentView(R.layout.activity_main);
  Toolbar toolbar=findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    Window w=getWindow();
    w.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
  }
 else {
    toolbar.setPadding(0,0,0,0);
  }
  RecyclerView navigation=findViewById(R.id.navigation_view);
  navigation.setHasFixedSize(true);
  adapter=new DrawerAdapter(this);
  navigation.setAdapter(adapter);
  RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
  navigation.setLayoutManager(layoutManager);
  drawerLayout=findViewById(R.id.drawer);
  final View appMainView=findViewById(R.id.app_main_layout);
  ActionBarDrawerToggle drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer,R.string.closeDrawer){
    int slidingDirection=+1;
{
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        if (isRTL())         slidingDirection=-1;
      }
    }
    @Override public void onDrawerSlide(    View drawerView,    float slideOffset){
      super.onDrawerSlide(drawerView,slideOffset);
      slidingAnimation(drawerView,slideOffset);
    }
    private void slidingAnimation(    View drawerView,    float slideOffset){
      appMainView.setTranslationX(slideOffset * drawerView.getWidth() * slidingDirection);
      drawerLayout.bringChildToFront(drawerView);
      drawerLayout.requestLayout();
    }
  }
;
  drawerLayout.addDrawerListener(drawerToggle);
  drawerToggle.syncState();
  String action=getIntent() != null ? getIntent().getAction() : null;
  if (""String_Node_Str"".equals(action)) {
    selectItem(COMPASS);
  }
 else   if (""String_Node_Str"".equals(action)) {
    selectItem(PREFERENCE);
  }
 else   if (""String_Node_Str"".equals(action)) {
    selectItem(CONVERTER);
  }
 else {
    selectItem(DEFAULT);
  }
  LocalBroadcastManager.getInstance(this).registerReceiver(dayPassedReceiver,new IntentFilter(Constants.LOCAL_INTENT_DAY_PASSED));
}","@Override protected void onCreate(Bundle savedInstanceState){
switch (Utils.getTheme(this)) {
case DARK_THEME:
    setTheme(R.style.DarkTheme);
case LIGHT_THEME:
default :
  setTheme(R.style.LightTheme);
}
requestWindowFeature(Window.FEATURE_NO_TITLE);
super.onCreate(savedInstanceState);
Utils.updateStoredPreference(this);
Utils.changeAppLanguage(this);
Utils.loadLanguageResource(this);
lastLocale=Utils.getAppLanguage();
lastTheme=Utils.getTheme(this);
TypeFaceUtil.overrideFont(getApplicationContext(),""String_Node_Str"",""String_Node_Str"");
if (!Utils.isServiceRunning(this,ApplicationService.class)) {
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) startForegroundService(new Intent(this,ApplicationService.class));
startService(new Intent(this,ApplicationService.class));
}
UpdateUtils.update(getApplicationContext(),true);
setContentView(R.layout.activity_main);
Toolbar toolbar=findViewById(R.id.toolbar);
setSupportActionBar(toolbar);
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
Window w=getWindow();
w.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
}
 else {
toolbar.setPadding(0,0,0,0);
}
RecyclerView navigation=findViewById(R.id.navigation_view);
navigation.setHasFixedSize(true);
adapter=new DrawerAdapter(this);
navigation.setAdapter(adapter);
RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
navigation.setLayoutManager(layoutManager);
drawerLayout=findViewById(R.id.drawer);
final View appMainView=findViewById(R.id.app_main_layout);
ActionBarDrawerToggle drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer,R.string.closeDrawer){
int slidingDirection=+1;
{
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
    if (isRTL())     slidingDirection=-1;
  }
}
@Override public void onDrawerSlide(View drawerView,float slideOffset){
  super.onDrawerSlide(drawerView,slideOffset);
  slidingAnimation(drawerView,slideOffset);
}
private void slidingAnimation(View drawerView,float slideOffset){
  appMainView.setTranslationX(slideOffset * drawerView.getWidth() * slidingDirection);
  drawerLayout.bringChildToFront(drawerView);
  drawerLayout.requestLayout();
}
}
;
drawerLayout.addDrawerListener(drawerToggle);
drawerToggle.syncState();
String action=getIntent() != null ? getIntent().getAction() : null;
if (""String_Node_Str"".equals(action)) {
selectItem(COMPASS);
}
 else if (""String_Node_Str"".equals(action)) {
selectItem(PREFERENCE);
}
 else if (""String_Node_Str"".equals(action)) {
selectItem(CONVERTER);
}
 else {
selectItem(DEFAULT);
}
LocalBroadcastManager.getInstance(this).registerReceiver(dayPassedReceiver,new IntentFilter(Constants.LOCAL_INTENT_DAY_PASSED));
}",0.9371080451531985
8642,"@Override public void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  Utils.changeAppLanguage(this);
  View v=findViewById(R.id.drawer);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
    v.setLayoutDirection(isRTL() ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR);
  }
}","@Override public void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  Utils.updateStoredPreference(this);
  Utils.changeAppLanguage(this);
  UpdateUtils.update(getApplicationContext(),true);
  View v=findViewById(R.id.drawer);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
    v.setLayoutDirection(isRTL() ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR);
  }
}",0.8854961832061069
8643,"public static void update(Context context,boolean updateDate){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Calendar calendar=Utils.makeCalendarFromDate(new Date());
  CivilDate civil=new CivilDate(calendar);
  PersianDate persian=Utils.getToday();
  Intent intent=new Intent(context,MainActivity.class);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
  RemoteViews remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
  RemoteViews remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2);
  String colorInt=Utils.getSelectedWidgetTextColor();
  int color=Color.parseColor(colorInt);
  ComponentName widget1x1=new ComponentName(context,Widget1x1.class), widget4x1=new ComponentName(context,Widget4x1.class), widget2x2=new ComponentName(context,Widget2x2.class);
  if (manager.getAppWidgetIds(widget1x1).length != 0) {
    remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
    remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
    remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,Utils.formatNumber(persian.getDayOfMonth()));
    remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,Utils.getMonthName(persian));
    remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
    manager.updateAppWidget(widget1x1,remoteViews1);
  }
  if (pastDate == null || !pastDate.equals(persian) || updateDate) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    pastDate=persian;
    Utils.initUtils(context);
    updateDate=true;
  }
  if (manager.getAppWidgetIds(widget4x1).length != 0 || manager.getAppWidgetIds(widget2x2).length != 0) {
    remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
    remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
    remoteViews4.setTextColor(R.id.textPlaceholder3_4x1,color);
    String text1;
    String text2;
    String text3=""String_Node_Str"";
    String weekDayName=Utils.getWeekDayName(civil);
    String persianDate=Utils.dateToString(context,persian);
    String civilDate=Utils.dateToString(context,civil);
    String date=persianDate + Constants.PERSIAN_COMMA + ""String_Node_Str""+ civilDate;
    String time=Utils.getPersianFormattedClock(calendar);
    boolean enableClock=Utils.isWidgetClock();
    if (enableClock) {
      text2=weekDayName + ""String_Node_Str"" + date;
      text1=time;
      if (Utils.isIranTime()) {
        text3=""String_Node_Str"" + context.getString(R.string.iran_time) + ""String_Node_Str"";
      }
    }
 else {
      text1=weekDayName;
      text2=date;
    }
    remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,text1);
    remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,text2);
    remoteViews4.setTextViewText(R.id.textPlaceholder3_4x1,text3);
    remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
    manager.updateAppWidget(widget4x1,remoteViews4);
    remoteViews2.setTextColor(R.id.time_2x2,color);
    remoteViews2.setTextColor(R.id.date_2x2,color);
    remoteViews2.setTextColor(R.id.event_2x2,color);
    remoteViews2.setTextColor(R.id.owghat_2x2,color);
    if (enableClock) {
      text2=weekDayName + ""String_Node_Str"" + persianDate;
      text1=time;
    }
 else {
      text1=weekDayName;
      text2=persianDate;
    }
    Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
    String owghat;
    if (updateDate) {
      owghat=Utils.getNextOghatTime(context,currentClock,true);
      String holidays=Utils.getEventsTitle(context,persian,true);
      if (!TextUtils.isEmpty(holidays)) {
        remoteViews2.setTextViewText(R.id.holiday_2x2,holidays);
        remoteViews2.setViewVisibility(R.id.holiday_2x2,View.VISIBLE);
      }
 else {
        remoteViews2.setViewVisibility(R.id.holiday_2x2,View.GONE);
      }
      String events=Utils.getEventsTitle(context,persian,false);
      if (!TextUtils.isEmpty(events)) {
        remoteViews2.setTextViewText(R.id.event_2x2,events);
        remoteViews2.setViewVisibility(R.id.event_2x2,View.VISIBLE);
      }
 else {
        remoteViews2.setViewVisibility(R.id.event_2x2,View.GONE);
      }
    }
 else {
      owghat=Utils.getNextOghatTime(context,currentClock,false);
    }
    if (owghat != null) {
      remoteViews2.setTextViewText(R.id.owghat_2x2,owghat);
      remoteViews2.setViewVisibility(R.id.owghat_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.owghat_2x2,View.GONE);
    }
    remoteViews2.setTextViewText(R.id.time_2x2,text1);
    remoteViews2.setTextViewText(R.id.date_2x2,text2);
    remoteViews2.setOnClickPendingIntent(R.id.widget_layout2x2,launchAppPendingIntent);
    manager.updateAppWidget(widget2x2,remoteViews2);
  }
  String status=Utils.getMonthName(persian);
  String title=Utils.getWeekDayName(civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ Utils.dateToString(context,persian);
  String body=Utils.dateToString(context,civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ Utils.dateToString(context,DateConverter.civilToIslamic(civil,Utils.getIslamicOffset()));
  if (Build.VERSION.SDK_INT > Build.VERSION_CODES.JELLY_BEAN) {
    title=Constants.RLM + title;
    body=Constants.RLM + body;
  }
  int icon=Utils.getDayIconResource(persian.getDayOfMonth());
  ApplicationService applicationService=ApplicationService.getInstance();
  if (applicationService != null && Utils.isNotifyDate()) {
    NotificationManager notificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
      int importance=NotificationManager.IMPORTANCE_LOW;
      NotificationChannel mChannel=new NotificationChannel(String.valueOf(NOTIFICATION_ID),context.getString(R.string.app_name),importance);
      mChannel.setShowBadge(false);
      if (notificationManager != null) {
        notificationManager.createNotificationChannel(mChannel);
      }
    }
    NotificationCompat.Builder builder=new NotificationCompat.Builder(context,String.valueOf(NOTIFICATION_ID)).setPriority(NotificationCompat.PRIORITY_LOW).setSmallIcon(icon).setOngoing(true).setWhen(0).setContentIntent(launchAppPendingIntent).setContentText(body).setContentTitle(title).setVisibility(Utils.isNotifyDateOnLockScreen() ? NotificationCompat.VISIBILITY_PUBLIC : NotificationCompat.VISIBILITY_SECRET).setColor(0xFF607D8B);
    applicationService.startForeground(NOTIFICATION_ID,builder.build());
  }
  mExtensionData=new ExtensionData().visible(true).icon(icon).status(status).expandedTitle(title).expandedBody(body).clickIntent(intent);
}","public static void update(Context context,boolean updateDate){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Utils.changeAppLanguage(context);
  Calendar calendar=Utils.makeCalendarFromDate(new Date());
  CivilDate civil=new CivilDate(calendar);
  PersianDate persian=Utils.getToday();
  Intent intent=new Intent(context,MainActivity.class);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
  RemoteViews remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
  RemoteViews remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2);
  String colorInt=Utils.getSelectedWidgetTextColor();
  int color=Color.parseColor(colorInt);
  ComponentName widget1x1=new ComponentName(context,Widget1x1.class), widget4x1=new ComponentName(context,Widget4x1.class), widget2x2=new ComponentName(context,Widget2x2.class);
  if (manager.getAppWidgetIds(widget1x1).length != 0) {
    remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
    remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
    remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,Utils.formatNumber(persian.getDayOfMonth()));
    remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,Utils.getMonthName(persian));
    remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
    manager.updateAppWidget(widget1x1,remoteViews1);
  }
  if (pastDate == null || !pastDate.equals(persian) || updateDate) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    pastDate=persian;
    Utils.initUtils(context);
    updateDate=true;
  }
  if (manager.getAppWidgetIds(widget4x1).length != 0 || manager.getAppWidgetIds(widget2x2).length != 0) {
    remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
    remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
    remoteViews4.setTextColor(R.id.textPlaceholder3_4x1,color);
    String text1;
    String text2;
    String text3=""String_Node_Str"";
    String weekDayName=Utils.getWeekDayName(civil);
    String persianDate=Utils.dateToString(context,persian);
    String civilDate=Utils.dateToString(context,civil);
    String date=persianDate + Constants.PERSIAN_COMMA + ""String_Node_Str""+ civilDate;
    String time=Utils.getPersianFormattedClock(calendar);
    boolean enableClock=Utils.isWidgetClock();
    if (enableClock) {
      text2=weekDayName + ""String_Node_Str"" + date;
      text1=time;
      if (Utils.isIranTime()) {
        text3=""String_Node_Str"" + context.getString(R.string.iran_time) + ""String_Node_Str"";
      }
    }
 else {
      text1=weekDayName;
      text2=date;
    }
    remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,text1);
    remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,text2);
    remoteViews4.setTextViewText(R.id.textPlaceholder3_4x1,text3);
    remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
    manager.updateAppWidget(widget4x1,remoteViews4);
    remoteViews2.setTextColor(R.id.time_2x2,color);
    remoteViews2.setTextColor(R.id.date_2x2,color);
    remoteViews2.setTextColor(R.id.event_2x2,color);
    remoteViews2.setTextColor(R.id.owghat_2x2,color);
    if (enableClock) {
      text2=weekDayName + ""String_Node_Str"" + persianDate;
      text1=time;
    }
 else {
      text1=weekDayName;
      text2=persianDate;
    }
    Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
    String owghat;
    if (updateDate) {
      owghat=Utils.getNextOghatTime(context,currentClock,true);
      String holidays=Utils.getEventsTitle(context,persian,true);
      if (!TextUtils.isEmpty(holidays)) {
        remoteViews2.setTextViewText(R.id.holiday_2x2,holidays);
        remoteViews2.setViewVisibility(R.id.holiday_2x2,View.VISIBLE);
      }
 else {
        remoteViews2.setViewVisibility(R.id.holiday_2x2,View.GONE);
      }
      String events=Utils.getEventsTitle(context,persian,false);
      if (!TextUtils.isEmpty(events)) {
        remoteViews2.setTextViewText(R.id.event_2x2,events);
        remoteViews2.setViewVisibility(R.id.event_2x2,View.VISIBLE);
      }
 else {
        remoteViews2.setViewVisibility(R.id.event_2x2,View.GONE);
      }
    }
 else {
      owghat=Utils.getNextOghatTime(context,currentClock,false);
    }
    if (owghat != null) {
      remoteViews2.setTextViewText(R.id.owghat_2x2,owghat);
      remoteViews2.setViewVisibility(R.id.owghat_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.owghat_2x2,View.GONE);
    }
    remoteViews2.setTextViewText(R.id.time_2x2,text1);
    remoteViews2.setTextViewText(R.id.date_2x2,text2);
    remoteViews2.setOnClickPendingIntent(R.id.widget_layout2x2,launchAppPendingIntent);
    manager.updateAppWidget(widget2x2,remoteViews2);
  }
  String status=Utils.getMonthName(persian);
  String title=Utils.getWeekDayName(civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ Utils.dateToString(context,persian);
  String body=Utils.dateToString(context,civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ Utils.dateToString(context,DateConverter.civilToIslamic(civil,Utils.getIslamicOffset()));
  if ((Build.VERSION.SDK_INT > Build.VERSION_CODES.JELLY_BEAN) && (Build.VERSION.SDK_INT < Build.VERSION_CODES.N)) {
    title=Constants.RLM + title;
    body=Constants.RLM + body;
  }
  int icon=Utils.getDayIconResource(persian.getDayOfMonth());
  ApplicationService applicationService=ApplicationService.getInstance();
  if (applicationService != null && Utils.isNotifyDate()) {
    NotificationManager notificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
      int importance=NotificationManager.IMPORTANCE_LOW;
      NotificationChannel mChannel=new NotificationChannel(String.valueOf(NOTIFICATION_ID),context.getString(R.string.app_name),importance);
      mChannel.setShowBadge(false);
      if (notificationManager != null) {
        notificationManager.createNotificationChannel(mChannel);
      }
    }
    NotificationCompat.Builder builder=new NotificationCompat.Builder(context,String.valueOf(NOTIFICATION_ID)).setPriority(NotificationCompat.PRIORITY_LOW).setSmallIcon(icon).setOngoing(true).setWhen(0).setContentIntent(launchAppPendingIntent).setContentText(body).setContentTitle(title).setVisibility(Utils.isNotifyDateOnLockScreen() ? NotificationCompat.VISIBILITY_PUBLIC : NotificationCompat.VISIBILITY_SECRET).setColor(0xFF607D8B);
    applicationService.startForeground(NOTIFICATION_ID,builder.build());
  }
  mExtensionData=new ExtensionData().visible(true).icon(icon).status(status).expandedTitle(title).expandedBody(body).clickIntent(intent);
}",0.9935230332581326
8644,"static private void changeAppLanguage(Context context){
  String localeCode=language.replaceAll(""String_Node_Str"",""String_Node_Str"");
  Locale locale=new Locale(localeCode);
  Locale.setDefault(locale);
  Resources resources=context.getResources();
  Configuration config=resources.getConfiguration();
  config.locale=locale;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
    config.setLayoutDirection(config.locale);
  }
  resources.updateConfiguration(config,resources.getDisplayMetrics());
}","static public void changeAppLanguage(Context context){
  String localeCode=language.replaceAll(""String_Node_Str"",""String_Node_Str"");
  Locale locale=new Locale(localeCode);
  Locale.setDefault(locale);
  Resources resources=context.getResources();
  Configuration config=resources.getConfiguration();
  config.locale=locale;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
    config.setLayoutDirection(config.locale);
  }
  resources.updateConfiguration(config,resources.getDisplayMetrics());
}",0.989351403678606
8645,"@Override protected void onCreate(Bundle savedInstanceState){
  setTheme(Utils.getTheme(this).equals(DARK_THEME) ? R.style.DarkTheme : R.style.LightTheme);
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  lastLocale=Utils.getAppLanguage();
  lastTheme=Utils.getTheme(this);
  TypeFaceUtil.overrideFont(getApplicationContext(),""String_Node_Str"",""String_Node_Str"");
  if (!Utils.isServiceRunning(this,ApplicationService.class)) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)     startForegroundService(new Intent(this,ApplicationService.class));
    startService(new Intent(this,ApplicationService.class));
  }
  UpdateUtils.update(getApplicationContext(),true);
  setContentView(R.layout.activity_main);
  Toolbar toolbar=findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    Window w=getWindow();
    w.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
  }
 else {
    toolbar.setPadding(0,0,0,0);
  }
  RecyclerView navigation=findViewById(R.id.navigation_view);
  navigation.setHasFixedSize(true);
  adapter=new DrawerAdapter(this);
  navigation.setAdapter(adapter);
  RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
  navigation.setLayoutManager(layoutManager);
  drawerLayout=findViewById(R.id.drawer);
  final View appMainView=findViewById(R.id.app_main_layout);
  ActionBarDrawerToggle drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer,R.string.closeDrawer){
    int slidingDirection=+1;
{
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        if (isRTL())         slidingDirection=-1;
      }
    }
    @Override public void onDrawerSlide(    View drawerView,    float slideOffset){
      super.onDrawerSlide(drawerView,slideOffset);
      slidingAnimation(drawerView,slideOffset);
    }
    private void slidingAnimation(    View drawerView,    float slideOffset){
      appMainView.setTranslationX(slideOffset * drawerView.getWidth() * slidingDirection);
      drawerLayout.bringChildToFront(drawerView);
      drawerLayout.requestLayout();
    }
  }
;
  drawerLayout.addDrawerListener(drawerToggle);
  drawerToggle.syncState();
  String action=getIntent() != null ? getIntent().getAction() : null;
  if (""String_Node_Str"".equals(action)) {
    selectItem(COMPASS);
  }
 else   if (""String_Node_Str"".equals(action)) {
    selectItem(PREFERENCE);
  }
 else   if (""String_Node_Str"".equals(action)) {
    selectItem(CONVERTER);
  }
 else {
    selectItem(DEFAULT);
  }
  LocalBroadcastManager.getInstance(this).registerReceiver(dayPassedReceiver,new IntentFilter(Constants.LOCAL_INTENT_DAY_PASSED));
}","@Override protected void onCreate(Bundle savedInstanceState){
  setTheme(Utils.getTheme(this).equals(DARK_THEME) ? R.style.DarkTheme : R.style.LightTheme);
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  Utils.initUtils(this);
  lastLocale=Utils.getAppLanguage();
  lastTheme=Utils.getTheme(this);
  TypeFaceUtil.overrideFont(getApplicationContext(),""String_Node_Str"",""String_Node_Str"");
  if (!Utils.isServiceRunning(this,ApplicationService.class)) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)     startForegroundService(new Intent(this,ApplicationService.class));
    startService(new Intent(this,ApplicationService.class));
  }
  UpdateUtils.update(getApplicationContext(),true);
  setContentView(R.layout.activity_main);
  Toolbar toolbar=findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    Window w=getWindow();
    w.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
  }
 else {
    toolbar.setPadding(0,0,0,0);
  }
  RecyclerView navigation=findViewById(R.id.navigation_view);
  navigation.setHasFixedSize(true);
  adapter=new DrawerAdapter(this);
  navigation.setAdapter(adapter);
  RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
  navigation.setLayoutManager(layoutManager);
  drawerLayout=findViewById(R.id.drawer);
  final View appMainView=findViewById(R.id.app_main_layout);
  ActionBarDrawerToggle drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer,R.string.closeDrawer){
    int slidingDirection=+1;
{
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        if (isRTL())         slidingDirection=-1;
      }
    }
    @Override public void onDrawerSlide(    View drawerView,    float slideOffset){
      super.onDrawerSlide(drawerView,slideOffset);
      slidingAnimation(drawerView,slideOffset);
    }
    private void slidingAnimation(    View drawerView,    float slideOffset){
      appMainView.setTranslationX(slideOffset * drawerView.getWidth() * slidingDirection);
      drawerLayout.bringChildToFront(drawerView);
      drawerLayout.requestLayout();
    }
  }
;
  drawerLayout.addDrawerListener(drawerToggle);
  drawerToggle.syncState();
  String action=getIntent() != null ? getIntent().getAction() : null;
  if (""String_Node_Str"".equals(action)) {
    selectItem(COMPASS);
  }
 else   if (""String_Node_Str"".equals(action)) {
    selectItem(PREFERENCE);
  }
 else   if (""String_Node_Str"".equals(action)) {
    selectItem(CONVERTER);
  }
 else {
    selectItem(DEFAULT);
  }
  LocalBroadcastManager.getInstance(this).registerReceiver(dayPassedReceiver,new IntentFilter(Constants.LOCAL_INTENT_DAY_PASSED));
}",0.9955237242614146
8646,"private void beforeMenuChange(int position){
  if (menuPosition != PREFERENCE)   return;
  Utils.initUtils(this);
  UpdateUtils.update(getApplicationContext(),true);
  boolean needsActivityRestart=false;
  String locale=Utils.getAppLanguage();
  if (!locale.equals(lastLocale)) {
    lastLocale=locale;
    Utils.initUtils(this);
    needsActivityRestart=true;
  }
  if (!lastTheme.equals(Utils.getTheme(this))) {
    needsActivityRestart=true;
    lastTheme=Utils.getTheme(this);
  }
  if (needsActivityRestart)   restartActivity();
}","private void beforeMenuChange(int position){
  if (menuPosition != PREFERENCE)   return;
  Utils.initUtils(this);
  UpdateUtils.update(getApplicationContext(),true);
  boolean needsActivityRestart=false;
  String locale=Utils.getAppLanguage();
  if (!locale.equals(lastLocale)) {
    lastLocale=locale;
    needsActivityRestart=true;
  }
  if (!lastTheme.equals(Utils.getTheme(this))) {
    needsActivityRestart=true;
    lastTheme=Utils.getTheme(this);
  }
  if (needsActivityRestart)   restartActivity();
}",0.9741131351869609
8647,"@Override public void onClick(View v){
switch (v.getId()) {
case R.id.owghat:
    if (sunriseLayout.getVisibility() == View.VISIBLE) {
      sunriseLayout.setVisibility(View.GONE);
      dhuhrLayout.setVisibility(View.GONE);
      asrLayout.setVisibility(View.GONE);
      sunsetLayout.setVisibility(View.GONE);
      maghribLayout.setVisibility(View.GONE);
      ishaLayout.setVisibility(View.GONE);
      midnightLayout.setVisibility(View.GONE);
      moreOwghat.setImageResource(R.drawable.ic_keyboard_arrow_down);
    }
 else {
      imsakLayout.setVisibility(View.VISIBLE);
      fajrLayout.setVisibility(View.VISIBLE);
      sunriseLayout.setVisibility(View.VISIBLE);
      dhuhrLayout.setVisibility(View.VISIBLE);
      asrLayout.setVisibility(View.VISIBLE);
      sunsetLayout.setVisibility(View.VISIBLE);
      maghribLayout.setVisibility(View.VISIBLE);
      ishaLayout.setVisibility(View.VISIBLE);
      midnightLayout.setVisibility(View.VISIBLE);
      moreOwghat.setImageResource(R.drawable.ic_keyboard_arrow_up);
    }
  break;
case R.id.today:
case R.id.today_icon:
bringTodayYearMonth();
break;
case R.id.shamsi_date:
case R.id.shamsi_date_day:
Utils.copyToClipboard(getContext(),shamsiDateDay.getText() + ""String_Node_Str"" + shamsiDate.getText().toString().replace(""String_Node_Str"",""String_Node_Str""));
break;
case R.id.gregorian_date:
case R.id.gregorian_date_day:
Utils.copyToClipboard(getContext(),gregorianDate.getText() + ""String_Node_Str"" + gregorianDateDay.getText().toString().replace(""String_Node_Str"",""String_Node_Str""));
break;
case R.id.islamic_date:
case R.id.islamic_date_day:
Utils.copyToClipboard(getContext(),islamicDateDay.getText() + ""String_Node_Str"" + islamicDate.getText().toString().replace(""String_Node_Str"",""String_Node_Str""));
break;
}
}","@Override public void onClick(View v){
switch (v.getId()) {
case R.id.owghat:
    if (sunriseLayout.getVisibility() == View.VISIBLE) {
      sunriseLayout.setVisibility(View.GONE);
      dhuhrLayout.setVisibility(View.GONE);
      asrLayout.setVisibility(View.GONE);
      sunsetLayout.setVisibility(View.GONE);
      maghribLayout.setVisibility(View.GONE);
      ishaLayout.setVisibility(View.GONE);
      midnightLayout.setVisibility(View.GONE);
      moreOwghat.setImageResource(R.drawable.ic_keyboard_arrow_down);
    }
 else {
      imsakLayout.setVisibility(View.VISIBLE);
      fajrLayout.setVisibility(View.VISIBLE);
      sunriseLayout.setVisibility(View.VISIBLE);
      dhuhrLayout.setVisibility(View.VISIBLE);
      asrLayout.setVisibility(View.VISIBLE);
      sunsetLayout.setVisibility(View.VISIBLE);
      maghribLayout.setVisibility(View.VISIBLE);
      ishaLayout.setVisibility(View.VISIBLE);
      midnightLayout.setVisibility(View.VISIBLE);
      moreOwghat.setImageResource(R.drawable.ic_keyboard_arrow_up);
    }
  break;
case R.id.today:
case R.id.today_icon:
bringTodayYearMonth();
break;
case R.id.shamsi_date:
case R.id.shamsi_date_day:
Utils.copyToClipboard(getContext(),shamsiDateDay.getText() + ""String_Node_Str"" + shamsiDate.getText().toString().replace(""String_Node_Str"",""String_Node_Str""));
break;
case R.id.gregorian_date:
case R.id.gregorian_date_day:
Utils.copyToClipboard(getContext(),gregorianDateDay.getText() + ""String_Node_Str"" + gregorianDate.getText().toString().replace(""String_Node_Str"",""String_Node_Str""));
break;
case R.id.islamic_date:
case R.id.islamic_date_day:
Utils.copyToClipboard(getContext(),islamicDateDay.getText() + ""String_Node_Str"" + islamicDate.getText().toString().replace(""String_Node_Str"",""String_Node_Str""));
break;
}
}",0.9983155530600786
8648,"public Set<String> commaSeparatedToSet(String commaSeparated){
  Set<String> result=new HashSet<>();
  result.addAll(Arrays.asList(TextUtils.split(commaSeparated,""String_Node_Str"")));
  return result;
}","public Set<String> commaSeparatedToSet(String commaSeparated){
  return new HashSet<>(Arrays.asList(TextUtils.split(commaSeparated,""String_Node_Str"")));
}",0.8539325842696629
8649,"public void update(boolean updateDate){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Utils utils=Utils.getInstance(context);
  utils.changeAppLanguage(context);
  if (firstTime) {
    utils.loadLanguageResource();
    firstTime=false;
  }
  Calendar calendar=utils.makeCalendarFromDate(new Date());
  CivilDate civil=new CivilDate(calendar);
  PersianDate persian=utils.getToday();
  Intent intent=new Intent(context,MainActivity.class);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
  RemoteViews remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
  RemoteViews remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2);
  String colorInt=utils.getSelectedWidgetTextColor();
  int color=Color.parseColor(colorInt);
  remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
  remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
  remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,utils.formatNumber(persian.getDayOfMonth()));
  remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,utils.shape(utils.getMonthName(persian)));
  remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget1x1.class),remoteViews1);
  remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
  remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
  remoteViews4.setTextColor(R.id.textPlaceholder3_4x1,color);
  String text1;
  String text2;
  String text3=""String_Node_Str"";
  String weekDayName=utils.getWeekDayName(civil);
  String persianDate=utils.dateToString(persian);
  String civilDate=utils.dateToString(civil);
  String date=persianDate + Constants.PERSIAN_COMMA + ""String_Node_Str""+ civilDate;
  String time=utils.getPersianFormattedClock(calendar);
  boolean enableClock=utils.isWidgetClock();
  if (enableClock) {
    text2=weekDayName + ""String_Node_Str"" + date;
    text1=time;
    if (utils.iranTime) {
      text3=""String_Node_Str"" + context.getString(R.string.iran_time) + ""String_Node_Str"";
    }
  }
 else {
    text1=weekDayName;
    text2=date;
  }
  remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,utils.shape(text1));
  remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,utils.shape(text2));
  remoteViews4.setTextViewText(R.id.textPlaceholder3_4x1,utils.shape(text3));
  remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget4x1.class),remoteViews4);
  remoteViews2.setTextColor(R.id.time_2x2,color);
  remoteViews2.setTextColor(R.id.date_2x2,color);
  remoteViews2.setTextColor(R.id.event_2x2,color);
  remoteViews2.setTextColor(R.id.owghat_2x2,color);
  if (enableClock) {
    text2=weekDayName + ""String_Node_Str"" + persianDate;
    text1=time;
  }
 else {
    text1=weekDayName;
    text2=persianDate;
  }
  Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
  String owghat;
  if (pastDate == null || !pastDate.equals(persian) || updateDate) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    pastDate=persian;
    utils.loadAlarms();
    owghat=utils.getNextOghatTime(currentClock,true);
    String holidays=utils.getEventsTitle(persian,true);
    if (!TextUtils.isEmpty(holidays)) {
      remoteViews2.setTextViewText(R.id.holiday_2x2,utils.shape(holidays));
      remoteViews2.setViewVisibility(R.id.holiday_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.holiday_2x2,View.GONE);
    }
    String events=utils.getEventsTitle(persian,false);
    if (!TextUtils.isEmpty(events)) {
      remoteViews2.setTextViewText(R.id.event_2x2,utils.shape(events));
      remoteViews2.setViewVisibility(R.id.event_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.event_2x2,View.GONE);
    }
  }
 else {
    owghat=utils.getNextOghatTime(currentClock,false);
  }
  if (owghat != null) {
    remoteViews2.setTextViewText(R.id.owghat_2x2,utils.shape(owghat));
    remoteViews2.setViewVisibility(R.id.owghat_2x2,View.VISIBLE);
  }
 else {
    remoteViews2.setViewVisibility(R.id.owghat_2x2,View.GONE);
  }
  remoteViews2.setTextViewText(R.id.time_2x2,utils.shape(text1));
  remoteViews2.setTextViewText(R.id.date_2x2,utils.shape(text2));
  remoteViews2.setOnClickPendingIntent(R.id.widget_layout2x2,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget2x2.class),remoteViews2);
  String status=utils.getMonthName(persian);
  String title=utils.getWeekDayName(civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ utils.dateToString(persian);
  String body=utils.dateToString(civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ utils.dateToString(DateConverter.civilToIslamic(civil,utils.getIslamicOffset()));
  if (Build.VERSION.SDK_INT > Build.VERSION_CODES.JELLY_BEAN) {
    title=Constants.RLM + title;
    body=Constants.RLM + body;
  }
  int icon=utils.getDayIconResource(persian.getDayOfMonth());
  if (mNotificationManager == null) {
    mNotificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  }
  if (utils.isNotifyDate()) {
    int priority=Build.VERSION.SDK_INT > Build.VERSION_CODES.M ? NotificationCompat.PRIORITY_DEFAULT : NotificationCompat.PRIORITY_LOW;
    mNotificationManager.notify(NOTIFICATION_ID,new NotificationCompat.Builder(context).setPriority(priority).setOngoing(true).setSmallIcon(icon).setWhen(0).setContentIntent(launchAppPendingIntent).setContentText(utils.shape(body)).setContentTitle(utils.shape(title)).setColor(0xFF607D8B).build());
  }
 else {
    mNotificationManager.cancel(NOTIFICATION_ID);
  }
  mExtensionData=new ExtensionData().visible(true).icon(icon).status(utils.shape(status)).expandedTitle(utils.shape(title)).expandedBody(utils.shape(body)).clickIntent(intent);
}","public void update(boolean updateDate){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Utils utils=Utils.getInstance(context);
  utils.changeAppLanguage(context);
  if (firstTime) {
    utils.loadLanguageResource();
    firstTime=false;
  }
  Calendar calendar=utils.makeCalendarFromDate(new Date());
  CivilDate civil=new CivilDate(calendar);
  PersianDate persian=utils.getToday();
  Intent intent=new Intent(context,MainActivity.class);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
  RemoteViews remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
  RemoteViews remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2);
  String colorInt=utils.getSelectedWidgetTextColor();
  int color=Color.parseColor(colorInt);
  remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
  remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
  remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,utils.formatNumber(persian.getDayOfMonth()));
  remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,utils.shape(utils.getMonthName(persian)));
  remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget1x1.class),remoteViews1);
  remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
  remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
  remoteViews4.setTextColor(R.id.textPlaceholder3_4x1,color);
  String text1;
  String text2;
  String text3=""String_Node_Str"";
  String weekDayName=utils.getWeekDayName(civil);
  String persianDate=utils.dateToString(persian);
  String civilDate=utils.dateToString(civil);
  String date=persianDate + Constants.PERSIAN_COMMA + ""String_Node_Str""+ civilDate;
  String time=utils.getPersianFormattedClock(calendar);
  boolean enableClock=utils.isWidgetClock();
  if (enableClock) {
    text2=weekDayName + ""String_Node_Str"" + date;
    text1=time;
    if (utils.iranTime) {
      text3=""String_Node_Str"" + context.getString(R.string.iran_time) + ""String_Node_Str"";
    }
  }
 else {
    text1=weekDayName;
    text2=date;
  }
  remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,utils.shape(text1));
  remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,utils.shape(text2));
  remoteViews4.setTextViewText(R.id.textPlaceholder3_4x1,utils.shape(text3));
  remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget4x1.class),remoteViews4);
  remoteViews2.setTextColor(R.id.time_2x2,color);
  remoteViews2.setTextColor(R.id.date_2x2,color);
  remoteViews2.setTextColor(R.id.event_2x2,color);
  remoteViews2.setTextColor(R.id.owghat_2x2,color);
  if (enableClock) {
    text2=weekDayName + ""String_Node_Str"" + persianDate;
    text1=time;
  }
 else {
    text1=weekDayName;
    text2=persianDate;
  }
  Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
  String owghat;
  if (pastDate == null || !pastDate.equals(persian) || updateDate) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    pastDate=persian;
    utils.loadAlarms();
    owghat=utils.getNextOghatTime(currentClock,true);
    String holidays=utils.getEventsTitle(persian,true);
    if (!TextUtils.isEmpty(holidays)) {
      remoteViews2.setTextViewText(R.id.holiday_2x2,utils.shape(holidays));
      remoteViews2.setViewVisibility(R.id.holiday_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.holiday_2x2,View.GONE);
    }
    String events=utils.getEventsTitle(persian,false);
    if (!TextUtils.isEmpty(events)) {
      remoteViews2.setTextViewText(R.id.event_2x2,utils.shape(events));
      remoteViews2.setViewVisibility(R.id.event_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.event_2x2,View.GONE);
    }
  }
 else {
    owghat=utils.getNextOghatTime(currentClock,false);
  }
  if (owghat != null) {
    remoteViews2.setTextViewText(R.id.owghat_2x2,utils.shape(owghat));
    remoteViews2.setViewVisibility(R.id.owghat_2x2,View.VISIBLE);
  }
 else {
    remoteViews2.setViewVisibility(R.id.owghat_2x2,View.GONE);
  }
  remoteViews2.setTextViewText(R.id.time_2x2,utils.shape(text1));
  remoteViews2.setTextViewText(R.id.date_2x2,utils.shape(text2));
  remoteViews2.setOnClickPendingIntent(R.id.widget_layout2x2,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget2x2.class),remoteViews2);
  String status=utils.getMonthName(persian);
  String title=utils.getWeekDayName(civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ utils.dateToString(persian);
  String body=utils.dateToString(civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ utils.dateToString(DateConverter.civilToIslamic(civil,utils.getIslamicOffset()));
  if (Build.VERSION.SDK_INT > Build.VERSION_CODES.JELLY_BEAN) {
    title=Constants.RLM + title;
    body=Constants.RLM + body;
  }
  int icon=utils.getDayIconResource(persian.getDayOfMonth());
  if (mNotificationManager == null) {
    mNotificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  }
  if (utils.isNotifyDate()) {
    mNotificationManager.notify(NOTIFICATION_ID,new NotificationCompat.Builder(context).setPriority(NotificationCompat.PRIORITY_LOW).setOngoing(true).setSmallIcon(icon).setWhen(0).setContentIntent(launchAppPendingIntent).setContentText(utils.shape(body)).setContentTitle(utils.shape(title)).setColor(0xFF607D8B).build());
  }
 else {
    mNotificationManager.cancel(NOTIFICATION_ID);
  }
  mExtensionData=new ExtensionData().visible(true).icon(icon).status(utils.shape(status)).expandedTitle(utils.shape(title)).expandedBody(utils.shape(body)).clickIntent(intent);
}",0.985430022479394
8650,"private void stop(){
  if (mediaPlayer != null && mediaPlayer.isPlaying()) {
    mediaPlayer.stop();
    mediaPlayer.release();
  }
}","private void stop(){
  try {
    if (mediaPlayer != null && mediaPlayer.isPlaying()) {
      mediaPlayer.stop();
      mediaPlayer.release();
    }
  }
 catch (  IllegalStateException ignored) {
  }
}",0.7807807807807807
8651,"public String getWeekDayName(AbstractDate date){
  if (date instanceof IslamicDate)   date=DateConverter.islamicToCivil((IslamicDate)date);
  if (weekDays == null)   loadLanguageResource();
  return weekDays[date.getDayOfWeek() - 1];
}","public String getWeekDayName(AbstractDate date){
  if (date instanceof IslamicDate)   date=DateConverter.islamicToCivil((IslamicDate)date);
 else   if (date instanceof PersianDate)   date=DateConverter.persianToCivil((PersianDate)date);
  if (weekDays == null)   loadLanguageResource();
  return weekDays[date.getDayOfWeek() % 7];
}",0.818342151675485
8652,"@Override protected void onPrepareDialogBuilder(AlertDialog.Builder builder){
  super.onPrepareDialogBuilder(builder);
  final ShapedListPreference listPref=(ShapedListPreference)getPreference();
  final CharSequence[] entriesValues=listPref.getEntryValues();
  ShapedArrayAdapter entriesAdapter=new ShapedArrayAdapter(getContext(),R.layout.select_dialog_singlechoice_material,Arrays.asList(listPref.getEntries()));
  int index=Arrays.asList(entriesValues).indexOf(listPref.getSelected());
  builder.setSingleChoiceItems(entriesAdapter,index,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      listPref.setSelected(entriesValues[which].toString());
      getDialog().dismiss();
    }
  }
);
  builder.setPositiveButton(""String_Node_Str"",null);
}","@Override protected void onPrepareDialogBuilder(AlertDialog.Builder builder){
  super.onPrepareDialogBuilder(builder);
  final ShapedListPreference listPref=(ShapedListPreference)getPreference();
  final CharSequence[] entriesValues=listPref.getEntryValues();
  int selectDialogLayout=R.layout.select_dialog_singlechoice_material;
  if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1)   selectDialogLayout=android.R.layout.select_dialog_singlechoice;
  ShapedArrayAdapter entriesAdapter=new ShapedArrayAdapter(getContext(),selectDialogLayout,Arrays.asList(listPref.getEntries()));
  int index=Arrays.asList(entriesValues).indexOf(listPref.getSelected());
  builder.setSingleChoiceItems(entriesAdapter,index,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      listPref.setSelected(entriesValues[which].toString());
      getDialog().dismiss();
    }
  }
);
  builder.setPositiveButton(""String_Node_Str"",null);
}",0.8584070796460177
8653,"private void fillYearMonthDaySpinners(){
  AbstractDate date=null;
  PersianDate newDatePersian=utils.getToday();
  CivilDate newDateCivil=DateConverter.persianToCivil(newDatePersian);
  IslamicDate newDateIslamic=DateConverter.persianToIslamic(newDatePersian);
  date=newDateCivil;
  CalendarTypeEnum selectedCalendarType=calendarTypeFromPosition(calendarTypeSpinner.getSelectedItemPosition());
switch (selectedCalendarType) {
case GREGORIAN:
    date=newDateCivil;
  break;
case ISLAMIC:
date=newDateIslamic;
break;
case SHAMSI:
date=newDatePersian;
break;
}
int dropdownLayout=R.layout.select_dialog_item_material;
List<String> yearsList=new ArrayList<>();
int yearDiffRange=200;
startingYearOnYearSpinner=date.getYear() - yearDiffRange / 2;
for (int i=startingYearOnYearSpinner; i < startingYearOnYearSpinner + yearDiffRange; ++i) {
yearsList.add(utils.formatNumber(i));
}
yearSpinner.setAdapter(new ShapedArrayAdapter(getContext(),dropdownLayout,yearsList));
yearSpinner.setSelection(yearDiffRange / 2);
List<String> monthsList=utils.getMonthsNamesListWithOrdinal(date);
monthSpinner.setAdapter(new ShapedArrayAdapter(getContext(),dropdownLayout,monthsList));
monthSpinner.setSelection(date.getMonth() - 1);
List<String> daysList=new ArrayList<>();
for (int i=1; i <= 31; ++i) {
daysList.add(utils.formatNumber(i));
}
daySpinner.setAdapter(new ShapedArrayAdapter(getContext(),dropdownLayout,daysList));
daySpinner.setSelection(date.getDayOfMonth() - 1);
}","private void fillYearMonthDaySpinners(){
  AbstractDate date=null;
  PersianDate newDatePersian=utils.getToday();
  CivilDate newDateCivil=DateConverter.persianToCivil(newDatePersian);
  IslamicDate newDateIslamic=DateConverter.persianToIslamic(newDatePersian);
  date=newDateCivil;
  CalendarTypeEnum selectedCalendarType=calendarTypeFromPosition(calendarTypeSpinner.getSelectedItemPosition());
switch (selectedCalendarType) {
case GREGORIAN:
    date=newDateCivil;
  break;
case ISLAMIC:
date=newDateIslamic;
break;
case SHAMSI:
date=newDatePersian;
break;
}
List<String> yearsList=new ArrayList<>();
int yearDiffRange=200;
startingYearOnYearSpinner=date.getYear() - yearDiffRange / 2;
for (int i=startingYearOnYearSpinner; i < startingYearOnYearSpinner + yearDiffRange; ++i) {
yearsList.add(utils.formatNumber(i));
}
yearSpinner.setAdapter(new ShapedArrayAdapter(getContext(),DROPDOWN_LAYOUT,yearsList));
yearSpinner.setSelection(yearDiffRange / 2);
List<String> monthsList=utils.getMonthsNamesListWithOrdinal(date);
monthSpinner.setAdapter(new ShapedArrayAdapter(getContext(),DROPDOWN_LAYOUT,monthsList));
monthSpinner.setSelection(date.getMonth() - 1);
List<String> daysList=new ArrayList<>();
for (int i=1; i <= 31; ++i) {
daysList.add(utils.formatNumber(i));
}
daySpinner.setAdapter(new ShapedArrayAdapter(getContext(),DROPDOWN_LAYOUT,daysList));
daySpinner.setSelection(date.getDayOfMonth() - 1);
}",0.9497557571528262
8654,"@Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_converter,container,false);
  utils=Utils.getInstance(getContext());
  utils.setActivityTitleAndSubtitle(getActivity(),getString(R.string.date_converter),""String_Node_Str"");
  calendarTypeSpinner=(Spinner)view.findViewById(R.id.calendarTypeSpinner);
  yearSpinner=(Spinner)view.findViewById(R.id.yearSpinner);
  monthSpinner=(Spinner)view.findViewById(R.id.monthSpinner);
  daySpinner=(Spinner)view.findViewById(R.id.daySpinner);
  date0=(TextView)view.findViewById(R.id.date0);
  date1=(TextView)view.findViewById(R.id.date1);
  date2=(TextView)view.findViewById(R.id.date2);
  date0.setOnClickListener(this);
  date1.setOnClickListener(this);
  date2.setOnClickListener(this);
  moreDate=(RelativeLayout)view.findViewById(R.id.more_date);
  Context context=getContext();
  utils.setFontAndShape((TextView)view.findViewById(R.id.converterLabelDay));
  utils.setFontAndShape((TextView)view.findViewById(R.id.converterLabelMonth));
  utils.setFontAndShape((TextView)view.findViewById(R.id.converterLabelYear));
  utils.setFontAndShape((TextView)view.findViewById(R.id.calendarTypeTitle));
  utils.setFont(date0);
  utils.setFont(date1);
  utils.setFont(date2);
  calendarTypeSpinner.setAdapter(new ShapedArrayAdapter(context,R.layout.select_dialog_item_material,getResources().getStringArray(R.array.calendar_type)));
  calendarTypeSpinner.setSelection(0);
  fillYearMonthDaySpinners();
  calendarTypeSpinner.setOnItemSelectedListener(this);
  yearSpinner.setOnItemSelectedListener(this);
  monthSpinner.setOnItemSelectedListener(this);
  daySpinner.setOnItemSelectedListener(this);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_converter,container,false);
  utils=Utils.getInstance(getContext());
  utils.setActivityTitleAndSubtitle(getActivity(),getString(R.string.date_converter),""String_Node_Str"");
  calendarTypeSpinner=(Spinner)view.findViewById(R.id.calendarTypeSpinner);
  yearSpinner=(Spinner)view.findViewById(R.id.yearSpinner);
  monthSpinner=(Spinner)view.findViewById(R.id.monthSpinner);
  daySpinner=(Spinner)view.findViewById(R.id.daySpinner);
  date0=(TextView)view.findViewById(R.id.date0);
  date1=(TextView)view.findViewById(R.id.date1);
  date2=(TextView)view.findViewById(R.id.date2);
  date0.setOnClickListener(this);
  date1.setOnClickListener(this);
  date2.setOnClickListener(this);
  moreDate=(RelativeLayout)view.findViewById(R.id.more_date);
  Context context=getContext();
  utils.setFontAndShape((TextView)view.findViewById(R.id.converterLabelDay));
  utils.setFontAndShape((TextView)view.findViewById(R.id.converterLabelMonth));
  utils.setFontAndShape((TextView)view.findViewById(R.id.converterLabelYear));
  utils.setFontAndShape((TextView)view.findViewById(R.id.calendarTypeTitle));
  utils.setFont(date0);
  utils.setFont(date1);
  utils.setFont(date2);
  calendarTypeSpinner.setAdapter(new ShapedArrayAdapter(context,DROPDOWN_LAYOUT,getResources().getStringArray(R.array.calendar_type)));
  calendarTypeSpinner.setSelection(0);
  fillYearMonthDaySpinners();
  calendarTypeSpinner.setOnItemSelectedListener(this);
  yearSpinner.setOnItemSelectedListener(this);
  monthSpinner.setOnItemSelectedListener(this);
  daySpinner.setOnItemSelectedListener(this);
  return view;
}",0.9866590973602044
8655,"public CalendarTypesSpinnerAdapter(Context context,int resource){
  super(context,resource);
  utils=Utils.getInstance(context);
  utils.loadLanguageFromSettings();
  spinnerResource=resource;
  calendarTypes.put(CalendarTypeEnum.SHAMSI,utils.getString(Constants.HIJRI_SHAMSI));
  calendarTypes.put(CalendarTypeEnum.ISLAMIC,utils.getString(Constants.HIJRI_QAMARI));
  calendarTypes.put(CalendarTypeEnum.GEORGIAN,utils.getString(Constants.GEORGIAN));
}","public CalendarTypesSpinnerAdapter(Context context,int resource){
  super(context,resource);
  utils=Utils.getInstance(context);
  spinnerResource=resource;
  calendarTypes.put(CalendarTypeEnum.SHAMSI,utils.getString(Constants.HIJRI_SHAMSI));
  calendarTypes.put(CalendarTypeEnum.ISLAMIC,utils.getString(Constants.HIJRI_QAMARI));
  calendarTypes.put(CalendarTypeEnum.GEORGIAN,utils.getString(Constants.GEORGIAN));
}",0.9584295612009238
8656,"public void update(boolean updateDate){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Utils utils=Utils.getInstance(context);
  if (firstTime) {
    utils.loadLanguageFromSettings();
    firstTime=false;
  }
  Calendar calendar=utils.makeCalendarFromDate(new Date());
  CivilDate civil=new CivilDate(calendar);
  PersianDate persian=utils.getToday();
  Intent intent=new Intent(context,MainActivity.class);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
  RemoteViews remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
  RemoteViews remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2);
  String colorInt=utils.getSelectedWidgetTextColor();
  int color=Color.parseColor(colorInt);
  remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
  remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
  remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,utils.formatNumber(persian.getDayOfMonth()));
  remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,utils.shape(utils.getMonthName(persian)));
  remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget1x1.class),remoteViews1);
  remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
  remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
  remoteViews4.setTextColor(R.id.textPlaceholder3_4x1,color);
  String text1;
  String text2;
  String text3=""String_Node_Str"";
  String weekDayName=utils.getWeekDayName(civil);
  String persianDate=utils.dateToString(persian);
  String civilDate=utils.dateToString(civil);
  String date=persianDate + Constants.PERSIAN_COMMA + ""String_Node_Str""+ civilDate;
  String time=utils.getPersianFormattedClock(calendar);
  boolean enableClock=utils.isWidgetClock();
  if (enableClock) {
    text2=weekDayName + ""String_Node_Str"" + date;
    text1=time;
    if (utils.iranTime) {
      text3=""String_Node_Str"" + context.getString(R.string.iran_time) + ""String_Node_Str"";
    }
  }
 else {
    text1=weekDayName;
    text2=date;
  }
  remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,utils.shape(text1));
  remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,utils.shape(text2));
  remoteViews4.setTextViewText(R.id.textPlaceholder3_4x1,utils.shape(text3));
  remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget4x1.class),remoteViews4);
  remoteViews2.setTextColor(R.id.time_2x2,color);
  remoteViews2.setTextColor(R.id.date_2x2,color);
  remoteViews2.setTextColor(R.id.event_2x2,color);
  remoteViews2.setTextColor(R.id.owghat_2x2,color);
  if (enableClock) {
    text2=weekDayName + ""String_Node_Str"" + persianDate;
    text1=time;
  }
 else {
    text1=weekDayName;
    text2=persianDate;
  }
  Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
  String owghat;
  if (pastDate == null || !pastDate.equals(persian) || updateDate) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    pastDate=persian;
    utils.loadAlarms();
    owghat=utils.getNextOghatTime(currentClock,true);
    String holidays=utils.getEventsTitle(persian,true);
    if (!TextUtils.isEmpty(holidays)) {
      remoteViews2.setTextViewText(R.id.holiday_2x2,utils.shape(holidays));
      remoteViews2.setViewVisibility(R.id.holiday_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.holiday_2x2,View.GONE);
    }
    String events=utils.getEventsTitle(persian,false);
    if (!TextUtils.isEmpty(events)) {
      remoteViews2.setTextViewText(R.id.event_2x2,utils.shape(events));
      remoteViews2.setViewVisibility(R.id.event_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.event_2x2,View.GONE);
    }
  }
 else {
    owghat=utils.getNextOghatTime(currentClock,false);
  }
  if (owghat != null) {
    remoteViews2.setTextViewText(R.id.owghat_2x2,utils.shape(owghat));
    remoteViews2.setViewVisibility(R.id.owghat_2x2,View.VISIBLE);
  }
 else {
    remoteViews2.setViewVisibility(R.id.owghat_2x2,View.GONE);
  }
  remoteViews2.setTextViewText(R.id.time_2x2,utils.shape(text1));
  remoteViews2.setTextViewText(R.id.date_2x2,utils.shape(text2));
  remoteViews2.setOnClickPendingIntent(R.id.widget_layout2x2,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget2x2.class),remoteViews2);
  String status=utils.getMonthName(persian);
  String title=utils.getWeekDayName(civil) + ""String_Node_Str"" + utils.dateToString(persian);
  String body=utils.dateToString(civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ utils.dateToString(DateConverter.civilToIslamic(civil,utils.getIslamicOffset()));
  int icon=utils.getDayIconResource(persian.getDayOfMonth());
  if (mNotificationManager == null) {
    mNotificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  }
  if (utils.isNotifyDate()) {
    mNotificationManager.notify(NOTIFICATION_ID,new NotificationCompat.Builder(context).setPriority(NotificationCompat.PRIORITY_LOW).setOngoing(true).setSmallIcon(icon).setWhen(0).setContentIntent(launchAppPendingIntent).setContentText(utils.shape(body)).setContentTitle(utils.shape(title)).build());
  }
 else {
    mNotificationManager.cancel(NOTIFICATION_ID);
  }
  mExtensionData=new ExtensionData().visible(true).icon(icon).status(utils.shape(status)).expandedTitle(utils.shape(title)).expandedBody(utils.shape(body)).clickIntent(intent);
}","public void update(boolean updateDate){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Utils utils=Utils.getInstance(context);
  if (firstTime) {
    utils.changeAppLanguage(context);
    utils.loadLanguageResource();
    firstTime=false;
  }
  Calendar calendar=utils.makeCalendarFromDate(new Date());
  CivilDate civil=new CivilDate(calendar);
  PersianDate persian=utils.getToday();
  Intent intent=new Intent(context,MainActivity.class);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
  RemoteViews remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
  RemoteViews remoteViews2=new RemoteViews(context.getPackageName(),R.layout.widget2x2);
  String colorInt=utils.getSelectedWidgetTextColor();
  int color=Color.parseColor(colorInt);
  remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
  remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
  remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,utils.formatNumber(persian.getDayOfMonth()));
  remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,utils.shape(utils.getMonthName(persian)));
  remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget1x1.class),remoteViews1);
  remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
  remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
  remoteViews4.setTextColor(R.id.textPlaceholder3_4x1,color);
  String text1;
  String text2;
  String text3=""String_Node_Str"";
  String weekDayName=utils.getWeekDayName(civil);
  String persianDate=utils.dateToString(persian);
  String civilDate=utils.dateToString(civil);
  String date=persianDate + Constants.PERSIAN_COMMA + ""String_Node_Str""+ civilDate;
  String time=utils.getPersianFormattedClock(calendar);
  boolean enableClock=utils.isWidgetClock();
  if (enableClock) {
    text2=weekDayName + ""String_Node_Str"" + date;
    text1=time;
    if (utils.iranTime) {
      text3=""String_Node_Str"" + context.getString(R.string.iran_time) + ""String_Node_Str"";
    }
  }
 else {
    text1=weekDayName;
    text2=date;
  }
  remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,utils.shape(text1));
  remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,utils.shape(text2));
  remoteViews4.setTextViewText(R.id.textPlaceholder3_4x1,utils.shape(text3));
  remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget4x1.class),remoteViews4);
  remoteViews2.setTextColor(R.id.time_2x2,color);
  remoteViews2.setTextColor(R.id.date_2x2,color);
  remoteViews2.setTextColor(R.id.event_2x2,color);
  remoteViews2.setTextColor(R.id.owghat_2x2,color);
  if (enableClock) {
    text2=weekDayName + ""String_Node_Str"" + persianDate;
    text1=time;
  }
 else {
    text1=weekDayName;
    text2=persianDate;
  }
  Clock currentClock=new Clock(calendar.get(Calendar.HOUR_OF_DAY),calendar.get(Calendar.MINUTE));
  String owghat;
  if (pastDate == null || !pastDate.equals(persian) || updateDate) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    pastDate=persian;
    utils.loadAlarms();
    owghat=utils.getNextOghatTime(currentClock,true);
    String holidays=utils.getEventsTitle(persian,true);
    if (!TextUtils.isEmpty(holidays)) {
      remoteViews2.setTextViewText(R.id.holiday_2x2,utils.shape(holidays));
      remoteViews2.setViewVisibility(R.id.holiday_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.holiday_2x2,View.GONE);
    }
    String events=utils.getEventsTitle(persian,false);
    if (!TextUtils.isEmpty(events)) {
      remoteViews2.setTextViewText(R.id.event_2x2,utils.shape(events));
      remoteViews2.setViewVisibility(R.id.event_2x2,View.VISIBLE);
    }
 else {
      remoteViews2.setViewVisibility(R.id.event_2x2,View.GONE);
    }
  }
 else {
    owghat=utils.getNextOghatTime(currentClock,false);
  }
  if (owghat != null) {
    remoteViews2.setTextViewText(R.id.owghat_2x2,utils.shape(owghat));
    remoteViews2.setViewVisibility(R.id.owghat_2x2,View.VISIBLE);
  }
 else {
    remoteViews2.setViewVisibility(R.id.owghat_2x2,View.GONE);
  }
  remoteViews2.setTextViewText(R.id.time_2x2,utils.shape(text1));
  remoteViews2.setTextViewText(R.id.date_2x2,utils.shape(text2));
  remoteViews2.setOnClickPendingIntent(R.id.widget_layout2x2,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,Widget2x2.class),remoteViews2);
  String status=utils.getMonthName(persian);
  String title=utils.getWeekDayName(civil) + ""String_Node_Str"" + utils.dateToString(persian);
  String body=utils.dateToString(civil) + Constants.PERSIAN_COMMA + ""String_Node_Str""+ utils.dateToString(DateConverter.civilToIslamic(civil,utils.getIslamicOffset()));
  int icon=utils.getDayIconResource(persian.getDayOfMonth());
  if (mNotificationManager == null) {
    mNotificationManager=(NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
  }
  if (utils.isNotifyDate()) {
    mNotificationManager.notify(NOTIFICATION_ID,new NotificationCompat.Builder(context).setPriority(NotificationCompat.PRIORITY_LOW).setOngoing(true).setSmallIcon(icon).setWhen(0).setContentIntent(launchAppPendingIntent).setContentText(utils.shape(body)).setContentTitle(utils.shape(title)).build());
  }
 else {
    mNotificationManager.cancel(NOTIFICATION_ID);
  }
  mExtensionData=new ExtensionData().visible(true).icon(icon).status(utils.shape(status)).expandedTitle(utils.shape(title)).expandedBody(utils.shape(body)).clickIntent(intent);
}",0.994266851980542
8657,"public void changeAppLanguage(String localeCode){
  Locale locale=TextUtils.isEmpty(localeCode) ? Locale.getDefault() : new Locale(localeCode);
  Locale.setDefault(locale);
  Configuration config=new Configuration();
  config.locale=locale;
  Resources resources=context.getResources();
  resources.updateConfiguration(config,resources.getDisplayMetrics());
}","public void changeAppLanguage(Context context){
  String localeCode=getAppLanguage().replaceAll(""String_Node_Str"",""String_Node_Str"");
  Locale locale=TextUtils.isEmpty(localeCode) ? Locale.getDefault() : new Locale(localeCode);
  Locale.setDefault(locale);
  Configuration config=new Configuration();
  config.locale=locale;
  Resources resources=context.getResources();
  resources.updateConfiguration(config,resources.getDisplayMetrics());
}",0.8902743142144638
8658,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  String prayerKey=getIntent().getStringExtra(Constants.KEY_EXTRA_PRAYER_KEY);
  Utils utils=Utils.getInstance(getApplicationContext());
  setContentView(R.layout.activity_athan);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
  }
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
  textAlarmName=(TextView)findViewById(R.id.athan_name);
  TextView textCityName=(TextView)findViewById(R.id.place);
  athanIconView=(AppCompatImageView)findViewById(R.id.background_image);
  athanIconView.setOnClickListener(this);
  setPrayerView(prayerKey);
  CityEntity cityEntity=utils.getCityFromPreference();
  if (cityEntity != null) {
    String cityName=utils.getAppLanguage().equals(""String_Node_Str"") ? cityEntity.getEn() : cityEntity.getFa();
    textCityName.setText(getString(R.string.in_city_time) + ""String_Node_Str"" + cityName);
  }
 else {
    Coordinate coordinate=utils.getCoordinate();
    textCityName.setText(getString(R.string.in_city_time) + ""String_Node_Str"" + coordinate.getLatitude()+ ""String_Node_Str""+ coordinate.getLongitude());
  }
  new Handler().postDelayed(new Runnable(){
    @Override public void run(){
      finish();
    }
  }
,TimeUnit.SECONDS.toMillis(45));
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  String prayerKey=getIntent().getStringExtra(Constants.KEY_EXTRA_PRAYER_KEY);
  Utils utils=Utils.getInstance(getApplicationContext());
  utils.changeAppLanguage(this);
  utils.loadLanguageResource();
  setContentView(R.layout.activity_athan);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
  }
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
  textAlarmName=(TextView)findViewById(R.id.athan_name);
  TextView textCityName=(TextView)findViewById(R.id.place);
  athanIconView=(AppCompatImageView)findViewById(R.id.background_image);
  athanIconView.setOnClickListener(this);
  setPrayerView(prayerKey);
  CityEntity cityEntity=utils.getCityFromPreference();
  if (cityEntity != null) {
    String cityName=utils.getAppLanguage().equals(""String_Node_Str"") ? cityEntity.getEn() : cityEntity.getFa();
    textCityName.setText(getString(R.string.in_city_time) + ""String_Node_Str"" + cityName);
  }
 else {
    Coordinate coordinate=utils.getCoordinate();
    textCityName.setText(getString(R.string.in_city_time) + ""String_Node_Str"" + coordinate.getLatitude()+ ""String_Node_Str""+ coordinate.getLongitude());
  }
  new Handler().postDelayed(new Runnable(){
    @Override public void run(){
      finish();
    }
  }
,TimeUnit.SECONDS.toMillis(45));
}",0.9789575914535448
8659,"@Override protected void onCreate(Bundle savedInstanceState){
  utils=Utils.getInstance(getApplicationContext());
  utils.setTheme(this);
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  prevLocale=utils.loadLanguageFromSettings();
  prevTheme=utils.getTheme();
  updateUtils=UpdateUtils.getInstance(getApplicationContext());
  if (!Utils.getInstance(this).isServiceRunning(ApplicationService.class)) {
    startService(new Intent(getBaseContext(),ApplicationService.class));
  }
  updateUtils.update(true);
  setContentView(R.layout.activity_main);
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    Window w=getWindow();
    w.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
  }
 else {
    toolbar.setPadding(0,0,0,0);
  }
  RecyclerView navigation=(RecyclerView)findViewById(R.id.navigation_view);
  navigation.setHasFixedSize(true);
  adapter=new DrawerAdapter(this);
  navigation.setAdapter(adapter);
  RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
  navigation.setLayoutManager(layoutManager);
  drawerLayout=(DrawerLayout)findViewById(R.id.drawer);
  final View appMainView=findViewById(R.id.app_main_layout);
  ActionBarDrawerToggle drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer,R.string.closeDrawer){
    int slidingDirection=+1;
{
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        if (isRTL())         slidingDirection=-1;
      }
    }
    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) private boolean isRTL(){
      return getResources().getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;
    }
    @Override public void onDrawerOpened(    View drawerView){
      super.onDrawerOpened(drawerView);
    }
    @Override public void onDrawerClosed(    View drawerView){
      super.onDrawerClosed(drawerView);
    }
    @Override public void onDrawerSlide(    View drawerView,    float slideOffset){
      super.onDrawerSlide(drawerView,slideOffset);
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        slidingAnimation(drawerView,slideOffset);
      }
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB) private void slidingAnimation(    View drawerView,    float slideOffset){
      appMainView.setTranslationX(slideOffset * drawerView.getWidth() * slidingDirection);
      drawerLayout.bringChildToFront(drawerView);
      drawerLayout.requestLayout();
    }
  }
;
  drawerLayout.setDrawerListener(drawerToggle);
  drawerToggle.syncState();
  getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new CalendarFragment(),Constants.CALENDAR_MAIN_FRAGMENT_TAG).commit();
}","@Override protected void onCreate(Bundle savedInstanceState){
  utils=Utils.getInstance(getApplicationContext());
  utils.setTheme(this);
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  utils.changeAppLanguage(this);
  utils.loadLanguageResource();
  lastLocale=utils.getAppLanguage();
  lastTheme=utils.getTheme();
  updateUtils=UpdateUtils.getInstance(getApplicationContext());
  if (!Utils.getInstance(this).isServiceRunning(ApplicationService.class)) {
    startService(new Intent(getBaseContext(),ApplicationService.class));
  }
  updateUtils.update(true);
  setContentView(R.layout.activity_main);
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    Window w=getWindow();
    w.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
  }
 else {
    toolbar.setPadding(0,0,0,0);
  }
  RecyclerView navigation=(RecyclerView)findViewById(R.id.navigation_view);
  navigation.setHasFixedSize(true);
  adapter=new DrawerAdapter(this);
  navigation.setAdapter(adapter);
  RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
  navigation.setLayoutManager(layoutManager);
  drawerLayout=(DrawerLayout)findViewById(R.id.drawer);
  final View appMainView=findViewById(R.id.app_main_layout);
  ActionBarDrawerToggle drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer,R.string.closeDrawer){
    int slidingDirection=+1;
{
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        if (isRTL())         slidingDirection=-1;
      }
    }
    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) private boolean isRTL(){
      return getResources().getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;
    }
    @Override public void onDrawerOpened(    View drawerView){
      super.onDrawerOpened(drawerView);
    }
    @Override public void onDrawerClosed(    View drawerView){
      super.onDrawerClosed(drawerView);
    }
    @Override public void onDrawerSlide(    View drawerView,    float slideOffset){
      super.onDrawerSlide(drawerView,slideOffset);
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        slidingAnimation(drawerView,slideOffset);
      }
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB) private void slidingAnimation(    View drawerView,    float slideOffset){
      appMainView.setTranslationX(slideOffset * drawerView.getWidth() * slidingDirection);
      drawerLayout.bringChildToFront(drawerView);
      drawerLayout.requestLayout();
    }
  }
;
  drawerLayout.setDrawerListener(drawerToggle);
  drawerToggle.syncState();
  getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new CalendarFragment(),Constants.CALENDAR_MAIN_FRAGMENT_TAG).commit();
}",0.977252995311686
8660,"private void menuChange(){
  if (menuPosition != PREFERENCE)   return;
  utils.updateStoredPreference();
  updateUtils.update(true);
  boolean needsActivityRestart=false;
  String locale=utils.getAppLanguage();
  if (!locale.equals(prevLocale)) {
    prevLocale=locale;
    utils.loadLanguageFromSettings();
    needsActivityRestart=true;
  }
  if (!prevTheme.equals(utils.getTheme())) {
    needsActivityRestart=true;
  }
  if (needsActivityRestart) {
    Intent intent=getIntent();
    finish();
    startActivity(intent);
  }
}","private void menuChange(){
  if (menuPosition != PREFERENCE)   return;
  utils.updateStoredPreference();
  updateUtils.update(true);
  boolean needsActivityRestart=false;
  String locale=utils.getAppLanguage();
  if (!locale.equals(lastLocale)) {
    lastLocale=locale;
    utils.changeAppLanguage(this);
    utils.loadLanguageResource();
    needsActivityRestart=true;
  }
  if (!lastTheme.equals(utils.getTheme())) {
    needsActivityRestart=true;
  }
  if (needsActivityRestart) {
    Intent intent=getIntent();
    finish();
    startActivity(intent);
  }
}",0.92025664527956
8661,"public CivilDate(int year,int month,int day){
  this();
  setYear(year);
  setMonth(month);
  setDayOfMonth(day);
}","public CivilDate(int year,int month,int day){
  this();
  setYear(year);
  this.day=1;
  setMonth(month);
  setDayOfMonth(day);
}",0.9426229508196722
8662,"@Override public void onClick(View v){
  if (getAdapterPosition() - 7 - days.get(0).getDayOfWeek() >= 0) {
    monthFragment.onClickItem(days.get(getAdapterPosition() - 7 - days.get(0).getDayOfWeek()).getPersianDate());
    select_Day=getAdapterPosition();
    notifyDataSetChanged();
  }
}","@Override public void onClick(View v){
  int position=getAdapterPosition();
  position+=6 - (position % 7) * 2;
  if (days.size() < position - 6 - firstDayDayOfWeek) {
    return;
  }
  if (position - 7 - firstDayDayOfWeek >= 0) {
    monthFragment.onClickItem(days.get(position - 7 - firstDayDayOfWeek).getPersianDate());
    select_Day=position;
    notifyDataSetChanged();
  }
}",0.5722801788375559
8663,"@Override public boolean onLongClick(View v){
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
    try {
      monthFragment.onLongClickItem(days.get(getAdapterPosition() - 7 - days.get(0).getDayOfWeek()).getPersianDate());
    }
 catch (    Exception e) {
    }
  }
  return false;
}","@Override public boolean onLongClick(View v){
  int position=getAdapterPosition();
  position+=6 - (position % 7) * 2;
  if (days.size() < position - 6 - firstDayDayOfWeek) {
    return false;
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
    try {
      monthFragment.onLongClickItem(days.get(position - 7 - firstDayDayOfWeek).getPersianDate());
    }
 catch (    Exception e) {
    }
  }
  return false;
}",0.6702412868632708
8664,"public MonthAdapter(Context context,MonthFragment monthFragment,List<DayEntity> days){
  this.monthFragment=monthFragment;
  this.context=context;
  this.days=days;
  utils=Utils.getInstance(context);
  persianDigit=utils.isPersianDigitSelected();
  context.getTheme().resolveAttribute(R.attr.colorHoliday,colorHoliday,true);
  context.getTheme().resolveAttribute(R.attr.colorTextHoliday,colorTextHoliday,true);
  context.getTheme().resolveAttribute(R.attr.colorPrimary,colorPrimary,true);
  context.getTheme().resolveAttribute(R.attr.colorTextDayName,colorDayName,true);
}","public MonthAdapter(Context context,MonthFragment monthFragment,List<DayEntity> days){
  firstDayDayOfWeek=days.get(0).getDayOfWeek();
  this.monthFragment=monthFragment;
  this.context=context;
  this.days=days;
  utils=Utils.getInstance(context);
  persianDigit=utils.isPersianDigitSelected();
  context.getTheme().resolveAttribute(R.attr.colorHoliday,colorHoliday,true);
  context.getTheme().resolveAttribute(R.attr.colorTextHoliday,colorTextHoliday,true);
  context.getTheme().resolveAttribute(R.attr.colorPrimary,colorPrimary,true);
  context.getTheme().resolveAttribute(R.attr.colorTextDayName,colorDayName,true);
}",0.9597989949748744
8665,"@Override public int getItemCount(){
  return days.size() + days.get(0).getDayOfWeek() + 7;
}","@Override public int getItemCount(){
  return 7 * 6;
}",0.6938775510204082
8666,"@Override public void onBindViewHolder(MonthAdapter.ViewHolder holder,int position){
  if (!isPositionHeader(position)) {
    if (position - 7 - days.get(0).getDayOfWeek() >= 0) {
      holder.num.setText(days.get(position - 7 - days.get(0).getDayOfWeek()).getNum());
      holder.num.setVisibility(View.VISIBLE);
      if (persianDigit) {
        holder.num.setTextSize(25);
      }
 else {
        holder.num.setTextSize(20);
      }
      if (days.get(position - 7 - days.get(0).getDayOfWeek()).isHoliday()) {
        holder.num.setTextColor(ContextCompat.getColor(context,colorHoliday.resourceId));
      }
 else {
        holder.num.setTextColor(ContextCompat.getColor(context,R.color.dark_text_day));
      }
      if (days.get(position - 7 - days.get(0).getDayOfWeek()).isEvent()) {
        holder.event.setVisibility(View.VISIBLE);
      }
 else {
        holder.event.setVisibility(View.GONE);
      }
      if (days.get(position - 7 - days.get(0).getDayOfWeek()).isToday()) {
        holder.today.setVisibility(View.VISIBLE);
      }
 else {
        holder.today.setVisibility(View.GONE);
      }
      if (position == select_Day) {
        holder.selectDay.setVisibility(View.VISIBLE);
        if (days.get(position - 7 - days.get(0).getDayOfWeek()).isHoliday()) {
          holder.num.setTextColor(ContextCompat.getColor(context,colorTextHoliday.resourceId));
        }
 else {
          holder.num.setTextColor(ContextCompat.getColor(context,colorPrimary.resourceId));
        }
      }
 else {
        holder.selectDay.setVisibility(View.GONE);
      }
    }
 else {
      holder.today.setVisibility(View.GONE);
      holder.selectDay.setVisibility(View.GONE);
      holder.num.setVisibility(View.GONE);
      holder.event.setVisibility(View.GONE);
    }
    utils.setFontAndShape(holder.num);
  }
 else {
    holder.num.setText(Constants.FIRST_CHAR_OF_DAYS_OF_WEEK_NAME[position]);
    holder.num.setTextColor(ContextCompat.getColor(context,colorDayName.resourceId));
    holder.num.setTextSize(20);
    holder.today.setVisibility(View.GONE);
    holder.selectDay.setVisibility(View.GONE);
    holder.event.setVisibility(View.GONE);
    holder.num.setVisibility(View.VISIBLE);
    utils.setFont(holder.num);
  }
}","@Override public void onBindViewHolder(MonthAdapter.ViewHolder holder,int position){
  position+=6 - (position % 7) * 2;
  if (days.size() < position - 6 - firstDayDayOfWeek) {
    return;
  }
  if (!isPositionHeader(position)) {
    if (position - 7 - firstDayDayOfWeek >= 0) {
      holder.num.setText(days.get(position - 7 - days.get(0).getDayOfWeek()).getNum());
      holder.num.setVisibility(View.VISIBLE);
      if (persianDigit) {
        holder.num.setTextSize(25);
      }
 else {
        holder.num.setTextSize(20);
      }
      if (days.get(position - 7 - firstDayDayOfWeek).isHoliday()) {
        holder.num.setTextColor(ContextCompat.getColor(context,colorHoliday.resourceId));
      }
 else {
        holder.num.setTextColor(ContextCompat.getColor(context,R.color.dark_text_day));
      }
      if (days.get(position - 7 - firstDayDayOfWeek).isEvent()) {
        holder.event.setVisibility(View.VISIBLE);
      }
 else {
        holder.event.setVisibility(View.GONE);
      }
      if (days.get(position - 7 - firstDayDayOfWeek).isToday()) {
        holder.today.setVisibility(View.VISIBLE);
      }
 else {
        holder.today.setVisibility(View.GONE);
      }
      if (position == select_Day) {
        holder.selectDay.setVisibility(View.VISIBLE);
        if (days.get(position - 7 - firstDayDayOfWeek).isHoliday()) {
          holder.num.setTextColor(ContextCompat.getColor(context,colorTextHoliday.resourceId));
        }
 else {
          holder.num.setTextColor(ContextCompat.getColor(context,colorPrimary.resourceId));
        }
      }
 else {
        holder.selectDay.setVisibility(View.GONE);
      }
    }
 else {
      holder.today.setVisibility(View.GONE);
      holder.selectDay.setVisibility(View.GONE);
      holder.num.setVisibility(View.GONE);
      holder.event.setVisibility(View.GONE);
    }
    utils.setFontAndShape(holder.num);
  }
 else {
    holder.num.setText(Constants.FIRST_CHAR_OF_DAYS_OF_WEEK_NAME[position]);
    holder.num.setTextColor(ContextCompat.getColor(context,colorDayName.resourceId));
    holder.num.setTextSize(20);
    holder.today.setVisibility(View.GONE);
    holder.selectDay.setVisibility(View.GONE);
    holder.event.setVisibility(View.GONE);
    holder.num.setVisibility(View.VISIBLE);
    utils.setFont(holder.num);
  }
}",0.9285240097366674
8667,"public int getIslamicOffset(){
  return Integer.parseInt(prefs.getString(Constants.PREF_ISLAMIC_OFFSET,Constants.DEFAULT_ISLAMIC_OFFSET));
}","public int getIslamicOffset(){
  return Integer.parseInt(prefs.getString(Constants.PREF_ISLAMIC_OFFSET,Constants.DEFAULT_ISLAMIC_OFFSET).replace(""String_Node_Str"",""String_Node_Str""));
}",0.8615384615384616
8668,"@Override protected View onCreateDialogView(Context context){
  View view=super.onCreateDialogView(context);
  final AthanVolumePreference athanPref=(AthanVolumePreference)getPreference();
  audioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mediaPlayer=new MediaPlayer();
  try {
    mediaPlayer.setAudioStreamType(AudioManager.STREAM_ALARM);
    mediaPlayer.setDataSource(getContext(),Utils.getInstance(getContext()).getAthanUri());
    audioManager.setStreamVolume(AudioManager.STREAM_ALARM,athanPref.getVolume(),0);
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  SeekBar seekBar=(SeekBar)view.findViewById(R.id.sbVolumeSlider);
  seekBar.setProgress(athanPref.getVolume());
  seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
      volume=progress;
      audioManager.setStreamVolume(AudioManager.STREAM_ALARM,progress,0);
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
      try {
        if (!mediaPlayer.isPlaying()) {
          mediaPlayer.prepare();
          mediaPlayer.start();
        }
      }
 catch (      IOException ignored) {
      }
    }
  }
);
  return view;
}","@Override protected View onCreateDialogView(Context context){
  View view=super.onCreateDialogView(context);
  final AthanVolumePreference athanPref=(AthanVolumePreference)getPreference();
  audioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mediaPlayer=new MediaPlayer();
  try {
    mediaPlayer.setAudioStreamType(AudioManager.STREAM_ALARM);
    mediaPlayer.setDataSource(getContext(),Utils.getInstance(getContext()).getAthanUri());
    audioManager.setStreamVolume(AudioManager.STREAM_ALARM,athanPref.getVolume(),0);
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"",e);
  }
  SeekBar seekBar=(SeekBar)view.findViewById(R.id.sbVolumeSlider);
  volume=athanPref.getVolume();
  seekBar.setProgress(volume);
  seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
      volume=progress;
      audioManager.setStreamVolume(AudioManager.STREAM_ALARM,progress,0);
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
      try {
        if (!mediaPlayer.isPlaying()) {
          mediaPlayer.prepare();
          mediaPlayer.start();
        }
      }
 catch (      IOException ignored) {
      }
    }
  }
);
  return view;
}",0.9794594594594594
8669,"public AthanVolumePreference(Context context,AttributeSet attrs){
  super(context,attrs);
  this.context=context;
  utils=Utils.getInstance(context);
  setDialogLayoutResource(R.layout.preference_volume);
  setDialogIcon(null);
}","public AthanVolumePreference(Context context,AttributeSet attrs){
  super(context,attrs);
  utils=Utils.getInstance(context);
  setDialogLayoutResource(R.layout.preference_volume);
  setDialogIcon(null);
}",0.9447004608294932
8670,"public void setAlarm(PrayTime prayTime,long timeInMillis,int id){
  String valAthanGap=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  long athanGap=TextUtils.isEmpty(valAthanGap) ? 0 : Long.parseLong(valAthanGap);
  Calendar triggerTime=Calendar.getInstance();
  triggerTime.setTimeInMillis(timeInMillis - TimeUnit.SECONDS.toMillis(athanGap));
  AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  if (!triggerTime.before(Calendar.getInstance())) {
    Log.d(TAG,""String_Node_Str"" + triggerTime.getTime());
    Intent intent=new Intent(context,BroadcastReceivers.class);
    intent.setAction(Constants.BROADCAST_ALARM);
    intent.putExtra(Constants.KEY_EXTRA_PRAYER_KEY,prayTime.name());
    PendingIntent pendingIntent=PendingIntent.getBroadcast(context,id,intent,0);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
      alarmManager.setExact(AlarmManager.RTC_WAKEUP,triggerTime.getTimeInMillis(),pendingIntent);
    }
 else {
      alarmManager.set(AlarmManager.RTC_WAKEUP,triggerTime.getTimeInMillis(),pendingIntent);
    }
  }
}","public void setAlarm(PrayTime prayTime,long timeInMillis,int id){
  String valAthanGap=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  long athanGap;
  try {
    athanGap=(long)(Double.parseDouble(valAthanGap) * 60);
  }
 catch (  NumberFormatException e) {
    athanGap=0;
  }
  Calendar triggerTime=Calendar.getInstance();
  triggerTime.setTimeInMillis(timeInMillis - TimeUnit.SECONDS.toMillis(athanGap));
  AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  if (!triggerTime.before(Calendar.getInstance())) {
    Log.d(TAG,""String_Node_Str"" + triggerTime.getTime());
    Intent intent=new Intent(context,BroadcastReceivers.class);
    intent.setAction(Constants.BROADCAST_ALARM);
    intent.putExtra(Constants.KEY_EXTRA_PRAYER_KEY,prayTime.name());
    PendingIntent pendingIntent=PendingIntent.getBroadcast(context,id,intent,0);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
      alarmManager.setExact(AlarmManager.RTC_WAKEUP,triggerTime.getTimeInMillis(),pendingIntent);
    }
 else {
      alarmManager.set(AlarmManager.RTC_WAKEUP,triggerTime.getTimeInMillis(),pendingIntent);
    }
  }
}",0.9224634470536108
8671,"public void loadApp(){
  AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  Calendar startTime=Calendar.getInstance();
  startTime.set(Calendar.HOUR_OF_DAY,0);
  startTime.set(Calendar.MINUTE,1);
  Intent intent=new Intent(context,BroadcastReceivers.class);
  intent.setAction(Constants.BROADCAST_ALARM);
  PendingIntent pendingIntent=PendingIntent.getBroadcast(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  alarmManager.set(AlarmManager.RTC,startTime.getTimeInMillis(),pendingIntent);
}","public void loadApp(){
  AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  Calendar startTime=Calendar.getInstance();
  startTime.set(Calendar.HOUR_OF_DAY,0);
  startTime.set(Calendar.MINUTE,1);
  Intent intent=new Intent(context,BroadcastReceivers.class);
  intent.setAction(Constants.BROADCAST_RESTART_APP);
  PendingIntent pendingIntent=PendingIntent.getBroadcast(context,0,intent,PendingIntent.FLAG_UPDATE_CURRENT);
  alarmManager.set(AlarmManager.RTC,startTime.getTimeInMillis(),pendingIntent);
}",0.9851576994434136
8672,"@Override public void onPageSelected(int position){
  Intent intent=new Intent(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT);
  intent.putExtra(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT,position - Constants.MONTHS_LIMIT / 2);
  getContext().sendBroadcast(intent);
  today.setVisibility(View.VISIBLE);
  todayIcon.setVisibility(View.VISIBLE);
}","@Override public void onPageSelected(int position){
  viewPagerPosition=position - Constants.MONTHS_LIMIT / 2;
  Intent intent=new Intent(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT);
  intent.putExtra(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT,position - Constants.MONTHS_LIMIT / 2);
  getContext().sendBroadcast(intent);
  today.setVisibility(View.VISIBLE);
  todayIcon.setVisibility(View.VISIBLE);
}",0.9212283044058746
8673,"@Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_converter,container,false);
  utils.setActivityTitleAndSubtitle(getActivity(),getString(R.string.date_converter),""String_Node_Str"");
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    clipboardManager=(ClipboardManager)getContext().getSystemService(Context.CLIPBOARD_SERVICE);
  }
  calendarTypeSpinner=(Spinner)view.findViewById(R.id.calendarTypeSpinner);
  yearSpinner=(Spinner)view.findViewById(R.id.yearSpinner);
  monthSpinner=(Spinner)view.findViewById(R.id.monthSpinner);
  daySpinner=(Spinner)view.findViewById(R.id.daySpinner);
  date0=(TextView)view.findViewById(R.id.date0);
  date1=(TextView)view.findViewById(R.id.date1);
  date2=(TextView)view.findViewById(R.id.date2);
  date0.setOnClickListener(this);
  date1.setOnClickListener(this);
  date2.setOnClickListener(this);
  moreDate=(RelativeLayout)view.findViewById(R.id.more_date);
  Context context=getContext();
  utils.prepareShapeTextView(context,(TextView)view.findViewById(R.id.converterLabelDay));
  utils.prepareShapeTextView(context,(TextView)view.findViewById(R.id.converterLabelMonth));
  utils.prepareShapeTextView(context,(TextView)view.findViewById(R.id.converterLabelYear));
  utils.prepareShapeTextView(context,(TextView)view.findViewById(R.id.calendarTypeTitle));
  utils.prepareTextView(context,date0);
  utils.prepareTextView(context,date1);
  utils.prepareTextView(context,date2);
  calendarTypeSpinner.setAdapter(new CalendarTypesSpinnerAdapter(getContext(),android.R.layout.select_dialog_item));
  calendarTypeSpinner.setSelection(0);
  fillYearMonthDaySpinners();
  calendarTypeSpinner.setOnItemSelectedListener(this);
  yearSpinner.setOnItemSelectedListener(this);
  monthSpinner.setOnItemSelectedListener(this);
  daySpinner.setOnItemSelectedListener(this);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_converter,container,false);
  utils.setActivityTitleAndSubtitle(getActivity(),getString(R.string.date_converter),""String_Node_Str"");
  calendarTypeSpinner=(Spinner)view.findViewById(R.id.calendarTypeSpinner);
  yearSpinner=(Spinner)view.findViewById(R.id.yearSpinner);
  monthSpinner=(Spinner)view.findViewById(R.id.monthSpinner);
  daySpinner=(Spinner)view.findViewById(R.id.daySpinner);
  date0=(TextView)view.findViewById(R.id.date0);
  date1=(TextView)view.findViewById(R.id.date1);
  date2=(TextView)view.findViewById(R.id.date2);
  date0.setOnClickListener(this);
  date1.setOnClickListener(this);
  date2.setOnClickListener(this);
  moreDate=(RelativeLayout)view.findViewById(R.id.more_date);
  Context context=getContext();
  utils.prepareShapeTextView(context,(TextView)view.findViewById(R.id.converterLabelDay));
  utils.prepareShapeTextView(context,(TextView)view.findViewById(R.id.converterLabelMonth));
  utils.prepareShapeTextView(context,(TextView)view.findViewById(R.id.converterLabelYear));
  utils.prepareShapeTextView(context,(TextView)view.findViewById(R.id.calendarTypeTitle));
  utils.prepareTextView(context,date0);
  utils.prepareTextView(context,date1);
  utils.prepareTextView(context,date2);
  calendarTypeSpinner.setAdapter(new CalendarTypesSpinnerAdapter(getContext(),android.R.layout.select_dialog_item));
  calendarTypeSpinner.setSelection(0);
  fillYearMonthDaySpinners();
  calendarTypeSpinner.setOnItemSelectedListener(this);
  yearSpinner.setOnItemSelectedListener(this);
  monthSpinner.setOnItemSelectedListener(this);
  daySpinner.setOnItemSelectedListener(this);
  return view;
}",0.955964771817454
8674,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_month,container,false);
  offset=getArguments().getInt(Constants.OFFSET_ARGUMENT);
  List<Day> days=utils.getDays(getContext(),offset);
  digits=utils.preferredDigits(getActivity());
  AppCompatImageView prev=(AppCompatImageView)view.findViewById(R.id.prev);
  AppCompatImageView next=(AppCompatImageView)view.findViewById(R.id.next);
  prev.setOnClickListener(this);
  next.setOnClickListener(this);
  persianDate=Utils.getToday();
  int month=persianDate.getMonth() - offset;
  month-=1;
  int year=persianDate.getYear();
  year=year + (month / 12);
  month=month % 12;
  if (month < 0) {
    year-=1;
    month+=12;
  }
  month+=1;
  persianDate.setMonth(month);
  persianDate.setYear(year);
  persianDate.setDayOfMonth(1);
  RecyclerView recyclerView=(RecyclerView)view.findViewById(R.id.RecyclerView);
  recyclerView.setHasFixedSize(true);
  RecyclerView.LayoutManager layoutManager=new GridLayoutManager(getContext(),7);
  recyclerView.setLayoutManager(layoutManager);
  adapter=new MonthAdapter(getActivity(),this,days);
  recyclerView.setAdapter(adapter);
  calendarMainFragment=(CalendarMainFragment)getActivity().getSupportFragmentManager().findFragmentByTag(Constants.CALENDAR_MAIN_FRAGMENT_TAG);
  if (calendarMainFragment != null && offset == 0) {
    calendarMainFragment.selectDay(Utils.getToday());
  }
  if (offset == 0) {
    UpdateTitle();
  }
  filter=new IntentFilter(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT);
  receiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      int value=intent.getExtras().getInt(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT);
      if (value == offset) {
        UpdateTitle();
      }
 else       if (value == Constants.BROADCAST_TO_MONTH_FRAGMENT_RESET_DAY) {
        resetSelectDay();
      }
    }
  }
;
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_month,container,false);
  offset=getArguments().getInt(Constants.OFFSET_ARGUMENT);
  List<Day> days=utils.getDays(getContext(),offset);
  digits=utils.preferredDigits(getActivity());
  AppCompatImageView prev=(AppCompatImageView)view.findViewById(R.id.prev);
  AppCompatImageView next=(AppCompatImageView)view.findViewById(R.id.next);
  prev.setOnClickListener(this);
  next.setOnClickListener(this);
  persianDate=Utils.getToday();
  int month=persianDate.getMonth() - offset;
  month-=1;
  int year=persianDate.getYear();
  year=year + (month / 12);
  month=month % 12;
  if (month < 0) {
    year-=1;
    month+=12;
  }
  month+=1;
  persianDate.setMonth(month);
  persianDate.setYear(year);
  persianDate.setDayOfMonth(1);
  RecyclerView recyclerView=(RecyclerView)view.findViewById(R.id.RecyclerView);
  recyclerView.setHasFixedSize(true);
  RecyclerView.LayoutManager layoutManager=new GridLayoutManager(getContext(),7);
  recyclerView.setLayoutManager(layoutManager);
  adapter=new MonthAdapter(getActivity(),this,days);
  recyclerView.setAdapter(adapter);
  calendarMainFragment=(CalendarMainFragment)getActivity().getSupportFragmentManager().findFragmentByTag(Constants.CALENDAR_MAIN_FRAGMENT_TAG);
  if (calendarMainFragment != null && offset == 0 && CalendarMainFragment.viewPagerPosition == offset) {
    calendarMainFragment.selectDay(Utils.getToday());
  }
  if (offset == 0 && CalendarMainFragment.viewPagerPosition == offset) {
    UpdateTitle();
  }
  filter=new IntentFilter(Constants.BROADCAST_INTENT_TO_MONTH_FRAGMENT);
  receiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      int value=intent.getExtras().getInt(Constants.BROADCAST_FIELD_TO_MONTH_FRAGMENT);
      if (value == offset) {
        UpdateTitle();
      }
 else       if (value == Constants.BROADCAST_TO_MONTH_FRAGMENT_RESET_DAY) {
        resetSelectDay();
      }
    }
  }
;
  return view;
}",0.9745098039215686
8675,"public void drawDial(Canvas canvas){
  Paint markerPaint, circlePaint;
  circlePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  circlePaint.setColor(ContextCompat.getColor(getContext(),R.color.background));
  circlePaint.setStrokeWidth(1);
  circlePaint.setStyle(Paint.Style.STROKE);
  int textHeight=(int)textPaint.measureText(""String_Node_Str"");
  markerPaint=new Paint(Paint.FAKE_BOLD_TEXT_FLAG);
  markerPaint.setColor(ContextCompat.getColor(getContext(),R.color.accent));
  canvas.drawCircle(px,py,Radius,circlePaint);
  canvas.drawCircle(px,py,Radius - 20,circlePaint);
  int textWidth=(int)textPaint.measureText(""String_Node_Str"");
  int cardinalX=px - textWidth / 2;
  int cardinalY=py - Radius + textHeight;
  for (int i=0; i < 24; i++) {
    canvas.drawLine(px,py - Radius,px,py - Radius + 10,markerPaint);
    canvas.save();
    canvas.translate(0,textHeight);
    if (i % 6 == 0) {
      String dirString=""String_Node_Str"";
switch (i) {
case (0):
{
          dirString=northString;
          break;
        }
case (6):
      dirString=eastString;
    break;
case (12):
  dirString=southString;
break;
case (18):
dirString=westString;
break;
}
canvas.drawText(dirString,cardinalX,cardinalY,textPaint);
}
 else if (i % 3 == 0) {
String angle=String.valueOf(i * 15);
float angleTextWidth=textPaint.measureText(angle);
int angleTextX=(int)(px - angleTextWidth / 2);
int angleTextY=py - Radius + textHeight;
canvas.drawText(angle,angleTextX,angleTextY,textPaint);
}
canvas.restore();
canvas.rotate(15,px,py);
}
}","public void drawDial(Canvas canvas){
  Paint markerPaint, circlePaint;
  circlePaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  circlePaint.setColor(ContextCompat.getColor(getContext(),R.color.text_normal));
  circlePaint.setStrokeWidth(1);
  circlePaint.setStyle(Paint.Style.STROKE);
  int textHeight=(int)textPaint.measureText(""String_Node_Str"");
  markerPaint=new Paint(Paint.FAKE_BOLD_TEXT_FLAG);
  markerPaint.setColor(ContextCompat.getColor(getContext(),R.color.text_normal));
  canvas.drawCircle(px,py,Radius,circlePaint);
  canvas.drawCircle(px,py,Radius - 20,circlePaint);
  int textWidth=(int)textPaint.measureText(""String_Node_Str"");
  int cardinalX=px - textWidth / 2;
  int cardinalY=py - Radius + textHeight;
  for (int i=0; i < 24; i++) {
    canvas.drawLine(px,py - Radius,px,py - Radius + 10,markerPaint);
    canvas.save();
    canvas.translate(0,textHeight);
    if (i % 6 == 0) {
      String dirString=""String_Node_Str"";
switch (i) {
case (0):
{
          dirString=northString;
          break;
        }
case (6):
      dirString=eastString;
    break;
case (12):
  dirString=southString;
break;
case (18):
dirString=westString;
break;
}
canvas.drawText(dirString,cardinalX,cardinalY,textPaint);
}
 else if (i % 3 == 0) {
String angle=String.valueOf(i * 15);
float angleTextWidth=textPaint.measureText(angle);
int angleTextX=(int)(px - angleTextWidth / 2);
int angleTextY=py - Radius + textHeight;
canvas.drawText(angle,angleTextX,angleTextY,textPaint);
}
canvas.restore();
canvas.rotate(15,px,py);
}
}",0.9874587458745876
8676,"public void initCompassView(){
  setFocusable(true);
  initAstronomicParameters();
  northString=""String_Node_Str"";
  eastString=""String_Node_Str"";
  southString=""String_Node_Str"";
  westString=""String_Node_Str"";
  dashPath=new DashPathEffect(new float[]{2,5},1);
  dashedPaint=new Paint(Paint.FAKE_BOLD_TEXT_FLAG);
  dashedPaint.setPathEffect(dashPath);
  dashedPaint.setStrokeWidth(2);
  dashedPaint.setPathEffect(dashPath);
  dashedPaint.setColor(ContextCompat.getColor(getContext(),R.color.accent));
  textPaint=new Paint(Paint.FAKE_BOLD_TEXT_FLAG);
  textPaint.setColor(ContextCompat.getColor(getContext(),(R.color.text_normal)));
  textPaint.setTextSize(20);
}","public void initCompassView(){
  setFocusable(true);
  initAstronomicParameters();
  northString=""String_Node_Str"";
  eastString=""String_Node_Str"";
  southString=""String_Node_Str"";
  westString=""String_Node_Str"";
  dashPath=new DashPathEffect(new float[]{2,5},1);
  dashedPaint=new Paint(Paint.FAKE_BOLD_TEXT_FLAG);
  dashedPaint.setPathEffect(dashPath);
  dashedPaint.setStrokeWidth(2);
  dashedPaint.setPathEffect(dashPath);
  dashedPaint.setColor(ContextCompat.getColor(getContext(),R.color.text_normal));
  textPaint=new Paint(Paint.FAKE_BOLD_TEXT_FLAG);
  textPaint.setColor(ContextCompat.getColor(getContext(),(R.color.text_normal)));
  textPaint.setTextSize(20);
}",0.987284966342558
8677,"@Nullable @Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_calendar,container,false);
  owghat1=(RelativeLayout)view.findViewById(R.id.owghat1);
  owghat2=(RelativeLayout)view.findViewById(R.id.owghat2);
  owghat3=(RelativeLayout)view.findViewById(R.id.owghat3);
  owghat4=(RelativeLayout)view.findViewById(R.id.owghat4);
  owghat5=(RelativeLayout)view.findViewById(R.id.owghat5);
  owghat6=(RelativeLayout)view.findViewById(R.id.owghat6);
  owghat7=(RelativeLayout)view.findViewById(R.id.owghat7);
  owghat8=(RelativeLayout)view.findViewById(R.id.owghat8);
  FragmentActivity activity=getActivity();
  georgianDate=(TextView)view.findViewById(R.id.georgian_date);
  utils.prepareTextView(activity,georgianDate);
  islamicDate=(TextView)view.findViewById(R.id.islamic_date);
  utils.prepareTextView(activity,islamicDate);
  shamsiDate=(TextView)view.findViewById(R.id.shamsi_date);
  utils.prepareTextView(activity,shamsiDate);
  weekDayName=(TextView)view.findViewById(R.id.week_day_name);
  utils.prepareTextView(activity,weekDayName);
  today=(TextView)view.findViewById(R.id.today);
  todayIcon=(AppCompatImageView)view.findViewById(R.id.today_icon);
  athan1=(TextView)view.findViewById(R.id.azan1);
  utils.prepareTextView(activity,athan1);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.azan1text));
  athan2=(TextView)view.findViewById(R.id.azan2);
  utils.prepareTextView(activity,athan2);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.azan2text));
  athan3=(TextView)view.findViewById(R.id.azan3);
  utils.prepareTextView(activity,athan3);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.azan3text));
  athan4=(TextView)view.findViewById(R.id.azan4);
  utils.prepareTextView(activity,athan4);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.azan4text));
  athan5=(TextView)view.findViewById(R.id.azan5);
  utils.prepareTextView(activity,athan5);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.azan5text));
  aftab1=(TextView)view.findViewById(R.id.aftab1);
  utils.prepareTextView(activity,aftab1);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.aftab1text));
  aftab2=(TextView)view.findViewById(R.id.aftab2);
  utils.prepareTextView(activity,aftab2);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.aftab2text));
  aftab3=(TextView)view.findViewById(R.id.aftab3);
  utils.prepareTextView(activity,aftab3);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.aftab3text));
  moreOwghat=(AppCompatImageView)view.findViewById(R.id.more_owghat);
  eventTitle=(TextView)view.findViewById(R.id.event_title);
  holidayTitle=(TextView)view.findViewById(R.id.holiday_title);
  utils.prepareTextView(activity,holidayTitle);
  owghat=(CardView)view.findViewById(R.id.owghat);
  event=(CardView)view.findViewById(R.id.event);
  monthViewPager=(ViewPager)view.findViewById(R.id.calendar_pager);
  utils.loadHolidays(getResources().openRawResource(R.raw.holidays));
  utils.loadEvents(getResources().openRawResource(R.raw.events));
  digits=utils.preferredDigits(getContext());
  clockIn24=utils.clockIn24(getContext());
  coordinate=utils.getCoordinate(getContext());
  prayTimesCalculator=new PrayTimesCalculator(utils.getCalculationMethod(getContext()));
  monthViewPager.setAdapter(new CalendarAdapter(activity.getSupportFragmentManager()));
  monthViewPager.setCurrentItem(Constants.MONTHS_LIMIT / 2);
  monthViewPager.addOnPageChangeListener(this);
  owghat.setOnClickListener(this);
  today.setOnClickListener(this);
  todayIcon.setOnClickListener(this);
  georgianDate.setOnClickListener(this);
  islamicDate.setOnClickListener(this);
  shamsiDate.setOnClickListener(this);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.event_card_title));
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.today));
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.owghat_text));
  return view;
}","@Nullable @Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_calendar,container,false);
  viewPagerPosition=0;
  owghat1=(RelativeLayout)view.findViewById(R.id.owghat1);
  owghat2=(RelativeLayout)view.findViewById(R.id.owghat2);
  owghat3=(RelativeLayout)view.findViewById(R.id.owghat3);
  owghat4=(RelativeLayout)view.findViewById(R.id.owghat4);
  owghat5=(RelativeLayout)view.findViewById(R.id.owghat5);
  owghat6=(RelativeLayout)view.findViewById(R.id.owghat6);
  owghat7=(RelativeLayout)view.findViewById(R.id.owghat7);
  owghat8=(RelativeLayout)view.findViewById(R.id.owghat8);
  FragmentActivity activity=getActivity();
  georgianDate=(TextView)view.findViewById(R.id.georgian_date);
  utils.prepareTextView(activity,georgianDate);
  islamicDate=(TextView)view.findViewById(R.id.islamic_date);
  utils.prepareTextView(activity,islamicDate);
  shamsiDate=(TextView)view.findViewById(R.id.shamsi_date);
  utils.prepareTextView(activity,shamsiDate);
  weekDayName=(TextView)view.findViewById(R.id.week_day_name);
  utils.prepareTextView(activity,weekDayName);
  today=(TextView)view.findViewById(R.id.today);
  todayIcon=(AppCompatImageView)view.findViewById(R.id.today_icon);
  athan1=(TextView)view.findViewById(R.id.azan1);
  utils.prepareTextView(activity,athan1);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.azan1text));
  athan2=(TextView)view.findViewById(R.id.azan2);
  utils.prepareTextView(activity,athan2);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.azan2text));
  athan3=(TextView)view.findViewById(R.id.azan3);
  utils.prepareTextView(activity,athan3);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.azan3text));
  athan4=(TextView)view.findViewById(R.id.azan4);
  utils.prepareTextView(activity,athan4);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.azan4text));
  athan5=(TextView)view.findViewById(R.id.azan5);
  utils.prepareTextView(activity,athan5);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.azan5text));
  aftab1=(TextView)view.findViewById(R.id.aftab1);
  utils.prepareTextView(activity,aftab1);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.aftab1text));
  aftab2=(TextView)view.findViewById(R.id.aftab2);
  utils.prepareTextView(activity,aftab2);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.aftab2text));
  aftab3=(TextView)view.findViewById(R.id.aftab3);
  utils.prepareTextView(activity,aftab3);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.aftab3text));
  moreOwghat=(AppCompatImageView)view.findViewById(R.id.more_owghat);
  eventTitle=(TextView)view.findViewById(R.id.event_title);
  holidayTitle=(TextView)view.findViewById(R.id.holiday_title);
  utils.prepareTextView(activity,holidayTitle);
  owghat=(CardView)view.findViewById(R.id.owghat);
  event=(CardView)view.findViewById(R.id.event);
  monthViewPager=(ViewPager)view.findViewById(R.id.calendar_pager);
  utils.loadHolidays(getResources().openRawResource(R.raw.holidays));
  utils.loadEvents(getResources().openRawResource(R.raw.events));
  digits=utils.preferredDigits(getContext());
  clockIn24=utils.clockIn24(getContext());
  coordinate=utils.getCoordinate(getContext());
  prayTimesCalculator=new PrayTimesCalculator(utils.getCalculationMethod(getContext()));
  monthViewPager.setAdapter(new CalendarAdapter(activity.getSupportFragmentManager()));
  monthViewPager.setCurrentItem(Constants.MONTHS_LIMIT / 2);
  monthViewPager.addOnPageChangeListener(this);
  owghat.setOnClickListener(this);
  today.setOnClickListener(this);
  todayIcon.setOnClickListener(this);
  georgianDate.setOnClickListener(this);
  islamicDate.setOnClickListener(this);
  shamsiDate.setOnClickListener(this);
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.event_card_title));
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.today));
  utils.prepareShapeTextView(activity,(TextView)view.findViewById(R.id.owghat_text));
  return view;
}",0.9972451790633609
8678,"private void showEvent(PersianDate persianDate){
  String holidays=utils.getHolidayTitle(persianDate);
  String events=utils.getEventTitle(persianDate);
  event.setVisibility(View.GONE);
  holidayTitle.setVisibility(View.GONE);
  eventTitle.setVisibility(View.GONE);
  if (holidays != null) {
    holidayTitle.setText(utils.textShaper(holidays));
    holidayTitle.setVisibility(View.VISIBLE);
    event.setVisibility(View.VISIBLE);
  }
  if (events != null) {
    eventTitle.setText(events);
    eventTitle.setVisibility(View.VISIBLE);
    event.setVisibility(View.VISIBLE);
  }
}","private void showEvent(PersianDate persianDate){
  String holidays=utils.getHolidayTitle(persianDate);
  String events=utils.getEventTitle(persianDate);
  event.setVisibility(View.GONE);
  holidayTitle.setVisibility(View.GONE);
  eventTitle.setVisibility(View.GONE);
  if (holidays != null) {
    holidayTitle.setText(utils.textShaper(holidays));
    holidayTitle.setVisibility(View.VISIBLE);
    event.setVisibility(View.VISIBLE);
  }
  if (!TextUtils.isEmpty(events)) {
    eventTitle.setText(events);
    eventTitle.setVisibility(View.VISIBLE);
    event.setVisibility(View.VISIBLE);
  }
}",0.9675767918088736
8679,"public String getNextOghatTime(Context context,Clock clock,boolean changeDate){
  Coordinate coordinate=getCoordinate(context);
  if (coordinate != null) {
    char[] digits=preferredDigits(context);
    boolean clockIn24=clockIn24(context);
    if (prayTimesCalculator != null) {
      prayTimesCalculator=new PrayTimesCalculator(getCalculationMethod(context));
      changeDate=true;
    }
    if (changeDate) {
      CivilDate civilDate=DateConverter.persianToCivil(Utils.getToday());
      Calendar calendar=Calendar.getInstance();
      calendar.set(civilDate.getYear(),civilDate.getMonth() - 1,civilDate.getDayOfMonth());
      Date date=calendar.getTime();
      prayTimes=prayTimesCalculator.calculate(date,coordinate);
    }
    if (prayTimes.get(PrayTime.IMSAK).getInt() > clock.getInt()) {
      return context.getString(R.string.azan1) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.IMSAK),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.SUNRISE).getInt() > clock.getInt()) {
      return context.getString(R.string.aftab1) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.SUNRISE),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.DHUHR).getInt() > clock.getInt()) {
      return context.getString(R.string.azan2) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.DHUHR),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.ASR).getInt() > clock.getInt()) {
      return context.getString(R.string.azan3) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.ASR),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.SUNSET).getInt() > clock.getInt()) {
      return context.getString(R.string.aftab2) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.SUNSET),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.MAGHRIB).getInt() > clock.getInt()) {
      return context.getString(R.string.azan4) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.MAGHRIB),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.ISHA).getInt() > clock.getInt()) {
      return context.getString(R.string.azan5) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.ISHA),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.MIDNIGHT).getInt() > clock.getInt()) {
      return context.getString(R.string.aftab3) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.MIDNIGHT),digits,clockIn24);
    }
 else {
      return context.getString(R.string.azan1) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.IMSAK),digits,clockIn24);
    }
  }
 else   return null;
}","public String getNextOghatTime(Context context,Clock clock,boolean changeDate){
  Coordinate coordinate=getCoordinate(context);
  if (coordinate != null) {
    char[] digits=preferredDigits(context);
    boolean clockIn24=clockIn24(context);
    if (prayTimesCalculator == null) {
      prayTimesCalculator=new PrayTimesCalculator(getCalculationMethod(context));
      changeDate=true;
    }
    if (changeDate) {
      CivilDate civilDate=DateConverter.persianToCivil(Utils.getToday());
      Calendar calendar=Calendar.getInstance();
      calendar.set(civilDate.getYear(),civilDate.getMonth() - 1,civilDate.getDayOfMonth());
      Date date=calendar.getTime();
      prayTimes=prayTimesCalculator.calculate(date,coordinate);
    }
    if (prayTimes.get(PrayTime.IMSAK).getInt() > clock.getInt()) {
      return context.getString(R.string.azan1) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.IMSAK),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.SUNRISE).getInt() > clock.getInt()) {
      return context.getString(R.string.aftab1) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.SUNRISE),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.DHUHR).getInt() > clock.getInt()) {
      return context.getString(R.string.azan2) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.DHUHR),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.ASR).getInt() > clock.getInt()) {
      return context.getString(R.string.azan3) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.ASR),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.SUNSET).getInt() > clock.getInt()) {
      return context.getString(R.string.aftab2) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.SUNSET),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.MAGHRIB).getInt() > clock.getInt()) {
      return context.getString(R.string.azan4) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.MAGHRIB),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.ISHA).getInt() > clock.getInt()) {
      return context.getString(R.string.azan5) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.ISHA),digits,clockIn24);
    }
 else     if (prayTimes.get(PrayTime.MIDNIGHT).getInt() > clock.getInt()) {
      return context.getString(R.string.aftab3) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.MIDNIGHT),digits,clockIn24);
    }
 else {
      return context.getString(R.string.azan1) + ""String_Node_Str"" + getPersianFormattedClock(prayTimes.get(PrayTime.IMSAK),digits,clockIn24);
    }
  }
 else   return null;
}",0.9996296296296296
8680,"public void changeLocale(String localeCode){
  String fileSuffix=(!TextUtils.isEmpty(localeCode) || localeCode.matches(""String_Node_Str"")) ? (""String_Node_Str"" + localeCode) : ""String_Node_Str"";
  try {
    InputStream pis=context.getAssets().open(""String_Node_Str"" + CALENDAR_BUNDLE + fileSuffix+ ""String_Node_Str"");
    ResourceBundle bundle=new PropertyResourceBundle(pis);
    for (    LocaleData.PersianMonthNames name : LocaleData.PersianMonthNames.values()) {
      String stringName=name.toString();
      cache.put(stringName,getUTF8(bundle.getString(stringName)));
    }
    for (    LocaleData.CivilMonthNames name : LocaleData.CivilMonthNames.values()) {
      String stringName=name.toString();
      cache.put(stringName,getUTF8(bundle.getString(stringName)));
    }
    for (    LocaleData.IslamicMonthNames name : LocaleData.IslamicMonthNames.values()) {
      String stringName=name.toString();
      cache.put(stringName,getUTF8(bundle.getString(stringName)));
    }
    for (    LocaleData.WeekDayNames name : LocaleData.WeekDayNames.values()) {
      String stringName=name.toString();
      cache.put(stringName,getUTF8(bundle.getString(stringName)));
    }
    cache.put(IMSAK,getUTF8(bundle.getString(IMSAK)));
    cache.put(SUNRISE,getUTF8(bundle.getString(SUNRISE)));
    cache.put(DHUHR,getUTF8(bundle.getString(DHUHR)));
    cache.put(ASR,getUTF8(bundle.getString(ASR)));
    cache.put(SUNSET,getUTF8(bundle.getString(SUNSET)));
    cache.put(MAGHRIB,getUTF8(bundle.getString(MAGHRIB)));
    cache.put(ISHA,getUTF8(bundle.getString(ISHA)));
    cache.put(MIDNIGHT,getUTF8(bundle.getString(MIDNIGHT)));
    cache.put(TODAY,getUTF8(bundle.getString(TODAY)));
    cache.put(EQUALS_WITH,getUTF8(bundle.getString(EQUALS_WITH)));
    cache.put(DAY,getUTF8(bundle.getString(DAY)));
    cache.put(MONTH,getUTF8(bundle.getString(MONTH)));
    cache.put(YEAR,getUTF8(bundle.getString(YEAR)));
    cache.put(HIJRI_SHAMSI,getUTF8(bundle.getString(HIJRI_SHAMSI)));
    cache.put(HIJRI_QAMARI,getUTF8(bundle.getString(HIJRI_QAMARI)));
    cache.put(GEORGIAN,getUTF8(bundle.getString(GEORGIAN)));
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","public void changeLocale(String localeCode){
  String fileSuffix=(!TextUtils.isEmpty(localeCode) && localeCode.matches(""String_Node_Str"")) ? (""String_Node_Str"" + localeCode) : ""String_Node_Str"";
  try {
    InputStream pis=context.getAssets().open(""String_Node_Str"" + CALENDAR_BUNDLE + fileSuffix+ ""String_Node_Str"");
    ResourceBundle bundle=new PropertyResourceBundle(pis);
    for (    LocaleData.PersianMonthNames name : LocaleData.PersianMonthNames.values()) {
      String stringName=name.toString();
      cache.put(stringName,getUTF8(bundle.getString(stringName)));
    }
    for (    LocaleData.CivilMonthNames name : LocaleData.CivilMonthNames.values()) {
      String stringName=name.toString();
      cache.put(stringName,getUTF8(bundle.getString(stringName)));
    }
    for (    LocaleData.IslamicMonthNames name : LocaleData.IslamicMonthNames.values()) {
      String stringName=name.toString();
      cache.put(stringName,getUTF8(bundle.getString(stringName)));
    }
    for (    LocaleData.WeekDayNames name : LocaleData.WeekDayNames.values()) {
      String stringName=name.toString();
      cache.put(stringName,getUTF8(bundle.getString(stringName)));
    }
    cache.put(IMSAK,getUTF8(bundle.getString(IMSAK)));
    cache.put(SUNRISE,getUTF8(bundle.getString(SUNRISE)));
    cache.put(DHUHR,getUTF8(bundle.getString(DHUHR)));
    cache.put(ASR,getUTF8(bundle.getString(ASR)));
    cache.put(SUNSET,getUTF8(bundle.getString(SUNSET)));
    cache.put(MAGHRIB,getUTF8(bundle.getString(MAGHRIB)));
    cache.put(ISHA,getUTF8(bundle.getString(ISHA)));
    cache.put(MIDNIGHT,getUTF8(bundle.getString(MIDNIGHT)));
    cache.put(TODAY,getUTF8(bundle.getString(TODAY)));
    cache.put(EQUALS_WITH,getUTF8(bundle.getString(EQUALS_WITH)));
    cache.put(DAY,getUTF8(bundle.getString(DAY)));
    cache.put(MONTH,getUTF8(bundle.getString(MONTH)));
    cache.put(YEAR,getUTF8(bundle.getString(YEAR)));
    cache.put(HIJRI_SHAMSI,getUTF8(bundle.getString(HIJRI_SHAMSI)));
    cache.put(HIJRI_QAMARI,getUTF8(bundle.getString(HIJRI_QAMARI)));
    cache.put(GEORGIAN,getUTF8(bundle.getString(GEORGIAN)));
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9990829894543788
8681,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.calendar_month,container,false);
  int offset=getArguments().getInt(""String_Node_Str"");
  List<Day> days=utils.getDays(getContext(),offset);
  char[] digits=utils.preferredDigits(getActivity());
  prev=(IconTextView)view.findViewById(R.id.prev);
  next=(IconTextView)view.findViewById(R.id.next);
  prev.setOnClickListener(this);
  next.setOnClickListener(this);
  PersianDate persianDate=Utils.getToday();
  int month=persianDate.getMonth() - offset;
  month-=1;
  int year=persianDate.getYear();
  year=year + (month / 12);
  month=month % 12;
  if (month < 0) {
    year-=1;
    month+=12;
  }
  month+=1;
  persianDate.setMonth(month);
  persianDate.setYear(year);
  persianDate.setDayOfMonth(1);
  TextView currentMonthTextView=(TextView)view.findViewById(R.id.currentMonthTextView);
  currentMonthTextView.setText(Utils.textShaper(utils.getMonthName(persianDate)));
  TextView currentYearTextView=(TextView)view.findViewById(R.id.currentYearTextView);
  currentYearTextView.setText(Utils.formatNumber(persianDate.getYear(),digits));
  recyclerView=(RecyclerView)view.findViewById(R.id.RecyclerView);
  recyclerView.setHasFixedSize(true);
  layoutManager=new GridLayoutManager(getContext(),7);
  recyclerView.setLayoutManager(layoutManager);
  adapter=new MonthAdapter(getActivity(),this,days);
  recyclerView.setAdapter(adapter);
  calendarMainFragment=(CalendarMainFragment)getActivity().getSupportFragmentManager().findFragmentByTag(""String_Node_Str"");
  calendarMainFragment.selectDay(Utils.getToday());
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.calendar_month,container,false);
  int offset=getArguments().getInt(""String_Node_Str"");
  List<Day> days=utils.getDays(getContext(),offset);
  char[] digits=utils.preferredDigits(getActivity());
  prev=(IconTextView)view.findViewById(R.id.prev);
  next=(IconTextView)view.findViewById(R.id.next);
  prev.setOnClickListener(this);
  next.setOnClickListener(this);
  PersianDate persianDate=Utils.getToday();
  int month=persianDate.getMonth() - offset;
  month-=1;
  int year=persianDate.getYear();
  year=year + (month / 12);
  month=month % 12;
  if (month < 0) {
    year-=1;
    month+=12;
  }
  month+=1;
  persianDate.setMonth(month);
  persianDate.setYear(year);
  persianDate.setDayOfMonth(1);
  TextView currentMonthTextView=(TextView)view.findViewById(R.id.currentMonthTextView);
  currentMonthTextView.setText(Utils.textShaper(utils.getMonthName(persianDate)));
  TextView currentYearTextView=(TextView)view.findViewById(R.id.currentYearTextView);
  currentYearTextView.setText(Utils.formatNumber(persianDate.getYear(),digits));
  recyclerView=(RecyclerView)view.findViewById(R.id.RecyclerView);
  recyclerView.setHasFixedSize(true);
  layoutManager=new GridLayoutManager(getContext(),7);
  recyclerView.setLayoutManager(layoutManager);
  adapter=new MonthAdapter(getActivity(),this,days);
  recyclerView.setAdapter(adapter);
  calendarMainFragment=(CalendarMainFragment)getActivity().getSupportFragmentManager().findFragmentByTag(""String_Node_Str"");
  if (calendarMainFragment != null) {
    calendarMainFragment.selectDay(Utils.getToday());
  }
  return view;
}",0.9870283018867924
8682,"@Override public void onClick(View view){
  mainActivity.onClickItem(view,getAdapterPosition());
  selectedItem=getAdapterPosition();
  notifyDataSetChanged();
}","@Override public void onClick(View view){
  mainActivity.onClickItem(getAdapterPosition());
  selectedItem=getAdapterPosition();
  notifyDataSetChanged();
}",0.9842271293375394
8683,"@Override protected void onCreate(Bundle savedInstanceState){
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  startService(new Intent(this,ApplicationService.class));
  setContentView(R.layout.activity_main);
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    Window w=getWindow();
    w.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
  }
 else {
    toolbar.setPadding(0,0,0,0);
  }
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  String key=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  int theme=R.style.LightTheme;
  if (key.equals(""String_Node_Str"")) {
    theme=R.style.LightTheme;
  }
 else   if (key.equals(""String_Node_Str"")) {
    theme=R.style.DarkTheme;
  }
  setTheme(theme);
  RecyclerView navigation=(RecyclerView)findViewById(R.id.navigation_view);
  navigation.setHasFixedSize(true);
  DrawerAdapter adapter=new DrawerAdapter(this);
  navigation.setAdapter(adapter);
  RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
  navigation.setLayoutManager(layoutManager);
  drawerLayout=(DrawerLayout)findViewById(R.id.drawer);
  final View appMainView=findViewById(R.id.app_main_layout);
  ActionBarDrawerToggle drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer,R.string.closeDrawer){
    int slidingDirection=+1;
{
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        if (isRTL())         slidingDirection=-1;
      }
    }
    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) private boolean isRTL(){
      return getResources().getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;
    }
    @Override public void onDrawerOpened(    View drawerView){
      super.onDrawerOpened(drawerView);
    }
    @Override public void onDrawerClosed(    View drawerView){
      super.onDrawerClosed(drawerView);
    }
    @Override public void onDrawerSlide(    View drawerView,    float slideOffset){
      super.onDrawerSlide(drawerView,slideOffset);
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        slidingAnimation(drawerView,slideOffset);
      }
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB) private void slidingAnimation(    View drawerView,    float slideOffset){
      appMainView.setTranslationX(slideOffset * drawerView.getWidth() * slidingDirection);
      drawerLayout.bringChildToFront(drawerView);
      drawerLayout.requestLayout();
    }
  }
;
  drawerLayout.setDrawerListener(drawerToggle);
  drawerToggle.syncState();
  FragmentManager manager=getSupportFragmentManager();
  FragmentTransaction transaction=manager.beginTransaction();
  transaction.replace(R.id.fragment_holder,new CalendarMainFragment(),""String_Node_Str"");
  transaction.commit();
}","@Override protected void onCreate(Bundle savedInstanceState){
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  startService(new Intent(this,ApplicationService.class));
  setContentView(R.layout.activity_main);
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    Window w=getWindow();
    w.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
  }
 else {
    toolbar.setPadding(0,0,0,0);
  }
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  String key=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  int theme=R.style.LightTheme;
  if (key.equals(""String_Node_Str"")) {
    theme=R.style.LightTheme;
  }
 else   if (key.equals(""String_Node_Str"")) {
    theme=R.style.DarkTheme;
  }
  setTheme(theme);
  RecyclerView navigation=(RecyclerView)findViewById(R.id.navigation_view);
  navigation.setHasFixedSize(true);
  DrawerAdapter adapter=new DrawerAdapter(this);
  navigation.setAdapter(adapter);
  RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
  navigation.setLayoutManager(layoutManager);
  drawerLayout=(DrawerLayout)findViewById(R.id.drawer);
  final View appMainView=findViewById(R.id.app_main_layout);
  ActionBarDrawerToggle drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer,R.string.closeDrawer){
    int slidingDirection=+1;
{
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        if (isRTL())         slidingDirection=-1;
      }
    }
    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) private boolean isRTL(){
      return getResources().getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;
    }
    @Override public void onDrawerOpened(    View drawerView){
      super.onDrawerOpened(drawerView);
    }
    @Override public void onDrawerClosed(    View drawerView){
      super.onDrawerClosed(drawerView);
    }
    @Override public void onDrawerSlide(    View drawerView,    float slideOffset){
      super.onDrawerSlide(drawerView,slideOffset);
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        slidingAnimation(drawerView,slideOffset);
      }
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB) private void slidingAnimation(    View drawerView,    float slideOffset){
      appMainView.setTranslationX(slideOffset * drawerView.getWidth() * slidingDirection);
      drawerLayout.bringChildToFront(drawerView);
      drawerLayout.requestLayout();
    }
  }
;
  drawerLayout.setDrawerListener(drawerToggle);
  drawerToggle.syncState();
  getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new CalendarMainFragment(),""String_Node_Str"").commit();
}",0.9791917454858126
8684,"public void onClickItem(View v,int position){
  selectItem(position);
}","public void onClickItem(int position){
  selectItem(position);
}",0.9481481481481482
8685,"public void selectItem(int position){
switch (position) {
case CALENDAR:
    if (menuPosition != CALENDAR) {
      getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new CalendarMainFragment(),""String_Node_Str"").addToBackStack(null).commit();
      menuPosition=CALENDAR;
    }
  break;
case CONVERTER:
if (menuPosition != CONVERTER) {
  getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new ConverterFragment()).addToBackStack(null).commit();
  menuPosition=CONVERTER;
}
break;
case COMPASS:
if (menuPosition != COMPASS) {
getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new CompassFragment()).addToBackStack(null).commit();
menuPosition=COMPASS;
}
break;
case PREFERENCE:
if (menuPosition != PREFERENCE) {
getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new ApplicationPreferenceFragment()).addToBackStack(null).commit();
menuPosition=PREFERENCE;
}
break;
case ABOUT:
if (menuPosition != ABOUT) {
getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new AboutFragment()).addToBackStack(null).commit();
menuPosition=ABOUT;
}
break;
case EXIT:
finish();
break;
}
drawerLayout.closeDrawers();
}","public void selectItem(int position){
switch (position) {
case CALENDAR:
    if (menuPosition != CALENDAR) {
      getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new CalendarMainFragment(),""String_Node_Str"").commit();
      menuPosition=CALENDAR;
    }
  break;
case CONVERTER:
if (menuPosition != CONVERTER) {
  getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new ConverterFragment()).commit();
  menuPosition=CONVERTER;
}
break;
case COMPASS:
if (menuPosition != COMPASS) {
getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new CompassFragment()).commit();
menuPosition=COMPASS;
}
break;
case PREFERENCE:
if (menuPosition != PREFERENCE) {
getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new ApplicationPreferenceFragment()).commit();
menuPosition=PREFERENCE;
}
break;
case ABOUT:
if (menuPosition != ABOUT) {
getSupportFragmentManager().beginTransaction().replace(R.id.fragment_holder,new AboutFragment()).commit();
menuPosition=ABOUT;
}
break;
case EXIT:
finish();
break;
}
drawerLayout.closeDrawers();
}",0.9551473729175566
8686,"private void setMonth(){
  int posithon=viewPager.getCurrentItem();
  int offset=posithon - CalendarMainFragment.MONTHS_LIMIT / 2;
  PersianDate persianDate=Utils.getToday();
  int month=persianDate.getMonth() - offset;
  month-=1;
  month=month % 12;
  if (month < 0) {
    month+=12;
  }
  month+=1;
  currentMounth=month;
}","private void setMonth(){
  int posithon=viewPager.getCurrentItem();
  int offset=posithon - CalendarMainFragment.MONTHS_LIMIT / 2;
  PersianDate persianDate=Utils.getToday();
  int month=persianDate.getMonth() - offset;
  month-=1;
  month=month % 12;
  if (month < 0) {
    month+=12;
  }
  month+=1;
}",0.9634340222575516
8687,"@Nullable @Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_new_calendar,container,false);
  utils.loadHolidays(getResources().openRawResource(R.raw.holidays));
  utils.loadLanguageFromSettings(getContext());
  digits=utils.preferredDigits(getContext());
  clockIn24=utils.clockIn24(getContext());
  coord=utils.getCoordinate(getContext());
  ptc=new PrayTimesCalculator(utils.getCalculationMethod(getContext()));
  toolbar=(Toolbar)getActivity().findViewById(R.id.toolbar);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    argbEvaluator=new ArgbEvaluator();
  }
  viewPager=(ViewPager)view.findViewById(R.id.calendar_pager);
  viewPager.setAdapter(new CalendarAdapter(getActivity().getSupportFragmentManager()));
  viewPager.setCurrentItem(MONTHS_LIMIT / 2);
  viewPager.addOnPageChangeListener(this);
  infoDay=(CardView)view.findViewById(R.id.info_day);
  owghat=(CardView)view.findViewById(R.id.owghat);
  event=(CardView)view.findViewById(R.id.event);
  infoDay.setOnClickListener(this);
  owghat.setOnClickListener(this);
  owghat1=(LinearLayoutCompat)view.findViewById(R.id.owghat1);
  owghat2=(LinearLayoutCompat)view.findViewById(R.id.owghat2);
  owghat3=(LinearLayoutCompat)view.findViewById(R.id.owghat3);
  owghat4=(LinearLayoutCompat)view.findViewById(R.id.owghat4);
  owghat5=(LinearLayoutCompat)view.findViewById(R.id.owghat5);
  owghat6=(LinearLayoutCompat)view.findViewById(R.id.owghat6);
  owghat7=(LinearLayoutCompat)view.findViewById(R.id.owghat7);
  owghat8=(LinearLayoutCompat)view.findViewById(R.id.owghat8);
  divider1=view.findViewById(R.id.div1);
  divider2=view.findViewById(R.id.div2);
  divider3=view.findViewById(R.id.div3);
  divider4=view.findViewById(R.id.div4);
  divider5=view.findViewById(R.id.div5);
  divider6=view.findViewById(R.id.div6);
  divider7=view.findViewById(R.id.div7);
  miladiDate=(TextView)view.findViewById(R.id.miladi_date);
  ghamariDate=(TextView)view.findViewById(R.id.ghamari_date);
  weekDayName=(TextView)view.findViewById(R.id.week_day_name);
  shamsiDate=(TextView)view.findViewById(R.id.shamsi_date);
  miladiDate=(TextView)view.findViewById(R.id.miladi_date);
  ghamariDate=(TextView)view.findViewById(R.id.ghamari_date);
  today=(TextView)view.findViewById(R.id.today);
  today.setOnClickListener(this);
  azan1=(TextView)view.findViewById(R.id.azan1);
  azan2=(TextView)view.findViewById(R.id.azan2);
  azan3=(TextView)view.findViewById(R.id.azan3);
  azan4=(TextView)view.findViewById(R.id.azan4);
  azan5=(TextView)view.findViewById(R.id.azan5);
  aftab1=(TextView)view.findViewById(R.id.aftab1);
  aftab2=(TextView)view.findViewById(R.id.aftab2);
  aftab3=(TextView)view.findViewById(R.id.aftab3);
  eventTitle=(TextView)view.findViewById(R.id.event_title);
  setMonth();
  return view;
}","@Nullable @Override public View onCreateView(LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_new_calendar,container,false);
  owghat1=(LinearLayoutCompat)view.findViewById(R.id.owghat1);
  owghat2=(LinearLayoutCompat)view.findViewById(R.id.owghat2);
  owghat3=(LinearLayoutCompat)view.findViewById(R.id.owghat3);
  owghat4=(LinearLayoutCompat)view.findViewById(R.id.owghat4);
  owghat5=(LinearLayoutCompat)view.findViewById(R.id.owghat5);
  owghat6=(LinearLayoutCompat)view.findViewById(R.id.owghat6);
  owghat7=(LinearLayoutCompat)view.findViewById(R.id.owghat7);
  owghat8=(LinearLayoutCompat)view.findViewById(R.id.owghat8);
  divider1=view.findViewById(R.id.div1);
  divider2=view.findViewById(R.id.div2);
  divider3=view.findViewById(R.id.div3);
  divider4=view.findViewById(R.id.div4);
  divider5=view.findViewById(R.id.div5);
  divider6=view.findViewById(R.id.div6);
  divider7=view.findViewById(R.id.div7);
  miladiDate=(TextView)view.findViewById(R.id.miladi_date);
  ghamariDate=(TextView)view.findViewById(R.id.ghamari_date);
  weekDayName=(TextView)view.findViewById(R.id.week_day_name);
  shamsiDate=(TextView)view.findViewById(R.id.shamsi_date);
  miladiDate=(TextView)view.findViewById(R.id.miladi_date);
  ghamariDate=(TextView)view.findViewById(R.id.ghamari_date);
  today=(TextView)view.findViewById(R.id.today);
  azan1=(TextView)view.findViewById(R.id.azan1);
  azan2=(TextView)view.findViewById(R.id.azan2);
  azan3=(TextView)view.findViewById(R.id.azan3);
  azan4=(TextView)view.findViewById(R.id.azan4);
  azan5=(TextView)view.findViewById(R.id.azan5);
  aftab1=(TextView)view.findViewById(R.id.aftab1);
  aftab2=(TextView)view.findViewById(R.id.aftab2);
  aftab3=(TextView)view.findViewById(R.id.aftab3);
  eventTitle=(TextView)view.findViewById(R.id.event_title);
  infoDay=(CardView)view.findViewById(R.id.info_day);
  owghat=(CardView)view.findViewById(R.id.owghat);
  event=(CardView)view.findViewById(R.id.event);
  viewPager=(ViewPager)view.findViewById(R.id.calendar_pager);
  utils.loadHolidays(getResources().openRawResource(R.raw.holidays));
  utils.loadLanguageFromSettings(getContext());
  digits=utils.preferredDigits(getContext());
  clockIn24=utils.clockIn24(getContext());
  coord=utils.getCoordinate(getContext());
  ptc=new PrayTimesCalculator(utils.getCalculationMethod(getContext()));
  viewPager.setAdapter(new CalendarAdapter(getActivity().getSupportFragmentManager()));
  viewPager.setCurrentItem(MONTHS_LIMIT / 2);
  viewPager.addOnPageChangeListener(this);
  infoDay.setOnClickListener(this);
  owghat.setOnClickListener(this);
  today.setOnClickListener(this);
  setMonth();
  return view;
}",0.3018465909090909
8688,"@TargetApi(Build.VERSION_CODES.HONEYCOMB) @Override public void onPageScrolled(int position,float positionOffset,int positionOffsetPixels){
  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB)   return;
  int color;
}","@TargetApi(Build.VERSION_CODES.HONEYCOMB) @Override public void onPageScrolled(int position,float positionOffset,int positionOffsetPixels){
}",0.7704918032786885
8689,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.calendar_month,container,false);
  int offset=getArguments().getInt(""String_Node_Str"");
  List<Day> days=utils.getDays(getContext(),offset);
  char[] digits=utils.preferredDigits(getActivity());
  prev=(IconTextView)view.findViewById(R.id.prev);
  next=(IconTextView)view.findViewById(R.id.next);
  prev.setOnClickListener(this);
  next.setOnClickListener(this);
  PersianDate persianDate=Utils.getToday();
  int month=persianDate.getMonth() - offset;
  month-=1;
  int year=persianDate.getYear();
  year=year + (month / 12);
  month=month % 12;
  if (month < 0) {
    year-=1;
    month+=12;
  }
  month+=1;
  persianDate.setMonth(month);
  persianDate.setYear(year);
  persianDate.setDayOfMonth(1);
  TextView currentMonthTextView=(TextView)view.findViewById(R.id.currentMonthTextView);
  currentMonthTextView.setText(Utils.textShaper(utils.getMonthName(persianDate)));
  TextView currentYearTextView=(TextView)view.findViewById(R.id.currentYearTextView);
  currentYearTextView.setText(Utils.formatNumber(persianDate.getYear(),digits));
  recyclerView=(RecyclerView)view.findViewById(R.id.RecyclerView);
  recyclerView.setHasFixedSize(true);
  layoutManager=new GridLayoutManager(getContext(),7);
  recyclerView.setLayoutManager(layoutManager);
  adapter=new MonthAdapter(getActivity(),this,days);
  recyclerView.setAdapter(adapter);
  calendarMainFragment.selectDay(Utils.getToday());
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.calendar_month,container,false);
  int offset=getArguments().getInt(""String_Node_Str"");
  List<Day> days=utils.getDays(getContext(),offset);
  char[] digits=utils.preferredDigits(getActivity());
  prev=(IconTextView)view.findViewById(R.id.prev);
  next=(IconTextView)view.findViewById(R.id.next);
  prev.setOnClickListener(this);
  next.setOnClickListener(this);
  PersianDate persianDate=Utils.getToday();
  int month=persianDate.getMonth() - offset;
  month-=1;
  int year=persianDate.getYear();
  year=year + (month / 12);
  month=month % 12;
  if (month < 0) {
    year-=1;
    month+=12;
  }
  month+=1;
  persianDate.setMonth(month);
  persianDate.setYear(year);
  persianDate.setDayOfMonth(1);
  TextView currentMonthTextView=(TextView)view.findViewById(R.id.currentMonthTextView);
  currentMonthTextView.setText(Utils.textShaper(utils.getMonthName(persianDate)));
  TextView currentYearTextView=(TextView)view.findViewById(R.id.currentYearTextView);
  currentYearTextView.setText(Utils.formatNumber(persianDate.getYear(),digits));
  recyclerView=(RecyclerView)view.findViewById(R.id.RecyclerView);
  recyclerView.setHasFixedSize(true);
  layoutManager=new GridLayoutManager(getContext(),7);
  recyclerView.setLayoutManager(layoutManager);
  adapter=new MonthAdapter(getActivity(),this,days);
  recyclerView.setAdapter(adapter);
  return view;
}",0.9829284307288249
8690,"public void addListener(CalendarMainFragment calendarMainFragment){
  this.calendarMainFragment=calendarMainFragment;
}","public void addListener(CalendarMainFragment calendarMainFragment){
  this.calendarMainFragment=calendarMainFragment;
  this.calendarMainFragment.selectDay(Utils.getToday());
}",0.8067796610169492
8691,"public ViewHolder(View itemView,int ViewType){
  super(itemView);
  itemView.setClickable(true);
  itemView.setOnClickListener(this);
  if (ViewType == TYPE_ITEM) {
    itemTitle=(TextView)itemView.findViewById(R.id.itemTitle);
    itemIcon=(IconTextView)itemView.findViewById(R.id.ItemIcon);
    backGrand=itemView.findViewById(R.id.back_grand);
  }
}","public ViewHolder(View itemView,int ViewType){
  super(itemView);
  itemView.setClickable(true);
  itemView.setOnClickListener(this);
  if (ViewType == TYPE_ITEM) {
    itemTitle=(TextView)itemView.findViewById(R.id.itemTitle);
    itemIcon=(IconTextView)itemView.findViewById(R.id.ItemIcon);
    background=itemView.findViewById(R.id.background);
  }
}",0.9843971631205674
8692,"@Override public void onBindViewHolder(DrawerAdapter.ViewHolder holder,int position){
  if (!isPositionHeader(position)) {
    holder.itemTitle.setText(drawerTitles[position - 1]);
    holder.itemIcon.setText(drawerIcon[position - 1]);
    if (selectedItem == position) {
      holder.backGrand.setVisibility(View.VISIBLE);
    }
 else {
      holder.backGrand.setVisibility(View.GONE);
    }
  }
  holder.itemView.setSelected(false);
}","@Override public void onBindViewHolder(DrawerAdapter.ViewHolder holder,int position){
  if (!isPositionHeader(position)) {
    holder.itemTitle.setText(drawerTitles[position - 1]);
    holder.itemIcon.setText(drawerIcon[position - 1]);
    if (selectedItem == position) {
      holder.background.setVisibility(View.VISIBLE);
    }
 else {
      holder.background.setVisibility(View.GONE);
    }
  }
  holder.itemView.setSelected(false);
}",0.9839816933638444
8693,"@Override public void onCreatePreferences(Bundle bundle,String s){
  addPreferencesFromResource(R.xml.preferences);
  LocationPreferencesChangeListener prefChangeListener=new LocationPreferencesChangeListener();
  categoryAthan=findPreference(""String_Node_Str"");
  prefLocation=findPreference(""String_Node_Str"");
  prefLatitude=findPreference(""String_Node_Str"");
  prefLongitude=findPreference(""String_Node_Str"");
  prefLocation.setOnPreferenceChangeListener(prefChangeListener);
  prefLatitude.setOnPreferenceChangeListener(prefChangeListener);
  prefLongitude.setOnPreferenceChangeListener(prefChangeListener);
  updateAthanPreferencesState(null,null);
  loadFonts(getActivity(),(ListPreference)findPreference(""String_Node_Str""));
}","@Override public void onCreatePreferences(Bundle bundle,String s){
  prefs=PreferenceManager.getDefaultSharedPreferences(getContext());
  locationName=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  String strLat=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  String strLng=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  latitude=TextUtils.isEmpty(strLat) ? 0 : Double.parseDouble(strLat);
  longitude=TextUtils.isEmpty(strLng) ? 0 : Double.parseDouble(strLng);
  addPreferencesFromResource(R.xml.preferences);
  LocationPreferencesChangeListener prefChangeListener=new LocationPreferencesChangeListener();
  categoryAthan=findPreference(""String_Node_Str"");
  prefLocation=findPreference(""String_Node_Str"");
  prefLatitude=findPreference(""String_Node_Str"");
  prefLongitude=findPreference(""String_Node_Str"");
  prefLocation.setOnPreferenceChangeListener(prefChangeListener);
  prefLatitude.setOnPreferenceChangeListener(prefChangeListener);
  prefLongitude.setOnPreferenceChangeListener(prefChangeListener);
  updateAthanPreferencesState(null,null);
  loadFonts(getContext().getApplicationContext(),(ListPreference)findPreference(""String_Node_Str""));
}",0.7604602510460251
8694,"@Override protected void onCreate(Bundle savedInstanceState){
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  startService(new Intent(this,ApplicationService.class));
  setContentView(R.layout.activity_main);
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    Window w=getWindow();
    w.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    toolbar.setPadding(0,48,0,0);
  }
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  String key=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  int theme=R.style.LightTheme;
  if (key.equals(""String_Node_Str"")) {
    theme=R.style.LightTheme;
  }
 else   if (key.equals(""String_Node_Str"")) {
    theme=R.style.DarkTheme;
  }
  setTheme(theme);
  toolbar.setBackgroundColor(getResources().getColor(R.color.first_row_background_color));
  RecyclerView navigation=(RecyclerView)findViewById(R.id.navigation_view);
  navigation.setHasFixedSize(true);
  DrawerAdapter adapter=new DrawerAdapter(this,this);
  navigation.setAdapter(adapter);
  RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
  navigation.setLayoutManager(layoutManager);
  drawerLayout=(DrawerLayout)findViewById(R.id.drawer);
  final View appMainView=findViewById(R.id.app_main_layout);
  ActionBarDrawerToggle drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer,R.string.closeDrawer){
    int slidingDirection=+1;
{
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        if (isRTL())         slidingDirection=-1;
      }
    }
    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) private boolean isRTL(){
      return getResources().getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;
    }
    @Override public void onDrawerOpened(    View drawerView){
      super.onDrawerOpened(drawerView);
    }
    @Override public void onDrawerClosed(    View drawerView){
      super.onDrawerClosed(drawerView);
    }
    @Override public void onDrawerSlide(    View drawerView,    float slideOffset){
      super.onDrawerSlide(drawerView,slideOffset);
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        slidingAnimation(drawerView,slideOffset);
      }
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB) private void slidingAnimation(    View drawerView,    float slideOffset){
      appMainView.setTranslationX(slideOffset * drawerView.getWidth() * slidingDirection);
      drawerLayout.bringChildToFront(drawerView);
      drawerLayout.requestLayout();
    }
  }
;
  drawerLayout.setDrawerListener(drawerToggle);
  drawerToggle.syncState();
  FragmentManager manager=getSupportFragmentManager();
  FragmentTransaction transaction=manager.beginTransaction();
  transaction.replace(R.id.fragment_holder,new CalendarFragment());
  transaction.commit();
}","@Override protected void onCreate(Bundle savedInstanceState){
  requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  startService(new Intent(this,ApplicationService.class));
  setContentView(R.layout.activity_main);
  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);
  setSupportActionBar(toolbar);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    Window w=getWindow();
    w.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    toolbar.setPadding(0,48,0,0);
  }
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(this);
  String key=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  int theme=R.style.LightTheme;
  if (key.equals(""String_Node_Str"")) {
    theme=R.style.LightTheme;
  }
 else   if (key.equals(""String_Node_Str"")) {
    theme=R.style.DarkTheme;
  }
  setTheme(theme);
  toolbar.setBackgroundColor(getResources().getColor(R.color.first_row_background_color));
  RecyclerView navigation=(RecyclerView)findViewById(R.id.navigation_view);
  navigation.setHasFixedSize(true);
  DrawerAdapter adapter=new DrawerAdapter(this,this);
  navigation.setAdapter(adapter);
  RecyclerView.LayoutManager layoutManager=new LinearLayoutManager(this);
  navigation.setLayoutManager(layoutManager);
  drawerLayout=(DrawerLayout)findViewById(R.id.drawer);
  final View appMainView=findViewById(R.id.app_main_layout);
  ActionBarDrawerToggle drawerToggle=new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.openDrawer,R.string.closeDrawer){
    int slidingDirection=+1;
{
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
        if (isRTL())         slidingDirection=-1;
      }
    }
    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) private boolean isRTL(){
      return getResources().getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;
    }
    @Override public void onDrawerOpened(    View drawerView){
      super.onDrawerOpened(drawerView);
    }
    @Override public void onDrawerClosed(    View drawerView){
      super.onDrawerClosed(drawerView);
    }
    @Override public void onDrawerSlide(    View drawerView,    float slideOffset){
      super.onDrawerSlide(drawerView,slideOffset);
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        slidingAnimation(drawerView,slideOffset);
      }
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB) private void slidingAnimation(    View drawerView,    float slideOffset){
      appMainView.setTranslationX(slideOffset * drawerView.getWidth() * slidingDirection);
      drawerLayout.bringChildToFront(drawerView);
      drawerLayout.requestLayout();
    }
  }
;
  drawerLayout.setDrawerListener(drawerToggle);
  drawerToggle.syncState();
  FragmentManager manager=getSupportFragmentManager();
  FragmentTransaction transaction=manager.beginTransaction();
  transaction.replace(R.id.fragment_holder,new CalendarFragment());
  transaction.commit();
}",0.7654566550638157
8695,"public Uri getAthanUri(Context context){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  String athanSoundUri=prefs.getString(""String_Node_Str"",""String_Node_Str"" + context.getPackageName() + ""String_Node_Str""+ R.raw.abdulbasit);
  return Uri.parse(athanSoundUri);
}","public Uri getAthanUri(Context context){
  String defaultSoundUri=""String_Node_Str"" + context.getPackageName() + ""String_Node_Str""+ R.raw.abdulbasit;
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  String athanSoundUri=prefs.getString(""String_Node_Str"",defaultSoundUri);
  if (TextUtils.isEmpty(athanSoundUri))   athanSoundUri=defaultSoundUri;
  return Uri.parse(athanSoundUri);
}",0.6192468619246861
8696,"public void setAlarm(Context context,long triggerInMillis){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  String valAthanGap=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  long athanGap=TextUtils.isEmpty(valAthanGap) ? 0 : Long.parseLong(valAthanGap);
  Calendar triggerTime=Calendar.getInstance();
  triggerTime.setTimeInMillis(triggerInMillis - TimeUnit.SECONDS.toMillis(athanGap));
  AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  if (!triggerTime.before(Calendar.getInstance())) {
    triggerTime.set(Calendar.SECOND,0);
    Log.d(TAG,""String_Node_Str"" + triggerTime.getTime());
    Intent intent=new Intent(context,AlarmReceiver.class);
    PendingIntent pendingIntent=PendingIntent.getBroadcast(context,0,intent,0);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
      alarmManager.setExact(AlarmManager.RTC_WAKEUP,triggerTime.getTimeInMillis(),pendingIntent);
    }
 else {
      alarmManager.set(AlarmManager.RTC_WAKEUP,triggerTime.getTimeInMillis(),pendingIntent);
    }
  }
}","public void setAlarm(Context context,long timeInMillis){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  String valAthanGap=prefs.getString(""String_Node_Str"",""String_Node_Str"");
  long athanGap=TextUtils.isEmpty(valAthanGap) ? 0 : Long.parseLong(valAthanGap);
  Calendar triggerTime=Calendar.getInstance();
  triggerTime.setTimeInMillis(timeInMillis - TimeUnit.SECONDS.toMillis(athanGap));
  AlarmManager alarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  if (!triggerTime.before(Calendar.getInstance())) {
    triggerTime.set(Calendar.SECOND,0);
    Log.d(TAG,""String_Node_Str"" + triggerTime.getTime());
    Intent intent=new Intent(context,AlarmReceiver.class);
    PendingIntent pendingIntent=PendingIntent.getBroadcast(context,0,intent,0);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
      alarmManager.setExact(AlarmManager.RTC_WAKEUP,triggerTime.getTimeInMillis(),pendingIntent);
    }
 else {
      alarmManager.set(AlarmManager.RTC_WAKEUP,triggerTime.getTimeInMillis(),pendingIntent);
    }
  }
}",0.9917355371900828
8697,"@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  Log.d(TAG,""String_Node_Str"" + progress);
  audioManager.setStreamVolume(AudioManager.STREAM_ALARM,progress,0);
}","@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
  audioManager.setStreamVolume(AudioManager.STREAM_ALARM,progress,0);
}",0.8808864265927978
8698,"@Override protected View onCreateDialogView(){
  View view=super.onCreateDialogView();
  instantiateMediaPlayer();
  seekBarVolumeSlider=(SeekBar)view.findViewById(R.id.sbVolumeSlider);
  seekBarVolumeSlider.setProgress(audioManager.getStreamVolume(AudioManager.STREAM_ALARM));
  seekBarVolumeSlider.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
      Log.d(TAG,""String_Node_Str"" + progress);
      audioManager.setStreamVolume(AudioManager.STREAM_ALARM,progress,0);
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
      try {
        if (!mediaPlayer.isPlaying()) {
          mediaPlayer.prepare();
          mediaPlayer.start();
        }
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
);
  return view;
}","@Override protected View onCreateDialogView(){
  View view=super.onCreateDialogView();
  instantiateMediaPlayer();
  seekBarVolumeSlider=(SeekBar)view.findViewById(R.id.sbVolumeSlider);
  seekBarVolumeSlider.setProgress(audioManager.getStreamVolume(AudioManager.STREAM_ALARM));
  seekBarVolumeSlider.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
      audioManager.setStreamVolume(AudioManager.STREAM_ALARM,progress,0);
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
      try {
        if (!mediaPlayer.isPlaying()) {
          mediaPlayer.prepare();
          mediaPlayer.start();
        }
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
);
  return view;
}",0.9754825247782994
8699,"public void instantiateMediaPlayer(){
  try {
    mediaPlayer=null;
    mediaPlayer=new MediaPlayer();
    mediaPlayer.setAudioStreamType(AudioManager.STREAM_ALARM);
    mediaPlayer.setDataSource(getContext(),athanSoundUri);
    mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener(){
      @Override public void onCompletion(      MediaPlayer mp){
        instantiateMediaPlayer();
      }
    }
);
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","public void instantiateMediaPlayer(){
  try {
    Log.v(TAG,""String_Node_Str"" + athanSoundUri);
    mediaPlayer=null;
    mediaPlayer=new MediaPlayer();
    mediaPlayer.setAudioStreamType(AudioManager.STREAM_ALARM);
    mediaPlayer.setDataSource(getContext(),athanSoundUri);
    mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener(){
      @Override public void onCompletion(      MediaPlayer mp){
        instantiateMediaPlayer();
      }
    }
);
  }
 catch (  IOException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9516441005802708
8700,"public void update(Context context){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  boolean gadgetClock=prefs.getBoolean(""String_Node_Str"",true);
  boolean gadgetIn24=prefs.getBoolean(""String_Node_Str"",false);
  boolean blackWidget=prefs.getBoolean(""String_Node_Str"",false);
  char[] digits=preferredDigits(context);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,new Intent(context,CalendarActivity.class),PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
  RemoteViews remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
  CivilDate civil=new CivilDate();
  PersianDate persian=DateConverter.civilToPersian(civil);
  persian.setDari(isDariVersion(context));
  int color;
  if (blackWidget) {
    color=context.getResources().getColor(android.R.color.black);
  }
 else {
    color=context.getResources().getColor(android.R.color.white);
  }
  remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
  remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
  remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,textShaper(persian.getMonthName()));
  remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,formatNumber(persian.getDayOfMonth(),digits));
  remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,CalendarWidget1x1.class),remoteViews1);
  remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
  remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
  String text1;
  String text2;
  text1=getDayOfWeekName(civil.getDayOfWeek());
  String dayTitle=dateToString(persian,digits,true);
  text2=dayTitle + PERSIAN_COMMA + ""String_Node_Str""+ dateToString(civil,digits,true);
  if (gadgetClock) {
    text2=text1 + ""String_Node_Str"" + text2;
    text1=getPersianFormattedClock(new Date(),digits,gadgetIn24);
  }
  text1=textShaper(text1);
  text2=textShaper(text2);
  remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,text1);
  remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,text2);
  remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,CalendarWidget4x1.class),remoteViews4);
  if (mNotificationManager == null) {
    mNotificationManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
  }
  if (prefs.getBoolean(""String_Node_Str"",true)) {
    mNotificationManager.cancel(NOTIFICATION_ID);
    String contentText=dateToString(civil,digits,true) + PERSIAN_COMMA + ""String_Node_Str""+ dateToString(DateConverter.civilToIslamic(civil),digits,true);
    if (largeIcon == null) {
      largeIcon=BitmapFactory.decodeResource(getResources(),R.drawable.launcher_icon);
    }
    Notification notification=new Notification.Builder(this).setSmallIcon(DaysIcons.getInstance().getDayIconResource(persian.getDayOfMonth())).setLargeIcon(largeIcon).setShowWhen(false).setPriority(Notification.PRIORITY_LOW).setContentText(contentText).setContentTitle(dayTitle).setContentIntent(launchAppPendingIntent).setOngoing(true).build();
    mNotificationManager.notify(NOTIFICATION_ID,notification);
  }
 else {
    mNotificationManager.cancel(NOTIFICATION_ID);
  }
}","public void update(Context context){
  SharedPreferences prefs=PreferenceManager.getDefaultSharedPreferences(context);
  boolean gadgetClock=prefs.getBoolean(""String_Node_Str"",true);
  boolean gadgetIn24=prefs.getBoolean(""String_Node_Str"",false);
  boolean blackWidget=prefs.getBoolean(""String_Node_Str"",false);
  char[] digits=preferredDigits(context);
  PendingIntent launchAppPendingIntent=PendingIntent.getActivity(context,0,new Intent(context,CalendarActivity.class),PendingIntent.FLAG_UPDATE_CURRENT);
  AppWidgetManager manager=AppWidgetManager.getInstance(context);
  RemoteViews remoteViews1=new RemoteViews(context.getPackageName(),R.layout.widget1x1);
  RemoteViews remoteViews4=new RemoteViews(context.getPackageName(),R.layout.widget4x1);
  CivilDate civil=new CivilDate();
  PersianDate persian=DateConverter.civilToPersian(civil);
  persian.setDari(isDariVersion(context));
  int color;
  if (blackWidget) {
    color=context.getResources().getColor(android.R.color.black);
  }
 else {
    color=context.getResources().getColor(android.R.color.white);
  }
  remoteViews1.setTextColor(R.id.textPlaceholder1_1x1,color);
  remoteViews1.setTextColor(R.id.textPlaceholder2_1x1,color);
  remoteViews1.setTextViewText(R.id.textPlaceholder2_1x1,textShaper(persian.getMonthName()));
  remoteViews1.setTextViewText(R.id.textPlaceholder1_1x1,formatNumber(persian.getDayOfMonth(),digits));
  remoteViews1.setOnClickPendingIntent(R.id.widget_layout1x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,CalendarWidget1x1.class),remoteViews1);
  remoteViews4.setTextColor(R.id.textPlaceholder1_4x1,color);
  remoteViews4.setTextColor(R.id.textPlaceholder2_4x1,color);
  String text1;
  String text2;
  text1=getDayOfWeekName(civil.getDayOfWeek());
  String dayTitle=dateToString(persian,digits,true);
  text2=dayTitle + PERSIAN_COMMA + ""String_Node_Str""+ dateToString(civil,digits,true);
  if (gadgetClock) {
    text2=text1 + ""String_Node_Str"" + text2;
    text1=getPersianFormattedClock(new Date(),digits,gadgetIn24);
  }
  text1=textShaper(text1);
  text2=textShaper(text2);
  remoteViews4.setTextViewText(R.id.textPlaceholder1_4x1,text1);
  remoteViews4.setTextViewText(R.id.textPlaceholder2_4x1,text2);
  remoteViews4.setOnClickPendingIntent(R.id.widget_layout4x1,launchAppPendingIntent);
  manager.updateAppWidget(new ComponentName(context,CalendarWidget4x1.class),remoteViews4);
  if (mNotificationManager == null) {
    mNotificationManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
  }
  if (prefs.getBoolean(""String_Node_Str"",true)) {
    mNotificationManager.cancel(NOTIFICATION_ID);
    String contentText=dateToString(civil,digits,true) + PERSIAN_COMMA + ""String_Node_Str""+ dateToString(DateConverter.civilToIslamic(civil),digits,true);
    if (largeIcon == null) {
      largeIcon=BitmapFactory.decodeResource(getResources(),R.drawable.launcher_icon);
    }
    Notification notification=new NotificationCompat.Builder(this).setSmallIcon(DaysIcons.getInstance().getDayIconResource(persian.getDayOfMonth())).setLargeIcon(largeIcon).setPriority(Notification.PRIORITY_LOW).setContentText(contentText).setContentTitle(dayTitle).setContentIntent(launchAppPendingIntent).setOngoing(true).build();
    mNotificationManager.notify(NOTIFICATION_ID,notification);
  }
 else {
    mNotificationManager.cancel(NOTIFICATION_ID);
  }
}",0.9963186570460904
8701,"public void setMonth(int month){
  if (month < 1 || month > 12)   throw new MonthOutOfRangeException(""String_Node_Str"" + month + ""String_Node_Str"");
  setDayOfMonth(getDayOfMonth());
  cal.set(Calendar.MONTH,month - 1);
}","public void setMonth(int month){
  if (month < 1 || month > 12)   throw new MonthOutOfRangeException(""String_Node_Str"" + month + ""String_Node_Str"");
  setDayOfMonth(getDayOfMonth());
  this.month=month;
}",0.8894117647058823
8702,"public void setYear(int year){
  if (year == 0)   throw new YearOutOfRangeException(""String_Node_Str"");
  cal.set(Calendar.YEAR,year);
}","public void setYear(int year){
  if (year == 0)   throw new YearOutOfRangeException(""String_Node_Str"");
  this.year=year;
}",0.8803088803088803
8703,"public void setDayOfMonth(int day){
  if (day < 1)   throw new DayOutOfRangeException(""String_Node_Str"" + day + ""String_Node_Str"");
  if (day > daysInMonth[getMonth() - 1])   throw new DayOutOfRangeException(""String_Node_Str"" + day + ""String_Node_Str"");
  cal.set(Calendar.DAY_OF_MONTH,day);
}","public void setDayOfMonth(int day){
  if (day < 1)   throw new DayOutOfRangeException(""String_Node_Str"" + day + ""String_Node_Str"");
  if (day > daysInMonth[month])   throw new DayOutOfRangeException(""String_Node_Str"" + day + ""String_Node_Str"");
  this.day=day;
}",0.8864864864864865
8704,"public int getDayOfWeek(){
  return cal.get(Calendar.DAY_OF_WEEK);
}","public int getDayOfWeek(){
  Calendar cal=Calendar.getInstance();
  cal.set(Calendar.YEAR,year);
  cal.set(Calendar.MONTH,month - 1);
  cal.set(Calendar.DAY_OF_MONTH,day);
  return cal.get(Calendar.DAY_OF_WEEK);
}",0.4839857651245551
8705,"public int getYear(){
  return cal.get(Calendar.YEAR);
}","public int getYear(){
  return year;
}",0.7872340425531915
8706,"public int getDayOfMonth(){
  return cal.get(Calendar.DAY_OF_MONTH);
}","public int getDayOfMonth(){
  return day;
}",0.7433628318584071
8707,"public int getMonth(){
  return cal.get(Calendar.MONTH) + 1;
}","public int getMonth(){
  return month;
}",0.7058823529411765
8708,"private void flushBatch(Batch<T> batch) throws IOException, InterruptedException {
  Map<Address,T> batchMap=batch.getMap();
  List<Address> successfulAddresses=Lists.newArrayListWithExpectedSize(batchMap.size());
  Map<byte[],byte[]> successfulRows=Maps.newTreeMap(UnsignedBytes.lexicographicalComparator());
  long nanoTimeBeforeBatch=System.nanoTime();
  try {
    if (commitType.equals(CommitType.INCREMENT) && configuration.batchSize > 1) {
      Iterable<List<Map.Entry<Address,T>>> partitions=Iterables.partition(batchMap.entrySet(),configuration.batchSize);
      int batchesPerFlush=0;
      Map<BoxedByteArray,T> increments=new HashMap<>();
      Map<BoxedByteArray,Address> backwards=new HashMap<>();
      for (      List<Map.Entry<Address,T>> entries : partitions) {
        batchesPerFlush++;
        final long nanoTimeBeforeWrite=System.nanoTime();
        for (        Map.Entry<Address,T> entry : entries) {
          final Address address=entry.getKey();
          final T op=entry.getValue();
          final BoxedByteArray rowKey=new BoxedByteArray(ArrayUtils.addAll(uniqueCubeName,address.toWriteKey(idService)));
          increments.put(rowKey,op);
          backwards.put(rowKey,address);
        }
        Map<BoxedByteArray,byte[]> successes=increment(increments);
        for (        Map.Entry<BoxedByteArray,byte[]> entry : successes.entrySet()) {
          successfulAddresses.add(backwards.get(entry.getKey()));
          successfulRows.put(entry.getKey().bytes,entry.getValue());
        }
        long writeDurationNanos=System.nanoTime() - nanoTimeBeforeWrite;
        batchWritesTimer.update(writeDurationNanos,TimeUnit.NANOSECONDS);
      }
      batchesPerFlushHisto.update(batchesPerFlush);
      if (successfulAddresses.size() < batchMap.size()) {
        int failures=batchMap.size() - successfulAddresses.size();
        incrementFailuresPerFlush.update(failures);
        throw new IOException(String.format(""String_Node_Str"",failures,batchMap.size()));
      }
    }
 else {
      for (      Map.Entry<Address,T> entry : batchMap.entrySet()) {
        final Address address=entry.getKey();
        final T op=entry.getValue();
        final byte[] rowKey=ArrayUtils.addAll(uniqueCubeName,address.toWriteKey(idService));
        final long nanoTimeBeforeWrite=System.nanoTime();
        byte[] dbBytes;
switch (commitType) {
case INCREMENT:
          long postIncr=increment(rowKey,op);
        dbBytes=Bytes.toBytes(postIncr);
      break;
case READ_COMBINE_CAS:
    dbBytes=readCombineCas(rowKey,op);
  break;
case OVERWRITE:
overwrite(rowKey,op);
dbBytes=op.serialize();
break;
default :
throw new RuntimeException(""String_Node_Str"" + commitType);
}
long writeDurationNanos=System.nanoTime() - nanoTimeBeforeWrite;
singleWriteTimer.update(writeDurationNanos,TimeUnit.NANOSECONDS);
if (log.isDebugEnabled()) {
log.debug(""String_Node_Str"" + Arrays.toString(uniqueCubeName) + ""String_Node_Str""+ address);
}
successfulAddresses.add(address);
successfulRows.put(rowKey,dbBytes);
}
}
long batchDurationNanos=System.nanoTime() - nanoTimeBeforeBatch;
flushSuccessTimer.update(batchDurationNanos,TimeUnit.NANOSECONDS);
}
 catch (IOException ioe) {
log.warn(""String_Node_Str"",ioe);
for (Address address : successfulAddresses) {
batch.getMap().remove(address);
}
long batchDurationNanos=System.nanoTime() - nanoTimeBeforeBatch;
flushFailTimer.update(batchDurationNanos,TimeUnit.NANOSECONDS);
throw ioe;
}
 finally {
try {
onFlush.apply(successfulRows);
}
 catch (Exception e) {
log.error(""String_Node_Str"",e);
}
}
}","private void flushBatch(Batch<T> batch) throws IOException, InterruptedException {
  Map<Address,T> batchMap=batch.getMap();
  List<Address> successfulAddresses=Lists.newArrayListWithExpectedSize(batchMap.size());
  Map<byte[],byte[]> successfulRows=Maps.newTreeMap(UnsignedBytes.lexicographicalComparator());
  long nanoTimeBeforeBatch=System.nanoTime();
  try {
    if (commitType.equals(CommitType.INCREMENT) && configuration.batchSize > 1) {
      flushBatchedIncrement(batchMap,successfulAddresses,successfulRows);
    }
 else {
      for (      Map.Entry<Address,T> entry : batchMap.entrySet()) {
        final Address address=entry.getKey();
        final T op=entry.getValue();
        final byte[] rowKey=ArrayUtils.addAll(uniqueCubeName,address.toWriteKey(idService));
        final long nanoTimeBeforeWrite=System.nanoTime();
        byte[] dbBytes;
switch (commitType) {
case INCREMENT:
          long postIncr=increment(rowKey,op);
        dbBytes=Bytes.toBytes(postIncr);
      break;
case READ_COMBINE_CAS:
    dbBytes=readCombineCas(rowKey,op);
  break;
case OVERWRITE:
overwrite(rowKey,op);
dbBytes=op.serialize();
break;
default :
throw new RuntimeException(""String_Node_Str"" + commitType);
}
long writeDurationNanos=System.nanoTime() - nanoTimeBeforeWrite;
singleWriteTimer.update(writeDurationNanos,TimeUnit.NANOSECONDS);
if (log.isDebugEnabled()) {
log.debug(""String_Node_Str"" + Arrays.toString(uniqueCubeName) + ""String_Node_Str""+ address);
}
successfulAddresses.add(address);
successfulRows.put(rowKey,dbBytes);
}
}
long batchDurationNanos=System.nanoTime() - nanoTimeBeforeBatch;
flushSuccessTimer.update(batchDurationNanos,TimeUnit.NANOSECONDS);
}
 catch (IOException ioe) {
log.warn(""String_Node_Str"",ioe);
if (ioe instanceof RetriesExhaustedWithDetailsException) {
RetriesExhaustedWithDetailsException details=(RetriesExhaustedWithDetailsException)ioe;
MDC.put(""String_Node_Str"",String.valueOf(details.mayHaveClusterIssues()));
for (int i=0; i < details.getNumExceptions(); ++i) {
MDC.put(""String_Node_Str"",details.getHostnamePort(i));
MDC.put(""String_Node_Str"",BaseEncoding.base64().encode(details.getRow(i).getRow()));
log.error(String.format(""String_Node_Str"",i),details.getCause(i));
}
MDC.clear();
}
for (Address address : successfulAddresses) {
batch.getMap().remove(address);
}
long batchDurationNanos=System.nanoTime() - nanoTimeBeforeBatch;
flushFailTimer.update(batchDurationNanos,TimeUnit.NANOSECONDS);
throw ioe;
}
 finally {
try {
onFlush.apply(successfulRows);
}
 catch (Exception e) {
log.error(""String_Node_Str"",e);
}
}
}",0.6578344782466471
8709,"@Test public void basicCallbackTest() throws Exception {
  HourDayMonthBucketer hourDayMonthBucketer=new HourDayMonthBucketer();
  Dimension<DateTime> time=new Dimension<DateTime>(""String_Node_Str"",hourDayMonthBucketer,false,8);
  Dimension<String> zipcode=new Dimension<String>(""String_Node_Str"",new StringToBytesBucketer(),true,5);
  Rollup hourAndZipRollup=new Rollup(zipcode,time,HourDayMonthBucketer.hours);
  Rollup dayAndZipRollup=new Rollup(zipcode,time,HourDayMonthBucketer.days);
  Rollup hourRollup=new Rollup(time,HourDayMonthBucketer.hours);
  Rollup dayRollup=new Rollup(time,HourDayMonthBucketer.days);
  List<Dimension<?>> dimensions=ImmutableList.<Dimension<?>>of(time,zipcode);
  List<Rollup> rollups=ImmutableList.of(hourAndZipRollup,dayAndZipRollup,hourRollup,dayRollup);
  DataCube<LongOp> dataCube=new DataCube<LongOp>(dimensions,rollups);
  IdService idService=new MapIdService();
  Semaphore s=new Semaphore(1);
  s.acquire();
  HTablePool pool=new HTablePool(getTestUtil().getConfiguration(),Integer.MAX_VALUE);
  DbHarness<LongOp> hbaseDbHarness=new HBaseDbHarness<LongOp>(pool,""String_Node_Str"".getBytes(),DATA_CUBE_TABLE,CF,LongOp.DESERIALIZER,idService,DbHarness.CommitType.INCREMENT,new TestCallback(s),1,1,1,""String_Node_Str"",1);
  DataCubeIo<LongOp> dataCubeIo=new DataCubeIo<LongOp>(dataCube,hbaseDbHarness,1,100000,SyncLevel.BATCH_SYNC,""String_Node_Str"",true);
  dataCubeIo.writeSync(new LongOp(5),new WriteBuilder().at(time,DateTime.now(DateTimeZone.UTC)).at(zipcode,""String_Node_Str""));
  boolean callbackCalled=s.tryAcquire(1,TimeUnit.SECONDS);
  Assert.assertTrue(callbackCalled);
  dataCubeIo.writeAsync(new LongOp(5),new WriteBuilder().at(time,DateTime.now(DateTimeZone.UTC)).at(zipcode,""String_Node_Str""));
  callbackCalled=s.tryAcquire(1,TimeUnit.SECONDS);
  Assert.assertTrue(callbackCalled);
}","@Test public void basicCallbackTest() throws Exception {
  HourDayMonthBucketer hourDayMonthBucketer=new HourDayMonthBucketer();
  Dimension<DateTime> time=new Dimension<DateTime>(""String_Node_Str"",hourDayMonthBucketer,false,8);
  Dimension<String> zipcode=new Dimension<String>(""String_Node_Str"",new StringToBytesBucketer(),true,5);
  Rollup hourAndZipRollup=new Rollup(zipcode,time,HourDayMonthBucketer.hours);
  Rollup dayAndZipRollup=new Rollup(zipcode,time,HourDayMonthBucketer.days);
  Rollup hourRollup=new Rollup(time,HourDayMonthBucketer.hours);
  Rollup dayRollup=new Rollup(time,HourDayMonthBucketer.days);
  List<Dimension<?>> dimensions=ImmutableList.<Dimension<?>>of(time,zipcode);
  List<Rollup> rollups=ImmutableList.of(hourAndZipRollup,dayAndZipRollup,hourRollup,dayRollup);
  DataCube<LongOp> dataCube=new DataCube<LongOp>(dimensions,rollups);
  IdService idService=new MapIdService();
  Semaphore s=new Semaphore(1);
  s.acquire();
  HTablePool pool=new HTablePool(getTestUtil().getConfiguration(),Integer.MAX_VALUE);
  DbHarness<LongOp> hbaseDbHarness=new HBaseDbHarness<LongOp>(pool,""String_Node_Str"".getBytes(),DATA_CUBE_TABLE,CF,LongOp.DESERIALIZER,idService,DbHarness.CommitType.INCREMENT,new TestCallback(s),1,1,1,""String_Node_Str"",this.batchSize);
  DataCubeIo<LongOp> dataCubeIo=new DataCubeIo<LongOp>(dataCube,hbaseDbHarness,1,100000,SyncLevel.BATCH_SYNC,""String_Node_Str"",true);
  dataCubeIo.writeSync(new LongOp(5),new WriteBuilder().at(time,DateTime.now(DateTimeZone.UTC)).at(zipcode,""String_Node_Str""));
  boolean callbackCalled=s.tryAcquire(1,TimeUnit.SECONDS);
  Assert.assertTrue(callbackCalled);
  dataCubeIo.writeAsync(new LongOp(5),new WriteBuilder().at(time,DateTime.now(DateTimeZone.UTC)).at(zipcode,""String_Node_Str""));
  callbackCalled=s.tryAcquire(1,TimeUnit.SECONDS);
  Assert.assertTrue(callbackCalled);
}",0.9959316517493898
8710,"@Test public void noCallbackTest() throws Exception {
  HourDayMonthBucketer hourDayMonthBucketer=new HourDayMonthBucketer();
  Dimension<DateTime> time=new Dimension<DateTime>(""String_Node_Str"",hourDayMonthBucketer,false,8);
  Dimension<String> zipcode=new Dimension<String>(""String_Node_Str"",new StringToBytesBucketer(),true,5);
  Rollup hourAndZipRollup=new Rollup(zipcode,time,HourDayMonthBucketer.hours);
  Rollup dayAndZipRollup=new Rollup(zipcode,time,HourDayMonthBucketer.days);
  Rollup hourRollup=new Rollup(time,HourDayMonthBucketer.hours);
  Rollup dayRollup=new Rollup(time,HourDayMonthBucketer.days);
  List<Dimension<?>> dimensions=ImmutableList.<Dimension<?>>of(time,zipcode);
  List<Rollup> rollups=ImmutableList.of(hourAndZipRollup,dayAndZipRollup,hourRollup,dayRollup);
  DataCube<LongOp> dataCube=new DataCube<LongOp>(dimensions,rollups);
  IdService idService=new MapIdService();
  HTablePool pool=new HTablePool(getTestUtil().getConfiguration(),Integer.MAX_VALUE);
  DbHarness<LongOp> hbaseDbHarness=new HBaseDbHarness<LongOp>(pool,""String_Node_Str"".getBytes(),DATA_CUBE_TABLE,CF,LongOp.DESERIALIZER,idService,DbHarness.CommitType.INCREMENT,1,1,1,""String_Node_Str"");
  DataCubeIo<LongOp> dataCubeIo=new DataCubeIo<LongOp>(dataCube,hbaseDbHarness,1,100000,SyncLevel.BATCH_SYNC,""String_Node_Str"",true);
  dataCubeIo.writeSync(new LongOp(5),new WriteBuilder().at(time,DateTime.now(DateTimeZone.UTC)).at(zipcode,""String_Node_Str""));
}","@Test public void noCallbackTest() throws Exception {
  HourDayMonthBucketer hourDayMonthBucketer=new HourDayMonthBucketer();
  Dimension<DateTime> time=new Dimension<DateTime>(""String_Node_Str"",hourDayMonthBucketer,false,8);
  Dimension<String> zipcode=new Dimension<String>(""String_Node_Str"",new StringToBytesBucketer(),true,5);
  Rollup hourAndZipRollup=new Rollup(zipcode,time,HourDayMonthBucketer.hours);
  Rollup dayAndZipRollup=new Rollup(zipcode,time,HourDayMonthBucketer.days);
  Rollup hourRollup=new Rollup(time,HourDayMonthBucketer.hours);
  Rollup dayRollup=new Rollup(time,HourDayMonthBucketer.days);
  List<Dimension<?>> dimensions=ImmutableList.<Dimension<?>>of(time,zipcode);
  List<Rollup> rollups=ImmutableList.of(hourAndZipRollup,dayAndZipRollup,hourRollup,dayRollup);
  DataCube<LongOp> dataCube=new DataCube<LongOp>(dimensions,rollups);
  IdService idService=new MapIdService();
  HTablePool pool=new HTablePool(getTestUtil().getConfiguration(),Integer.MAX_VALUE);
  DbHarness<LongOp> hbaseDbHarness=new HBaseDbHarness<LongOp>(pool,""String_Node_Str"".getBytes(),DATA_CUBE_TABLE,CF,LongOp.DESERIALIZER,idService,DbHarness.CommitType.INCREMENT,(ignored) -> null,1,1,1,""String_Node_Str"",this.batchSize);
  DataCubeIo<LongOp> dataCubeIo=new DataCubeIo<LongOp>(dataCube,hbaseDbHarness,1,100000,SyncLevel.BATCH_SYNC,""String_Node_Str"",true);
  dataCubeIo.writeSync(new LongOp(5),new WriteBuilder().at(time,DateTime.now(DateTimeZone.UTC)).at(zipcode,""String_Node_Str""));
}",0.9887640449438202
8711,"@Test public void test() throws Exception {
  IdService idService=new MapIdService();
  HTablePool pool=mock(HTablePool.class);
  HTableInterface htableInterface=mock(HTableInterface.class);
  when(pool.getTable(any(byte[].class))).thenReturn(htableInterface);
  when(htableInterface.batch(anyList())).thenAnswer(a -> {
    List<Row> arguments=(List<Row>)a.getArguments()[0];
    int size=arguments.size();
    Object[] objects=new Object[size];
    for (int i=0; i < size; ++i) {
      if (i % 2 == 1) {
        objects[i]=null;
      }
      objects[i]=new Result(new KeyValue[]{new KeyValue(arguments.get(i).getRow(),CF,HBaseDbHarness.QUALIFIER,Longs.toByteArray(10L))});
    }
    return objects;
  }
);
  HbaseDbHarnessConfiguration config=HbaseDbHarnessConfiguration.newBuilder().setBatchSize(100).setUniqueCubeName(""String_Node_Str"".getBytes()).setTableName(CUBE_DATA_TABLE).setCf(CF).setCommitType(DbHarness.CommitType.INCREMENT).build();
  DbHarness<LongOp> hbaseDbHarness=new HBaseDbHarness<LongOp>(config,pool,LongOp.DESERIALIZER,idService,(avoid) -> null);
  when(htableInterface.get(any(Get.class))).thenReturn(getResult(10L),getResult(10L),getResult(100L));
  DbHarnessTests.asyncBatchWritesTest(hbaseDbHarness,10);
  verify(htableInterface,atLeast(2)).batch(anyList());
}","@Test public void test() throws Exception {
  IdService idService=new MapIdService();
  HTablePool pool=mock(HTablePool.class);
  HTableInterface htableInterface=mock(HTableInterface.class);
  final List<Increment> incrementOperations=new LinkedList<>();
  when(pool.getTable(any(byte[].class))).thenReturn(htableInterface);
  long value=10L;
  when(htableInterface.batch(anyList())).thenAnswer(a -> {
    List<Increment> arguments=(List<Increment>)a.getArguments()[0];
    int size=arguments.size();
    Object[] objects=new Object[size];
    for (int i=0; i < size; ++i) {
      incrementOperations.add(arguments.get(i));
      if (i % 2 == 1) {
        objects[i]=null;
      }
      objects[i]=new Result(new KeyValue[]{new KeyValue(arguments.get(i).getRow(),CF,HBaseDbHarness.QUALIFIER,Longs.toByteArray(value))});
    }
    return objects;
  }
);
  HbaseDbHarnessConfiguration config=HbaseDbHarnessConfiguration.newBuilder().setBatchSize(2).setUniqueCubeName(new byte[]{}).setTableName(CUBE_DATA_TABLE).setCf(CF).setCommitType(DbHarness.CommitType.INCREMENT).build();
  DbHarness<LongOp> hbaseDbHarness=new HBaseDbHarness<LongOp>(config,pool,LongOp.DESERIALIZER,idService,(avoid) -> null);
  when(htableInterface.get(any(Get.class))).thenReturn(getResult(value),getResult(value),getResult(100L));
  HourDayMonthBucketer hourDayMonthBucketer=new HourDayMonthBucketer();
  Dimension<DateTime> time=new Dimension<DateTime>(""String_Node_Str"",hourDayMonthBucketer,false,8);
  Dimension<String> zipcode=new Dimension<String>(""String_Node_Str"",new StringToBytesBucketer(),true,5);
  Rollup hourAndZipRollup=new Rollup(zipcode,time,HourDayMonthBucketer.hours);
  Rollup dayAndZipRollup=new Rollup(zipcode,time,HourDayMonthBucketer.days);
  Rollup hourRollup=new Rollup(time,HourDayMonthBucketer.hours);
  Rollup dayRollup=new Rollup(time,HourDayMonthBucketer.days);
  List<Dimension<?>> dimensions=ImmutableList.<Dimension<?>>of(time,zipcode);
  List<Rollup> rollups=ImmutableList.of(hourAndZipRollup,dayAndZipRollup,hourRollup,dayRollup);
  DataCube<LongOp> cube=new DataCube<LongOp>(dimensions,rollups);
  WriteBuilder writeBuilder=new WriteBuilder();
  Batch<LongOp> writes=cube.getWrites(writeBuilder.at(time,DateTime.now()).at(zipcode,""String_Node_Str""),new LongOp(10));
  hbaseDbHarness.runBatchAsync(writes,new AfterExecute<LongOp>(){
    @Override public void afterExecute(    Throwable t){
      throw new RuntimeException(t);
    }
  }
);
  hbaseDbHarness.shutdown();
  int size=writes.getMap().size();
  List<BoxedByteArray> result=incrementOperations.stream().map(Increment::getRow).sorted((a,b) -> Bytes.BYTES_COMPARATOR.compare(a,b)).map(BoxedByteArray::new).collect(Collectors.toList());
  List<BoxedByteArray> expected=writes.getMap().keySet().stream().map(a -> {
    try {
      return a.toWriteKey(idService);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
).map(BoxedByteArray::new).sorted((a,b) -> Bytes.BYTES_COMPARATOR.compare(a.bytes,b.bytes)).collect(Collectors.toList());
  assertEquals(expected,result);
  assertEquals(incrementOperations.size(),size);
  verify(htableInterface,times(size / config.batchSize)).batch(anyList());
}",0.5028546332894159
8712,"public boolean runWithCheckedExceptions() throws IOException, InterruptedException {
  HTable backfilledHTable=null;
  HTable liveCubeHTable=null;
  ResultScanner liveCubeScanner=null;
  try {
    liveCubeHTable=new HTable(conf,liveCubeTableName);
    liveCubeScanner=liveCubeHTable.getScanner(cf);
    boolean liveCubeIsEmpty=!liveCubeScanner.iterator().hasNext();
    liveCubeScanner.close();
    if (liveCubeIsEmpty) {
      log.info(""String_Node_Str"");
      HBaseSnapshotter hbaseSnapshotter=new HBaseSnapshotter(conf,backfilledTableName,cf,liveCubeTableName,new Path(""String_Node_Str""),true,null,null);
      return hbaseSnapshotter.runWithCheckedExceptions();
    }
 else {
      Job job=new Job(conf);
      backfilledHTable=new HTable(conf,backfilledTableName);
      Pair<byte[][],byte[][]> allRegionsStartAndEndKeys=backfilledHTable.getStartEndKeys();
      byte[][] internalSplitKeys=BackfillUtil.getSplitKeys(allRegionsStartAndEndKeys);
      Collection<Scan> scans=scansThisCubeOnly(cubeNameKeyPrefix,internalSplitKeys);
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + scans);
      }
      CollectionInputFormat.setCollection(job,Scan.class,scans);
      job.getConfiguration().set(""String_Node_Str"",""String_Node_Str"");
      job.setJobName(""String_Node_Str"");
      job.setJarByClass(HBaseBackfillMerger.class);
      job.getConfiguration().set(CONFKEY_DESERIALIZER,opDeserializer.getName());
      job.setMapperClass(HBaseBackfillMergeMapper.class);
      job.setInputFormatClass(CollectionInputFormat.class);
      job.setNumReduceTasks(0);
      job.setOutputFormatClass(NullOutputFormat.class);
      job.getConfiguration().set(CONFKEY_LIVECUBE_TABLE_NAME,new String(liveCubeTableName));
      job.getConfiguration().set(CONFKEY_SNAPSHOT_TABLE_NAME,new String(snapshotTableName));
      job.getConfiguration().set(CONFKEY_BACKFILLED_TABLE_NAME,new String(backfilledTableName));
      job.getConfiguration().set(CONFKEY_COLUMN_FAMILY,new String(cf));
      job.getConfiguration().set(""String_Node_Str"",""String_Node_Str"");
      job.getConfiguration().set(""String_Node_Str"",""String_Node_Str"");
      try {
        job.waitForCompletion(true);
        return job.isSuccessful();
      }
 catch (      ClassNotFoundException e) {
        log.error(""String_Node_Str"",e);
        throw new RuntimeException(e);
      }
    }
  }
  finally {
    if (liveCubeScanner != null) {
      liveCubeScanner.close();
    }
    if (liveCubeHTable != null) {
      liveCubeHTable.close();
    }
    if (backfilledHTable != null) {
      backfilledHTable.close();
    }
  }
}","public boolean runWithCheckedExceptions() throws IOException, InterruptedException {
  HTable backfilledHTable=null;
  HTable liveCubeHTable=null;
  ResultScanner liveCubeScanner=null;
  try {
    liveCubeHTable=new HTable(conf,liveCubeTableName);
    liveCubeScanner=liveCubeHTable.getScanner(cf);
    boolean liveCubeIsEmpty=!liveCubeScanner.iterator().hasNext();
    liveCubeScanner.close();
    if (liveCubeIsEmpty) {
      log.info(""String_Node_Str"");
      HBaseSnapshotter hbaseSnapshotter=new HBaseSnapshotter(conf,backfilledTableName,cf,liveCubeTableName,new Path(""String_Node_Str""),true,cubeNameKeyPrefix,Bytes.add(cubeNameKeyPrefix,fiftyBytesFF));
      return hbaseSnapshotter.runWithCheckedExceptions();
    }
 else {
      Job job=new Job(conf);
      backfilledHTable=new HTable(conf,backfilledTableName);
      Pair<byte[][],byte[][]> allRegionsStartAndEndKeys=backfilledHTable.getStartEndKeys();
      byte[][] internalSplitKeys=BackfillUtil.getSplitKeys(allRegionsStartAndEndKeys);
      Collection<Scan> scans=scansThisCubeOnly(cubeNameKeyPrefix,internalSplitKeys);
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"" + scans);
      }
      CollectionInputFormat.setCollection(job,Scan.class,scans);
      job.getConfiguration().set(""String_Node_Str"",""String_Node_Str"");
      job.setJobName(""String_Node_Str"");
      job.setJarByClass(HBaseBackfillMerger.class);
      job.getConfiguration().set(CONFKEY_DESERIALIZER,opDeserializer.getName());
      job.setMapperClass(HBaseBackfillMergeMapper.class);
      job.setInputFormatClass(CollectionInputFormat.class);
      job.setNumReduceTasks(0);
      job.setOutputFormatClass(NullOutputFormat.class);
      job.getConfiguration().set(CONFKEY_LIVECUBE_TABLE_NAME,new String(liveCubeTableName));
      job.getConfiguration().set(CONFKEY_SNAPSHOT_TABLE_NAME,new String(snapshotTableName));
      job.getConfiguration().set(CONFKEY_BACKFILLED_TABLE_NAME,new String(backfilledTableName));
      job.getConfiguration().set(CONFKEY_COLUMN_FAMILY,new String(cf));
      job.getConfiguration().set(""String_Node_Str"",""String_Node_Str"");
      job.getConfiguration().set(""String_Node_Str"",""String_Node_Str"");
      try {
        job.waitForCompletion(true);
        return job.isSuccessful();
      }
 catch (      ClassNotFoundException e) {
        log.error(""String_Node_Str"",e);
        throw new RuntimeException(e);
      }
    }
  }
  finally {
    if (liveCubeScanner != null) {
      liveCubeScanner.close();
    }
    if (liveCubeHTable != null) {
      liveCubeHTable.close();
    }
    if (backfilledHTable != null) {
      backfilledHTable.close();
    }
  }
}",0.9874285714285714
8713,"@Override public byte[] serialize(){
  if (this.bool) {
    return TRUE_SERIAL;
  }
 else {
    return FALSE_SERIAL;
  }
}","@Override public byte[] serialize(){
  return staticSerialize(bool);
}",0.5208333333333334
8714,"@Override public byte[] serialize(){
  byte[] ordinalBytes=Util.intToBytes(ordinal);
  int startAtIndex=4 - numFieldBytes;
  return Arrays.copyOfRange(ordinalBytes,startAtIndex,4);
}","@Override public byte[] serialize(){
  return staticSerialize(ordinal,numFieldBytes);
}",0.5278810408921933
8715,"@Override public byte[] serialize(){
  return Util.intToBytes(i);
}","@Override public byte[] serialize(){
  return staticSerialize(x);
}",0.835820895522388
8716,"public IntSerializable(int l){
  this.i=l;
}","public IntSerializable(int x){
  this.x=x;
}",0.9318181818181818
8717,"@Override public byte[] serialize(){
  return Util.longToBytes(l);
}","@Override public byte[] serialize(){
  return staticSerialize(l);
}",0.8296296296296296
8718,"@Override public byte[] serialize(){
  try {
    return s.getBytes(""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
}","@Override public byte[] serialize(){
  return staticSerialize(s);
}",0.4545454545454545
8719,"/** 
 * Test StringSerializable Class
 * @throws Exception
 */
@Test public void testStringSerializable() throws Exception {
  Assert.assertArrayEquals(new StringSerializable(TEST_STRING).serialize(),TEST_STRING.getBytes());
}","@Test public void testStringSerializable() throws Exception {
  Assert.assertArrayEquals(new StringSerializable(TEST_STRING).serialize(),TEST_STRING.getBytes());
}",0.8380462724935732
8720,"/** 
 * Test BytesSerializable Class
 * @throws Exception
 */
@Test public void testBytesSerializable() throws Exception {
  Assert.assertArrayEquals(new BytesSerializable(new byte[]{1}).serialize(),TRUE_CASE);
  Assert.assertArrayEquals(new BytesSerializable(new byte[]{0}).serialize(),FALSE_CASE);
}","@Test public void testBytesSerializable() throws Exception {
  Assert.assertArrayEquals(new BytesSerializable(new byte[]{1}).serialize(),TRUE_CASE);
  Assert.assertArrayEquals(new BytesSerializable(new byte[]{0}).serialize(),FALSE_CASE);
}",0.8851851851851852
8721,"/** 
 * Test LongSerializable (mostly through re-implementation).
 * @throws Exception
 */
@Test public void testLongSerializable() throws Exception {
  Assert.assertArrayEquals(new LongSerializable(TEST_LONG).serialize(),ByteBuffer.allocate(8).putLong(TEST_LONG).array());
}","@Test public void testLongSerializable() throws Exception {
  Assert.assertArrayEquals(new LongSerializable(TEST_LONG).serialize(),ByteBuffer.allocate(8).putLong(TEST_LONG).array());
}",0.8017429193899782
8722,"/** 
 * Test Boolean Serializable Class
 * @throws Exception
 */
@Test public void testBooleanSerializable() throws Exception {
  Assert.assertArrayEquals(new BooleanSerializable(true).serialize(),TRUE_CASE);
  Assert.assertArrayEquals(new BooleanSerializable(false).serialize(),FALSE_CASE);
}","@Test public void testBooleanSerializable() throws Exception {
  Assert.assertArrayEquals(new BooleanSerializable(true).serialize(),TRUE_CASE);
  Assert.assertArrayEquals(new BooleanSerializable(false).serialize(),FALSE_CASE);
}",0.8752399232245681
8723,"public static void log(String s){
  if (isEnabled) {
    hacklog.HackLog.log(s);
  }
}","/** 
 * Log a message. Note that this will probably be a no-op in a map or reduce task unless you find some way to set the required system properties on those JVMs to enable this code.
 */
public static void log(String s){
  if (isEnabled) {
    hacklog.HackLog.log(s);
  }
}",0.4764542936288088
8724,"/** 
 * Given a multimap returned by the merge iterator, return an Op that should be the new value in the live production cube, or null if the value in the live production cube should be deleted.
 * @return an ActionRowKeyAndOp telling what action should be taken for this row
 */
private static final ActionRowKeyAndOp makeNewLiveCubeOp(Deserializer<?> deserializer,Collection<Result> liveCubeResults,Collection<Result> snapshotResults,Collection<Result> backfilledResults,Context ctx) throws IOException {
  Op liveCubeOp=null;
  Op snapshotOp=null;
  Op backfilledOp=null;
  byte[] rowKey=null;
  if (!liveCubeResults.isEmpty()) {
    Result result=liveCubeResults.iterator().next();
    liveCubeOp=deserializer.fromBytes(result.value());
    rowKey=result.getRow();
  }
  if (!snapshotResults.isEmpty()) {
    Result result=snapshotResults.iterator().next();
    snapshotOp=deserializer.fromBytes(result.value());
    rowKey=result.getRow();
  }
  if (!backfilledResults.isEmpty()) {
    Result result=backfilledResults.iterator().next();
    backfilledOp=deserializer.fromBytes(result.value());
    rowKey=result.getRow();
  }
  if (snapshotOp != null && backfilledOp != null && liveCubeOp != null) {
    if (liveCubeOp.equals(snapshotOp)) {
      return new ActionRowKeyAndOp(Action.OVERWRITE,rowKey,backfilledOp);
    }
    Op newLiveCubeValue=(liveCubeOp.subtract(snapshotOp)).add(backfilledOp);
    if (newLiveCubeValue.equals(liveCubeOp)) {
      return new ActionRowKeyAndOp(Action.LEAVE_ALONE,rowKey,null);
    }
 else {
      return new ActionRowKeyAndOp(Action.OVERWRITE,rowKey,newLiveCubeValue);
    }
  }
 else   if (snapshotOp != null && backfilledOp == null && liveCubeOp != null) {
    if (liveCubeOp.equals(snapshotOp)) {
      return new ActionRowKeyAndOp(Action.DELETE,rowKey,null);
    }
 else {
      Op newLiveCubeValue=liveCubeOp.subtract(snapshotOp);
      return new ActionRowKeyAndOp(Action.OVERWRITE,rowKey,newLiveCubeValue);
    }
  }
 else   if (snapshotOp == null && backfilledOp != null && liveCubeOp != null) {
    Op newLiveCubeValue=backfilledOp.add(liveCubeOp);
    return new ActionRowKeyAndOp(Action.OVERWRITE,rowKey,newLiveCubeValue);
  }
 else   if (snapshotOp == null && backfilledOp != null && liveCubeOp == null) {
    return new ActionRowKeyAndOp(Action.OVERWRITE,rowKey,backfilledOp);
  }
 else   if (snapshotOp == null && backfilledOp == null && liveCubeOp != null) {
    return new ActionRowKeyAndOp(Action.LEAVE_ALONE,rowKey,null);
  }
 else   if (snapshotOp == null && backfilledOp == null && liveCubeOp == null) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (snapshotOp != null && backfilledOp != null && liveCubeOp == null) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * Given a multimap returned by the merge iterator, return an Op that should be the new value in the live production cube, or null if the value in the live production cube should be deleted.
 * @return an ActionRowKeyAndOp telling what action should be taken for this row
 */
private static final ActionRowKeyAndOp makeNewLiveCubeOp(Deserializer<?> deserializer,Collection<Result> liveCubeResults,Collection<Result> snapshotResults,Collection<Result> backfilledResults,Context ctx) throws IOException {
  Op liveCubeOp=null;
  Op snapshotOp=null;
  Op backfilledOp=null;
  byte[] rowKey=null;
  if (!liveCubeResults.isEmpty()) {
    Result result=liveCubeResults.iterator().next();
    liveCubeOp=deserializer.fromBytes(result.value());
    rowKey=result.getRow();
  }
  if (!snapshotResults.isEmpty()) {
    Result result=snapshotResults.iterator().next();
    snapshotOp=deserializer.fromBytes(result.value());
    rowKey=result.getRow();
  }
  if (!backfilledResults.isEmpty()) {
    Result result=backfilledResults.iterator().next();
    backfilledOp=deserializer.fromBytes(result.value());
    rowKey=result.getRow();
  }
  if (snapshotOp != null && backfilledOp != null && liveCubeOp != null) {
    DebugHack.log(""String_Node_Str"");
    if (liveCubeOp.equals(snapshotOp)) {
      return new ActionRowKeyAndOp(Action.OVERWRITE,rowKey,backfilledOp);
    }
    Op newLiveCubeValue=(liveCubeOp.subtract(snapshotOp)).add(backfilledOp);
    if (newLiveCubeValue.equals(liveCubeOp)) {
      return new ActionRowKeyAndOp(Action.LEAVE_ALONE,rowKey,null);
    }
 else {
      return new ActionRowKeyAndOp(Action.OVERWRITE,rowKey,newLiveCubeValue);
    }
  }
 else   if (snapshotOp != null && backfilledOp == null && liveCubeOp != null) {
    DebugHack.log(""String_Node_Str"");
    if (liveCubeOp.equals(snapshotOp)) {
      return new ActionRowKeyAndOp(Action.DELETE,rowKey,null);
    }
 else {
      Op newLiveCubeValue=liveCubeOp.subtract(snapshotOp);
      return new ActionRowKeyAndOp(Action.OVERWRITE,rowKey,newLiveCubeValue);
    }
  }
 else   if (snapshotOp == null && backfilledOp != null && liveCubeOp != null) {
    DebugHack.log(""String_Node_Str"");
    Op newLiveCubeValue=backfilledOp.add(liveCubeOp);
    return new ActionRowKeyAndOp(Action.OVERWRITE,rowKey,newLiveCubeValue);
  }
 else   if (snapshotOp == null && backfilledOp != null && liveCubeOp == null) {
    DebugHack.log(""String_Node_Str"");
    return new ActionRowKeyAndOp(Action.OVERWRITE,rowKey,backfilledOp);
  }
 else   if (snapshotOp == null && backfilledOp == null && liveCubeOp != null) {
    DebugHack.log(""String_Node_Str"");
    return new ActionRowKeyAndOp(Action.LEAVE_ALONE,rowKey,null);
  }
 else   if (snapshotOp == null && backfilledOp == null && liveCubeOp == null) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (snapshotOp != null && backfilledOp != null && liveCubeOp == null) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
}",0.9680672268907564
8725,"@Override protected void map(ImmutableBytesWritable key,Result result,Context context) throws IOException, InterruptedException {
  DebugHack.log(""String_Node_Str"");
  for (  KeyValue kv : result.list()) {
    context.write(key,kv);
  }
}","@Override protected void map(ImmutableBytesWritable key,Result result,Context context) throws IOException, InterruptedException {
  for (  KeyValue kv : result.list()) {
    context.write(key,kv);
  }
}",0.9181818181818182
8726,"public void writeOne(Address address,T op) throws IOException {
  byte[] addressAsBytes=address.toKey(idService);
  byte[] rowKey=ArrayUtils.addAll(uniqueCubeName,addressAsBytes);
  if (DebugHack.isEnabled()) {
    DebugHack.log(""String_Node_Str"" + new String(tableName) + ""String_Node_Str""+ new String(cf)+ ""String_Node_Str""+ Hex.encodeHexString(rowKey));
  }
  Optional<T> preexistingValInDb=get(address);
  T valToWrite;
  if (preexistingValInDb.isPresent()) {
    valToWrite=(T)(preexistingValInDb.get().add(op));
  }
 else {
    valToWrite=op;
  }
  Put put=new Put(rowKey);
  put.add(cf,QUALIFIER,valToWrite.serialize());
  WithHTable.put(pool,tableName,put);
}","public void writeOne(Address address,T op) throws IOException {
  byte[] addressAsBytes=address.toKey(idService);
  byte[] rowKey=ArrayUtils.addAll(uniqueCubeName,addressAsBytes);
  Optional<T> preexistingValInDb=get(address);
  T valToWrite;
  if (preexistingValInDb.isPresent()) {
    valToWrite=(T)(preexistingValInDb.get().add(op));
  }
 else {
    valToWrite=op;
  }
  byte[] serializedOp=valToWrite.serialize();
  if (DebugHack.isEnabled()) {
    DebugHack.log(""String_Node_Str"" + new String(tableName) + ""String_Node_Str""+ new String(cf)+ ""String_Node_Str""+ Base64.encodeBase64String(rowKey)+ ""String_Node_Str""+ Base64.encodeBase64String(serializedOp));
  }
  Put put=new Put(rowKey);
  put.add(cf,QUALIFIER,serializedOp);
  WithHTable.put(pool,tableName,put);
}",0.6267409470752089
8727,"/** 
 * Get a byte array encoding the buckets of this cell in the Cube. For internal use only.
 */
public byte[] toKey(IdService idService) throws IOException {
  List<Dimension<?>> dimensions=cube.getDimensions();
  boolean sawOnlyWildcardsSoFar=true;
  List<byte[]> reversedKeyElems=Lists.newArrayListWithCapacity(dimensions.size());
  for (int i=dimensions.size() - 1; i >= 0; i--) {
    Dimension<?> dimension=dimensions.get(i);
    BucketTypeAndBucket bucketAndCoord=buckets.get(dimension);
    int thisDimBucketLen=dimension.getNumFieldBytes();
    int thisDimBucketTypeLen=dimension.getBucketPrefixSize();
    if (bucketAndCoord == BucketTypeAndBucket.WILDCARD || bucketAndCoord == null) {
      if (sawOnlyWildcardsSoFar) {
        continue;
      }
      reversedKeyElems.add(new byte[thisDimBucketTypeLen + thisDimBucketLen]);
      reversedKeyElems.add(WILDCARD_FIELD);
    }
 else {
      sawOnlyWildcardsSoFar=false;
      byte[] elem;
      if (idService == null || !dimension.getDoIdSubstitution()) {
        elem=bucketAndCoord.bucket;
      }
 else {
        int dimensionNum=cube.getDimensions().indexOf(dimension);
        elem=idService.getId(dimensionNum,bucketAndCoord.bucket,dimension.getNumFieldBytes());
      }
      if (elem.length != thisDimBucketLen) {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + dimension + ""String_Node_Str""+ dimension.getNumFieldBytes()+ ""String_Node_Str""+ bucketAndCoord.bucket.length);
      }
      byte[] bucketTypeId=bucketAndCoord.bucketType.getUniqueId();
      if (bucketTypeId.length != thisDimBucketTypeLen) {
        throw new RuntimeException(""String_Node_Str"" + dimension + ""String_Node_Str""+ dimension.getBucketPrefixSize()+ ""String_Node_Str""+ Arrays.toString(bucketTypeId)+ ""String_Node_Str""+ bucketTypeId.length);
      }
      reversedKeyElems.add(bucketAndCoord.bucket);
      reversedKeyElems.add(bucketTypeId);
      reversedKeyElems.add(NON_WILDCARD_FIELD);
    }
  }
  List<byte[]> keyElemsInOrder=Lists.reverse(reversedKeyElems);
  int totalKeySize=0;
  for (  byte[] keyElement : keyElemsInOrder) {
    totalKeySize+=keyElement.length;
  }
  ByteBuffer bb=ByteBuffer.allocate(totalKeySize);
  for (  byte[] keyElement : keyElemsInOrder) {
    bb.put(keyElement);
  }
  if (bb.remaining() != 0) {
    throw new AssertionError(""String_Node_Str"" + bb.remaining() + ""String_Node_Str"");
  }
  return bb.array();
}","/** 
 * Get a byte array encoding the buckets of this cell in the Cube. For internal use only.
 */
public byte[] toKey(IdService idService) throws IOException {
  List<Dimension<?>> dimensions=cube.getDimensions();
  boolean sawOnlyWildcardsSoFar=true;
  List<byte[]> reversedKeyElems=Lists.newArrayListWithCapacity(dimensions.size());
  for (int i=dimensions.size() - 1; i >= 0; i--) {
    Dimension<?> dimension=dimensions.get(i);
    BucketTypeAndBucket bucketAndCoord=buckets.get(dimension);
    int thisDimBucketLen=dimension.getNumFieldBytes();
    int thisDimBucketTypeLen=dimension.getBucketPrefixSize();
    if (bucketAndCoord == BucketTypeAndBucket.WILDCARD || bucketAndCoord == null) {
      if (sawOnlyWildcardsSoFar) {
        continue;
      }
      reversedKeyElems.add(new byte[thisDimBucketTypeLen + thisDimBucketLen]);
      reversedKeyElems.add(WILDCARD_FIELD);
    }
 else {
      sawOnlyWildcardsSoFar=false;
      byte[] elem;
      if (idService == null || !dimension.getDoIdSubstitution()) {
        elem=bucketAndCoord.bucket;
      }
 else {
        int dimensionNum=cube.getDimensions().indexOf(dimension);
        elem=idService.getId(dimensionNum,bucketAndCoord.bucket,dimension.getNumFieldBytes());
      }
      if (elem.length != thisDimBucketLen) {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + dimension + ""String_Node_Str""+ dimension.getNumFieldBytes()+ ""String_Node_Str""+ bucketAndCoord.bucket.length);
      }
      byte[] bucketTypeId=bucketAndCoord.bucketType.getUniqueId();
      if (bucketTypeId.length != thisDimBucketTypeLen) {
        throw new RuntimeException(""String_Node_Str"" + dimension + ""String_Node_Str""+ dimension.getBucketPrefixSize()+ ""String_Node_Str""+ Arrays.toString(bucketTypeId)+ ""String_Node_Str""+ bucketTypeId.length);
      }
      reversedKeyElems.add(elem);
      reversedKeyElems.add(bucketTypeId);
      reversedKeyElems.add(NON_WILDCARD_FIELD);
    }
  }
  List<byte[]> keyElemsInOrder=Lists.reverse(reversedKeyElems);
  int totalKeySize=0;
  for (  byte[] keyElement : keyElemsInOrder) {
    totalKeySize+=keyElement.length;
  }
  ByteBuffer bb=ByteBuffer.allocate(totalKeySize);
  for (  byte[] keyElement : keyElemsInOrder) {
    bb.put(keyElement);
  }
  if (bb.remaining() != 0) {
    throw new AssertionError(""String_Node_Str"" + bb.remaining() + ""String_Node_Str"");
  }
  return bb.array();
}",0.9948165042504664
8728,"private static String parseFullTextExpression(FullTextExpression ft,final OakSolrConfiguration configuration){
  final StringBuilder fullTextString=new StringBuilder();
  ft.accept(new FullTextVisitor(){
    @Override public boolean visit(    FullTextOr or){
      fullTextString.append('(');
      for (int i=0; i < or.list.size(); i++) {
        FullTextExpression e=or.list.get(i);
        if (e.toString().equals(""String_Node_Str"")) {
          continue;
        }
        if (i > 0 && i < or.list.size()) {
          fullTextString.append(""String_Node_Str"");
        }
        String orTerm=parseFullTextExpression(e,configuration);
        fullTextString.append(orTerm);
      }
      fullTextString.append(')');
      fullTextString.append(' ');
      return true;
    }
    @Override public boolean visit(    FullTextContains contains){
      return contains.getBase().accept(this);
    }
    @Override public boolean visit(    FullTextAnd and){
      fullTextString.append('(');
      for (int i=0; i < and.list.size(); i++) {
        FullTextExpression e=and.list.get(i);
        if (e.toString().equals(""String_Node_Str"")) {
          continue;
        }
        if (i > 0 && i < and.list.size()) {
          fullTextString.append(""String_Node_Str"");
        }
        String andTerm=parseFullTextExpression(e,configuration);
        fullTextString.append(andTerm);
      }
      fullTextString.append(')');
      fullTextString.append(' ');
      return true;
    }
    @Override public boolean visit(    FullTextTerm term){
      if (term.isNot()) {
        fullTextString.append('-');
      }
      String p=term.getPropertyName();
      if (p != null && p.indexOf('/') >= 0) {
        p=getName(p);
      }
      if (p == null || ""String_Node_Str"".equals(p)) {
        p=configuration.getCatchAllField();
      }
      fullTextString.append(partialEscape(p));
      fullTextString.append(':');
      String termText=term.getText();
      if (termText.indexOf(' ') > 0) {
        fullTextString.append('""');
      }
      fullTextString.append(termText.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
      if (termText.indexOf(' ') > 0) {
        fullTextString.append('""');
      }
      String boost=term.getBoost();
      if (boost != null) {
        fullTextString.append('^');
        fullTextString.append(boost);
      }
      fullTextString.append(' ');
      return true;
    }
  }
);
  return fullTextString.toString();
}","private static String parseFullTextExpression(FullTextExpression ft,final OakSolrConfiguration configuration){
  final StringBuilder fullTextString=new StringBuilder();
  ft.accept(new FullTextVisitor(){
    @Override public boolean visit(    FullTextOr or){
      fullTextString.append('(');
      for (int i=0; i < or.list.size(); i++) {
        FullTextExpression e=or.list.get(i);
        if (e.toString().contains(""String_Node_Str"")) {
          continue;
        }
        if (i > 0 && i < or.list.size()) {
          fullTextString.append(""String_Node_Str"");
        }
        String orTerm=parseFullTextExpression(e,configuration);
        fullTextString.append(orTerm);
      }
      fullTextString.append(')');
      fullTextString.append(' ');
      return true;
    }
    @Override public boolean visit(    FullTextContains contains){
      return contains.getBase().accept(this);
    }
    @Override public boolean visit(    FullTextAnd and){
      fullTextString.append('(');
      for (int i=0; i < and.list.size(); i++) {
        FullTextExpression e=and.list.get(i);
        if (e.toString().contains(""String_Node_Str"")) {
          continue;
        }
        if (i > 0 && i < and.list.size()) {
          fullTextString.append(""String_Node_Str"");
        }
        String andTerm=parseFullTextExpression(e,configuration);
        fullTextString.append(andTerm);
      }
      fullTextString.append(')');
      fullTextString.append(' ');
      return true;
    }
    @Override public boolean visit(    FullTextTerm term){
      if (term.isNot()) {
        fullTextString.append('-');
      }
      String p=term.getPropertyName();
      if (p != null && p.indexOf('/') >= 0) {
        p=getName(p);
      }
      if (p == null || ""String_Node_Str"".equals(p)) {
        p=configuration.getCatchAllField();
      }
      fullTextString.append(partialEscape(p));
      fullTextString.append(':');
      String termText=term.getText();
      if (termText.indexOf(' ') > 0) {
        fullTextString.append('""');
      }
      fullTextString.append(termText.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
      if (termText.indexOf(' ') > 0) {
        fullTextString.append('""');
      }
      String boost=term.getBoost();
      if (boost != null) {
        fullTextString.append('^');
        fullTextString.append(boost);
      }
      fullTextString.append(' ');
      return true;
    }
  }
);
  return fullTextString.toString();
}",0.9951845906902088
8729,"/** 
 * Creates a copy of this   {@code DocumentNodeState} with the{@link #rootRevision} set to the given {@code root} revision. This methodreturns  {@code this} instance if the given {@code root} revision isthe same as the one in this instance and the  {@link #fromExternalChange}flags are equal.
 * @param root the root revision for the copy of this node state.
 * @param externalChange if the {@link #fromExternalChange} flag must beset on the returned node state.
 * @return a copy of this node state with the given root revision andexternal change flag.
 */
public abstract AbstractDocumentNodeState withRootRevision(@Nonnull RevisionVector root,boolean externalChange);","/** 
 * Creates a copy of this   {@code DocumentNodeState} with the{@link #getRootRevision()} set to the given {@code root} revision. This methodreturns  {@code this} instance if the given {@code root} revision isthe same as the one in this instance and the  {@link #isFromExternalChange()}flags are equal.
 * @param root the root revision for the copy of this node state.
 * @param externalChange if the {@link #isFromExternalChange()} flag must beset on the returned node state.
 * @return a copy of this node state with the given root revision andexternal change flag.
 */
public abstract AbstractDocumentNodeState withRootRevision(@Nonnull RevisionVector root,boolean externalChange);",0.9728539985326484
8730,"/** 
 * Adds the provided glob paths to the set of include paths. <p> The definition of a glob path is <a href=""https://jackrabbit.apache.org/oak/docs/apidocs/org/apache/jackrabbit/oak/plugins/observation/filter/GlobbingPathFilter.html"">here</a> <p> Note that unlike 'normal' include and exclude paths, this variant doesn't apply Oak's NamePathMapper. <p> This filter property is added in 'or' mode.
 * @param globPath glob path that should be added as include path pattern. Note that the NamePathMapper is not applied on this globPath.
 * @return this filter with the filter change applied
 */
public abstract OakEventFilter withIncludeGlobPaths(String... globPaths);","/** 
 * Adds the provided glob paths to the set of include paths. <p> The definition of a glob path is <a href=""https://jackrabbit.apache.org/oak/docs/apidocs/org/apache/jackrabbit/oak/plugins/observation/filter/GlobbingPathFilter.html"">here</a> <p> Note that unlike 'normal' include and exclude paths, this variant doesn't apply Oak's NamePathMapper. <p> This filter property is added in 'or' mode.
 * @param globPaths glob paths that should be added as include path pattern. Note that the NamePathMapper is not applied on these globPaths.
 * @return this filter with the filter change applied
 */
public abstract OakEventFilter withIncludeGlobPaths(String... globPaths);",0.9791044776119404
8731,"/** 
 * Returns the File if present or null otherwise. Any usage of the returned file should assert for its existence as the file could be purged from the file system once uploaded using  {@link org.apache.jackrabbit.core.data.CachingDataStore.FilesUploader}.
 * @param key of the file to check
 * @return a File object if found
 */
@Nullable public File getIfPresent(String key){
  cacheStats.markLoad();
  if (map.containsKey(key)) {
    cacheStats.markLoadSuccess();
    return map.get(key);
  }
  return null;
}","/** 
 * Returns the File if present or null otherwise. Any usage of the returned file should assert for its existence as the file could be purged from the file system once uploaded using the internal scheduled remove mechanism.
 * @param key of the file to check
 * @return a File object if found
 */
@Nullable public File getIfPresent(String key){
  cacheStats.markLoad();
  if (map.containsKey(key)) {
    cacheStats.markLoadSuccess();
    return map.get(key);
  }
  return null;
}",0.8897795591182365
8732,"@Test public void queryOptions() throws ParseException {
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void queryOptions() throws ParseException {
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8012718600953895
8733,"private Statement convertToUnion(String query,Statement statement,int startParseIndex) throws ParseException {
  int start=query.indexOf(""String_Node_Str"",startParseIndex);
  String begin=query.substring(0,start);
  XPathToSQL2Converter converter=new XPathToSQL2Converter();
  String partList=query.substring(start);
  converter.initialize(partList);
  converter.read();
  int lastParseIndex=converter.parseIndex;
  int lastOrIndex=lastParseIndex;
  converter.read(""String_Node_Str"");
  int level=0;
  ArrayList<String> parts=new ArrayList<String>();
  int parseIndex;
  while (true) {
    parseIndex=converter.parseIndex;
    if (converter.readIf(""String_Node_Str"")) {
      level++;
    }
 else     if (converter.readIf(""String_Node_Str"") && level-- <= 0) {
      break;
    }
 else     if (converter.readIf(""String_Node_Str"") && level == 0) {
      String or=partList.substring(lastOrIndex,lastParseIndex);
      parts.add(or);
      lastOrIndex=parseIndex;
    }
 else     if (converter.currentTokenType == END) {
      throw getSyntaxError(""String_Node_Str"");
    }
 else {
      converter.read();
    }
    lastParseIndex=parseIndex;
  }
  String or=partList.substring(lastOrIndex,lastParseIndex);
  parts.add(or);
  String end=partList.substring(parseIndex);
  Statement result=null;
  for (  String p : parts) {
    String q=begin + p + end;
    converter=new XPathToSQL2Converter();
    Statement stat=converter.convertToStatement(q);
    if (result == null) {
      result=stat;
    }
 else {
      UnionStatement union=new UnionStatement(result,stat);
      union.orderList=stat.orderList;
      union.queryOptions=stat.queryOptions;
      result=union;
    }
    stat.orderList=new ArrayList<Order>();
    stat.queryOptions=new QueryOptions();
  }
  return result;
}","private Statement convertToUnion(String query,Statement statement,int startParseIndex) throws ParseException {
  int start=query.indexOf(""String_Node_Str"",startParseIndex);
  String begin=query.substring(0,start);
  XPathToSQL2Converter converter=new XPathToSQL2Converter();
  String partList=query.substring(start);
  converter.initialize(partList);
  converter.read();
  int lastParseIndex=converter.parseIndex;
  int lastOrIndex=lastParseIndex;
  converter.read(""String_Node_Str"");
  int level=0;
  ArrayList<String> parts=new ArrayList<String>();
  int parseIndex;
  while (true) {
    parseIndex=converter.parseIndex;
    if (converter.readIf(""String_Node_Str"")) {
      level++;
    }
 else     if (converter.readIf(""String_Node_Str"")) {
      if (level-- <= 0) {
        break;
      }
    }
 else     if (converter.readIf(""String_Node_Str"") && level == 0) {
      String or=partList.substring(lastOrIndex,parseIndex - 1);
      parts.add(or);
      lastOrIndex=parseIndex;
    }
 else     if (converter.currentTokenType == END) {
      throw getSyntaxError(""String_Node_Str"");
    }
 else {
      converter.read();
    }
  }
  String or=partList.substring(lastOrIndex,parseIndex - 1);
  parts.add(or);
  String end=partList.substring(parseIndex);
  Statement result=null;
  for (  String p : parts) {
    String q=begin + p + end;
    converter=new XPathToSQL2Converter();
    Statement stat=converter.convertToStatement(q);
    if (result == null) {
      result=stat;
    }
 else {
      UnionStatement union=new UnionStatement(result,stat);
      union.orderList=stat.orderList;
      union.queryOptions=stat.queryOptions;
      result=union;
    }
    stat.orderList=new ArrayList<Order>();
    stat.queryOptions=new QueryOptions();
  }
  return result;
}",0.8891396332863187
8734,"@Test public void union() throws ParseException {
  try {
    verify(""String_Node_Str"",""String_Node_Str"");
    fail();
  }
 catch (  ParseException e) {
  }
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void union() throws ParseException {
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  try {
    verify(""String_Node_Str"",""String_Node_Str"");
    fail();
  }
 catch (  ParseException e) {
  }
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  verify(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}",0.8867689755288262
8735,"private Statement convertToStatement(String query) throws ParseException {
  query=query.trim();
  Statement statement=new Statement();
  if (query.startsWith(""String_Node_Str"")) {
    query=query.substring(""String_Node_Str"".length()).trim();
    statement.setExplain(true);
  }
  if (query.startsWith(""String_Node_Str"")) {
    query=query.substring(""String_Node_Str"".length()).trim();
    statement.setMeasure(true);
  }
  if (query.isEmpty()) {
    query=""String_Node_Str"";
  }
  statement.setOriginalQuery(query);
  initialize(query);
  expected=new ArrayList<String>();
  read();
  if (currentTokenType == END) {
    throw getSyntaxError(""String_Node_Str"");
  }
  currentSelector.name=""String_Node_Str"";
  String pathPattern=""String_Node_Str"";
  boolean startOfQuery=true;
  while (true) {
    boolean shortcut=false;
    boolean slash=readIf(""String_Node_Str"");
    if (!slash) {
      if (startOfQuery) {
        currentSelector.path=""String_Node_Str"";
        pathPattern=""String_Node_Str"";
        currentSelector.isChild=true;
      }
 else {
        break;
      }
    }
 else     if (readIf(""String_Node_Str"")) {
      if (!pathPattern.isEmpty()) {
        throw getSyntaxError(""String_Node_Str"");
      }
      if (readIf(""String_Node_Str"")) {
        currentSelector.path=""String_Node_Str"";
        pathPattern=""String_Node_Str"";
        if (readIf(""String_Node_Str"")) {
          pathPattern=""String_Node_Str"";
          currentSelector.isDescendant=true;
        }
 else {
          currentSelector.isChild=true;
        }
      }
 else {
        pathPattern=""String_Node_Str"";
        currentSelector.path=""String_Node_Str"";
        shortcut=true;
      }
    }
 else     if (readIf(""String_Node_Str"")) {
      pathPattern+=""String_Node_Str"";
      if (currentSelector.isDescendant) {
        nextSelector(true);
      }
      currentSelector.isDescendant=true;
    }
 else {
      pathPattern+=""String_Node_Str"";
      if (startOfQuery) {
        currentSelector.path=""String_Node_Str"";
      }
 else {
        if (currentSelector.isDescendant) {
          nextSelector(true);
        }
        currentSelector.isChild=true;
      }
    }
    int startParseIndex=parseIndex;
    if (shortcut) {
    }
 else     if (readIf(""String_Node_Str"")) {
      pathPattern+=""String_Node_Str"";
      if (!currentSelector.isDescendant) {
        if (selectors.size() == 0 && currentSelector.path.equals(""String_Node_Str"")) {
          currentSelector.path=""String_Node_Str"";
        }
      }
    }
 else     if (currentTokenType == IDENTIFIER) {
      String identifier=readIdentifier();
      if (readIf(""String_Node_Str"")) {
        if (""String_Node_Str"".equals(identifier)) {
          currentSelector.isChild=false;
          pathPattern+=""String_Node_Str"";
          read(""String_Node_Str"");
          if (currentSelector.isDescendant) {
            currentSelector.nodeName=""String_Node_Str"";
          }
 else {
            currentSelector.path=PathUtils.concat(currentSelector.path,""String_Node_Str"");
          }
        }
 else         if (""String_Node_Str"".equals(identifier)) {
          if (readIf(""String_Node_Str"")) {
            pathPattern+=""String_Node_Str"";
          }
 else {
            if (readIf(""String_Node_Str"")) {
              pathPattern+=""String_Node_Str"";
            }
 else {
              String name=readPathSegment();
              pathPattern+=name;
              appendNodeName(name);
            }
            if (readIf(""String_Node_Str"")) {
              currentSelector.nodeType=readIdentifier();
            }
            read(""String_Node_Str"");
          }
        }
 else         if (""String_Node_Str"".equals(identifier)) {
          readOpenDotClose(false);
          rewindSelector();
          Expression.Property p=new Expression.Property(currentSelector,""String_Node_Str"",false);
          statement.addSelectColumn(p);
        }
 else {
          throw getSyntaxError();
        }
      }
 else {
        String name=ISO9075.decode(identifier);
        pathPattern+=name;
        appendNodeName(name);
      }
    }
 else     if (readIf(""String_Node_Str"")) {
      rewindSelector();
      Expression.Property p=readProperty();
      statement.addSelectColumn(p);
    }
 else     if (readIf(""String_Node_Str"")) {
      rewindSelector();
      do {
        if (readIf(""String_Node_Str"")) {
          Expression.Property p=readProperty();
          statement.addSelectColumn(p);
        }
 else         if (readIf(""String_Node_Str"")) {
          readOpenDotClose(true);
          Expression.Property p=new Expression.Property(currentSelector,""String_Node_Str"",false);
          statement.addSelectColumn(p);
        }
 else         if (readIf(""String_Node_Str"")) {
          read(""String_Node_Str"");
          read(""String_Node_Str"");
          Expression.Property p=new Expression.Property(currentSelector,""String_Node_Str"",false);
          statement.addSelectColumn(p);
        }
 else         if (readIf(""String_Node_Str"")) {
          readOpenDotClose(true);
          Expression.Property p=new Expression.Property(currentSelector,""String_Node_Str"",false);
          statement.addSelectColumn(p);
        }
      }
 while (readIf(""String_Node_Str""));
      if (!readIf(""String_Node_Str"")) {
        return convertToUnion(query,statement,startParseIndex - 1);
      }
    }
 else     if (readIf(""String_Node_Str"")) {
      if (readIf(""String_Node_Str"")) {
        String name=""String_Node_Str"";
        pathPattern+=name;
        if (!currentSelector.isChild) {
          currentSelector.nodeName=name;
        }
 else {
          if (currentSelector.isChild) {
            currentSelector.isChild=false;
            currentSelector.isParent=true;
          }
        }
      }
 else {
        if (selectors.size() > 0) {
          currentSelector=selectors.remove(selectors.size() - 1);
          currentSelector.condition=null;
          currentSelector.joinCondition=null;
        }
      }
    }
 else {
      throw getSyntaxError();
    }
    if (readIf(""String_Node_Str"")) {
      Expression c=parseConstraint();
      currentSelector.condition=Expression.and(currentSelector.condition,c);
      read(""String_Node_Str"");
    }
    startOfQuery=false;
    nextSelector(false);
  }
  if (selectors.size() == 0) {
    nextSelector(true);
  }
  currentSelector=selectors.get(selectors.size() - 1);
  if (selectors.size() == 1) {
    currentSelector.onlySelector=true;
  }
  if (readIf(""String_Node_Str"")) {
    read(""String_Node_Str"");
    do {
      Order order=new Order();
      order.expr=parseExpression();
      if (readIf(""String_Node_Str"")) {
        order.descending=true;
      }
 else {
        readIf(""String_Node_Str"");
      }
      statement.addOrderBy(order);
    }
 while (readIf(""String_Node_Str""));
  }
  QueryOptions options=new QueryOptions();
  if (readIf(""String_Node_Str"")) {
    read(""String_Node_Str"");
    if (readIf(""String_Node_Str"")) {
      String type=readIdentifier().toUpperCase(Locale.ENGLISH);
      options.traversal=Traversal.valueOf(type);
    }
    read(""String_Node_Str"");
  }
  if (!currentToken.isEmpty()) {
    throw getSyntaxError(""String_Node_Str"");
  }
  statement.setColumnSelector(currentSelector);
  statement.setSelectors(selectors);
  statement.setQueryOptions(options);
  Expression where=null;
  for (  Selector s : selectors) {
    where=Expression.and(where,s.condition);
  }
  statement.setWhere(where);
  return statement;
}","private Statement convertToStatement(String query) throws ParseException {
  query=query.trim();
  Statement statement=new Statement();
  if (query.startsWith(""String_Node_Str"")) {
    query=query.substring(""String_Node_Str"".length()).trim();
    statement.setExplain(true);
  }
  if (query.startsWith(""String_Node_Str"")) {
    query=query.substring(""String_Node_Str"".length()).trim();
    statement.setMeasure(true);
  }
  if (query.isEmpty()) {
    query=""String_Node_Str"";
  }
  statement.setOriginalQuery(query);
  initialize(query);
  expected=new ArrayList<String>();
  read();
  if (currentTokenType == END) {
    throw getSyntaxError(""String_Node_Str"");
  }
  currentSelector.name=""String_Node_Str"";
  String pathPattern=""String_Node_Str"";
  boolean startOfQuery=true;
  while (true) {
    boolean shortcut=false;
    boolean slash=readIf(""String_Node_Str"");
    if (!slash) {
      if (startOfQuery) {
        currentSelector.path=""String_Node_Str"";
        pathPattern=""String_Node_Str"";
        currentSelector.isChild=true;
      }
 else {
        break;
      }
    }
 else     if (readIf(""String_Node_Str"")) {
      if (!pathPattern.isEmpty()) {
        throw getSyntaxError(""String_Node_Str"");
      }
      if (readIf(""String_Node_Str"")) {
        currentSelector.path=""String_Node_Str"";
        pathPattern=""String_Node_Str"";
        if (readIf(""String_Node_Str"")) {
          pathPattern=""String_Node_Str"";
          currentSelector.isDescendant=true;
        }
 else {
          currentSelector.isChild=true;
        }
      }
 else {
        pathPattern=""String_Node_Str"";
        currentSelector.path=""String_Node_Str"";
        shortcut=true;
      }
    }
 else     if (readIf(""String_Node_Str"")) {
      pathPattern+=""String_Node_Str"";
      if (currentSelector.isDescendant) {
        nextSelector(true);
      }
      currentSelector.isDescendant=true;
    }
 else {
      pathPattern+=""String_Node_Str"";
      if (startOfQuery) {
        currentSelector.path=""String_Node_Str"";
      }
 else {
        if (currentSelector.isDescendant) {
          nextSelector(true);
        }
        currentSelector.isChild=true;
      }
    }
    int startParseIndex=parseIndex;
    if (shortcut) {
    }
 else     if (readIf(""String_Node_Str"")) {
      pathPattern+=""String_Node_Str"";
      if (!currentSelector.isDescendant) {
        if (selectors.size() == 0 && currentSelector.path.equals(""String_Node_Str"")) {
          currentSelector.path=""String_Node_Str"";
        }
      }
    }
 else     if (currentTokenType == IDENTIFIER) {
      String identifier=readIdentifier();
      if (readIf(""String_Node_Str"")) {
        if (""String_Node_Str"".equals(identifier)) {
          currentSelector.isChild=false;
          pathPattern+=""String_Node_Str"";
          read(""String_Node_Str"");
          if (currentSelector.isDescendant) {
            currentSelector.nodeName=""String_Node_Str"";
          }
 else {
            currentSelector.path=PathUtils.concat(currentSelector.path,""String_Node_Str"");
          }
        }
 else         if (""String_Node_Str"".equals(identifier)) {
          if (readIf(""String_Node_Str"")) {
            pathPattern+=""String_Node_Str"";
          }
 else {
            if (readIf(""String_Node_Str"")) {
              pathPattern+=""String_Node_Str"";
            }
 else {
              String name=readPathSegment();
              pathPattern+=name;
              appendNodeName(name);
            }
            if (readIf(""String_Node_Str"")) {
              currentSelector.nodeType=readIdentifier();
            }
            read(""String_Node_Str"");
          }
        }
 else         if (""String_Node_Str"".equals(identifier)) {
          readOpenDotClose(false);
          rewindSelector();
          Expression.Property p=new Expression.Property(currentSelector,""String_Node_Str"",false);
          statement.addSelectColumn(p);
        }
 else {
          throw getSyntaxError();
        }
      }
 else {
        String name=ISO9075.decode(identifier);
        pathPattern+=name;
        appendNodeName(name);
      }
    }
 else     if (readIf(""String_Node_Str"")) {
      rewindSelector();
      Expression.Property p=readProperty();
      statement.addSelectColumn(p);
    }
 else     if (readIf(""String_Node_Str"")) {
      rewindSelector();
      do {
        if (readIf(""String_Node_Str"")) {
          Expression.Property p=readProperty();
          statement.addSelectColumn(p);
        }
 else         if (readIf(""String_Node_Str"")) {
          readOpenDotClose(true);
          Expression.Property p=new Expression.Property(currentSelector,""String_Node_Str"",false);
          statement.addSelectColumn(p);
        }
 else         if (readIf(""String_Node_Str"")) {
          read(""String_Node_Str"");
          read(""String_Node_Str"");
          Expression.Property p=new Expression.Property(currentSelector,""String_Node_Str"",false);
          statement.addSelectColumn(p);
        }
 else         if (readIf(""String_Node_Str"")) {
          readOpenDotClose(true);
          Expression.Property p=new Expression.Property(currentSelector,""String_Node_Str"",false);
          statement.addSelectColumn(p);
        }
      }
 while (readIf(""String_Node_Str""));
      if (!readIf(""String_Node_Str"")) {
        return convertToUnion(query,statement,startParseIndex - 1);
      }
    }
 else     if (readIf(""String_Node_Str"")) {
      if (readIf(""String_Node_Str"")) {
        String name=""String_Node_Str"";
        pathPattern+=name;
        if (!currentSelector.isChild) {
          currentSelector.nodeName=name;
        }
 else {
          if (currentSelector.isChild) {
            currentSelector.isChild=false;
            currentSelector.isParent=true;
          }
        }
      }
 else {
        if (selectors.size() > 0) {
          currentSelector=selectors.remove(selectors.size() - 1);
          currentSelector.condition=null;
          currentSelector.joinCondition=null;
        }
      }
    }
 else {
      throw getSyntaxError();
    }
    if (readIf(""String_Node_Str"")) {
      do {
        Expression c=parseConstraint();
        currentSelector.condition=Expression.and(currentSelector.condition,c);
        read(""String_Node_Str"");
      }
 while (readIf(""String_Node_Str""));
    }
    startOfQuery=false;
    nextSelector(false);
  }
  if (selectors.size() == 0) {
    nextSelector(true);
  }
  currentSelector=selectors.get(selectors.size() - 1);
  if (selectors.size() == 1) {
    currentSelector.onlySelector=true;
  }
  if (readIf(""String_Node_Str"")) {
    read(""String_Node_Str"");
    do {
      Order order=new Order();
      order.expr=parseExpression();
      if (readIf(""String_Node_Str"")) {
        order.descending=true;
      }
 else {
        readIf(""String_Node_Str"");
      }
      statement.addOrderBy(order);
    }
 while (readIf(""String_Node_Str""));
  }
  QueryOptions options=new QueryOptions();
  if (readIf(""String_Node_Str"")) {
    read(""String_Node_Str"");
    if (readIf(""String_Node_Str"")) {
      String type=readIdentifier().toUpperCase(Locale.ENGLISH);
      options.traversal=Traversal.valueOf(type);
    }
    read(""String_Node_Str"");
  }
  if (!currentToken.isEmpty()) {
    throw getSyntaxError(""String_Node_Str"");
  }
  statement.setColumnSelector(currentSelector);
  statement.setSelectors(selectors);
  statement.setQueryOptions(options);
  Expression where=null;
  for (  Selector s : selectors) {
    where=Expression.and(where,s.condition);
  }
  statement.setWhere(where);
  return statement;
}",0.9929751789656788
8736,"private Statement convertToUnion(String query,Statement statement,int startParseIndex) throws ParseException {
  int start=query.indexOf(""String_Node_Str"",startParseIndex);
  String begin=query.substring(0,start);
  XPathToSQL2Converter converter=new XPathToSQL2Converter();
  String partList=query.substring(start);
  converter.initialize(partList);
  converter.read();
  int lastParseIndex=converter.parseIndex;
  int lastOrIndex=lastParseIndex;
  converter.read(""String_Node_Str"");
  int level=0;
  ArrayList<String> parts=new ArrayList<String>();
  while (true) {
    int parseIndex=converter.parseIndex;
    if (converter.readIf(""String_Node_Str"")) {
      level++;
    }
 else     if (converter.readIf(""String_Node_Str"") && level-- <= 0) {
      break;
    }
 else     if (converter.readIf(""String_Node_Str"") && level == 0) {
      String or=partList.substring(lastOrIndex,lastParseIndex);
      parts.add(or);
      lastOrIndex=parseIndex;
    }
 else     if (currentTokenType == END) {
      throw getSyntaxError(""String_Node_Str"");
    }
 else {
      converter.read();
    }
    lastParseIndex=parseIndex;
  }
  String or=partList.substring(lastOrIndex,lastParseIndex);
  parts.add(or);
  String end=partList.substring(lastParseIndex + 1);
  Statement result=null;
  for (  String p : parts) {
    String q=begin + p + end;
    converter=new XPathToSQL2Converter();
    Statement stat=converter.convertToStatement(q);
    if (result == null) {
      result=stat;
    }
 else {
      UnionStatement union=new UnionStatement(result,stat);
      union.orderList=stat.orderList;
      union.queryOptions=stat.queryOptions;
      result=union;
    }
    stat.orderList=new ArrayList<Order>();
    stat.queryOptions=new QueryOptions();
  }
  return result;
}","private Statement convertToUnion(String query,Statement statement,int startParseIndex) throws ParseException {
  int start=query.indexOf(""String_Node_Str"",startParseIndex);
  String begin=query.substring(0,start);
  XPathToSQL2Converter converter=new XPathToSQL2Converter();
  String partList=query.substring(start);
  converter.initialize(partList);
  converter.read();
  int lastParseIndex=converter.parseIndex;
  int lastOrIndex=lastParseIndex;
  converter.read(""String_Node_Str"");
  int level=0;
  ArrayList<String> parts=new ArrayList<String>();
  int parseIndex;
  while (true) {
    parseIndex=converter.parseIndex;
    if (converter.readIf(""String_Node_Str"")) {
      level++;
    }
 else     if (converter.readIf(""String_Node_Str"") && level-- <= 0) {
      break;
    }
 else     if (converter.readIf(""String_Node_Str"") && level == 0) {
      String or=partList.substring(lastOrIndex,lastParseIndex);
      parts.add(or);
      lastOrIndex=parseIndex;
    }
 else     if (converter.currentTokenType == END) {
      throw getSyntaxError(""String_Node_Str"");
    }
 else {
      converter.read();
    }
    lastParseIndex=parseIndex;
  }
  String or=partList.substring(lastOrIndex,lastParseIndex);
  parts.add(or);
  String end=partList.substring(parseIndex);
  Statement result=null;
  for (  String p : parts) {
    String q=begin + p + end;
    converter=new XPathToSQL2Converter();
    Statement stat=converter.convertToStatement(q);
    if (result == null) {
      result=stat;
    }
 else {
      UnionStatement union=new UnionStatement(result,stat);
      union.orderList=stat.orderList;
      union.queryOptions=stat.queryOptions;
      result=union;
    }
    stat.orderList=new ArrayList<Order>();
    stat.queryOptions=new QueryOptions();
  }
  return result;
}",0.9830508474576272
8737,"/** 
 * Defines the mapping of internal property names from external values. Only the external properties defined as keys of this map are synced with the mapped internal properties. note that the property names can be relative paths. the intermediate nodes will be created accordingly. Example: <xmp> { ""rep:fullname"": ""cn"", ""country"", ""c"", ""profile/email"": ""mail"", ""profile/givenName"": ""cn"" } </xmp> The implicit properties like userid, groupname, password must not be mapped.
 * @return the property mapping where the keys are the local property names and the values the external ones.
 */
@Nonnull public Map<String,String> getPropertyMapping(){
  return propertyMapping == null ? Collections.<String,String>emptyMap() : propertyMapping;
}","/** 
 * Defines the mapping of internal property names from external values. Only the external properties defined as keys of this map are synced with the mapped internal properties. note that the property names can be relative paths. the intermediate nodes will be created accordingly. Example: <pre>  {@code}{ ""rep:fullname"": ""cn"", ""country"", ""c"", ""profile/email"": ""mail"", ""profile/givenName"": ""cn"" } }</pre> The implicit properties like userid, groupname, password must not be mapped.
 * @return the property mapping where the keys are the local property names and the values the external ones.
 */
@Nonnull public Map<String,String> getPropertyMapping(){
  return propertyMapping == null ? Collections.<String,String>emptyMap() : propertyMapping;
}",0.985934360348292
8738,"/** 
 * Returns the LDAP filter that is used when searching for groups where an identity is member of. The filter is based on the configuration and has the following format: <pre> (&(${memberAttribute}=${dn})(objectclass=${objectclass})${extraFilter}) </pre> Note that the objectclass part is repeated according to the specified objectclasses in  {@link Identity#getObjectClasses()} of the group configuration.
 * @param dn the dn of the identity to search for
 * @return the search filter
 */
public String getMemberOfSearchFilter(@Nonnull String dn){
  if (memberOfFilterTemplate == null) {
    StringBuilder filter=new StringBuilder(""String_Node_Str"").append(groupMemberAttribute).append(""String_Node_Str"");
    for (    String objectClass : groupConfig.objectClasses) {
      filter.append(""String_Node_Str"").append(encodeFilterValue(objectClass)).append(')');
    }
    if (groupConfig.extraFilter != null && groupConfig.extraFilter.length() > 0) {
      filter.append(groupConfig.extraFilter);
    }
    filter.append(')');
    memberOfFilterTemplate=filter.toString();
  }
  return String.format(memberOfFilterTemplate,encodeFilterValue(dn));
}","/** 
 * Returns the LDAP filter that is used when searching for groups where an identity is member of. The filter is based on the configuration and has the following format: <pre>  {@code}(&($ memberAttribute}=${dn})(objectclass=${objectclass})${extraFilter}) }</pre> Note that the objectclass part is repeated according to the specified objectclasses in  {@link Identity#getObjectClasses()} of the group configuration.
 * @param dn the dn of the identity to search for
 * @return the search filter
 */
public String getMemberOfSearchFilter(@Nonnull String dn){
  if (memberOfFilterTemplate == null) {
    StringBuilder filter=new StringBuilder(""String_Node_Str"").append(groupMemberAttribute).append(""String_Node_Str"");
    for (    String objectClass : groupConfig.objectClasses) {
      filter.append(""String_Node_Str"").append(encodeFilterValue(objectClass)).append(')');
    }
    if (groupConfig.extraFilter != null && groupConfig.extraFilter.length() > 0) {
      filter.append(groupConfig.extraFilter);
    }
    filter.append(')');
    memberOfFilterTemplate=filter.toString();
  }
  return String.format(memberOfFilterTemplate,encodeFilterValue(dn));
}",0.99524015577672
8739,"/** 
 * Returns the LDAP filter that is used when searching this type of identity. The filter is based on the configuration and has the following format: <pre> (&(${idAttr}=${id})(objectclass=${objectclass})${extraFilter}) </pre> Note that the objectclass part is repeated according to the specified objectclasses in   {@link #getObjectClasses()}.
 * @param id the id value
 * @return the search filter
 */
@Nonnull public String getSearchFilter(@Nonnull String id){
  if (filterTemplate == null) {
    StringBuilder filter=new StringBuilder(""String_Node_Str"").append(idAttribute).append(""String_Node_Str"");
    for (    String objectClass : objectClasses) {
      filter.append(""String_Node_Str"").append(encodeFilterValue(objectClass)).append(')');
    }
    if (extraFilter != null && extraFilter.length() > 0) {
      filter.append(extraFilter);
    }
    filter.append(')');
    filterTemplate=filter.toString();
  }
  return String.format(filterTemplate,encodeFilterValue(id));
}","/** 
 * Returns the LDAP filter that is used when searching this type of identity. The filter is based on the configuration and has the following format: <pre>  {@code}(&($ idAttr}=${id})(objectclass=${objectclass})${extraFilter}) }</pre> Note that the objectclass part is repeated according to the specified objectclasses in   {@link #getObjectClasses()}.
 * @param id the id value
 * @return the search filter
 */
@Nonnull public String getSearchFilter(@Nonnull String id){
  if (filterTemplate == null) {
    StringBuilder filter=new StringBuilder(""String_Node_Str"").append(idAttribute).append(""String_Node_Str"");
    for (    String objectClass : objectClasses) {
      filter.append(""String_Node_Str"").append(encodeFilterValue(objectClass)).append(')');
    }
    if (extraFilter != null && extraFilter.length() > 0) {
      filter.append(extraFilter);
    }
    filter.append(')');
    filterTemplate=filter.toString();
  }
  return String.format(filterTemplate,encodeFilterValue(id));
}",0.9944360141628732
8740,"/** 
 * <p> consolidate the   {@link #PREFIX_PROP_COUNTER} properties and sum them into the{@link #PROP_COUNTER}</p> <p> The passed in   {@code NodeBuilder} must have{@link org.apache.jackrabbit.JcrConstants#JCR_MIXINTYPES JCR_MIXINTYPES} with{@link org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants#MIX_ATOMIC_COUNTER MIX_ATOMIC_COUNTER}. If not it will be silently ignored. </p>
 * @param builder the builder to work on. Cannot be null.
 */
public static void consolidateCount(@Nonnull final NodeBuilder builder){
  long count=0;
  for (  PropertyState p : builder.getProperties()) {
    if (p.getName().startsWith(PREFIX_PROP_COUNTER)) {
      count+=p.getValue(LONG);
    }
  }
  builder.setProperty(PROP_COUNTER,count);
}","/** 
 * <p> consolidate the   {@link #PREFIX_PROP_COUNTER} properties and sum them into the{@link #PROP_COUNTER}</p> <p> The passed in   {@code NodeBuilder} must have{@link org.apache.jackrabbit.JcrConstants#JCR_MIXINTYPES JCR_MIXINTYPES} with{@link NodeTypeConstants#MIX_ATOMIC_COUNTER MIX_ATOMIC_COUNTER}. If not it will be silently ignored. </p>
 * @param builder the builder to work on. Cannot be null.
 */
public static void consolidateCount(@Nonnull final NodeBuilder builder){
  long count=0;
  for (  PropertyState p : builder.getProperties()) {
    if (p.getName().startsWith(PREFIX_PROP_COUNTER)) {
      count+=p.getValue(LONG);
    }
  }
  builder.setProperty(PROP_COUNTER,count);
}",0.9699510831586304
8741,"/** 
 * <p> Plain Java oriented constructor. Refer to  {@link AtomicCounterEditor#AtomicCounterEditor(NodeBuilder,String,ScheduledExecutorService,NodeStore)}for constructions details of the actual editor. </p> <p> Based on the use case this may need an already set of the constructor parameters during the repository construction. Please ensure they're registered before this provider is registered. </p>
 * @param clusterInfo cluster node information
 * @param executor the executor for running asynchronously.
 * @param store reference to the NodeStore.
 * @param whiteboard the underlying board for picking up the registered {@link CommitHook}
 */
public AtomicCounterEditorProvider(@Nullable Supplier<Clusterable> clusterInfo,@Nullable Supplier<ScheduledExecutorService> executor,@Nullable Supplier<NodeStore> store,@Nullable Supplier<Whiteboard> whiteboard){
  this.clusterSupplier=clusterInfo;
  this.schedulerSupplier=executor;
  this.storeSupplier=store;
  this.wbSupplier=whiteboard;
}","/** 
 * <p> Plain Java oriented constructor. Refer to  {@link AtomicCounterEditor#AtomicCounterEditor(NodeBuilder,String,ScheduledExecutorService,NodeStore,Whiteboard)}for constructions details of the actual editor. </p> <p> Based on the use case this may need an already set of the constructor parameters during the repository construction. Please ensure they're registered before this provider is registered. </p>
 * @param clusterInfo cluster node information
 * @param executor the executor for running asynchronously.
 * @param store reference to the NodeStore.
 * @param whiteboard the underlying board for picking up the registered {@link CommitHook}
 */
public AtomicCounterEditorProvider(@Nullable Supplier<Clusterable> clusterInfo,@Nullable Supplier<ScheduledExecutorService> executor,@Nullable Supplier<NodeStore> store,@Nullable Supplier<Whiteboard> whiteboard){
  this.clusterSupplier=clusterInfo;
  this.schedulerSupplier=executor;
  this.storeSupplier=store;
  this.wbSupplier=whiteboard;
}",0.994497248624312
8742,"/** 
 * Collect references.
 * @param collector the collector to collect all references
 * @return the references
 * @throws Exception the exception
 */
void collectReferences(ReferenceCollector collector);","/** 
 * Collect references.
 * @param collector the collector to collect all references
 */
void collectReferences(ReferenceCollector collector);",0.8262108262108262
8743,"/** 
 * Sweep phase of gc candidate deletion. <p> Performs the following steps depending upon the type of the blob store refer  {@link org.apache.jackrabbit.oak.plugins.blob.SharedDataStore.Type}: <ul> <li>Shared</li> <ul> <li> Merge all marked references (from the mark phase run independently) available in the data store meta store (from all configured independent repositories). <li> Retrieve all blob ids available. <li> Diffs the 2 sets above to retrieve list of blob ids not used. <li> Deletes only blobs created after (earliest time stamp of the marked references - #maxLastModifiedInterval) from the above set. </ul> <li>Default</li> <ul> <li> Mark phase already run. <li> Retrieve all blob ids available. <li> Diffs the 2 sets above to retrieve list of blob ids not used. <li> Deletes only blobs created after (time stamp of the marked references - #maxLastModifiedInterval). </ul> </ul>
 * @return the number of blobs deleted
 * @throws Exception the exception
 * @param fs the garbage collector file state
 * @param markStart the start time of mark to take as reference for deletion
 */
protected long sweep(GarbageCollectorFileState fs,long markStart) throws Exception {
  long earliestRefAvailTime;
  try {
    earliestRefAvailTime=GarbageCollectionType.get(blobStore).mergeAllMarkedReferences(blobStore,fs);
    LOG.debug(""String_Node_Str"",earliestRefAvailTime);
    earliestRefAvailTime=(earliestRefAvailTime < markStart ? earliestRefAvailTime : markStart);
  }
 catch (  Exception e) {
    return 0;
  }
  (new BlobIdRetriever(fs)).call();
  difference(fs);
  long count=0;
  long deleted=0;
  long lastMaxModifiedTime=getLastMaxModifiedTime(earliestRefAvailTime);
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"",timestampToString(lastMaxModifiedTime));
  ConcurrentLinkedQueue<String> exceptionQueue=new ConcurrentLinkedQueue<String>();
  LineIterator iterator=FileUtils.lineIterator(fs.getGcCandidates(),Charsets.UTF_8.name());
  List<String> ids=newArrayList();
  while (iterator.hasNext()) {
    ids.add(iterator.next());
    if (ids.size() >= getBatchCount()) {
      count+=ids.size();
      deleted+=sweepInternal(ids,exceptionQueue,lastMaxModifiedTime);
      ids=newArrayList();
    }
  }
  if (!ids.isEmpty()) {
    count+=ids.size();
    deleted+=sweepInternal(ids,exceptionQueue,lastMaxModifiedTime);
  }
  BufferedWriter writer=null;
  try {
    if (!exceptionQueue.isEmpty()) {
      writer=Files.newWriter(fs.getGarbage(),Charsets.UTF_8);
      saveBatchToFile(newArrayList(exceptionQueue),writer);
    }
  }
  finally {
    LineIterator.closeQuietly(iterator);
    IOUtils.closeQuietly(writer);
  }
  if (!exceptionQueue.isEmpty()) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",fs.getGarbage().getAbsolutePath());
  }
  if (count != deleted) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",deleted,count,timestampToString(lastMaxModifiedTime));
  }
  GarbageCollectionType.get(blobStore).removeAllMarkedReferences(blobStore);
  LOG.debug(""String_Node_Str"");
  return deleted;
}","/** 
 * Sweep phase of gc candidate deletion. <p> Performs the following steps depending upon the type of the blob store refer  {@link org.apache.jackrabbit.oak.plugins.blob.SharedDataStore.Type}: <ul> <li>Shared</li> <li> <ul> <li> Merge all marked references (from the mark phase run independently) available in the data store meta store (from all configured independent repositories). <li> Retrieve all blob ids available. <li> Diffs the 2 sets above to retrieve list of blob ids not used. <li> Deletes only blobs created after (earliest time stamp of the marked references - #maxLastModifiedInterval) from the above set. </ul> </li> <li>Default</li> <li> <ul> <li> Mark phase already run. <li> Retrieve all blob ids available. <li> Diffs the 2 sets above to retrieve list of blob ids not used. <li> Deletes only blobs created after (time stamp of the marked references - #maxLastModifiedInterval). </ul> </li> </ul>
 * @return the number of blobs deleted
 * @throws Exception the exception
 * @param fs the garbage collector file state
 * @param markStart the start time of mark to take as reference for deletion
 */
protected long sweep(GarbageCollectorFileState fs,long markStart) throws Exception {
  long earliestRefAvailTime;
  try {
    earliestRefAvailTime=GarbageCollectionType.get(blobStore).mergeAllMarkedReferences(blobStore,fs);
    LOG.debug(""String_Node_Str"",earliestRefAvailTime);
    earliestRefAvailTime=(earliestRefAvailTime < markStart ? earliestRefAvailTime : markStart);
  }
 catch (  Exception e) {
    return 0;
  }
  (new BlobIdRetriever(fs)).call();
  difference(fs);
  long count=0;
  long deleted=0;
  long lastMaxModifiedTime=getLastMaxModifiedTime(earliestRefAvailTime);
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"",timestampToString(lastMaxModifiedTime));
  ConcurrentLinkedQueue<String> exceptionQueue=new ConcurrentLinkedQueue<String>();
  LineIterator iterator=FileUtils.lineIterator(fs.getGcCandidates(),Charsets.UTF_8.name());
  List<String> ids=newArrayList();
  while (iterator.hasNext()) {
    ids.add(iterator.next());
    if (ids.size() >= getBatchCount()) {
      count+=ids.size();
      deleted+=sweepInternal(ids,exceptionQueue,lastMaxModifiedTime);
      ids=newArrayList();
    }
  }
  if (!ids.isEmpty()) {
    count+=ids.size();
    deleted+=sweepInternal(ids,exceptionQueue,lastMaxModifiedTime);
  }
  BufferedWriter writer=null;
  try {
    if (!exceptionQueue.isEmpty()) {
      writer=Files.newWriter(fs.getGarbage(),Charsets.UTF_8);
      saveBatchToFile(newArrayList(exceptionQueue),writer);
    }
  }
  finally {
    LineIterator.closeQuietly(iterator);
    IOUtils.closeQuietly(writer);
  }
  if (!exceptionQueue.isEmpty()) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",fs.getGarbage().getAbsolutePath());
  }
  if (count != deleted) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",deleted,count,timestampToString(lastMaxModifiedTime));
  }
  GarbageCollectionType.get(blobStore).removeAllMarkedReferences(blobStore);
  LOG.debug(""String_Node_Str"");
  return deleted;
}",0.9964134333224648
8744,"/** 
 * Adds the root record.
 * @param stream the stream
 * @param name the name of the root record
 * @return the data record
 * @throws DataStoreException the data store exception
 */
void addMetadataRecord(InputStream stream,String name) throws DataStoreException ;","/** 
 * Adds the root record.
 * @param stream the stream
 * @param name the name of the root record
 * @throws DataStoreException the data store exception
 */
void addMetadataRecord(InputStream stream,String name) throws DataStoreException ;",0.9471624266144814
8745,"/** 
 * Check if _lastRev recovery needed for this cluster node state is Active && currentTime past the leaseEnd time
 */
public boolean isRecoveryNeeded(@Nonnull ClusterNodeInfoDocument nodeInfo){
  return nodeInfo.isActive() && clock.getTime() > nodeInfo.getLeaseEndTime();
}","/** 
 * Check if _lastRev recovery needed for this cluster node state is Active and currentTime past the leaseEnd time
 */
public boolean isRecoveryNeeded(@Nonnull ClusterNodeInfoDocument nodeInfo){
  return nodeInfo.isActive() && clock.getTime() > nodeInfo.getLeaseEndTime();
}",0.990990990990991
8746,"/** 
 * Reconstructs a   {@link} Document) based on the persisted {@link RDBRow}.
 */
@Nonnull public <T extends Document>T fromRow(@Nonnull Collection<T> collection,@Nonnull RDBRow row) throws DocumentStoreException {
  T doc=collection.newDocument(store);
  doc.put(ID,row.getId());
  doc.put(MODIFIED,row.getModified());
  doc.put(MODCOUNT,row.getModcount());
  if (RDBDocumentStore.USECMODCOUNT) {
    doc.put(CMODCOUNT,row.getCollisionsModcount());
  }
  if (row.hasBinaryProperties()) {
    doc.put(HASBINARY,NodeDocument.HAS_BINARY_VAL);
  }
  if (row.deletedOnce()) {
    doc.put(DELETEDONCE,Boolean.TRUE);
  }
  byte[] bdata=row.getBdata();
  boolean blobInUse=false;
  JsopTokenizer json;
  try {
    if (bdata != null && bdata.length != 0) {
      String s=fromBlobData(bdata);
      json=new JsopTokenizer(s);
      json.read('{');
      readDocumentFromJson(json,doc);
      json.read(JsopReader.END);
      blobInUse=true;
    }
  }
 catch (  Exception ex) {
    throw new DocumentStoreException(ex);
  }
  String charData=row.getData();
  json=new JsopTokenizer(charData);
  try {
    int next=json.read();
    if (next == '{') {
      if (blobInUse) {
        throw new DocumentStoreException(""String_Node_Str"" + row.getData());
      }
      readDocumentFromJson(json,doc);
    }
 else     if (next == JsopReader.STRING) {
      if (!blobInUse) {
        throw new DocumentStoreException(""String_Node_Str"" + row.getData());
      }
      if (!""String_Node_Str"".equals(json.getToken())) {
        throw new DocumentStoreException(""String_Node_Str"");
      }
    }
 else {
      throw new DocumentStoreException(""String_Node_Str"" + next + ""String_Node_Str""+ row.getData());
    }
    next=json.read();
    if (next == ',') {
      do {
        Object ob=JSON.parse(json);
        if (!(ob instanceof List)) {
          throw new DocumentStoreException(""String_Node_Str"" + ob);
        }
        List<List<Object>> update=(List<List<Object>>)ob;
        for (        List<Object> op : update) {
          applyUpdate(doc,update,op);
        }
      }
 while (json.matches(','));
    }
    json.read(JsopReader.END);
    return doc;
  }
 catch (  Exception ex) {
    String message=String.format(""String_Node_Str"",row.getId());
    if (charData.length() > 0) {
      int last=charData.charAt(charData.length() - 1);
      if (last != '}' && last != '""' && last != ']') {
        message+=""String_Node_Str"";
      }
    }
    LOG.error(message,ex);
    throw new DocumentStoreException(message,ex);
  }
}","/** 
 * Reconstructs a   {@link Document} based on the persisted {@link RDBRow}.
 */
@Nonnull public <T extends Document>T fromRow(@Nonnull Collection<T> collection,@Nonnull RDBRow row) throws DocumentStoreException {
  T doc=collection.newDocument(store);
  doc.put(ID,row.getId());
  doc.put(MODIFIED,row.getModified());
  doc.put(MODCOUNT,row.getModcount());
  if (RDBDocumentStore.USECMODCOUNT) {
    doc.put(CMODCOUNT,row.getCollisionsModcount());
  }
  if (row.hasBinaryProperties()) {
    doc.put(HASBINARY,NodeDocument.HAS_BINARY_VAL);
  }
  if (row.deletedOnce()) {
    doc.put(DELETEDONCE,Boolean.TRUE);
  }
  byte[] bdata=row.getBdata();
  boolean blobInUse=false;
  JsopTokenizer json;
  try {
    if (bdata != null && bdata.length != 0) {
      String s=fromBlobData(bdata);
      json=new JsopTokenizer(s);
      json.read('{');
      readDocumentFromJson(json,doc);
      json.read(JsopReader.END);
      blobInUse=true;
    }
  }
 catch (  Exception ex) {
    throw new DocumentStoreException(ex);
  }
  String charData=row.getData();
  json=new JsopTokenizer(charData);
  try {
    int next=json.read();
    if (next == '{') {
      if (blobInUse) {
        throw new DocumentStoreException(""String_Node_Str"" + row.getData());
      }
      readDocumentFromJson(json,doc);
    }
 else     if (next == JsopReader.STRING) {
      if (!blobInUse) {
        throw new DocumentStoreException(""String_Node_Str"" + row.getData());
      }
      if (!""String_Node_Str"".equals(json.getToken())) {
        throw new DocumentStoreException(""String_Node_Str"");
      }
    }
 else {
      throw new DocumentStoreException(""String_Node_Str"" + next + ""String_Node_Str""+ row.getData());
    }
    next=json.read();
    if (next == ',') {
      do {
        Object ob=JSON.parse(json);
        if (!(ob instanceof List)) {
          throw new DocumentStoreException(""String_Node_Str"" + ob);
        }
        List<List<Object>> update=(List<List<Object>>)ob;
        for (        List<Object> op : update) {
          applyUpdate(doc,update,op);
        }
      }
 while (json.matches(','));
    }
    json.read(JsopReader.END);
    return doc;
  }
 catch (  Exception ex) {
    String message=String.format(""String_Node_Str"",row.getId());
    if (charData.length() > 0) {
      int last=charData.charAt(charData.length() - 1);
      if (last != '}' && last != '""' && last != ']') {
        message+=""String_Node_Str"";
      }
    }
    LOG.error(message,ex);
    throw new DocumentStoreException(message,ex);
  }
}",0.996223414828066
8747,"/** 
 * @param useRevisionMaps whether to use  {@link RevisionMap}s instead of regular  {@link Map}s.
 */
public RDBJSONSupport(boolean useRevisionMaps){
  this.useRevisionMaps=useRevisionMaps;
}","/** 
 * @param useRevisionMaps whether to use revision maps instead of regular {@link Map}s.
 */
public RDBJSONSupport(boolean useRevisionMaps){
  this.useRevisionMaps=useRevisionMaps;
}",0.9606299212598424
8748,"/** 
 * Returns the parent id for given id if possible <p>It would return null in following cases <ul> <li>If id is from long path</li> <li>If id is for root path</li> <li>If id is for an invalid path</li> </ul> </p>
 * @param id id for which parent id needs to be determined
 * @return parent id. null if parent id cannot be determined
 */
@CheckForNull public static String getParentId(String id){
  if (Utils.isIdFromLongPath(id)) {
    return null;
  }
  String path=Utils.getPathFromId(id);
  if (!PathUtils.isValid(path)) {
    return null;
  }
  if (PathUtils.denotesRoot(path)) {
    return null;
  }
  String parentPath=PathUtils.getParentPath(path);
  return Utils.getIdFromPath(parentPath);
}","/** 
 * Returns the parent id for given id if possible <p>It would return null in following cases <ul> <li>If id is from long path</li> <li>If id is for root path</li> <li>If id is for an invalid path</li> </ul>
 * @param id id for which parent id needs to be determined
 * @return parent id. null if parent id cannot be determined
 */
@CheckForNull public static String getParentId(String id){
  if (Utils.isIdFromLongPath(id)) {
    return null;
  }
  String path=Utils.getPathFromId(id);
  if (!PathUtils.isValid(path)) {
    return null;
  }
  if (PathUtils.denotesRoot(path)) {
    return null;
  }
  String parentPath=PathUtils.getParentPath(path);
  return Utils.getIdFromPath(parentPath);
}",0.9964311206281228
8749,"/** 
 * Calculates the applicable definition for the property with the specified characteristics under a parent with this effective type.
 * @param propertyName The internal oak name of the property for which thedefinition should be retrieved.
 * @param isMultiple {@code true} if the target property is multi-valued.
 * @param type The target type of the property.
 * @param exactTypeMatch {@code true} if the required type of the definitionmust exactly match the type of the target property.
 * @return the applicable definition for the target property.
 * @throws ConstraintViolationException If no matching definition can be found.
 * @throws RepositoryException If another error occurs.
 */
public PropertyDefinition getPropertyDefinition(String propertyName,boolean isMultiple,int type,boolean exactTypeMatch) throws ConstraintViolationException {
  for (  PropertyDefinition def : getNamedPropertyDefinitions(propertyName)) {
    int defType=def.getRequiredType();
    if (isMultiple == def.isMultiple() && (!exactTypeMatch || (type == defType || UNDEFINED == type || UNDEFINED == defType))) {
      return def;
    }
  }
  for (  PropertyDefinition def : getResidualPropertyDefinitions()) {
    int defType=def.getRequiredType();
    if (isMultiple == def.isMultiple() && (!exactTypeMatch || (type == defType || UNDEFINED == type || UNDEFINED == defType))) {
      return def;
    }
  }
  throw new ConstraintViolationException(""String_Node_Str"" + propertyName);
}","/** 
 * Calculates the applicable definition for the property with the specified characteristics under a parent with this effective type.
 * @param propertyName The internal oak name of the property for which thedefinition should be retrieved.
 * @param isMultiple {@code true} if the target property is multi-valued.
 * @param type The target type of the property.
 * @param exactTypeMatch {@code true} if the required type of the definitionmust exactly match the type of the target property.
 * @return the applicable definition for the target property.
 * @throws ConstraintViolationException If no matching definition can be found.
 */
public PropertyDefinition getPropertyDefinition(String propertyName,boolean isMultiple,int type,boolean exactTypeMatch) throws ConstraintViolationException {
  for (  PropertyDefinition def : getNamedPropertyDefinitions(propertyName)) {
    int defType=def.getRequiredType();
    if (isMultiple == def.isMultiple() && (!exactTypeMatch || (type == defType || UNDEFINED == type || UNDEFINED == defType))) {
      return def;
    }
  }
  for (  PropertyDefinition def : getResidualPropertyDefinitions()) {
    int defType=def.getRequiredType();
    if (isMultiple == def.isMultiple() && (!exactTypeMatch || (type == defType || UNDEFINED == type || UNDEFINED == defType))) {
      return def;
    }
  }
  throw new ConstraintViolationException(""String_Node_Str"" + propertyName);
}",0.9806094182825484
8750,"/** 
 * Tries to retrieve the tree corresponding to specified   {@code versionTree}outside of the version storage based on versionable path information stored with the version history. The following cases are distinguished: <ul> <li>Version History: If the given tree is a version history the associated versionable tree in the specified workspace is being returned based on the information stored in the versionable path property. If no versionable path property is present   {@code null} is returned.</li><li>Version: Same as for version history.</li> <li>Version Labels: Same as for version history.</li> <li>Frozen Node: If the given tree forms part of a frozen node the path of the target node is computed from the versionable path and the relative path of the frozen node.</li> <li>Other Nodes: If the specified tree is not part of the tree structure defined by a version history,  {@code null} will be returned.</li></ul> Please note that this method will not verify if the tree at the versionable path or the computed subtree actually exists. This must be asserted by the caller before operating on the tree.
 * @param versionTree The tree from within the version storage for whichthat versionable correspondent should be retrieved.
 * @param workspaceName The name of the workspace for which the target should be retrieved.
 * @return A existing or non-existing tree pointing to the location of thecorrespondent tree outside of the version storage or  {@code null} if theversionable path property for the specified workspace is missing or if the given tree is not located within the tree structure defined by a version history.
 * @see {@link VersionablePathHook}
 * @see {@link VersionConstants#MIX_REP_VERSIONABLE_PATHS}
 */
@CheckForNull public Tree getVersionable(@Nonnull Tree versionTree,@Nonnull String workspaceName){
  Root root=getWorkspaceRoot();
  String relPath=""String_Node_Str"";
  Tree t=versionTree;
  while (t.exists() && !isVersionStoreTree(t) && !t.isRoot()) {
    String ntName=TreeUtil.getPrimaryTypeName(t);
    if (VersionConstants.NT_FROZENNODE.equals(ntName)) {
      relPath=PathUtils.relativize(t.getPath(),versionTree.getPath());
    }
 else     if (JcrConstants.NT_VERSIONHISTORY.equals(ntName)) {
      PropertyState prop=t.getProperty(workspaceName);
      if (prop != null) {
        return root.getTree(PathUtils.concat(prop.getValue(Type.PATH),relPath));
      }
 else {
        log.warn(""String_Node_Str"",workspaceName,t.getPath());
        break;
      }
    }
    t=t.getParent();
  }
  return null;
}","/** 
 * Tries to retrieve the tree corresponding to specified   {@code versionTree}outside of the version storage based on versionable path information stored with the version history. The following cases are distinguished: <ul> <li>Version History: If the given tree is a version history the associated versionable tree in the specified workspace is being returned based on the information stored in the versionable path property. If no versionable path property is present   {@code null} is returned.</li><li>Version: Same as for version history.</li> <li>Version Labels: Same as for version history.</li> <li>Frozen Node: If the given tree forms part of a frozen node the path of the target node is computed from the versionable path and the relative path of the frozen node.</li> <li>Other Nodes: If the specified tree is not part of the tree structure defined by a version history,  {@code null} will be returned.</li></ul> Please note that this method will not verify if the tree at the versionable path or the computed subtree actually exists. This must be asserted by the caller before operating on the tree.
 * @param versionTree The tree from within the version storage for whichthat versionable correspondent should be retrieved.
 * @param workspaceName The name of the workspace for which the target should be retrieved.
 * @return A existing or non-existing tree pointing to the location of thecorrespondent tree outside of the version storage or  {@code null} if theversionable path property for the specified workspace is missing or if the given tree is not located within the tree structure defined by a version history.
 * @see VersionablePathHook
 * @see VersionConstants#MIX_REP_VERSIONABLE_PATHS
 */
@CheckForNull public Tree getVersionable(@Nonnull Tree versionTree,@Nonnull String workspaceName){
  Root root=getWorkspaceRoot();
  String relPath=""String_Node_Str"";
  Tree t=versionTree;
  while (t.exists() && !isVersionStoreTree(t) && !t.isRoot()) {
    String ntName=TreeUtil.getPrimaryTypeName(t);
    if (VersionConstants.NT_FROZENNODE.equals(ntName)) {
      relPath=PathUtils.relativize(t.getPath(),versionTree.getPath());
    }
 else     if (JcrConstants.NT_VERSIONHISTORY.equals(ntName)) {
      PropertyState prop=t.getProperty(workspaceName);
      if (prop != null) {
        return root.getTree(PathUtils.concat(prop.getValue(Type.PATH),relPath));
      }
 else {
        log.warn(""String_Node_Str"",workspaceName,t.getPath());
        break;
      }
    }
    t=t.getParent();
  }
  return null;
}",0.986608901142182
8751,"/** 
 * <i>Copied from Apache Jackrabbit Core</i> <p> Calculates the name of the new version that will be created by a checkin call. The name is determined as follows: <ul> <li> first the predecessor version with the shortest name is searched. <li> if that predecessor version is the root version, the new version gets the name ""{number of successors}+1"" + "".0"" <li> if that predecessor version has no successor, the last digit of it's version number is incremented. <li> if that predecessor version has successors but the incremented name does not exist, that name is used. <li> otherwise a "".0"" is added to the name until a non conflicting name is found. <ul> </p> Example Graph: <pre> jcr:rootVersion |     | 1.0   2.0 | 1.1 | 1.2 ---\  ------\ |      \        \ 1.3   1.2.0   1.2.0.0 |      | 1.4   1.2.1 ----\ |      |        \ 1.5   1.2.2   1.2.1.0 |      |        | 1.6     |     1.2.1.1 |-----/ 1.7 </pre>
 * @param history the version history
 * @param versionable the node to checkin
 * @return the new version name
 * @throws IllegalStateException if mandatory version properties are missing.
 */
protected String calculateVersion(@Nonnull NodeBuilder history,@Nonnull NodeBuilder versionable) throws IllegalStateException {
  PropertyState predecessors=versionable.getProperty(JCR_PREDECESSORS);
  if (predecessors == null || predecessors.count() == 0) {
    String message;
    if (predecessors == null) {
      message=""String_Node_Str"" + uuidFromNode(versionable);
    }
 else {
      message=""String_Node_Str"" + uuidFromNode(versionable);
    }
    throw new IllegalStateException(message);
  }
  String best=null;
  for (  String id : predecessors.getValue(Type.REFERENCES)) {
    String name=PathUtils.getName(getIdentifierManager().getPath(id));
    if (best == null || name.length() < best.length()) {
      best=name;
    }
  }
  if (best == null) {
    String message=""String_Node_Str"" + uuidFromNode(versionable);
    throw new IllegalStateException(message);
  }
  String versionName=best;
  int pos=versionName.lastIndexOf('.');
  if (pos > 0) {
    String newVersionName=versionName.substring(0,pos + 1) + (Integer.parseInt(versionName.substring(pos + 1)) + 1);
    while (history.hasChildNode(newVersionName)) {
      versionName+=""String_Node_Str"";
      newVersionName=versionName;
    }
    return newVersionName;
  }
 else {
    checkState(history.hasChildNode(JCR_ROOTVERSION));
    NodeBuilder v=history.getChildNode(JCR_ROOTVERSION);
    return String.valueOf(v.getProperty(JCR_SUCCESSORS).count() + 1) + ""String_Node_Str"";
  }
}","/** 
 * <i>Copied from Apache Jackrabbit Core</i> <p> Calculates the name of the new version that will be created by a checkin call. The name is determined as follows: <ul> <li> first the predecessor version with the shortest name is searched. <li> if that predecessor version is the root version, the new version gets the name ""{number of successors}+1"" + "".0"" <li> if that predecessor version has no successor, the last digit of it's version number is incremented. <li> if that predecessor version has successors but the incremented name does not exist, that name is used. <li> otherwise a "".0"" is added to the name until a non conflicting name is found. </ul> <p> Example Graph: <pre> jcr:rootVersion |     | 1.0   2.0 | 1.1 | 1.2 ---\  ------\ |      \        \ 1.3   1.2.0   1.2.0.0 |      | 1.4   1.2.1 ----\ |      |        \ 1.5   1.2.2   1.2.1.0 |      |        | 1.6     |     1.2.1.1 |-----/ 1.7 </pre>
 * @param history the version history
 * @param versionable the node to checkin
 * @return the new version name
 * @throws IllegalStateException if mandatory version properties are missing.
 */
protected String calculateVersion(@Nonnull NodeBuilder history,@Nonnull NodeBuilder versionable) throws IllegalStateException {
  PropertyState predecessors=versionable.getProperty(JCR_PREDECESSORS);
  if (predecessors == null || predecessors.count() == 0) {
    String message;
    if (predecessors == null) {
      message=""String_Node_Str"" + uuidFromNode(versionable);
    }
 else {
      message=""String_Node_Str"" + uuidFromNode(versionable);
    }
    throw new IllegalStateException(message);
  }
  String best=null;
  for (  String id : predecessors.getValue(Type.REFERENCES)) {
    String name=PathUtils.getName(getIdentifierManager().getPath(id));
    if (best == null || name.length() < best.length()) {
      best=name;
    }
  }
  if (best == null) {
    String message=""String_Node_Str"" + uuidFromNode(versionable);
    throw new IllegalStateException(message);
  }
  String versionName=best;
  int pos=versionName.lastIndexOf('.');
  if (pos > 0) {
    String newVersionName=versionName.substring(0,pos + 1) + (Integer.parseInt(versionName.substring(pos + 1)) + 1);
    while (history.hasChildNode(newVersionName)) {
      versionName+=""String_Node_Str"";
      newVersionName=versionName;
    }
    return newVersionName;
  }
 else {
    checkState(history.hasChildNode(JCR_ROOTVERSION));
    NodeBuilder v=history.getChildNode(JCR_ROOTVERSION);
    return String.valueOf(v.getProperty(JCR_SUCCESSORS).count() + 1) + ""String_Node_Str"";
  }
}",0.999609832227858
8752,"@Test public void testUpdateAndDelete() throws Exception {
  byte[] data=new byte[256];
  Random r=new Random(0);
  r.nextBytes(data);
  byte[] digest=getDigest(data);
  RDBBlobStoreFriend.storeBlock(blobStore,digest,0,data);
  String id=StringUtils.convertBytesToHex(digest);
  long until=System.currentTimeMillis() + 1000;
  while (System.currentTimeMillis() < until) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
  RDBBlobStoreFriend.storeBlock(blobStore,digest,0,data);
  Assert.assertFalse(blobStore.deleteChunks(ImmutableList.of(id),System.currentTimeMillis() - 100));
  Assert.assertNotNull(RDBBlobStoreFriend.readBlockFromBackend(blobStore,digest));
}","@Test public void testUpdateAndDelete() throws Exception {
  byte[] data=new byte[256];
  Random r=new Random(0);
  r.nextBytes(data);
  byte[] digest=getDigest(data);
  RDBBlobStoreFriend.storeBlock(blobStore,digest,0,data);
  String id=StringUtils.convertBytesToHex(digest);
  long until=System.currentTimeMillis() + 1000;
  while (System.currentTimeMillis() < until) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
  long beforeUpdateTs=System.currentTimeMillis() - 100;
  RDBBlobStoreFriend.storeBlock(blobStore,digest,0,data);
  Assert.assertFalse(""String_Node_Str"",blobStore.deleteChunks(ImmutableList.of(id),beforeUpdateTs));
  Assert.assertNotNull(RDBBlobStoreFriend.readBlockFromBackend(blobStore,digest));
}",0.9193989071038252
8753,"static Delegatee createInstance(final @Nonnull Repository repository,@Nonnull SyncHandler handler,@Nonnull ExternalIdentityProvider idp){
  Session systemSession;
  try {
    systemSession=Subject.doAs(SystemSubject.INSTANCE,new PrivilegedExceptionAction<Session>(){
      @Override public Session run() throws RepositoryException {
        if (repository instanceof JackrabbitRepository) {
          return ((JackrabbitRepository)repository).login(null,null,null);
        }
 else {
          return repository.login(null,null);
        }
      }
    }
);
  }
 catch (  PrivilegedActionException e) {
    throw new SyncRuntimeException(ERROR_CREATE_DELEGATEE,e);
  }
  if (!(systemSession instanceof JackrabbitSession)) {
    systemSession.logout();
    throw new SyncRuntimeException(""String_Node_Str"");
  }
  try {
    return new Delegatee(handler,idp,(JackrabbitSession)systemSession);
  }
 catch (  RepositoryException e) {
    systemSession.logout();
    throw new SyncRuntimeException(ERROR_CREATE_DELEGATEE,e);
  }
catch (  SyncException e) {
    systemSession.logout();
    throw new SyncRuntimeException(ERROR_CREATE_DELEGATEE,e);
  }
}","static Delegatee createInstance(@Nonnull final Repository repository,@Nonnull SyncHandler handler,@Nonnull ExternalIdentityProvider idp){
  Session systemSession;
  try {
    systemSession=Subject.doAs(SystemSubject.INSTANCE,new PrivilegedExceptionAction<Session>(){
      @Override public Session run() throws RepositoryException {
        if (repository instanceof JackrabbitRepository) {
          return ((JackrabbitRepository)repository).login(null,null,null);
        }
 else {
          return repository.login(null,null);
        }
      }
    }
);
  }
 catch (  PrivilegedActionException e) {
    throw new SyncRuntimeException(ERROR_CREATE_DELEGATEE,e);
  }
  if (!(systemSession instanceof JackrabbitSession)) {
    systemSession.logout();
    throw new SyncRuntimeException(""String_Node_Str"");
  }
  try {
    return new Delegatee(handler,idp,(JackrabbitSession)systemSession);
  }
 catch (  RepositoryException e) {
    systemSession.logout();
    throw new SyncRuntimeException(ERROR_CREATE_DELEGATEE,e);
  }
catch (  SyncException e) {
    systemSession.logout();
    throw new SyncRuntimeException(ERROR_CREATE_DELEGATEE,e);
  }
}",0.9947643979057592
8754,"@Override public long countDeleteChunks(List<String> chunkIds,long maxLastModifiedTime) throws Exception {
  long count=0;
  for (  List<String> chunk : Lists.partition(chunkIds,RDBJDBCTools.MAX_IN_CLAUSE)) {
    Connection con=this.ch.getRWConnection();
    PreparedStatement prepMeta=null;
    PreparedStatement prepData=null;
    try {
      PreparedStatementComponent inClause=RDBJDBCTools.createInStatement(""String_Node_Str"",chunk,false);
      StringBuilder metaStatement=new StringBuilder(""String_Node_Str"" + this.tnMeta + ""String_Node_Str"").append(inClause.getStatementComponent());
      StringBuilder dataStatement=new StringBuilder(""String_Node_Str"" + this.tnData + ""String_Node_Str"").append(inClause.getStatementComponent());
      if (maxLastModifiedTime > 0) {
        metaStatement.append(""String_Node_Str"");
        dataStatement.append(""String_Node_Str"" + this.tnMeta + ""String_Node_Str"");
      }
      prepMeta=con.prepareStatement(metaStatement.toString());
      prepData=con.prepareStatement(dataStatement.toString());
      int mindex=1, dindex=1;
      mindex=inClause.setParameters(prepMeta,mindex);
      dindex=inClause.setParameters(prepData,dindex);
      if (maxLastModifiedTime > 0) {
        prepMeta.setLong(mindex,maxLastModifiedTime);
        prepData.setLong(dindex,maxLastModifiedTime);
      }
      count+=prepMeta.executeUpdate();
      prepData.execute();
    }
  finally {
      closeStatement(prepMeta);
      closeStatement(prepData);
      con.commit();
      this.ch.closeConnection(con);
    }
  }
  return count;
}","@Override public long countDeleteChunks(List<String> chunkIds,long maxLastModifiedTime) throws Exception {
  long count=0;
  for (  List<String> chunk : Lists.partition(chunkIds,RDBJDBCTools.MAX_IN_CLAUSE)) {
    Connection con=this.ch.getRWConnection();
    PreparedStatement prepMeta=null;
    PreparedStatement prepData=null;
    try {
      PreparedStatementComponent inClause=RDBJDBCTools.createInStatement(""String_Node_Str"",chunk,false);
      StringBuilder metaStatement=new StringBuilder(""String_Node_Str"" + this.tnMeta + ""String_Node_Str"").append(inClause.getStatementComponent());
      StringBuilder dataStatement=new StringBuilder(""String_Node_Str"" + this.tnData + ""String_Node_Str"").append(inClause.getStatementComponent());
      if (maxLastModifiedTime > 0) {
        metaStatement.append(""String_Node_Str"");
        dataStatement.append(""String_Node_Str"" + this.tnMeta + ""String_Node_Str"");
      }
      prepMeta=con.prepareStatement(metaStatement.toString());
      prepData=con.prepareStatement(dataStatement.toString());
      int mindex=1, dindex=1;
      mindex=inClause.setParameters(prepMeta,mindex);
      dindex=inClause.setParameters(prepData,dindex);
      if (maxLastModifiedTime > 0) {
        prepMeta.setLong(mindex,maxLastModifiedTime);
        prepData.setLong(dindex,maxLastModifiedTime);
      }
      int deletedMeta=prepMeta.executeUpdate();
      int deletedData=prepData.executeUpdate();
      if (deletedMeta != deletedData) {
        String message=String.format(""String_Node_Str"",deletedMeta,deletedData);
        LOG.info(message);
      }
      count+=deletedMeta;
    }
  finally {
      closeStatement(prepMeta);
      closeStatement(prepData);
      con.commit();
      this.ch.closeConnection(con);
    }
  }
  return count;
}",0.822894815702727
8755,"/** 
 * Get the nth ancestor of a path. The 1st ancestor is the parent path, 2nd ancestor the grandparent path, and so on... <p> If nth <= 0, the path argument is returned as is.
 * @param path the path
 * @param nth  indicates the ancestor level for which the path should becalculated.
 * @return the ancestor path
 */
@Nonnull public static String getAncestorPath(String path,int nth){
}","/** 
 * Get the nth ancestor of a path. The 1st ancestor is the parent path, 2nd ancestor the grandparent path, and so on... <p> If   {@code nth <= 0}, the path argument is returned as is.
 * @param path the path
 * @param nth  indicates the ancestor level for which the path should becalculated.
 * @return the ancestor path
 */
@Nonnull public static String getAncestorPath(String path,int nth){
}",0.9873096446700508
8756,"/** 
 * Set the on complete handler. The handler will run exactly once after the task terminated. If the task has already terminated at the time of this method call the handler will execute immediately. <p/> Note: there is no guarantee to which handler will run when the method is called multiple times with different arguments.
 * @param onComplete listener to invoke upon completion
 */
public void onComplete(Runnable onComplete){
  this.onComplete=onComplete;
  if (isDone()) {
    run(onComplete);
  }
}","/** 
 * Set the on complete handler. The handler will run exactly once after the task terminated. If the task has already terminated at the time of this method call the handler will execute immediately. <p> Note: there is no guarantee to which handler will run when the method is called multiple times with different arguments. </p>
 * @param onComplete listener to invoke upon completion
 */
public void onComplete(Runnable onComplete){
  this.onComplete=onComplete;
  if (isDone()) {
    run(onComplete);
  }
}",0.9941176470588236
8757,"/** 
 * <p> Enable the asynchronous (background) indexing behavior for the provided task name. </p> <p> Please note that when enabling the background indexer, you need to take care of calling <code>#shutdown<code> on the <code>executor<code> provided for this Oak instance. </p>
 */
public Oak withAsyncIndexing(@Nonnull String name,long delayInSeconds){
  if (this.asyncTasks == null) {
    asyncTasks=new HashMap<String,Long>();
  }
  checkState(delayInSeconds > 0,""String_Node_Str"");
  asyncTasks.put(checkNotNull(name),delayInSeconds);
  return this;
}","/** 
 * <p> Enable the asynchronous (background) indexing behavior for the provided task name. </p> <p> Please note that when enabling the background indexer, you need to take care of calling <code>#shutdown</code> on the <code>executor</code> provided for this Oak instance. </p>
 */
public Oak withAsyncIndexing(@Nonnull String name,long delayInSeconds){
  if (this.asyncTasks == null) {
    asyncTasks=new HashMap<String,Long>();
  }
  checkState(delayInSeconds > 0,""String_Node_Str"");
  asyncTasks.put(checkNotNull(name),delayInSeconds);
  return this;
}",0.9982046678635548
8758,"/** 
 * @return the original statement as it was used to construct the object. If not provided the{@link #toString()} will be used instead.
 */
String getStatement();","/** 
 * @return the original statement as it was used to construct the object. If not provided thetoString() will be used instead.
 */
String getStatement();",0.9721362229102168
8759,"/** 
 * Whether this condition will, from now on, always evaluate to false. This is the case for example for full-text constraints if there is no full-text index (unless FullTextComparisonWithoutIndex is enabled). This will also allow is to add conditions that stop further processing for other reasons, similar to ""WHERE ROWNUM < 10"" in Oracle.
 * @return true if further processing should be stopped
 */
public boolean evaluateStop(){
  return false;
}","/** 
 * Whether this condition will, from now on, always evaluate to false. This is the case for example for full-text constraints if there is no full-text index (unless FullTextComparisonWithoutIndex is enabled). This will also allow is to add conditions that stop further processing for other reasons, similar to   {@code ""WHERE ROWNUM < 10""} in Oracle.
 * @return true if further processing should be stopped
 */
public boolean evaluateStop(){
  return false;
}",0.989106753812636
8760,"/** 
 * <b>!Test purpose only! <b> this creates a filter for the given query
 * @param preparing whether this this the prepare phase
 * @return a new filter
 */
public abstract Filter createFilter(boolean preparing);","/** 
 * <b>!Test purpose only! </b> this creates a filter for the given query
 * @param preparing whether this this the prepare phase
 * @return a new filter
 */
public abstract Filter createFilter(boolean preparing);",0.9976905311778292
8761,"/** 
 * Create a   {@code LoginContextProvider} using standard{@link javax.security.auth.login.Configuration#getConfiguration() JAAS}functionality. In case no login configuration for the specified app name can be retrieve this implementation uses the default as defined by  {@link org.apache.jackrabbit.oak.spi.security.authentication.ConfigurationUtil#getDefaultConfiguration(org.apache.jackrabbit.oak.spi.security.ConfigurationParameters)}. <p> The   {@link LoginContextProvider} implementation is intended to be used with<ul> <li>Regular login using JAAS  {@link javax.security.auth.spi.LoginModule} or</li><li>Pre-authenticated subjects in which case any authentication related validation is omitted</li> </ul> <h4>Configuration Options</h4> <ul> <li> {@link #PARAM_APP_NAME}: The appName passed to  {@code Configuration#getAppConfigurationEntry(String)}. The default value is   {@link #DEFAULT_APP_NAME}.</li> </ul>
 * @param contentRepository The content repository.
 * @return An new instance of {@link LoginContextProvider}.
 */
@Nonnull @Override public LoginContextProvider getLoginContextProvider(ContentRepository contentRepository){
  String appName=getParameters().getConfigValue(PARAM_APP_NAME,DEFAULT_APP_NAME);
  SecurityProvider provider=getSecurityProvider();
  Whiteboard whiteboard=null;
  if (provider instanceof WhiteboardAware) {
    whiteboard=((WhiteboardAware)provider).getWhiteboard();
  }
 else {
    log.warn(""String_Node_Str"");
  }
  return new LoginContextProviderImpl(appName,getParameters(),contentRepository,getSecurityProvider(),whiteboard);
}","/** 
 * Create a   {@code LoginContextProvider} using standard{@link javax.security.auth.login.Configuration#getConfiguration() JAAS}functionality. In case no login configuration for the specified app name can be retrieve this implementation uses the default as defined by  {@link org.apache.jackrabbit.oak.spi.security.authentication.ConfigurationUtil#getDefaultConfiguration(org.apache.jackrabbit.oak.spi.security.ConfigurationParameters)}. <p> The   {@link LoginContextProvider} implementation is intended to be used with<ul> <li>Regular login using JAAS  {@link javax.security.auth.spi.LoginModule} or</li><li>Pre-authenticated subjects in which case any authentication related validation is omitted</li> </ul> <h3>Configuration Options</h3> <ul> <li> {@link #PARAM_APP_NAME}: The appName passed to  {@code Configuration#getAppConfigurationEntry(String)}. The default value is   {@link #DEFAULT_APP_NAME}.</li> </ul>
 * @param contentRepository The content repository.
 * @return An new instance of {@link LoginContextProvider}.
 */
@Nonnull @Override public LoginContextProvider getLoginContextProvider(ContentRepository contentRepository){
  String appName=getParameters().getConfigValue(PARAM_APP_NAME,DEFAULT_APP_NAME);
  SecurityProvider provider=getSecurityProvider();
  Whiteboard whiteboard=null;
  if (provider instanceof WhiteboardAware) {
    whiteboard=((WhiteboardAware)provider).getWhiteboard();
  }
 else {
    log.warn(""String_Node_Str"");
  }
  return new LoginContextProviderImpl(appName,getParameters(),contentRepository,getSecurityProvider(),whiteboard);
}",0.9987333755541482
8762,"/** 
 * Returns a cursor wrapper, which returns the ancestor rows at the given <code>level</code> of the wrapped cursor <code>c</code>. With <code>level</code> e.g. set to <code>1</code>, the returned cursor iterates over the parent rows of the passed cursor <code>c</code>. The returned cursor guarantees distinct rows.
 * @param c the cursor to wrap.
 * @param level the ancestor level. Must be >= 1.
 * @return cursor over the ancestors of <code>c</code> at <code>level</code>.
 */
public static Cursor newAncestorCursor(Cursor c,int level,QueryEngineSettings settings){
  checkNotNull(c);
  checkArgument(level >= 1);
  return new AncestorCursor(c,level,settings);
}","/** 
 * Returns a cursor wrapper, which returns the ancestor rows at the given <code>level</code> of the wrapped cursor <code>c</code>. With <code>level</code> e.g. set to <code>1</code>, the returned cursor iterates over the parent rows of the passed cursor <code>c</code>. The returned cursor guarantees distinct rows.
 * @param c the cursor to wrap.
 * @param level the ancestor level. Must be {@code >= 1}.
 * @return cursor over the ancestors of <code>c</code> at <code>level</code>.
 */
public static Cursor newAncestorCursor(Cursor c,int level,QueryEngineSettings settings){
  checkNotNull(c);
  checkArgument(level >= 1);
  return new AncestorCursor(c,level,settings);
}",0.9940652818991098
8763,"/** 
 * Optional method that allows a given user management implementation to provide a specific and optimized implementation of the   {@link PrincipalProvider}interface for the principals represented by the user/groups known to this implementation. If this method returns   {@code null} the security setup will by defaultuse a basic  {@code PrincipalProvider} implementation based on publicuser management API or a combination of other  {@link PrincipalProvider}s as configured with the repository setup.
 * @param root The root used to read the principal information from.
 * @param namePathMapper The {@code NamePathMapper} to convert oak paths to JCR paths.
 * @return An implementation of {@code PrincipalProvider} or {@code null} ifprincipal discovery is provided by other means of if the default principal provider implementation should be used that acts on public user management API.
 * @see {@link org.apache.jackrabbit.oak.spi.security.principal.PrincipalConfiguration}
 */
@Nullable PrincipalProvider getUserPrincipalProvider(@Nonnull Root root,@Nonnull NamePathMapper namePathMapper);","/** 
 * Optional method that allows a given user management implementation to provide a specific and optimized implementation of the   {@link PrincipalProvider}interface for the principals represented by the user/groups known to this implementation. If this method returns   {@code null} the security setup will by defaultuse a basic  {@code PrincipalProvider} implementation based on publicuser management API or a combination of other  {@link PrincipalProvider}s as configured with the repository setup.
 * @param root The root used to read the principal information from.
 * @param namePathMapper The {@code NamePathMapper} to convert oak paths to JCR paths.
 * @return An implementation of {@code PrincipalProvider} or {@code null} ifprincipal discovery is provided by other means of if the default principal provider implementation should be used that acts on public user management API.
 * @see org.apache.jackrabbit.oak.spi.security.principal.PrincipalConfiguration
 */
@Nullable PrincipalProvider getUserPrincipalProvider(@Nonnull Root root,@Nonnull NamePathMapper namePathMapper);",0.9332113449222325
8764,"/** 
 * Returns the name value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre> PropertyState property = builder.getProperty(name); if (property != null && property.getType() == Type.NAME) { return property.getValue(Type.NAME); } else { return null; } </pre>
 * @param name property name
 * @return name value of the named property, or {@code null}
 */
@CheckForNull String getName(@Nonnull String name);","/** 
 * Returns the name value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre>  {@code PropertyState property = builder.getProperty(name);}if (property != null && property.getType() == Type.NAME)  return property.getValue(Type.NAME); } else { return null; } } </pre>
 * @param name property name
 * @return name value of the named property, or {@code null}
 */
@CheckForNull String getName(@Nonnull String name);",0.9860664523043944
8765,"/** 
 * Returns the name values of the named property. The implementation is equivalent to the following code, but may be optimized. <pre> PropertyState property = builder.getProperty(name); if (property != null && property.getType() == Type.NAMES) { return property.getValue(Type.NAMES); } else { return Collections.emptyList(); } </pre>
 * @param name property name
 * @return name values of the named property, or an empty collection
 */
@Nonnull Iterable<String> getNames(@Nonnull String name);","/** 
 * Returns the name values of the named property. The implementation is equivalent to the following code, but may be optimized. <pre>  {@code PropertyState property = builder.getProperty(name);}if (property != null && property.getType() == Type.NAMES)  return property.getValue(Type.NAMES); } else { return Collections.emptyList(); } } </pre>
 * @param name property name
 * @return name values of the named property, or an empty collection
 */
@Nonnull Iterable<String> getNames(@Nonnull String name);",0.9870646766169154
8766,"/** 
 * Returns the boolean value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre> PropertyState property = builder.getProperty(name); return property != null && property.getType() == Type.BOOLEAN && property.getValue(Type.BOOLEAN); </pre>
 * @param name property name
 * @return boolean value of the named property, or {@code false}
 */
boolean getBoolean(@Nonnull String name);","/** 
 * Returns the boolean value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre>  {@code PropertyState property = builder.getProperty(name); return property != null && property.getType() == Type.BOOLEAN && property.getValue(Type.BOOLEAN);}</pre>
 * @param name property name
 * @return boolean value of the named property, or {@code false}
 */
boolean getBoolean(@Nonnull String name);",0.9886621315192744
8767,"/** 
 * Returns the name value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre> PropertyState property = builder.getProperty(name); if (property != null && property.getType() == Type.STRING) { return property.getValue(Type.STRING); } else { return null; } </pre>
 * @param name property name
 * @return string value of the named property, or {@code null}
 */
@CheckForNull String getString(String name);","/** 
 * Returns the name value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre>  {@code PropertyState property = builder.getProperty(name);}if (property != null && property.getType() == Type.STRING)  return property.getValue(Type.STRING); } else { return null; } } </pre>
 * @param name property name
 * @return string value of the named property, or {@code null}
 */
@CheckForNull String getString(String name);",0.9860365198711064
8768,"/** 
 * Returns the name value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre> PropertyState property = state.getProperty(name); if (property != null && property.getType() == Type.NAME) { return property.getValue(Type.NAME); } else { return null; } </pre>
 * @param name property name
 * @return name value of the named property, or {@code null}
 */
@CheckForNull String getName(@Nonnull String name);","/** 
 * Returns the name value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre>  {@code PropertyState property = state.getProperty(name);}if (property != null && property.getType() == Type.NAME)  return property.getValue(Type.NAME); } else { return null; } } </pre>
 * @param name property name
 * @return name value of the named property, or {@code null}
 */
@CheckForNull String getName(@Nonnull String name);",0.9860064585575888
8769,"/** 
 * Returns the string value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre> PropertyState property = state.getProperty(name); if (property != null && property.getType() == Type.STRING) { return property.getValue(Type.STRING); } else { return null; } </pre>
 * @param name property name
 * @return string value of the named property, or {@code null}
 */
@CheckForNull String getString(String name);","/** 
 * Returns the string value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre>  {@code PropertyState property = state.getProperty(name);}if (property != null && property.getType() == Type.STRING)  return property.getValue(Type.STRING); } else { return null; } } </pre>
 * @param name property name
 * @return string value of the named property, or {@code null}
 */
@CheckForNull String getString(String name);",0.9860365198711064
8770,"/** 
 * Returns the name values of the named property. The implementation is equivalent to the following code, but may be optimized. <pre> PropertyState property = state.getProperty(name); if (property != null && property.getType() == Type.NAMES) { return property.getValue(Type.NAMES); } else { return Collections.emptyList(); } </pre>
 * @param name property name
 * @return name values of the named property, or an empty collection
 */
@Nonnull Iterable<String> getNames(@Nonnull String name);","/** 
 * Returns the name values of the named property. The implementation is equivalent to the following code, but may be optimized. <pre>  {@code PropertyState property = state.getProperty(name);}if (property != null && property.getType() == Type.NAMES)  return property.getValue(Type.NAMES); } else { return Collections.emptyList(); } } </pre>
 * @param name property name
 * @return name values of the named property, or an empty collection
 */
@Nonnull Iterable<String> getNames(@Nonnull String name);",0.987012987012987
8771,"/** 
 * Returns the string values of the named property. The implementation is equivalent to the following code, but may be optimized. <pre> PropertyState property = state.getProperty(name); if (property != null && property.getType() == Type.STRINGS) { return property.getValue(Type.STRINGS); } else { return Collections.emptyList(); } </pre>
 * @param name property name
 * @return string values of the named property, or an empty collection
 */
@Nonnull Iterable<String> getStrings(@Nonnull String name);","/** 
 * Returns the string values of the named property. The implementation is equivalent to the following code, but may be optimized. <pre>  {@code PropertyState property = state.getProperty(name);}if (property != null && property.getType() == Type.STRINGS)  return property.getValue(Type.STRINGS); } else { return Collections.emptyList(); } } </pre>
 * @param name property name
 * @return string values of the named property, or an empty collection
 */
@Nonnull Iterable<String> getStrings(@Nonnull String name);",0.9872673849167484
8772,"/** 
 * Returns the long value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre> PropertyState property = state.getProperty(name); if (property != null && property.getType() == Type.LONG) { return property.getValue(Type.LONG); } else { return 0; } </pre>
 * @param name property name
 * @return long value of the named property, or zero
 */
long getLong(String name);","/** 
 * Returns the long value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre>  {@code PropertyState property = state.getProperty(name);}if (property != null && property.getType() == Type.LONG)  return property.getValue(Type.LONG); } else { return 0; } } </pre>
 * @param name property name
 * @return long value of the named property, or zero
 */
long getLong(String name);",0.9848308051341892
8773,"/** 
 * Returns the boolean value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre> PropertyState property = state.getProperty(name); return property != null && property.getType() == Type.BOOLEAN && property.getValue(Type.BOOLEAN); </pre>
 * @param name property name
 * @return boolean value of the named property, or {@code false}
 */
boolean getBoolean(@Nonnull String name);","/** 
 * Returns the boolean value of the named property. The implementation is equivalent to the following code, but may be optimized. <pre>  {@code PropertyState property = state.getProperty(name); return property != null && property.getType() == Type.BOOLEAN && property.getValue(Type.BOOLEAN);}</pre>
 * @param name property name
 * @return boolean value of the named property, or {@code false}
 */
boolean getBoolean(@Nonnull String name);",0.9886104783599088
8774,"/** 
 * Store the given id mapping for later lookup using  {@code }{@link #get(String)}</code>.
 * @param oldUUID old node id
 * @param newUUID new node id
 */
public void put(String oldUUID,String newUUID){
  uuidMap.put(oldUUID,newUUID);
}","/** 
 * Store the given id mapping for later lookup using  {@link #get(String)}.
 * @param oldUUID old node id
 * @param newUUID new node id
 */
public void put(String oldUUID,String newUUID){
  uuidMap.put(oldUUID,newUUID);
}",0.9678800856531048
8775,"/** 
 * Store the given reference property for later retrieval using  {@code }{@link #getProcessedReferences()}</code>.
 * @param refProp reference property
 */
public void processedReference(Object refProp){
  references.add(refProp);
}","/** 
 * Store the given reference property for later retrieval using  {@link #getProcessedReferences()}.
 * @param refProp reference property
 */
public void processedReference(Object refProp){
  references.add(refProp);
}",0.9673202614379084
8776,"private ArrayList<ColumnOrWildcard> parseColumns() throws ParseException {
  ArrayList<ColumnOrWildcard> list=new ArrayList<ColumnOrWildcard>();
  if (readIf(""String_Node_Str"")) {
    list.add(new ColumnOrWildcard());
  }
 else {
    do {
      ColumnOrWildcard column=new ColumnOrWildcard();
      if (readIf(""String_Node_Str"")) {
        column.propertyName=null;
      }
 else       if (readIf(""String_Node_Str"")) {
        column.propertyName=QueryImpl.REP_EXCERPT;
        read(""String_Node_Str"");
        if (!readIf(""String_Node_Str"")) {
          if (!readIf(""String_Node_Str"")) {
            column.selectorName=readName();
          }
          read(""String_Node_Str"");
        }
        readOptionalAlias(column);
      }
 else {
        column.propertyName=readName();
        if (column.propertyName.equals(QueryImpl.REP_SPELLCHECK)) {
          if (readIf(""String_Node_Str"")) {
            read(""String_Node_Str"");
            column.propertyName=""String_Node_Str"";
          }
          readOptionalAlias(column);
        }
 else         if (readIf(""String_Node_Str"")) {
          column.selectorName=column.propertyName;
          if (readIf(""String_Node_Str"")) {
            column.propertyName=null;
          }
 else {
            column.propertyName=readName();
            if (!readOptionalAlias(column)) {
              column.columnName=column.selectorName + ""String_Node_Str"" + column.propertyName;
            }
          }
        }
 else {
          readOptionalAlias(column);
        }
      }
      list.add(column);
    }
 while (readIf(""String_Node_Str""));
  }
  return list;
}","private ArrayList<ColumnOrWildcard> parseColumns() throws ParseException {
  ArrayList<ColumnOrWildcard> list=new ArrayList<ColumnOrWildcard>();
  if (readIf(""String_Node_Str"")) {
    list.add(new ColumnOrWildcard());
  }
 else {
    do {
      ColumnOrWildcard column=new ColumnOrWildcard();
      if (readIf(""String_Node_Str"")) {
        column.propertyName=null;
      }
 else       if (readIf(""String_Node_Str"")) {
        column.propertyName=""String_Node_Str"";
        read(""String_Node_Str"");
        if (!readIf(""String_Node_Str"")) {
          if (!readIf(""String_Node_Str"")) {
            column.selectorName=readName();
          }
          read(""String_Node_Str"");
        }
        readOptionalAlias(column);
      }
 else {
        column.propertyName=readName();
        if (column.propertyName.equals(""String_Node_Str"")) {
          if (readIf(""String_Node_Str"")) {
            read(""String_Node_Str"");
            column.propertyName=""String_Node_Str"";
          }
          readOptionalAlias(column);
        }
 else         if (readIf(""String_Node_Str"")) {
          column.selectorName=column.propertyName;
          if (readIf(""String_Node_Str"")) {
            column.propertyName=null;
          }
 else {
            column.propertyName=readName();
            if (!readOptionalAlias(column)) {
              column.columnName=column.selectorName + ""String_Node_Str"" + column.propertyName;
            }
          }
        }
 else {
          readOptionalAlias(column);
        }
      }
      list.add(column);
    }
 while (readIf(""String_Node_Str""));
  }
  return list;
}",0.7681747269890795
8777,"public static CompiledPermissions getInstance(){
  return INSTANCE;
}","static CompiledPermissions getInstance(){
  return INSTANCE;
}",0.9465648854961832
8778,"public boolean isReadableTree(@Nonnull Tree tree,boolean exactMatch){
  String targetPath=tree.getPath();
  for (  String path : readPaths) {
    if (targetPath.equals(path)) {
      return true;
    }
  }
  if (!exactMatch) {
    for (    String path : altReadPaths) {
      if (targetPath.startsWith(path)) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean isReadableTree(@Nonnull Tree tree,boolean exactMatch){
  String targetPath=tree.getPath();
  for (  String path : readPaths) {
    if (targetPath.equals(path)) {
      return true;
    }
  }
  if (!exactMatch) {
    for (    String path : altReadPaths) {
      if (targetPath.startsWith(path)) {
        return true;
      }
    }
  }
  return false;
}",0.9865591397849462
8779,"@Override public boolean canRead(@Nonnull PropertyState property){
  boolean isAcTree=isAcTree();
  if (!isAcTree && readableTree) {
    return true;
  }
  if (readStatus != null && readStatus.allowsProperties()) {
    return true;
  }
  long permission=(isAcTree) ? Permissions.READ_ACCESS_CONTROL : Permissions.READ_PROPERTY;
  Iterator<PermissionEntry> it=getIterator(property,permission);
  while (it.hasNext()) {
    PermissionEntry entry=it.next();
    if (entry.privilegeBits.includes(READ_BITS.get(permission))) {
      return (entry.isAllow);
    }
  }
  return false;
}","@Override public boolean canRead(@Nonnull PropertyState property){
  boolean isAcTree=isAcTree();
  if (!isAcTree && isReadableTree) {
    return true;
  }
  if (readStatus != null && readStatus.allowsProperties()) {
    return true;
  }
  long permission=(isAcTree) ? Permissions.READ_ACCESS_CONTROL : Permissions.READ_PROPERTY;
  Iterator<PermissionEntry> it=getIterator(property,permission);
  while (it.hasNext()) {
    PermissionEntry entry=it.next();
    if (entry.privilegeBits.includes(READ_BITS.get(permission))) {
      return (entry.isAllow);
    }
  }
  return false;
}",0.996551724137931
8780,"public boolean isReadablePath(@Nullable String treePath,boolean exactMatch){
  if (treePath != null) {
    for (    String path : readPaths) {
      if (treePath.equals(path)) {
        return true;
      }
    }
    if (!exactMatch) {
      for (      String path : altReadPaths) {
        if (treePath.startsWith(path)) {
          return true;
        }
      }
    }
  }
  return false;
}","@Override public boolean isReadablePath(@Nullable String treePath,boolean exactMatch){
  if (treePath != null) {
    for (    String path : readPaths) {
      if (treePath.equals(path)) {
        return true;
      }
    }
    if (!exactMatch) {
      for (      String path : altReadPaths) {
        if (treePath.startsWith(path)) {
          return true;
        }
      }
    }
  }
  return false;
}",0.9874055415617128
8781,"private TreePermissionImpl(Tree tree,TreeType type,TreePermission parentPermission){
  this.tree=tree;
  this.type=type;
  if (parentPermission instanceof TreePermissionImpl) {
    parent=(TreePermissionImpl)parentPermission;
  }
 else {
    parent=null;
  }
  readableTree=readPolicy.isReadableTree(tree,parent);
}","private TreePermissionImpl(Tree tree,TreeType type,TreePermission parentPermission){
  this.tree=tree;
  this.type=type;
  if (parentPermission instanceof TreePermissionImpl) {
    parent=(TreePermissionImpl)parentPermission;
  }
 else {
    parent=null;
  }
  isReadableTree=readPolicy.isReadableTree(tree,parent);
}",0.9936708860759492
8782,"/** 
 * Retruns true if all privileges identified by the given   {@code privilegeNames}are granted at the given   {@code tree}.
 * @param tree The target tree.
 * @param privilegeNames The privilege names to be tested.
 * @return {@code true} if the tree has privileges
 */
boolean hasPrivileges(@Nullable Tree tree,@Nonnull String... privilegeNames);","/** 
 * Returns   {@code true} if all privileges identified by the given {@code privilegeNames}are granted at the given   {@code tree}.
 * @param tree The target tree.
 * @param privilegeNames The privilege names to be tested.
 * @return {@code true} if the tree has privileges
 */
boolean hasPrivileges(@Nullable Tree tree,@Nonnull String... privilegeNames);",0.9577464788732394
8783,"@CheckForNull public String getPath(){
  return path;
}","@CheckForNull String getPath(){
  return path;
}",0.9320388349514565
8784,"@Override public Validator childNodeDeleted(String name,NodeState before) throws CommitFailedException {
  if (moveCtx.processDelete((ImmutableTree)getParentBefore().getChild(name),this)) {
    return null;
  }
 else {
    return super.childNodeDeleted(name,before);
  }
}","@Override public Validator childNodeDeleted(String name,NodeState before) throws CommitFailedException {
  if (moveCtx.processDelete(getParentBefore(),name,this)) {
    return null;
  }
 else {
    return super.childNodeDeleted(name,before);
  }
}",0.5433526011560693
8785,"private boolean processDelete(ImmutableTree child,MoveAwarePermissionValidator validator) throws CommitFailedException {
  String destPath=moveTracker.getDestPath(child.getPath());
  if (destPath != null) {
    ImmutableTree dest=(ImmutableTree)rootAfter.getTree(destPath);
    if (dest.exists()) {
      validator.checkPermissions(child,true,Permissions.REMOVE_NODE);
      checkPermissions(dest,Permissions.ADD_NODE | Permissions.NODE_TYPE_MANAGEMENT);
      return diff(child,dest,validator);
    }
  }
  return false;
}","private boolean processDelete(@CheckForNull Tree parent,@Nonnull String name,@Nonnull MoveAwarePermissionValidator validator) throws CommitFailedException {
  if (parent == null) {
    return false;
  }
  ImmutableTree child=(ImmutableTree)parent.getChild(name);
  String destPath=moveTracker.getDestPath(child.getPath());
  if (destPath != null) {
    ImmutableTree dest=(ImmutableTree)rootAfter.getTree(destPath);
    if (dest.exists()) {
      validator.checkPermissions(child,true,Permissions.REMOVE_NODE);
      checkPermissions(dest,Permissions.ADD_NODE | Permissions.NODE_TYPE_MANAGEMENT);
      return diff(child,dest,validator);
    }
  }
  return false;
}",0.8484848484848485
8786,"private boolean diff(ImmutableTree source,ImmutableTree dest,MoveAwarePermissionValidator validator) throws CommitFailedException {
  Validator nextValidator=validator.visibleValidator(source,dest);
  CommitFailedException e=EditorDiff.process(nextValidator,source.getNodeState(),dest.getNodeState());
  if (e != null) {
    throw e;
  }
  return true;
}","private boolean diff(@Nonnull ImmutableTree source,@Nonnull ImmutableTree dest,@Nonnull MoveAwarePermissionValidator validator) throws CommitFailedException {
  Validator nextValidator=validator.visibleValidator(source,dest);
  CommitFailedException e=EditorDiff.process(nextValidator,source.getNodeState(),dest.getNodeState());
  if (e != null) {
    throw e;
  }
  return true;
}",0.963265306122449
8787,"private boolean containsMove(Tree parentBefore,Tree parentAfter){
  return moveTracker.containsMove(PermissionUtil.getPath(parentBefore,parentAfter));
}","private boolean containsMove(@Nullable Tree parentBefore,@Nullable Tree parentAfter){
  return moveTracker.containsMove(PermissionUtil.getPath(parentBefore,parentAfter));
}",0.9382716049382716
8788,"private boolean processAdd(ImmutableTree child,MoveAwarePermissionValidator validator) throws CommitFailedException {
  String sourcePath=moveTracker.getSourcePath(child.getPath());
  if (sourcePath != null) {
    ImmutableTree source=(ImmutableTree)rootBefore.getTree(sourcePath);
    if (source.exists()) {
      validator.checkPermissions(child,false,Permissions.ADD_NODE | Permissions.NODE_TYPE_MANAGEMENT);
      checkPermissions(source,Permissions.REMOVE_NODE);
      return diff(source,child,validator);
    }
  }
  return false;
}","private boolean processAdd(@CheckForNull Tree parent,@Nonnull String name,@Nonnull MoveAwarePermissionValidator validator) throws CommitFailedException {
  if (parent == null) {
    return false;
  }
  ImmutableTree child=(ImmutableTree)parent.getChild(name);
  String sourcePath=moveTracker.getSourcePath(child.getPath());
  if (sourcePath != null) {
    ImmutableTree source=(ImmutableTree)rootBefore.getTree(sourcePath);
    if (source.exists()) {
      validator.checkPermissions(child,false,Permissions.ADD_NODE | Permissions.NODE_TYPE_MANAGEMENT);
      checkPermissions(source,Permissions.REMOVE_NODE);
      return diff(source,child,validator);
    }
  }
  return false;
}",0.8522167487684729
8789,"@Override public Validator childNodeAdded(String name,NodeState after) throws CommitFailedException {
  if (moveCtx.processAdd((ImmutableTree)getParentAfter().getChild(name),this)) {
    return null;
  }
 else {
    return super.childNodeAdded(name,after);
  }
}","@Override public Validator childNodeAdded(String name,NodeState after) throws CommitFailedException {
  if (moveCtx.processAdd(getParentAfter(),name,this)) {
    return null;
  }
 else {
    return super.childNodeAdded(name,after);
  }
}",0.6052104208416834
8790,"public static CompiledPermissions getInstance(){
  return INSTANCE;
}","static CompiledPermissions getInstance(){
  return INSTANCE;
}",0.9465648854961832
8791,"public boolean matchesParent(@Nonnull String parentPath){
  return Text.isDescendantOrEqual(path,parentPath) && (restriction == RestrictionPattern.EMPTY || restriction.matches(parentPath));
}","boolean matchesParent(@Nonnull String parentPath){
  return Text.isDescendantOrEqual(path,parentPath) && (restriction == RestrictionPattern.EMPTY || restriction.matches(parentPath));
}",0.9813333333333332
8792,"public boolean matches(){
  return restriction == RestrictionPattern.EMPTY || restriction.matches();
}","boolean matches(){
  return restriction == RestrictionPattern.EMPTY || restriction.matches();
}",0.964467005076142
8793,@Nonnull Collection<PermissionEntry> getEntries(@Nonnull String accessControlledPath);,@Nonnull Collection<PermissionEntry> getEntries(@Nonnull Tree accessControlledTree);,0.9058823529411764
8794,"@Nonnull public Iterator<PermissionEntry> getEntryIterator(@Nonnull EntryPredicate predicate){
  if (existingNames.isEmpty()) {
    return Iterators.emptyIterator();
  }
 else {
    return new EntryIterator(predicate);
  }
}","@Override @Nonnull public Iterator<PermissionEntry> getEntryIterator(@Nonnull EntryPredicate predicate){
  if (existingNames.isEmpty()) {
    return Iterators.emptyIterator();
  }
 else {
    return new EntryIterator(predicate);
  }
}",0.9781659388646288
8795,"public void flush(){
  cache.flush(principalNames);
  init();
}","@Override public void flush(){
  cache.flush(principalNames);
  init();
}",0.9264705882352942
8796,"@Nonnull public Collection<PermissionEntry> getEntries(@Nonnull String path){
  if (existingNames.isEmpty()) {
    return Collections.emptyList();
  }
 else   if (pathEntryMap != null) {
    Collection<PermissionEntry> entries=pathEntryMap.get(path);
    return (entries != null) ? entries : Collections.<PermissionEntry>emptyList();
  }
 else {
    return loadEntries(path);
  }
}","@Nonnull private Collection<PermissionEntry> getEntries(@Nonnull String path){
  if (existingNames.isEmpty()) {
    return Collections.emptyList();
  }
 else   if (pathEntryMap != null) {
    Collection<PermissionEntry> entries=pathEntryMap.get(path);
    return (entries != null) ? entries : Collections.<PermissionEntry>emptyList();
  }
 else {
    return loadEntries(path);
  }
}",0.9855832241153342
8797,"PermissionStoreEditor(@Nonnull String aclPath,@Nonnull String name,@Nonnull NodeState node,@Nonnull NodeBuilder permissionRoot,@Nonnull TypePredicate isACE,@Nonnull TypePredicate isGrantACE,@Nonnull PrivilegeBitsProvider bitsProvider,@Nonnull RestrictionProvider restrictionProvider){
  this.permissionRoot=permissionRoot;
  if (name.equals(REP_REPO_POLICY)) {
    accessControlledPath=""String_Node_Str"";
  }
 else {
    accessControlledPath=aclPath.length() == 0 ? ""String_Node_Str"" : aclPath;
  }
  nodeName=PermissionUtil.getEntryName(accessControlledPath);
  Set<String> orderedChildNames=newLinkedHashSet(node.getNames(OAK_CHILD_ORDER));
  long n=orderedChildNames.size();
  if (node.getChildNodeCount(n + 1) > n) {
    addAll(orderedChildNames,node.getChildNodeNames());
  }
  PrivilegeBits jcrAll=bitsProvider.getBits(PrivilegeConstants.JCR_ALL);
  int index=0;
  for (  String childName : orderedChildNames) {
    NodeState ace=node.getChildNode(childName);
    if (isACE.apply(ace)) {
      boolean isAllow=isGrantACE.apply(ace);
      PrivilegeBits privilegeBits=bitsProvider.getBits(ace.getNames(REP_PRIVILEGES));
      Set<Restriction> restrictions=restrictionProvider.readRestrictions(Strings.emptyToNull(accessControlledPath),TreeFactory.createReadOnlyTree(ace));
      AcEntry entry=(privilegeBits.equals(jcrAll)) ? new JcrAllAcEntry(ace,accessControlledPath,index,isAllow,privilegeBits,restrictions) : new AcEntry(ace,accessControlledPath,index,isAllow,privilegeBits,restrictions);
      List<AcEntry> list=entries.get(entry.principalName);
      if (list == null) {
        list=new ArrayList<AcEntry>();
        entries.put(entry.principalName,list);
      }
      list.add(entry);
      index++;
    }
  }
}","PermissionStoreEditor(@Nonnull String aclPath,@Nonnull String name,@Nonnull NodeState node,@Nonnull NodeBuilder permissionRoot,@Nonnull TypePredicate isACE,@Nonnull TypePredicate isGrantACE,@Nonnull PrivilegeBitsProvider bitsProvider,@Nonnull RestrictionProvider restrictionProvider){
  this.permissionRoot=permissionRoot;
  if (name.equals(REP_REPO_POLICY)) {
    accessControlledPath=""String_Node_Str"";
  }
 else {
    accessControlledPath=aclPath.isEmpty() ? ""String_Node_Str"" : aclPath;
  }
  nodeName=PermissionUtil.getEntryName(accessControlledPath);
  Set<String> orderedChildNames=newLinkedHashSet(node.getNames(OAK_CHILD_ORDER));
  long n=orderedChildNames.size();
  if (node.getChildNodeCount(n + 1) > n) {
    addAll(orderedChildNames,node.getChildNodeNames());
  }
  PrivilegeBits jcrAll=bitsProvider.getBits(PrivilegeConstants.JCR_ALL);
  int index=0;
  for (  String childName : orderedChildNames) {
    NodeState ace=node.getChildNode(childName);
    if (isACE.apply(ace)) {
      boolean isAllow=isGrantACE.apply(ace);
      PrivilegeBits privilegeBits=bitsProvider.getBits(ace.getNames(REP_PRIVILEGES));
      Set<Restriction> restrictions=restrictionProvider.readRestrictions(Strings.emptyToNull(accessControlledPath),TreeFactory.createReadOnlyTree(ace));
      AcEntry entry=(privilegeBits.equals(jcrAll)) ? new JcrAllAcEntry(ace,accessControlledPath,index,isAllow,privilegeBits,restrictions) : new AcEntry(ace,accessControlledPath,index,isAllow,privilegeBits,restrictions);
      List<AcEntry> list=entries.get(entry.principalName);
      if (list == null) {
        list=new ArrayList<AcEntry>();
        entries.put(entry.principalName,list);
      }
      list.add(entry);
      index++;
    }
  }
}",0.9936194895591648
8798,"void updatePermissionEntries(){
  for (  String principalName : entries.keySet()) {
    NodeBuilder principalRoot=permissionRoot.child(principalName);
    if (!principalRoot.hasProperty(JCR_PRIMARYTYPE)) {
      principalRoot.setProperty(JCR_PRIMARYTYPE,NT_REP_PERMISSION_STORE,Type.NAME);
    }
    NodeBuilder parent=principalRoot.child(nodeName);
    if (!parent.hasProperty(JCR_PRIMARYTYPE)) {
      parent.setProperty(JCR_PRIMARYTYPE,NT_REP_PERMISSION_STORE,Type.NAME);
    }
    if (parent.hasProperty(REP_ACCESS_CONTROLLED_PATH)) {
      if (!PermissionUtil.checkACLPath(parent,accessControlledPath)) {
        NodeBuilder child=null;
        int idx=0;
        for (        String childName : parent.getChildNodeNames()) {
          if (childName.charAt(0) != 'c') {
            continue;
          }
          child=parent.getChildNode(childName);
          if (PermissionUtil.checkACLPath(child,accessControlledPath)) {
            break;
          }
          child=null;
          idx++;
        }
        while (child == null) {
          String name='c' + String.valueOf(idx++);
          child=parent.getChildNode(name);
          if (child.exists()) {
            child=null;
          }
 else {
            child=parent.child(name);
            child.setProperty(JCR_PRIMARYTYPE,NT_REP_PERMISSION_STORE,Type.NAME);
          }
        }
        parent=child;
        parent.setProperty(REP_ACCESS_CONTROLLED_PATH,accessControlledPath);
      }
    }
 else {
      parent.setProperty(REP_ACCESS_CONTROLLED_PATH,accessControlledPath);
    }
    updateEntries(parent,entries.get(principalName));
  }
}","void updatePermissionEntries(){
  for (  Map.Entry<String,List<AcEntry>> entry : entries.entrySet()) {
    String principalName=entry.getKey();
    NodeBuilder principalRoot=permissionRoot.child(principalName);
    if (!principalRoot.hasProperty(JCR_PRIMARYTYPE)) {
      principalRoot.setProperty(JCR_PRIMARYTYPE,NT_REP_PERMISSION_STORE,Type.NAME);
    }
    NodeBuilder parent=principalRoot.child(nodeName);
    if (!parent.hasProperty(JCR_PRIMARYTYPE)) {
      parent.setProperty(JCR_PRIMARYTYPE,NT_REP_PERMISSION_STORE,Type.NAME);
    }
    if (parent.hasProperty(REP_ACCESS_CONTROLLED_PATH)) {
      if (!PermissionUtil.checkACLPath(parent,accessControlledPath)) {
        NodeBuilder child=null;
        int idx=0;
        for (        String childName : parent.getChildNodeNames()) {
          if (childName.charAt(0) != 'c') {
            continue;
          }
          child=parent.getChildNode(childName);
          if (PermissionUtil.checkACLPath(child,accessControlledPath)) {
            break;
          }
          child=null;
          idx++;
        }
        while (child == null) {
          String name='c' + String.valueOf(idx++);
          child=parent.getChildNode(name);
          if (child.exists()) {
            child=null;
          }
 else {
            child=parent.child(name);
            child.setProperty(JCR_PRIMARYTYPE,NT_REP_PERMISSION_STORE,Type.NAME);
          }
        }
        parent=child;
        parent.setProperty(REP_ACCESS_CONTROLLED_PATH,accessControlledPath);
      }
    }
 else {
      parent.setProperty(REP_ACCESS_CONTROLLED_PATH,accessControlledPath);
    }
    updateEntries(parent,entry.getValue());
  }
}",0.9609756097560976
8799,"@Override public boolean matches(TokenCredentials tokenCredentials){
  String tk=tokenCredentials.getToken();
  int pos=tk.lastIndexOf(DELIM);
  if (pos > -1) {
    tk=tk.substring(pos + 1);
  }
  if (key == null || !PasswordUtil.isSame(key,getKeyValue(tk,userId))) {
    return false;
  }
  for (  String name : mandatoryAttributes.keySet()) {
    String expectedValue=mandatoryAttributes.get(name);
    if (!expectedValue.equals(tokenCredentials.getAttribute(name))) {
      return false;
    }
  }
  Collection<String> attrNames=Arrays.asList(tokenCredentials.getAttributeNames());
  for (  String name : publicAttributes.keySet()) {
    if (!attrNames.contains(name)) {
      tokenCredentials.setAttribute(name,publicAttributes.get(name).toString());
    }
  }
  return true;
}","@Override public boolean matches(TokenCredentials tokenCredentials){
  String tk=tokenCredentials.getToken();
  int pos=tk.lastIndexOf(DELIM);
  if (pos > -1) {
    tk=tk.substring(pos + 1);
  }
  if (key == null || !PasswordUtil.isSame(key,getKeyValue(tk,userId))) {
    return false;
  }
  for (  Map.Entry<String,String> mandatory : mandatoryAttributes.entrySet()) {
    String name=mandatory.getKey();
    String expectedValue=mandatory.getValue();
    if (!expectedValue.equals(tokenCredentials.getAttribute(name))) {
      return false;
    }
  }
  Collection<String> attrNames=Arrays.asList(tokenCredentials.getAttributeNames());
  for (  Map.Entry<String,String> attr : publicAttributes.entrySet()) {
    String name=attr.getKey();
    if (!attrNames.contains(name)) {
      tokenCredentials.setAttribute(name,attr.getValue());
    }
  }
  return true;
}",0.8533171028606208
8800,"protected Repository createRepository(String url,String username,String password){
  String prefix=""String_Node_Str"" + UUID.randomUUID().toString().replace(""String_Node_Str"",""String_Node_Str"");
  RDBOptions options=new RDBOptions().tablePrefix(prefix).dropTablesOnClose(true);
  DocumentNodeStore m=new DocumentMK.Builder().setClusterId(1).memoryCacheSize(64 * 1024 * 1024).setPersistentCache(""String_Node_Str"").setRDBConnection(RDBDataSourceFactory.forJdbcUrl(url,username,password),options).getNodeStore();
  QueryEngineSettings qs=new QueryEngineSettings();
  qs.setFullTextComparisonWithoutIndex(true);
  return new Jcr(m).with(qs).createRepository();
}","protected Repository createRepository(String url,String username,String password){
  String prefix=""String_Node_Str"" + UUID.randomUUID().toString().replace(""String_Node_Str"",""String_Node_Str"");
  RDBOptions options=new RDBOptions().tablePrefix(prefix).dropTablesOnClose(true);
  DocumentNodeStore m=new DocumentMK.Builder().memoryCacheSize(64 * 1024 * 1024).setPersistentCache(""String_Node_Str"").setRDBConnection(RDBDataSourceFactory.forJdbcUrl(url,username,password),options).getNodeStore();
  QueryEngineSettings qs=new QueryEngineSettings();
  qs.setFullTextComparisonWithoutIndex(true);
  return new Jcr(m).with(qs).createRepository();
}",0.987673343605547
8801,"private static Repository createRepository(MongoConnection connection){
  DocumentNodeStore store=new DocumentMK.Builder().setClusterId(1).memoryCacheSize(64 * 1024 * 1024).setPersistentCache(""String_Node_Str"").setMongoDB(connection.getDB()).getNodeStore();
  QueryEngineSettings qs=new QueryEngineSettings();
  qs.setFullTextComparisonWithoutIndex(true);
  return new Jcr(store).with(qs).createRepository();
}","private static Repository createRepository(MongoConnection connection){
  DocumentNodeStore store=new DocumentMK.Builder().memoryCacheSize(64 * 1024 * 1024).setPersistentCache(""String_Node_Str"").setMongoDB(connection.getDB()).getNodeStore();
  QueryEngineSettings qs=new QueryEngineSettings();
  qs.setFullTextComparisonWithoutIndex(true);
  return new Jcr(store).with(qs).createRepository();
}",0.9800995024875622
8802,"private DocumentNodeStore createNodeStore(String workingDir) throws SecurityException, Exception {
  setFinalStatic(ClusterNodeInfo.class.getDeclaredField(""String_Node_Str""),workingDir);
  DocumentMK mk1=createMK(0,500);
  logger.info(""String_Node_Str"" + mk1.nodeStore.getClusterId() + ""String_Node_Str""+ workingDir);
  return mk1.nodeStore;
}","private DocumentNodeStore createNodeStore(String workingDir) throws SecurityException, Exception {
  Object prevWorkingDir=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  try {
    prevWorkingDir=setFinalStatic(ClusterNodeInfo.class.getDeclaredField(""String_Node_Str""),workingDir);
    DocumentMK mk1=createMK(0,500);
    logger.info(""String_Node_Str"" + mk1.nodeStore.getClusterId() + ""String_Node_Str""+ workingDir);
    return mk1.nodeStore;
  }
  finally {
    setFinalStatic(ClusterNodeInfo.class.getDeclaredField(""String_Node_Str""),prevWorkingDir);
  }
}",0.7521929824561403
8803,"/** 
 * Borrowed from http://stackoverflow.com/questions/3301635/change-private-static-final- field-using-java-reflection
 */
static void setFinalStatic(Field field,Object newValue) throws Exception {
  field.setAccessible(true);
  Field modifiersField=Field.class.getDeclaredField(""String_Node_Str"");
  modifiersField.setAccessible(true);
  modifiersField.setInt(field,field.getModifiers() & ~Modifier.FINAL);
  field.set(null,newValue);
}","/** 
 * Borrowed from http://stackoverflow.com/questions/3301635/change-private-static-final- field-using-java-reflection
 */
static Object setFinalStatic(Field field,Object newValue) throws Exception {
  field.setAccessible(true);
  Field modifiersField=Field.class.getDeclaredField(""String_Node_Str"");
  modifiersField.setAccessible(true);
  modifiersField.setInt(field,field.getModifiers() & ~Modifier.FINAL);
  Object prev=field.get(null);
  field.set(null,newValue);
  return prev;
}",0.9396551724137931
8804,"public void performLeaseCheck(){
  if (leaseCheckDisabled || !renewed) {
    return;
  }
  if (leaseCheckFailed) {
    LOG.error(LEASE_CHECK_FAILED_MSG);
    throw new AssertionError(LEASE_CHECK_FAILED_MSG);
  }
  long now=getCurrentTime();
  if (now < (leaseEndTime - leaseFailureMargin)) {
    return;
  }
synchronized (this) {
    if (leaseCheckFailed) {
      LOG.error(LEASE_CHECK_FAILED_MSG);
      throw new AssertionError(LEASE_CHECK_FAILED_MSG);
    }
    for (int i=0; i < MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE; i++) {
      now=getCurrentTime();
      if (now < (leaseEndTime - leaseFailureMargin)) {
        return;
      }
      try {
        LOG.info(""String_Node_Str"" + leaseFailureMargin + ""String_Node_Str""+ (leaseEndTime - now)+ ""String_Node_Str""+ ""String_Node_Str""+ (MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE - 1 - i)+ ""String_Node_Str"");
        Thread.sleep(1000);
      }
 catch (      InterruptedException e) {
        LOG.warn(""String_Node_Str"" + e,e);
        break;
      }
    }
    leaseCheckFailed=true;
  }
  final String errorMsg=LEASE_CHECK_FAILED_MSG + ""String_Node_Str"" + leaseEndTime+ ""String_Node_Str""+ leaseTime+ ""String_Node_Str""+ leaseFailureMargin+ ""String_Node_Str""+ (leaseEndTime - leaseFailureMargin)+ ""String_Node_Str""+ now+ ""String_Node_Str""+ ((leaseEndTime - leaseFailureMargin) - now)+ ""String_Node_Str"";
  LOG.error(errorMsg);
  handleLeaseFailure(errorMsg);
}","public void performLeaseCheck(){
  if (leaseCheckDisabled || !renewed) {
    return;
  }
  if (leaseCheckFailed) {
    LOG.error(LEASE_CHECK_FAILED_MSG);
    throw new AssertionError(LEASE_CHECK_FAILED_MSG);
  }
  long now=getCurrentTime();
  if (now < (leaseEndTime - leaseFailureMargin)) {
    return;
  }
synchronized (this) {
    if (leaseCheckFailed) {
      LOG.error(LEASE_CHECK_FAILED_MSG);
      throw new AssertionError(LEASE_CHECK_FAILED_MSG);
    }
    for (int i=0; i < MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE; i++) {
      now=getCurrentTime();
      if (now < (leaseEndTime - leaseFailureMargin)) {
        return;
      }
      try {
        LOG.info(""String_Node_Str"" + leaseFailureMargin + ""String_Node_Str""+ (leaseEndTime - now)+ ""String_Node_Str""+ ""String_Node_Str""+ (MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE - 1 - i)+ ""String_Node_Str"");
        wait(1000);
      }
 catch (      InterruptedException e) {
        LOG.warn(""String_Node_Str"" + e,e);
        break;
      }
    }
    leaseCheckFailed=true;
  }
  final String errorMsg=LEASE_CHECK_FAILED_MSG + ""String_Node_Str"" + leaseEndTime+ ""String_Node_Str""+ leaseTime+ ""String_Node_Str""+ leaseFailureMargin+ ""String_Node_Str""+ (leaseEndTime - leaseFailureMargin)+ ""String_Node_Str""+ now+ ""String_Node_Str""+ ((leaseEndTime - leaseFailureMargin) - now)+ ""String_Node_Str"";
  LOG.error(errorMsg);
  handleLeaseFailure(errorMsg);
}",0.9942857142857144
8805,"@SuppressWarnings(""String_Node_Str"") ClusterViewDocument(Document doc){
  if (doc == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.clusterViewId=(String)doc.get(CLUSTER_VIEW_ID_KEY);
  this.viewSeqNum=(Long)doc.get(VIEW_SEQ_NUM_KEY);
  this.createdAt=(String)doc.get(CREATED_KEY);
  this.createdBy=(Long)doc.get(CREATOR_KEY);
  Object obj=doc.get(ACTIVE_KEY);
  if (obj == null || !(obj instanceof String)) {
    logger.trace(""String_Node_Str"",ACTIVE_KEY,obj);
    this.activeIds=new Integer[0];
  }
 else {
    this.activeIds=csvToIntegerArray((String)obj);
  }
  Object obj2=doc.get(RECOVERING_KEY);
  if (obj2 == null || !(obj2 instanceof String)) {
    logger.trace(""String_Node_Str"",RECOVERING_KEY,obj2);
    this.recoveringIds=new Integer[0];
  }
 else {
    this.recoveringIds=csvToIntegerArray((String)obj2);
  }
  Object obj3=doc.get(INACTIVE_KEY);
  if (obj3 == null || !(obj3 instanceof String)) {
    logger.trace(""String_Node_Str"",INACTIVE_KEY,obj3);
    this.inactiveIds=new Integer[0];
  }
 else {
    this.inactiveIds=csvToIntegerArray((String)obj3);
  }
  Object obj4=doc.get(CLUSTER_VIEW_HISTORY_KEY);
  if (obj4 == null || !(obj4 instanceof Map)) {
    logger.trace(""String_Node_Str"");
    this.viewHistory=null;
  }
 else {
    this.viewHistory=((Map<Object,String>)obj4);
  }
}","@SuppressWarnings(""String_Node_Str"") ClusterViewDocument(Document doc){
  if (doc == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.clusterViewId=(String)doc.get(CLUSTER_VIEW_ID_KEY);
  this.viewSeqNum=(Long)doc.get(VIEW_SEQ_NUM_KEY);
  this.createdAt=(String)doc.get(CREATED_KEY);
  Object creatorId=doc.get(CREATOR_KEY);
  if (creatorId instanceof Long) {
    this.createdBy=(Long)creatorId;
  }
 else   if (creatorId instanceof Integer) {
    this.createdBy=(long)((Integer)creatorId);
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + creatorId);
  }
  Object obj=doc.get(ACTIVE_KEY);
  if (obj == null || !(obj instanceof String)) {
    logger.trace(""String_Node_Str"",ACTIVE_KEY,obj);
    this.activeIds=new Integer[0];
  }
 else {
    this.activeIds=csvToIntegerArray((String)obj);
  }
  Object obj2=doc.get(RECOVERING_KEY);
  if (obj2 == null || !(obj2 instanceof String)) {
    logger.trace(""String_Node_Str"",RECOVERING_KEY,obj2);
    this.recoveringIds=new Integer[0];
  }
 else {
    this.recoveringIds=csvToIntegerArray((String)obj2);
  }
  Object obj3=doc.get(INACTIVE_KEY);
  if (obj3 == null || !(obj3 instanceof String)) {
    logger.trace(""String_Node_Str"",INACTIVE_KEY,obj3);
    this.inactiveIds=new Integer[0];
  }
 else {
    this.inactiveIds=csvToIntegerArray((String)obj3);
  }
  Object obj4=doc.get(CLUSTER_VIEW_HISTORY_KEY);
  if (obj4 == null || !(obj4 instanceof Map)) {
    logger.trace(""String_Node_Str"");
    this.viewHistory=null;
  }
 else {
    this.viewHistory=((Map<Object,String>)obj4);
  }
}",0.900894700619408
8806,"/** 
 * Returns the parameter as an integer or the <code>defaultValue</code> if the parameter is <code>null</code> or if the parameter is not an <code>Integer</code> and cannot be converted to an <code>Integer</code> from the parameter's string value.
 * @param propValue the property value or <code>null</code>
 * @param defaultValue the default integer value
 */
public static int toInteger(Object propValue,int defaultValue){
  propValue=toObject(propValue);
  if (propValue instanceof Integer) {
    return (Integer)propValue;
  }
 else   if (propValue != null) {
    try {
      return Integer.parseInt(String.valueOf(propValue));
    }
 catch (    NumberFormatException nfe) {
    }
  }
  return defaultValue;
}","/** 
 * Returns the parameter as an integer or the  {@code defaultValue} if the parameter is {@code null} or ifthe parameter is not an  {@code Integer} and cannot be converted toan  {@code Integer} from the parameter's string value.
 * @param propValue the property value or {@code null}
 * @param defaultValue the default integer value
 */
public static int toInteger(Object propValue,int defaultValue){
  propValue=toObject(propValue);
  if (propValue instanceof Integer) {
    return (Integer)propValue;
  }
 else   if (propValue != null) {
    try {
      return Integer.parseInt(String.valueOf(propValue));
    }
 catch (    NumberFormatException nfe) {
    }
  }
  return defaultValue;
}",0.8170212765957446
8807,"/** 
 * Populates the bean properties from config instance. It supports coercing values for simple types like Number, Integer, Long, Boolean etc. Complex objects are not supported
 * @param instance bean to populate
 * @param config propertires to set in the passed bean
 * @param validate Flag to validate the configured bean property names againstthe configured bean class
 */
@SuppressWarnings(""String_Node_Str"") public static void populate(Object instance,Map<String,?> config,boolean validate){
  Class<?> objectClass=instance.getClass();
  Map<String,Method> setters=getSetters(objectClass);
  ToStringHelper toStringHelper=Objects.toStringHelper(instance);
  for (  Map.Entry<String,?> e : config.entrySet()) {
    String name=e.getKey();
    Method setter=setters.get(name);
    if (setter != null) {
      if (setter.getAnnotation(Deprecated.class) != null) {
        log.warn(""String_Node_Str"",name,objectClass.getName());
      }
      Object value=e.getValue();
      setProperty(instance,name,setter,value);
      toStringHelper.add(name,value);
    }
 else     if (validate) {
      throw new IllegalArgumentException(""String_Node_Str"" + objectClass.getName() + ""String_Node_Str""+ name);
    }
  }
  log.debug(""String_Node_Str"",toStringHelper);
}","/** 
 * Populates the bean properties from config instance. It supports coercing values for simple types like Number, Integer, Long, Boolean etc. Complex objects are not supported
 * @param instance bean to populate
 * @param config properties to set in the passed bean
 * @param validate Flag to validate the configured bean property names againstthe configured bean class
 */
@SuppressWarnings(""String_Node_Str"") public static void populate(Object instance,Map<String,?> config,boolean validate){
  Class<?> objectClass=instance.getClass();
  Map<String,Method> setters=getSetters(objectClass);
  ToStringHelper toStringHelper=Objects.toStringHelper(instance);
  for (  Map.Entry<String,?> e : config.entrySet()) {
    String name=e.getKey();
    Method setter=setters.get(name);
    if (setter != null) {
      if (setter.getAnnotation(Deprecated.class) != null) {
        log.warn(""String_Node_Str"",name,objectClass.getName());
      }
      Object value=e.getValue();
      setProperty(instance,name,setter,value);
      toStringHelper.add(name,value);
    }
 else     if (validate) {
      throw new IllegalArgumentException(""String_Node_Str"" + objectClass.getName() + ""String_Node_Str""+ name);
    }
  }
  log.debug(""String_Node_Str"",toStringHelper);
}",0.999603017070266
8808,"/** 
 * Returns the parameter as a double or the <code>defaultValue</code> if the parameter is <code>null</code> or if the parameter is not a <code>Double</code> and cannot be converted to a <code>Double</code> from the parameter's string value.
 * @param propValue the property value or <code>null</code>
 * @param defaultValue the default double value
 */
public static double toDouble(Object propValue,double defaultValue){
  propValue=toObject(propValue);
  if (propValue instanceof Double) {
    return (Double)propValue;
  }
 else   if (propValue != null) {
    try {
      return Double.parseDouble(String.valueOf(propValue));
    }
 catch (    NumberFormatException nfe) {
    }
  }
  return defaultValue;
}","/** 
 * Returns the parameter as a double or the  {@code defaultValue} if the parameter is {@code null} or ifthe parameter is not a  {@code Double} and cannot be converted toa  {@code Double} from the parameter's string value.
 * @param propValue the property value or {@code null}
 * @param defaultValue the default double value
 */
public static double toDouble(Object propValue,double defaultValue){
  propValue=toObject(propValue);
  if (propValue instanceof Double) {
    return (Double)propValue;
  }
 else   if (propValue != null) {
    try {
      return Double.parseDouble(String.valueOf(propValue));
    }
 catch (    NumberFormatException nfe) {
    }
  }
  return defaultValue;
}",0.8193456614509246
8809,"/** 
 * Returns the boolean value of the parameter or the <code>defaultValue</code> if the parameter is <code>null</code>. If the parameter is not a <code>Boolean</code> it is converted by calling <code>Boolean.valueOf</code> on the string value of the object.
 * @param propValue the property value or <code>null</code>
 * @param defaultValue the default boolean value
 */
public static boolean toBoolean(Object propValue,boolean defaultValue){
  propValue=toObject(propValue);
  if (propValue instanceof Boolean) {
    return (Boolean)propValue;
  }
 else   if (propValue != null) {
    return Boolean.parseBoolean(String.valueOf(propValue));
  }
  return defaultValue;
}","/** 
 * Returns the boolean value of the parameter or the  {@code defaultValue} if the parameter is {@code null}. If the parameter is not a   {@code Boolean} it is convertedby calling  {@code Boolean.valueOf} on the string value of theobject.
 * @param propValue the property value or {@code null}
 * @param defaultValue the default boolean value
 */
public static boolean toBoolean(Object propValue,boolean defaultValue){
  propValue=toObject(propValue);
  if (propValue instanceof Boolean) {
    return (Boolean)propValue;
  }
 else   if (propValue != null) {
    return Boolean.parseBoolean(String.valueOf(propValue));
  }
  return defaultValue;
}",0.8858654572940288
8810,"/** 
 * Returns the parameter as a long or the <code>defaultValue</code> if the parameter is <code>null</code> or if the parameter is not a <code>Long</code> and cannot be converted to a <code>Long</code> from the parameter's string value.
 * @param propValue the property value or <code>null</code>
 * @param defaultValue the default long value
 */
public static long toLong(Object propValue,long defaultValue){
  propValue=toObject(propValue);
  if (propValue instanceof Long) {
    return (Long)propValue;
  }
 else   if (propValue != null) {
    try {
      return Long.parseLong(String.valueOf(propValue));
    }
 catch (    NumberFormatException nfe) {
    }
  }
  return defaultValue;
}","/** 
 * Returns the parameter as a long or the  {@code defaultValue} if the parameter is {@code null} or ifthe parameter is not a  {@code Long} and cannot be converted toa  {@code Long} from the parameter's string value.
 * @param propValue the property value or {@code null}
 * @param defaultValue the default long value
 */
public static long toLong(Object propValue,long defaultValue){
  propValue=toObject(propValue);
  if (propValue instanceof Long) {
    return (Long)propValue;
  }
 else   if (propValue != null) {
    try {
      return Long.parseLong(String.valueOf(propValue));
    }
 catch (    NumberFormatException nfe) {
    }
  }
  return defaultValue;
}",0.8135095447870778
8811,"private static void setProperty(Object instance,String name,Method setter,Object value){
  String className=instance.getClass().getName();
  Class<?> type=setter.getParameterTypes()[0];
  try {
    if (type.isAssignableFrom(String.class) || type.isAssignableFrom(Object.class)) {
      setter.invoke(instance,value);
    }
 else     if (type.isAssignableFrom(Boolean.TYPE) || type.isAssignableFrom(Boolean.class)) {
      setter.invoke(instance,toBoolean(value,false));
    }
 else     if (type.isAssignableFrom(Integer.TYPE) || type.isAssignableFrom(Integer.class)) {
      setter.invoke(instance,toInteger(value,0));
    }
 else     if (type.isAssignableFrom(Long.TYPE) || type.isAssignableFrom(Long.class)) {
      setter.invoke(instance,toLong(value,0));
    }
 else     if (type.isAssignableFrom(Double.TYPE) || type.isAssignableFrom(Double.class)) {
      setter.invoke(instance,toDouble(value,0));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + type.getName() + ""String_Node_Str""+ name+ ""String_Node_Str""+ className+ ""String_Node_Str"");
    }
  }
 catch (  NumberFormatException e) {
    throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str""+ name+ ""String_Node_Str""+ className,e);
  }
catch (  InvocationTargetException e) {
    throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ className+ ""String_Node_Str""+ value+ ""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ className+ ""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ className,e);
  }
}","private static void setProperty(Object instance,String name,Method setter,Object value){
  String className=instance.getClass().getName();
  Class<?> type=setter.getParameterTypes()[0];
  try {
    if (type.isAssignableFrom(String.class) || type.isAssignableFrom(Object.class)) {
      setter.invoke(instance,value);
    }
 else     if (type.isAssignableFrom(Boolean.TYPE) || type.isAssignableFrom(Boolean.class)) {
      setter.invoke(instance,toBoolean(value,false));
    }
 else     if (type.isAssignableFrom(Integer.TYPE) || type.isAssignableFrom(Integer.class)) {
      setter.invoke(instance,toInteger(value,0));
    }
 else     if (type.isAssignableFrom(Long.TYPE) || type.isAssignableFrom(Long.class)) {
      setter.invoke(instance,toLong(value,0));
    }
 else     if (type.isAssignableFrom(Double.TYPE) || type.isAssignableFrom(Double.class)) {
      setter.invoke(instance,toDouble(value,0));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + type.getName() + ""String_Node_Str""+ name+ ""String_Node_Str""+ className+ ""String_Node_Str"");
    }
  }
 catch (  NumberFormatException e) {
    throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str""+ name+ ""String_Node_Str""+ className,e);
  }
catch (  InvocationTargetException e) {
    throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ className+ ""String_Node_Str""+ value+ '""',e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ className+ ""String_Node_Str"",e);
  }
catch (  IllegalArgumentException e) {
    throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ className,e);
  }
}",0.994086339444116
8812,"/** 
 * Returns the parameter as a string or the <code>defaultValue</code> if the parameter is <code>null</code>.
 * @param propValue the property value or <code>null</code>
 * @param defaultValue the default string value
 */
public static String toString(Object propValue,String defaultValue){
  propValue=toObject(propValue);
  return (propValue != null) ? propValue.toString() : defaultValue;
}","/** 
 * Returns the parameter as a string or the  {@code defaultValue} if the parameter is {@code null}.
 * @param propValue the property value or {@code null}
 * @param defaultValue the default string value
 */
public static String toString(Object propValue,String defaultValue){
  propValue=toObject(propValue);
  return (propValue != null) ? propValue.toString() : defaultValue;
}",0.8666666666666667
8813,"/** 
 * Returns the parameter as a single value. If the parameter is neither an array nor a <code>java.util.Collection</code> the parameter is returned unmodified. If the parameter is a non-empty array, the first array element is returned. If the property is a non-empty <code>java.util.Collection</code>, the first collection element is returned. Otherwise <code>null</code> is returned.
 * @param propValue the parameter to convert.
 */
public static Object toObject(Object propValue){
  if (propValue == null) {
    return null;
  }
 else   if (propValue.getClass().isArray()) {
    Object[] prop=(Object[])propValue;
    return prop.length > 0 ? prop[0] : null;
  }
 else   if (propValue instanceof Collection<?>) {
    Collection<?> prop=(Collection<?>)propValue;
    return prop.isEmpty() ? null : prop.iterator().next();
  }
 else {
    return propValue;
  }
}","/** 
 * Returns the parameter as a single value. If the parameter is neither an array nor a   {@code java.util.Collection} theparameter is returned unmodified. If the parameter is a non-empty array, the first array element is returned. If the property is a non-empty {@code java.util.Collection}, the first collection element is returned. Otherwise   {@code null} is returned.
 * @param propValue the parameter to convert.
 */
public static Object toObject(Object propValue){
  if (propValue == null) {
    return null;
  }
 else   if (propValue.getClass().isArray()) {
    Object[] prop=(Object[])propValue;
    return prop.length > 0 ? prop[0] : null;
  }
 else   if (propValue instanceof Collection<?>) {
    Collection<?> prop=(Collection<?>)propValue;
    return prop.isEmpty() ? null : prop.iterator().next();
  }
 else {
    return propValue;
  }
}",0.9001161440185831
8814,"/** 
 * Returns the parameter as an array of Strings. If the parameter is a scalar value its string value is returned as a single element array. If the parameter is an array, the elements are converted to String objects and returned as an array. If the parameter is a collection, the collection elements are converted to String objects and returned as an array. Otherwise (if the property is <code>null</code>) a provided default value is returned.
 * @param propValue The object to convert.
 * @param defaultArray The default array to return.
 */
public static String[] toStringArray(Object propValue,String[] defaultArray){
  if (propValue == null) {
    return defaultArray;
  }
 else   if (propValue instanceof String) {
    return new String[]{(String)propValue};
  }
 else   if (propValue instanceof String[]) {
    return (String[])propValue;
  }
 else   if (propValue.getClass().isArray()) {
    Object[] valueArray=(Object[])propValue;
    List<String> values=new ArrayList<String>(valueArray.length);
    for (    Object value : valueArray) {
      if (value != null) {
        values.add(value.toString());
      }
    }
    return values.toArray(new String[values.size()]);
  }
 else   if (propValue instanceof Collection<?>) {
    Collection<?> valueCollection=(Collection<?>)propValue;
    List<String> valueList=new ArrayList<String>(valueCollection.size());
    for (    Object value : valueCollection) {
      if (value != null) {
        valueList.add(value.toString());
      }
    }
    return valueList.toArray(new String[valueList.size()]);
  }
  return defaultArray;
}","/** 
 * Returns the parameter as an array of Strings. If the parameter is a scalar value its string value is returned as a single element array. If the parameter is an array, the elements are converted to String objects and returned as an array. If the parameter is a collection, the collection elements are converted to String objects and returned as an array. Otherwise (if the property is   {@code null}) a provided default value is returned.
 * @param propValue The object to convert.
 * @param defaultArray The default array to return.
 */
public static String[] toStringArray(Object propValue,String[] defaultArray){
  if (propValue == null) {
    return defaultArray;
  }
 else   if (propValue instanceof String) {
    return new String[]{(String)propValue};
  }
 else   if (propValue instanceof String[]) {
    return (String[])propValue;
  }
 else   if (propValue.getClass().isArray()) {
    Object[] valueArray=(Object[])propValue;
    List<String> values=new ArrayList<String>(valueArray.length);
    for (    Object value : valueArray) {
      if (value != null) {
        values.add(value.toString());
      }
    }
    return values.toArray(new String[values.size()]);
  }
 else   if (propValue instanceof Collection<?>) {
    Collection<?> valueCollection=(Collection<?>)propValue;
    List<String> valueList=new ArrayList<String>(valueCollection.size());
    for (    Object value : valueCollection) {
      if (value != null) {
        valueList.add(value.toString());
      }
    }
    return valueList.toArray(new String[valueList.size()]);
  }
  return defaultArray;
}",0.99024850581944
8815,"protected NamedTemplate(NameMapper mapper,String jcrName) throws ConstraintViolationException {
  this(mapper);
  if (jcrName != null) {
    setName(jcrName);
  }
}","protected NamedTemplate(@Nonnull NameMapper mapper,@Nullable String jcrName) throws ConstraintViolationException {
  this(mapper);
  if (jcrName != null) {
    setName(jcrName);
  }
}",0.9452449567723344
8816,"NodeTypeTemplateImpl(NameMapper mapper,NodeTypeDefinition definition) throws ConstraintViolationException {
  super(mapper,definition.getName());
  setMixin(definition.isMixin());
  setOrderableChildNodes(definition.hasOrderableChildNodes());
  setAbstract(definition.isAbstract());
  setQueryable(definition.isQueryable());
  String primaryItemName=definition.getPrimaryItemName();
  if (primaryItemName != null) {
    setPrimaryItemName(primaryItemName);
  }
  setDeclaredSuperTypeNames(definition.getDeclaredSupertypeNames());
  PropertyDefinition[] pds=definition.getDeclaredPropertyDefinitions();
  if (pds != null) {
    propertyDefinitionTemplates=Lists.newArrayListWithCapacity(pds.length);
    for (    PropertyDefinition pd : pds) {
      propertyDefinitionTemplates.add(new PropertyDefinitionTemplateImpl(mapper,pd));
    }
  }
  NodeDefinition[] nds=definition.getDeclaredChildNodeDefinitions();
  if (nds != null) {
    nodeDefinitionTemplates=Lists.newArrayListWithCapacity(nds.length);
    for (    NodeDefinition nd : nds) {
      nodeDefinitionTemplates.add(new NodeDefinitionTemplateImpl(mapper,nd));
    }
  }
}","NodeTypeTemplateImpl(@Nonnull NameMapper mapper,@Nonnull NodeTypeDefinition definition) throws ConstraintViolationException {
  super(mapper,definition.getName());
  setMixin(definition.isMixin());
  setOrderableChildNodes(definition.hasOrderableChildNodes());
  setAbstract(definition.isAbstract());
  setQueryable(definition.isQueryable());
  String primaryItemName=definition.getPrimaryItemName();
  if (primaryItemName != null) {
    setPrimaryItemName(primaryItemName);
  }
  setDeclaredSuperTypeNames(definition.getDeclaredSupertypeNames());
  PropertyDefinition[] pds=definition.getDeclaredPropertyDefinitions();
  if (pds != null) {
    propertyDefinitionTemplates=Lists.newArrayListWithCapacity(pds.length);
    for (    PropertyDefinition pd : pds) {
      propertyDefinitionTemplates.add(new PropertyDefinitionTemplateImpl(mapper,pd));
    }
  }
  NodeDefinition[] nds=definition.getDeclaredChildNodeDefinitions();
  if (nds != null) {
    nodeDefinitionTemplates=Lists.newArrayListWithCapacity(nds.length);
    for (    NodeDefinition nd : nds) {
      nodeDefinitionTemplates.add(new NodeDefinitionTemplateImpl(mapper,nd));
    }
  }
}",0.9920983318700616
8817,"/** 
 * Writes this node type as an   {@code nt:nodeType} child of the givenparent node. An exception is thrown if the child node already exists, unless the  {@code allowUpdate} flag is set, in which case the existingnode is overwritten.
 * @param parent parent node under which to write this node type
 * @param allowUpdate whether to overwrite an existing type
 * @return The node type tree.
 * @throws RepositoryException if this type could not be written
 */
Tree writeTo(Tree parent,boolean allowUpdate) throws RepositoryException {
  String oakName=getOakName();
  Tree type=parent.getChild(oakName);
  if (!type.exists()) {
    type=parent.addChild(oakName);
    type.setProperty(JCR_PRIMARYTYPE,NT_NODETYPE,Type.NAME);
  }
 else   if (!allowUpdate) {
    throw new NodeTypeExistsException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  type.setProperty(JCR_NODETYPENAME,oakName,Type.NAME);
  if (superTypeOakNames.length > 0) {
    type.setProperty(JCR_SUPERTYPES,Arrays.asList(superTypeOakNames),Type.NAMES);
  }
 else {
    type.removeProperty(JCR_SUPERTYPES);
  }
  type.setProperty(JCR_IS_ABSTRACT,isAbstract);
  type.setProperty(JCR_IS_QUERYABLE,queryable);
  type.setProperty(JCR_ISMIXIN,isMixin);
  type.setProperty(JCR_HASORDERABLECHILDNODES,isOrderable);
  if (primaryItemOakName != null) {
    type.setProperty(JCR_PRIMARYITEMNAME,primaryItemOakName,Type.NAME);
  }
 else {
    type.removeProperty(JCR_PRIMARYITEMNAME);
  }
  Tree tree;
  int pdn=1;
  if (propertyDefinitionTemplates != null) {
    for (    PropertyDefinitionTemplateImpl pdt : propertyDefinitionTemplates) {
      String name=JCR_PROPERTYDEFINITION + ""String_Node_Str"" + pdn+++ ""String_Node_Str"";
      tree=type.getChild(name);
      if (!tree.exists()) {
        tree=type.addChild(name);
        tree.setProperty(JCR_PRIMARYTYPE,NT_PROPERTYDEFINITION,NAME);
      }
      pdt.writeTo(tree);
    }
  }
  tree=type.getChild(JCR_PROPERTYDEFINITION + ""String_Node_Str"" + pdn+++ ""String_Node_Str"");
  while (tree.exists()) {
    tree.remove();
    tree=type.getChild(JCR_PROPERTYDEFINITION + ""String_Node_Str"" + pdn+++ ""String_Node_Str"");
  }
  int ndn=1;
  if (nodeDefinitionTemplates != null) {
    for (    NodeDefinitionTemplateImpl ndt : nodeDefinitionTemplates) {
      String name=JCR_CHILDNODEDEFINITION + ""String_Node_Str"" + ndn+++ ""String_Node_Str"";
      tree=type.getChild(name);
      if (!tree.exists()) {
        tree=type.addChild(name);
        tree.setProperty(JCR_PRIMARYTYPE,NT_CHILDNODEDEFINITION,NAME);
      }
      ndt.writeTo(tree);
    }
  }
  tree=type.getChild(JCR_CHILDNODEDEFINITION + ""String_Node_Str"" + ndn+++ ""String_Node_Str"");
  while (tree.exists()) {
    tree.remove();
    tree=type.getChild(JCR_CHILDNODEDEFINITION + ""String_Node_Str"" + ndn+++ ""String_Node_Str"");
  }
  return type;
}","/** 
 * Writes this node type as an   {@code nt:nodeType} child of the givenparent node. An exception is thrown if the child node already exists, unless the  {@code allowUpdate} flag is set, in which case the existingnode is overwritten.
 * @param parent parent node under which to write this node type
 * @param allowUpdate whether to overwrite an existing type
 * @return The node type tree.
 * @throws RepositoryException if this type could not be written
 */
Tree writeTo(@Nonnull Tree parent,boolean allowUpdate) throws RepositoryException {
  String oakName=getOakName();
  if (oakName == null) {
    throw new RepositoryException(""String_Node_Str"");
  }
  Tree type=parent.getChild(oakName);
  if (!type.exists()) {
    type=parent.addChild(oakName);
    type.setProperty(JCR_PRIMARYTYPE,NT_NODETYPE,Type.NAME);
  }
 else   if (!allowUpdate) {
    throw new NodeTypeExistsException(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  type.setProperty(JCR_NODETYPENAME,oakName,Type.NAME);
  if (superTypeOakNames.length > 0) {
    type.setProperty(JCR_SUPERTYPES,Arrays.asList(superTypeOakNames),Type.NAMES);
  }
 else {
    type.removeProperty(JCR_SUPERTYPES);
  }
  type.setProperty(JCR_IS_ABSTRACT,isAbstract);
  type.setProperty(JCR_IS_QUERYABLE,queryable);
  type.setProperty(JCR_ISMIXIN,isMixin);
  type.setProperty(JCR_HASORDERABLECHILDNODES,isOrderable);
  if (primaryItemOakName != null) {
    type.setProperty(JCR_PRIMARYITEMNAME,primaryItemOakName,Type.NAME);
  }
 else {
    type.removeProperty(JCR_PRIMARYITEMNAME);
  }
  Tree tree;
  int pdn=1;
  if (propertyDefinitionTemplates != null) {
    for (    PropertyDefinitionTemplateImpl pdt : propertyDefinitionTemplates) {
      String name=JCR_PROPERTYDEFINITION + ""String_Node_Str"" + pdn+++ ""String_Node_Str"";
      tree=type.getChild(name);
      if (!tree.exists()) {
        tree=type.addChild(name);
        tree.setProperty(JCR_PRIMARYTYPE,NT_PROPERTYDEFINITION,NAME);
      }
      pdt.writeTo(tree);
    }
  }
  tree=type.getChild(JCR_PROPERTYDEFINITION + ""String_Node_Str"" + pdn+++ ""String_Node_Str"");
  while (tree.exists()) {
    tree.remove();
    tree=type.getChild(JCR_PROPERTYDEFINITION + ""String_Node_Str"" + pdn+++ ""String_Node_Str"");
  }
  int ndn=1;
  if (nodeDefinitionTemplates != null) {
    for (    NodeDefinitionTemplateImpl ndt : nodeDefinitionTemplates) {
      String name=JCR_CHILDNODEDEFINITION + ""String_Node_Str"" + ndn+++ ""String_Node_Str"";
      tree=type.getChild(name);
      if (!tree.exists()) {
        tree=type.addChild(name);
        tree.setProperty(JCR_PRIMARYTYPE,NT_CHILDNODEDEFINITION,NAME);
      }
      ndt.writeTo(tree);
    }
  }
  tree=type.getChild(JCR_CHILDNODEDEFINITION + ""String_Node_Str"" + ndn+++ ""String_Node_Str"");
  while (tree.exists()) {
    tree.remove();
    tree=type.getChild(JCR_CHILDNODEDEFINITION + ""String_Node_Str"" + ndn+++ ""String_Node_Str"");
  }
  return type;
}",0.9839385474860336
8818,"private void registerNodeStore() throws IOException {
  String uri=PropertiesUtil.toString(prop(PROP_URI,FWK_PROP_URI),DEFAULT_URI);
  String db=PropertiesUtil.toString(prop(PROP_DB,FWK_PROP_DB),DEFAULT_DB);
  int offHeapCache=toInteger(prop(PROP_OFF_HEAP_CACHE),DEFAULT_OFF_HEAP_CACHE);
  int cacheSize=toInteger(prop(PROP_CACHE),DEFAULT_CACHE);
  int nodeCachePercentage=toInteger(prop(PROP_NODE_CACHE_PERCENTAGE),DEFAULT_NODE_CACHE_PERCENTAGE);
  int childrenCachePercentage=toInteger(prop(PROP_CHILDREN_CACHE_PERCENTAGE),DEFAULT_CHILDREN_CACHE_PERCENTAGE);
  int docChildrenCachePercentage=toInteger(prop(PROP_DOC_CHILDREN_CACHE_PERCENTAGE),DEFAULT_DOC_CHILDREN_CACHE_PERCENTAGE);
  int diffCachePercentage=toInteger(prop(PROP_DIFF_CACHE_PERCENTAGE),DEFAULT_DIFF_CACHE_PERCENTAGE);
  int changesSize=toInteger(prop(PROP_CHANGES_SIZE),DEFAULT_CHANGES_SIZE);
  int blobCacheSize=toInteger(prop(PROP_BLOB_CACHE_SIZE),DEFAULT_BLOB_CACHE_SIZE);
  String persistentCache=PropertiesUtil.toString(prop(PROP_PERSISTENT_CACHE),DEFAULT_PERSISTENT_CACHE);
  int cacheSegmentCount=toInteger(prop(PROP_CACHE_SEGMENT_COUNT),DEFAULT_CACHE_SEGMENT_COUNT);
  int cacheStackMoveDistance=toInteger(prop(PROP_CACHE_STACK_MOVE_DISTANCE),DEFAULT_CACHE_STACK_MOVE_DISTANCE);
  DocumentMK.Builder mkBuilder=new DocumentMK.Builder().memoryCacheSize(cacheSize * MB).memoryCacheDistribution(nodeCachePercentage,childrenCachePercentage,docChildrenCachePercentage,diffCachePercentage).setCacheSegmentCount(cacheSegmentCount).setCacheStackMoveDistance(cacheStackMoveDistance).offHeapCacheSize(offHeapCache * MB);
  if (persistentCache != null && persistentCache.length() > 0) {
    mkBuilder.setPersistentCache(persistentCache);
  }
  if (customBlobStore) {
    checkNotNull(blobStore,""String_Node_Str"" + ""String_Node_Str"",CUSTOM_BLOB_STORE);
    mkBuilder.setBlobStore(blobStore);
  }
  if (documentStoreType == DocumentStoreType.RDB) {
    checkNotNull(dataSource,""String_Node_Str"",PROP_DS_TYPE);
    if (!customBlobStore) {
      checkNotNull(blobDataSource,""String_Node_Str"",PROP_DS_TYPE);
      mkBuilder.setRDBConnection(dataSource,blobDataSource);
      log.info(""String_Node_Str"",dataSource,blobDataSource);
    }
 else {
      if (blobDataSource != null && blobDataSource != dataSource) {
        log.info(""String_Node_Str"",blobDataSource);
      }
      mkBuilder.setRDBConnection(dataSource);
      log.info(""String_Node_Str"",dataSource);
    }
  }
 else {
    MongoClientOptions.Builder builder=MongoConnection.getDefaultBuilder();
    MongoClientURI mongoURI=new MongoClientURI(uri,builder);
    if (log.isInfoEnabled()) {
      log.info(""String_Node_Str"" + ""String_Node_Str"",mongoURI.getHosts(),db,cacheSize,persistentCache,changesSize,blobCacheSize,maxReplicationLagInSecs);
      log.info(""String_Node_Str"",MongoConnection.toString(mongoURI.getOptions()));
    }
    MongoClient client=new MongoClient(mongoURI);
    DB mongoDB=client.getDB(db);
    mkBuilder.setMaxReplicationLag(maxReplicationLagInSecs,TimeUnit.SECONDS);
    mkBuilder.setMongoDB(mongoDB,changesSize,blobCacheSize);
    log.info(""String_Node_Str"",mongoDB);
  }
  mkBuilder.setExecutor(executor);
  mk=mkBuilder.open();
  if (SharedDataStoreUtils.isShared(blobStore)) {
    try {
      String repoId=ClusterRepositoryInfo.createId(mk.getNodeStore());
      ((SharedDataStore)blobStore).addMetadataRecord(new ByteArrayInputStream(new byte[0]),SharedDataStoreUtils.SharedStoreRecordType.REPOSITORY.getNameFromId(repoId));
    }
 catch (    Exception e) {
      throw new IOException(""String_Node_Str"",e);
    }
  }
  registerJMXBeans(mk.getNodeStore());
  registerLastRevRecoveryJob(mk.getNodeStore());
  registerJournalGC(mk.getNodeStore());
  NodeStore store;
  DocumentNodeStore mns=mk.getNodeStore();
  store=mns;
  observerTracker=new ObserverTracker(mns);
  observerTracker.start(context.getBundleContext());
  DocumentStore ds=mk.getDocumentStore();
  final long maxDiff=Long.parseLong(System.getProperty(""String_Node_Str"",""String_Node_Str""));
  try {
    final long timeDiff=ds.determineServerTimeDifferenceMillis();
    log.info(""String_Node_Str"",timeDiff,maxDiff);
    if (Math.abs(timeDiff) > Math.abs(maxDiff)) {
      throw new IllegalStateException(""String_Node_Str"" + timeDiff + ""String_Node_Str""+ maxDiff+ ""String_Node_Str"");
    }
  }
 catch (  RuntimeException e) {
    log.warn(""String_Node_Str"" + e,e);
  }
  Dictionary<String,Object> props=new Hashtable<String,Object>();
  props.put(Constants.SERVICE_PID,DocumentNodeStore.class.getName());
  props.put(DESCRIPTION,getMetadata(ds));
  reg=context.getBundleContext().registerService(NodeStore.class.getName(),store,props);
}","private void registerNodeStore() throws IOException {
  String uri=PropertiesUtil.toString(prop(PROP_URI,FWK_PROP_URI),DEFAULT_URI);
  String db=PropertiesUtil.toString(prop(PROP_DB,FWK_PROP_DB),DEFAULT_DB);
  int offHeapCache=toInteger(prop(PROP_OFF_HEAP_CACHE),DEFAULT_OFF_HEAP_CACHE);
  int cacheSize=toInteger(prop(PROP_CACHE),DEFAULT_CACHE);
  int nodeCachePercentage=toInteger(prop(PROP_NODE_CACHE_PERCENTAGE),DEFAULT_NODE_CACHE_PERCENTAGE);
  int childrenCachePercentage=toInteger(prop(PROP_CHILDREN_CACHE_PERCENTAGE),DEFAULT_CHILDREN_CACHE_PERCENTAGE);
  int docChildrenCachePercentage=toInteger(prop(PROP_DOC_CHILDREN_CACHE_PERCENTAGE),DEFAULT_DOC_CHILDREN_CACHE_PERCENTAGE);
  int diffCachePercentage=toInteger(prop(PROP_DIFF_CACHE_PERCENTAGE),DEFAULT_DIFF_CACHE_PERCENTAGE);
  int changesSize=toInteger(prop(PROP_CHANGES_SIZE),DEFAULT_CHANGES_SIZE);
  int blobCacheSize=toInteger(prop(PROP_BLOB_CACHE_SIZE),DEFAULT_BLOB_CACHE_SIZE);
  String persistentCache=PropertiesUtil.toString(prop(PROP_PERSISTENT_CACHE),DEFAULT_PERSISTENT_CACHE);
  int cacheSegmentCount=toInteger(prop(PROP_CACHE_SEGMENT_COUNT),DEFAULT_CACHE_SEGMENT_COUNT);
  int cacheStackMoveDistance=toInteger(prop(PROP_CACHE_STACK_MOVE_DISTANCE),DEFAULT_CACHE_STACK_MOVE_DISTANCE);
  DocumentMK.Builder mkBuilder=new DocumentMK.Builder().memoryCacheSize(cacheSize * MB).memoryCacheDistribution(nodeCachePercentage,childrenCachePercentage,docChildrenCachePercentage,diffCachePercentage).setCacheSegmentCount(cacheSegmentCount).setCacheStackMoveDistance(cacheStackMoveDistance).offHeapCacheSize(offHeapCache * MB);
  if (persistentCache != null && persistentCache.length() > 0) {
    mkBuilder.setPersistentCache(persistentCache);
  }
  if (customBlobStore) {
    checkNotNull(blobStore,""String_Node_Str"" + ""String_Node_Str"",CUSTOM_BLOB_STORE);
    mkBuilder.setBlobStore(blobStore);
  }
  if (documentStoreType == DocumentStoreType.RDB) {
    checkNotNull(dataSource,""String_Node_Str"",PROP_DS_TYPE);
    if (!customBlobStore) {
      checkNotNull(blobDataSource,""String_Node_Str"",PROP_DS_TYPE);
      mkBuilder.setRDBConnection(dataSource,blobDataSource);
      log.info(""String_Node_Str"",dataSource,blobDataSource);
    }
 else {
      if (blobDataSource != null && blobDataSource != dataSource) {
        log.info(""String_Node_Str"",blobDataSource);
      }
      mkBuilder.setRDBConnection(dataSource);
      log.info(""String_Node_Str"",dataSource);
    }
  }
 else {
    MongoClientOptions.Builder builder=MongoConnection.getDefaultBuilder();
    MongoClientURI mongoURI=new MongoClientURI(uri,builder);
    if (log.isInfoEnabled()) {
      log.info(""String_Node_Str"" + ""String_Node_Str"",mongoURI.getHosts(),db,cacheSize,persistentCache,changesSize,blobCacheSize,maxReplicationLagInSecs);
      log.info(""String_Node_Str"",MongoConnection.toString(mongoURI.getOptions()));
    }
    MongoClient client=new MongoClient(mongoURI);
    DB mongoDB=client.getDB(db);
    mkBuilder.setMaxReplicationLag(maxReplicationLagInSecs,TimeUnit.SECONDS);
    mkBuilder.setMongoDB(mongoDB,changesSize,blobCacheSize);
    log.info(""String_Node_Str"",mongoDB);
  }
  mkBuilder.setExecutor(executor);
  mk=mkBuilder.open();
  if (SharedDataStoreUtils.isShared(blobStore)) {
    try {
      String repoId=ClusterRepositoryInfo.createId(mk.getNodeStore());
      ((SharedDataStore)blobStore).addMetadataRecord(new ByteArrayInputStream(new byte[0]),SharedDataStoreUtils.SharedStoreRecordType.REPOSITORY.getNameFromId(repoId));
    }
 catch (    Exception e) {
      throw new IOException(""String_Node_Str"",e);
    }
  }
  registerJMXBeans(mk.getNodeStore());
  registerLastRevRecoveryJob(mk.getNodeStore());
  registerJournalGC(mk.getNodeStore());
  NodeStore store;
  DocumentNodeStore mns=mk.getNodeStore();
  store=mns;
  observerTracker=new ObserverTracker(mns);
  observerTracker.start(context.getBundleContext());
  DocumentStore ds=mk.getDocumentStore();
  final long maxDiff=Long.parseLong(System.getProperty(""String_Node_Str"",""String_Node_Str""));
  try {
    final long timeDiff=ds.determineServerTimeDifferenceMillis();
    log.info(""String_Node_Str"",timeDiff,maxDiff);
    if (Math.abs(timeDiff) > Math.abs(maxDiff)) {
      throw new AssertionError(""String_Node_Str"" + timeDiff + ""String_Node_Str""+ maxDiff+ ""String_Node_Str"");
    }
  }
 catch (  RuntimeException e) {
    log.warn(""String_Node_Str"" + e,e);
  }
  Dictionary<String,Object> props=new Hashtable<String,Object>();
  props.put(Constants.SERVICE_PID,DocumentNodeStore.class.getName());
  props.put(DESCRIPTION,getMetadata(ds));
  reg=context.getBundleContext().registerService(NodeStore.class.getName(),store,props);
}",0.9962337243086192
8819,"/** 
 * Sweep phase of gc candidate deletion. <p> Performs the following steps depending upon the type of the blob store refer  {@link org.apache.jackrabbit.oak.plugins.blob.SharedDataStore.Type}: <ul> <li>Shared</li> <ul> <li> Merge all marked references (from the mark phase run independently) available in the data store meta store (from all configured independent repositories). <li> Retrieve all blob ids available. <li> Diffs the 2 sets above to retrieve list of blob ids not used. <li> Deletes only blobs created after (earliest time stamp of the marked references - #maxLastModifiedInterval) from the above set. </ul> <li>Default</li> <ul> <li> Mark phase already run. <li> Retrieve all blob ids available. <li> Diffs the 2 sets above to retrieve list of blob ids not used. <li> Deletes only blobs created after (time stamp of the marked references - #maxLastModifiedInterval). </ul> </ul>
 * @return the number of blobs deleted
 * @throws Exception the exception
 */
private int sweep() throws Exception {
  long earliestRefAvailTime;
  try {
    earliestRefAvailTime=GarbageCollectionType.get(blobStore).mergeAllMarkedReferences(blobStore,fs);
    LOG.debug(""String_Node_Str"",earliestRefAvailTime);
  }
 catch (  Exception e) {
    return 0;
  }
  (new BlobIdRetriever()).call();
  difference();
  int count=0;
  state=State.SWEEPING;
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + timestampToString(getLastMaxModifiedTime(earliestRefAvailTime)));
  ConcurrentLinkedQueue<String> exceptionQueue=new ConcurrentLinkedQueue<String>();
  LineIterator iterator=FileUtils.lineIterator(fs.getGcCandidates(),Charsets.UTF_8.name());
  List<String> ids=Lists.newArrayList();
  while (iterator.hasNext()) {
    ids.add(iterator.next());
    if (ids.size() > getBatchCount()) {
      count+=ids.size();
      executor.execute(new Sweeper(ids,exceptionQueue,earliestRefAvailTime));
      ids=Lists.newArrayList();
    }
  }
  if (!ids.isEmpty()) {
    count+=ids.size();
    executor.execute(new Sweeper(ids,exceptionQueue,earliestRefAvailTime));
  }
  count-=exceptionQueue.size();
  BufferedWriter writer=null;
  try {
    if (!exceptionQueue.isEmpty()) {
      writer=Files.newWriter(fs.getGarbage(),Charsets.UTF_8);
      saveBatchToFile(Lists.newArrayList(exceptionQueue),writer);
    }
  }
  finally {
    LineIterator.closeQuietly(iterator);
    IOUtils.closeQuietly(writer);
  }
  if (!exceptionQueue.isEmpty()) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",timestampToString(getLastMaxModifiedTime(earliestRefAvailTime)),fs.getGarbage().getAbsolutePath());
  }
  GarbageCollectionType.get(blobStore).removeAllMarkedReferences(blobStore);
  LOG.debug(""String_Node_Str"");
  return count;
}","/** 
 * Sweep phase of gc candidate deletion. <p> Performs the following steps depending upon the type of the blob store refer  {@link org.apache.jackrabbit.oak.plugins.blob.SharedDataStore.Type}: <ul> <li>Shared</li> <ul> <li> Merge all marked references (from the mark phase run independently) available in the data store meta store (from all configured independent repositories). <li> Retrieve all blob ids available. <li> Diffs the 2 sets above to retrieve list of blob ids not used. <li> Deletes only blobs created after (earliest time stamp of the marked references - #maxLastModifiedInterval) from the above set. </ul> <li>Default</li> <ul> <li> Mark phase already run. <li> Retrieve all blob ids available. <li> Diffs the 2 sets above to retrieve list of blob ids not used. <li> Deletes only blobs created after (time stamp of the marked references - #maxLastModifiedInterval). </ul> </ul>
 * @return the number of blobs deleted
 * @throws Exception the exception
 */
private int sweep() throws Exception {
  long earliestRefAvailTime;
  try {
    earliestRefAvailTime=GarbageCollectionType.get(blobStore).mergeAllMarkedReferences(blobStore,fs);
    LOG.debug(""String_Node_Str"",earliestRefAvailTime);
  }
 catch (  Exception e) {
    return 0;
  }
  (new BlobIdRetriever()).call();
  difference();
  int count=0;
  state=State.SWEEPING;
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"",timestampToString(getLastMaxModifiedTime(earliestRefAvailTime)));
  ConcurrentLinkedQueue<String> exceptionQueue=new ConcurrentLinkedQueue<String>();
  LineIterator iterator=FileUtils.lineIterator(fs.getGcCandidates(),Charsets.UTF_8.name());
  List<String> ids=Lists.newArrayList();
  while (iterator.hasNext()) {
    ids.add(iterator.next());
    if (ids.size() > getBatchCount()) {
      count+=ids.size();
      executor.execute(new Sweeper(ids,exceptionQueue,earliestRefAvailTime));
      ids=Lists.newArrayList();
    }
  }
  if (!ids.isEmpty()) {
    count+=ids.size();
    executor.execute(new Sweeper(ids,exceptionQueue,earliestRefAvailTime));
  }
  count-=exceptionQueue.size();
  BufferedWriter writer=null;
  try {
    if (!exceptionQueue.isEmpty()) {
      writer=Files.newWriter(fs.getGarbage(),Charsets.UTF_8);
      saveBatchToFile(Lists.newArrayList(exceptionQueue),writer);
    }
  }
  finally {
    LineIterator.closeQuietly(iterator);
    IOUtils.closeQuietly(writer);
  }
  if (!exceptionQueue.isEmpty()) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"",timestampToString(getLastMaxModifiedTime(earliestRefAvailTime)),fs.getGarbage().getAbsolutePath());
  }
  GarbageCollectionType.get(blobStore).removeAllMarkedReferences(blobStore);
  LOG.debug(""String_Node_Str"");
  return count;
}",0.9992636229749632
8820,"@Nonnull private static Result searchAces(@Nonnull Set<Principal> principals,@Nonnull Root root) throws RepositoryException {
  StringBuilder stmt=new StringBuilder(""String_Node_Str"");
  stmt.append(""String_Node_Str"");
  stmt.append(NT_REP_ACE);
  stmt.append(""String_Node_Str"");
  int i=0;
  for (  Principal principal : principals) {
    if (i > 0) {
      stmt.append(""String_Node_Str"");
    }
    stmt.append('@');
    stmt.append(ISO9075.encode(REP_PRINCIPAL_NAME));
    stmt.append(""String_Node_Str"");
    stmt.append(principal.getName().replaceAll(""String_Node_Str"",""String_Node_Str""));
    stmt.append('\'');
    i++;
  }
  stmt.append(']');
  stmt.append(""String_Node_Str"");
  try {
    QueryEngine queryEngine=root.getQueryEngine();
    return queryEngine.executeQuery(stmt.toString(),Query.XPATH,Long.MAX_VALUE,0,QueryEngine.NO_BINDINGS,QueryEngine.NO_MAPPINGS);
  }
 catch (  ParseException e) {
    String msg=""String_Node_Str"";
    log.error(msg,e.getMessage());
    throw new RepositoryException(msg,e);
  }
}","@Nonnull private static Result searchAces(@Nonnull Set<Principal> principals,@Nonnull Root root) throws RepositoryException {
  StringBuilder stmt=new StringBuilder(""String_Node_Str"");
  stmt.append(""String_Node_Str"");
  stmt.append(NT_REP_ACE);
  stmt.append(""String_Node_Str"");
  int i=0;
  for (  Principal principal : principals) {
    if (i > 0) {
      stmt.append(""String_Node_Str"");
    }
    stmt.append('@');
    stmt.append(ISO9075.encode(REP_PRINCIPAL_NAME));
    stmt.append(""String_Node_Str"");
    stmt.append(principal.getName().replaceAll(""String_Node_Str"",""String_Node_Str""));
    stmt.append('\'');
    i++;
  }
  stmt.append(']');
  stmt.append(""String_Node_Str"");
  try {
    QueryEngine queryEngine=root.getQueryEngine();
    return queryEngine.executeQuery(stmt.toString(),Query.XPATH,Long.MAX_VALUE,0,QueryEngine.NO_BINDINGS,QueryEngine.NO_MAPPINGS);
  }
 catch (  ParseException e) {
    String msg=""String_Node_Str"";
    log.error(msg,e);
    throw new RepositoryException(msg,e);
  }
}",0.9936117936117936
8821,"@CheckForNull private String saveGetId(@Nonnull Authorizable authorizable){
  try {
    return authorizable.getID();
  }
 catch (  RepositoryException e) {
    log.debug(""String_Node_Str"",authorizable,e.getMessage());
  }
  return null;
}","@CheckForNull private String saveGetId(@Nonnull Authorizable authorizable){
  try {
    return authorizable.getID();
  }
 catch (  RepositoryException e) {
    log.debug(""String_Node_Str"",authorizable,e);
  }
  return null;
}",0.9719222462203024
8822,"@Override public boolean apply(@Nullable Authorizable authorizable){
  if (authorizable != null) {
    try {
      String id=authorizable.getID();
      if (memberIds.contains(id)) {
        return true;
      }
 else {
        while (membersIterator.hasNext()) {
          String memberId=saveGetId(membersIterator.next());
          if (memberId != null) {
            memberIds.add(memberId);
            if (memberId.equals(id)) {
              return true;
            }
          }
        }
      }
    }
 catch (    RepositoryException e) {
      log.debug(""String_Node_Str"",authorizable,e.getMessage());
    }
  }
  return false;
}","@Override public boolean apply(@Nullable Authorizable authorizable){
  if (authorizable != null) {
    try {
      String id=authorizable.getID();
      if (memberIds.contains(id)) {
        return true;
      }
 else {
        while (membersIterator.hasNext()) {
          String memberId=saveGetId(membersIterator.next());
          if (memberId != null) {
            memberIds.add(memberId);
            if (memberId.equals(id)) {
              return true;
            }
          }
        }
      }
    }
 catch (    RepositoryException e) {
      log.debug(""String_Node_Str"",authorizable,e);
    }
  }
  return false;
}",0.98973954222573
8823,"/** 
 * Get a possibly non existing tree.
 * @param path the path to the tree
 * @return a {@link Tree} instance for the child at {@code path}.
 */
@CheckForNull MutableTree getTree(@Nonnull String path){
  checkArgument(isAbsolute(checkNotNull(path)));
  beforeRead();
  MutableTree child=this;
  for (  String name : elements(path)) {
    child=new MutableTree(root,pendingMoves,child,child.nodeBuilder.getChildNode(name),name);
  }
  return child;
}","/** 
 * Get a possibly non existing tree.
 * @param path the path to the tree
 * @return a {@link Tree} instance for the child at {@code path}.
 */
@Nonnull MutableTree getTree(@Nonnull String path){
  checkArgument(isAbsolute(checkNotNull(path)));
  beforeRead();
  MutableTree child=this;
  for (  String name : elements(path)) {
    child=new MutableTree(root,pendingMoves,child,child.nodeBuilder.getChildNode(name),name);
  }
  return child;
}",0.9877641824249166
8824,"@Test public void testCombinedOr() throws ParseException {
  StringBuilder buff=new StringBuilder(""String_Node_Str"");
  StringBuilder buff2=new StringBuilder(""String_Node_Str"");
  int step=111;
  for (int i=0; i < 5000; i++) {
    if (i % step == 2) {
      if (i > 0) {
        buff.append(""String_Node_Str"");
      }
      buff.append(""String_Node_Str"").append(i);
      buff2.append(""String_Node_Str"" + ""String_Node_Str"").append(i);
      buff2.append(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      if (i > 0) {
        buff.append(""String_Node_Str"");
      }
      buff.append(""String_Node_Str"").append(i);
      if (i > 0 && i % step != 3) {
        buff2.append(""String_Node_Str"");
      }
      buff2.append(i);
    }
  }
  buff.append(""String_Node_Str"");
  buff2.append(""String_Node_Str"");
  String xpath=buff.toString();
  XPathToSQL2Converter conv=new XPathToSQL2Converter();
  long start=System.currentTimeMillis();
  Profiler prof=new Profiler().startCollecting();
  String sql2=conv.convert(xpath);
  long time=System.currentTimeMillis() - start;
  System.out.println(""String_Node_Str"" + time);
  System.out.println(prof.getTop(5));
  buff2.append(""String_Node_Str"").append(xpath).append(""String_Node_Str"");
  assertEquals(buff2.toString(),sql2);
}","@Test public void testCombinedOr() throws ParseException {
  StringBuilder buff=new StringBuilder(""String_Node_Str"");
  StringBuilder buff2=new StringBuilder(""String_Node_Str"");
  int step=111;
  for (int i=0; i < 5000; i++) {
    if (i % step == 2) {
      if (i > 0) {
        buff.append(""String_Node_Str"");
      }
      buff.append(""String_Node_Str"").append(i);
      buff2.append(""String_Node_Str"" + ""String_Node_Str"").append(i);
      buff2.append(""String_Node_Str"" + ""String_Node_Str"");
    }
 else {
      if (i > 0) {
        buff.append(""String_Node_Str"");
      }
      buff.append(""String_Node_Str"").append(i);
      if (i > 0 && i % step != 3) {
        buff2.append(""String_Node_Str"");
      }
      buff2.append(i);
    }
  }
  buff.append(""String_Node_Str"");
  buff2.append(""String_Node_Str"");
  String xpath=buff.toString();
  XPathToSQL2Converter conv=new XPathToSQL2Converter();
  String sql2=conv.convert(xpath);
  buff2.append(""String_Node_Str"").append(xpath).append(""String_Node_Str"");
  assertEquals(buff2.toString(),sql2);
}",0.9031424881618596
8825,"@Override public Principal apply(Authorizable authorizable){
  if (authorizable == null) {
    return null;
  }
  try {
    return authorizable.getPrincipal();
  }
 catch (  RepositoryException e) {
    String msg=""String_Node_Str"" + e.getMessage();
    log.error(msg);
    throw new IllegalStateException(msg);
  }
}","@Override public Principal apply(Authorizable authorizable){
  if (authorizable == null) {
    return null;
  }
  try {
    return authorizable.getPrincipal();
  }
 catch (  RepositoryException e) {
    String msg=""String_Node_Str"" + e.getMessage();
    log.error(msg);
    throw new IllegalStateException(msg,e);
  }
}",0.9968553459119496
8826,"@Override public Enumeration<? extends Principal> members(){
  final Iterator<Authorizable> members;
  try {
    members=getMembers();
  }
 catch (  RepositoryException e) {
    String msg=""String_Node_Str"" + e.getMessage();
    log.error(msg);
    throw new IllegalStateException(msg);
  }
  Iterator<Principal> principals=Iterators.transform(members,new Function<Authorizable,Principal>(){
    @Override public Principal apply(    Authorizable authorizable){
      if (authorizable == null) {
        return null;
      }
      try {
        return authorizable.getPrincipal();
      }
 catch (      RepositoryException e) {
        String msg=""String_Node_Str"" + e.getMessage();
        log.error(msg);
        throw new IllegalStateException(msg);
      }
    }
  }
);
  return Iterators.asEnumeration(Iterators.filter(principals,Predicates.<Object>notNull()));
}","@Override public Enumeration<? extends Principal> members(){
  final Iterator<Authorizable> members;
  try {
    members=getMembers();
  }
 catch (  RepositoryException e) {
    String msg=""String_Node_Str"" + e.getMessage();
    log.error(msg);
    throw new IllegalStateException(msg,e);
  }
  Iterator<Principal> principals=Iterators.transform(members,new Function<Authorizable,Principal>(){
    @Override public Principal apply(    Authorizable authorizable){
      if (authorizable == null) {
        return null;
      }
      try {
        return authorizable.getPrincipal();
      }
 catch (      RepositoryException e) {
        String msg=""String_Node_Str"" + e.getMessage();
        log.error(msg);
        throw new IllegalStateException(msg,e);
      }
    }
  }
);
  return Iterators.asEnumeration(Iterators.filter(principals,Predicates.<Object>notNull()));
}",0.997698504027618
8827,"public static boolean notMatch(PropertyValue p1,PropertyValue p2){
  if (p1.getType().tag() != p2.getType().tag()) {
    return true;
  }
switch (p1.getType().tag()) {
case PropertyType.BINARY:
    if (p1.isArray() && !p2.isArray()) {
      if (p1.count() > 1) {
        return true;
      }
      return !contains(p1.getValue(Type.BINARIES),p2.getValue(Type.BINARY));
    }
  if (!p1.isArray() && p2.isArray()) {
    if (p2.count() > 1) {
      return true;
    }
    return !contains(p2.getValue(Type.BINARIES),p1.getValue(Type.BINARY));
  }
break;
default :
if (p1.isArray() && !p2.isArray()) {
if (p1.count() > 1) {
  return true;
}
return !contains(p1.getValue(Type.STRINGS),p2.getValue(Type.STRING));
}
if (!p1.isArray() && p2.isArray()) {
if (p2.count() > 1) {
return true;
}
return !contains(p2.getValue(Type.STRINGS),p1.getValue(Type.STRING));
}
}
return p1.compareTo(p2) != 0;
}","public static boolean notMatch(@Nonnull PropertyValue p1,@Nonnull PropertyValue p2){
  if (p1.getType().tag() != p2.getType().tag()) {
    return true;
  }
switch (p1.getType().tag()) {
case PropertyType.BINARY:
    if (p1.isArray() && !p2.isArray()) {
      if (p1.count() > 1) {
        return true;
      }
      return !contains(p1.getValue(Type.BINARIES),p2.getValue(Type.BINARY));
    }
  if (!p1.isArray() && p2.isArray()) {
    if (p2.count() > 1) {
      return true;
    }
    return !contains(p2.getValue(Type.BINARIES),p1.getValue(Type.BINARY));
  }
break;
default :
if (p1.isArray() && !p2.isArray()) {
if (p1.count() > 1) {
  return true;
}
return !contains(p1.getValue(Type.STRINGS),p2.getValue(Type.STRING));
}
if (!p1.isArray() && p2.isArray()) {
if (p2.count() > 1) {
return true;
}
return !contains(p2.getValue(Type.STRINGS),p1.getValue(Type.STRING));
}
}
return p1.compareTo(p2) != 0;
}",0.9899665551839464
8828,"@Nonnull public static PropertyValue newLong(Long value){
  return new PropertyStateValue(LongPropertyState.createLongProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newLong(@Nonnull Long value){
  return new PropertyStateValue(LongPropertyState.createLongProperty(""String_Node_Str"",value));
}",0.9717868338557992
8829,"@Nonnull public static PropertyValue newWeakReference(String value){
  return new PropertyStateValue(GenericPropertyState.weakreferenceProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newWeakReference(@Nonnull String value){
  return new PropertyStateValue(GenericPropertyState.weakreferenceProperty(""String_Node_Str"",value));
}",0.9745042492917848
8830,"public static boolean match(PropertyValue p1,PropertyValue p2){
  if (p1.getType().tag() != p2.getType().tag()) {
    return false;
  }
switch (p1.getType().tag()) {
case PropertyType.BINARY:
    if (p1.isArray() && !p2.isArray()) {
      return contains(p1.getValue(Type.BINARIES),p2.getValue(Type.BINARY));
    }
  if (!p1.isArray() && p2.isArray()) {
    return contains(p2.getValue(Type.BINARIES),p1.getValue(Type.BINARY));
  }
break;
default :
if (p1.isArray() && !p2.isArray()) {
return contains(p1.getValue(Type.STRINGS),p2.getValue(Type.STRING));
}
if (!p1.isArray() && p2.isArray()) {
return contains(p2.getValue(Type.STRINGS),p1.getValue(Type.STRING));
}
}
return p1.compareTo(p2) == 0;
}","public static boolean match(@Nonnull PropertyValue p1,@Nonnull PropertyValue p2){
  if (p1.getType().tag() != p2.getType().tag()) {
    return false;
  }
switch (p1.getType().tag()) {
case PropertyType.BINARY:
    if (p1.isArray() && !p2.isArray()) {
      return contains(p1.getValue(Type.BINARIES),p2.getValue(Type.BINARY));
    }
  if (!p1.isArray() && p2.isArray()) {
    return contains(p2.getValue(Type.BINARIES),p1.getValue(Type.BINARY));
  }
break;
default :
if (p1.isArray() && !p2.isArray()) {
return contains(p1.getValue(Type.STRINGS),p2.getValue(Type.STRING));
}
if (!p1.isArray() && p2.isArray()) {
return contains(p2.getValue(Type.STRINGS),p1.getValue(Type.STRING));
}
}
return p1.compareTo(p2) == 0;
}",0.9872701555869872
8831,"@Nonnull public static PropertyValue newReference(String value){
  return new PropertyStateValue(GenericPropertyState.referenceProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newReference(@Nonnull String value){
  return new PropertyStateValue(GenericPropertyState.referenceProperty(""String_Node_Str"",value));
}",0.973293768545994
8832,"/** 
 * Converts the given value to a value of the specified target type. The conversion is performed according to the rules described in ""3.6.4 Property Type Conversion"" in the JCR 2.0 specification.
 * @param value the value to convert
 * @param targetType the target property type 
 * @param mapper the name mapper
 * @return the converted value
 * @throws IllegalArgumentException if mapping is illegal
 */
public static PropertyValue convert(PropertyValue value,int targetType,NamePathMapper mapper){
  int sourceType=value.getType().tag();
  if (sourceType == targetType) {
    return value;
  }
switch (targetType) {
case PropertyType.BINARY:
    Blob blob=value.getValue(Type.BINARY);
  return newBinary(blob);
case PropertyType.BOOLEAN:
return newBoolean(value.getValue(Type.BOOLEAN));
case PropertyType.DATE:
return newDate(value.getValue(Type.DATE));
case PropertyType.DOUBLE:
return newDouble(value.getValue(Type.DOUBLE));
case PropertyType.LONG:
return newLong(value.getValue(Type.LONG));
case PropertyType.DECIMAL:
return newDecimal(value.getValue(Type.DECIMAL));
}
String v=value.getValue(Type.STRING);
switch (targetType) {
case PropertyType.STRING:
return newString(v);
case PropertyType.PATH:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.NAME:
return newPath(v);
case PropertyType.URI:
URI uri=URI.create(v);
if (uri.isAbsolute()) {
throw new IllegalArgumentException(""String_Node_Str"" + v + ""String_Node_Str"");
}
String p=uri.getPath();
if (p.startsWith(""String_Node_Str"")) {
p=p.substring(2);
}
return newPath(v);
}
break;
case PropertyType.NAME:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.PATH:
return newName(getOakPath(v,mapper));
case PropertyType.URI:
URI uri=URI.create(v);
if (uri.isAbsolute()) {
throw new IllegalArgumentException(""String_Node_Str"" + v + ""String_Node_Str"");
}
String p=uri.getPath();
if (p.startsWith(""String_Node_Str"")) {
p=p.substring(2);
}
return newName(getOakPath(v,mapper));
}
break;
case PropertyType.REFERENCE:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.WEAKREFERENCE:
return newReference(v);
}
break;
case PropertyType.WEAKREFERENCE:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.REFERENCE:
return newWeakReference(v);
}
break;
case PropertyType.URI:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
return newUri(v);
case PropertyType.NAME:
return newUri(""String_Node_Str"" + v);
case PropertyType.PATH:
return newUri(""String_Node_Str"" + v);
}
}
throw new IllegalArgumentException(""String_Node_Str"" + PropertyType.nameFromValue(sourceType) + ""String_Node_Str""+ PropertyType.nameFromValue(targetType));
}","/** 
 * Converts the given value to a value of the specified target type. The conversion is performed according to the rules described in ""3.6.4 Property Type Conversion"" in the JCR 2.0 specification.
 * @param value the value to convert
 * @param targetType the target property type 
 * @param mapper the name mapper
 * @return the converted value
 * @throws IllegalArgumentException if mapping is illegal
 */
public static PropertyValue convert(@Nonnull PropertyValue value,int targetType,@Nonnull NamePathMapper mapper){
  int sourceType=value.getType().tag();
  if (sourceType == targetType) {
    return value;
  }
switch (targetType) {
case PropertyType.BINARY:
    Blob blob=value.getValue(Type.BINARY);
  return newBinary(blob);
case PropertyType.BOOLEAN:
return newBoolean(value.getValue(Type.BOOLEAN));
case PropertyType.DATE:
return newDate(value.getValue(Type.DATE));
case PropertyType.DOUBLE:
return newDouble(value.getValue(Type.DOUBLE));
case PropertyType.LONG:
return newLong(value.getValue(Type.LONG));
case PropertyType.DECIMAL:
return newDecimal(value.getValue(Type.DECIMAL));
}
String v=value.getValue(Type.STRING);
switch (targetType) {
case PropertyType.STRING:
return newString(v);
case PropertyType.PATH:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.NAME:
return newPath(v);
case PropertyType.URI:
URI uri=URI.create(v);
if (uri.isAbsolute()) {
throw new IllegalArgumentException(""String_Node_Str"" + v + ""String_Node_Str"");
}
String p=uri.getPath();
if (p.startsWith(""String_Node_Str"")) {
p=p.substring(2);
}
return newPath(v);
}
break;
case PropertyType.NAME:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.PATH:
return newName(getOakPath(v,mapper));
case PropertyType.URI:
URI uri=URI.create(v);
if (uri.isAbsolute()) {
throw new IllegalArgumentException(""String_Node_Str"" + v + ""String_Node_Str"");
}
String p=uri.getPath();
if (p.startsWith(""String_Node_Str"")) {
p=p.substring(2);
}
return newName(getOakPath(v,mapper));
}
break;
case PropertyType.REFERENCE:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.WEAKREFERENCE:
return newReference(v);
}
break;
case PropertyType.WEAKREFERENCE:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.REFERENCE:
return newWeakReference(v);
}
break;
case PropertyType.URI:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
return newUri(v);
case PropertyType.NAME:
return newUri(""String_Node_Str"" + v);
case PropertyType.PATH:
return newUri(""String_Node_Str"" + v);
}
}
throw new IllegalArgumentException(""String_Node_Str"" + PropertyType.nameFromValue(sourceType) + ""String_Node_Str""+ PropertyType.nameFromValue(targetType));
}",0.996764917325665
8833,"@Nonnull public static PropertyValue newDecimal(BigDecimal value){
  return new PropertyStateValue(DecimalPropertyState.decimalProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newDecimal(@Nonnull BigDecimal value){
  return new PropertyStateValue(DecimalPropertyState.decimalProperty(""String_Node_Str"",value));
}",0.973293768545994
8834,"@Nonnull public static PropertyValue newString(Iterable<String> value){
  return new PropertyStateValue(MultiStringPropertyState.stringProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newString(@Nonnull Iterable<String> value){
  return new PropertyStateValue(MultiStringPropertyState.stringProperty(""String_Node_Str"",value));
}",0.9745042492917848
8835,"@Nonnull public static PropertyValue newDouble(Double value){
  return new PropertyStateValue(DoublePropertyState.doubleProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newDouble(@Nonnull Double value){
  return new PropertyStateValue(DoublePropertyState.doubleProperty(""String_Node_Str"",value));
}",0.9721362229102168
8836,"@Nonnull public static PropertyValue newName(Iterable<String> value){
  return new PropertyStateValue(MultiGenericPropertyState.nameProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newName(@Nonnull Iterable<String> value){
  return new PropertyStateValue(MultiGenericPropertyState.nameProperty(""String_Node_Str"",value));
}",0.9740634005763688
8837,"@Nonnull public static PropertyValue newUri(String value){
  return new PropertyStateValue(GenericPropertyState.uriProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newUri(@Nonnull String value){
  return new PropertyStateValue(GenericPropertyState.uriProperty(""String_Node_Str"",value));
}",0.9712460063897764
8838,"public static String getOakPath(String jcrPath,NamePathMapper mapper){
  if (mapper == null) {
    return jcrPath;
  }
  String p=mapper.getOakPath(jcrPath);
  if (p == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + jcrPath);
  }
  return p;
}","public static String getOakPath(@Nonnull String jcrPath,@CheckForNull NamePathMapper mapper){
  if (mapper == null) {
    return jcrPath;
  }
  String p=mapper.getOakPath(jcrPath);
  if (p == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + jcrPath);
  }
  return p;
}",0.9581056466302368
8839,"@CheckForNull public static PropertyState create(PropertyValue value){
  if (value == null) {
    return null;
  }
  if (value instanceof PropertyStateValue) {
    return ((PropertyStateValue)value).unwrap();
  }
  return null;
}","@CheckForNull public static PropertyState create(@CheckForNull PropertyValue value){
  if (value == null) {
    return null;
  }
  if (value instanceof PropertyStateValue) {
    return ((PropertyStateValue)value).unwrap();
  }
  return null;
}",0.9703389830508474
8840,"@Nonnull public static PropertyValue newDate(String value){
  return new PropertyStateValue(GenericPropertyState.dateProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newDate(@Nonnull String value){
  return new PropertyStateValue(GenericPropertyState.dateProperty(""String_Node_Str"",value));
}",0.9716088328075708
8841,"@Nonnull public static PropertyValue newPath(String value){
  return new PropertyStateValue(GenericPropertyState.pathProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newPath(@Nonnull String value){
  return new PropertyStateValue(GenericPropertyState.pathProperty(""String_Node_Str"",value));
}",0.9716088328075708
8842,"@Nonnull public static PropertyValue newBinary(Blob value){
  return new PropertyStateValue(BinaryPropertyState.binaryProperty(""String_Node_Str"",value));
}","@Nonnull public static PropertyValue newBinary(@Nonnull Blob value){
  return new PropertyStateValue(BinaryPropertyState.binaryProperty(""String_Node_Str"",value));
}",0.9717868338557992
8843,"/** 
 * Returns   {@code true} if the given {@code tree} is of type{@code mix:versionable};   {@code false} otherwise.
 * @param tree the tree to check.
 * @return whether the {@code tree} is versionable.
 * @throws RepositoryException if an error occurs while checking the nodetype of the tree.
 */
protected boolean isVersionable(@Nonnull Tree tree){
  return getNodeTypeManager().isNodeType(checkNotNull(tree),VersionConstants.MIX_VERSIONABLE);
}","/** 
 * Returns   {@code true} if the given {@code tree} is of type{@code mix:versionable};   {@code false} otherwise.
 * @param tree the tree to check.
 * @return whether the {@code tree} is versionable.
 */
protected boolean isVersionable(@Nonnull Tree tree){
  return getNodeTypeManager().isNodeType(checkNotNull(tree),VersionConstants.MIX_VERSIONABLE);
}",0.8872366790582404
8844,"@Override public int getAction(NodeBuilder src,NodeBuilder dest,PropertyState prop) throws RepositoryException {
  return COPY;
}","@Override public int getAction(NodeBuilder src,NodeBuilder dest,PropertyState prop){
  return COPY;
}",0.8782608695652174
8845,"public void removeVersion(@Nonnull VersionStorage versionStorage,@Nonnull String versionHistoryOakRelPath,@Nonnull String oakVersionName) throws RepositoryException {
  Tree versionHistory=TreeUtil.getTree(versionStorage.getTree(),versionHistoryOakRelPath);
  if (!versionHistory.exists()) {
    throw new VersionException(""String_Node_Str"" + versionHistoryOakRelPath + ""String_Node_Str"");
  }
  Tree version=versionHistory.getChild(oakVersionName);
  if (!version.exists()) {
    throw new VersionException(""String_Node_Str"" + oakVersionName + ""String_Node_Str"");
  }
  version.remove();
  try {
    sessionDelegate.commit(versionStorage.getRoot());
    refresh();
  }
 catch (  CommitFailedException e) {
    versionStorage.refresh();
    throw e.asRepositoryException();
  }
}","public void removeVersion(@Nonnull VersionStorage versionStorage,@Nonnull String versionHistoryOakRelPath,@Nonnull String oakVersionName) throws RepositoryException {
  Tree versionHistory=TreeUtil.getTree(versionStorage.getTree(),versionHistoryOakRelPath);
  if (versionHistory == null || !versionHistory.exists()) {
    throw new VersionException(""String_Node_Str"" + versionHistoryOakRelPath + ""String_Node_Str"");
  }
  Tree version=versionHistory.getChild(oakVersionName);
  if (!version.exists()) {
    throw new VersionException(""String_Node_Str"" + oakVersionName + ""String_Node_Str"");
  }
  version.remove();
  try {
    sessionDelegate.commit(versionStorage.getRoot());
    refresh();
  }
 catch (  CommitFailedException e) {
    versionStorage.refresh();
    throw e.asRepositoryException();
  }
}",0.9835858585858586
8846,"/** 
 * Performs a checkin on a versionable tree and returns the tree that represents the created version.
 * @param versionable the versionable node to check in.
 * @return the created version.
 * @throws InvalidItemStateException if the current root has pendingchanges.
 * @throws UnsupportedRepositoryOperationException if the versionable tree isn't actually versionable.
 * @throws RepositoryException       if an error occurs while checking thenode type of the tree.
 */
@Nonnull public Tree checkin(@Nonnull Tree versionable) throws RepositoryException, InvalidItemStateException, UnsupportedRepositoryOperationException {
  if (sessionDelegate.hasPendingChanges()) {
    throw new InvalidItemStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!isVersionable(versionable)) {
    throw new UnsupportedRepositoryOperationException(versionable.getPath() + ""String_Node_Str"");
  }
  if (isCheckedOut(versionable)) {
    versionable.setProperty(JCR_ISCHECKEDOUT,Boolean.FALSE,Type.BOOLEAN);
    Tree baseVersion=getBaseVersion(versionable);
    PropertyState created=baseVersion.getProperty(JCR_CREATED);
    if (created != null) {
      long c=ISO8601.parse(created.getValue(Type.DATE)).getTimeInMillis();
      while (System.currentTimeMillis() == c) {
      }
    }
    try {
      sessionDelegate.commit();
      refresh();
    }
 catch (    CommitFailedException e) {
      sessionDelegate.refresh(true);
      throw e.asRepositoryException();
    }
  }
  return getBaseVersion(getWorkspaceRoot().getTree(versionable.getPath()));
}","/** 
 * Performs a checkin on a versionable tree and returns the tree that represents the created version.
 * @param versionable the versionable node to check in.
 * @return the created version.
 * @throws InvalidItemStateException if the current root has pendingchanges.
 * @throws UnsupportedRepositoryOperationException if the versionable tree isn't actually versionable.
 * @throws RepositoryException       if an error occurs while checking thenode type of the tree.
 */
@Nonnull public Tree checkin(@Nonnull Tree versionable) throws RepositoryException, InvalidItemStateException, UnsupportedRepositoryOperationException {
  if (sessionDelegate.hasPendingChanges()) {
    throw new InvalidItemStateException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (!isVersionable(versionable)) {
    throw new UnsupportedRepositoryOperationException(versionable.getPath() + ""String_Node_Str"");
  }
  if (isCheckedOut(versionable)) {
    Tree baseVersion=getExistingBaseVersion(versionable);
    versionable.setProperty(JCR_ISCHECKEDOUT,Boolean.FALSE,Type.BOOLEAN);
    PropertyState created=baseVersion.getProperty(JCR_CREATED);
    if (created != null) {
      long c=ISO8601.parse(created.getValue(Type.DATE)).getTimeInMillis();
      while (System.currentTimeMillis() == c) {
      }
    }
    try {
      sessionDelegate.commit();
      refresh();
    }
 catch (    CommitFailedException e) {
      sessionDelegate.refresh(true);
      throw e.asRepositoryException();
    }
  }
  return getExistingBaseVersion(getWorkspaceRoot().getTree(versionable.getPath()));
}",0.962796664528544
8847,"/** 
 * Performs a checkout on a versionable tree.
 * @param workspaceRoot a fresh workspace root without pending changes.
 * @param versionablePath the absolute path to the versionable node to check out.
 * @throws UnsupportedRepositoryOperationException if the versionable tree isn't actually versionable.
 * @throws RepositoryException if an error occurs while checking thenode type of the tree.
 * @throws IllegalStateException if the workspaceRoot has pending changes.
 * @throws IllegalArgumentException if the <code>versionablePath</code> isnot absolute.
 */
public void checkout(@Nonnull Root workspaceRoot,@Nonnull String versionablePath) throws UnsupportedRepositoryOperationException, InvalidItemStateException, RepositoryException {
  checkState(!workspaceRoot.hasPendingChanges());
  checkArgument(PathUtils.isAbsolute(versionablePath));
  Tree versionable=workspaceRoot.getTree(versionablePath);
  if (!isVersionable(versionable)) {
    throw new UnsupportedRepositoryOperationException(versionable.getPath() + ""String_Node_Str"");
  }
  if (!isCheckedOut(versionable)) {
    versionable.setProperty(JCR_ISCHECKEDOUT,Boolean.TRUE,Type.BOOLEAN);
    try {
      workspaceRoot.commit();
      refresh();
    }
 catch (    CommitFailedException e) {
      workspaceRoot.refresh();
      throw e.asRepositoryException();
    }
  }
}","/** 
 * Performs a checkout on a versionable tree.
 * @param workspaceRoot a fresh workspace root without pending changes.
 * @param versionablePath the absolute path to the versionable node to check out.
 * @throws UnsupportedRepositoryOperationException if the versionable tree isn't actually versionable.
 * @throws RepositoryException if an error occurs while checking thenode type of the tree.
 * @throws IllegalStateException if the workspaceRoot has pending changes.
 * @throws IllegalArgumentException if the {@code versionablePath} isnot absolute.
 */
public void checkout(@Nonnull Root workspaceRoot,@Nonnull String versionablePath) throws UnsupportedRepositoryOperationException, InvalidItemStateException, RepositoryException {
  checkState(!workspaceRoot.hasPendingChanges());
  checkArgument(PathUtils.isAbsolute(versionablePath));
  Tree versionable=workspaceRoot.getTree(versionablePath);
  if (!isVersionable(versionable)) {
    throw new UnsupportedRepositoryOperationException(versionable.getPath() + ""String_Node_Str"");
  }
  if (!isCheckedOut(versionable)) {
    versionable.setProperty(JCR_ISCHECKEDOUT,Boolean.TRUE,Type.BOOLEAN);
    try {
      workspaceRoot.commit();
      refresh();
    }
 catch (    CommitFailedException e) {
      workspaceRoot.refresh();
      throw e.asRepositoryException();
    }
  }
}",0.9951438177063876
8848,"/** 
 * Checks if the provided directory is a valid FileStore
 * @return true if the provided directory is a valid FileStore
 */
private static boolean isValidFileStore(String path){
  File store=new File(path);
  if (store == null || !store.isDirectory()) {
    return false;
  }
  for (  String f : store.list()) {
    if (""String_Node_Str"".equals(f)) {
      return true;
    }
  }
  return false;
}","/** 
 * Checks if the provided directory is a valid FileStore
 * @return true if the provided directory is a valid FileStore
 */
private static boolean isValidFileStore(String path){
  File store=new File(path);
  if (!store.isDirectory()) {
    return false;
  }
  for (  String f : store.list()) {
    if (""String_Node_Str"".equals(f)) {
      return true;
    }
  }
  return false;
}",0.9783989834815756
8849,"private static void primaryInstance(String[] args) throws Exception {
  final int defaultPort=8023;
  final OptionParser parser=new OptionParser();
  final OptionSpec<Integer> port=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(defaultPort);
  final OptionSpec<Boolean> secure=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Boolean.class);
  final OptionSpec<String> admissible=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(String.class);
  final OptionSpec<?> help=parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").forHelp();
  final OptionSpec<String> nonOption=parser.nonOptions(Mode.PRIMARY + ""String_Node_Str"");
  final OptionSet options=parser.parse(args);
  final List<String> nonOptions=nonOption.values(options);
  if (options.has(help)) {
    parser.printHelpOn(System.out);
    System.exit(0);
  }
  if (nonOptions.isEmpty()) {
    parser.printHelpOn(System.err);
    System.exit(1);
  }
  List<String> admissibleSlaves=options.has(admissible) ? options.valuesOf(admissible) : Collections.EMPTY_LIST;
  FileStore store=null;
  StandbyServer failoverServer=null;
  try {
    store=new FileStore(new File(nonOptions.get(0)),256);
    failoverServer=new StandbyServer(options.has(port) ? options.valueOf(port) : defaultPort,store,admissibleSlaves.toArray(new String[0]),options.has(secure) && options.valueOf(secure));
    failoverServer.startAndWait();
  }
  finally {
    if (store != null) {
      store.close();
    }
    if (failoverServer != null) {
      failoverServer.close();
    }
  }
}","private static void primaryInstance(String[] args) throws Exception {
  final int defaultPort=8023;
  final OptionParser parser=new OptionParser();
  final OptionSpec<Integer> port=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Integer.class).defaultsTo(defaultPort);
  final OptionSpec<Boolean> secure=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(Boolean.class);
  final OptionSpec<String> admissible=parser.accepts(""String_Node_Str"",""String_Node_Str"").withRequiredArg().ofType(String.class);
  final OptionSpec<?> help=parser.acceptsAll(asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").forHelp();
  final OptionSpec<String> nonOption=parser.nonOptions(Mode.PRIMARY + ""String_Node_Str"");
  final OptionSet options=parser.parse(args);
  final List<String> nonOptions=nonOption.values(options);
  if (options.has(help)) {
    parser.printHelpOn(System.out);
    System.exit(0);
  }
  if (nonOptions.isEmpty()) {
    parser.printHelpOn(System.err);
    System.exit(1);
  }
  List<String> admissibleSlaves=options.has(admissible) ? options.valuesOf(admissible) : Collections.EMPTY_LIST;
  FileStore store=null;
  StandbyServer failoverServer=null;
  try {
    store=new FileStore(new File(nonOptions.get(0)),256);
    failoverServer=new StandbyServer(options.has(port) ? options.valueOf(port) : defaultPort,store,admissibleSlaves.toArray(new String[admissibleSlaves.size()]),options.has(secure) && options.valueOf(secure));
    failoverServer.startAndWait();
  }
  finally {
    if (store != null) {
      store.close();
    }
    if (failoverServer != null) {
      failoverServer.close();
    }
  }
}",0.9928656361474436
8850,"/** 
 * Creates a new property mapping map from a list of patterns.
 * @param patterns the patterns
 * @return the mapping map
 */
private static Map<String,String> createMapping(String[] patterns){
  Map<String,String> mapping=new HashMap<String,String>();
  for (  String pattern : patterns) {
    int idx=pattern.indexOf('=');
    if (idx > 0) {
      String relPath=pattern.substring(0,idx).trim();
      String value=pattern.substring(idx + 1).trim();
      mapping.put(relPath,value);
    }
  }
  return mapping;
}","/** 
 * Creates a new property mapping map from a list of patterns.
 * @param patterns the patterns
 * @return the mapping map
 */
private static Map<String,String> createMapping(@Nonnull String[] patterns){
  Map<String,String> mapping=new HashMap<String,String>();
  for (  String pattern : patterns) {
    int idx=pattern.indexOf('=');
    if (idx > 0) {
      String relPath=pattern.substring(0,idx).trim();
      String value=pattern.substring(idx + 1).trim();
      mapping.put(relPath,value);
    }
  }
  return mapping;
}",0.9914204003813156
8851,"/** 
 * Creates a new LDAP provider configuration based on the properties store in the given parameters.
 * @param params the configuration parameters.
 * @return the config
 */
public static DefaultSyncConfig of(ConfigurationParameters params){
  DefaultSyncConfig cfg=new DefaultSyncConfig().setName(params.getConfigValue(PARAM_NAME,PARAM_NAME_DEFAULT));
  cfg.user().setMembershipExpirationTime(ConfigurationParameters.Milliseconds.of(params.getConfigValue(PARAM_USER_MEMBERSHIP_EXPIRATION_TIME,PARAM_USER_MEMBERSHIP_EXPIRATION_TIME_DEFAULT)).value).setMembershipNestingDepth(params.getConfigValue(PARAM_USER_MEMBERSHIP_NESTING_DEPTH,PARAM_USER_MEMBERSHIP_NESTING_DEPTH_DEFAULT)).setExpirationTime(ConfigurationParameters.Milliseconds.of(params.getConfigValue(PARAM_USER_EXPIRATION_TIME,PARAM_USER_EXPIRATION_TIME_DEFAULT)).value).setPathPrefix(params.getConfigValue(PARAM_USER_PATH_PREFIX,PARAM_USER_PATH_PREFIX_DEFAULT)).setAutoMembership(params.getConfigValue(PARAM_USER_AUTO_MEMBERSHIP,PARAM_USER_AUTO_MEMBERSHIP_DEFAULT)).setPropertyMapping(createMapping(params.getConfigValue(PARAM_USER_PROPERTY_MAPPING,PARAM_USER_PROPERTY_MAPPING_DEFAULT)));
  cfg.group().setExpirationTime(ConfigurationParameters.Milliseconds.of(params.getConfigValue(PARAM_GROUP_EXPIRATION_TIME,PARAM_GROUP_EXPIRATION_TIME_DEFAULT)).value).setPathPrefix(params.getConfigValue(PARAM_GROUP_PATH_PREFIX,PARAM_GROUP_PATH_PREFIX_DEFAULT)).setAutoMembership(params.getConfigValue(PARAM_GROUP_AUTO_MEMBERSHIP,PARAM_GROUP_AUTO_MEMBERSHIP_DEFAULT)).setPropertyMapping(createMapping(params.getConfigValue(PARAM_GROUP_PROPERTY_MAPPING,PARAM_GROUP_PROPERTY_MAPPING_DEFAULT)));
  return cfg;
}","/** 
 * Creates a new LDAP provider configuration based on the properties store in the given parameters.
 * @param params the configuration parameters.
 * @return the config
 */
public static DefaultSyncConfig of(ConfigurationParameters params){
  DefaultSyncConfig cfg=new DefaultSyncConfig().setName(params.getConfigValue(PARAM_NAME,PARAM_NAME_DEFAULT));
  cfg.user().setMembershipExpirationTime(getMilliSeconds(params,PARAM_USER_MEMBERSHIP_EXPIRATION_TIME,PARAM_USER_MEMBERSHIP_EXPIRATION_TIME_DEFAULT,ONE_HOUR)).setMembershipNestingDepth(params.getConfigValue(PARAM_USER_MEMBERSHIP_NESTING_DEPTH,PARAM_USER_MEMBERSHIP_NESTING_DEPTH_DEFAULT)).setExpirationTime(getMilliSeconds(params,PARAM_USER_EXPIRATION_TIME,PARAM_USER_EXPIRATION_TIME_DEFAULT,ONE_HOUR)).setPathPrefix(params.getConfigValue(PARAM_USER_PATH_PREFIX,PARAM_USER_PATH_PREFIX_DEFAULT)).setAutoMembership(params.getConfigValue(PARAM_USER_AUTO_MEMBERSHIP,PARAM_USER_AUTO_MEMBERSHIP_DEFAULT)).setPropertyMapping(createMapping(params.getConfigValue(PARAM_USER_PROPERTY_MAPPING,PARAM_USER_PROPERTY_MAPPING_DEFAULT)));
  cfg.group().setExpirationTime(getMilliSeconds(params,PARAM_GROUP_EXPIRATION_TIME,PARAM_GROUP_EXPIRATION_TIME_DEFAULT,ONE_DAY)).setPathPrefix(params.getConfigValue(PARAM_GROUP_PATH_PREFIX,PARAM_GROUP_PATH_PREFIX_DEFAULT)).setAutoMembership(params.getConfigValue(PARAM_GROUP_AUTO_MEMBERSHIP,PARAM_GROUP_AUTO_MEMBERSHIP_DEFAULT)).setPropertyMapping(createMapping(params.getConfigValue(PARAM_GROUP_PROPERTY_MAPPING,PARAM_GROUP_PROPERTY_MAPPING_DEFAULT)));
  return cfg;
}",0.7325436408977556
8852,"@Override public Session run() throws LoginException, RepositoryException {
  if (repository instanceof JackrabbitRepository) {
    return ((JackrabbitRepository)repository).login(null,null,null);
  }
 else {
    return repository.login(null,null);
  }
}","@Override public Session run() throws RepositoryException {
  if (repository instanceof JackrabbitRepository) {
    return ((JackrabbitRepository)repository).login(null,null,null);
  }
 else {
    return repository.login(null,null);
  }
}",0.3130081300813008
8853,"private Delegatee(SyncHandler handler,ExternalIdentityProvider idp) throws SyncException {
  this.handler=handler;
  this.idp=idp;
  try {
    systemSession=Subject.doAs(SystemSubject.INSTANCE,new PrivilegedExceptionAction<Session>(){
      @Override public Session run() throws LoginException, RepositoryException {
        if (repository instanceof JackrabbitRepository) {
          return ((JackrabbitRepository)repository).login(null,null,null);
        }
 else {
          return repository.login(null,null);
        }
      }
    }
);
  }
 catch (  PrivilegedActionException e) {
    throw new SyncException(e);
  }
  try {
    context=handler.createContext(idp,userMgr=((JackrabbitSession)systemSession).getUserManager(),systemSession.getValueFactory());
  }
 catch (  Exception e) {
    systemSession.logout();
    throw new SyncException(e);
  }
  log.info(""String_Node_Str"",systemSession,systemSession.getUserID());
}","private Delegatee(@Nonnull SyncHandler handler,@Nonnull ExternalIdentityProvider idp) throws SyncException {
  this.handler=handler;
  this.idp=idp;
  try {
    systemSession=Subject.doAs(SystemSubject.INSTANCE,new PrivilegedExceptionAction<Session>(){
      @Override public Session run() throws RepositoryException {
        if (repository instanceof JackrabbitRepository) {
          return ((JackrabbitRepository)repository).login(null,null,null);
        }
 else {
          return repository.login(null,null);
        }
      }
    }
);
  }
 catch (  PrivilegedActionException e) {
    throw new SyncException(e);
  }
  try {
    context=handler.createContext(idp,userMgr=((JackrabbitSession)systemSession).getUserManager(),systemSession.getValueFactory());
  }
 catch (  Exception e) {
    systemSession.logout();
    throw new SyncException(e);
  }
  log.info(""String_Node_Str"",systemSession,systemSession.getUserID());
}",0.4816810344827586
8854,"private boolean isMyIDP(SyncedIdentity id){
  String idpName=id.getExternalIdRef() == null ? null : id.getExternalIdRef().getProviderName();
  return (idpName == null || idpName.length() == 0 || idpName.equals(idp.getName()));
}","private boolean isMyIDP(@Nonnull SyncedIdentity id){
  String idpName=id.getExternalIdRef() == null ? null : id.getExternalIdRef().getProviderName();
  return (idpName == null || idpName.isEmpty() || idpName.equals(idp.getName()));
}",0.9327548806941433
8855,"private static boolean importPwdNodeProperty(@Nonnull Tree parent,@Nonnull PropInfo propInfo,@Nonnull PropertyDefinition def) throws RepositoryException {
  String propName=propInfo.getName();
  int targetType=def.getRequiredType();
  if (targetType == PropertyType.UNDEFINED) {
    targetType=(REP_PASSWORD_LAST_MODIFIED.equals(propName)) ? PropertyType.LONG : PropertyType.STRING;
  }
  PropertyState property;
  if (def.isMultiple()) {
    property=PropertyStates.createProperty(propName,propInfo.getValues(targetType));
  }
 else {
    property=PropertyStates.createProperty(propName,propInfo.getValue(targetType));
  }
  parent.setProperty(property);
  return true;
}","private static boolean importPwdNodeProperty(@Nonnull Tree parent,@Nonnull PropInfo propInfo,@Nonnull PropertyDefinition def) throws RepositoryException {
  String propName=propInfo.getName();
  if (propName == null) {
    propName=def.getName();
    if (propName == null || NodeTypeConstants.RESIDUAL_NAME.equals(propName)) {
      return false;
    }
  }
  int targetType=def.getRequiredType();
  if (targetType == PropertyType.UNDEFINED) {
    targetType=(REP_PASSWORD_LAST_MODIFIED.equals(propName)) ? PropertyType.LONG : PropertyType.STRING;
  }
  PropertyState property;
  if (def.isMultiple()) {
    property=PropertyStates.createProperty(propName,propInfo.getValues(targetType));
  }
 else {
    property=PropertyStates.createProperty(propName,propInfo.getValue(targetType));
  }
  parent.setProperty(property);
  return true;
}",0.8912466843501327
8856,"@Override public Node storeAsNode(String absPath) throws RepositoryException {
  manager.ensureIsAlive();
  String oakPath=sessionContext.getOakPathOrThrow(absPath);
  String parent=PathUtils.getParentPath(oakPath);
  NodeDelegate parentDelegate=sessionContext.getSessionDelegate().getNode(parent);
  if (parentDelegate == null) {
    throw new PathNotFoundException(""String_Node_Str"" + parent);
  }
  Node parentNode=NodeImpl.createNodeOrNull(parentDelegate,sessionContext);
  if (!parentNode.isCheckedOut()) {
    throw new VersionException(""String_Node_Str"" + absPath + ""String_Node_Str"");
  }
  String nodeName=PathUtils.getName(oakPath);
  ValueFactory vf=sessionContext.getValueFactory();
  Node n=parentNode.addNode(nodeName,JcrConstants.NT_QUERY);
  n.setProperty(JcrConstants.JCR_STATEMENT,vf.createValue(statement));
  n.setProperty(JcrConstants.JCR_LANGUAGE,vf.createValue(language));
  setStoredQueryPath(oakPath);
  return n;
}","@Override public Node storeAsNode(String absPath) throws RepositoryException {
  manager.ensureIsAlive();
  String oakPath=sessionContext.getOakPathOrThrow(absPath);
  String parent=PathUtils.getParentPath(oakPath);
  NodeDelegate parentDelegate=sessionContext.getSessionDelegate().getNode(parent);
  if (parentDelegate == null) {
    throw new PathNotFoundException(""String_Node_Str"" + parent);
  }
  Node parentNode=NodeImpl.createNode(parentDelegate,sessionContext);
  if (!parentNode.isCheckedOut()) {
    throw new VersionException(""String_Node_Str"" + absPath + ""String_Node_Str"");
  }
  String nodeName=PathUtils.getName(oakPath);
  ValueFactory vf=sessionContext.getValueFactory();
  Node n=parentNode.addNode(nodeName,JcrConstants.NT_QUERY);
  n.setProperty(JcrConstants.JCR_STATEMENT,vf.createValue(statement));
  n.setProperty(JcrConstants.JCR_LANGUAGE,vf.createValue(language));
  setStoredQueryPath(oakPath);
  return n;
}",0.9967982924226254
8857,"@CheckForNull private ItemImpl<?> getItemInternal(@Nonnull String oakPath) throws RepositoryException {
  ItemDelegate item=sd.getItem(oakPath);
  if (item instanceof NodeDelegate) {
    return NodeImpl.createNodeOrNull((NodeDelegate)item,sessionContext);
  }
 else   if (item instanceof PropertyDelegate) {
    return new PropertyImpl((PropertyDelegate)item,sessionContext);
  }
 else {
    return null;
  }
}","@CheckForNull private ItemImpl<?> getItemInternal(@Nonnull String oakPath) throws RepositoryException {
  ItemDelegate item=sd.getItem(oakPath);
  if (item instanceof NodeDelegate) {
    return NodeImpl.createNode((NodeDelegate)item,sessionContext);
  }
 else   if (item instanceof PropertyDelegate) {
    return new PropertyImpl((PropertyDelegate)item,sessionContext);
  }
 else {
    return null;
  }
}",0.9926289926289926
8858,"/** 
 * Converts the given value to a value of the specified target type. The conversion is performed according to the rules described in ""3.6.4 Property Type Conversion"" in the JCR 2.0 specification.
 * @param value the value to convert
 * @param targetType the target property type 
 * @param mapper the name mapper
 * @return the converted value
 * @throws IllegalArgumentException if mapping is illegal
 */
public static PropertyValue convert(@Nonnull PropertyValue value,int targetType,@Nonnull NamePathMapper mapper){
  int sourceType=value.getType().tag();
  if (sourceType == targetType) {
    return value;
  }
switch (targetType) {
case PropertyType.BINARY:
    Blob blob=value.getValue(Type.BINARY);
  return newBinary(blob);
case PropertyType.BOOLEAN:
return newBoolean(value.getValue(Type.BOOLEAN));
case PropertyType.DATE:
return newDate(value.getValue(Type.DATE));
case PropertyType.DOUBLE:
return newDouble(value.getValue(Type.DOUBLE));
case PropertyType.LONG:
return newLong(value.getValue(Type.LONG));
case PropertyType.DECIMAL:
return newDecimal(value.getValue(Type.DECIMAL));
}
String v=value.getValue(Type.STRING);
switch (targetType) {
case PropertyType.STRING:
return newString(v);
case PropertyType.PATH:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.NAME:
return newPath(v);
case PropertyType.URI:
URI uri=URI.create(v);
if (uri.isAbsolute()) {
throw new IllegalArgumentException(""String_Node_Str"" + v + ""String_Node_Str"");
}
String p=uri.getPath();
if (p.startsWith(""String_Node_Str"")) {
p=p.substring(2);
}
return newPath(v);
}
break;
case PropertyType.NAME:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.PATH:
return newName(getOakPath(v,mapper));
case PropertyType.URI:
URI uri=URI.create(v);
if (uri.isAbsolute()) {
throw new IllegalArgumentException(""String_Node_Str"" + v + ""String_Node_Str"");
}
String p=uri.getPath();
if (p.startsWith(""String_Node_Str"")) {
p=p.substring(2);
}
return newName(getOakPath(v,mapper));
}
break;
case PropertyType.REFERENCE:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.WEAKREFERENCE:
return newReference(v);
}
break;
case PropertyType.WEAKREFERENCE:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.REFERENCE:
return newWeakReference(v);
}
break;
case PropertyType.URI:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
return newUri(v);
case PropertyType.NAME:
return newUri(""String_Node_Str"" + v);
case PropertyType.PATH:
return newUri(""String_Node_Str"" + v);
}
}
throw new IllegalArgumentException(""String_Node_Str"" + PropertyType.nameFromValue(sourceType) + ""String_Node_Str""+ PropertyType.nameFromValue(targetType));
}","/** 
 * Converts the given value to a value of the specified target type. The conversion is performed according to the rules described in ""3.6.4 Property Type Conversion"" in the JCR 2.0 specification.
 * @param value the value to convert
 * @param targetType the target property type 
 * @param mapper the name mapper or {@code null} if no name/path mapping is required.
 * @return the converted value
 * @throws IllegalArgumentException if mapping is illegal
 */
public static PropertyValue convert(@Nonnull PropertyValue value,int targetType,@Nullable NamePathMapper mapper){
  int sourceType=value.getType().tag();
  if (sourceType == targetType) {
    return value;
  }
switch (targetType) {
case PropertyType.BINARY:
    Blob blob=value.getValue(Type.BINARY);
  return newBinary(blob);
case PropertyType.BOOLEAN:
return newBoolean(value.getValue(Type.BOOLEAN));
case PropertyType.DATE:
return newDate(value.getValue(Type.DATE));
case PropertyType.DOUBLE:
return newDouble(value.getValue(Type.DOUBLE));
case PropertyType.LONG:
return newLong(value.getValue(Type.LONG));
case PropertyType.DECIMAL:
return newDecimal(value.getValue(Type.DECIMAL));
}
String v=value.getValue(Type.STRING);
switch (targetType) {
case PropertyType.STRING:
return newString(v);
case PropertyType.PATH:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.NAME:
return newPath(v);
case PropertyType.URI:
URI uri=URI.create(v);
if (uri.isAbsolute()) {
throw new IllegalArgumentException(""String_Node_Str"" + v + ""String_Node_Str"");
}
String p=uri.getPath();
if (p.startsWith(""String_Node_Str"")) {
p=p.substring(2);
}
return newPath(v);
}
break;
case PropertyType.NAME:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.PATH:
return newName(getOakPath(v,mapper));
case PropertyType.URI:
URI uri=URI.create(v);
if (uri.isAbsolute()) {
throw new IllegalArgumentException(""String_Node_Str"" + v + ""String_Node_Str"");
}
String p=uri.getPath();
if (p.startsWith(""String_Node_Str"")) {
p=p.substring(2);
}
return newName(getOakPath(v,mapper));
}
break;
case PropertyType.REFERENCE:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.WEAKREFERENCE:
return newReference(v);
}
break;
case PropertyType.WEAKREFERENCE:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
case PropertyType.REFERENCE:
return newWeakReference(v);
}
break;
case PropertyType.URI:
switch (sourceType) {
case PropertyType.BINARY:
case PropertyType.STRING:
return newUri(v);
case PropertyType.NAME:
return newUri(""String_Node_Str"" + v);
case PropertyType.PATH:
return newUri(""String_Node_Str"" + v);
}
}
throw new IllegalArgumentException(""String_Node_Str"" + PropertyType.nameFromValue(sourceType) + ""String_Node_Str""+ PropertyType.nameFromValue(targetType));
}",0.9882895670688432
8859,"/** 
 * Parses a value string into a duration. the String has the following format: <xmp> format:= (value [ unit ])+; value:= float value; unit: ""ms"" | ""s"" | ""m"" | ""h"" | ""d""; </xmp> Example: <xmp> ""100"", ""100ms"" : 100 milliseconds ""1s 50ms"": 1050 milliseconds ""1.5d"":  1 1/2 days == 36 hours. </xmp>
 * @param str the string to parse
 * @return the new Milliseconds object or null.
 */
@CheckForNull public static Milliseconds of(@Nullable String str){
  if (str == null) {
    return null;
  }
  Matcher m=pattern.matcher(str);
  long current=-1;
  while (m.find()) {
    String number=m.group(1);
    String decimal=m.group(2);
    if (decimal != null) {
      number+=decimal;
    }
    String unit=m.group(3);
    double value=Double.valueOf(number);
    if (""String_Node_Str"".equals(unit)) {
      value*=1000.0;
    }
 else     if (""String_Node_Str"".equals(unit)) {
      value*=60 * 1000.0;
    }
 else     if (""String_Node_Str"".equals(unit)) {
      value*=60 * 60 * 1000.0;
    }
 else     if (""String_Node_Str"".equals(unit)) {
      value*=24 * 60 * 60* 1000.0;
    }
    current+=value;
  }
  return current < 0 ? null : new Milliseconds(current + 1);
}","@Nonnull public static Milliseconds of(@Nullable String str,@Nonnull Milliseconds defaultValue){
  if (str == null) {
    return defaultValue;
  }
  Matcher m=pattern.matcher(str);
  long current=-1;
  while (m.find()) {
    String number=m.group(1);
    String decimal=m.group(2);
    if (decimal != null) {
      number+=decimal;
    }
    String unit=m.group(3);
    double value=Double.valueOf(number);
    if (""String_Node_Str"".equals(unit)) {
      value*=1000.0;
    }
 else     if (""String_Node_Str"".equals(unit)) {
      value*=60 * 1000.0;
    }
 else     if (""String_Node_Str"".equals(unit)) {
      value*=60 * 60 * 1000.0;
    }
 else     if (""String_Node_Str"".equals(unit)) {
      value*=24 * 60 * 60* 1000.0;
    }
    current+=value;
  }
  return current < 0 ? defaultValue : new Milliseconds(current + 1);
}",0.7142857142857143
8860,"@Override public boolean hasCapability(String methodName,Object target,Object[] arguments) throws RepositoryException {
  checkNotNull(methodName);
  checkNotNull(target);
  sd.checkAlive();
  if (target instanceof ItemImpl) {
    ItemDelegate dlg=((ItemImpl<?>)target).dlg;
    if (dlg.isProtected()) {
      return false;
    }
    boolean isNode=((ItemImpl<?>)target).isNode();
    Node parent=(isNode) ? (Node)target : ((ItemImpl<?>)target).getParent();
    if (!parent.isCheckedOut()) {
      return false;
    }
    if (parent.isLocked()) {
      return false;
    }
    AccessManager accessMgr=sessionContext.getAccessManager();
    long permission=Permissions.NO_PERMISSION;
    if (isNode) {
      Tree tree=((NodeDelegate)dlg).getTree();
      if (""String_Node_Str"".equals(methodName)) {
        if (arguments != null && arguments.length > 0) {
          String path=PathUtils.concat(tree.getPath(),sessionContext.getOakName(arguments[0].toString()));
          return accessMgr.hasPermissions(path,Session.ACTION_ADD_NODE);
        }
      }
 else       if (""String_Node_Str"".equals(methodName) || ""String_Node_Str"".equals(methodName) || ""String_Node_Str"".equals(methodName)) {
        permission=Permissions.NODE_TYPE_MANAGEMENT;
      }
 else       if (""String_Node_Str"".equals(methodName)) {
        if (tree.isRoot()) {
          return false;
        }
 else {
          permission=Permissions.MODIFY_CHILD_NODE_COLLECTION;
          tree=tree.getParent();
        }
      }
 else       if (""String_Node_Str"".equals(methodName)) {
        permission=Permissions.ADD_PROPERTY;
      }
 else       if (""String_Node_Str"".equals(methodName)) {
        permission=Permissions.REMOVE_NODE;
      }
      return accessMgr.hasPermissions(tree,null,permission);
    }
 else {
      if (""String_Node_Str"".equals(methodName)) {
        permission=Permissions.MODIFY_PROPERTY;
      }
 else       if (""String_Node_Str"".equals(methodName)) {
        permission=Permissions.REMOVE_PROPERTY;
      }
      Tree tree=dlg.getParent().getTree();
      return accessMgr.hasPermissions(tree,((PropertyDelegate)dlg).getPropertyState(),permission);
    }
  }
  return true;
}","@Override public boolean hasCapability(String methodName,Object target,Object[] arguments) throws RepositoryException {
  checkNotNull(methodName);
  checkNotNull(target);
  sd.checkAlive();
  if (target instanceof ItemImpl) {
    ItemDelegate dlg=((ItemImpl<?>)target).dlg;
    if (dlg.isProtected()) {
      return false;
    }
    boolean isNode=((ItemImpl<?>)target).isNode();
    Node parent=(isNode) ? (Node)target : ((ItemImpl<?>)target).getParent();
    if (!parent.isCheckedOut()) {
      return false;
    }
    if (parent.isLocked()) {
      return false;
    }
    AccessManager accessMgr=sessionContext.getAccessManager();
    long permission=Permissions.NO_PERMISSION;
    if (isNode) {
      Tree tree=((NodeDelegate)dlg).getTree();
      if (""String_Node_Str"".equals(methodName)) {
        if (arguments != null && arguments.length > 0) {
          String path=PathUtils.concat(tree.getPath(),sessionContext.getOakName(arguments[0].toString()));
          return accessMgr.hasPermissions(path,Session.ACTION_ADD_NODE);
        }
      }
 else       if (""String_Node_Str"".equals(methodName) || ""String_Node_Str"".equals(methodName) || ""String_Node_Str"".equals(methodName)) {
        permission=Permissions.NODE_TYPE_MANAGEMENT;
      }
 else       if (""String_Node_Str"".equals(methodName)) {
        if (tree.isRoot()) {
          return false;
        }
 else {
          permission=Permissions.MODIFY_CHILD_NODE_COLLECTION;
          tree=tree.getParent();
        }
      }
 else       if (""String_Node_Str"".equals(methodName)) {
        permission=Permissions.ADD_PROPERTY;
      }
 else       if (""String_Node_Str"".equals(methodName)) {
        permission=Permissions.REMOVE_NODE;
      }
      return accessMgr.hasPermissions(tree,null,permission);
    }
 else {
      if (""String_Node_Str"".equals(methodName)) {
        permission=Permissions.MODIFY_PROPERTY;
      }
 else       if (""String_Node_Str"".equals(methodName)) {
        permission=Permissions.REMOVE_PROPERTY;
      }
      NodeDelegate parentDelegate=dlg.getParent();
      if (parentDelegate != null) {
        return accessMgr.hasPermissions(parentDelegate.getTree(),((PropertyDelegate)dlg).getPropertyState(),permission);
      }
 else {
        return accessMgr.hasPermissions(dlg.getPath(),(permission == Permissions.MODIFY_PROPERTY) ? Session.ACTION_SET_PROPERTY : Session.ACTION_REMOVE);
      }
    }
  }
  return true;
}",0.9083369707551288
8861,"@Override @Nonnull public <T extends Document>List<T> query(Collection<T> collection,String fromKey,String toKey,String indexedProperty,long startValue,int limit){
  Lock lock=rwLock.readLock();
  lock.lock();
  try {
    ConcurrentSkipListMap<String,T> map=getMap(collection);
    ConcurrentNavigableMap<String,T> sub=map.subMap(fromKey + ""String_Node_Str"",toKey);
    ArrayList<T> list=new ArrayList<T>();
    for (    T doc : sub.values()) {
      if (indexedProperty != null) {
        Object value=doc.get(indexedProperty);
        if (value instanceof Boolean) {
          long test=(value != null && ((Boolean)value).booleanValue()) ? 1 : 0;
          if (test < startValue) {
            continue;
          }
        }
 else         if (value instanceof Long) {
          if (value == null || ((Long)value < startValue)) {
            continue;
          }
        }
 else         if (value != null) {
          throw new DocumentStoreException(""String_Node_Str"" + indexedProperty + ""String_Node_Str""+ value.getClass());
        }
      }
      list.add(doc);
      if (list.size() >= limit) {
        break;
      }
    }
    return list;
  }
  finally {
    lock.unlock();
  }
}","@Override @Nonnull public <T extends Document>List<T> query(Collection<T> collection,String fromKey,String toKey,String indexedProperty,long startValue,int limit){
  Lock lock=rwLock.readLock();
  lock.lock();
  try {
    ConcurrentSkipListMap<String,T> map=getMap(collection);
    ConcurrentNavigableMap<String,T> sub=map.subMap(fromKey + ""String_Node_Str"",toKey);
    ArrayList<T> list=new ArrayList<T>();
    for (    T doc : sub.values()) {
      if (indexedProperty != null) {
        Object value=doc.get(indexedProperty);
        if (value instanceof Boolean) {
          long test=((Boolean)value) ? 1 : 0;
          if (test < startValue) {
            continue;
          }
        }
 else         if (value instanceof Long) {
          if ((Long)value < startValue) {
            continue;
          }
        }
 else         if (value != null) {
          throw new DocumentStoreException(""String_Node_Str"" + indexedProperty + ""String_Node_Str""+ value.getClass());
        }
      }
      list.add(doc);
      if (list.size() >= limit) {
        break;
      }
    }
    return list;
  }
  finally {
    lock.unlock();
  }
}",0.7612903225806451
8862,"@Override public boolean apply(@Nonnull PropertyState property){
  return getTreePermission().canRead(property) || isNew(property.getName());
}","@Override public boolean apply(@Nullable PropertyState property){
  if (property != null) {
    return getTreePermission().canRead(property) || isNew(property.getName());
  }
 else {
    return false;
  }
}",0.7851002865329513
8863,"@Override public void execute(Runnable command){
  for (  Executor executor : getServices()) {
    executor.execute(command);
    return;
  }
  command.run();
}","@Override public void execute(@Nonnull Runnable command){
  for (  Executor executor : getServices()) {
    executor.execute(command);
    return;
  }
  command.run();
}",0.972644376899696
8864,"/** 
 * Synchronizes an authorizable with the corresponding external identity with the repository based on the respective configuration.
 * @param id the id of the authorizable
 * @return the result of the operation
 * @throws SyncException if an error occurrs
 */
SyncResult sync(@Nonnull String id) throws SyncException ;","/** 
 * Synchronizes an authorizable with the corresponding external identity with the repository based on the respective configuration.
 * @param id the id of the authorizable
 * @return the result of the operation
 * @throws SyncException if an error occurrs
 */
@Nonnull SyncResult sync(@Nonnull String id) throws SyncException ;",0.9862595419847328
8865,"/** 
 * Sets the auto membership
 * @param autoMembership the membership
 * @return {@code this}
 * @see #getAutoMembership()
 */
@Nonnull public Authorizable setAutoMembership(String... autoMembership){
  this.autoMembership=new HashSet<String>();
  for (  String groupName : autoMembership) {
    if (groupName.trim().length() > 0) {
      this.autoMembership.add(groupName.trim());
    }
  }
  return this;
}","/** 
 * Sets the auto membership
 * @param autoMembership the membership
 * @return {@code this}
 * @see #getAutoMembership()
 */
@Nonnull public Authorizable setAutoMembership(String... autoMembership){
  this.autoMembership=new HashSet<String>();
  for (  String groupName : autoMembership) {
    if (!groupName.trim().isEmpty()) {
      this.autoMembership.add(groupName.trim());
    }
  }
  return this;
}",0.973170731707317
8866,"/** 
 * Returns the sync configuration for users.
 * @return the user sync configuration.
 */
public User user(){
  return user;
}","/** 
 * Returns the sync configuration for users.
 * @return the user sync configuration.
 */
@Nonnull public User user(){
  return user;
}",0.966542750929368
8867,"/** 
 * Returns the sync configuration for groups.
 * @return the group sync configuration.
 */
public Group group(){
  return group;
}","/** 
 * Returns the sync configuration for groups.
 * @return the group sync configuration.
 */
@Nonnull public Group group(){
  return group;
}",0.967741935483871
8868,"private SyncResultImpl syncGroup(ExternalGroup external,Group group) throws RepositoryException {
  if (!forceGroupSync && !isExpired(group,config.group().getExpirationTime(),""String_Node_Str"")) {
    SyncedIdentityImpl syncId=createSyncedIdentity(group);
    return new SyncResultImpl(syncId,SyncResult.Status.NOP);
  }
  syncProperties(external,group,config.group().getPropertyMapping());
  applyMembership(group,config.group().getAutoMembership());
  group.setProperty(REP_LAST_SYNCED,nowValue);
  SyncedIdentityImpl syncId=createSyncedIdentity(group);
  return new SyncResultImpl(syncId,SyncResult.Status.UPDATE);
}","@Nonnull private SyncResultImpl syncGroup(@Nonnull ExternalGroup external,@Nonnull Group group) throws RepositoryException {
  if (!forceGroupSync && !isExpired(group,config.group().getExpirationTime(),""String_Node_Str"")) {
    SyncedIdentityImpl syncId=createSyncedIdentity(group);
    return new SyncResultImpl(syncId,SyncResult.Status.NOP);
  }
  syncProperties(external,group,config.group().getPropertyMapping());
  applyMembership(group,config.group().getAutoMembership());
  group.setProperty(REP_LAST_SYNCED,nowValue);
  SyncedIdentityImpl syncId=createSyncedIdentity(group);
  return new SyncResultImpl(syncId,SyncResult.Status.UPDATE);
}",0.9786561264822136
8869,"private SyncResultImpl syncUser(@Nonnull ExternalUser external,@Nonnull User user) throws RepositoryException {
  if (!forceUserSync && !isExpired(user,config.user().getExpirationTime(),""String_Node_Str"")) {
    SyncedIdentityImpl syncId=createSyncedIdentity(user);
    return new SyncResultImpl(syncId,SyncResult.Status.NOP);
  }
  syncProperties(external,user,config.user().getPropertyMapping());
  applyMembership(user,config.user().getAutoMembership());
  if (isExpired(user,config.user().getMembershipExpirationTime(),""String_Node_Str"")) {
    syncMembership(external,user,config.user().getMembershipNestingDepth());
  }
  user.setProperty(REP_LAST_SYNCED,nowValue);
  SyncedIdentityImpl syncId=createSyncedIdentity(user);
  return new SyncResultImpl(syncId,SyncResult.Status.UPDATE);
}","@Nonnull private SyncResultImpl syncUser(@Nonnull ExternalUser external,@Nonnull User user) throws RepositoryException {
  if (!forceUserSync && !isExpired(user,config.user().getExpirationTime(),""String_Node_Str"")) {
    SyncedIdentityImpl syncId=createSyncedIdentity(user);
    return new SyncResultImpl(syncId,SyncResult.Status.NOP);
  }
  syncProperties(external,user,config.user().getPropertyMapping());
  applyMembership(user,config.user().getAutoMembership());
  if (isExpired(user,config.user().getMembershipExpirationTime(),""String_Node_Str"")) {
    syncMembership(external,user,config.user().getMembershipNestingDepth());
  }
  user.setProperty(REP_LAST_SYNCED,nowValue);
  SyncedIdentityImpl syncId=createSyncedIdentity(user);
  return new SyncResultImpl(syncId,SyncResult.Status.UPDATE);
}",0.994343180389692
8870,"/** 
 * Creates a new repository group for the given external one. Note that this method only creates the authorizable but does not perform any synchronization.
 * @param externalGroup the external group
 * @return the repository group
 * @throws RepositoryException if an error occurs
 */
@CheckForNull private Group createGroup(ExternalGroup externalGroup) throws RepositoryException {
  Principal principal=new PrincipalImpl(externalGroup.getPrincipalName());
  Group group=userManager.createGroup(externalGroup.getId(),principal,joinPaths(config.group().getPathPrefix(),externalGroup.getIntermediatePath()));
  group.setProperty(REP_EXTERNAL_ID,valueFactory.createValue(externalGroup.getExternalId().getString()));
  return group;
}","/** 
 * Creates a new repository group for the given external one. Note that this method only creates the authorizable but does not perform any synchronization.
 * @param externalGroup the external group
 * @return the repository group
 * @throws RepositoryException if an error occurs
 */
@Nonnull private Group createGroup(@Nonnull ExternalGroup externalGroup) throws RepositoryException {
  Principal principal=new PrincipalImpl(externalGroup.getPrincipalName());
  Group group=userManager.createGroup(externalGroup.getId(),principal,joinPaths(config.group().getPathPrefix(),externalGroup.getIntermediatePath()));
  group.setProperty(REP_EXTERNAL_ID,valueFactory.createValue(externalGroup.getExternalId().getString()));
  return group;
}",0.986449864498645
8871,"/** 
 * Creates a synced identity from the given authorizable.
 * @param auth the authorizable
 * @return the id
 * @throws RepositoryException if an error occurrs
 */
@CheckForNull private static SyncedIdentityImpl createSyncedIdentity(@Nullable Authorizable auth) throws RepositoryException {
  ExternalIdentityRef ref=auth == null ? null : getIdentityRef(auth);
  if (ref == null) {
    return null;
  }
 else {
    Value[] lmValues=auth.getProperty(REP_LAST_SYNCED);
    long lastModified=-1;
    if (lmValues != null && lmValues.length > 0) {
      lastModified=lmValues[0].getLong();
    }
    return new SyncedIdentityImpl(auth.getID(),ref,auth.isGroup(),lastModified);
  }
}","/** 
 * Creates a synced identity from the given authorizable.
 * @param auth the authorizable
 * @return the id
 * @throws RepositoryException if an error occurs
 */
@CheckForNull private static SyncedIdentityImpl createSyncedIdentity(@Nullable Authorizable auth) throws RepositoryException {
  ExternalIdentityRef ref=(auth == null) ? null : getIdentityRef(auth);
  if (ref == null) {
    return null;
  }
 else {
    Value[] lmValues=auth.getProperty(REP_LAST_SYNCED);
    long lastModified=-1;
    if (lmValues != null && lmValues.length > 0) {
      lastModified=lmValues[0].getLong();
    }
    return new SyncedIdentityImpl(auth.getID(),ref,auth.isGroup(),lastModified);
  }
}",0.9802197802197802
8872,"/** 
 * {@inheritDoc}
 */
@Override public SyncResult sync(@Nonnull String id) throws SyncException {
  try {
    DebugTimer timer=new DebugTimer();
    SyncResultImpl ret;
    Authorizable auth=userManager.getAuthorizable(id);
    if (auth == null) {
      return new SyncResultImpl(new SyncedIdentityImpl(id,null,false,-1),SyncResult.Status.NO_SUCH_AUTHORIZABLE);
    }
    ExternalIdentityRef ref=getIdentityRef(auth);
    if (ref == null || !idp.getName().equals(ref.getProviderName())) {
      return new SyncResultImpl(new SyncedIdentityImpl(id,null,false,-1),SyncResult.Status.FOREIGN);
    }
    if (auth instanceof Group) {
      Group group=(Group)auth;
      ExternalGroup external=idp.getGroup(id);
      timer.mark(""String_Node_Str"");
      if (external == null) {
        SyncedIdentityImpl syncId=createSyncedIdentity(auth);
        if (group.getDeclaredMembers().hasNext()) {
          log.info(""String_Node_Str"",id);
          ret=new SyncResultImpl(syncId,SyncResult.Status.NOP);
        }
 else         if (!keepMissing) {
          auth.remove();
          log.debug(""String_Node_Str"",id,idp.getName());
          timer.mark(""String_Node_Str"");
          ret=new SyncResultImpl(syncId,SyncResult.Status.DELETE);
        }
 else {
          ret=new SyncResultImpl(syncId,SyncResult.Status.MISSING);
          log.info(""String_Node_Str"",id);
        }
      }
 else {
        ret=syncGroup(external,group);
        timer.mark(""String_Node_Str"");
      }
    }
 else {
      ExternalUser external=idp.getUser(id);
      timer.mark(""String_Node_Str"");
      if (external == null) {
        SyncedIdentityImpl syncId=createSyncedIdentity(auth);
        if (!keepMissing) {
          auth.remove();
          log.debug(""String_Node_Str"",id,idp.getName());
          timer.mark(""String_Node_Str"");
          ret=new SyncResultImpl(syncId,SyncResult.Status.DELETE);
        }
 else {
          ret=new SyncResultImpl(syncId,SyncResult.Status.MISSING);
          log.info(""String_Node_Str"",id);
        }
      }
 else {
        ret=syncUser(external,(User)auth);
        timer.mark(""String_Node_Str"");
      }
    }
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",id,ref.getString(),timer.getString());
    }
    return ret;
  }
 catch (  RepositoryException e) {
    throw new SyncException(e);
  }
catch (  ExternalIdentityException e) {
    throw new SyncException(e);
  }
}","/** 
 * {@inheritDoc}
 */
@Nonnull @Override public SyncResult sync(@Nonnull String id) throws SyncException {
  try {
    DebugTimer timer=new DebugTimer();
    SyncResultImpl ret;
    Authorizable auth=userManager.getAuthorizable(id);
    if (auth == null) {
      return new SyncResultImpl(new SyncedIdentityImpl(id,null,false,-1),SyncResult.Status.NO_SUCH_AUTHORIZABLE);
    }
    ExternalIdentityRef ref=getIdentityRef(auth);
    if (ref == null || !idp.getName().equals(ref.getProviderName())) {
      return new SyncResultImpl(new SyncedIdentityImpl(id,null,false,-1),SyncResult.Status.FOREIGN);
    }
    if (auth instanceof Group) {
      Group group=(Group)auth;
      ExternalGroup external=idp.getGroup(id);
      timer.mark(""String_Node_Str"");
      if (external == null) {
        SyncedIdentityImpl syncId=createSyncedIdentity(auth);
        if (group.getDeclaredMembers().hasNext()) {
          log.info(""String_Node_Str"",id);
          ret=new SyncResultImpl(syncId,SyncResult.Status.NOP);
        }
 else         if (!keepMissing) {
          auth.remove();
          log.debug(""String_Node_Str"",id,idp.getName());
          timer.mark(""String_Node_Str"");
          ret=new SyncResultImpl(syncId,SyncResult.Status.DELETE);
        }
 else {
          ret=new SyncResultImpl(syncId,SyncResult.Status.MISSING);
          log.info(""String_Node_Str"",id);
        }
      }
 else {
        ret=syncGroup(external,group);
        timer.mark(""String_Node_Str"");
      }
    }
 else {
      ExternalUser external=idp.getUser(id);
      timer.mark(""String_Node_Str"");
      if (external == null) {
        SyncedIdentityImpl syncId=createSyncedIdentity(auth);
        if (!keepMissing) {
          auth.remove();
          log.debug(""String_Node_Str"",id,idp.getName());
          timer.mark(""String_Node_Str"");
          ret=new SyncResultImpl(syncId,SyncResult.Status.DELETE);
        }
 else {
          ret=new SyncResultImpl(syncId,SyncResult.Status.MISSING);
          log.info(""String_Node_Str"",id);
        }
      }
 else {
        ret=syncUser(external,(User)auth);
        timer.mark(""String_Node_Str"");
      }
    }
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",id,ref.getString(),timer.getString());
    }
    return ret;
  }
 catch (  RepositoryException e) {
    throw new SyncException(e);
  }
catch (  ExternalIdentityException e) {
    throw new SyncException(e);
  }
}",0.998133941530168
8873,"/** 
 * Creates a new repository user for the given external one. Note that this method only creates the authorizable but does not perform any synchronization.
 * @param externalUser the external user
 * @return the repository user
 * @throws RepositoryException if an error occurs
 */
@CheckForNull private User createUser(ExternalUser externalUser) throws RepositoryException {
  Principal principal=new PrincipalImpl(externalUser.getPrincipalName());
  User user=userManager.createUser(externalUser.getId(),null,principal,joinPaths(config.user().getPathPrefix(),externalUser.getIntermediatePath()));
  user.setProperty(REP_EXTERNAL_ID,valueFactory.createValue(externalUser.getExternalId().getString()));
  return user;
}","/** 
 * Creates a new repository user for the given external one. Note that this method only creates the authorizable but does not perform any synchronization.
 * @param externalUser the external user
 * @return the repository user
 * @throws RepositoryException if an error occurs
 */
@Nonnull private User createUser(@Nonnull ExternalUser externalUser) throws RepositoryException {
  Principal principal=new PrincipalImpl(externalUser.getPrincipalName());
  User user=userManager.createUser(externalUser.getId(),null,principal,joinPaths(config.user().getPathPrefix(),externalUser.getIntermediatePath()));
  user.setProperty(REP_EXTERNAL_ID,valueFactory.createValue(externalUser.getExternalId().getString()));
  return user;
}",0.986206896551724
8874,"@Activate private void activate(ComponentContext ctx){
  start(new OsgiWhiteboard(ctx.getBundleContext()));
}","@SuppressWarnings(""String_Node_Str"") @Activate private void activate(ComponentContext ctx){
  start(new OsgiWhiteboard(ctx.getBundleContext()));
}",0.8549019607843137
8875,"@Deactivate private void deactivate(){
  stop();
}","@SuppressWarnings(""String_Node_Str"") @Deactivate private void deactivate(){
  stop();
}",0.7299270072992701
8876,"@Override public void initialize(Subject subject,CallbackHandler callbackHandler,Map<String,?> ss,Map<String,?> opts){
  super.initialize(subject,callbackHandler,ss,opts);
  if (osgiConfig != null) {
    options=ConfigurationParameters.of(osgiConfig,options);
  }
  Whiteboard whiteboard=getWhiteboard();
  if (whiteboard == null) {
    log.error(""String_Node_Str"");
    return;
  }
  String idpName=options.getConfigValue(PARAM_IDP_NAME,""String_Node_Str"");
  if (idpName.length() == 0) {
    log.error(""String_Node_Str"");
  }
 else {
    ExternalIdentityProviderManager idpMgr=WhiteboardUtils.getService(whiteboard,ExternalIdentityProviderManager.class);
    if (idpMgr == null) {
      log.error(""String_Node_Str"");
    }
 else {
      idp=idpMgr.getProvider(idpName);
      if (idp == null) {
        log.error(""String_Node_Str"",idpName);
      }
    }
  }
  String syncHandlerName=options.getConfigValue(PARAM_SYNC_HANDLER_NAME,""String_Node_Str"");
  if (syncHandlerName.length() == 0) {
    log.error(""String_Node_Str"");
  }
 else {
    SyncManager syncMgr=WhiteboardUtils.getService(whiteboard,SyncManager.class);
    if (syncMgr == null) {
      log.error(""String_Node_Str"");
    }
 else {
      syncHandler=syncMgr.getSyncHandler(syncHandlerName);
      if (syncHandler == null) {
        log.error(""String_Node_Str"",syncHandlerName);
      }
    }
  }
}","@Override public void initialize(Subject subject,CallbackHandler callbackHandler,Map<String,?> ss,Map<String,?> opts){
  super.initialize(subject,callbackHandler,ss,opts);
  if (osgiConfig != null) {
    options=ConfigurationParameters.of(osgiConfig,options);
  }
  Whiteboard whiteboard=getWhiteboard();
  if (whiteboard == null) {
    log.error(""String_Node_Str"");
    return;
  }
  String idpName=options.getConfigValue(PARAM_IDP_NAME,""String_Node_Str"");
  if (idpName.isEmpty()) {
    log.error(""String_Node_Str"");
  }
 else {
    ExternalIdentityProviderManager idpMgr=WhiteboardUtils.getService(whiteboard,ExternalIdentityProviderManager.class);
    if (idpMgr == null) {
      log.error(""String_Node_Str"");
    }
 else {
      idp=idpMgr.getProvider(idpName);
      if (idp == null) {
        log.error(""String_Node_Str"",idpName);
      }
    }
  }
  String syncHandlerName=options.getConfigValue(PARAM_SYNC_HANDLER_NAME,""String_Node_Str"");
  if (syncHandlerName.isEmpty()) {
    log.error(""String_Node_Str"");
  }
 else {
    SyncManager syncMgr=WhiteboardUtils.getService(whiteboard,SyncManager.class);
    if (syncMgr == null) {
      log.error(""String_Node_Str"");
    }
 else {
      syncHandler=syncMgr.getSyncHandler(syncHandlerName);
      if (syncHandler == null) {
        log.error(""String_Node_Str"",syncHandlerName);
      }
    }
  }
}",0.9837877671333825
8877,"@Activate private void activate(ComponentContext ctx){
  start(new OsgiWhiteboard(ctx.getBundleContext()));
}","@SuppressWarnings(""String_Node_Str"") @Activate private void activate(ComponentContext ctx){
  start(new OsgiWhiteboard(ctx.getBundleContext()));
}",0.8549019607843137
8878,"@Deactivate private void deactivate(){
  stop();
}","@SuppressWarnings(""String_Node_Str"") @Deactivate private void deactivate(){
  stop();
}",0.7299270072992701
8879,"@Override public ExternalIdentityRef getExternalIdRef(){
  return ref;
}","@CheckForNull @Override public ExternalIdentityRef getExternalIdRef(){
  return ref;
}",0.9113924050632912
8880,"public SyncedIdentityImpl(String id,ExternalIdentityRef ref,boolean isGroup,long lastSynced){
  this.id=id;
  this.ref=ref;
  this.isGroup=isGroup;
  this.lastSynced=lastSynced;
}","public SyncedIdentityImpl(@Nonnull String id,@Nullable ExternalIdentityRef ref,boolean isGroup,long lastSynced){
  this.id=id;
  this.ref=ref;
  this.isGroup=isGroup;
  this.lastSynced=lastSynced;
}",0.9496021220159152
8881,"@Nonnull @Override public Collection<String> getIgnoredProperties(){
  Collection<String> ignoredProperties;
  Iterable<String> ignoredPropertiesValues=getStringValuesFor(Properties.IGNORED_PROPERTIES);
  if (ignoredPropertiesValues != null) {
    ignoredProperties=new LinkedList<String>();
    for (    String ignoredProperty : ignoredPropertiesValues) {
      ignoredProperties.add(ignoredProperty);
    }
  }
 else {
    ignoredProperties=Arrays.asList(SolrServerConfigurationDefaults.IGNORED_PROPERTIES);
  }
  return ignoredProperties;
}","@Nonnull @Override public Collection<String> getIgnoredProperties(){
  Collection<String> ignoredProperties;
  Iterable<String> ignoredPropertiesValues=getStringValuesFor(Properties.IGNORED_PROPERTIES);
  if (ignoredPropertiesValues != null) {
    ignoredProperties=new LinkedList<String>();
    for (    String ignoredProperty : ignoredPropertiesValues) {
      ignoredProperties.add(ignoredProperty);
    }
  }
 else {
    ignoredProperties=SolrServerConfigurationDefaults.IGNORED_PROPERTIES;
  }
  return ignoredProperties;
}",0.9859943977591036
8882,"@Override public IndexRow next(){
  final IndexRow pathRow=pathCursor.next();
  return new IndexRow(){
    @Override public String getPath(){
      return pathRow.getPath();
    }
    @Override public PropertyValue getValue(    String columnName){
      if (QueryImpl.JCR_SCORE.equals(columnName)) {
        return PropertyValues.newDouble(currentRow.score);
      }
      Collection<Object> fieldValues=currentRow.doc.getFieldValues(columnName);
      return currentRow.doc != null ? PropertyValues.newString(Iterables.toString(fieldValues != null ? fieldValues : Collections.emptyList())) : null;
    }
  }
;
}","@Override public IndexRow next(){
  final IndexRow pathRow=pathCursor.next();
  return new IndexRow(){
    @Override public String getPath(){
      return pathRow.getPath();
    }
    @Override public PropertyValue getValue(    String columnName){
      if (QueryImpl.JCR_SCORE.equals(columnName)) {
        return PropertyValues.newDouble(currentRow.score);
      }
      Collection<Object> fieldValues=currentRow.doc.getFieldValues(columnName);
      return PropertyValues.newString(Iterables.toString(fieldValues != null ? fieldValues : Collections.emptyList()));
    }
  }
;
}",0.8808724832214765
8883,"@Override public PropertyValue getValue(String columnName){
  if (QueryImpl.JCR_SCORE.equals(columnName)) {
    return PropertyValues.newDouble(currentRow.score);
  }
  Collection<Object> fieldValues=currentRow.doc.getFieldValues(columnName);
  return currentRow.doc != null ? PropertyValues.newString(Iterables.toString(fieldValues != null ? fieldValues : Collections.emptyList())) : null;
}","@Override public PropertyValue getValue(String columnName){
  if (QueryImpl.JCR_SCORE.equals(columnName)) {
    return PropertyValues.newDouble(currentRow.score);
  }
  Collection<Object> fieldValues=currentRow.doc.getFieldValues(columnName);
  return PropertyValues.newString(Iterables.toString(fieldValues != null ? fieldValues : Collections.emptyList()));
}",0.8138297872340425
8884,"private AbstractIterator<SolrResultRow> getIterator(final Filter filter,final List<OrderEntry> sortOrder,final String parent,final int parentDepth){
  return new AbstractIterator<SolrResultRow>(){
    private final Set<String> seenPaths=Sets.newHashSet();
    private final Deque<SolrResultRow> queue=Queues.newArrayDeque();
    private int offset=0;
    private boolean noDocs=false;
    private long numFound=0;
    @Override protected SolrResultRow computeNext(){
      if (!queue.isEmpty() || loadDocs()) {
        return queue.remove();
      }
      return endOfData();
    }
    private SolrResultRow convertToRow(    SolrDocument doc){
      String path=String.valueOf(doc.getFieldValue(configuration.getPathField()));
      if (path != null) {
        if (""String_Node_Str"".equals(path)) {
          path=""String_Node_Str"";
        }
        if (!parent.isEmpty()) {
          path=getAncestorPath(path,parentDepth);
          if (seenPaths.contains(path)) {
            return null;
          }
          seenPaths.add(path);
        }
        float score=0f;
        Object scoreObj=doc.get(""String_Node_Str"");
        if (scoreObj != null) {
          score=(Float)scoreObj;
        }
        return new SolrResultRow(path,score,doc);
      }
      return null;
    }
    /** 
 * Loads the Solr documents in batches
 * @return true if any document is loaded
 */
    private boolean loadDocs(){
      if (noDocs) {
        return false;
      }
      try {
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"",filter);
        }
        SolrQuery query=FilterQueryParser.getQuery(filter,sortOrder,configuration);
        if (numFound > 0) {
          offset++;
          int newOffset=offset * configuration.getRows();
          if (newOffset >= numFound) {
            return false;
          }
          query.setParam(""String_Node_Str"",String.valueOf(newOffset));
        }
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"",query);
        }
        QueryResponse queryResponse=solrServer.query(query);
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"",queryResponse.getHeader());
        }
        SolrDocumentList docs=queryResponse.getResults();
        if (docs != null) {
          numFound=docs.getNumFound();
          onRetrievedDocs(filter,docs);
          for (          SolrDocument doc : docs) {
            SolrResultRow row=convertToRow(doc);
            if (row != null) {
              queue.add(row);
            }
          }
        }
        SpellCheckResponse spellCheckResponse=queryResponse.getSpellCheckResponse();
        if (spellCheckResponse != null && spellCheckResponse.getSuggestions() != null && spellCheckResponse.getSuggestions().size() > 0) {
          SolrDocument fakeDoc=getSpellChecks(spellCheckResponse,filter);
          queue.add(new SolrResultRow(""String_Node_Str"",1.0,fakeDoc));
          noDocs=true;
        }
        NamedList<Object> response=queryResponse.getResponse();
        Map suggest=(Map)response.get(""String_Node_Str"");
        if (suggest != null) {
          Set<Map.Entry<String,Object>> suggestEntries=suggest.entrySet();
          if (!suggestEntries.isEmpty()) {
            SolrDocument fakeDoc=getSuggestions(suggestEntries,filter);
            queue.add(new SolrResultRow(""String_Node_Str"",1.0,fakeDoc));
            noDocs=true;
          }
        }
      }
 catch (      Exception e) {
        if (log.isWarnEnabled()) {
          log.warn(""String_Node_Str"",solrServer,e);
        }
      }
      return !queue.isEmpty();
    }
  }
;
}","private AbstractIterator<SolrResultRow> getIterator(final Filter filter,final List<OrderEntry> sortOrder,final String parent,final int parentDepth){
  return new AbstractIterator<SolrResultRow>(){
    private final Set<String> seenPaths=Sets.newHashSet();
    private final Deque<SolrResultRow> queue=Queues.newArrayDeque();
    private int offset=0;
    private boolean noDocs=false;
    private long numFound=0;
    @Override protected SolrResultRow computeNext(){
      if (!queue.isEmpty() || loadDocs()) {
        return queue.remove();
      }
      return endOfData();
    }
    private SolrResultRow convertToRow(    SolrDocument doc){
      String path=String.valueOf(doc.getFieldValue(configuration.getPathField()));
      if (""String_Node_Str"".equals(path)) {
        path=""String_Node_Str"";
      }
      if (!parent.isEmpty()) {
        path=getAncestorPath(path,parentDepth);
        if (seenPaths.contains(path)) {
          return null;
        }
        seenPaths.add(path);
      }
      float score=0f;
      Object scoreObj=doc.get(""String_Node_Str"");
      if (scoreObj != null) {
        score=(Float)scoreObj;
      }
      return new SolrResultRow(path,score,doc);
    }
    /** 
 * Loads the Solr documents in batches
 * @return true if any document is loaded
 */
    private boolean loadDocs(){
      if (noDocs) {
        return false;
      }
      try {
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"",filter);
        }
        SolrQuery query=FilterQueryParser.getQuery(filter,sortOrder,configuration);
        if (numFound > 0) {
          offset++;
          int newOffset=offset * configuration.getRows();
          if (newOffset >= numFound) {
            return false;
          }
          query.setParam(""String_Node_Str"",String.valueOf(newOffset));
        }
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"",query);
        }
        QueryResponse queryResponse=solrServer.query(query);
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"",queryResponse.getHeader());
        }
        SolrDocumentList docs=queryResponse.getResults();
        if (docs != null) {
          numFound=docs.getNumFound();
          onRetrievedDocs(filter,docs);
          for (          SolrDocument doc : docs) {
            SolrResultRow row=convertToRow(doc);
            if (row != null) {
              queue.add(row);
            }
          }
        }
        SpellCheckResponse spellCheckResponse=queryResponse.getSpellCheckResponse();
        if (spellCheckResponse != null && spellCheckResponse.getSuggestions() != null && spellCheckResponse.getSuggestions().size() > 0) {
          SolrDocument fakeDoc=getSpellChecks(spellCheckResponse,filter);
          queue.add(new SolrResultRow(""String_Node_Str"",1.0,fakeDoc));
          noDocs=true;
        }
        NamedList<Object> response=queryResponse.getResponse();
        Map suggest=(Map)response.get(""String_Node_Str"");
        if (suggest != null) {
          Set<Map.Entry<String,Object>> suggestEntries=suggest.entrySet();
          if (!suggestEntries.isEmpty()) {
            SolrDocument fakeDoc=getSuggestions(suggestEntries,filter);
            queue.add(new SolrResultRow(""String_Node_Str"",1.0,fakeDoc));
            noDocs=true;
          }
        }
      }
 catch (      Exception e) {
        if (log.isWarnEnabled()) {
          log.warn(""String_Node_Str"",solrServer,e);
        }
      }
      return !queue.isEmpty();
    }
  }
;
}",0.9843463545339164
8885,"private SolrResultRow convertToRow(SolrDocument doc){
  String path=String.valueOf(doc.getFieldValue(configuration.getPathField()));
  if (path != null) {
    if (""String_Node_Str"".equals(path)) {
      path=""String_Node_Str"";
    }
    if (!parent.isEmpty()) {
      path=getAncestorPath(path,parentDepth);
      if (seenPaths.contains(path)) {
        return null;
      }
      seenPaths.add(path);
    }
    float score=0f;
    Object scoreObj=doc.get(""String_Node_Str"");
    if (scoreObj != null) {
      score=(Float)scoreObj;
    }
    return new SolrResultRow(path,score,doc);
  }
  return null;
}","private SolrResultRow convertToRow(SolrDocument doc){
  String path=String.valueOf(doc.getFieldValue(configuration.getPathField()));
  if (""String_Node_Str"".equals(path)) {
    path=""String_Node_Str"";
  }
  if (!parent.isEmpty()) {
    path=getAncestorPath(path,parentDepth);
    if (seenPaths.contains(path)) {
      return null;
    }
    seenPaths.add(path);
  }
  float score=0f;
  Object scoreObj=doc.get(""String_Node_Str"");
  if (scoreObj != null) {
    score=(Float)scoreObj;
  }
  return new SolrResultRow(path,score,doc);
}",0.9129287598944592
8886,"@Override public void close() throws IOException {
  try {
    getSolrServer().shutdown();
  }
 catch (  Exception e) {
  }
  try {
    getIndexingSolrServer().shutdown();
  }
 catch (  Exception e) {
  }
  try {
    getSearchingSolrServer().shutdown();
  }
 catch (  Exception e) {
  }
}","@Override public void close() throws IOException {
  try {
    SolrServer solrServer=getSolrServer();
    if (solrServer != null) {
      solrServer.shutdown();
    }
  }
 catch (  Exception e) {
  }
  try {
    SolrServer indexingSolrServer=getIndexingSolrServer();
    if (indexingSolrServer != null) {
      indexingSolrServer.shutdown();
    }
  }
 catch (  Exception e) {
  }
  try {
    getSearchingSolrServer().shutdown();
  }
 catch (  Exception e) {
  }
}",0.726063829787234
8887,"@Override public void close() throws IOException {
  try {
    if (solrServer != null) {
      solrServer.shutdown();
    }
  }
 catch (  Exception e) {
  }
}","@Override public void close() throws IOException {
  try {
synchronized (this) {
      if (solrServer != null) {
        solrServer.shutdown();
      }
    }
  }
 catch (  Exception e) {
  }
}",0.9028571428571428
8888,"/** 
 * Finds a matching definition for a property with the given name and type.
 * @param property modified property
 * @return matching property definition, or {@code null}
 */
@CheckForNull NodeState getDefinition(PropertyState property){
  String propertyName=property.getName();
  Type<?> propertyType=property.getType();
  String escapedName;
  if (JCR_PRIMARYTYPE.equals(propertyName)) {
    escapedName=NodeTypeConstants.REP_PRIMARY_TYPE;
  }
 else   if (JCR_MIXINTYPES.equals(propertyName)) {
    escapedName=NodeTypeConstants.REP_MIXIN_TYPES;
  }
 else   if (JCR_UUID.equals(propertyName)) {
    escapedName=NodeTypeConstants.REP_UUID;
  }
 else {
    escapedName=propertyName;
  }
  String definedType=propertyType.toString();
  String undefinedType;
  if (propertyType.isArray()) {
    undefinedType=UNDEFINEDS.toString();
  }
 else {
    undefinedType=UNDEFINED.toString();
  }
  for (  NodeState type : types) {
    NodeState definitions=type.getChildNode(REP_NAMED_PROPERTY_DEFINITIONS).getChildNode(escapedName);
    NodeState definition=definitions.getChildNode(definedType);
    if (definition.exists()) {
      return definition;
    }
    definition=definitions.getChildNode(undefinedType);
    if (definition.exists()) {
      return definition;
    }
    for (    ChildNodeEntry entry : definitions.getChildNodeEntries()) {
      definition=entry.getNodeState();
      if (definition.getBoolean(JCR_MANDATORY)) {
        return definition;
      }
    }
  }
  for (  NodeState type : types) {
    NodeState residual=type.getChildNode(REP_RESIDUAL_PROPERTY_DEFINITIONS);
    NodeState definition=residual.getChildNode(definedType);
    if (!definition.exists()) {
      definition=residual.getChildNode(undefinedType);
    }
    if (definition.exists()) {
      return definition;
    }
  }
  return null;
}","/** 
 * Finds a matching definition for a property with the given name and type.
 * @param property modified property
 * @return matching property definition, or {@code null}
 */
@CheckForNull NodeState getDefinition(@Nonnull PropertyState property){
  String propertyName=property.getName();
  Type<?> propertyType=property.getType();
  String escapedName;
  if (JCR_PRIMARYTYPE.equals(propertyName)) {
    escapedName=NodeTypeConstants.REP_PRIMARY_TYPE;
  }
 else   if (JCR_MIXINTYPES.equals(propertyName)) {
    escapedName=NodeTypeConstants.REP_MIXIN_TYPES;
  }
 else   if (JCR_UUID.equals(propertyName)) {
    escapedName=NodeTypeConstants.REP_UUID;
  }
 else {
    escapedName=propertyName;
  }
  String definedType=propertyType.toString();
  String undefinedType;
  if (propertyType.isArray()) {
    undefinedType=UNDEFINEDS.toString();
  }
 else {
    undefinedType=UNDEFINED.toString();
  }
  for (  NodeState type : types) {
    NodeState definitions=type.getChildNode(REP_NAMED_PROPERTY_DEFINITIONS).getChildNode(escapedName);
    NodeState definition=definitions.getChildNode(definedType);
    if (definition.exists()) {
      return definition;
    }
    definition=definitions.getChildNode(undefinedType);
    if (definition.exists()) {
      return definition;
    }
    for (    ChildNodeEntry entry : definitions.getChildNodeEntries()) {
      definition=entry.getNodeState();
      if (definition.getBoolean(JCR_MANDATORY)) {
        return definition;
      }
    }
  }
  for (  NodeState type : types) {
    NodeState residual=type.getChildNode(REP_RESIDUAL_PROPERTY_DEFINITIONS);
    NodeState definition=residual.getChildNode(definedType);
    if (!definition.exists()) {
      definition=residual.getChildNode(undefinedType);
    }
    if (definition.exists()) {
      return definition;
    }
  }
  return null;
}",0.9975443383356072
8889,"boolean isMandatoryChildNode(String name){
  return nameSetContains(REP_MANDATORY_CHILD_NODES,name);
}","boolean isMandatoryChildNode(@Nonnull String name){
  return nameSetContains(REP_MANDATORY_CHILD_NODES,name);
}",0.9577464788732394
8890,"private boolean nameSetContains(String set,String name){
  for (  NodeState type : types) {
    if (contains(type.getNames(set),name)) {
      return true;
    }
  }
  return false;
}","private boolean nameSetContains(@Nonnull String set,@Nonnull String name){
  for (  NodeState type : types) {
    if (contains(type.getNames(set),name)) {
      return true;
    }
  }
  return false;
}",0.953125
8891,"/** 
 * Checks whether this effective type contains the named type.
 * @param name node type name
 * @return {@code true} if the named type is included,{@code false} otherwise
 */
boolean isNodeType(String name){
  for (  NodeState type : types) {
    if (name.equals(type.getName(JCR_NODETYPENAME)) || contains(type.getNames(REP_SUPERTYPES),name)) {
      return true;
    }
  }
  return false;
}","/** 
 * Checks whether this effective type contains the named type.
 * @param name node type name
 * @return {@code true} if the named type is included,{@code false} otherwise
 */
boolean isNodeType(@Nonnull String name){
  for (  NodeState type : types) {
    if (name.equals(type.getName(JCR_NODETYPENAME)) || contains(type.getNames(REP_SUPERTYPES),name)) {
      return true;
    }
  }
  return false;
}",0.9887920298879204
8892,"/** 
 * Finds the default node type for a child node with the given name.
 * @param nameWithIndex child node name, possibly with an SNS index
 * @return default type, or {@code null} if not found
 */
@CheckForNull String getDefaultType(String nameWithIndex){
  String name=dropIndexFromName(nameWithIndex);
  boolean sns=!name.equals(nameWithIndex);
  for (  NodeState type : types) {
    NodeState named=type.getChildNode(REP_NAMED_CHILD_NODE_DEFINITIONS).getChildNode(name);
    NodeState residual=type.getChildNode(REP_RESIDUAL_CHILD_NODE_DEFINITIONS);
    for (    ChildNodeEntry entry : concat(named.getChildNodeEntries(),residual.getChildNodeEntries())) {
      NodeState definition=entry.getNodeState();
      String defaultType=definition.getName(JCR_DEFAULTPRIMARYTYPE);
      if (defaultType != null && snsMatch(sns,definition)) {
        return defaultType;
      }
    }
  }
  return null;
}","/** 
 * Finds the default node type for a child node with the given name.
 * @param nameWithIndex child node name, possibly with an SNS index
 * @return default type, or {@code null} if not found
 */
@CheckForNull String getDefaultType(@Nonnull String nameWithIndex){
  String name=dropIndexFromName(nameWithIndex);
  boolean sns=!name.equals(nameWithIndex);
  for (  NodeState type : types) {
    NodeState named=type.getChildNode(REP_NAMED_CHILD_NODE_DEFINITIONS).getChildNode(name);
    NodeState residual=type.getChildNode(REP_RESIDUAL_CHILD_NODE_DEFINITIONS);
    for (    ChildNodeEntry entry : concat(named.getChildNodeEntries(),residual.getChildNodeEntries())) {
      NodeState definition=entry.getNodeState();
      String defaultType=definition.getName(JCR_DEFAULTPRIMARYTYPE);
      if (defaultType != null && snsMatch(sns,definition)) {
        return defaultType;
      }
    }
  }
  return null;
}",0.9950413223140496
8893,"@Nonnull private Set<String> getNameSet(String set){
  Set<String> names=newHashSet();
  for (  NodeState type : types) {
    addAll(names,type.getNames(set));
  }
  return names;
}","@Nonnull private Set<String> getNameSet(@Nonnull String set){
  Set<String> names=newHashSet();
  for (  NodeState type : types) {
    addAll(names,type.getNames(set));
  }
  return names;
}",0.9757412398921832
8894,"boolean isMandatoryProperty(String name){
  return nameSetContains(REP_MANDATORY_PROPERTIES,name);
}","boolean isMandatoryProperty(@Nonnull String name){
  return nameSetContains(REP_MANDATORY_PROPERTIES,name);
}",0.9569377990430622
8895,"/** 
 * Depending on the given SNS flag, checks whether the given child node definition allows same-name-siblings.
 * @param sns SNS flag, {@code true} if processing an SNS node
 * @param definition child node definition
 */
private boolean snsMatch(boolean sns,NodeState definition){
  return !sns || definition.getBoolean(JCR_SAMENAMESIBLINGS);
}","/** 
 * Depending on the given SNS flag, checks whether the given child node definition allows same-name-siblings.
 * @param sns SNS flag, {@code true} if processing an SNS node
 * @param definition child node definition
 */
private boolean snsMatch(boolean sns,@Nonnull NodeState definition){
  return !sns || definition.getBoolean(JCR_SAMENAMESIBLINGS);
}",0.9872340425531916
8896,"/** 
 * Finds a matching definition for a child node with the given name and types.
 * @param nameWithIndex child node name, possibly with an SNS index
 * @param effective effective types of the child node
 * @return {@code true} if there's a matching child node definition,{@code false} otherwise
 */
boolean isValidChildNode(String nameWithIndex,EffectiveType effective){
  String name=dropIndexFromName(nameWithIndex);
  boolean sns=!name.equals(nameWithIndex);
  Set<String> typeNames=effective.getTypeNames();
  for (  NodeState type : types) {
    NodeState definitions=type.getChildNode(REP_NAMED_CHILD_NODE_DEFINITIONS).getChildNode(name);
    for (    String typeName : typeNames) {
      NodeState definition=definitions.getChildNode(typeName);
      if (definition.exists() && snsMatch(sns,definition)) {
        return true;
      }
    }
    for (    ChildNodeEntry entry : definitions.getChildNodeEntries()) {
      NodeState definition=entry.getNodeState();
      if (definition.getBoolean(JCR_MANDATORY)) {
        return false;
      }
    }
  }
  for (  NodeState type : types) {
    NodeState residual=type.getChildNode(REP_RESIDUAL_CHILD_NODE_DEFINITIONS);
    for (    String typeName : typeNames) {
      NodeState definition=residual.getChildNode(typeName);
      if (definition.exists() && snsMatch(sns,definition)) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Finds a matching definition for a child node with the given name and types.
 * @param nameWithIndex child node name, possibly with an SNS index
 * @param effective effective types of the child node
 * @return {@code true} if there's a matching child node definition,{@code false} otherwise
 */
boolean isValidChildNode(@Nonnull String nameWithIndex,@Nonnull EffectiveType effective){
  String name=dropIndexFromName(nameWithIndex);
  boolean sns=!name.equals(nameWithIndex);
  Set<String> typeNames=effective.getTypeNames();
  for (  NodeState type : types) {
    NodeState definitions=type.getChildNode(REP_NAMED_CHILD_NODE_DEFINITIONS).getChildNode(name);
    for (    String typeName : typeNames) {
      NodeState definition=definitions.getChildNode(typeName);
      if (definition.exists() && snsMatch(sns,definition)) {
        return true;
      }
    }
    for (    ChildNodeEntry entry : definitions.getChildNodeEntries()) {
      NodeState definition=entry.getNodeState();
      if (definition.getBoolean(JCR_MANDATORY)) {
        return false;
      }
    }
  }
  for (  NodeState type : types) {
    NodeState residual=type.getChildNode(REP_RESIDUAL_CHILD_NODE_DEFINITIONS);
    for (    String typeName : typeNames) {
      NodeState definition=residual.getChildNode(typeName);
      if (definition.exists() && snsMatch(sns,definition)) {
        return true;
      }
    }
  }
  return false;
}",0.9936034115138592
8897,"Set<String> getTypeNames(){
  Set<String> names=newHashSet();
  for (  NodeState type : types) {
    names.add(type.getName(JCR_NODETYPENAME));
    addAll(names,type.getNames(REP_SUPERTYPES));
  }
  return names;
}","@Nonnull Set<String> getTypeNames(){
  Set<String> names=newHashSet();
  for (  NodeState type : types) {
    names.add(type.getName(JCR_NODETYPENAME));
    addAll(names,type.getNames(REP_SUPERTYPES));
  }
  return names;
}",0.9794050343249427
8898,"EffectiveType(List<NodeState> types){
  this.types=checkNotNull(types);
}","EffectiveType(@Nonnull List<NodeState> types){
  this.types=checkNotNull(types);
}",0.9419354838709676
8899,"/** 
 * Throws or logs the specified constraint violation.
 * @param code code of this violation
 * @param message description of the violation
 * @throws CommitFailedException the constraint violation
 */
private void constraintViolation(int code,String message) throws CommitFailedException {
  String path=getPath();
  if (effective != null) {
    path=path + ""String_Node_Str"" + effective+ ""String_Node_Str"";
  }
  CommitFailedException exception=new CommitFailedException(CONSTRAINT,code,path + ""String_Node_Str"" + message);
  if (strict) {
    throw exception;
  }
 else {
    log.warn(exception.getMessage());
  }
}","/** 
 * Throws or logs the specified constraint violation.
 * @param code code of this violation
 * @param message description of the violation
 * @throws CommitFailedException the constraint violation
 */
private void constraintViolation(int code,String message) throws CommitFailedException {
  String path=getPath();
  path=path + '[' + getEffective()+ ']';
  CommitFailedException exception=new CommitFailedException(CONSTRAINT,code,path + ""String_Node_Str"" + message);
  if (strict) {
    throw exception;
  }
 else {
    log.warn(exception.getMessage());
  }
}",0.9074074074074074
8900,"private String getPath(){
  if (parent == null) {
    return ""String_Node_Str"";
  }
 else   if (parent.parent == null) {
    return ""String_Node_Str"" + nodeName;
  }
 else {
    return parent.getPath() + ""String_Node_Str"" + nodeName;
  }
}","private String getPath(){
  if (parent == null) {
    return ""String_Node_Str"";
  }
 else   if (parent.parent == null) {
    return '/' + nodeName;
  }
 else {
    return parent.getPath() + '/' + nodeName;
  }
}",0.6755555555555556
8901,"@Override public Editor childNodeAdded(String name,NodeState after) throws CommitFailedException {
  TypeEditor editor=childNodeChanged(name,MISSING_NODE,after);
  if (editor.checkThisNode) {
    for (    String property : editor.effective.getMandatoryProperties()) {
      if (!after.hasProperty(property)) {
        editor.constraintViolation(21,""String_Node_Str"" + property + ""String_Node_Str"");
      }
    }
    for (    String child : editor.effective.getMandatoryChildNodes()) {
      if (!after.hasChildNode(child)) {
        editor.constraintViolation(25,""String_Node_Str"" + child + ""String_Node_Str"");
      }
    }
  }
  return editor;
}","@Override public Editor childNodeAdded(String name,NodeState after) throws CommitFailedException {
  TypeEditor editor=childNodeChanged(name,MISSING_NODE,after);
  if (editor != null && editor.checkThisNode) {
    for (    String property : editor.getEffective().getMandatoryProperties()) {
      if (!after.hasProperty(property)) {
        editor.constraintViolation(21,""String_Node_Str"" + property + ""String_Node_Str"");
      }
    }
    for (    String child : editor.getEffective().getMandatoryChildNodes()) {
      if (!after.hasChildNode(child)) {
        editor.constraintViolation(25,""String_Node_Str"" + child + ""String_Node_Str"");
      }
    }
  }
  return editor;
}",0.9758308157099698
8902,"@Override public TypeEditor childNodeChanged(String name,NodeState before,NodeState after) throws CommitFailedException {
  String primary=after.getName(JCR_PRIMARYTYPE);
  Iterable<String> mixins=after.getNames(JCR_MIXINTYPES);
  NodeBuilder childBuilder=builder.getChildNode(name);
  if (primary == null && effective != null) {
    primary=effective.getDefaultType(name);
    if (primary != null) {
      builder.setProperty(JCR_PRIMARYTYPE,primary,NAME);
    }
 else {
      constraintViolation(4,""String_Node_Str"" + ""String_Node_Str"" + name);
    }
  }
  TypeEditor editor=new TypeEditor(this,name,primary,mixins,childBuilder);
  if (checkThisNode && !effective.isValidChildNode(name,editor.effective)) {
    constraintViolation(1,""String_Node_Str"" + name + ""String_Node_Str""+ editor.effective);
  }
  return editor;
}","@Override public TypeEditor childNodeChanged(String name,NodeState before,NodeState after) throws CommitFailedException {
  String primary=after.getName(JCR_PRIMARYTYPE);
  Iterable<String> mixins=after.getNames(JCR_MIXINTYPES);
  NodeBuilder childBuilder=builder.getChildNode(name);
  if (primary == null && effective != null) {
    primary=effective.getDefaultType(name);
    if (primary != null) {
      builder.setProperty(JCR_PRIMARYTYPE,primary,NAME);
    }
 else {
      constraintViolation(4,""String_Node_Str"" + ""String_Node_Str"" + name);
    }
  }
  TypeEditor editor=new TypeEditor(this,name,primary,mixins,childBuilder);
  if (checkThisNode && !getEffective().isValidChildNode(name,editor.getEffective())) {
    constraintViolation(1,""String_Node_Str"" + name + ""String_Node_Str""+ editor.getEffective());
  }
  return editor;
}",0.9873417721518988
8903,"public String getString(){
  if (timestamps.isEmpty()) {
    return ""String_Node_Str"";
  }
  StringBuilder b=new StringBuilder();
  for (  TimeStamp t : timestamps) {
    if (b.length() > 0) {
      b.append(""String_Node_Str"");
    }
 else {
      b.append(""String_Node_Str"");
    }
    int u=0;
    double time=t.time;
    while (time > 1000 && u < units.length - 1) {
      time=time / 1000;
      u++;
    }
    b.append(String.format(""String_Node_Str"",t.msg,time,units[u]));
  }
  return b.append(')').toString();
}","public String getString(){
  if (timestamps.isEmpty()) {
    return ""String_Node_Str"";
  }
  StringBuilder b=new StringBuilder();
  for (  TimeStamp t : timestamps) {
    if (b.length() > 0) {
      b.append(""String_Node_Str"");
    }
 else {
      b.append('(');
    }
    int u=0;
    double time=t.time;
    while (time > 1000 && u < units.length - 1) {
      time=time / 1000;
      u++;
    }
    b.append(String.format(""String_Node_Str"",t.msg,time,units[u]));
  }
  return b.append(')').toString();
}",0.548828125
8904,"public SyncContext setForceGroupSync(boolean forceGroupSync){
  this.forceGroupSync=forceGroupSync;
  return this;
}","@Nonnull public SyncContext setForceGroupSync(boolean forceGroupSync){
  this.forceGroupSync=forceGroupSync;
  return this;
}",0.9626556016597512
8905,"/** 
 * {@inheritDoc}
 */
@Override public Iterator<SyncedIdentity> listIdentities(@Nonnull UserManager userManager) throws RepositoryException {
  final Iterator<Authorizable> iter=userManager.findAuthorizables(""String_Node_Str"",null);
  return new AbstractLazyIterator<SyncedIdentity>(){
    @Override protected SyncedIdentity getNext(){
      while (iter.hasNext()) {
        try {
          SyncedIdentity id=createSyncedIdentity(iter.next());
          if (id != null) {
            return id;
          }
        }
 catch (        RepositoryException e) {
          log.error(""String_Node_Str"",e);
          break;
        }
      }
      return null;
    }
  }
;
}","/** 
 * {@inheritDoc}
 */
@Nonnull @Override public Iterator<SyncedIdentity> listIdentities(@Nonnull UserManager userManager) throws RepositoryException {
  final Iterator<Authorizable> iter=userManager.findAuthorizables(""String_Node_Str"",null);
  return new AbstractLazyIterator<SyncedIdentity>(){
    @Override protected SyncedIdentity getNext(){
      while (iter.hasNext()) {
        try {
          SyncedIdentity id=createSyncedIdentity(iter.next());
          if (id != null) {
            return id;
          }
        }
 catch (        RepositoryException e) {
          log.error(""String_Node_Str"",e);
          break;
        }
      }
      return null;
    }
  }
;
}",0.993338267949667
8906,"/** 
 * {@inheritDoc}
 */
@Override public SyncContext setKeepMissing(boolean keepMissing){
  this.keepMissing=keepMissing;
  return this;
}","/** 
 * {@inheritDoc}
 */
@Nonnull @Override public SyncContext setKeepMissing(boolean keepMissing){
  this.keepMissing=keepMissing;
  return this;
}",0.9688581314878892
8907,"/** 
 * {@inheritDoc}
 */
@Override public SyncContext setForceUserSync(boolean forceUserSync){
  this.forceUserSync=forceUserSync;
  return this;
}","/** 
 * {@inheritDoc}
 */
@Nonnull @Override public SyncContext setForceUserSync(boolean forceUserSync){
  this.forceUserSync=forceUserSync;
  return this;
}",0.9704918032786886
8908,"@Activate private void activate(Map<String,Object> properties){
  ConfigurationParameters cfg=ConfigurationParameters.of(properties);
  config=DefaultSyncConfig.of(cfg);
}","@SuppressWarnings(""String_Node_Str"") @Activate private void activate(Map<String,Object> properties){
  ConfigurationParameters cfg=ConfigurationParameters.of(properties);
  config=DefaultSyncConfig.of(cfg);
}",0.9023746701846964
8909,"/** 
 * @return An immutable set containing only the {@link SimpleCredentials} class.
 */
@Override protected Set<Class> getSupportedCredentials(){
  Class scClass=SimpleCredentials.class;
  return Collections.singleton(scClass);
}","/** 
 * @return An immutable set containing only the {@link SimpleCredentials} class.
 */
@Nonnull @Override protected Set<Class> getSupportedCredentials(){
  Class scClass=SimpleCredentials.class;
  return Collections.singleton(scClass);
}",0.9808917197452228
8910,"public SyncedIdentityImpl getIdentity(){
  return id;
}","@CheckForNull public SyncedIdentityImpl getIdentity(){
  return id;
}",0.8870967741935484
8911,"public Status getStatus(){
  return status;
}","@Nonnull public Status getStatus(){
  return status;
}",0.9090909090909092
8912,"@Override public Map<String,?> getProperties(){
  return props;
}","@Nonnull @Override public Map<String,?> getProperties(){
  return props;
}",0.935251798561151
8913,"@Override public String getId(){
  return userId;
}","@Nonnull @Override public String getId(){
  return userId;
}",0.918918918918919
8914,"@Override public String getPrincipalName(){
  return userId;
}","@Nonnull @Override public String getPrincipalName(){
  return userId;
}",0.9323308270676692
8915,"@Override public Iterable<ExternalIdentityRef> getDeclaredGroups(){
  return groups;
}","@Nonnull @Override public Iterable<ExternalIdentityRef> getDeclaredGroups(){
  return groups;
}",0.9502762430939228
8916,"@Override public Iterator<ExternalUser> listUsers() throws ExternalIdentityException {
  return externalUsers.values().iterator();
}","@Nonnull @Override public Iterator<ExternalUser> listUsers() throws ExternalIdentityException {
  return externalUsers.values().iterator();
}",0.967032967032967
8917,"@Override public Iterator<ExternalGroup> listGroups() throws ExternalIdentityException {
  return externalGroups.values().iterator();
}","@Nonnull @Override public Iterator<ExternalGroup> listGroups() throws ExternalIdentityException {
  return externalGroups.values().iterator();
}",0.967741935483871
8918,"@Override public Iterator<ExternalUser> listUsers() throws ExternalIdentityException {
  DebugTimer timer=new DebugTimer();
  LdapConnection connection=connect();
  timer.mark(""String_Node_Str"");
  try {
    final List<Entry> entries=getEntries(connection,config.getUserConfig());
    timer.mark(""String_Node_Str"");
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",timer.getString());
    }
    return new AbstractLazyIterator<ExternalUser>(){
      private final Iterator<Entry> iter=entries.iterator();
      @Override protected ExternalUser getNext(){
        while (iter.hasNext()) {
          try {
            return createUser(iter.next(),null);
          }
 catch (          LdapInvalidAttributeValueException e) {
            log.warn(""String_Node_Str"",e);
          }
        }
        return null;
      }
    }
;
  }
 catch (  LdapException e) {
    log.error(""String_Node_Str"" + timer.getString(),e);
    throw new ExternalIdentityException(""String_Node_Str"",e);
  }
catch (  CursorException e) {
    log.error(""String_Node_Str"" + timer.getString(),e);
    throw new ExternalIdentityException(""String_Node_Str"",e);
  }
 finally {
    disconnect(connection);
  }
}","@Nonnull @Override public Iterator<ExternalUser> listUsers() throws ExternalIdentityException {
  DebugTimer timer=new DebugTimer();
  LdapConnection connection=connect();
  timer.mark(""String_Node_Str"");
  try {
    final List<Entry> entries=getEntries(connection,config.getUserConfig());
    timer.mark(""String_Node_Str"");
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",timer.getString());
    }
    return new AbstractLazyIterator<ExternalUser>(){
      private final Iterator<Entry> iter=entries.iterator();
      @Override protected ExternalUser getNext(){
        while (iter.hasNext()) {
          try {
            return createUser(iter.next(),null);
          }
 catch (          LdapInvalidAttributeValueException e) {
            log.warn(""String_Node_Str"",e);
          }
        }
        return null;
      }
    }
;
  }
 catch (  LdapException e) {
    log.error(""String_Node_Str"" + timer.getString(),e);
    throw new ExternalIdentityException(""String_Node_Str"",e);
  }
catch (  CursorException e) {
    log.error(""String_Node_Str"" + timer.getString(),e);
    throw new ExternalIdentityException(""String_Node_Str"",e);
  }
 finally {
    disconnect(connection);
  }
}",0.9962421711899792
8919,"@Override public Iterator<ExternalGroup> listGroups() throws ExternalIdentityException {
  DebugTimer timer=new DebugTimer();
  LdapConnection connection=connect();
  timer.mark(""String_Node_Str"");
  try {
    final List<Entry> entries=getEntries(connection,config.getGroupConfig());
    timer.mark(""String_Node_Str"");
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",timer.getString());
    }
    return new AbstractLazyIterator<ExternalGroup>(){
      private final Iterator<Entry> iter=entries.iterator();
      @Override protected ExternalGroup getNext(){
        while (iter.hasNext()) {
          try {
            return createGroup(iter.next(),null);
          }
 catch (          LdapInvalidAttributeValueException e) {
            log.warn(""String_Node_Str"",e);
          }
        }
        return null;
      }
    }
;
  }
 catch (  LdapException e) {
    log.error(""String_Node_Str"" + timer.getString(),e);
    throw new ExternalIdentityException(""String_Node_Str"",e);
  }
catch (  CursorException e) {
    log.error(""String_Node_Str"" + timer.getString(),e);
    throw new ExternalIdentityException(""String_Node_Str"",e);
  }
 finally {
    disconnect(connection);
  }
}","@Nonnull @Override public Iterator<ExternalGroup> listGroups() throws ExternalIdentityException {
  DebugTimer timer=new DebugTimer();
  LdapConnection connection=connect();
  timer.mark(""String_Node_Str"");
  try {
    final List<Entry> entries=getEntries(connection,config.getGroupConfig());
    timer.mark(""String_Node_Str"");
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"",timer.getString());
    }
    return new AbstractLazyIterator<ExternalGroup>(){
      private final Iterator<Entry> iter=entries.iterator();
      @Override protected ExternalGroup getNext(){
        while (iter.hasNext()) {
          try {
            return createGroup(iter.next(),null);
          }
 catch (          LdapInvalidAttributeValueException e) {
            log.warn(""String_Node_Str"",e);
          }
        }
        return null;
      }
    }
;
  }
 catch (  LdapException e) {
    log.error(""String_Node_Str"" + timer.getString(),e);
    throw new ExternalIdentityException(""String_Node_Str"",e);
  }
catch (  CursorException e) {
    log.error(""String_Node_Str"" + timer.getString(),e);
    throw new ExternalIdentityException(""String_Node_Str"",e);
  }
 finally {
    disconnect(connection);
  }
}",0.9962609056917324
8920,"@Override public RestrictionProvider getRestrictionProvider(){
  return RestrictionProvider.EMPTY;
}","@Nonnull @Override public RestrictionProvider getRestrictionProvider(){
  return RestrictionProvider.EMPTY;
}",0.9569377990430622
8921,"@Override public String getName(){
  return AuthorizationConfiguration.NAME;
}","@Nonnull @Override public String getName(){
  return AuthorizationConfiguration.NAME;
}",0.9454545454545454
8922,"@Nonnull @Override public RepositoryInitializer getRepositoryInitializer(){
  return new RepositoryInitializer(){
    @Override public void initialize(    NodeBuilder builder){
      NodeState base=builder.getNodeState();
      NodeStore store=new MemoryNodeStore(base);
      Root root=RootFactory.createSystemRoot(store,new EditorHook(new CompositeEditorProvider(new NamespaceEditorProvider(),new TypeEditorProvider())),null,null,null,null);
      if (CugUtil.registerCugNodeTypes(root)) {
        NodeState target=store.getRoot();
        target.compareAgainstBaseState(base,new ApplyDiff(builder));
      }
    }
  }
;
}","@Nonnull @Override public RepositoryInitializer getRepositoryInitializer(){
  return new RepositoryInitializer(){
    @Override public void initialize(    @Nonnull NodeBuilder builder){
      NodeState base=builder.getNodeState();
      NodeStore store=new MemoryNodeStore(base);
      Root root=RootFactory.createSystemRoot(store,new EditorHook(new CompositeEditorProvider(new NamespaceEditorProvider(),new TypeEditorProvider())),null,null,null,null);
      if (CugUtil.registerCugNodeTypes(root)) {
        NodeState target=store.getRoot();
        target.compareAgainstBaseState(base,new ApplyDiff(builder));
      }
    }
  }
;
}",0.9928400954653938
8923,"@Override public List<ProtectedItemImporter> getProtectedItemImporters(){
  return Collections.<ProtectedItemImporter>singletonList(new CugImporter());
}","@Nonnull @Override public List<ProtectedItemImporter> getProtectedItemImporters(){
  return Collections.<ProtectedItemImporter>singletonList(new CugImporter());
}",0.9714285714285714
8924,"@Override public AccessControlManager getAccessControlManager(Root root,NamePathMapper namePathMapper){
  return new CugAccessControlManager(root,namePathMapper,getSecurityProvider());
}","@Nonnull @Override public AccessControlManager getAccessControlManager(@Nonnull Root root,@Nonnull NamePathMapper namePathMapper){
  return new CugAccessControlManager(root,namePathMapper,getSecurityProvider());
}",0.9323308270676692
8925,"@Override public PermissionProvider getPermissionProvider(Root root,String workspaceName,Set<Principal> principals){
  ConfigurationParameters params=getParameters();
  boolean enabled=params.getConfigValue(CugConstants.PARAM_CUG_ENABLED,false);
  Set<String> supportedPaths=params.getConfigValue(CugConstants.PARAM_CUG_SUPPORTED_PATHS,Collections.<String>emptySet());
  if (!enabled || supportedPaths.isEmpty() || getExclude().isExcluded(principals)) {
    return EmptyPermissionProvider.getInstance();
  }
 else {
    return new CugPermissionProvider(root,principals,supportedPaths,getContext());
  }
}","@Nonnull @Override public PermissionProvider getPermissionProvider(@Nonnull Root root,@Nonnull String workspaceName,@Nonnull Set<Principal> principals){
  ConfigurationParameters params=getParameters();
  boolean enabled=params.getConfigValue(CugConstants.PARAM_CUG_ENABLED,false);
  Set<String> supportedPaths=params.getConfigValue(CugConstants.PARAM_CUG_SUPPORTED_PATHS,Collections.<String>emptySet());
  if (!enabled || supportedPaths.isEmpty() || getExclude().isExcluded(principals)) {
    return EmptyPermissionProvider.getInstance();
  }
 else {
    return new CugPermissionProvider(root,principals,supportedPaths,getContext());
  }
}",0.9710610932475884
8926,"@Override public void initialize(NodeBuilder builder){
  NodeState base=builder.getNodeState();
  NodeStore store=new MemoryNodeStore(base);
  Root root=RootFactory.createSystemRoot(store,new EditorHook(new CompositeEditorProvider(new NamespaceEditorProvider(),new TypeEditorProvider())),null,null,null,null);
  if (CugUtil.registerCugNodeTypes(root)) {
    NodeState target=store.getRoot();
    target.compareAgainstBaseState(base,new ApplyDiff(builder));
  }
}","@Override public void initialize(@Nonnull NodeBuilder builder){
  NodeState base=builder.getNodeState();
  NodeStore store=new MemoryNodeStore(base);
  Root root=RootFactory.createSystemRoot(store,new EditorHook(new CompositeEditorProvider(new NamespaceEditorProvider(),new TypeEditorProvider())),null,null,null,null);
  if (CugUtil.registerCugNodeTypes(root)) {
    NodeState target=store.getRoot();
    target.compareAgainstBaseState(base,new ApplyDiff(builder));
  }
}",0.990353697749196
8927,"@Override public Context getContext(){
  return CugContext.INSTANCE;
}","@Nonnull @Override public Context getContext(){
  return CugContext.INSTANCE;
}",0.9395973154362416
8928,"@Nonnull @Override public List<? extends ValidatorProvider> getValidators(String workspaceName,Set<Principal> principals,MoveTracker moveTracker){
  return ImmutableList.of(new CugValidatorProvider());
}","@Nonnull @Override public List<? extends ValidatorProvider> getValidators(@Nonnull String workspaceName,@Nonnull Set<Principal> principals,@Nonnull MoveTracker moveTracker){
  return ImmutableList.of(new CugValidatorProvider());
}",0.9376443418013856
8929,"@Override public boolean init(@Nonnull Session session,@Nonnull Root root,@Nonnull NamePathMapper namePathMapper,boolean isWorkspaceImport,int uuidBehavior,@Nonnull ReferenceChangeTracker referenceTracker,SecurityProvider securityProvider){
  if (initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    config=securityProvider.getConfiguration(AuthorizationConfiguration.class).getParameters();
    importBehavior=CugUtil.getImportBehavior(config);
    if (isWorkspaceImport) {
      PrincipalConfiguration pConfig=securityProvider.getConfiguration(PrincipalConfiguration.class);
      principalManager=pConfig.getPrincipalManager(root,namePathMapper);
    }
 else {
      principalManager=((JackrabbitSession)session).getPrincipalManager();
    }
    initialized=true;
  }
 catch (  RepositoryException e) {
    log.warn(""String_Node_Str"",e);
  }
  return initialized;
}","@Override public boolean init(@Nonnull Session session,@Nonnull Root root,@Nonnull NamePathMapper namePathMapper,boolean isWorkspaceImport,int uuidBehavior,@Nonnull ReferenceChangeTracker referenceTracker,@Nonnull SecurityProvider securityProvider){
  if (initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  try {
    config=securityProvider.getConfiguration(AuthorizationConfiguration.class).getParameters();
    importBehavior=CugUtil.getImportBehavior(config);
    if (isWorkspaceImport) {
      PrincipalConfiguration pConfig=securityProvider.getConfiguration(PrincipalConfiguration.class);
      principalManager=pConfig.getPrincipalManager(root,namePathMapper);
    }
 else {
      principalManager=((JackrabbitSession)session).getPrincipalManager();
    }
    initialized=true;
  }
 catch (  RepositoryException e) {
    log.warn(""String_Node_Str"",e);
  }
  return initialized;
}",0.9950358521787092
8930,"@Override public boolean hasPrivileges(Tree tree,String... privilegeNames){
  for (  String privilegeName : privilegeNames) {
    if (!READ_PRIVILEGE_NAMES.contains(privilegeName)) {
      return false;
    }
  }
  return canRead(tree);
}","@Override public boolean hasPrivileges(@Nullable Tree tree,@Nonnull String... privilegeNames){
  if (tree == null) {
    return false;
  }
  for (  String privilegeName : privilegeNames) {
    if (!READ_PRIVILEGE_NAMES.contains(privilegeName)) {
      return false;
    }
  }
  return canRead(tree);
}",0.8831168831168831
8931,"@Override public TreePermission getChildPermission(String childName,NodeState childState){
  return getTreePermission(tree.getChild(childName),this);
}","@Nonnull @Override public TreePermission getChildPermission(@Nonnull String childName,@Nonnull NodeState childState){
  return getTreePermission(tree.getChild(childName),this);
}",0.917933130699088
8932,"@Override public TreePermission getTreePermission(Tree tree,TreePermission parentPermission){
  Tree immutableTree=getImmutableTree(tree);
  if (parentPermission == TreePermission.EMPTY && !immutableTree.isRoot() || isAcContent(immutableTree,true)) {
    return TreePermission.EMPTY;
  }
  TreePermission tp;
  if (parentPermission instanceof CugTreePermission) {
    tp=new CugTreePermission(immutableTree,((CugTreePermission)parentPermission).allow);
    if (hasCug(immutableTree)) {
      tp=createCugPermission(immutableTree,tp);
    }
  }
 else {
    String path=immutableTree.getPath();
    if (supportedPaths.includes(path)) {
      tp=createCugPermission(immutableTree,null);
    }
 else     if (supportedPaths.mayContainCug(path)) {
      tp=new EmptyCugPermission(immutableTree);
    }
 else {
      tp=TreePermission.EMPTY;
    }
  }
  return tp;
}","@Nonnull @Override public TreePermission getTreePermission(@Nonnull Tree tree,@Nonnull TreePermission parentPermission){
  Tree immutableTree=getImmutableTree(tree);
  if (parentPermission == TreePermission.EMPTY && !immutableTree.isRoot() || isAcContent(immutableTree,true)) {
    return TreePermission.EMPTY;
  }
  TreePermission tp;
  if (parentPermission instanceof CugTreePermission) {
    tp=new CugTreePermission(immutableTree,((CugTreePermission)parentPermission).allow);
    if (hasCug(immutableTree)) {
      tp=createCugPermission(immutableTree,tp);
    }
  }
 else {
    String path=immutableTree.getPath();
    if (supportedPaths.includes(path)) {
      tp=createCugPermission(immutableTree,null);
    }
 else     if (supportedPaths.mayContainCug(path)) {
      tp=new EmptyCugPermission(immutableTree);
    }
 else {
      tp=TreePermission.EMPTY;
    }
  }
  return tp;
}",0.9845272206303723
8933,"@Override public Set<String> getPrivileges(Tree tree){
  if (canRead(tree)) {
    return READ_PRIVILEGE_NAMES;
  }
 else {
    return Collections.emptySet();
  }
}","@Nonnull @Override public Set<String> getPrivileges(@Nullable Tree tree){
  if (tree != null && canRead(tree)) {
    return READ_PRIVILEGE_NAMES;
  }
 else {
    return Collections.emptySet();
  }
}",0.9030470914127424
8934,"@Override public RepositoryPermission getRepositoryPermission(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Nonnull @Override public RepositoryPermission getRepositoryPermission(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.9660377358490566
8935,"@Override public String getReference(String blobId){
  checkNotNull(blobId,""String_Node_Str"");
  try {
    Mac mac=Mac.getInstance(ALGORITHM);
    mac.init(new SecretKeySpec(getReferenceKey(),ALGORITHM));
    byte[] hash=mac.doFinal(blobId.getBytes(""String_Node_Str""));
    return blobId + ':' + BaseEncoding.base32Hex().encode(hash);
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalStateException(e);
  }
catch (  InvalidKeyException e) {
    throw new IllegalStateException(e);
  }
catch (  UnsupportedEncodingException e) {
    throw new IllegalStateException(e);
  }
}","@Override public String getReference(@Nonnull String blobId){
  checkNotNull(blobId,""String_Node_Str"");
  try {
    Mac mac=Mac.getInstance(ALGORITHM);
    mac.init(new SecretKeySpec(getReferenceKey(),ALGORITHM));
    byte[] hash=mac.doFinal(blobId.getBytes(""String_Node_Str""));
    return blobId + ':' + BaseEncoding.base32Hex().encode(hash);
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalStateException(e);
  }
catch (  InvalidKeyException e) {
    throw new IllegalStateException(e);
  }
catch (  UnsupportedEncodingException e) {
    throw new IllegalStateException(e);
  }
}",0.9924178601516428
8936,"@Override public String getBlobId(String reference){
  checkNotNull(reference,""String_Node_Str"");
  int colon=reference.indexOf(':');
  if (colon != -1) {
    String blobId=reference.substring(0,colon);
    if (reference.equals(getReference(blobId))) {
      return blobId;
    }
    log.debug(""String_Node_Str"",reference);
  }
  return null;
}","@Override public String getBlobId(@Nonnull String reference){
  checkNotNull(reference,""String_Node_Str"");
  int colon=reference.indexOf(':');
  if (colon != -1) {
    String blobId=reference.substring(0,colon);
    if (reference.equals(getReference(blobId))) {
      return blobId;
    }
    log.debug(""String_Node_Str"",reference);
  }
  return null;
}",0.9870875179340028
8937,"@Override public Thread newThread(Runnable r){
  Thread thread=new Thread(r,createName());
  thread.setDaemon(true);
  thread.setPriority(Thread.MIN_PRIORITY);
  return thread;
}","@Override public Thread newThread(@Nonnull Runnable r){
  Thread thread=new Thread(r,createName());
  thread.setDaemon(true);
  thread.setPriority(Thread.MIN_PRIORITY);
  return thread;
}",0.9753424657534246
8938,"/** 
 * Default   {@code ExecutorService} used for scheduling concurrent tasks.This default spawns as many threads as required with a priority of {@code Thread.MIN_PRIORITY}. Idle threads are pruned after one minute.
 * @return  fresh ExecutorService
 */
public static ExecutorService defaultExecutorService(){
  ThreadPoolExecutor executor=new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue<Runnable>(),new ThreadFactory(){
    private final AtomicInteger counter=new AtomicInteger();
    @Override public Thread newThread(    Runnable r){
      Thread thread=new Thread(r,createName());
      thread.setDaemon(true);
      thread.setPriority(Thread.MIN_PRIORITY);
      return thread;
    }
    private String createName(){
      return ""String_Node_Str"" + counter.getAndIncrement();
    }
  }
);
  executor.setKeepAliveTime(1,TimeUnit.MINUTES);
  executor.allowCoreThreadTimeOut(true);
  return executor;
}","/** 
 * Default   {@code ExecutorService} used for scheduling concurrent tasks.This default spawns as many threads as required with a priority of {@code Thread.MIN_PRIORITY}. Idle threads are pruned after one minute.
 * @return  fresh ExecutorService
 */
public static ExecutorService defaultExecutorService(){
  ThreadPoolExecutor executor=new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue<Runnable>(),new ThreadFactory(){
    private final AtomicInteger counter=new AtomicInteger();
    @Override public Thread newThread(    @Nonnull Runnable r){
      Thread thread=new Thread(r,createName());
      thread.setDaemon(true);
      thread.setPriority(Thread.MIN_PRIORITY);
      return thread;
    }
    private String createName(){
      return ""String_Node_Str"" + counter.getAndIncrement();
    }
  }
);
  executor.setKeepAliveTime(1,TimeUnit.MINUTES);
  executor.allowCoreThreadTimeOut(true);
  return executor;
}",0.9952506596306068
8939,"/** 
 * Default   {@code ScheduledExecutorService} used for scheduling background tasks.This default spawns up to 32 background thread on an as need basis. Idle threads are pruned after one minute.
 * @return  fresh ScheduledExecutorService
 */
public static ScheduledExecutorService defaultScheduledExecutor(){
  ScheduledThreadPoolExecutor executor=new ScheduledThreadPoolExecutor(32,new ThreadFactory(){
    private final AtomicInteger counter=new AtomicInteger();
    @Override public Thread newThread(    Runnable r){
      Thread thread=new Thread(r,createName());
      thread.setDaemon(true);
      return thread;
    }
    private String createName(){
      return ""String_Node_Str"" + counter.getAndIncrement();
    }
  }
);
  executor.setKeepAliveTime(1,TimeUnit.MINUTES);
  executor.allowCoreThreadTimeOut(true);
  return executor;
}","/** 
 * Default   {@code ScheduledExecutorService} used for scheduling background tasks.This default spawns up to 32 background thread on an as need basis. Idle threads are pruned after one minute.
 * @return  fresh ScheduledExecutorService
 */
public static ScheduledExecutorService defaultScheduledExecutor(){
  ScheduledThreadPoolExecutor executor=new ScheduledThreadPoolExecutor(32,new ThreadFactory(){
    private final AtomicInteger counter=new AtomicInteger();
    @Override public Thread newThread(    @Nonnull Runnable r){
      Thread thread=new Thread(r,createName());
      thread.setDaemon(true);
      return thread;
    }
    private String createName(){
      return ""String_Node_Str"" + counter.getAndIncrement();
    }
  }
);
  executor.setKeepAliveTime(1,TimeUnit.MINUTES);
  executor.allowCoreThreadTimeOut(true);
  return executor;
}",0.99469652327637
8940,"@Override public int compareTo(Type<?> that){
  return ComparisonChain.start().compare(tag,that.tag).compareFalseFirst(array,that.array).result();
}","@Override public int compareTo(@Nonnull Type<?> that){
  return ComparisonChain.start().compare(tag,that.tag).compareFalseFirst(array,that.array).result();
}",0.9704918032786886
8941,"static protected void setAuthInfo(@Nonnull AuthInfo authInfo,@Nonnull Subject subject){
  Set<AuthInfo> ais=subject.getPublicCredentials(AuthInfo.class);
  if (!ais.isEmpty()) {
    subject.getPublicCredentials().removeAll(ais);
  }
  subject.getPublicCredentials().add(authInfo);
}","protected static void setAuthInfo(@Nonnull AuthInfo authInfo,@Nonnull Subject subject){
  Set<AuthInfo> ais=subject.getPublicCredentials(AuthInfo.class);
  if (!ais.isEmpty()) {
    subject.getPublicCredentials().removeAll(ais);
  }
  subject.getPublicCredentials().add(authInfo);
}",0.975177304964539
8942,"/** 
 * Returns the next policy.
 * @return next policy.
 * @throws java.util.NoSuchElementException if there is no next policy.
 */
@Override public Principal nextPrincipal() throws NoSuchElementException {
  return (Principal)next();
}","/** 
 * Returns the next policy.
 * @return next policy.
 */
@Override public Principal nextPrincipal(){
  return (Principal)next();
}",0.7223719676549866
8943,"@Nonnull @Override public Restriction createRestriction(@Nullable String oakPath,@Nonnull String oakName,@Nonnull Value... values) throws AccessControlException, RepositoryException {
  return getProvider().createRestriction(oakPath,oakName,values);
}","@Nonnull @Override public Restriction createRestriction(@Nullable String oakPath,@Nonnull String oakName,@Nonnull Value... values) throws RepositoryException {
  return getProvider().createRestriction(oakPath,oakName,values);
}",0.9497907949790796
8944,"@Override public void validateRestrictions(@Nullable String oakPath,@Nonnull Tree aceTree) throws AccessControlException, RepositoryException {
  getProvider().validateRestrictions(oakPath,aceTree);
}","@Override public void validateRestrictions(@Nullable String oakPath,@Nonnull Tree aceTree) throws RepositoryException {
  getProvider().validateRestrictions(oakPath,aceTree);
}",0.9361702127659576
8945,"@Activate protected void activate(ComponentContext componentContext){
  Object value=componentContext.getProperties().get(QUERY_TIME_AGGREGATION);
  boolean queryTimeAggregation=PropertiesUtil.toBoolean(value,QUERY_TIME_AGGREGATION_DEFAULT);
  if (solrServerProvider != null && oakSolrConfigurationProvider != null) {
    QueryIndexProvider solrQueryIndexProvider=new SolrQueryIndexProvider(solrServerProvider,oakSolrConfigurationProvider,nodeAggregator);
    log.debug(""String_Node_Str"",queryTimeAggregation ? ""String_Node_Str"" : ""String_Node_Str"");
    if (queryTimeAggregation) {
      solrQueryIndexProvider=AggregateIndexProvider.wrap(solrQueryIndexProvider);
    }
    regs.add(componentContext.getBundleContext().registerService(QueryIndexProvider.class.getName(),solrQueryIndexProvider,null));
  }
}","@SuppressWarnings(""String_Node_Str"") @Activate protected void activate(ComponentContext componentContext){
  Object value=componentContext.getProperties().get(QUERY_TIME_AGGREGATION);
  boolean queryTimeAggregation=PropertiesUtil.toBoolean(value,QUERY_TIME_AGGREGATION_DEFAULT);
  if (solrServerProvider != null && oakSolrConfigurationProvider != null) {
    QueryIndexProvider solrQueryIndexProvider=new SolrQueryIndexProvider(solrServerProvider,oakSolrConfigurationProvider,nodeAggregator);
    log.debug(""String_Node_Str"",queryTimeAggregation ? ""String_Node_Str"" : ""String_Node_Str"");
    if (queryTimeAggregation) {
      solrQueryIndexProvider=AggregateIndexProvider.wrap(solrQueryIndexProvider);
    }
    regs.add(componentContext.getBundleContext().registerService(QueryIndexProvider.class.getName(),solrQueryIndexProvider,null));
  }
}",0.977589339794064
8946,"@Deactivate protected void deactivate(){
  for (  ServiceRegistration registration : regs) {
    registration.unregister();
  }
}","@SuppressWarnings(""String_Node_Str"") @Deactivate protected void deactivate(){
  for (  ServiceRegistration registration : regs) {
    registration.unregister();
  }
}",0.8745762711864407
8947,"/** 
 * Deletes all the metadata records with the specified prefix.
 * @param prefix the prefix of the record
 */
public void deleteAllMetadataRecords(String prefix);","/** 
 * Deletes all the metadata records with the specified prefix.
 * @param prefix the prefix of the record
 */
void deleteAllMetadataRecords(String prefix);",0.9784615384615384
8948,"/** 
 * Adds a metadata record with the specified name
 * @param input the record input stream
 * @param name the name
 * @throws org.apache.jackrabbit.core.data.DataStoreException
 */
public void addMetadataRecord(final InputStream input,final String name) throws DataStoreException ;","/** 
 * Adds a metadata record with the specified name
 * @param input the record input stream
 * @param name the name
 * @throws org.apache.jackrabbit.core.data.DataStoreException
 */
void addMetadataRecord(final InputStream input,final String name) throws DataStoreException ;",0.9875666074600356
8949,"/** 
 * Gets all the metadata with a specified prefix.
 * @param prefix the prefix of the records to retrieve
 * @return list of all the metadata DataRecords
 */
public List<DataRecord> getAllMetadataRecords(String prefix);","/** 
 * Gets all the metadata with a specified prefix.
 * @param prefix the prefix of the records to retrieve
 * @return list of all the metadata DataRecords
 */
List<DataRecord> getAllMetadataRecords(String prefix);",0.9840546697038725
8950,"/** 
 * Gets the metadata of the specified name.
 * @param name the name of the record
 * @return the metadata DataRecord
 */
public DataRecord getMetadataRecord(String name);","/** 
 * Gets the metadata of the specified name.
 * @param name the name of the record
 * @return the metadata DataRecord
 */
DataRecord getMetadataRecord(String name);",0.979591836734694
8951,"/** 
 * Deletes the metadata record with the specified name
 * @param name the name of the record
 * @return boolean to indicate success of deletion
 */
public boolean deleteMetadataRecord(String name);","/** 
 * Deletes the metadata record with the specified name
 * @param name the name of the record
 * @return boolean to indicate success of deletion
 */
boolean deleteMetadataRecord(String name);",0.982367758186398
8952,"@Deactivate protected void deactivate() throws Exception {
  authorizableActionProvider.stop();
  authorizableNodeName.stop();
  restrictionProvider.stop();
  userAuthenticationFactory.stop();
}","@Deactivate protected void deactivate(){
  authorizableActionProvider.stop();
  authorizableNodeName.stop();
  restrictionProvider.stop();
  userAuthenticationFactory.stop();
}",0.9513513513513514
8953,"@Activate protected void activate(BundleContext context) throws Exception {
  whiteboard=new OsgiWhiteboard(context);
  authorizableActionProvider.start(whiteboard);
  authorizableNodeName.start(whiteboard);
  restrictionProvider.start(whiteboard);
  userAuthenticationFactory.start(whiteboard);
  initializeConfigurations();
}","@Activate protected void activate(BundleContext context){
  whiteboard=new OsgiWhiteboard(context);
  authorizableActionProvider.start(whiteboard);
  authorizableNodeName.start(whiteboard);
  restrictionProvider.start(whiteboard);
  userAuthenticationFactory.start(whiteboard);
  initializeConfigurations();
}",0.9716981132075472
8954,"/** 
 * Create a   {@code LoginContextProvider} using standard{@link javax.security.auth.login.Configuration#getConfiguration() JAAS}functionality. In case no login configuration for the specified app name can be retrieve this implementation uses the default as defined by  {@link ConfigurationUtil#getDefaultConfiguration(org.apache.jackrabbit.oak.spi.security.ConfigurationParameters)}. <p> The   {@link LoginContextProvider} implementation is intended to be used with<ul> <li>Regular login using JAAS  {@link javax.security.auth.spi.LoginModule} or</li><li>Pre-authenticated subjects in which case any authentication related validation is omitted</li> </ul> <h4>Configuration Options</h4> <ul> <li> {@link #PARAM_APP_NAME}: The appName passed to  {@code Configuration#getAppConfigurationEntry(String)}. The default value is   {@link #DEFAULT_APP_NAME}.</li> </ul>
 * @param contentRepository The content repository.
 * @return An new instance of {@link LoginContextProvider}.
 */
@Nonnull @Override public LoginContextProvider getLoginContextProvider(ContentRepository contentRepository){
  String appName=getParameters().getConfigValue(PARAM_APP_NAME,DEFAULT_APP_NAME);
  SecurityProvider provider=getSecurityProvider();
  Whiteboard whiteboard=null;
  if (provider instanceof WhiteboardAware) {
    whiteboard=((WhiteboardAware)provider).getWhiteboard();
  }
 else {
    log.warn(""String_Node_Str"");
  }
  return new LoginContextProviderImpl(appName,getParameters(),contentRepository,getSecurityProvider(),whiteboard);
}","/** 
 * Create a   {@code LoginContextProvider} using standard{@link javax.security.auth.login.Configuration#getConfiguration() JAAS}functionality. In case no login configuration for the specified app name can be retrieve this implementation uses the default as defined by  {@link org.apache.jackrabbit.oak.spi.security.authentication.ConfigurationUtil#getDefaultConfiguration(org.apache.jackrabbit.oak.spi.security.ConfigurationParameters)}. <p> The   {@link LoginContextProvider} implementation is intended to be used with<ul> <li>Regular login using JAAS  {@link javax.security.auth.spi.LoginModule} or</li><li>Pre-authenticated subjects in which case any authentication related validation is omitted</li> </ul> <h4>Configuration Options</h4> <ul> <li> {@link #PARAM_APP_NAME}: The appName passed to  {@code Configuration#getAppConfigurationEntry(String)}. The default value is   {@link #DEFAULT_APP_NAME}.</li> </ul>
 * @param contentRepository The content repository.
 * @return An new instance of {@link LoginContextProvider}.
 */
@Nonnull @Override public LoginContextProvider getLoginContextProvider(ContentRepository contentRepository){
  String appName=getParameters().getConfigValue(PARAM_APP_NAME,DEFAULT_APP_NAME);
  SecurityProvider provider=getSecurityProvider();
  Whiteboard whiteboard=null;
  if (provider instanceof WhiteboardAware) {
    whiteboard=((WhiteboardAware)provider).getWhiteboard();
  }
 else {
    log.warn(""String_Node_Str"");
  }
  return new LoginContextProviderImpl(appName,getParameters(),contentRepository,getSecurityProvider(),whiteboard);
}",0.9826030927835052
8955,"@Nonnull private Configuration getConfiguration(){
  if (configuration == null) {
    Configuration loginConfig=null;
    String configSpiName=params.getConfigValue(PARAM_CONFIG_SPI_NAME,""String_Node_Str"");
    if (!""String_Node_Str"".equals(configSpiName)) {
      try {
        loginConfig=Configuration.getInstance(""String_Node_Str"",null,configSpiName);
        if (loginConfig.getAppConfigurationEntry(appName) == null) {
          log.warn(""String_Node_Str"" + ""String_Node_Str"",appName,configSpiName);
        }
      }
 catch (      NoSuchAlgorithmException e) {
        log.warn(""String_Node_Str"",configSpiName,e);
      }
catch (      NoSuchProviderException e) {
        log.warn(""String_Node_Str"",configSpiName,e);
      }
    }
    if (loginConfig == null) {
      try {
        loginConfig=Configuration.getConfiguration();
        if (loginConfig.getAppConfigurationEntry(appName) == null) {
          loginConfig=null;
        }
      }
 catch (      SecurityException e) {
        log.info(""String_Node_Str"" + e);
      }
    }
    if (loginConfig == null) {
      log.debug(""String_Node_Str"",appName);
      loginConfig=ConfigurationUtil.getDefaultConfiguration(params);
    }
    configuration=loginConfig;
  }
  return configuration;
}","@Nonnull private Configuration getConfiguration(){
  if (configuration == null) {
    Configuration loginConfig=null;
    String configSpiName=params.getConfigValue(PARAM_CONFIG_SPI_NAME,null,String.class);
    if (configSpiName != null) {
      try {
        loginConfig=Configuration.getInstance(""String_Node_Str"",null,configSpiName);
        if (loginConfig.getAppConfigurationEntry(appName) == null) {
          log.warn(""String_Node_Str"" + ""String_Node_Str"",appName,configSpiName);
        }
      }
 catch (      NoSuchAlgorithmException e) {
        log.warn(""String_Node_Str"",configSpiName,e);
      }
catch (      NoSuchProviderException e) {
        log.warn(""String_Node_Str"",configSpiName,e);
      }
    }
    if (loginConfig == null) {
      try {
        loginConfig=Configuration.getConfiguration();
        if (loginConfig.getAppConfigurationEntry(appName) == null) {
          loginConfig=null;
        }
      }
 catch (      SecurityException e) {
        log.info(""String_Node_Str"" + e);
      }
    }
    if (loginConfig == null) {
      log.debug(""String_Node_Str"",appName);
      loginConfig=ConfigurationUtil.getDefaultConfiguration(params);
    }
    configuration=loginConfig;
  }
  return configuration;
}",0.9625754527162976
8956,"@Nonnull @Override public AccessControlManager getAccessControlManager(final @Nonnull Root root,final @Nonnull NamePathMapper namePathMapper){
  List<AuthorizationConfiguration> configurations=getConfigurations();
switch (configurations.size()) {
case 0:
    throw new IllegalStateException();
case 1:
  return configurations.get(0).getAccessControlManager(root,namePathMapper);
default :
List<AccessControlManager> mgrs=Lists.transform(configurations,new Function<AuthorizationConfiguration,AccessControlManager>(){
  @Override public AccessControlManager apply(  AuthorizationConfiguration authorizationConfiguration){
    return authorizationConfiguration.getAccessControlManager(root,namePathMapper);
  }
}
);
return new CompositeAccessControlManager(root,namePathMapper,getSecurityProvider(),mgrs);
}
}","@Nonnull @Override public AccessControlManager getAccessControlManager(@Nonnull final Root root,@Nonnull final NamePathMapper namePathMapper){
  List<AuthorizationConfiguration> configurations=getConfigurations();
switch (configurations.size()) {
case 0:
    throw new IllegalStateException();
case 1:
  return configurations.get(0).getAccessControlManager(root,namePathMapper);
default :
List<AccessControlManager> mgrs=Lists.transform(configurations,new Function<AuthorizationConfiguration,AccessControlManager>(){
  @Override public AccessControlManager apply(  AuthorizationConfiguration authorizationConfiguration){
    return authorizationConfiguration.getAccessControlManager(root,namePathMapper);
  }
}
);
return new CompositeAccessControlManager(root,namePathMapper,getSecurityProvider(),mgrs);
}
}",0.9851301115241636
8957,"@Nonnull @Override public PermissionProvider getPermissionProvider(final @Nonnull Root root,final @Nonnull String workspaceName,final @Nonnull Set<Principal> principals){
  List<AuthorizationConfiguration> configurations=getConfigurations();
switch (configurations.size()) {
case 0:
    throw new IllegalStateException();
case 1:
  return configurations.get(0).getPermissionProvider(root,workspaceName,principals);
default :
List<AggregatedPermissionProvider> aggrPermissionProviders=Lists.newArrayListWithCapacity(configurations.size());
for (AuthorizationConfiguration conf : configurations) {
PermissionProvider pProvider=conf.getPermissionProvider(root,workspaceName,principals);
if (pProvider instanceof AggregatedPermissionProvider) {
  aggrPermissionProviders.add((AggregatedPermissionProvider)pProvider);
}
}
if (aggrPermissionProviders.size() == 1) {
return aggrPermissionProviders.get(0);
}
 else {
return new CompositePermissionProvider(root,aggrPermissionProviders);
}
}
}","@Nonnull @Override public PermissionProvider getPermissionProvider(@Nonnull final Root root,@Nonnull final String workspaceName,@Nonnull final Set<Principal> principals){
  List<AuthorizationConfiguration> configurations=getConfigurations();
switch (configurations.size()) {
case 0:
    throw new IllegalStateException();
case 1:
  return configurations.get(0).getPermissionProvider(root,workspaceName,principals);
default :
List<AggregatedPermissionProvider> aggrPermissionProviders=Lists.newArrayListWithCapacity(configurations.size());
for (AuthorizationConfiguration conf : configurations) {
PermissionProvider pProvider=conf.getPermissionProvider(root,workspaceName,principals);
if (pProvider instanceof AggregatedPermissionProvider) {
  aggrPermissionProviders.add((AggregatedPermissionProvider)pProvider);
}
}
if (aggrPermissionProviders.size() == 1) {
return aggrPermissionProviders.get(0);
}
 else {
return new CompositePermissionProvider(root,aggrPermissionProviders);
}
}
}",0.9817073170731708
8958,"@Override public boolean hasPrivileges(final @Nullable Tree tree,@Nonnull String... privilegeNames){
  for (  final String privName : pbp.getAggregatedPrivilegeNames(privilegeNames)) {
    Iterable<AggregatedPermissionProvider> providers=Iterables.filter(pps,new Predicate<AggregatedPermissionProvider>(){
      @Override public boolean apply(      @Nullable AggregatedPermissionProvider pp){
        return pp != null && ((tree == null) ? pp.handlesRepositoryPermissions() : pp.handles(tree,pbp.getBits(privName)));
      }
    }
);
    for (    AggregatedPermissionProvider pp : providers) {
      if (!pp.hasPrivileges(tree,privName)) {
        return false;
      }
    }
  }
  return true;
}","@Override public boolean hasPrivileges(@Nullable final Tree tree,@Nonnull String... privilegeNames){
  for (  final String privName : pbp.getAggregatedPrivilegeNames(privilegeNames)) {
    Iterable<AggregatedPermissionProvider> providers=Iterables.filter(pps,new Predicate<AggregatedPermissionProvider>(){
      @Override public boolean apply(      @Nullable AggregatedPermissionProvider pp){
        return pp != null && ((tree == null) ? pp.handlesRepositoryPermissions() : pp.handles(tree,pbp.getBits(privName)));
      }
    }
);
    for (    AggregatedPermissionProvider pp : providers) {
      if (!pp.hasPrivileges(tree,privName)) {
        return false;
      }
    }
  }
  return true;
}",0.985632183908046
8959,"@Override public Set<String> getPrivileges(final @Nullable Tree tree){
  PrivilegeBits result=null;
  Iterable<AggregatedPermissionProvider> providers=Iterables.filter(pps,new Predicate<AggregatedPermissionProvider>(){
    @Override public boolean apply(    @Nullable AggregatedPermissionProvider pp){
      return pp != null && ((tree != null) || pp.handlesRepositoryPermissions());
    }
  }
);
  for (  AggregatedPermissionProvider pp : providers) {
    PrivilegeBits privs=pbp.getBits(pp.getPrivileges(tree));
    if (result == null) {
      result=PrivilegeBits.getInstance();
      result.add(privs);
    }
 else {
      result.retain(privs);
    }
  }
  return pbp.getPrivilegeNames(result);
}","@Override public Set<String> getPrivileges(@Nullable final Tree tree){
  PrivilegeBits result=null;
  Iterable<AggregatedPermissionProvider> providers=Iterables.filter(pps,new Predicate<AggregatedPermissionProvider>(){
    @Override public boolean apply(    @Nullable AggregatedPermissionProvider pp){
      return pp != null && ((tree != null) || pp.handlesRepositoryPermissions());
    }
  }
);
  for (  AggregatedPermissionProvider pp : providers) {
    PrivilegeBits privs=pbp.getBits(pp.getPrivileges(tree));
    if (result == null) {
      result=PrivilegeBits.getInstance();
      result.add(privs);
    }
 else {
      result.retain(privs);
    }
  }
  return pbp.getPrivilegeNames(result);
}",0.9914285714285714
8960,"private CompositeTreePermission(final @Nonnull ImmutableTree tree,@Nonnull CompositeTreePermission parentPermission){
  this.tree=tree;
  this.parentPermission=parentPermission;
  map=new LinkedHashMap<AggregatedPermissionProvider,TreePermission>(pps.size());
  for (  AggregatedPermissionProvider provider : pps) {
    TreePermission tp=provider.getTreePermission(tree,getParentPermission(provider));
    map.put(provider,tp);
  }
}","private CompositeTreePermission(@Nonnull final ImmutableTree tree,@Nonnull CompositeTreePermission parentPermission){
  this.tree=tree;
  this.parentPermission=parentPermission;
  map=new LinkedHashMap<AggregatedPermissionProvider,TreePermission>(pps.size());
  for (  AggregatedPermissionProvider provider : pps) {
    TreePermission tp=provider.getTreePermission(tree,getParentPermission(provider));
    map.put(provider,tp);
  }
}",0.9861431870669746
8961,"@Nonnull @Override public RestrictionPattern getPattern(@Nullable String oakPath,@Nonnull Set<Restriction> restrictions){
  if (oakPath == null || restrictions.isEmpty()) {
    return RestrictionPattern.EMPTY;
  }
 else {
    List<RestrictionPattern> patterns=new ArrayList<RestrictionPattern>(3);
    for (    Restriction r : restrictions) {
      String name=r.getDefinition().getName();
      if (REP_GLOB.equals(name)) {
        patterns.add(GlobPattern.create(oakPath,r.getProperty().getValue(Type.STRING)));
      }
 else       if (REP_NT_NAMES.equals(name)) {
        patterns.add(new NodeTypePattern(r.getProperty().getValue(Type.NAMES)));
      }
 else       if (REP_PREFIXES.equals(name)) {
        patterns.add(new PrefixPattern(r.getProperty().getValue(Type.STRINGS)));
      }
 else {
        log.debug(""String_Node_Str"" + name);
      }
    }
    return CompositePattern.create(patterns);
  }
}","@Nonnull @Override public RestrictionPattern getPattern(@Nullable String oakPath,@Nonnull Set<Restriction> restrictions){
  if (oakPath == null || restrictions.isEmpty()) {
    return RestrictionPattern.EMPTY;
  }
 else {
    List<RestrictionPattern> patterns=new ArrayList<RestrictionPattern>(NUMBER_OF_DEFINITIONS);
    for (    Restriction r : restrictions) {
      String name=r.getDefinition().getName();
      if (REP_GLOB.equals(name)) {
        patterns.add(GlobPattern.create(oakPath,r.getProperty().getValue(Type.STRING)));
      }
 else       if (REP_NT_NAMES.equals(name)) {
        patterns.add(new NodeTypePattern(r.getProperty().getValue(Type.NAMES)));
      }
 else       if (REP_PREFIXES.equals(name)) {
        patterns.add(new PrefixPattern(r.getProperty().getValue(Type.STRINGS)));
      }
 else {
        log.debug(""String_Node_Str"" + name);
      }
    }
    return CompositePattern.create(patterns);
  }
}",0.9880174291938998
8962,"@Override public void propertiesCompleted(@Nonnull Tree protectedParent) throws IllegalStateException, ConstraintViolationException, RepositoryException {
  Authorizable a=userManager.getAuthorizable(protectedParent);
  if (a == null) {
    return;
  }
  if (!protectedParent.hasProperty(REP_AUTHORIZABLE_ID)) {
    protectedParent.setProperty(REP_AUTHORIZABLE_ID,a.getID(),Type.STRING);
  }
  if (protectedParent.getStatus() == Tree.Status.NEW) {
    if (a.isGroup()) {
      userManager.onCreate((Group)a);
    }
 else {
      userManager.onCreate((User)a,currentPw);
    }
  }
  currentPw=null;
}","@Override public void propertiesCompleted(@Nonnull Tree protectedParent) throws RepositoryException {
  Authorizable a=userManager.getAuthorizable(protectedParent);
  if (a == null) {
    return;
  }
  if (!protectedParent.hasProperty(REP_AUTHORIZABLE_ID)) {
    protectedParent.setProperty(REP_AUTHORIZABLE_ID,a.getID(),Type.STRING);
  }
  if (protectedParent.getStatus() == Tree.Status.NEW) {
    if (a.isGroup()) {
      userManager.onCreate((Group)a);
    }
 else {
      userManager.onCreate((User)a,currentPw);
    }
  }
  currentPw=null;
}",0.9537117903930132
8963,"@Override public User createSystemUser(String userID,String intermediatePath) throws AuthorizableExistsException, RepositoryException {
  checkValidID(userID);
  Principal principal=new PrincipalImpl(userID);
  checkValidPrincipal(principal,false);
  Tree userTree=userProvider.createSystemUser(userID,intermediatePath);
  setPrincipal(userTree,principal);
  User user=new SystemUserImpl(userID,userTree,this);
  log.debug(""String_Node_Str"" + userID);
  return user;
}","@Override public User createSystemUser(String userID,String intermediatePath) throws RepositoryException {
  checkValidID(userID);
  Principal principal=new PrincipalImpl(userID);
  checkValidPrincipal(principal,false);
  Tree userTree=userProvider.createSystemUser(userID,intermediatePath);
  setPrincipal(userTree,principal);
  User user=new SystemUserImpl(userID,userTree,this);
  log.debug(""String_Node_Str"" + userID);
  return user;
}",0.968026460859978
8964,"@Override public User createSystemUser(String userID,String intermediatePath) throws AuthorizableExistsException, RepositoryException {
  try {
    return wrap(dlg.createUser(userID,intermediatePath));
  }
  finally {
    autosave();
  }
}","@Override public User createSystemUser(String userID,String intermediatePath) throws RepositoryException {
  try {
    return wrap(dlg.createUser(userID,intermediatePath));
  }
  finally {
    autosave();
  }
}",0.935412026726058
8965,"@Override public boolean removeMember(Authorizable authorizable) throws RepositoryException {
  try {
    if (isValid(authorizable)) {
      return getDelegate().removeMember(((AuthorizableImpl)authorizable).dlg);
    }
 else {
      return false;
    }
  }
  finally {
    mgr.autosave();
  }
}","@Override public boolean removeMember(Authorizable authorizable) throws RepositoryException {
  try {
    if (isValid(authorizable)) {
      return getDelegate().removeMember(((AuthorizableImpl)authorizable).getDlg());
    }
 else {
      return false;
    }
  }
  finally {
    getMgr().autosave();
  }
}",0.9633333333333334
8966,"@Override public boolean addMember(Authorizable authorizable) throws RepositoryException {
  try {
    if (isValid(authorizable)) {
      return getDelegate().addMember(((AuthorizableImpl)authorizable).dlg);
    }
 else {
      return false;
    }
  }
  finally {
    mgr.autosave();
  }
}","@Override public boolean addMember(Authorizable authorizable) throws RepositoryException {
  try {
    if (isValid(authorizable)) {
      return getDelegate().addMember(((AuthorizableImpl)authorizable).getDlg());
    }
 else {
      return false;
    }
  }
  finally {
    getMgr().autosave();
  }
}",0.9625850340136054
8967,"@Override public Iterator<Authorizable> getDeclaredMembers() throws RepositoryException {
  return AuthorizableWrapper.createIterator(getDelegate().getDeclaredMembers(),mgr);
}","@Override public Iterator<Authorizable> getDeclaredMembers() throws RepositoryException {
  return AuthorizableWrapper.createIterator(getDelegate().getDeclaredMembers(),getMgr());
}",0.9803921568627452
8968,"@Override public boolean isDeclaredMember(Authorizable authorizable) throws RepositoryException {
  if (isValid(authorizable)) {
    return getDelegate().isDeclaredMember(((AuthorizableImpl)authorizable).dlg);
  }
 else {
    return false;
  }
}","@Override public boolean isDeclaredMember(Authorizable authorizable) throws RepositoryException {
  if (isValid(authorizable)) {
    return getDelegate().isDeclaredMember(((AuthorizableImpl)authorizable).getDlg());
  }
 else {
    return false;
  }
}",0.9777777777777776
8969,"private Group getDelegate(){
  return (Group)dlg;
}","Group getDelegate(){
  return (Group)getDlg();
}",0.8484848484848485
8970,"@Override public boolean isMember(Authorizable authorizable) throws RepositoryException {
  if (isValid(authorizable)) {
    return getDelegate().isMember(((AuthorizableImpl)authorizable).dlg);
  }
 else {
    return false;
  }
}","@Override public boolean isMember(Authorizable authorizable) throws RepositoryException {
  if (isValid(authorizable)) {
    return getDelegate().isMember(((AuthorizableImpl)authorizable).getDlg());
  }
 else {
    return false;
  }
}",0.976241900647948
8971,"@Override public Iterator<Authorizable> getMembers() throws RepositoryException {
  return AuthorizableWrapper.createIterator(getDelegate().getMembers(),mgr);
}","@Override public Iterator<Authorizable> getMembers() throws RepositoryException {
  return AuthorizableWrapper.createIterator(getDelegate().getMembers(),getMgr());
}",0.9784615384615384
8972,"@Override public boolean grantImpersonation(Principal principal) throws RepositoryException {
  try {
    return dlg.grantImpersonation(principal);
  }
  finally {
    mgr.autosave();
  }
}","@Override public boolean grantImpersonation(Principal principal) throws RepositoryException {
  try {
    return dlg.grantImpersonation(principal);
  }
  finally {
    getMgr().autosave();
  }
}",0.9817232375979112
8973,"private User getDelegate(){
  return (User)dlg;
}","private User getDelegate(){
  return (User)getDlg();
}",0.9320388349514565
8974,"@Override public void changePassword(String pw,String oldPw) throws RepositoryException {
  try {
    getDelegate().changePassword(pw,oldPw);
  }
  finally {
    mgr.autosave();
  }
}","@Override public void changePassword(String pw,String oldPw) throws RepositoryException {
  try {
    getDelegate().changePassword(pw,oldPw);
  }
  finally {
    getMgr().autosave();
  }
}",0.981132075471698
8975,"@Override public void disable(String msg) throws RepositoryException {
  try {
    getDelegate().disable(msg);
  }
  finally {
    mgr.autosave();
  }
}","@Override public void disable(String msg) throws RepositoryException {
  try {
    getDelegate().disable(msg);
  }
  finally {
    getMgr().autosave();
  }
}",0.9773462783171522
8976,"@Override public boolean revokeImpersonation(Principal principal) throws RepositoryException {
  try {
    return dlg.revokeImpersonation(principal);
  }
  finally {
    mgr.autosave();
  }
}","@Override public boolean revokeImpersonation(Principal principal) throws RepositoryException {
  try {
    return dlg.revokeImpersonation(principal);
  }
  finally {
    getMgr().autosave();
  }
}",0.9819121447028424
8977,"@Nonnull private String buildXPathStatement(@Nonnull String relPath,@Nullable String value,@Nonnull AuthorizableType type,boolean exact){
  StringBuilder stmt=new StringBuilder();
  String searchRoot=namePathMapper.getJcrPath(QueryUtil.getSearchRoot(type,config));
  if (!""String_Node_Str"".equals(searchRoot)) {
    stmt.append(searchRoot);
  }
  String propName;
  String path;
  String ntName;
  if (relPath.indexOf('/') == -1) {
    propName=relPath;
    path=null;
    ntName=null;
  }
 else {
    propName=Text.getName(relPath);
    String[] segments=Text.explode(relPath,'/',false);
    StringBuilder sb=new StringBuilder();
    for (int i=0; i < segments.length - 1; i++) {
      if (!PathUtils.denotesCurrent(segments[i])) {
        if (i > 0) {
          sb.append('/');
        }
        sb.append(segments[i]);
      }
    }
    path=Strings.emptyToNull(sb.toString());
    ntName=namePathMapper.getJcrName(QueryUtil.getNodeTypeName(type));
  }
  stmt.append(""String_Node_Str"");
  if (path != null) {
    stmt.append(path);
  }
 else   if (ntName != null) {
    stmt.append(""String_Node_Str"").append(ntName).append(')');
  }
 else {
    stmt.append(""String_Node_Str"");
  }
  if (value == null) {
    stmt.append(""String_Node_Str"").append(propName).append(']');
  }
 else {
    stmt.append('[');
    stmt.append((exact) ? ""String_Node_Str"" : ""String_Node_Str"");
    stmt.append(ISO9075.encode(propName));
    if (exact) {
      stmt.append(""String_Node_Str"");
      stmt.append(value.replaceAll(""String_Node_Str"",""String_Node_Str""));
      stmt.append('\'');
    }
 else {
      stmt.append(""String_Node_Str"");
      stmt.append(QueryUtil.escapeForQuery(value));
      stmt.append(""String_Node_Str"");
    }
    stmt.append(']');
  }
  return stmt.toString();
}","@Nonnull private String buildXPathStatement(@Nonnull XPathQueryBuilder builder) throws RepositoryException {
  Condition condition=builder.getCondition();
  String sortCol=builder.getSortProperty();
  QueryBuilder.Direction sortDir=builder.getSortDirection();
  Value bound=builder.getBound();
  if (bound != null) {
    if (sortCol == null) {
      log.warn(""String_Node_Str"");
    }
 else {
      Condition boundCondition=builder.property(sortCol,QueryUtil.getCollation(sortDir),bound);
      if (condition == null) {
        condition=boundCondition;
      }
 else {
        condition=builder.and(condition,boundCondition);
      }
    }
  }
  StringBuilder statement=new StringBuilder();
  ConditionVisitor visitor=new XPathConditionVisitor(statement,namePathMapper,userManager);
  String searchRoot=namePathMapper.getJcrPath(QueryUtil.getSearchRoot(builder.getSelectorType(),config));
  String ntName=namePathMapper.getJcrName(QueryUtil.getNodeTypeName(builder.getSelectorType()));
  statement.append(searchRoot).append(""String_Node_Str"").append(ntName).append(')');
  if (condition != null) {
    statement.append('[');
    condition.accept(visitor);
    statement.append(']');
  }
  if (sortCol != null) {
    boolean ignoreCase=builder.getSortIgnoreCase();
    statement.append(""String_Node_Str"");
    if (ignoreCase) {
      statement.append(""String_Node_Str"").append(sortCol).append(')');
    }
 else {
      statement.append(sortCol);
    }
    statement.append(' ').append(sortDir.getDirection());
  }
  return statement.toString();
}",0.120627261761158
8978,"/** 
 * Constructor for non-OSGi cases.
 * @param config the configuration
 */
public LdapIdentityProvider(LdapProviderConfig config){
  this.config=config;
  init();
}","/** 
 * Constructor for non-OSGi cases.
 * @param config the configuration
 */
public LdapIdentityProvider(@Nonnull LdapProviderConfig config){
  this.config=config;
  init();
}",0.9739130434782608
8979,"/** 
 * Initializes the ldap identity provider.
 */
private void init(){
  if (adminConnectionFactory != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  LdapConnectionConfig cc=createConnectionConfig();
  if (!config.getBindDN().isEmpty()) {
    cc.setName(config.getBindDN());
    cc.setCredentials(config.getBindPassword());
  }
  adminConnectionFactory=new PoolableLdapConnectionFactory(cc);
  if (config.getAdminPoolConfig().getMaxActive() != 0) {
    adminPool=new LdapConnectionPool(adminConnectionFactory);
    adminPool.setTestOnBorrow(true);
    adminPool.setMaxActive(config.getAdminPoolConfig().getMaxActive());
    adminPool.setWhenExhaustedAction(GenericObjectPool.WHEN_EXHAUSTED_BLOCK);
  }
  cc=createConnectionConfig();
  userConnectionFactory=new PoolableUnboundConnectionFactory(cc);
  if (config.getUserPoolConfig().getMaxActive() != 0) {
    userPool=new UnboundLdapConnectionPool(userConnectionFactory);
    userPool.setTestOnBorrow(true);
    userPool.setMaxActive(config.getUserPoolConfig().getMaxActive());
    userPool.setWhenExhaustedAction(GenericObjectPool.WHEN_EXHAUSTED_BLOCK);
  }
  log.info(""String_Node_Str"",config);
}","/** 
 * Initializes the ldap identity provider.
 */
private void init(){
  if (adminConnectionFactory != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  LdapConnectionConfig cc=createConnectionConfig();
  String bindDN=config.getBindDN();
  if (bindDN != null && !bindDN.isEmpty()) {
    cc.setName(bindDN);
    cc.setCredentials(config.getBindPassword());
  }
  adminConnectionFactory=new PoolableLdapConnectionFactory(cc);
  if (config.getAdminPoolConfig().getMaxActive() != 0) {
    adminPool=new LdapConnectionPool(adminConnectionFactory);
    adminPool.setTestOnBorrow(true);
    adminPool.setMaxActive(config.getAdminPoolConfig().getMaxActive());
    adminPool.setWhenExhaustedAction(GenericObjectPool.WHEN_EXHAUSTED_BLOCK);
  }
  cc=createConnectionConfig();
  userConnectionFactory=new PoolableUnboundConnectionFactory(cc);
  if (config.getUserPoolConfig().getMaxActive() != 0) {
    userPool=new UnboundLdapConnectionPool(userConnectionFactory);
    userPool.setTestOnBorrow(true);
    userPool.setMaxActive(config.getUserPoolConfig().getMaxActive());
    userPool.setWhenExhaustedAction(GenericObjectPool.WHEN_EXHAUSTED_BLOCK);
  }
  log.info(""String_Node_Str"",config);
}",0.9612794612794612
8980,"@Deactivate private void deactivate(){
  close();
}","@SuppressWarnings(""String_Node_Str"") @Deactivate private void deactivate(){
  close();
}",0.7338129496402878
8981,"@Activate private void activate(Map<String,Object> properties){
  ConfigurationParameters cfg=ConfigurationParameters.of(properties);
  config=LdapProviderConfig.of(cfg);
  init();
}","@SuppressWarnings(""String_Node_Str"") @Activate private void activate(Map<String,Object> properties){
  ConfigurationParameters cfg=ConfigurationParameters.of(properties);
  config=LdapProviderConfig.of(cfg);
  init();
}",0.9077306733167082
8982,"private boolean isImmutableProperty(@Nonnull String name,@Nonnull Tree parent){
  NodeState parentNs=getNodeState(parent);
  if (JcrConstants.JCR_UUID.equals(name) && isReferenceable.apply(parentNs)) {
    return true;
  }
 else   if ((JCR_CREATED.equals(name) || JCR_CREATEDBY.equals(name)) && isCreated.apply(parentNs)) {
    return true;
  }
 else {
    return false;
  }
}","private boolean isImmutableProperty(@Nonnull String name,@Nonnull Tree parent){
  NodeState parentNs=getNodeState(parent);
  if (JcrConstants.JCR_UUID.equals(name) && isReferenceable.apply(parentNs)) {
    return true;
  }
 else {
    return (JCR_CREATED.equals(name) || JCR_CREATEDBY.equals(name)) && isCreated.apply(parentNs);
  }
}",0.904225352112676
8983,"@Override public boolean definesLocation(TreeLocation location){
  Tree tree=location.getTree();
  if (tree != null && location.exists()) {
    PropertyState p=location.getProperty();
    return (p == null) ? definesTree(tree) : definesProperty(tree,p);
  }
 else {
    String path=location.getPath();
    String name=Text.getName(path);
    if (USER_PROPERTY_NAMES.contains(name) || GROUP_PROPERTY_NAMES.contains(name) || path.contains(REP_MEMBERS)|| path.contains(REP_MEMBERS_LIST)|| path.contains(REP_PWD)) {
      return true;
    }
 else {
      return false;
    }
  }
}","@Override public boolean definesLocation(TreeLocation location){
  Tree tree=location.getTree();
  if (tree != null && location.exists()) {
    PropertyState p=location.getProperty();
    return (p == null) ? definesTree(tree) : definesProperty(tree,p);
  }
 else {
    String path=location.getPath();
    String name=Text.getName(path);
    return USER_PROPERTY_NAMES.contains(name) || GROUP_PROPERTY_NAMES.contains(name) || path.contains(REP_MEMBERS)|| path.contains(REP_MEMBERS_LIST)|| path.contains(REP_PWD);
  }
}",0.9341864716636198
8984,"/** 
 * Recursively updates references on the destination tree as defined by  {@code Workspace.copy()}.
 * @param src  the source tree of the copy operation.
 * @param dest the unprocessed copy of the tree.
 */
private void updateReferences(Tree src,Tree dest) throws RepositoryException {
  for (  PropertyState prop : src.getProperties()) {
    if (isReferenceType(prop) && !VersionConstants.VERSION_PROPERTY_NAMES.contains(prop.getName()))     updateProperty(prop,dest);
  }
  for (  Tree child : src.getChildren()) {
    updateReferences(child,dest.getChild(child.getName()));
  }
}","/** 
 * Recursively updates references on the destination tree as defined by  {@code Workspace.copy()}.
 * @param src  the source tree of the copy operation.
 * @param dest the unprocessed copy of the tree.
 */
private void updateReferences(Tree src,Tree dest) throws RepositoryException {
  for (  PropertyState prop : src.getProperties()) {
    if (isReferenceType(prop) && !VersionConstants.VERSION_PROPERTY_NAMES.contains(prop.getName())) {
      updateProperty(prop,dest);
    }
  }
  for (  Tree child : src.getChildren()) {
    updateReferences(child,dest.getChild(child.getName()));
  }
}",0.9915397631133672
8985,"@Override public boolean commit() throws LoginException {
  if (tokenCredentials != null) {
    updateSubject(tokenCredentials,getAuthInfo(tokenInfo),principals);
    return true;
  }
  if (tokenProvider != null && sharedState.containsKey(SHARED_KEY_CREDENTIALS)) {
    Credentials shared=getSharedCredentials();
    if (shared != null && tokenProvider.doCreateToken(shared)) {
      getRoot().refresh();
      TokenInfo ti=tokenProvider.createToken(shared);
      if (ti != null) {
        TokenCredentials tc=new TokenCredentials(ti.getToken());
        Map<String,String> attributes=ti.getPrivateAttributes();
        for (        String name : attributes.keySet()) {
          tc.setAttribute(name,attributes.get(name));
        }
        attributes=ti.getPublicAttributes();
        for (        String name : attributes.keySet()) {
          tc.setAttribute(name,attributes.get(name));
        }
        sharedState.put(SHARED_KEY_ATTRIBUTES,attributes);
        updateSubject(tc,null,null);
      }
 else {
        log.debug(""String_Node_Str"" + userId);
        throw new LoginException(""String_Node_Str"" + userId);
      }
    }
  }
  clearState();
  return false;
}","@Override public boolean commit() throws LoginException {
  if (tokenCredentials != null) {
    updateSubject(tokenCredentials,getAuthInfo(tokenInfo),principals);
    return true;
  }
  if (tokenProvider != null && sharedState.containsKey(SHARED_KEY_CREDENTIALS)) {
    Credentials shared=getSharedCredentials();
    if (shared != null && tokenProvider.doCreateToken(shared)) {
      Root r=getRoot();
      if (r != null) {
        r.refresh();
      }
      TokenInfo ti=tokenProvider.createToken(shared);
      if (ti != null) {
        TokenCredentials tc=new TokenCredentials(ti.getToken());
        Map<String,String> attributes=ti.getPrivateAttributes();
        for (        String name : attributes.keySet()) {
          tc.setAttribute(name,attributes.get(name));
        }
        attributes=ti.getPublicAttributes();
        for (        String name : attributes.keySet()) {
          tc.setAttribute(name,attributes.get(name));
        }
        sharedState.put(SHARED_KEY_ATTRIBUTES,attributes);
        updateSubject(tc,null,null);
      }
 else {
        log.debug(""String_Node_Str"" + userId);
        throw new LoginException(""String_Node_Str"" + userId);
      }
    }
  }
  clearState();
  return false;
}",0.9728827701293284
8986,"@CheckForNull private JackrabbitAccessControlList getACL(String path) throws RepositoryException {
  JackrabbitAccessControlList acl=null;
  for (  AccessControlPolicy p : acMgr.getPolicies(path)) {
    if (p instanceof JackrabbitAccessControlList) {
      acl=(JackrabbitAccessControlList)p;
      break;
    }
  }
  return acl;
}","@CheckForNull private JackrabbitAccessControlList getACL(String path) throws RepositoryException {
  JackrabbitAccessControlList acList=null;
  for (  AccessControlPolicy p : acMgr.getPolicies(path)) {
    if (p instanceof JackrabbitAccessControlList) {
      acList=(JackrabbitAccessControlList)p;
      break;
    }
  }
  return acList;
}",0.977645305514158
8987,"@CheckForNull public NodeUtil getParent(){
  return new NodeUtil(tree.getParent(),mapper);
}","@Nonnull public NodeUtil getParent(){
  return new NodeUtil(tree.getParent(),mapper);
}",0.9385474860335196
8988,"/** 
 * TODO: clean up. workaround for OAK-426 <p> Create the tree at the specified relative path including all missing intermediate trees using the specified   {@code primaryTypeName}. This method treats "".."" parent element and ""."" as current element and resolves them accordingly; in case of a relative path containing parent elements this may lead to tree creating outside the tree structure defined by this   {@code NodeUtil}.
 * @param relativePath    A relative OAK path that may contain parent andcurrent elements.
 * @param primaryTypeName A oak name of a primary node type that is usedto create the missing trees.
 * @return The node util of the tree at the specified {@code relativePath}.
 * @throws AccessDeniedException If the any intermediate tree does not existand cannot be created.
 */
@Nonnull public NodeUtil getOrAddTree(String relativePath,String primaryTypeName) throws AccessDeniedException {
  if (relativePath.indexOf('/') == -1) {
    return getOrAddChild(relativePath,primaryTypeName);
  }
 else {
    Tree t=TreeUtil.getTree(tree,relativePath);
    if (t == null || !t.exists()) {
      NodeUtil target=this;
      for (      String segment : Text.explode(relativePath,'/')) {
        if (PathUtils.denotesParent(segment)) {
          target=target.getParent();
        }
 else         if (target.hasChild(segment)) {
          target=target.getChild(segment);
        }
 else         if (!PathUtils.denotesCurrent(segment)) {
          target=target.addChild(segment,primaryTypeName);
        }
      }
      return target;
    }
 else {
      return new NodeUtil(t);
    }
  }
}","/** 
 * TODO: clean up. workaround for OAK-426 <p> Create the tree at the specified relative path including all missing intermediate trees using the specified   {@code primaryTypeName}. This method treats "".."" parent element and ""."" as current element and resolves them accordingly; in case of a relative path containing parent elements this may lead to tree creating outside the tree structure defined by this   {@code NodeUtil}.
 * @param relativePath    A relative OAK path that may contain parent andcurrent elements.
 * @param primaryTypeName A oak name of a primary node type that is usedto create the missing trees.
 * @return The node util of the tree at the specified {@code relativePath}.
 * @throws AccessDeniedException If the any intermediate tree does not existand cannot be created.
 */
@Nonnull public NodeUtil getOrAddTree(String relativePath,String primaryTypeName) throws AccessDeniedException {
  if (relativePath.indexOf('/') == -1) {
    return getOrAddChild(relativePath,primaryTypeName);
  }
 else {
    Tree t=TreeUtil.getTree(tree,relativePath);
    if (t == null || !t.exists()) {
      NodeUtil target=this;
      for (      String segment : Text.explode(relativePath,'/')) {
        if (PathUtils.denotesParent(segment)) {
          target=target.getParent();
        }
 else         if (target.hasChild(segment)) {
          target=target.getChild(segment);
        }
 else         if (!PathUtils.denotesCurrent(segment)) {
          target=target.addChild(segment,primaryTypeName);
        }
      }
      if (target == null) {
        throw new AccessDeniedException();
      }
      return target;
    }
 else {
      return new NodeUtil(t);
    }
  }
}",0.9681141815973276
8989,"/** 
 * Returns an iterator over all member paths of the given group.
 * @param groupTree the group tree
 * @param authorizableType type of authorizables to filter.
 * @param includeInherited {@code true} to include inherited members
 * @param processedRefs helper set that contains the references that are already processed.
 * @return an iterator over all member paths
 */
@Nonnull private Iterator<String> getMembers(@Nonnull final Tree groupTree,@Nonnull final AuthorizableType authorizableType,final boolean includeInherited,@Nonnull final Set<String> processedRefs){
  return new AbstractLazyIterator<String>(){
    private MemberReferenceIterator references=new MemberReferenceIterator(groupTree,processedRefs);
    private Iterator<String> parent;
    @Override protected String getNext(){
      String next=null;
      while (next == null) {
        if (parent != null) {
          if (parent.hasNext()) {
            next=parent.next();
          }
 else {
            parent=null;
          }
        }
 else         if (!references.hasNext()) {
          break;
        }
 else {
          String value=references.next();
          next=identifierManager.getPath(PropertyValues.newWeakReference(value));
          if (next != null && (includeInherited || authorizableType != AuthorizableType.AUTHORIZABLE)) {
            Tree auth=getByPath(next);
            AuthorizableType type=UserUtil.getType(auth);
            if (includeInherited && type == AuthorizableType.GROUP) {
              parent=getMembers(auth,authorizableType,true,processedRefs);
            }
            if (authorizableType != AuthorizableType.AUTHORIZABLE && type != authorizableType) {
              next=null;
            }
          }
        }
      }
      return next;
    }
  }
;
}","/** 
 * Returns an iterator over all member paths of the given group.
 * @param groupTree the group tree
 * @param authorizableType type of authorizables to filter.
 * @param includeInherited {@code true} to include inherited members
 * @param processedRefs helper set that contains the references that are already processed.
 * @return an iterator over all member paths
 */
@Nonnull private Iterator<String> getMembers(@Nonnull final Tree groupTree,@Nonnull final AuthorizableType authorizableType,final boolean includeInherited,@Nonnull final Set<String> processedRefs){
  return new AbstractLazyIterator<String>(){
    private MemberReferenceIterator references=new MemberReferenceIterator(groupTree,processedRefs);
    private Iterator<String> parent;
    @Override protected String getNext(){
      String next=null;
      while (next == null) {
        if (parent != null) {
          if (parent.hasNext()) {
            next=parent.next();
          }
 else {
            parent=null;
          }
        }
 else         if (!references.hasNext()) {
          break;
        }
 else {
          String value=references.next();
          next=identifierManager.getPath(PropertyValues.newWeakReference(value));
          if (next != null && (includeInherited || authorizableType != AuthorizableType.AUTHORIZABLE)) {
            Tree auth=getByPath(next);
            AuthorizableType type=(auth == null) ? null : UserUtil.getType(auth);
            if (includeInherited && type == AuthorizableType.GROUP) {
              parent=getMembers(auth,authorizableType,true,processedRefs);
            }
            if (authorizableType != AuthorizableType.AUTHORIZABLE && type != authorizableType) {
              next=null;
            }
          }
        }
      }
      return next;
    }
  }
;
}",0.9932848349188584
8990,"private void validateAuthorizable(@Nonnull Tree tree,@Nonnull AuthorizableType type) throws CommitFailedException {
  boolean isSystemUser=(type == AuthorizableType.USER) && UserUtil.isSystemUser(tree);
  String authRoot=UserUtil.getAuthorizableRootPath(provider.getConfig(),type);
  if (isSystemUser) {
    String sysRelPath=provider.getConfig().getConfigValue(PARAM_SYSTEM_RELATIVE_PATH,DEFAULT_SYSTEM_RELATIVE_PATH);
    authRoot=authRoot + '/' + sysRelPath;
  }
  if (authRoot != null) {
    assertHierarchy(tree,authRoot);
    if (TreeUtil.getString(tree,REP_PRINCIPAL_NAME) == null) {
      throw constraintViolation(26,""String_Node_Str"");
    }
    if (isSystemUser) {
      if (TreeUtil.getString(tree,REP_PASSWORD) != null) {
        throw constraintViolation(32,""String_Node_Str"");
      }
      if (tree.hasChild(REP_PWD)) {
        throw constraintViolation(33,""String_Node_Str"");
      }
    }
  }
}","private void validateAuthorizable(@Nonnull Tree tree,@Nullable AuthorizableType type) throws CommitFailedException {
  boolean isSystemUser=(type == AuthorizableType.USER) && UserUtil.isSystemUser(tree);
  String authRoot=UserUtil.getAuthorizableRootPath(provider.getConfig(),type);
  if (isSystemUser) {
    String sysRelPath=provider.getConfig().getConfigValue(PARAM_SYSTEM_RELATIVE_PATH,DEFAULT_SYSTEM_RELATIVE_PATH);
    authRoot=authRoot + '/' + sysRelPath;
  }
  if (authRoot != null) {
    assertHierarchy(tree,authRoot);
    if (TreeUtil.getString(tree,REP_PRINCIPAL_NAME) == null) {
      throw constraintViolation(26,""String_Node_Str"");
    }
    if (isSystemUser) {
      if (TreeUtil.getString(tree,REP_PASSWORD) != null) {
        throw constraintViolation(32,""String_Node_Str"");
      }
      if (tree.hasChild(REP_PWD)) {
        throw constraintViolation(33,""String_Node_Str"");
      }
    }
  }
}",0.9928767123287672
8991,"@Nonnull private static Object readValueFromJson(@Nonnull JsopTokenizer json){
switch (json.read()) {
case JsopReader.NULL:
    return null;
case JsopReader.TRUE:
  return true;
case JsopReader.FALSE:
return false;
case JsopReader.NUMBER:
return Long.parseLong(json.getToken());
case JsopReader.STRING:
return json.getToken();
case '{':
TreeMap<Revision,Object> map=new TreeMap<Revision,Object>(StableRevisionComparator.REVERSE);
while (true) {
if (json.matches('}')) {
break;
}
String k=json.readString();
json.read(':');
map.put(Revision.fromString(k),readValueFromJson(json));
json.matches(',');
}
return map;
case '[':
List<Object> list=new ArrayList<Object>();
while (true) {
if (json.matches(']')) {
break;
}
list.add(readValueFromJson(json));
json.matches(',');
}
return list;
default :
throw new IllegalArgumentException(json.readRawValue());
}
}","@Nullable private static Object readValueFromJson(@Nonnull JsopTokenizer json){
switch (json.read()) {
case JsopReader.NULL:
    return null;
case JsopReader.TRUE:
  return true;
case JsopReader.FALSE:
return false;
case JsopReader.NUMBER:
return Long.parseLong(json.getToken());
case JsopReader.STRING:
return json.getToken();
case '{':
TreeMap<Revision,Object> map=new TreeMap<Revision,Object>(StableRevisionComparator.REVERSE);
while (true) {
if (json.matches('}')) {
break;
}
String k=json.readString();
if (k == null) {
throw new IllegalArgumentException(""String_Node_Str"");
}
json.read(':');
map.put(Revision.fromString(k),readValueFromJson(json));
json.matches(',');
}
return map;
case '[':
List<Object> list=new ArrayList<Object>();
while (true) {
if (json.matches(']')) {
break;
}
list.add(readValueFromJson(json));
json.matches(',');
}
return list;
default :
throw new IllegalArgumentException(json.readRawValue());
}
}",0.9512058328659564
8992,"/** 
 * Reconstructs a   {@link} Document) based on the persisted {@link DBRow}.
 */
public <T extends Document>T fromRow(@Nonnull Collection<T> collection,@Nonnull RDBRow row) throws DocumentStoreException {
  T doc=collection.newDocument(store);
  doc.put(ID,row.getId());
  doc.put(MODIFIED,row.getModified());
  doc.put(MODCOUNT,row.getModcount());
  if (RDBDocumentStore.USECMODCOUNT) {
    doc.put(CMODCOUNT,row.getCollisionsModcount());
  }
  if (row.hasBinaryProperties()) {
    doc.put(HASBINARY,NodeDocument.HAS_BINARY_VAL);
  }
  if (row.deletedOnce()) {
    doc.put(DELETEDONCE,Boolean.TRUE);
  }
  byte[] bdata=row.getBdata();
  boolean blobInUse=false;
  JsopTokenizer json;
  try {
    if (bdata != null && bdata.length != 0) {
      String s=fromBlobData(bdata);
      json=new JsopTokenizer(s);
      json.read('{');
      readDocumentFromJson(json,doc);
      json.read(JsopReader.END);
      blobInUse=true;
    }
  }
 catch (  Exception ex) {
    throw new DocumentStoreException(ex);
  }
  try {
    json=new JsopTokenizer(row.getData());
    int next=json.read();
    if (next == '{') {
      if (blobInUse) {
        throw new DocumentStoreException(""String_Node_Str"" + row.getData());
      }
      readDocumentFromJson(json,doc);
    }
 else     if (next == JsopReader.STRING) {
      if (!blobInUse) {
        throw new DocumentStoreException(""String_Node_Str"" + row.getData());
      }
      if (!json.getToken().equals(""String_Node_Str"")) {
        throw new DocumentStoreException(""String_Node_Str"");
      }
    }
 else {
      throw new DocumentStoreException(""String_Node_Str"" + next + ""String_Node_Str""+ row.getData());
    }
    next=json.read();
    if (next == ',') {
      do {
        Object ob=readValueFromJson(json);
        if (!(ob instanceof List)) {
          throw new DocumentStoreException(""String_Node_Str"" + ob);
        }
        List<List<Object>> update=(List<List<Object>>)ob;
        for (        List<Object> op : update) {
          applyUpdate(doc,update,op);
        }
      }
 while (json.matches(','));
    }
    json.read(JsopReader.END);
    return doc;
  }
 catch (  Exception ex) {
    throw new DocumentStoreException(ex);
  }
}","/** 
 * Reconstructs a   {@link} Document) based on the persisted {@link DBRow}.
 */
public <T extends Document>T fromRow(@Nonnull Collection<T> collection,@Nonnull RDBRow row) throws DocumentStoreException {
  T doc=collection.newDocument(store);
  doc.put(ID,row.getId());
  doc.put(MODIFIED,row.getModified());
  doc.put(MODCOUNT,row.getModcount());
  if (RDBDocumentStore.USECMODCOUNT) {
    doc.put(CMODCOUNT,row.getCollisionsModcount());
  }
  if (row.hasBinaryProperties()) {
    doc.put(HASBINARY,NodeDocument.HAS_BINARY_VAL);
  }
  if (row.deletedOnce()) {
    doc.put(DELETEDONCE,Boolean.TRUE);
  }
  byte[] bdata=row.getBdata();
  boolean blobInUse=false;
  JsopTokenizer json;
  try {
    if (bdata != null && bdata.length != 0) {
      String s=fromBlobData(bdata);
      json=new JsopTokenizer(s);
      json.read('{');
      readDocumentFromJson(json,doc);
      json.read(JsopReader.END);
      blobInUse=true;
    }
  }
 catch (  Exception ex) {
    throw new DocumentStoreException(ex);
  }
  try {
    json=new JsopTokenizer(row.getData());
    int next=json.read();
    if (next == '{') {
      if (blobInUse) {
        throw new DocumentStoreException(""String_Node_Str"" + row.getData());
      }
      readDocumentFromJson(json,doc);
    }
 else     if (next == JsopReader.STRING) {
      if (!blobInUse) {
        throw new DocumentStoreException(""String_Node_Str"" + row.getData());
      }
      if (!""String_Node_Str"".equals(json.getToken())) {
        throw new DocumentStoreException(""String_Node_Str"");
      }
    }
 else {
      throw new DocumentStoreException(""String_Node_Str"" + next + ""String_Node_Str""+ row.getData());
    }
    next=json.read();
    if (next == ',') {
      do {
        Object ob=readValueFromJson(json);
        if (!(ob instanceof List)) {
          throw new DocumentStoreException(""String_Node_Str"" + ob);
        }
        List<List<Object>> update=(List<List<Object>>)ob;
        for (        List<Object> op : update) {
          applyUpdate(doc,update,op);
        }
      }
 while (json.matches(','));
    }
    json.read(JsopReader.END);
    return doc;
  }
 catch (  Exception ex) {
    throw new DocumentStoreException(ex);
  }
}",0.9895168641750228
8993,"/** 
 * Serializes the changes in the   {@link UpdateOp} into a JSON array; eachentry is another JSON array holding operation, key, revision, and value.
 */
public String asString(UpdateOp update){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  boolean needComma=false;
  for (  Map.Entry<Key,Operation> change : update.getChanges().entrySet()) {
    Operation op=change.getValue();
    Key key=change.getKey();
    if (columnProperties.contains(key.getName()) && null == key.getRevision())     continue;
    if (op.type == UpdateOp.Operation.Type.CONTAINS_MAP_ENTRY)     continue;
    if (needComma) {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    if (op.type == UpdateOp.Operation.Type.INCREMENT) {
      sb.append(""String_Node_Str"");
    }
 else     if (op.type == UpdateOp.Operation.Type.SET || op.type == UpdateOp.Operation.Type.SET_MAP_ENTRY) {
      sb.append(""String_Node_Str"");
    }
 else     if (op.type == UpdateOp.Operation.Type.MAX) {
      sb.append(""String_Node_Str"");
    }
 else     if (op.type == UpdateOp.Operation.Type.REMOVE_MAP_ENTRY) {
      sb.append(""String_Node_Str"");
    }
 else {
      throw new DocumentStoreException(""String_Node_Str"" + update.toString() + ""String_Node_Str"");
    }
    appendString(sb,key.getName());
    sb.append(""String_Node_Str"");
    if (key.getRevision() != null) {
      appendString(sb,key.getRevision().toString());
      sb.append(""String_Node_Str"");
    }
    appendValue(sb,op.value);
    sb.append(""String_Node_Str"");
    needComma=true;
  }
  return sb.append(""String_Node_Str"").toString();
}","/** 
 * Serializes the changes in the   {@link UpdateOp} into a JSON array; eachentry is another JSON array holding operation, key, revision, and value.
 */
public String asString(UpdateOp update){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  boolean needComma=false;
  for (  Map.Entry<Key,Operation> change : update.getChanges().entrySet()) {
    Operation op=change.getValue();
    Key key=change.getKey();
    if (columnProperties.contains(key.getName()) && null == key.getRevision())     continue;
    if (op.type == UpdateOp.Operation.Type.CONTAINS_MAP_ENTRY)     continue;
    if (needComma) {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    if (op.type == UpdateOp.Operation.Type.INCREMENT) {
      sb.append(""String_Node_Str"");
    }
 else     if (op.type == UpdateOp.Operation.Type.SET || op.type == UpdateOp.Operation.Type.SET_MAP_ENTRY) {
      sb.append(""String_Node_Str"");
    }
 else     if (op.type == UpdateOp.Operation.Type.MAX) {
      sb.append(""String_Node_Str"");
    }
 else     if (op.type == UpdateOp.Operation.Type.REMOVE_MAP_ENTRY) {
      sb.append(""String_Node_Str"");
    }
 else {
      throw new DocumentStoreException(""String_Node_Str"" + update.toString() + ""String_Node_Str"");
    }
    appendString(sb,key.getName());
    sb.append(""String_Node_Str"");
    Revision rev=key.getRevision();
    if (rev != null) {
      appendString(sb,rev.toString());
      sb.append(""String_Node_Str"");
    }
    appendValue(sb,op.value);
    sb.append(""String_Node_Str"");
    needComma=true;
  }
  return sb.append(""String_Node_Str"").toString();
}",0.978829389788294
8994,"@CheckForNull private <T extends Document>void internalUpdate(Collection<T> collection,List<String> ids,UpdateOp update){
  if (isAppendableUpdate(update) && !requiresPreviousState(update)) {
    long modified=getModifiedFromUpdate(update);
    String appendData=SR.asString(update);
    for (    List<String> chunkedIds : Lists.partition(ids,CHUNKSIZE)) {
      Map<String,NodeDocument> cachedDocs=Collections.emptyMap();
      if (collection == Collection.NODES) {
        cachedDocs=new HashMap<String,NodeDocument>();
        for (        String key : chunkedIds) {
          cachedDocs.put(key,nodesCache.getIfPresent(new StringValue(key)));
        }
      }
      Connection connection=null;
      String tableName=getTable(collection);
      boolean success=false;
      try {
        connection=this.ch.getRWConnection();
        success=dbBatchedAppendingUpdate(connection,tableName,chunkedIds,modified,appendData);
        connection.commit();
      }
 catch (      SQLException ex) {
        success=false;
        this.ch.rollbackConnection(connection);
      }
 finally {
        this.ch.closeConnection(connection);
      }
      if (success) {
        for (        Entry<String,NodeDocument> entry : cachedDocs.entrySet()) {
          if (entry.getValue() == null) {
            nodesCache.invalidate(new StringValue(entry.getKey()));
          }
 else {
            T oldDoc=(T)(entry.getValue());
            T newDoc=applyChanges(collection,(T)(entry.getValue()),update,true);
            applyToCache((NodeDocument)oldDoc,(NodeDocument)newDoc);
          }
        }
      }
 else {
        for (        String id : chunkedIds) {
          UpdateOp up=update.copy();
          up=up.shallowCopy(id);
          internalCreateOrUpdate(collection,up,false,true);
        }
      }
    }
  }
 else {
    for (    String id : ids) {
      UpdateOp up=update.copy();
      up=up.shallowCopy(id);
      internalCreateOrUpdate(collection,up,false,true);
    }
  }
}","@CheckForNull private <T extends Document>void internalUpdate(Collection<T> collection,List<String> ids,UpdateOp update){
  if (isAppendableUpdate(update) && !requiresPreviousState(update)) {
    long modified=getModifiedFromUpdate(update);
    String appendData=SR.asString(update);
    for (    List<String> chunkedIds : Lists.partition(ids,CHUNKSIZE)) {
      Map<String,NodeDocument> cachedDocs=Collections.emptyMap();
      if (collection == Collection.NODES) {
        cachedDocs=new HashMap<String,NodeDocument>();
        for (        String key : chunkedIds) {
          cachedDocs.put(key,nodesCache.getIfPresent(new StringValue(key)));
        }
      }
      Connection connection=null;
      String tableName=getTable(collection);
      boolean success=false;
      try {
        connection=this.ch.getRWConnection();
        success=dbBatchedAppendingUpdate(connection,tableName,chunkedIds,modified,appendData);
        connection.commit();
      }
 catch (      SQLException ex) {
        success=false;
        this.ch.rollbackConnection(connection);
      }
 finally {
        this.ch.closeConnection(connection);
      }
      if (success) {
        for (        Entry<String,NodeDocument> entry : cachedDocs.entrySet()) {
          T oldDoc=(T)(entry.getValue());
          if (oldDoc == null) {
            nodesCache.invalidate(new StringValue(entry.getKey()));
          }
 else {
            T newDoc=applyChanges(collection,oldDoc,update,true);
            if (newDoc != null) {
              applyToCache((NodeDocument)oldDoc,(NodeDocument)newDoc);
            }
          }
        }
      }
 else {
        for (        String id : chunkedIds) {
          UpdateOp up=update.copy();
          up=up.shallowCopy(id);
          internalCreateOrUpdate(collection,up,false,true);
        }
      }
    }
  }
 else {
    for (    String id : ids) {
      UpdateOp up=update.copy();
      up=up.shallowCopy(id);
      internalCreateOrUpdate(collection,up,false,true);
    }
  }
}",0.9600201156650742
8995,"private <T extends Document>void addToCache(Collection<T> collection,T doc){
  if (collection == Collection.NODES) {
    Lock lock=getAndLock(doc.getId());
    try {
      addToCache((NodeDocument)doc);
    }
  finally {
      lock.unlock();
    }
  }
}","private <T extends Document>void addToCache(Collection<T> collection,T doc){
  if (collection == Collection.NODES) {
    Lock lock=getAndLock(idOf(doc));
    try {
      addToCache((NodeDocument)doc);
    }
  finally {
      lock.unlock();
    }
  }
}",0.9642857142857144
8996,"@CheckForNull private <T extends Document>T readDocumentUncached(Collection<T> collection,String id,NodeDocument cachedDoc){
  Connection connection=null;
  String tableName=getTable(collection);
  try {
    long lastmodcount=-1;
    if (cachedDoc != null && cachedDoc.getModCount() != null) {
      lastmodcount=cachedDoc.getModCount().longValue();
    }
    connection=this.ch.getROConnection();
    RDBRow row=dbRead(connection,tableName,id,lastmodcount);
    connection.commit();
    if (row == null) {
      return null;
    }
 else {
      if (lastmodcount == row.getModcount()) {
        cachedDoc.markUpToDate(System.currentTimeMillis());
        return (T)cachedDoc;
      }
 else {
        return SR.fromRow(collection,row);
      }
    }
  }
 catch (  Exception ex) {
    throw new DocumentStoreException(ex);
  }
 finally {
    this.ch.closeConnection(connection);
  }
}","@CheckForNull private <T extends Document>T readDocumentUncached(Collection<T> collection,String id,NodeDocument cachedDoc){
  Connection connection=null;
  String tableName=getTable(collection);
  try {
    long lastmodcount=-1;
    if (cachedDoc != null) {
      lastmodcount=modcountOf(cachedDoc);
    }
    connection=this.ch.getROConnection();
    RDBRow row=dbRead(connection,tableName,id,lastmodcount);
    connection.commit();
    if (row == null) {
      return null;
    }
 else {
      if (lastmodcount == row.getModcount()) {
        cachedDoc.markUpToDate(System.currentTimeMillis());
        return (T)cachedDoc;
      }
 else {
        return SR.fromRow(collection,row);
      }
    }
  }
 catch (  Exception ex) {
    throw new DocumentStoreException(ex);
  }
 finally {
    this.ch.closeConnection(connection);
  }
}",0.9481049562682216
8997,"@Nonnull private void applyToCache(@Nonnull final NodeDocument oldDoc,@Nonnull final NodeDocument newDoc){
  NodeDocument cached=addToCache(newDoc);
  if (cached == newDoc) {
    return;
  }
 else   if (oldDoc == null) {
    return;
  }
 else {
    CacheValue key=new StringValue(newDoc.getId());
    if (Objects.equal(cached.getModCount(),oldDoc.getModCount())) {
      nodesCache.put(key,newDoc);
    }
 else {
      nodesCache.invalidate(key);
    }
  }
}","@Nonnull private void applyToCache(@Nonnull final NodeDocument oldDoc,@Nonnull final NodeDocument newDoc){
  NodeDocument cached=addToCache(newDoc);
  if (cached == newDoc) {
    return;
  }
 else   if (oldDoc == null) {
    return;
  }
 else {
    CacheValue key=new StringValue(idOf(newDoc));
    if (Objects.equal(cached.getModCount(),oldDoc.getModCount())) {
      nodesCache.put(key,newDoc);
    }
 else {
      nodesCache.invalidate(key);
    }
  }
}",0.973741794310722
8998,"private List<RDBRow> dbQuery(Connection connection,String tableName,String minId,String maxId,String indexedProperty,long startValue,int limit) throws SQLException {
  String t=""String_Node_Str"" + tableName + ""String_Node_Str"";
  if (indexedProperty != null) {
    if (MODIFIED.equals(indexedProperty)) {
      t+=""String_Node_Str"";
    }
 else     if (NodeDocument.HAS_BINARY_FLAG.equals(indexedProperty)) {
      if (startValue != NodeDocument.HAS_BINARY_VAL) {
        throw new DocumentStoreException(""String_Node_Str"" + NodeDocument.HAS_BINARY_FLAG);
      }
      t+=""String_Node_Str"";
    }
  }
  t+=""String_Node_Str"";
  if (limit != Integer.MAX_VALUE) {
    t+=this.needsConcat ? (""String_Node_Str"" + limit) : (""String_Node_Str"" + limit + ""String_Node_Str"");
  }
  PreparedStatement stmt=connection.prepareStatement(t);
  List<RDBRow> result=new ArrayList<RDBRow>();
  try {
    int si=1;
    stmt.setString(si++,minId);
    stmt.setString(si++,maxId);
    if (MODIFIED.equals(indexedProperty)) {
      stmt.setLong(si++,startValue);
    }
    if (limit != Integer.MAX_VALUE) {
      stmt.setFetchSize(limit);
    }
    ResultSet rs=stmt.executeQuery();
    while (rs.next() && result.size() < limit) {
      String id=rs.getString(1);
      if (id.compareTo(minId) < 0 || id.compareTo(maxId) > 0) {
        throw new DocumentStoreException(""String_Node_Str"" + minId + ""String_Node_Str""+ id+ ""String_Node_Str""+ maxId+ ""String_Node_Str"");
      }
      long modified=rs.getLong(2);
      long modcount=rs.getLong(3);
      String data=rs.getString(4);
      byte[] bdata=rs.getBytes(5);
      result.add(new RDBRow(id,modified,modcount,data,bdata));
    }
  }
  finally {
    stmt.close();
  }
  return result;
}","private List<RDBRow> dbQuery(Connection connection,String tableName,String minId,String maxId,String indexedProperty,long startValue,int limit) throws SQLException {
  String t=""String_Node_Str"" + tableName + ""String_Node_Str"";
  if (indexedProperty != null) {
    if (MODIFIED.equals(indexedProperty)) {
      t+=""String_Node_Str"";
    }
 else     if (NodeDocument.HAS_BINARY_FLAG.equals(indexedProperty)) {
      if (startValue != NodeDocument.HAS_BINARY_VAL) {
        throw new DocumentStoreException(""String_Node_Str"" + NodeDocument.HAS_BINARY_FLAG);
      }
      t+=""String_Node_Str"";
    }
  }
  t+=""String_Node_Str"";
  if (limit != Integer.MAX_VALUE) {
    t+=this.needsLimit ? (""String_Node_Str"" + limit) : (""String_Node_Str"" + limit + ""String_Node_Str"");
  }
  PreparedStatement stmt=connection.prepareStatement(t);
  List<RDBRow> result=new ArrayList<RDBRow>();
  try {
    int si=1;
    stmt.setString(si++,minId);
    stmt.setString(si++,maxId);
    if (MODIFIED.equals(indexedProperty)) {
      stmt.setLong(si++,startValue);
    }
    if (limit != Integer.MAX_VALUE) {
      stmt.setFetchSize(limit);
    }
    ResultSet rs=stmt.executeQuery();
    while (rs.next() && result.size() < limit) {
      String id=rs.getString(1);
      if (id.compareTo(minId) < 0 || id.compareTo(maxId) > 0) {
        throw new DocumentStoreException(""String_Node_Str"" + minId + ""String_Node_Str""+ id+ ""String_Node_Str""+ maxId+ ""String_Node_Str"");
      }
      long modified=rs.getLong(2);
      long modcount=rs.getLong(3);
      String data=rs.getString(4);
      byte[] bdata=rs.getBytes(5);
      result.add(new RDBRow(id,modified,modcount,data,bdata));
    }
  }
  finally {
    stmt.close();
  }
  return result;
}",0.9973814372999708
8999,"@Override public Iterator<ResultRowImpl> getRows(){
  prepare();
  if (explain) {
    String plan=getPlan();
    columns=new ColumnImpl[]{new ColumnImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")};
    ResultRowImpl r=new ResultRowImpl(this,Tree.EMPTY_ARRAY,new PropertyValue[]{PropertyValues.newString(plan)},null);
    return Arrays.asList(r).iterator();
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",statement);
    LOG.debug(""String_Node_Str"",getPlan());
  }
  RowIterator rowIt=new RowIterator(context.getBaseState());
  Comparator<ResultRowImpl> orderBy;
  boolean sortUsingIndex=false;
  if (selectors.size() == 1) {
    IndexPlan plan=selectors.get(0).getExecutionPlan().getIndexPlan();
    if (plan != null) {
      List<OrderEntry> list=plan.getSortOrder();
      if (list != null && list.size() == orderings.length) {
        sortUsingIndex=true;
        for (int i=0; i < list.size(); i++) {
          OrderEntry e=list.get(i);
          OrderingImpl o=orderings[i];
          DynamicOperandImpl op=o.getOperand();
          if (!(op instanceof PropertyValueImpl)) {
            sortUsingIndex=false;
            break;
          }
          String pn=((PropertyValueImpl)op).getPropertyName();
          if (!pn.equals(e.getPropertyName())) {
            sortUsingIndex=false;
            break;
          }
          if (o.isDescending() != (e.getOrder() == Order.DESCENDING)) {
            sortUsingIndex=false;
            break;
          }
        }
      }
    }
  }
  if (sortUsingIndex) {
    orderBy=null;
  }
 else {
    orderBy=ResultRowImpl.getComparator(orderings);
  }
  Iterator<ResultRowImpl> it=FilterIterators.newCombinedFilter(rowIt,distinct,limit,offset,orderBy);
  if (measure) {
    while (it.hasNext()) {
      it.next();
    }
    columns=new ColumnImpl[]{new ColumnImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new ColumnImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")};
    ArrayList<ResultRowImpl> list=new ArrayList<ResultRowImpl>();
    ResultRowImpl r=new ResultRowImpl(this,Tree.EMPTY_ARRAY,new PropertyValue[]{PropertyValues.newString(""String_Node_Str""),PropertyValues.newLong(rowIt.getReadCount())},null);
    list.add(r);
    for (    SelectorImpl selector : selectors) {
      r=new ResultRowImpl(this,Tree.EMPTY_ARRAY,new PropertyValue[]{PropertyValues.newString(selector.getSelectorName()),PropertyValues.newLong(selector.getScanCount())},null);
      list.add(r);
    }
    it=list.iterator();
  }
  return it;
}","@Override public Iterator<ResultRowImpl> getRows(){
  prepare();
  if (explain) {
    String plan=getPlan();
    columns=new ColumnImpl[]{new ColumnImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")};
    ResultRowImpl r=new ResultRowImpl(this,Tree.EMPTY_ARRAY,new PropertyValue[]{PropertyValues.newString(plan)},null);
    return Arrays.asList(r).iterator();
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",statement);
    LOG.debug(""String_Node_Str"",getPlan());
  }
  RowIterator rowIt=new RowIterator(context.getBaseState());
  Comparator<ResultRowImpl> orderBy;
  boolean sortUsingIndex=false;
  if (orderings != null && selectors.size() == 1) {
    IndexPlan plan=selectors.get(0).getExecutionPlan().getIndexPlan();
    if (plan != null) {
      List<OrderEntry> list=plan.getSortOrder();
      if (list != null && list.size() == orderings.length) {
        sortUsingIndex=true;
        for (int i=0; i < list.size(); i++) {
          OrderEntry e=list.get(i);
          OrderingImpl o=orderings[i];
          DynamicOperandImpl op=o.getOperand();
          if (!(op instanceof PropertyValueImpl)) {
            sortUsingIndex=false;
            break;
          }
          String pn=((PropertyValueImpl)op).getPropertyName();
          if (!pn.equals(e.getPropertyName())) {
            sortUsingIndex=false;
            break;
          }
          if (o.isDescending() != (e.getOrder() == Order.DESCENDING)) {
            sortUsingIndex=false;
            break;
          }
        }
      }
    }
  }
  if (sortUsingIndex) {
    orderBy=null;
  }
 else {
    orderBy=ResultRowImpl.getComparator(orderings);
  }
  Iterator<ResultRowImpl> it=FilterIterators.newCombinedFilter(rowIt,distinct,limit,offset,orderBy);
  if (measure) {
    while (it.hasNext()) {
      it.next();
    }
    columns=new ColumnImpl[]{new ColumnImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new ColumnImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")};
    ArrayList<ResultRowImpl> list=new ArrayList<ResultRowImpl>();
    ResultRowImpl r=new ResultRowImpl(this,Tree.EMPTY_ARRAY,new PropertyValue[]{PropertyValues.newString(""String_Node_Str""),PropertyValues.newLong(rowIt.getReadCount())},null);
    list.add(r);
    for (    SelectorImpl selector : selectors) {
      r=new ResultRowImpl(this,Tree.EMPTY_ARRAY,new PropertyValue[]{PropertyValues.newString(selector.getSelectorName()),PropertyValues.newLong(selector.getScanCount())},null);
      list.add(r);
    }
    it=list.iterator();
  }
  return it;
}",0.9958522615050366
9000,"@Test @Ignore(""String_Node_Str"") public void testAddNodeCollidingWithInvisibleNode() throws Exception {
  setupPermission(""String_Node_Str"",testPrincipal,true,PrivilegeConstants.JCR_ALL);
  setupPermission(""String_Node_Str"",testPrincipal,false,PrivilegeConstants.JCR_READ);
  setupPermission(""String_Node_Str"",testPrincipal,true,PrivilegeConstants.JCR_ALL);
  Root testRoot=getTestRoot();
  Tree a=testRoot.getTree(""String_Node_Str"");
  assertFalse(a.getChild(""String_Node_Str"").exists());
  assertTrue(a.getChild(""String_Node_Str"").getChild(""String_Node_Str"").exists());
  new NodeUtil(a).addChild(""String_Node_Str"",JcrConstants.NT_UNSTRUCTURED);
  assertTrue(a.getChild(""String_Node_Str"").exists());
  assertFalse(a.getChild(""String_Node_Str"").getChild(""String_Node_Str"").exists());
  testRoot.commit();
  assertTrue(a.getChild(""String_Node_Str"").exists());
  assertFalse(a.getChild(""String_Node_Str"").getChild(""String_Node_Str"").exists());
}","public void testAddNodeCollidingWithInvisibleNode() throws Exception {
  setupPermission(""String_Node_Str"",testPrincipal,true,PrivilegeConstants.JCR_ALL);
  setupPermission(""String_Node_Str"",testPrincipal,false,PrivilegeConstants.JCR_READ);
  setupPermission(""String_Node_Str"",testPrincipal,true,PrivilegeConstants.JCR_ALL);
  Root testRoot=getTestRoot();
  Tree a=testRoot.getTree(""String_Node_Str"");
  assertFalse(a.getChild(""String_Node_Str"").exists());
  assertTrue(a.getChild(""String_Node_Str"").getChild(""String_Node_Str"").exists());
  new NodeUtil(a).addChild(""String_Node_Str"",JcrConstants.NT_UNSTRUCTURED);
  assertTrue(a.getChild(""String_Node_Str"").exists());
  assertFalse(a.getChild(""String_Node_Str"").getChild(""String_Node_Str"").exists());
  testRoot.commit();
  assertTrue(a.getChild(""String_Node_Str"").exists());
  assertFalse(a.getChild(""String_Node_Str"").getChild(""String_Node_Str"").exists());
}",0.982210242587601
